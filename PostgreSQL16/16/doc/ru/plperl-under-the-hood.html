<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>45.8. Внутренние особенности PL/Perl</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="plperl-event-triggers.html" title="45.7. Событийные триггеры на PL/Perl" /><link rel="next" href="plpython.html" title="Глава 46. PL/Python — процедурный язык Python" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">45.8. Внутренние особенности PL/Perl</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="plperl-event-triggers.html" title="45.7. Событийные триггеры на PL/Perl">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="plperl.html" title="Глава 45. PL/Perl — процедурный язык Perl">Наверх</a></td><th width="60%" align="center">Глава 45. PL/Perl — процедурный язык Perl</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="plpython.html" title="Глава 46. PL/Python — процедурный язык Python">След.</a></td></tr></table><hr /></div><div class="sect1" id="PLPERL-UNDER-THE-HOOD"><div class="titlepage"><div><div><h2 class="title" style="clear: both">45.8. Внутренние особенности PL/Perl <a href="#PLPERL-UNDER-THE-HOOD" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="plperl-under-the-hood.html#PLPERL-CONFIG">45.8.1. Конфигурирование</a></span></dt><dt><span class="sect2"><a href="plperl-under-the-hood.html#PLPERL-MISSING">45.8.2. Ограничения и недостающие возможности</a></span></dt></dl></div><div class="sect2" id="PLPERL-CONFIG"><div class="titlepage"><div><div><h3 class="title">45.8.1. Конфигурирование <a href="#PLPERL-CONFIG" class="id_link">#</a></h3></div></div></div><p>В этом разделе описываются параметры конфигурации, влияющие на работу <span class="application">PL/Perl</span>.</p><div class="variablelist"><dl class="variablelist"><dt id="GUC-PLPERL-ON-INIT"><span class="term"><code class="varname">plperl.on_init</code> (<code class="type">string</code>) <a id="id-1.8.10.16.2.3.1.1.3" class="indexterm"></a></span> <a href="#GUC-PLPERL-ON-INIT" class="id_link">#</a></dt><dd><p>Задаёт код Perl, который будет выполняться при первой инициализации интерпретатора Perl, до того, как он получает специализацию <code class="literal">plperl</code> или <code class="literal">plperlu</code>. Когда этот код выполняется, функции SPI ещё не доступны. Если выполнение кода завершается ошибкой, инициализация интерпретатора прерывается и ошибка распространяется в вызывающий запрос, в результате чего текущая транзакция или подтранзакция прерывается.</p><p>Размер этого кода ограничивается одной строкой. Более объёмный код можно поместить в модуль и загрузить этот модуль в строке <code class="literal">on_init</code>. Например: </p><pre class="programlisting">plperl.on_init = 'require "plperlinit.pl"'
plperl.on_init = 'use lib "/my/app"; use MyApp::PgInit;'</pre><p>Любые модули, загруженные в <code class="literal">plperl.on_init</code>, явно или неявно, будут доступны для использования в коде на языке <code class="literal">plperl</code>. Это может создать угрозу безопасности. Чтобы определить, какие модули были загружены, можно выполнить: </p><pre class="programlisting">DO 'elog(WARNING, join ", ", sort keys %INC)' LANGUAGE plperl;</pre><p>Если библиотека <code class="literal">plperl</code> включена в <a class="xref" href="runtime-config-client.html#GUC-SHARED-PRELOAD-LIBRARIES">shared_preload_libraries</a>, инициализация произойдёт в главном процессе (postmaster) и в этом случае необходимо очень серьёзно оценить риск нарушения работоспособности этого процесса. Основной смысл использовать эту возможность в том, чтобы модули Perl, подключаемые в <code class="literal">plperl.on_init</code>, загружались только при запуске главного процесса, и это исключало бы издержки загрузки для отдельных сеансов. Однако имейте в виду, что эти издержки исключаются только при загрузке в сеансе первого интерпретатора Perl — будь то PL/PerlU или PL/Perl для первой SQL-роли, вызывающей функцию на PL/Perl. Любые дополнительные интерпретаторы Perl, создаваемые в сеансе базы данных, должны будут выполнять <code class="literal">plperl.on_init</code> заново. Также учтите, что в Windows предварительная загрузка не даёт никакого выигрыша, так как интерпретатор Perl, созданный в главном процессе, не передаётся дочерним процессам.</p><p>Задать этот параметр можно только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера.</p></dd><dt id="GUC-PLPERL-ON-PLPERL-INIT"><span class="term"><code class="varname">plperl.on_plperl_init</code> (<code class="type">string</code>) <a id="id-1.8.10.16.2.3.2.1.3" class="indexterm"></a><br /></span><span class="term"><code class="varname">plperl.on_plperlu_init</code> (<code class="type">string</code>) <a id="id-1.8.10.16.2.3.2.2.3" class="indexterm"></a></span> <a href="#GUC-PLPERL-ON-PLPERL-INIT" class="id_link">#</a></dt><dd><p>В этих параметрах задаётся код Perl, который будет выполняться в момент, когда интерпретатор Perl получает специализацию <code class="literal">plperl</code> или <code class="literal">plperlu</code>, соответственно. Это произойдёт, когда в рамках сеанса будет первый раз вызвана функция на PL/Perl или PL/PerlU, либо когда потребуется дополнительный интерпретатор при использовании другого языка или при вызове функции PL/Perl новой SQL-ролью. Этот код выполняется после инициализации, произведённой в <code class="literal">plperl.on_init</code>. Однако функции SPI в момент исполнения этого кода ещё не доступны. Код в <code class="literal">plperl.on_plperl_init</code> запускается после того, как интерпретатор <span class="quote">«<span class="quote">помещается под замок</span>»</span>, так что в нём разрешаются только доверенные операции.</p><p>Если этот код завершается ошибкой, инициализация прерывается и ошибка распространяется в вызывающий запрос, что приводит к прерыванию текущей транзакции или подтранзакции. При этом любые действия, уже произведённые в Perl, не будут отменены; однако использоваться этот интерпретатор больше не будет. При следующей попытке использовать этот язык система попытается заново инициализировать свежий интерпретатор Perl.</p><p>Изменять эти параметры разрешено только суперпользователям. Хотя изменить их можно в рамках сеанса, такие изменения не повлияют на работу интерпретаторов Perl, задействованных для выполнения функций ранее.</p></dd><dt id="GUC-PLPERL-USE-STRICT"><span class="term"><code class="varname">plperl.use_strict</code> (<code class="type">boolean</code>) <a id="id-1.8.10.16.2.3.3.1.3" class="indexterm"></a></span> <a href="#GUC-PLPERL-USE-STRICT" class="id_link">#</a></dt><dd><p>При значении, равном true, последующая компиляция функций PL/Perl будет выполняться с включённым указанием <code class="literal">strict</code>. Этот параметр не влияет на функции, уже скомпилированные в текущем сеансе.</p></dd></dl></div></div><div class="sect2" id="PLPERL-MISSING"><div class="titlepage"><div><div><h3 class="title">45.8.2. Ограничения и недостающие возможности <a href="#PLPERL-MISSING" class="id_link">#</a></h3></div></div></div><p>Следующие возможности в настоящее время в PL/Perl отсутствуют, но их реализация будет желанной доработкой. </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Функции на PL/Perl не могут напрямую вызывать друг друга.</p></li><li class="listitem"><p>SPI ещё не полностью реализован.</p></li><li class="listitem"><p>Если вы выбираете очень большие наборы данных, используя <code class="literal">spi_exec_query</code>, вы должны понимать, что все эти данные загружаются в память. Вы можете избежать этого, используя пару функций <code class="literal">spi_query</code>/<code class="literal">spi_fetchrow</code>, как показано ранее.</p><p>Похожая проблема возникает, если функция, возвращающая множество, передаёт в PostgreSQL большое число строк, выполняя <code class="literal">return</code>. Этой проблемы так же можно избежать, выполняя для каждой возвращаемой строки <code class="literal">return_next</code>, как показано ранее.</p></li><li class="listitem"><p>Когда сеанс завершается штатно, не по причине критической ошибки, в Perl выполняются все блоки <code class="literal">END</code>, которые были определены. Никакие другие действия в настоящее время не выполняются. В частности, буферы файлов автоматически не сбрасываются и объекты автоматически не уничтожаются.</p></li></ul></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="plperl-event-triggers.html" title="45.7. Событийные триггеры на PL/Perl">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="plperl.html" title="Глава 45. PL/Perl — процедурный язык Perl">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="plpython.html" title="Глава 46. PL/Python — процедурный язык Python">След.</a></td></tr><tr><td width="40%" align="left" valign="top">45.7. Событийные триггеры на PL/Perl </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> Глава 46. PL/Python — процедурный язык Python</td></tr></table></div></body></html>