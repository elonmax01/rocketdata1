<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>34.5. Конвейерный режим</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="libpq-async.html" title="34.4. Асинхронная обработка команд" /><link rel="next" href="libpq-single-row-mode.html" title="34.6. Построчное извлечение результатов запроса" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">34.5. Конвейерный режим</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="libpq-async.html" title="34.4. Асинхронная обработка команд">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="libpq.html" title="Глава 34. libpq — библиотека для языка C">Наверх</a></td><th width="60%" align="center">Глава 34. <span class="application">libpq</span> — библиотека для языка C</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="libpq-single-row-mode.html" title="34.6. Построчное извлечение результатов запроса">След.</a></td></tr></table><hr /></div><div class="sect1" id="LIBPQ-PIPELINE-MODE"><div class="titlepage"><div><div><h2 class="title" style="clear: both">34.5. Конвейерный режим <a href="#LIBPQ-PIPELINE-MODE" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="libpq-pipeline-mode.html#LIBPQ-PIPELINE-USING">34.5.1. Использование конвейерного режима</a></span></dt><dt><span class="sect2"><a href="libpq-pipeline-mode.html#LIBPQ-PIPELINE-FUNCTIONS">34.5.2. Функции, связанные с конвейерным режимом</a></span></dt><dt><span class="sect2"><a href="libpq-pipeline-mode.html#LIBPQ-PIPELINE-TIPS">34.5.3. Когда использовать конвейерный режим</a></span></dt></dl></div><a id="id-1.7.3.12.2" class="indexterm"></a><a id="id-1.7.3.12.3" class="indexterm"></a><a id="id-1.7.3.12.4" class="indexterm"></a><p>Конвейерный режим <span class="application">libpq</span> даёт приложению отправить запрос, не получая результат предыдущего. Используя преимущества конвейерного режима, клиент будет меньше ждать сервер, поскольку несколько запросов/результатов могут быть отправлены/получены в одной сетевой транзакции.</p><p>Хотя конвейерный режим обеспечивает значительный прирост производительности, разрабатывать клиентские приложения, использующие этот режим, гораздо сложнее, так как требуется реализовывать очереди ожидающих запросов и сопоставлять результаты с запросами в очереди.</p><p>Для конвейерного режима также обычно требуется больше памяти как на стороне клиента, так и на стороне сервера, хотя тщательное и агрессивное управление очередью отправки/получения может это нивелировать. Это не зависит от того, в каком режиме — блокирующем или нет — устанавливается подключение.</p><p>Хотя конвейерный API в <span class="application">libpq</span> появился с выходом <span class="productname">PostgreSQL</span> 14, это клиентская функциональность, которая не требует специальной поддержки на стороне сервера и работает с любым сервером, поддерживающем 3-ю версию расширенного протокола запросов. За дополнительными сведениями обратитесь к <a class="xref" href="protocol-flow.html#PROTOCOL-FLOW-PIPELINING" title="55.2.4. Конвейеризация">Подразделу 55.2.4</a>.</p><div class="sect2" id="LIBPQ-PIPELINE-USING"><div class="titlepage"><div><div><h3 class="title">34.5.1. Использование конвейерного режима <a href="#LIBPQ-PIPELINE-USING" class="id_link">#</a></h3></div></div></div><p>Для запуска конвейеров приложение должно переключить соединение в конвейерный режим посредством функции <a class="xref" href="libpq-pipeline-mode.html#LIBPQ-PQENTERPIPELINEMODE"><code class="function">PQenterPipelineMode</code></a>. Можно проверить, включён ли данный режим, используя функцию <a class="xref" href="libpq-pipeline-mode.html#LIBPQ-PQPIPELINESTATUS"><code class="function">PQpipelineStatus</code></a>. В конвейерном режиме разрешены только <a class="link" href="libpq-async.html" title="34.4. Асинхронная обработка команд">асинхронные операции</a>, использующие расширенный протокол запросов, а строки команд, содержащие несколько SQL-команд, и команда <code class="literal">COPY</code> запрещены. Использовать функции синхронного выполнения команд, такие как <code class="function">PQfn</code>, <code class="function">PQexec</code>, <code class="function">PQexecParams</code>, <code class="function">PQprepare</code>, <code class="function">PQexecPrepared</code>, <code class="function">PQdescribePrepared</code>, <code class="function">PQdescribePortal</code>, в этом режиме нельзя. Функцию <code class="function">PQsendQuery</code> применять также нельзя, так как она использует простой протокол запросов. Обработав результаты всех отправленных команд и итоговый результат конвейера, приложение может вернуться в обычный режим, вызвав <a class="xref" href="libpq-pipeline-mode.html#LIBPQ-PQEXITPIPELINEMODE"><code class="function">PQexitPipelineMode</code></a>.</p><div class="note"><h3 class="title">Примечание</h3><p>Конвейерный режим рекомендуется использовать при работе <span class="application">libpq</span> в <a class="link" href="libpq-async.html#LIBPQ-PQSETNONBLOCKING">неблокирующем режиме</a>. В блокирующем режиме возможны взаимоблокировки на уровне клиент-сервер. <a href="#ftn.id-1.7.3.12.9.3.1.3" class="footnote"><sup class="footnote" id="id-1.7.3.12.9.3.1.3">[15]</sup></a></p></div><div class="sect3" id="LIBPQ-PIPELINE-SENDING"><div class="titlepage"><div><div><h4 class="title">34.5.1.1. Отправка запросов <a href="#LIBPQ-PIPELINE-SENDING" class="id_link">#</a></h4></div></div></div><p>Перейдя в конвейерный режим, приложение отправляет запросы, вызывая <a class="xref" href="libpq-async.html#LIBPQ-PQSENDQUERYPARAMS"><code class="function">PQsendQueryParams</code></a> или родственную ей функцию <a class="xref" href="libpq-async.html#LIBPQ-PQSENDQUERYPREPARED"><code class="function">PQsendQueryPrepared</code></a>, работающую с подготовленными запросами. Данные запросы ставятся в очередь на стороне клиента, а затем сбрасываются на сервер; это происходит, когда вызывается <a class="xref" href="libpq-pipeline-mode.html#LIBPQ-PQPIPELINESYNC"><code class="function">PQpipelineSync</code></a>, устанавливающая точку синхронизации в конвейере, или когда вызывается <a class="xref" href="libpq-async.html#LIBPQ-PQFLUSH"><code class="function">PQflush</code></a>. В конвейерном режиме также работают функции <a class="xref" href="libpq-async.html#LIBPQ-PQSENDPREPARE"><code class="function">PQsendPrepare</code></a>, <a class="xref" href="libpq-async.html#LIBPQ-PQSENDDESCRIBEPREPARED"><code class="function">PQsendDescribePrepared</code></a> и <a class="xref" href="libpq-async.html#LIBPQ-PQSENDDESCRIBEPORTAL"><code class="function">PQsendDescribePortal</code></a>. Обработка результатов описана ниже.</p><p>Сервер выполняет операторы и в порядке их поступления от клиента возвращает результаты. Сервер начнёт выполнять команды в конвейере немедленно, не дожидаясь конца конвейера. Обратите внимание, что результаты буферизуются на стороне сервера; сервер сбрасывает этот буфер, когда функцией <code class="function">PQpipelineSync</code> устанавливается точка синхронизации или когда вызывается функция <code class="function">PQsendFlushRequest</code>. Если при выполнении какого-либо оператора возникает ошибка, сервер прерывает текущую транзакцию и не выполняет никакую следующую команду в очереди до следующей точки синхронизации; для каждой такой команды выдаётся результат <code class="literal">PGRES_PIPELINE_ABORTED</code>. (Это справедливо и тогда, когда в конвейере передаются команды, которые могли бы откатить транзакцию.) Обработка запроса возобновляется после точки синхронизации.</p><p>Одна операция вполне может зависеть от результатов предыдущей; например, в одном запросе может создаваться таблица, которую будет использовать следующий запрос в том же конвейере. Точно так же приложение может создать именованный подготовленный оператор и выполнить его с последующими операторами в том же конвейере.</p></div><div class="sect3" id="LIBPQ-PIPELINE-RESULTS"><div class="titlepage"><div><div><h4 class="title">34.5.1.2. Обработка результатов <a href="#LIBPQ-PIPELINE-RESULTS" class="id_link">#</a></h4></div></div></div><p>Чтобы обработать результат одного запроса в конвейере, приложение многократно вызывает <code class="function">PQgetResult</code> и обрабатывает каждый её результат, пока <code class="function">PQgetResult</code> не выдаст NULL. Затем может быть получен результат следующего запроса в конвейере, также с помощью <code class="function">PQgetResult</code>, и весь цикл повторяется. Результаты отдельных запросов приложение обрабатывает обычным образом. После того, как будут выданы результаты всех запросов в конвейере, <code class="function">PQgetResult</code> выдаёт результат со значением статуса <code class="literal">PGRES_PIPELINE_SYNC</code>.</p><p>Клиент может отложить обработку результатов до тех пор, пока весь конвейер не будет отправлен, или чередовать её с отправкой дальнейших запросов в конвейере; см. <a class="xref" href="libpq-pipeline-mode.html#LIBPQ-PIPELINE-INTERLEAVE" title="34.5.1.4. Чередование обработки результатов и отправки запросов">Подраздел 34.5.1.4</a>.</p><p>Чтобы войти в однострочный режим, вызовите <code class="function">PQsetSingleRowMode</code> перед получением результатов от <code class="function">PQgetResult</code>. Выбранный режим будет действовать только для текущего обрабатываемого запроса. Для получения дополнительной информации об использовании <code class="function">PQsetSingleRowMode</code> обратитесь к <a class="xref" href="libpq-single-row-mode.html" title="34.6. Построчное извлечение результатов запроса">Разделу 34.6</a>.</p><p>Функция <code class="function">PQgetResult</code> работает так же, как и при обычной асинхронной обработке, но может дополнительно выдавать результаты новых типов <code class="literal">PGRES_PIPELINE_SYNC</code> и <code class="literal">PGRES_PIPELINE_ABORTED</code>. <code class="literal">PGRES_PIPELINE_SYNC</code> выдаётся ровно один раз для каждого вызова <code class="function">PQpipelineSync</code> в соответствующей точке конвейера. <code class="literal">PGRES_PIPELINE_ABORTED</code> выдаётся вместо обычного результата запроса для первой ошибки и всех последующих результатов до следующего <code class="literal">PGRES_PIPELINE_SYNC</code>; см. <a class="xref" href="libpq-pipeline-mode.html#LIBPQ-PIPELINE-ERRORS" title="34.5.1.3. Обработка ошибок">Подраздел 34.5.1.3</a>.</p><p>Функции <code class="function">PQisBusy</code>, <code class="function">PQconsumeInput</code> и т. п. работают как обычно при обработке результатов конвейера. В частности, вызов <code class="function">PQisBusy</code> в середине конвейера возвращает 0, если были обработаны результаты всех выполненных на данный момент запросов.</p><p><span class="application">libpq</span> не предоставляет приложению никакой информации о запросе, обрабатываемом в данный момент (за исключением того, что <code class="function">PQgetResult</code> возвращает NULL, чтобы указать, что далее выдаются результаты следующего запроса). Приложение должно отслеживать порядок отправки запросов, чтобы связать их с соответствующими результатами. Для этого приложение обычно использует конечный автомат или очередь.</p></div><div class="sect3" id="LIBPQ-PIPELINE-ERRORS"><div class="titlepage"><div><div><h4 class="title">34.5.1.3. Обработка ошибок <a href="#LIBPQ-PIPELINE-ERRORS" class="id_link">#</a></h4></div></div></div><p>С точки зрения клиента, после того, как <code class="function">PQresultStatus</code> возвращает <code class="literal">PGRES_FATAL_ERROR</code>, конвейер помечается как нерабочий. <code class="function">PQresultStatus</code> будет выдавать результат <code class="literal">PGRES_PIPELINE_ABORTED</code> для каждой оставшейся в очереди операции в нерабочем конвейере. Функция <code class="function">PQpipelineSync</code> выдаёт результат <code class="literal">PGRES_PIPELINE_SYNC</code>, сигнализируя о возвращении конвейера в рабочее состояние и возобновлении нормальной обработки результатов.</p><p>Клиент <span class="emphasis"><em>должен</em></span> обрабатывать результаты, вызывая <code class="function">PQgetResult</code> во время восстановления после ошибки.</p><p>Если в конвейере передавалась неявная транзакция, то операции, которые уже были выполнены, откатываются, а операции, которые были поставлены в очередь после неудачной операции, полностью пропускаются. То же самое происходит, если в конвейере запускается и фиксируется одна явная транзакция (т. е. первый оператор — <code class="literal">BEGIN</code>, а последний — <code class="literal">COMMIT</code>), за исключением того, что сеанс остаётся в состоянии прерванной транзакции в конце конвейера. Если конвейер содержит <span class="emphasis"><em>несколько явных транзакций</em></span>, все транзакции, зафиксированные до ошибки, остаются зафиксированными, текущая транзакция прерывается, а все последующие операции полностью пропускаются, включая транзакции. Если выполняется точка синхронизации, когда явный блок транзакции находится в прерванном состоянии, следующий конвейер сразу же становится нерабочим, если следующая команда (<code class="command">ROLLBACK</code>) не переключает его в обычный режим.</p><div class="note"><h3 class="title">Примечание</h3><p>Клиент не должен рассчитывать на то, что выполненная работа зафиксирована сразу после того, как был <span class="emphasis"><em>отправлен</em></span> <code class="literal">COMMIT</code>; только получение соответствующего результата даёт такую гарантию. Поскольку ошибки поступают асинхронно, приложение должно уметь возвращаться к моменту последнего <span class="emphasis"><em>подтверждённого</em></span> зафиксированного изменения и повторно отправлять работу, выполненную после этого момента, если что-то пойдёт не так.</p></div></div><div class="sect3" id="LIBPQ-PIPELINE-INTERLEAVE"><div class="titlepage"><div><div><h4 class="title">34.5.1.4. Чередование обработки результатов и отправки запросов <a href="#LIBPQ-PIPELINE-INTERLEAVE" class="id_link">#</a></h4></div></div></div><p>Во избежание взаимоблокировок с большими конвейерами, клиент должен быть построен вокруг неблокирующего цикла событий, реализованного с использованием таких механизмов операционной системы, как <code class="function">select</code>, <code class="function">poll</code>, <code class="function">WaitForMultipleObjectEx</code> и т. д.</p><p>Клиентское приложение, как правило, должно поддерживать очередь ещё не отправленной работы и очередь работы, которая уже отправлена, но её результаты ещё не обработаны. Когда сокет доступен для записи, в него следует отправлять очередной объём работы. Когда он доступен для чтения, из него следует прочитать и обработать результаты, сопоставив их со следующей записью в очереди ожидания результатов. Если объём памяти позволяет, результаты следует читать достаточно часто — дожидаться окончания конвейера не требуется. Конвейеры должны быть ограничены логическими единицами работы, обычно (но не обязательно) по одной транзакции на конвейер. Нет необходимости выходить из конвейерного режима и возвращаться в него между конвейерами, так же как не нужно дожидаться завершения одного конвейере, прежде чем передавать работу в другой.</p><p>Пример использования <code class="function">select()</code> и простого конечного автомата для отслеживания отправляемой работы и полученных результатов находится в <code class="filename">src/test/modules/libpq_pipeline/libpq_pipeline.c</code> в дистрибутиве исходного кода PostgreSQL.</p></div></div><div class="sect2" id="LIBPQ-PIPELINE-FUNCTIONS"><div class="titlepage"><div><div><h3 class="title">34.5.2. Функции, связанные с конвейерным режимом <a href="#LIBPQ-PIPELINE-FUNCTIONS" class="id_link">#</a></h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQPIPELINESTATUS"><span class="term"><code class="function">PQpipelineStatus</code><a id="id-1.7.3.12.10.2.1.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQPIPELINESTATUS" class="id_link">#</a></dt><dd><p>Возвращает текущее состояние конвейерного режима для подключения <span class="application">libpq</span>. </p><pre class="synopsis">
PGpipelineStatus PQpipelineStatus(const PGconn *conn);
</pre><p><code class="function">PQpipelineStatus</code> может выдавать одно из следующих значений: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
          <code class="literal">PQ_PIPELINE_ON</code>
         </span></dt><dd><p>Подключение <span class="application">libpq</span> находится в конвейерном режиме.</p></dd><dt><span class="term">
          <code class="literal">PQ_PIPELINE_OFF</code>
         </span></dt><dd><p>Подключение <span class="application">libpq</span> <span class="emphasis"><em>не</em></span> находится в конвейерном режиме.</p></dd><dt><span class="term">
          <code class="literal">PQ_PIPELINE_ABORTED</code>
         </span></dt><dd><p>Соединение <span class="application">libpq</span> находится в конвейерном режиме, и при обработке текущего конвейера произошла ошибка. Флаг прерывания сбрасывается, когда <code class="function">PQgetResult</code> возвращает результат типа <code class="literal">PGRES_PIPELINE_SYNC</code>.</p></dd></dl></div></dd><dt id="LIBPQ-PQENTERPIPELINEMODE"><span class="term"><code class="function">PQenterPipelineMode</code><a id="id-1.7.3.12.10.2.2.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQENTERPIPELINEMODE" class="id_link">#</a></dt><dd><p>Переводит подключение в конвейерный режим, если оно в данный момент находится в режиме ожидания или уже находится в конвейерном режиме. </p><pre class="synopsis">
int PQenterPipelineMode(PGconn *conn);
</pre><p>Возвращает 1 в случае успеха. Возвращает 0 и ничего не делает, если соединение в настоящий момент не простаивает, т. е. если у него есть готовый результат, или оно ожидает поступления дополнительных данных от сервера и т. д. Эта функция на самом деле ничего не отправляет серверу, а просто изменяет состояние соединения <span class="application">libpq</span>.</p></dd><dt id="LIBPQ-PQEXITPIPELINEMODE"><span class="term"><code class="function">PQexitPipelineMode</code><a id="id-1.7.3.12.10.2.3.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQEXITPIPELINEMODE" class="id_link">#</a></dt><dd><p>Выводит подключение из конвейерного режима, если подключение находится в нём и его очереди пусты. </p><pre class="synopsis">
int PQexitPipelineMode (PGconn * conn);
</pre><p>Возвращает 1 в случае успеха. Не в конвейерном режиме возвращает 1 и не выполняет никаких действий. Если обработка текущего оператора не завершена или <code class="function">PQgetResult</code> не была вызвана для сбора результатов всех ранее отправленных запросов, возвращает 0 (в этом случае используйте <a class="xref" href="libpq-status.html#LIBPQ-PQERRORMESSAGE"><code class="function">PQerrorMessage</code></a>, чтобы получить дополнительную информацию о проблеме).</p></dd><dt id="LIBPQ-PQPIPELINESYNC"><span class="term"><code class="function">PQpipelineSync</code><a id="id-1.7.3.12.10.2.4.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQPIPELINESYNC" class="id_link">#</a></dt><dd><p>Отмечает точку синхронизации в конвейере, отправляя <a class="link" href="protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY" title="55.2.3. Расширенное выполнение запросов">сообщение синхронизации</a> и очищая буфер отправки. Эта точка служит ограничителем неявной транзакции и точкой восстановления после ошибки; см. <a class="xref" href="libpq-pipeline-mode.html#LIBPQ-PIPELINE-ERRORS" title="34.5.1.3. Обработка ошибок">Подраздел 34.5.1.3</a>. </p><pre class="synopsis">
int PQpipelineSync(PGconn *conn);
</pre><p>Возвращает 1 в случае успеха. Возвращает 0, если соединение не находится в конвейерном режиме или <a class="link" href="protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY" title="55.2.3. Расширенное выполнение запросов">сообщение синхронизации</a> отправить не удалось.</p></dd><dt id="LIBPQ-PQSENDFLUSHREQUEST"><span class="term"><code class="function">PQsendFlushRequest</code><a id="id-1.7.3.12.10.2.5.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQSENDFLUSHREQUEST" class="id_link">#</a></dt><dd><p>Отправляет серверу команду сбросить его буфер вывода. </p><pre class="synopsis">
int PQsendFlushRequest(PGconn *conn);
</pre><p>Возвращает 1 в случае успеха. Возвращает 0 в случае любой ошибки.</p><p>Сервер сбрасывает свой буфер вывода автоматически, когда вызывается <code class="function">PQpipelineSync</code> или передаётся любой запрос не в конвейерном режиме; эта функция полезна в конвейерном режиме: она позволяет сбросить серверный буфер, не устанавливая точку синхронизации. Обратите внимание, что сам этот запрос не передаётся серверу автоматически; чтобы передать его немедленно, вызовите <code class="function">PQflush</code>.</p></dd></dl></div></div><div class="sect2" id="LIBPQ-PIPELINE-TIPS"><div class="titlepage"><div><div><h3 class="title">34.5.3. Когда использовать конвейерный режим <a href="#LIBPQ-PIPELINE-TIPS" class="id_link">#</a></h3></div></div></div><p>Как и в случае с асинхронным режимом запросов, при использовании конвейерного режима нет значительных издержек производительности. Использование конвейерного режима увеличивает сложность клиентского приложения и требует дополнительной осторожности во избежание взаимоблокировок клиент-сервер, но может предложить значительное улучшение производительности в обмен на увеличение объёма используемой памяти из-за более длительного выхода из состояния.</p><p>Конвейерный режим наиболее полезен, когда сервер находится на большом расстоянии от клиента, т. е. когда сетевая задержка (<span class="quote">«<span class="quote">ping time</span>»</span>) велика, а также когда много небольших операций выполняются в быстрой последовательности. Как правило, использование конвейерных команд даёт меньше преимуществ, когда выполнение каждого запроса занимает в несколько раз больше времени, чем передача данных клиент-сервер и обратно. Операция из 100 операторов, выполняемая на сервере за 300 миллисекунд, без конвейеризации займёт 30 секунд из-за одной только сетевой задержки; с конвейеризацией данная операция потратит не более 0,3 секунды на ожидание результатов от сервера.</p><p>Используйте конвейерные команды, когда ваше приложение выполняет множество небольших операций <code class="literal">INSERT</code>, <code class="literal">UPDATE</code> и <code class="literal">DELETE</code>, которые нелегко преобразовать в наборы операций или в операцию <code class="literal">COPY</code>.</p><p>Конвейерный режим бесполезен, когда информация из одной операции требуется клиенту для выполнения следующей операции. В таких случаях клиенту придётся ввести точку синхронизации и дождаться полного цикла передачи данных клиент-сервер, чтобы получить требуемые результаты. Однако часто можно настроить клиент для обмена необходимой информацией на стороне сервера. Циклы чтения-изменения-записи особенно хорошо подходят для такой настройки; например: </p><pre class="programlisting">BEGIN;
SELECT x FROM mytable WHERE id = 42 FOR UPDATE;
-- result: x=2
-- client adds 1 to x:
UPDATE mytable SET x = 3 WHERE id = 42;
COMMIT;</pre><p> можно гораздо эффективнее сделать с помощью: </p><pre class="programlisting">UPDATE mytable SET x = x + 1 WHERE id = 42;</pre><p>Конвейеризация менее полезна и более сложна, когда один конвейер содержит несколько транзакций (см. <a class="xref" href="libpq-pipeline-mode.html#LIBPQ-PIPELINE-ERRORS" title="34.5.1.3. Обработка ошибок">Подраздел 34.5.1.3</a>).</p></div><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.id-1.7.3.12.9.3.1.3" class="footnote"><p><a href="#id-1.7.3.12.9.3.1.3" class="para"><sup class="para">[15] </sup></a>Клиент может заблокироваться, пытаясь передать запросы серверу, а сервер заблокируется, пытаясь выдать клиенту результаты уже выполненных запросов. Это возможно, только когда клиент передаёт так много запросов, что заполняет и свой выходной буфер, и входной буфер сервера, и только затем переключается на обработку передаваемых сервером результатов, но предсказать, когда точно это произойдёт, сложно.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="libpq-async.html" title="34.4. Асинхронная обработка команд">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="libpq.html" title="Глава 34. libpq — библиотека для языка C">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="libpq-single-row-mode.html" title="34.6. Построчное извлечение результатов запроса">След.</a></td></tr><tr><td width="40%" align="left" valign="top">34.4. Асинхронная обработка команд </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 34.6. Построчное извлечение результатов запроса</td></tr></table></div></body></html>