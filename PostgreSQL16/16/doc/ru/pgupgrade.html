<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>pg_upgrade</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="pgtesttiming.html" title="pg_test_timing" /><link rel="next" href="pgwaldump.html" title="pg_waldump" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center"><span class="application">pg_upgrade</span></th></tr><tr><td width="10%" align="left"><a accesskey="p" href="pgtesttiming.html" title="pg_test_timing">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="reference-server.html" title="Серверные приложения PostgreSQL">Наверх</a></td><th width="60%" align="center">Серверные приложения PostgreSQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="pgwaldump.html" title="pg_waldump">След.</a></td></tr></table><hr /></div><div class="refentry" id="PGUPGRADE"><div class="titlepage"></div><a id="id-1.9.5.12.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle"><span class="application">pg_upgrade</span></span></h2><p>pg_upgrade — обновить экземпляр сервера <span class="productname">PostgreSQL</span></p></div><div class="refsynopsisdiv"><h2>Синтаксис</h2><div class="cmdsynopsis"><p id="id-1.9.5.12.4.1"><code class="command">pg_upgrade</code>  <code class="option">-b</code>   <em class="replaceable"><code>старый_каталог_bin</code></em>  [<code class="option">-B</code> <em class="replaceable"><code>новый_каталог_bin</code></em>]  <code class="option">-d</code>   <em class="replaceable"><code>старый_каталог_конфигурации</code></em>   <code class="option">-D</code>   <em class="replaceable"><code>новый_каталог_конфигурации</code></em>  [<em class="replaceable"><code>параметр</code></em>...]</p></div></div><div class="refsect1" id="id-1.9.5.12.5"><h2>Описание</h2><p>Программа <span class="application">pg_upgrade</span> (ранее называвшаяся <span class="application">pg_migrator</span>) позволяет обновить данные в каталоге базы данных <span class="productname">PostgreSQL</span> до последней основной версии <span class="productname">PostgreSQL</span> без операции выгрузки/восстановления данных, обычно необходимой при обновлениях основной версии, например, при переходе от 12.14 к 13.10 или от 14.9 к 15.5. Эти действия не требуются при установке корректирующей версии, например, при переходе от 12.7 к 12.8 или от 14.1 к 14.5.</p><p>С выходом новых основных версий в PostgreSQL регулярно добавляются новые возможности, которые часто меняют структуру системных таблицы, но внутренний формат хранения меняется редко. Учитывая этот факт, <span class="application">pg_upgrade</span> позволяет выполнить быстрое обновление, создавая системные таблицы заново, но сохраняя старые файлы данных. Если при обновлении основной версии формат хранения данных изменится так, что данные в старом формате окажутся нечитаемыми, <span class="application">pg_upgrade</span> не сможет произвести такое обновление. (Сообщество разработчиков постарается не допустить подобных ситуаций.)</p><p>Программа <span class="application">pg_upgrade</span> делает всё возможное, чтобы убедиться в том, что старый и новый кластеры двоично-совместимы, в частности проверяя параметры времени компиляции и разрядность (32/64 бита) исполняемых файлов. Важно, чтобы и все внешние модули тоже были двоично-совместимыми, хотя это <span class="application">pg_upgrade</span> проверить не может.</p><p>pg_upgrade поддерживает обновление с версии 9.2.X и новее до текущей основной версии <span class="productname">PostgreSQL</span>, включая бета-выпуски и сборки снимков кода.</p></div><div class="refsect1" id="id-1.9.5.12.6"><h2>Параметры</h2><p><span class="application">pg_upgrade</span> принимает следующие аргументы командной строки: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="option">-b</code> <em class="replaceable"><code>каталог_bin</code></em><br /></span><span class="term"><code class="option">--old-bindir=</code><em class="replaceable"><code>каталог_bin</code></em></span></dt><dd><p>каталог с исполняемыми файлами старой версии PostgreSQL; переменная окружения <code class="envar">PGBINOLD</code></p></dd><dt><span class="term"><code class="option">-B</code> <em class="replaceable"><code>каталог_bin</code></em><br /></span><span class="term"><code class="option">--new-bindir=</code><em class="replaceable"><code>каталог_bin</code></em></span></dt><dd><p>каталог с исполняемыми файлами новой версии PostgreSQL, по умолчанию это каталог, в котором располагается <span class="application">pg_upgrade</span>; переменная окружения <code class="envar">PGBINNEW</code></p></dd><dt><span class="term"><code class="option">-c</code><br /></span><span class="term"><code class="option">--check</code></span></dt><dd><p>только проверить кластеры, не изменять никакие данные</p></dd><dt><span class="term"><code class="option">-d</code> <em class="replaceable"><code>каталог_конфигурации</code></em><br /></span><span class="term"><code class="option">--old-datadir=</code><em class="replaceable"><code>каталог_конфигурации</code></em></span></dt><dd><p>каталог конфигурации старого кластера; переменная окружения <code class="envar">PGDATAOLD</code></p></dd><dt><span class="term"><code class="option">-D</code> <em class="replaceable"><code>каталог_конфигурации</code></em><br /></span><span class="term"><code class="option">--new-datadir=</code><em class="replaceable"><code>каталог_конфигурации</code></em></span></dt><dd><p>каталог конфигурации нового кластера; переменная окружения <code class="envar">PGDATANEW</code></p></dd><dt><span class="term"><code class="option">-j <em class="replaceable"><code>число_заданий</code></em></code><br /></span><span class="term"><code class="option">--jobs=<em class="replaceable"><code>число_заданий</code></em></code></span></dt><dd><p>число одновременно задействуемых процессов или потоков</p></dd><dt><span class="term"><code class="option">-k</code><br /></span><span class="term"><code class="option">--link</code></span></dt><dd><p>использовать жёсткие ссылки вместо копирования файлов в новый кластер</p></dd><dt><span class="term"><code class="option">-N</code><br /></span><span class="term"><code class="option">--no-sync</code></span></dt><dd><p>По умолчанию <code class="command">pg_upgrade</code> ждёт, пока все файлы обновлённого кластера не будут надёжно записаны на диск. С данным параметром <code class="command">pg_upgrade</code> завершается быстрее, без ожидания, но в случае последующего сбоя операционной системы каталог данных может оказаться испорченным. Этот параметр может быть полезен при тестировании; в производственной среде применять его не следует.</p></dd><dt><span class="term"><code class="option">-o</code> <em class="replaceable"><code>параметры</code></em><br /></span><span class="term"><code class="option">--old-options</code> <em class="replaceable"><code>параметры</code></em></span></dt><dd><p>параметры, передаваемые непосредственно старой программе <code class="command">postgres</code>; несколько параметров складываются вместе</p></dd><dt><span class="term"><code class="option">-O</code> <em class="replaceable"><code>параметры</code></em><br /></span><span class="term"><code class="option">--new-options</code> <em class="replaceable"><code>параметры</code></em></span></dt><dd><p>параметры, передаваемые непосредственно новой программе <code class="command">postgres</code>; несколько параметров складываются вместе</p></dd><dt><span class="term"><code class="option">-p</code> <em class="replaceable"><code>порт</code></em><br /></span><span class="term"><code class="option">--old-port=</code><em class="replaceable"><code>порт</code></em></span></dt><dd><p>номер порта старого кластера; переменная окружения <code class="envar">PGPORTOLD</code></p></dd><dt><span class="term"><code class="option">-P</code> <em class="replaceable"><code>порт</code></em><br /></span><span class="term"><code class="option">--new-port=</code><em class="replaceable"><code>порт</code></em></span></dt><dd><p>номер порта нового кластера; переменная окружения <code class="envar">PGPORTNEW</code></p></dd><dt><span class="term"><code class="option">-r</code><br /></span><span class="term"><code class="option">--retain</code></span></dt><dd><p>сохранить SQL и журналы сообщений даже при успешном завершении</p></dd><dt><span class="term"><code class="option">-s</code> <em class="replaceable"><code>каталог</code></em><br /></span><span class="term"><code class="option">--socketdir=</code><em class="replaceable"><code>каталог</code></em></span></dt><dd><p>каталог, в котором будет создавать сокеты процесс postmaster во время обновления; по умолчанию выбирается текущий рабочий каталог; переменная окружения <code class="envar">PGSOCKETDIR</code></p></dd><dt><span class="term"><code class="option">-U</code> <em class="replaceable"><code>имя_пользователя</code></em><br /></span><span class="term"><code class="option">--username=</code><em class="replaceable"><code>имя_пользователя</code></em></span></dt><dd><p>имя пользователя, установившего кластер; переменная окружения <code class="envar">PGUSER</code></p></dd><dt><span class="term"><code class="option">-v</code><br /></span><span class="term"><code class="option">--verbose</code></span></dt><dd><p>включить подробные внутренние сообщения</p></dd><dt><span class="term"><code class="option">-V</code><br /></span><span class="term"><code class="option">--version</code></span></dt><dd><p>показать версию, а затем завершиться</p></dd><dt><span class="term"><code class="option">--clone</code></span></dt><dd><p>Использовать эффективное клонирование файлов (в ряде систем это называется <span class="quote">«<span class="quote">reflink</span>»</span>) вместо копирования файлов в новый кластер. В результате файлы данных могут копироваться практически мгновенно, как и с использованием <code class="option">-k</code>/<code class="option">--link</code>, но последующие изменения не будут затрагивать старый кластер.</p><p>Клонирование файлов поддерживается не во всех операционных системах и только с определёнными файловыми системами. Если этот режим выбран, но клонирование не поддерживается, при выполнении <span class="application">pg_upgrade</span> произойдёт ошибка. В настоящее время оно поддерживается в Linux (с ядром 4.5 или новее) с Btrfs и XFS (если файловая система была создана с поддержкой reflink), а также в macOS с APFS.</p></dd><dt><span class="term"><code class="option">--copy</code></span></dt><dd><p>Копировать файлы в новый кластер. Это поведение по умолчанию. (См. также <code class="option">--link</code> и <code class="option">--clone</code>.)</p></dd><dt><span class="term"><code class="option">-?</code><br /></span><span class="term"><code class="option">--help</code></span></dt><dd><p>показать справку, а затем завершиться</p></dd></dl></div></div><div class="refsect1" id="id-1.9.5.12.7"><h2>Использование</h2><p>Далее описан план обновления с использованием <span class="application">pg_upgrade</span>:</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p class="title"><strong>Переместить старый кластер (необязательно)</strong></p><p>Если ваш каталог инсталляции привязан к версии, например, <code class="filename">/opt/PostgreSQL/16</code>, перемещать его не требуется. Все графические инсталляторы выбирают при установке каталоги, привязанные к версии.</p><p>Если ваш каталог инсталляции не привязан к версии, например <code class="filename">/usr/local/pgsql</code>, необходимо переместить каталог текущей инсталляции PostgreSQL, чтобы он не конфликтовал с новой инсталляцией <span class="productname">PostgreSQL</span>. Когда текущий сервер <span class="productname">PostgreSQL</span> отключён, каталог этой инсталляции PostgreSQL можно безопасно переместить; если старый каталог <code class="filename">/usr/local/pgsql</code>, его можно переименовать, выполнив: </p><pre class="programlisting">mv /usr/local/pgsql /usr/local/pgsql.old</pre></li><li class="step"><p class="title"><strong>Собрать новую версию при установке из исходного кода</strong></p><p>Соберите из исходного кода новую версию PostgreSQL с флагами <code class="command">configure</code>, совместимыми с флагами старого кластера. Программа <span class="application">pg_upgrade</span> проверит результаты <code class="command">pg_controldata</code>, чтобы убедиться, что все параметры совместимы, прежде чем начинать обновление.</p></li><li class="step"><p class="title"><strong>Установить новые исполняемые файлы PostgreSQL</strong></p><p>Установите новые исполняемые файлы сервера и вспомогательные файлы. Программа <span class="application">pg_upgrade</span> включена в инсталляцию по умолчанию.</p><p>При установке из исходного кода, если вы хотите разместить сервер в нестандартном каталоге, воспользуйтесь переменной <code class="literal">prefix</code>: </p><pre class="programlisting">make prefix=/usr/local/pgsql.new install</pre></li><li class="step"><p class="title"><strong>Инициализировать новый кластер PostgreSQL</strong></p><p>Инициализируйте новый кластер, используя <code class="command">initdb</code>. При этом так же необходимо указать флаги <code class="command">initdb</code>, совместимые с флагами в старом кластере. Многие готовые инсталляторы выполняют это действие автоматически. Запускать новый кластер не требуется.</p></li><li class="step"><p class="title"><strong>Установить разделяемые объектные файлы расширения</strong></p><p>Многие расширения и пользовательские модули, как из <code class="filename">contrib</code>, так и из других источников, используют разделяемые объектные файлы (или библиотеки DLL), например, <code class="filename">pgcrypto.so</code>. Если они использовались в старом кластере, разделяемые объектные файлы, соответствующие новому исполняемому файлу сервера, должны быть установлены в новом кластере, обычно средствами операционной системы. Не загружайте определения схемы, например, выполняя <code class="command">CREATE EXTENSION pgcrypto</code>, потому что они будут скопированы из старого кластера. Если доступны обновления расширений, <span class="application">pg_upgrade</span> сообщит об этом и создаст скрипт, который можно будет запустить позже, чтобы обновить эти расширения.</p></li><li class="step"><p class="title"><strong>Скопируйте пользовательские файлы полнотекстового поиска</strong></p><p>Скопировать пользовательские файлы полнотекстового поиска (словари, тезаурусы, списки синонимов и стоп-слов) из старого кластера в новый.</p></li><li class="step"><p class="title"><strong>Настроить аутентификацию</strong></p><p>Программа <code class="command">pg_upgrade</code> будет подключаться к новому и старому серверу несколько раз, так что имеет смысл установить режим аутентификации <code class="literal">peer</code> в <code class="filename">pg_hba.conf</code> или использовать файл <code class="filename">~/.pgpass</code> (см. <a class="xref" href="libpq-pgpass.html" title="34.16. Файл паролей">Раздел 34.16</a>).</p></li><li class="step"><p class="title"><strong>Остановить оба сервера</strong></p><p>Убедитесь в том, что оба сервера баз данных остановлены. Для этого в Unix можно выполнить: </p><pre class="programlisting">pg_ctl -D /opt/PostgreSQL/12 stop
pg_ctl -D /opt/PostgreSQL/16 stop</pre><p> А в Windows, с соответствующими именами служб: </p><pre class="programlisting">NET STOP postgresql-12
NET STOP postgresql-16</pre><p>Ведомые серверы с потоковой репликацией и трансляцией журнала должны продолжать работать во время этого отключения, чтобы получить все изменения.</p></li><li class="step"><p class="title"><strong>Подготовиться к обновлению ведомых серверов</strong></p><p>Если вы производите обновление ведомых серверов (как описано в разделе <a class="xref" href="pgupgrade.html#PGUPGRADE-STEP-REPLICAS" title="Обновить ведомые серверы с потоковой репликацией и трансляцией журнала">Шаг 11</a>), удостоверьтесь, что эти серверы находятся в актуальном состоянии, запустив <span class="application">pg_controldata</span> в старых ведущем и ведомых кластерах. Убедитесь в том, что <span class="quote">«<span class="quote">Положение последней контрольной точки</span>»</span> во всех кластерах одинаковое. Также смените <code class="varname">wal_level</code> на <code class="literal">replica</code> в файле <code class="filename">postgresql.conf</code> нового ведущего кластера.</p></li><li class="step"><p class="title"><strong>Запустить <span class="application">pg_upgrade</span></strong></p><p>Всегда запускайте программу <span class="application">pg_upgrade</span> от нового сервера, а не от старого. <span class="application">pg_upgrade</span> требует указания каталогов данных старого и нового кластера, а также каталогов исполняемых файлов (<code class="filename">bin</code>). Вы можете также определить имя пользователя и номера портов, и нужно ли копировать файлы данных (по умолчанию), клонировать их или создавать ссылки на них.</p><p>Если выбрать вариант со ссылкой на данные, обновление выполнится гораздо быстрее (так как файлы не копируются) и потребует меньше места на диске, но вы лишитесь возможности обращаться к вашему старому кластеру, запустив новый после обновления. Этот вариант также требует, чтобы каталоги данных старого и нового кластера располагались в одной файловой системе. (Табличные пространства и <code class="filename">pg_wal</code> могут находиться в других файловых системах.) Вариант с клонированием работает так же быстро и экономит место на диске, но позволяет сохранить рабочее состояние старого кластера при запуске нового. Для этого варианта тоже требуется, чтобы старый и новый каталоги данных находились в одной файловой системе. Клонирование возможно только в некоторых операционных системах с определёнными файловыми системами.</p><p>Параметр <code class="option">--jobs</code> позволяет задействовать для копирования/связывания файлов и для выгрузки/восстановления схем баз данных несколько процессорных ядер. В качестве начального значения параметра стоит выбрать максимум из числа процессорных ядер и числа табличных пространств. Этот параметр может радикально сократить время обновления сервера со множеством баз данных, работающего в многопроцессорной системе.</p><p>В Windows вы должны войти в систему с административными полномочиями, затем запустить командную строку от имени пользователя <code class="literal">postgres</code>, задать подходящий путь: </p><pre class="programlisting">RUNAS /USER:postgres "CMD.EXE"
SET PATH=%PATH%;C:\Program Files\PostgreSQL\16\bin;</pre><p> Наконец, запустить <span class="application">pg_upgrade</span> с путями каталогов в кавычках, например, так: </p><pre class="programlisting">pg_upgrade.exe
        --old-datadir "C:/Program Files/PostgreSQL/12/data"
        --new-datadir "C:/Program Files/PostgreSQL/16/data"
        --old-bindir "C:/Program Files/PostgreSQL/12/bin"
        --new-bindir "C:/Program Files/PostgreSQL/16/bin"</pre><p> При запуске <code class="command">pg_upgrade</code> проверит два кластера на совместимость и, если всё в порядке, выполнит обновление. Также возможно запустить <code class="command">pg_upgrade --check</code>, чтобы ограничиться только проверками (при этом старый сервер может продолжать работать). Команда <code class="command">pg_upgrade --check</code> также сообщит, какие коррективы вам нужно будет внести вручную после обновления. Если вы планируете использовать режим ссылок на данные или клонирования, укажите вместе с <code class="option">--check</code> или <code class="option">--clone</code> параметр <code class="option">--link</code>, чтобы были проведены специальные проверки для этого режима. Программе <code class="command">pg_upgrade</code> требуются права на запись в текущий каталог.</p><p>Очевидно, никто не должен обращаться к кластерам в процессе обновления. Программа <span class="application">pg_upgrade</span> по умолчанию запускает серверы с портом 50432, чтобы не допустить нежелательных клиентских подключений. В процессе обновления оба кластера могут использовать один номер порта, так как они не будут работать одновременно. Однако для проверки старого работающего сервера новый порт должен отличаться от старого.</p><p>Если при восстановлении схемы базы данных происходит ошибка, <code class="command">pg_upgrade</code> завершает свою работу и вы должны вернуться к старому кластеру, как описывается ниже в <a class="xref" href="pgupgrade.html#PGUPGRADE-STEP-REVERT" title="Возврат к старому кластеру">Шаг 17</a>. Чтобы попробовать <code class="command">pg_upgrade</code> ещё раз, вы должны внести коррективы в старом кластере, чтобы pg_upgrade могла успешно восстановить схему. Если проблема возникла в модуле <code class="filename">contrib</code>, может потребоваться удалить этот модуль <code class="filename">contrib</code> в старом кластере, а затем установить его в новом после обновления (предполагается, что этот модуль не хранит пользовательские данные).</p></li><li class="step" id="PGUPGRADE-STEP-REPLICAS"><p class="title"><strong>Обновить ведомые серверы с потоковой репликацией и трансляцией журнала</strong></p><p>Если вы используете режим ссылок и у вас реализована потоковая репликация (см. <a class="xref" href="warm-standby.html#STREAMING-REPLICATION" title="27.2.5. Потоковая репликация">Подраздел 27.2.5</a>) или трансляция журнала (см. <a class="xref" href="warm-standby.html" title="27.2. Трансляция журналов на резервные серверы">Раздел 27.2</a>) для ведомых серверов, вы можете быстро обновить эти серверы следующим образом. Вам не нужно будет запускать на них <span class="application">pg_upgrade</span>, вместо этого вы выполните <span class="application">rsync</span> на ведущем. Не запускайте никакие серверы на этом этапе.</p><p>Если вы <span class="emphasis"><em>не</em></span> используете режим ссылок, либо у вас нет <span class="application">rsync</span> или вы не хотите его использовать, либо если вам нужен более простой вариант, пропустите инструкции в этом разделе и просто пересоздайте ведомые серверы сразу после завершения <span class="application">pg_upgrade</span> и запуска нового ведущего сервера.</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p class="title"><strong>Установите новые исполняемые файлы PostgreSQL на ведомых серверах</strong></p><p>Убедитесь в том, что на всех ведомых серверах установлены новые исполняемые и вспомогательные файлы.</p></li><li class="step"><p class="title"><strong>Убедитесь в том, что новые каталоги данных на ведомых серверах <span class="emphasis"><em>не</em></span> существуют</strong></p><p>Новые каталоги данных ведомых серверов должны <span class="emphasis"><em>отсутствовать</em></span> либо быть пустыми. Если запускалась программа <span class="application">initdb</span>, удалите новые каталоги данных на ведомых.</p></li><li class="step"><p class="title"><strong>Установить разделяемые объектные файлы расширения</strong></p><p>Установите на новых ведомых серверах те же разделяемые объектные файлы расширения, что вы установили в новом ведущем кластере.</p></li><li class="step"><p class="title"><strong>Остановите ведомые серверы</strong></p><p>Если ведомые серверы продолжают работу, остановите их, следуя приведённым выше инструкциям.</p></li><li class="step"><p class="title"><strong>Сохраните файлы конфигурации</strong></p><p>Сохраните все нужные вам файлы конфигурации из старых каталогов конфигурации ведомых серверов, в частности <code class="filename">postgresql.conf</code> (и все файлы, включённые в него), <code class="filename">postgresql.auto.conf</code> и <code class="literal">pg_hba.conf</code>, так как они будут перезаписаны или удалены на следующем этапе.</p></li><li class="step"><p class="title"><strong>Запустите <span class="application">rsync</span></strong></p><p>Когда используется режим ссылок, ведомые серверы можно быстро обновить, применив <span class="application">rsync</span>. Для этого в каталоге, внутри которого находятся каталоги старого и нового кластера, для каждого ведомого сервера выполните на <span class="emphasis"><em>ведущем</em></span>: </p><pre class="programlisting">rsync --archive --delete --hard-links --size-only --no-inc-recursive old_cluster new_cluster remote_dir</pre><p> Здесь каталоги <code class="option">old_cluster</code> и <code class="option">new_cluster</code> задаются относительно текущего каталога на ведущем, а <code class="option">remote_dir</code> находится <span class="emphasis"><em>над</em></span> каталогами старого и нового кластера на ведомом. Структура подкаталогов в заданных каталогах на ведущем и ведомых серверах должна быть одинаковой. Обратитесь к странице руководства <span class="application">rsync</span>, где подробно описано, как указать удалённый каталог, например так: </p><pre class="programlisting">rsync --archive --delete --hard-links --size-only --no-inc-recursive /opt/PostgreSQL/12 \
      /opt/PostgreSQL/16 standby.example.com:/opt/PostgreSQL</pre><p> Проверить, что будет делать команда, можно, воспользовавшись параметром <span class="application">rsync</span> <code class="option">--dry-run</code>. Выполнить <span class="application">rsync</span> на ведущем необходимо как минимум с одним ведомым, но затем, пока обновлённый ведомый остаётся остановленным, можно запускать <span class="application">rsync</span> на нём для обновления других ведомых.</p><p>В ходе этой операции записываются ссылки, созданные режимом ссылок <span class="application">pg_upgrade</span>, связывающие файлы нового и старого кластера на ведущем сервере. Затем в старом кластере ведомого находятся соответствующие файлы и в новом кластере ведомого создаются ссылки на них. Файлы, не связанные ссылками на ведущем, копируются с него на ведомый. (Обычно их объём невелик.) Это позволяет произвести обновление ведомого быстро. К сожалению, при этом <span class="application">rsync</span> будет напрасно копировать файлы, связанные с временными и нежурналируемыми таблицами, так как они обычно не будут существовать на ведомых серверах.</p><p>Если у вас есть табличные пространства, вам потребуется выполнить подобную команду <span class="application">rsync</span> для каталогов всех табличных пространств, например: </p><pre class="programlisting">rsync --archive --delete --hard-links --size-only --no-inc-recursive /vol1/pg_tblsp/PG_12_201909212 \
      /vol1/pg_tblsp/PG_16_202307071 standby.example.com:/vol1/pg_tblsp</pre><p> Если вы вынесли <code class="filename">pg_wal</code> за пределы каталогов данных, нужно будет запустить <span class="application">rsync</span> и для этих каталогов.</p></li><li class="step"><p class="title"><strong>Настройте ведомые серверы с потоковой репликацией и трансляцией журнала</strong></p><p>Настройте серверы для трансляции журнала. (Запускать <code class="function">pg_backup_start()</code> и <code class="function">pg_backup_stop()</code> или делать копию файловой системы не нужно, так как ведомые серверы остаются синхронизированными с ведущим.) Слоты репликации не копируются, их нужно создавать заново.</p></li></ol></div></li><li class="step"><p class="title"><strong>Восстановить <code class="filename">pg_hba.conf</code></strong></p><p>Если вы изменяли <code class="filename">pg_hba.conf</code>, восстановите его исходное состояние. Также может потребоваться скорректировать другие файлы конфигурации в новом кластере, чтобы они соответствовали старому, например, <code class="filename">postgresql.conf</code> (и файлы, включённые в него) и <code class="filename">postgresql.auto.conf</code>.</p></li><li class="step"><p class="title"><strong>Запустить новый сервер</strong></p><p>Теперь можно безопасно запустить новый сервер, а затем ведомые серверы, синхронизированные с ним с помощью <span class="application">rsync</span>.</p></li><li class="step"><p class="title"><strong>Действия после обновления</strong></p><p>Если после обновления требуются какие-то дополнительные действия, программа pg_upgrade выдаст предупреждения об этом по завершении работы. Она также сгенерирует файлы скриптов, которые должны запускаться администратором. Эти скрипты будут подключаться к каждой базе данных, требующей дополнительных операций. Каждый такой скрипт следует выполнять командой: </p><pre class="programlisting">psql --username=postgres --file=script.sql postgres</pre><p> Эти скрипты могут выполняться в любом порядке, а после выполнения их можно удалить.</p><div class="caution"><h3 class="title">Внимание</h3><p>Обычно к таблицам, задействованным в перестраивающих базу скриптах, опасно обращаться, пока эти скрипты не сделают свою работу; при этом можно получить некорректный результат или плохую производительность. К таблицам, не задействованным в таких скриптах, можно обращаться немедленно.</p></div></li><li class="step"><p class="title"><strong>Статистика</strong></p><p>Так как статистика оптимизатора не передаётся в процессе работы <code class="command">pg_upgrade</code>, вы получите указание запустить соответствующую команду для воссоздания этой информации после обновления. Возможно, для этого вам понадобится установить параметры подключения к новому кластеру.</p></li><li class="step"><p class="title"><strong>Удалить старый кластер</strong></p><p>Если вы удовлетворены результатами обновления, вы можете удалить каталоги данных старого кластера, запустив скрипт, упомянутый в выводе <code class="command">pg_upgrade</code> после обновления. (Автоматическое удаление невозможно, если в старом каталоге данных находятся дополнительные табличные пространства.) Также вы можете удалить каталоги старой инсталляции (например, <code class="filename">bin</code>, <code class="filename">share</code>).</p></li><li class="step" id="PGUPGRADE-STEP-REVERT"><p class="title"><strong>Возврат к старому кластеру</strong></p><p>Если выполнив команду <code class="command">pg_upgrade</code>, вы захотите вернуться к старому кластеру, возможны следующие варианты: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Если использовался ключ <code class="option">--check</code>, в старом кластере ничего не меняется; его можно просто перезапустить.</p></li><li class="listitem"><p>Если <span class="emphasis"><em>не</em></span> использовался ключ <code class="option">--link</code>, в старом кластере ничего не меняется; его можно просто перезапустить.</p></li><li class="listitem"><p>Если использовался ключ <code class="option">--link</code>, у старого и нового кластера могут оказаться общие файлы данных: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>Если работа <code class="command">pg_upgrade</code> была прервана до начала расстановки ссылок, в старом кластере ничего не меняется; его можно просто перезапустить.</p></li><li class="listitem"><p>Если вы <span class="emphasis"><em>не</em></span> запускали новый кластер, старый кластер не претерпел никаких изменений, за исключением того, что при создании ссылки на данные к имени <code class="filename">$PGDATA/global/pg_control</code> было добавлено окончание <code class="literal">.old</code>. Чтобы продолжить использование старого кластера, достаточно убрать окончание <code class="filename">.old</code> из имени файла <code class="filename">$PGDATA/global/pg_control</code>; после этого старый кластер можно будет перезапустить.</p></li><li class="listitem"><p>Если вы запускали новый кластер, он внёс изменения в общие файлы, и использовать старый кластер небезопасно. В этом случае старый кластер нужно будет восстановить из резервной копии.</p></li></ul></div></li></ul></div></li></ol></div></div><div class="refsect1" id="id-1.9.5.12.8"><h2>Замечания</h2><p>Программа <span class="application">pg_upgrade</span> создаёт различные временные файлы, например выгружая схему базы, в своём рабочем каталоге <code class="filename">pg_upgrade_output.d</code> внутри каталога данных нового кластера. При каждом запуске в этом рабочем каталоге создаётся подкаталог с именем, содержащим отметку времени в формате стандарта ISO 8601 (<code class="literal">%Y%m%dT%H%M%S</code>), и в данный подкаталог помещаются все создаваемые файлы. Каталог <code class="filename">pg_upgrade_output.d</code> со всем содержимым удаляется автоматически в случае успешного выполнения <span class="application">pg_upgrade</span>; но если возникает проблема, сохранённые в нём файлы могут быть полезны для диагностики.</p><p>Программа <span class="application">pg_upgrade</span> запускает на короткое время процессы postmaster со старым и новым каталогом данных. Временные файлы сокетов Unix для взаимодействия с этими процессами по умолчанию создаются в текущем рабочем каталоге. В некоторых ситуациях путь к файлу в текущем каталоге может оказаться слишком длинным для имени сокета. В этом случае вы можете передать параметр <code class="option">-s</code>, чтобы файлы сокетов создавались в другом каталоге с более коротким путём. В целях безопасности этот каталог не должен быть доступен для чтения и записи другим пользователям. (В Windows это не поддерживается.)</p><p>Программа <span class="application">pg_upgrade</span> сообщит обо всех актуальных для вашей инсталляции ошибках и потребностях перестроения или переиндексации базы; при этом будут созданы завершающие обновление скрипты, перестраивающие таблицы или индексы. Если вы попытаетесь автоматизировать обновление множества серверов, вы обнаружите, что для кластеров с одинаковыми схемами баз данных потребуются одинаковые действия после обновления; это объясняется тем, что эти действия диктуются схемой базы данных, а не данными пользователей.</p><p>Для проверки развёртывания новой версии создайте копию только схемы старого кластера, наполните этот кластер фиктивными данными, и попробуйте обновить его.</p><p><span class="application">pg_upgrade</span> не поддерживает обновление баз данных, в которых есть таблицы со столбцами, имеющими следующие системные типы данных <code class="type">reg*</code>, ссылающиеся на OID: </p><table border="0" summary="Simple list" class="simplelist"><tr><td><code class="type">regcollation</code></td></tr><tr><td><code class="type">regconfig</code></td></tr><tr><td><code class="type">regdictionary</code></td></tr><tr><td><code class="type">regnamespace</code></td></tr><tr><td><code class="type">regoper</code></td></tr><tr><td><code class="type">regoperator</code></td></tr><tr><td><code class="type">regproc</code></td></tr><tr><td><code class="type">regprocedure</code></td></tr></table><p> (Обновление <code class="type">regclass</code>, <code class="type">regrole</code> и <code class="type">regtype</code> поддерживается.)</p><p>Если вы хотите использовать режим ссылок на данные, но при этом исключить изменения в старом кластере при запуске нового, вам может подойти режим клонирования. Если же этот режим недоступен, сделайте копию старого кластера и обновите его в этом режиме. Чтобы получить рабочую копию старого кластера, воспользуйтесь командой <code class="command">rsync</code> и создайте предварительную копию кластера при работающем сервере, а затем отключите старый сервер и ещё раз запустите <code class="command">rsync --checksum</code>, чтобы привести эту копию в согласованное состояние. (Ключ <code class="option">--checksum</code> необходим, потому что <code class="command">rsync</code> различает время с точностью только до секунд.) При этом вы можете исключить некоторые файлы, например <code class="filename">postmaster.pid</code>, как описано в <a class="xref" href="continuous-archiving.html#BACKUP-LOWLEVEL-BASE-BACKUP" title="26.3.3. Создание базовой резервной копии через низкоуровневый API">Подразделе 26.3.3</a>. Если ваша файловая система поддерживает снимки файловой системы или копирование при записи, вы можете воспользоваться этим для создания копии старого кластера и табличных пространств; при этом важно, чтобы такие снимки и копии файлов создавались одномоментно или когда сервер баз данных отключён.</p></div><div class="refsect1" id="id-1.9.5.12.9"><h2>См. также</h2><span class="simplelist"><a class="xref" href="app-initdb.html" title="initdb"><span class="refentrytitle"><span class="application">initdb</span></span></a>, <a class="xref" href="app-pg-ctl.html" title="pg_ctl"><span class="refentrytitle"><span class="application">pg_ctl</span></span></a>, <a class="xref" href="app-pgdump.html" title="pg_dump"><span class="refentrytitle"><span class="application">pg_dump</span></span></a>, <a class="xref" href="app-postgres.html" title="postgres"><span class="refentrytitle"><span class="application">postgres</span></span></a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="pgtesttiming.html" title="pg_test_timing">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="reference-server.html" title="Серверные приложения PostgreSQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="pgwaldump.html" title="pg_waldump">След.</a></td></tr><tr><td width="40%" align="left" valign="top"><span class="application">pg_test_timing</span> </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> <span class="application">pg_waldump</span></td></tr></table></div></body></html>