<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>73.2. TOAST</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="storage-file-layout.html" title="73.1. Размещение файлов базы данных" /><link rel="next" href="storage-fsm.html" title="73.3. Карта свободного пространства" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">73.2. TOAST</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="storage-file-layout.html" title="73.1. Размещение файлов базы данных">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="storage.html" title="Глава 73. Физическое хранение базы данных">Наверх</a></td><th width="60%" align="center">Глава 73. Физическое хранение базы данных</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="storage-fsm.html" title="73.3. Карта свободного пространства">След.</a></td></tr></table><hr /></div><div class="sect1" id="STORAGE-TOAST"><div class="titlepage"><div><div><h2 class="title" style="clear: both">73.2. TOAST <a href="#STORAGE-TOAST" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="storage-toast.html#STORAGE-TOAST-ONDISK">73.2.1. Отдельное размещение TOAST на диске</a></span></dt><dt><span class="sect2"><a href="storage-toast.html#STORAGE-TOAST-INMEMORY">73.2.2. Отдельное размещение TOAST в памяти</a></span></dt></dl></div><a id="id-1.10.24.4.2" class="indexterm"></a><a id="id-1.10.24.4.3" class="indexterm"></a><p>В данном разделе рассматривается <acronym class="acronym">TOAST</acronym> (The Oversized-Attribute Storage Technique, Методика хранения сверхбольших атрибутов).</p><p><span class="productname">PostgreSQL</span> использует фиксированный размер страницы (обычно 8 КБ), и не позволяет кортежам занимать несколько страниц. Поэтому непосредственно хранить очень большие значения полей невозможно. Для преодоления этого ограничения большие значения полей сжимаются и/или разбиваются на несколько физических строк. Это происходит незаметно для пользователя и на большую часть кода сервера влияет незначительно. Этот метод известен как <acronym class="acronym">TOAST</acronym> (тост, или <span class="quote">«<span class="quote">лучшее после изобретения нарезанного хлеба</span>»</span>). Инфраструктура <acronym class="acronym">TOAST</acronym> также применяется для оптимизации обработки больших значений данных в памяти.</p><p>Лишь определённые типы данных поддерживают <acronym class="acronym">TOAST</acronym> — нет смысла производить дополнительные действия с типами данных, размер которых не может быть большим. Чтобы поддерживать <acronym class="acronym">TOAST</acronym>, тип данных должен представлять значение переменной длины (<em class="firstterm">varlena</em>), в котором первое четырёхбайтовое слово любого хранящегося значения содержит общую длину значения в байтах (включая само это слово). Содержание оставшейся части значения <acronym class="acronym">TOAST</acronym> не ограничивает. Специальные представления, в целом называемые <em class="firstterm">значениями в формате <acronym class="acronym">TOAST</acronym></em>, работают, манипулируя этим начальным словом длины и интерпретируя его по-своему. Таким образом, функции уровня C, работающие с типом данных, поддерживающим <acronym class="acronym">TOAST</acronym>, должны аккуратно обращаться со входными значениями, которые могут быть в формате <acronym class="acronym">TOAST</acronym>: входные данные могут и не содержать четырёхбайтовое слово длины и содержимое после него, пока не будут <em class="firstterm">распакованы</em>. (Обычно в таких ситуациях нужно использовать макрос <code class="function">PG_DETOAST_DATUM</code> прежде чем что-либо делать с входным значением, но в некоторых случаях возможны и более эффективные подходы. За подробностями обратитесь к <a class="xref" href="xtypes.html#XTYPES-TOAST" title="38.13.1. Особенности TOAST">Подразделу 38.13.1</a>.)</p><p><acronym class="acronym">TOAST</acronym> занимает два бита слова длины varlena (старшие биты на машинах с порядком байт от старшего к младшему, или младшие биты — при другом порядке байт), таким образом, логический размер любого значения в формате <acronym class="acronym">TOAST</acronym> ограничивается 1 Гигабайтом (2<sup>30</sup> - 1 байт). Когда оба бита равны нулю, значение является обычным, не в формате <acronym class="acronym">TOAST</acronym>, и оставшиеся биты слова длины задают общий размер элемента данных (включая слово длины) в байтах. Когда установлен старший (или младший, в зависимости от архитектуры) бит, значение имеет однобайтовый заголовок вместо обычного четырёхбайтового, а оставшиеся биты этого байта задают общий размер элемента данных (включая байт длины) в байтах. Этот вариант позволяет экономно хранить значения короче 127 байт и при этом допускает расширение значения этого типа данных до 1 Гбайта при необходимости. Значения с однобайтовыми заголовками не выравниваются по какой-либо определённой границе, тогда как значения с четырёхбайтовыми заголовками выравниваются по границе минимум четырёх байт; это избавление от выравнивания даёт дополнительный выигрыш в объёме, очень ощутимый для коротких значений. В качестве особого случая, если все оставшиеся биты однобайтового заголовка равны нулю (что в принципе невозможно с учётом включения размера длины), значением является указатель на отдельно размещённые данные, с несколькими возможными вариантами, описанными ниже. Тип и размер такого <em class="firstterm">указателя TOAST</em> определяется кодом, хранящимся во втором байте значения. Наконец, когда старший (или младший, в зависимости от архитектуры) бит очищен, а соседний бит установлен, содержимое данных хранится в упакованном виде и должно быть распаковано перед использованием. В этом случае оставшиеся биты четырёхбайтового слова длины задают общий размер сжатых, а не исходных данных. Заметьте, что сжатие также возможно и для отделённых данных, но заголовок varlena не говорит, имеет ли оно место — это определяется содержимым, на которое указывает указатель <acronym class="acronym">TOAST</acronym>.</p><p>Метод, который будет применяться для сжатия данных при внутреннем и внешнем хранении, можно выбрать для каждого отдельного столбца, задав параметр <code class="literal">COMPRESSION</code> в команде <code class="command">CREATE TABLE</code> или <code class="command">ALTER TABLE</code>. Если метод сжатия для столбца не задан явным образом, по умолчанию при вставке данных будет использоваться метод из параметра <a class="xref" href="runtime-config-client.html#GUC-DEFAULT-TOAST-COMPRESSION">default_toast_compression</a>.</p><p>Как уже было сказано, существуют разные варианты использования указателя <acronym class="acronym">TOAST</acronym>. Самый старый и наиболее популярный вариант — когда он указывает на отделённые данные, размещённые в <em class="firstterm"><acronym class="acronym">TOAST</acronym>-таблице</em>, которая отделена, но связана с таблицей, содержащей собственно указатель данных <acronym class="acronym">TOAST</acronym>. Такой указатель на данные <em class="firstterm">на диске</em> создаётся кодом обработки <acronym class="acronym">TOAST</acronym> (в <code class="filename">access/common/toast_internals.c</code>), когда кортеж, сохраняемый на диск, оказывается слишком большим. Дополнительные подробности описаны в <a class="xref" href="storage-toast.html#STORAGE-TOAST-ONDISK" title="73.2.1. Отдельное размещение TOAST на диске">Подразделе 73.2.1</a>. Кроме того, указатель <acronym class="acronym">TOAST</acronym> может указывать на отделённые данные, размещённые где-то в памяти. Такие данные обязательно недолговременные и никогда не оказываются на диске, но этот механизм очень полезен для исключения копирования и избыточной обработки данных большого размера. Дополнительные подробности описаны в <a class="xref" href="storage-toast.html#STORAGE-TOAST-INMEMORY" title="73.2.2. Отдельное размещение TOAST в памяти">Подразделе 73.2.2</a>.</p><div class="sect2" id="STORAGE-TOAST-ONDISK"><div class="titlepage"><div><div><h3 class="title">73.2.1. Отдельное размещение TOAST на диске <a href="#STORAGE-TOAST-ONDISK" class="id_link">#</a></h3></div></div></div><p>Если какие-либо столбцы таблицы хранятся в формате <acronym class="acronym">TOAST</acronym>, у таблицы будет связанная с ней таблица <acronym class="acronym">TOAST</acronym>, OID которой хранится в значении <code class="structname">pg_class</code>.<code class="structfield">reltoastrelid</code> для данной таблицы. Размещаемые на диске <acronym class="acronym">TOAST</acronym>-значения содержатся в таблице <acronym class="acronym">TOAST</acronym>, что подробнее описано ниже.</p><p>Отделённые значения делятся на порции (после сжатия, если оно применяется) размером не более <code class="symbol">TOAST_MAX_CHUNK_SIZE</code> байт (по умолчанию это значение выбирается таким образом, чтобы на странице помещались четыре строки порций, то есть размер одной составляет порядка 2000 байт). Каждая порция хранится как отдельная строка в таблице <acronym class="acronym">TOAST</acronym>, принадлежащей исходной таблице-владельцу. Каждая таблица <acronym class="acronym">TOAST</acronym> имеет столбцы <code class="structfield">chunk_id</code> (OID, идентифицирующий конкретное <acronym class="acronym">TOAST</acronym>-значение), <code class="structfield">chunk_seq</code> (последовательный номер для порции внутри значения) и <code class="structfield">chunk_data</code> (фактические данные порции). Уникальный индекс по <code class="structfield">chunk_id</code> и <code class="structfield">chunk_seq</code> обеспечивает быструю выдачу значений. Таким образом, в указателе, представляющем отдельно размещаемое на диске значение <acronym class="acronym">TOAST</acronym>, должно храниться OID таблицы <acronym class="acronym">TOAST</acronym>, к которой нужно обращаться, и OID определённого значения (его <code class="structfield">chunk_id</code>). Для удобства в данных указателя также хранится логический размер элемента данных (исходных данных без сжатия), фактический размер хранимых данных (отличающийся, если было применено сжатие) и используемый метод сжатия, если он задан. Учитывая байты заголовка varlena, общий размер указателя на хранимое на диске значение <acronym class="acronym">TOAST</acronym> составляет 18 байт, независимо от фактического размера собственно значения.</p><p>Код обработки <acronym class="acronym">TOAST</acronym> срабатывает, только когда значение строки, которое должно храниться в таблице, по размеру больше, чем <code class="symbol">TOAST_TUPLE_THRESHOLD</code> байт (обычно это 2 Кб). Код <acronym class="acronym">TOAST</acronym> будет сжимать и/или выносить значения поля за пределы таблицы до тех пор, пока значение строки не станет меньше <code class="symbol">TOAST_TUPLE_TARGET</code> байт (переменная величина, так же обычно 2 Кб) или уменьшить объём станет невозможно. Во время операции UPDATE значения неизменённых полей обычно сохраняются как есть, поэтому модификация строки с отдельно хранимыми значениями не несёт издержек, связанных с <acronym class="acronym">TOAST</acronym>, если все такие значения остаются без изменений.</p><p>Код обработки <acronym class="acronym">TOAST</acronym> распознаёт четыре различные стратегии хранения столбцов, совместимых с <acronym class="acronym">TOAST</acronym>, на диске: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">PLAIN</code> не допускает ни сжатия, ни отдельного хранения. Это единственно возможная стратегия для столбцов типов данных, которые несовместимы с <acronym class="acronym">TOAST</acronym>.</p></li><li class="listitem"><p><code class="literal">EXTENDED</code> допускает как сжатие, так и отдельное хранение. Это стандартный вариант для большинства типов данных, совместимых с <acronym class="acronym">TOAST</acronym>. Сначала происходит попытка выполнить сжатие, затем — сохранение вне таблицы, если строка всё ещё слишком велика.</p></li><li class="listitem"><p><code class="literal">EXTERNAL</code> допускает отдельное хранение, но не сжатие. Использование <code class="literal">EXTERNAL</code> ускорит операции над частями строк в больших столбцах <code class="type">text</code> и <code class="type">bytea</code> (ценой увеличения объёма памяти для хранения), так как эти операции оптимизированы для извлечения только требуемых частей отделённого значения, когда оно не сжато.</p></li><li class="listitem"><p><code class="literal">MAIN</code> допускает сжатие, но не отдельное хранение. (Фактически для таких столбцов будет тем не менее применяться отдельное хранение, но лишь как крайняя мера, когда нет другого способа уменьшить строку так, чтобы она помещалась на странице.)</p></li></ul></div><p> Каждый тип данных, совместимый с <acronym class="acronym">TOAST</acronym>, определяет стандартную стратегию для столбцов этого типа данных, но стратегия для заданного столбца таблицы может быть изменена с помощью <a class="link" href="sql-altertable.html" title="ALTER TABLE"><code class="command">ALTER TABLE ... SET STORAGE</code></a>.</p><p><code class="symbol">TOAST_TUPLE_TARGET</code> можно задавать на уровне таблиц с помощью команды <a class="link" href="sql-altertable.html" title="ALTER TABLE"><code class="command">ALTER TABLE ... SET (toast_tuple_target = N)</code></a></p><p>Эта схема имеет ряд преимуществ по сравнению с более простым подходом, когда значения строк могут занимать несколько страниц. Если предположить, что обычно запросы характеризуются выполнением сравнения с относительно маленькими значениями ключа, большая часть работы будет выполняться с использованием главной записи строки. Большие значения атрибутов в формате <acronym class="acronym">TOAST</acronym> будут просто передаваться (если будут выбраны) в тот момент, когда результирующий набор отправляется клиенту. Таким образом, главная таблица получается гораздо меньше, и в общий кеш буферов помещается больше её строк, чем их было бы без использования отдельного хранения. Наборы данных для сортировок также уменьшаются, а сортировки чаще будут выполняться исключительно в памяти. Небольшой тест показал, что таблица, содержащая типичные HTML-страницы и их URL после сжатия занимала примерно половину объёма исходных данных, включая таблицу <acronym class="acronym">TOAST</acronym>, и что главная таблица содержала лишь около 10% всех данных (URL и некоторые маленькие HTML-страницы). Время обработки не отличалось от времени, необходимого для обработки таблицы без использования <acronym class="acronym">TOAST</acronym>, в которой размер всех HTML-страниц был уменьшен до 7 Кб, чтобы они уместились в строках.</p></div><div class="sect2" id="STORAGE-TOAST-INMEMORY"><div class="titlepage"><div><div><h3 class="title">73.2.2. Отдельное размещение TOAST в памяти <a href="#STORAGE-TOAST-INMEMORY" class="id_link">#</a></h3></div></div></div><p>Указатели <acronym class="acronym">TOAST</acronym> могут указывать на данные, размещённые не на диске, а где-либо в памяти текущего серверного процесса. Очевидно, что такие указатели не могут быть долговременными, но они тем не менее полезны. В настоящее время поддерживаются два подварианта: <em class="firstterm">косвенные</em> указатели на данные и указатели на <em class="firstterm">развёрнутые</em> данные.</p><p>Косвенный указатель <acronym class="acronym">TOAST</acronym> просто указывает на значение varlena, хранящееся где-то в памяти. Этот вариант изначально был реализован просто как подтверждение концепции, но в настоящее время он применяется при логическом декодировании, чтобы не приходилось создавать физические кортежи больше одного 1 ГБ (что может потребоваться при консолидации всех отделённых значений полей в одном кортеже). Данный вариант имеет ограниченное применение, так как создатель такого указателя должен полностью понимать, что целевые данные будут существовать, только пока существует указатель, и никакой инфраструктуры для сохранения их нет.</p><p>Указатели на развёрнутые данные <acronym class="acronym">TOAST</acronym> полезны для сложных типов, представление которых на диске плохо приспособлено для вычислительных целей. Например, стандартное представление в виде varlena массива <span class="productname">PostgreSQL</span> включает информацию о размерности, битовую карту элементов NULL (если они в нём содержатся), а затем значения всех элементов по порядку. Когда элемент сам по себе имеет переменную длину, единственный способ найти <em class="replaceable"><code>N</code></em>-ый элемент — просканировать все предыдущие элементы. Это представление компактно и поэтому подходит для хранения на диске, но для вычислительной обработки массива гораздо удобнее иметь <span class="quote">«<span class="quote">развёрнутое</span>»</span> или <span class="quote">«<span class="quote">деконструированное</span>»</span> представление, в котором можно определить начальные адреса всех элементов. Механизм указателей <acronym class="acronym">TOAST</acronym> способствует решению этой задачи, допуская передачу по ссылке элемента Datum как указателя на стандартное значение varlena (представление на диске) или указателя <acronym class="acronym">TOAST</acronym> на развёрнутое представление где-то в памяти. Детали развёрнутого представление определяются самим типом данных, хотя оно может иметь стандартный заголовок и удовлетворять другим требованиям API, описанным в <code class="filename">src/include/utils/expandeddatum.h</code>. Функции уровня C, работающие с этим типом, могут реализовать поддержку любого из этих представлений. Функции, не знающие о развёрнутом представлении, а просто применяющие <code class="function">PG_DETOAST_DATUM</code> к своим входным данным, будут автоматически получать традиционное представление varlena; так что поддержка развёрнутого представления может вводиться постепенно, по одной функции.</p><p>Указатели <acronym class="acronym">TOAST</acronym> на развёрнутые значения далее подразделяются на указатели <em class="firstterm">для чтения/записи</em> и указатели <em class="firstterm">только для чтения</em>. Представление, на которое они указывают, в любом случае одинаковое, но функции, получающей указатель для чтения/записи, разрешается модифицировать целевые данные прямо на месте, тогда как функция, получающая указатель только для чтения, не должна этого делать; если ей нужно получить изменённую версию значения, она должна сначала сделать копию. Это отличие и связанные с ним соглашения позволяют избежать излишнего копирования развёрнутых значений при выполнении запросов.</p><p>Для всех типов указателей <acronym class="acronym">TOAST</acronym> на данные в памяти, код обработки <acronym class="acronym">TOAST</acronym> гарантирует, что такие данные не окажутся случайно сохранены на диске. Указатели <acronym class="acronym">TOAST</acronym> в памяти автоматически сворачиваются в обычные значения varlena перед сохранением — а затем могут преобразоваться в указатели <acronym class="acronym">TOAST</acronym> на диске, если без этого не смогут уместиться в содержащем их кортеже.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="storage-file-layout.html" title="73.1. Размещение файлов базы данных">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="storage.html" title="Глава 73. Физическое хранение базы данных">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="storage-fsm.html" title="73.3. Карта свободного пространства">След.</a></td></tr><tr><td width="40%" align="left" valign="top">73.1. Размещение файлов базы данных </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 73.3. Карта свободного пространства</td></tr></table></div></body></html>