<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CREATE TYPE</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sql-createtrigger.html" title="CREATE TRIGGER" /><link rel="next" href="sql-createuser.html" title="CREATE USER" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">CREATE TYPE</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-createtrigger.html" title="CREATE TRIGGER">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><th width="60%" align="center">Команды SQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-createuser.html" title="CREATE USER">След.</a></td></tr></table><hr /></div><div class="refentry" id="SQL-CREATETYPE"><div class="titlepage"></div><a id="id-1.9.3.94.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">CREATE TYPE</span></h2><p>CREATE TYPE — создать новый тип данных</p></div><div class="refsynopsisdiv"><h2>Синтаксис</h2><pre class="synopsis">CREATE TYPE <em class="replaceable"><code>имя</code></em> AS
    ( [ <em class="replaceable"><code>имя_атрибута</code></em> <em class="replaceable"><code>тип_данных</code></em> [ COLLATE <em class="replaceable"><code>правило_сортировки</code></em> ] [, ... ] ] )

CREATE TYPE <em class="replaceable"><code>имя</code></em> AS ENUM
    ( [ '<em class="replaceable"><code>метка</code></em>' [, ... ] ] )

CREATE TYPE <em class="replaceable"><code>имя</code></em> AS RANGE (
    SUBTYPE = <em class="replaceable"><code>подтип</code></em>
    [ , SUBTYPE_OPCLASS = <em class="replaceable"><code>класс_оператора_подтипа</code></em> ]
    [ , COLLATION = <em class="replaceable"><code>правило_сортировки</code></em> ]
    [ , CANONICAL = <em class="replaceable"><code>функция_нормализации</code></em> ]
    [ , SUBTYPE_DIFF = <em class="replaceable"><code>функция_разницы_подтипа</code></em> ]
    [ , MULTIRANGE_TYPE_NAME = <em class="replaceable"><code>имя_мультидиапазонного_типа</code></em> ]
)

CREATE TYPE <em class="replaceable"><code>имя</code></em> (
    INPUT = <em class="replaceable"><code>функция_ввода</code></em>,
    OUTPUT = <em class="replaceable"><code>функция_вывода</code></em>
    [ , RECEIVE = <em class="replaceable"><code>функция_получения</code></em> ]
    [ , SEND = <em class="replaceable"><code>функция_отправки</code></em> ]
    [ , TYPMOD_IN = <em class="replaceable"><code>функция_ввода_модификатора_типа</code></em> ]
    [ , TYPMOD_OUT = <em class="replaceable"><code>функция_вывода_модификатора_типа</code></em> ]
    [ , ANALYZE = <em class="replaceable"><code>функция_анализа</code></em> ]
    [ , SUBSCRIPT = <em class="replaceable"><code>функция_обращения_по_индексу</code></em> ]
    [ , INTERNALLENGTH = { <em class="replaceable"><code>внутр_длина</code></em> | VARIABLE } ]
    [ , PASSEDBYVALUE ]
    [ , ALIGNMENT = <em class="replaceable"><code>выравнивание</code></em> ]
    [ , STORAGE = <em class="replaceable"><code>хранение</code></em> ]
    [ , LIKE = <em class="replaceable"><code>тип_образец</code></em> ]
    [ , CATEGORY = <em class="replaceable"><code>категория</code></em> ]
    [ , PREFERRED = <em class="replaceable"><code>предпочитаемый</code></em> ]
    [ , DEFAULT = <em class="replaceable"><code>по_умолчанию</code></em> ]
    [ , ELEMENT = <em class="replaceable"><code>элемент</code></em> ]
    [ , DELIMITER = <em class="replaceable"><code>разделитель</code></em> ]
    [ , COLLATABLE = <em class="replaceable"><code>сортируемый</code></em> ]
)

CREATE TYPE <em class="replaceable"><code>имя</code></em></pre></div><div class="refsect1" id="id-1.9.3.94.5"><h2>Описание</h2><p><code class="command">CREATE TYPE</code> регистрирует новый тип данных для использования в текущей базе данных. Владельцем типа становится создавший его пользователь.</p><p>Если указано имя схемы, тип создаётся в указанной схеме. В противном случае он создаётся в текущей схеме. Имя типа должно отличаться от имён любых других существующих типов или доменов в той же схеме. (А так как с таблицами связываются типы данных, имя типа должно также отличаться и от имён существующих таблиц в этой схеме.)</p><p>Команда <code class="command">CREATE TYPE</code> имеет пять форм, показанных выше в сводке синтаксиса. Они создают соответственно <em class="firstterm">составной тип</em>, <em class="firstterm">перечисление</em>, <em class="firstterm">диапазон</em>, <em class="firstterm">базовый тип</em> или <em class="firstterm">тип-пустышку</em>. Первые четыре эти типа рассматриваются по порядку ниже. Тип-пустышка представляет собой просто заготовку для типа, который будет определён позже; он создаётся командой <code class="command">CREATE TYPE</code> с одним именем, без параметров. Типы-пустышки необходимы для определения прямых ссылок при создании базовых типов и типов-диапазонов, как описывается в соответствующих разделах.</p><div class="refsect2" id="id-1.9.3.94.5.5"><h3>Составные типы</h3><p>Первая форма <code class="command">CREATE TYPE</code> создаёт составной тип. Составной тип задаётся списком имён и типами данных атрибутов. Если тип данных является сортируемым, то для атрибута можно также задать правило сортировки. Составной тип по сути не отличается от типа строки таблицы, но <code class="command">CREATE TYPE</code> избавляет от необходимости создавать таблицу, когда всё, что нужно, это создать тип. Отдельный составной тип может быть полезен, например, для передачи аргументов или результатов функции.</p><p>Чтобы создать составной тип, необходимо иметь право <code class="literal">USAGE</code> для типов всех его атрибутов.</p></div><div class="refsect2" id="SQL-CREATETYPE-ENUM"><h3>Типы перечислений</h3><p>Вторая форма <code class="command">CREATE TYPE</code> создаёт тип-перечисление (такие типы описываются в <a class="xref" href="datatype-enum.html" title="8.7. Типы перечислений">Разделе 8.7</a>). Перечисления принимают список меток в кавычках. Максимальная длина каждой метки — <code class="symbol">NAMEDATALEN</code> байт (64 байта в стандартной сборке <span class="productname">PostgreSQL</span>). (Также возможно создать перечисляемый тип без меток, но этот тип нельзя будет использовать для хранения значений, пока командой <a class="link" href="sql-altertype.html" title="ALTER TYPE"><code class="command">ALTER TYPE</code></a> не будет добавлена хотя бы одна метка.)</p></div><div class="refsect2" id="SQL-CREATETYPE-RANGE"><h3>Диапазонные типы</h3><p>Третья форма <code class="command">CREATE TYPE</code> создаёт тип-диапазон (такие типы описываются в <a class="xref" href="rangetypes.html" title="8.17. Диапазонные типы">Разделе 8.17</a>).</p><p>Задаваемый для диапазона <em class="replaceable"><code>подтип</code></em> может быть любым типом со связанным классом операторов B-дерева (что позволяет определить порядок значений в диапазоне). Обычно порядок элементов определяет класс операторов B-дерева по умолчанию, но его можно изменить, задав имя другого класса в параметре <em class="replaceable"><code>класс_операторов_подтипа</code></em>. Если подтип поддерживает сортировку и требуется, чтобы значения упорядочивались с нестандартным правилом сортировки, его имя можно задать в параметре <em class="replaceable"><code>правило_сортировки</code></em>.</p><p>Необязательная <em class="replaceable"><code>функция_нормализации</code></em> должна принимать один аргумент определяемого типа диапазона и возвращать значение того же типа. Она используется для преобразования значений диапазона в нормализованную форму, когда это уместно. За дополнительными сведениями обратитесь к <a class="xref" href="rangetypes.html#RANGETYPES-DEFINING" title="8.17.8. Определение новых диапазонных типов">Подразделу 8.17.8</a>. Создаётся <em class="replaceable"><code>функция_нормализации</code></em> несколько нетривиально, так как она должна быть уже определена, прежде чем можно будет объявить тип-диапазон. Для этого нужно сначала создать тип-пустышку, который будет заготовкой типа, не имеющей никаких свойств, кроме имени и владельца. Это можно сделать, выполнив команду <code class="literal">CREATE TYPE <em class="replaceable"><code>имя</code></em></code> без дополнительных параметров. Затем можно объявить функцию, для которой тип-пустышка будет типом аргумента и результата, и, наконец, объявить тип-диапазон с тем же именем. При этом тип-пустышка автоматически заменится полноценным типом-диапазоном.</p><p>Необязательная <em class="replaceable"><code>функция_разницы_подтипа</code></em> должна принимать в аргументах два значения типа <em class="replaceable"><code>подтип</code></em> и возвращать значение <code class="type">double precision</code>, представляющее разницу между двумя данными значениями. Хотя эту функцию можно не использовать, она позволяет кардинально увеличить эффективность индексов GiST для столбцов с типом-диапазоном. За дополнительными сведениями обратитесь к <a class="xref" href="rangetypes.html#RANGETYPES-DEFINING" title="8.17.8. Определение новых диапазонных типов">Подразделу 8.17.8</a>.</p><p>В необязательном параметре <em class="replaceable"><code>имя_мультидиапазонного_типа</code></em> задаётся имя соответствующего типа. В отсутствие данного параметра имя этого типа выбирается автоматически следующим образом. Если имя диапазонного типа содержит подстроку <code class="literal">range</code>, в имени мультидиапазонного типа она заменяется подстрокой <code class="literal">multirange</code>. В противном случае к имени диапазонного типа добавляется окончание <code class="literal">_multirange</code>.</p></div><div class="refsect2" id="id-1.9.3.94.5.8"><h3>Базовые типы</h3><p>Четвёртая форма <code class="command">CREATE TYPE</code> создаёт новый базовый тип (скалярный тип). Чтобы создать новый базовый тип, нужно быть суперпользователем. (Это ограничение введено потому, что ошибочное определение типа может вызвать нарушения или даже сбой в работе сервера.)</p><p>Эти параметры могут перечисляться в любом порядке, не только в показанном выше, и большинство из них необязательные. Прежде чем создавать тип, необходимо зарегистрировать две или более функций (с помощью <code class="command">CREATE FUNCTION</code>). Обязательными являются функции <em class="replaceable"><code>функция_ввода</code></em> и <em class="replaceable"><code>функция_вывода</code></em>, тогда как <em class="replaceable"><code>функция_получения</code></em>, <em class="replaceable"><code>функция_отправки</code></em>, <em class="replaceable"><code>функция_модификатора_типа</code></em>, <em class="replaceable"><code>функция_вывода_модификатора_типа</code></em>, <em class="replaceable"><code>функция_анализа</code></em> и <em class="replaceable"><code>функция_обращения_по_индексу</code></em> могут отсутствовать. Обычно эти функции разрабатываются на C или другом низкоуровневом языке.</p><p><em class="replaceable"><code>Функция_ввода</code></em> преобразует внешнее текстовое представление типа во внутреннее, с которым работают операторы и функции, определённые для этого типа. <em class="replaceable"><code>Функция_вывода</code></em> выполняет обратное преобразование. Функцию ввода можно объявить как принимающую один аргумент типа <code class="type">cstring</code>, либо как принимающую три аргумента типов <code class="type">cstring</code>, <code class="type">oid</code> и <code class="type">integer</code>. В первом аргументе передаётся вводимый текст в виде строки в стиле C, во втором аргументе — собственный OID типа (кроме типов массивов, для которых передаётся OID типа элемента), а в третьем — <code class="literal">модификатор_типа</code> для целевого столбца, если он определён (или -1 в противном случае). Функция ввода должна возвращать значение нового типа данных. Обычно функция ввода должна быть строгой (STRICT); если это не так, при получении на вход значения NULL она будет вызываться с первым параметром NULL. Функция может в этом случае сама вернуть NULL или вызвать ошибку. (Это полезно в основном для поддержки функций ввода доменных типов, которые не должны принимать данные NULL.) Функция вывода должна принимать один аргумент нового типа данных, а возвращать она должна <code class="type">cstring</code>. Для значений NULL функции вывода не вызываются.</p><p>Необязательная <em class="replaceable"><code>функция_получения</code></em> преобразует двоичное внешнее представление типа во внутреннее представление. Если эта функция отсутствует, новый тип не сможет участвовать в двоичном вводе. Двоичное представление следует выбирать таким, чтобы оно легко переводилось во внутреннюю форму и при этом было переносимым до разумной степени. (Например, для стандартных целочисленных типов данных во внешнем двоичном представлении выбран сетевой порядок байтов, тогда как внутреннее представление определяется порядком байтов в процессоре.) Функция получения должна выполнить проверку вводимого значения на допустимость. Функция получения может быть объявлена как принимающая один аргумент типа <code class="type">internal</code>, либо как принимающая три аргумента типов <code class="type">internal</code>, <code class="type">oid</code> и <code class="type">integer</code>. В первом аргументе передаётся указатель на буфер <code class="type">StringInfo</code>, содержащий полученную байтовую строку, а дополнительные аргументы такие же, как и для функции ввода текста. Функция получения должна возвращать значение нового типа данных. Обычно функция получения должна быть строгой (STRICT); если это не так, при получении на вход значения NULL, она будет вызываться с первым параметром NULL. Функция может в этом случае сама вернуть NULL или вызывать ошибку. (Это полезно в основном для поддержки функций получения доменных типов, которые не должны принимать значения NULL.) Подобным образом, необязательная <em class="replaceable"><code>функция_отправки</code></em> преобразует данные из внутреннего во внешнее двоичное представление. Если эта функция не определена, новый тип не может участвовать в двоичном выводе. Функция отправки должна принимать один аргумент нового типа данных, а возвращать она должна <code class="type">bytea</code>. Для значений NULL функции отправки не вызываются.</p><p>Здесь у вас может возникнуть вопрос, как функции ввода и вывода могут быть объявлены принимающими или возвращающими значения нового типа, если они должны быть созданы до объявления нового типа. Ответ довольно прост: сначала нужно создать <em class="firstterm">тип-пустышку</em>, который будет заготовкой типа, не имеющей никаких свойств, кроме имени и владельца. Это можно сделать, выполнив команду <code class="literal">CREATE TYPE <em class="replaceable"><code>имя</code></em></code> без дополнительных параметров. Затем можно будет определить функции ввода/вывода на C, ссылающиеся на этот тип. И наконец, команда <code class="command">CREATE TYPE</code> с полным определением заменит тип-пустышку окончательным и полноценным определением, после чего новый тип можно будет использовать как обычно.</p><p>Необязательные <em class="replaceable"><code>функция_ввода_модификатора_типа</code></em> и <em class="replaceable"><code>функция_вывода_модификатора_типа</code></em> требуются, только если типы поддерживают модификаторы, или, другими словами, дополнительные ограничения, связываемые с объявлением типа, например <code class="literal">char(5)</code> или <code class="literal">numeric(30,2)</code>. В <span class="productname">PostgreSQL</span> типы могут принимать в качестве модификаторов одну или несколько простых констант или идентификаторов. Однако эти данные должны упаковываться в единственное неотрицательное целочисленное значение, которое и будет храниться в системных каталогах. <em class="replaceable"><code>Функция_ввода_модификатора_типа</code></em> получает объявленные модификаторы в виде строки <code class="type">cstring</code>. Она должна проверить значения на допустимость (и вызвать ошибку, если они неверны), а затем выдать неотрицательное значение <code class="type">integer</code>, которое будет сохранено в столбце <span class="quote">«<span class="quote">typmod</span>»</span>. Если для типа не определена <em class="replaceable"><code>функция_ввода_модификатора_типа</code></em>, модификаторы типа приниматься не будут. <em class="replaceable"><code>Функция_вывода_модификатора_типа</code></em> преобразует внутреннее целочисленное значение typmod обратно, в форму, понятную пользователю. Она должна вернуть значение <code class="type">cstring</code>, которое именно в этом виде будет добавлено к имени типа; например, функция для <code class="type">numeric</code> должна вернуть <code class="literal">(30,2)</code>. <em class="replaceable"><code>Функция_вывода_модификатора_типа</code></em> может быть опущена, в этом случае сохранённое целочисленное значение typmod по умолчанию будет выводиться просто в виде числа, заключённого в скобки.</p><p>Необязательная <em class="replaceable"><code>функция_анализа</code></em> выполняет сбор специфической для этого типа статистики в столбцах с таким типом данных. По умолчанию <code class="command">ANALYZE</code> пытается собрать статистику, используя операторы <span class="quote">«<span class="quote">равно</span>»</span> и <span class="quote">«<span class="quote">меньше</span>»</span>, если для этого типа определён класс операторов B-дерева по умолчанию. Для нескалярных типов это поведение скорее всего не подойдёт, поэтому его можно переопределить, задав собственную функцию анализа. Эта функция должна принимать единственный аргумент типа <code class="type">internal</code> и возвращать результат <code class="type">boolean</code>. Более глубоко API функций анализа описан в <code class="filename">src/include/commands/vacuum.h</code>.</p><p>Необязательное указание <em class="replaceable"><code>функции_обращения_по_индексу</code></em> позволяет добавить для типа возможность обращения по индексу в SQL-командах. Указание этой функции не делает тип <span class="quote">«<span class="quote">настоящим</span>»</span> массивом; например, такой тип не будет рассматриваться как возможный тип результата конструкций <code class="literal">ARRAY[]</code>. Но если извлечение значений при обращении по индексу для некоторого типа выглядит естественным, заданная <em class="replaceable"><code>функция_обращения_по_индексу</code></em> позволяет определить, что именно подразумевается под таким обращением. Данная функция должна объявляться как принимающая один аргумент типа <code class="type">internal</code> и возвращающая результат типа <code class="type">internal</code>, в котором передаётся указатель на структуру с методами (функциями), реализующими обращение по индексу. В деталях API этих методов описывается в <code class="filename">src/include/nodes/subscripting.h</code>. Также может быть полезно изучить реализацию массивов в <code class="filename">src/backend/utils/adt/arraysubs.c</code> или более простой код в <code class="filename">contrib/hstore/hstore_subs.c</code>. Дополнительная информация приведена в <a class="xref" href="sql-createtype.html#SQL-CREATETYPE-ARRAY" title="Типы массивов">Типы массивов</a> ниже.</p><p>Если особенности внутреннего представления нового типа известны функциям ввода/вывода и другим функциям, созданным специально для работы с этим типом, необходимо определить ряд характеристик внутреннего представления, о которых должен знать <span class="productname">PostgreSQL</span>. В первую очередь это <em class="replaceable"><code>internallength</code></em> (внутренняя длина). Если базовый тип данных имеет фиксированную длину, в <em class="replaceable"><code>internallength</code></em> указывается эта длина в виде положительного числа, а если длина переменная, в <em class="replaceable"><code>internallength</code></em> задаётся значение <code class="literal">VARIABLE</code>. (Внутри при этом <code class="literal">typlen</code> принимает значение -1.) Внутреннее представление всех типов переменной длины должно начинаться с 4-байтового целого, задающего общую длину значения этого типа. (Заметьте, что поле длины часто кодируется, как описано в <a class="xref" href="storage-toast.html" title="73.2. TOAST">Разделе 73.2</a>; обращаться к нему напрямую неразумно.)</p><p>Необязательный флаг <code class="literal">PASSEDBYVALUE</code> указывает, что значения этого типа данных передаются по значению, а не по ссылке. Типы, передаваемые по значению, должны быть фиксированной длины и их внутреннее представление не может быть больше размера типа <code class="type">Datum</code> (4 байта на одних машинах, 8 — на других).</p><p>Параметр <em class="replaceable"><code>выравнивание</code></em> определяет, как требуется выравнивать данные этого типа. Допускается выравнивание по границам 1, 2, 4 или 8 байт. Заметьте, что типы переменной длины должны быть выровнены как минимум по границе 4 байт, так как их первым компонентом обязательно должен быть <code class="type">int4</code>.</p><p>Параметр <em class="replaceable"><code>хранение</code></em> позволяет выбрать стратегию хранения для типов данных переменной длины. (Для типов с фиксированной длиной поддерживается только вариант <code class="literal">plain</code>.) Если выбрана стратегия <code class="literal">plain</code>, данные этого типа всегда хранятся внутри, без сжатия. Со стратегией <code class="literal">extended</code> система сначала попытается сжать большое значение, а затем выносит его из строки основной таблицы, если оно всё же окажется слишком большим. С <code class="literal">external</code> значение может быть вынесено из основной таблицы, но система не будет пытаться сжать его. Стратегия <code class="literal">main</code> позволяет сжать данные, но не стремится вынести их из основной таблицы. (Элементы данных с этой стратегией хранения тем не менее могут быть вынесены из основной таблицы, если другого способа уместить их в строке нет, но всё же она отдаёт большее предпочтение основной таблице, по сравнению со стратегиями <code class="literal">extended</code> и <code class="literal">external</code>.)</p><p>Значения параметра <em class="replaceable"><code>хранение</code></em>, отличные от <code class="literal">plain</code>, подразумевают, что функции типа данных могут принимать значения в формате <em class="firstterm">toast</em>, описанном в <a class="xref" href="storage-toast.html" title="73.2. TOAST">Разделе 73.2</a> и <a class="xref" href="xtypes.html#XTYPES-TOAST" title="38.13.1. Особенности TOAST">Подразделе 38.13.1</a>. Эти значения просто определяют стратегию хранения TOAST по умолчанию для столбцов отделяемого в TOAST типа данных; пользователи могут выбирать другие стратегии для отдельных столбцов, применяя команду <code class="literal">ALTER TABLE SET STORAGE</code>.</p><p>Параметр <em class="replaceable"><code>тип_образец</code></em> позволяет задать основные свойства представления типа другим способом: скопировать их из существующего типа. В частности, из указанного типа будут скопированы свойства <em class="replaceable"><code>internallength</code></em>, <em class="replaceable"><code>passedbyvalue</code></em>, <em class="replaceable"><code>alignment</code></em> и <em class="replaceable"><code>storage</code></em>. (Также возможно, хотя обычно это не требуется, переопределить некоторые из этих значений, указав их вместе с предложением <code class="literal">LIKE</code>.) Определять представление типа таким образом особенно удобно, когда низкоуровневая реализация нового типа некоторым образом опирается на существующий тип.</p><p>Параметры <em class="replaceable"><code>категория</code></em> и <em class="replaceable"><code>предпочитаемый</code></em> позволяют определять, какое неявное приведение будет применяться в неоднозначных ситуациях. Каждый тип данных принадлежит к некоторой категории, обозначаемой одним символом ASCII, при этом он может быть, либо не быть <span class="quote">«<span class="quote">предпочитаемым</span>»</span> в этой категории. Анализатор запроса по возможности выберет приведение к предпочитаемому типу (но только среди других типов той же категории), когда это может помочь разрешить имя перегруженной функции или оператора. За дополнительными подробностями обратитесь к <a class="xref" href="typeconv.html" title="Глава 10. Преобразование типов">Главе 10</a>. Если для типа не определено неявное приведение к какому-либо другому типу или обратное, для этих параметров достаточно оставить значения по умолчанию. Однако если есть группа связанных типов, для которых определены неявные приведения, часто бывает полезно пометить их все как принадлежащие некоторой категории и назначить один или два <span class="quote">«<span class="quote">наиболее общих</span>»</span> предпочитаемыми в этой категории. Параметр <em class="replaceable"><code>категория</code></em> особенно полезен при добавлении типа, определённого пользователем, в существующую встроенную категорию, например, в категорию числовых или строковых типов. Однако так же возможно создать категории типов, полностью определённые пользователем. В качестве имени такой категории можно выбрать любой ASCII-символ, кроме латинской заглавной буквы.</p><p>Если пользователь хочет назначить столбцам с этим типом данных значение по умолчанию, отличное от NULL, он может задать его в этой команде, указав его после ключевого слова <code class="literal">DEFAULT</code>. (Такое значение по умолчанию можно переопределить явным предложением <code class="literal">DEFAULT</code>, добавленным при создании столбца.)</p><p>Чтобы обозначить, что тип является массивом фиксированной длины, укажите тип элементов массива, воспользовавшись ключевым словом <code class="literal">ELEMENT</code>. Например, чтобы определить массив из четырёхбайтовых целых (<code class="type">int4</code>), укажите <code class="literal">ELEMENT = int4</code>. За подробностями обратитесь к <a class="xref" href="sql-createtype.html#SQL-CREATETYPE-ARRAY" title="Типы массивов">Типы массивов</a>.</p><p>Параметр <em class="replaceable"><code>delimiter</code></em> позволяет задать разделитель, который будет вставляться между значениями во внешнем представлении массива с элементами этого типа. По умолчанию разделителем является запятая (<code class="literal">,</code>). Заметьте, что разделитель связывается с типом элементов массива, а не с типом самого массива.</p><p>Если необязательный логический параметр <em class="replaceable"><code>сортируемый</code></em> равен true, определения столбцов и выражения с этим типом могут включать указания о порядке сортировки, в предложении <code class="literal">COLLATE</code>. Как именно будут использоваться эти указания, зависит от реализации функций, работающих с этим типом; эти указания не действуют автоматически просто от того, что тип помечен как сортируемый.</p></div><div class="refsect2" id="SQL-CREATETYPE-ARRAY"><h3>Типы массивов</h3><p>При создании любого нового типа <span class="productname">PostgreSQL</span> автоматически создаёт соответствующий тип массива, имя которого он получает, добавляя подчёркивание перед именем типа элементов. Если полученное имя оказывается не короче <code class="symbol">NAMEDATALEN</code> байт, оно усекается. (Если полученное таким образом имя конфликтует с именем уже существующего типа, процесс повторяется, пока не будет получено уникальное имя.) Этот неявно создаваемый тип массива имеет переменную длину и использует встроенные функции ввода и вывода <code class="literal">array_in</code> и <code class="literal">array_out</code>. Более того, этот тип используется системой при обработке конструкций ARRAY[] с типом, созданным пользователем. Тип массива отражает любые изменения владельца или схемы связанного типа элемента и удаляется сам при удалении типа элемента.</p><p>Вы можете вполне резонно спросить, зачем нужен параметр <code class="option">ELEMENT</code>, если система создаёт правильный тип массива автоматически. В основном параметр <code class="option">ELEMENT</code> полезен в случае, когда вы создаёте тип фиксированной длины, который внутри оказывается массивом одинаковых элементов, и вы хотите, чтобы к этим элементам можно было обращаться по индексу, помимо того, что вы можете реализовать какие угодно операции с типом в целом. Например, тип <code class="type">point</code> представлен просто как два числа с плавающей точкой, к которым можно обратиться так: <code class="literal">point[0]</code> и <code class="literal">point[1]</code>. Заметьте, что это работает только с типами фиксированной длины, которые представляют собой в точности последовательность одинаковых полей фиксированной длины. По историческим причинам (т. е. это определённо некорректно, но менять уже слишком поздно), индексы в массивах фиксированной длины начинаются с нуля, а не с 1, как в массивах переменной длины.</p><p>Указание <code class="option">SUBSCRIPT</code> позволяет добавить для типа данных поддержку обращения по индексу, даже для типов, которые система не считает массивами. Поведение, описанное выше для массивов фиксированной длины, на самом деле реализуется функцией <code class="function">raw_array_subscript_handler</code>, заданной в качестве обработчика <code class="option">SUBSCRIPT</code> — она используется автоматически, если для типа фиксированной длины задан параметр <code class="option">ELEMENT</code>, но не задан <code class="option">SUBSCRIPT</code>.</p><p>Когда задаётся пользовательская функция <code class="option">SUBSCRIPT</code>, указывать также <code class="option">ELEMENT</code> обязательно, только если функция-обработчик <code class="option">SUBSCRIPT</code> должна узнать <code class="structfield">typelem</code>, чтобы определить возвращаемый тип. Учтите, что с указанием <code class="option">ELEMENT</code> система будет предполагать, что новый тип содержит тип элемента либо каким-либо образом физически зависит от него; например, изменить свойства типа элемента нельзя, если созданы какие-либо столбцы зависимого типа.</p></div></div><div class="refsect1" id="id-1.9.3.94.6"><h2>Параметры</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>имя</code></em></span></dt><dd><p>Имя создаваемого типа (возможно, дополненное схемой).</p></dd><dt><span class="term"><em class="replaceable"><code>имя_атрибута</code></em></span></dt><dd><p>Имя атрибута (столбца) составного типа.</p></dd><dt><span class="term"><em class="replaceable"><code>тип_данных</code></em></span></dt><dd><p>Имя существующего типа данных, который станет типом столбца составного типа.</p></dd><dt><span class="term"><em class="replaceable"><code>правило_сортировки</code></em></span></dt><dd><p>Имя существующего правила сортировки, связываемого со столбцом составного типа или с типом-диапазоном.</p></dd><dt><span class="term"><em class="replaceable"><code>метка</code></em></span></dt><dd><p>Строковая константа, представляющая текстовую метку, связанную с отдельным значением типа-перечисления.</p></dd><dt><span class="term"><em class="replaceable"><code>подтип</code></em></span></dt><dd><p>Имя типа элемента, множество значений которого будет представлять тип-диапазон.</p></dd><dt><span class="term"><em class="replaceable"><code>класс_оператора_подтипа</code></em></span></dt><dd><p>Имя класса операторов B-дерева для подтипа.</p></dd><dt><span class="term"><em class="replaceable"><code>функция_нормализации</code></em></span></dt><dd><p>Имя функции нормализации для типа-диапазона.</p></dd><dt><span class="term"><em class="replaceable"><code>функция_разницы_подтипа</code></em></span></dt><dd><p>Имя функции разницы для значений подтипа.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_мультидиапазонного_типа</code></em></span></dt><dd><p>Имя соответствующего мультидиапазонного типа.</p></dd><dt><span class="term"><em class="replaceable"><code>функция_ввода</code></em></span></dt><dd><p>Имя функции, преобразующей данные из внешнего текстового представления типа во внутреннюю форму.</p></dd><dt><span class="term"><em class="replaceable"><code>функция_вывода</code></em></span></dt><dd><p>Имя функции, преобразующей данные из внутренней формы во внешнее текстовое представление типа.</p></dd><dt><span class="term"><em class="replaceable"><code>функция_получения</code></em></span></dt><dd><p>Имя функции, преобразующей данные из внешнего двоичного представления типа во внутреннюю форму.</p></dd><dt><span class="term"><em class="replaceable"><code>функция_отправки</code></em></span></dt><dd><p>Имя функции, преобразующей данные из внутренней формы во внешнее двоичное представление типа.</p></dd><dt><span class="term"><em class="replaceable"><code>функция_ввода_модификатора_типа</code></em></span></dt><dd><p>Имя функции, преобразующей массив модификаторов типа во внутреннюю форму.</p></dd><dt><span class="term"><em class="replaceable"><code>функция_вывода_модификатора_типа</code></em></span></dt><dd><p>Имя функции, преобразующей внутреннюю форму модификаторов типа во внешнее текстовое представление.</p></dd><dt><span class="term"><em class="replaceable"><code>функция_анализа</code></em></span></dt><dd><p>Имя функции, производящей статистический анализ типа данных.</p></dd><dt><span class="term"><em class="replaceable"><code>функция_обращения_по_индексу</code></em></span></dt><dd><p>Имя функции, определяющей, как для типа данных работает извлечение значения по индексу.</p></dd><dt><span class="term"><em class="replaceable"><code>внутр_длина</code></em></span></dt><dd><p>Числовая константа, задающая размер внутреннего представления нового типа в байтах. По умолчанию предполагается, что тип имеет переменную длину.</p></dd><dt><span class="term"><em class="replaceable"><code>выравнивание</code></em></span></dt><dd><p>Требуемое выравнивание для типа данных. Допустимые значения этого параметра, если он указывается: <code class="literal">char</code>, <code class="literal">int2</code>, <code class="literal">int4</code> или <code class="literal">double</code>; по умолчанию подразумевается <code class="literal">int4</code>.</p></dd><dt><span class="term"><em class="replaceable"><code>хранение</code></em></span></dt><dd><p>Стратегия хранения для типа данных. Допустимые значения этого параметра, если он указывается: <code class="literal">plain</code>, <code class="literal">external</code>, <code class="literal">extended</code> или <code class="literal">main</code>; по умолчанию подразумевается <code class="literal">plain</code>.</p></dd><dt><span class="term"><em class="replaceable"><code>тип_образец</code></em></span></dt><dd><p>Имя существующего типа данных, от которого новый тип получит свойства представления. Из этого типа будут скопированы значения параметров <em class="replaceable"><code>internallength</code></em>, <em class="replaceable"><code>passedbyvalue</code></em>, <em class="replaceable"><code>alignment</code></em> и <em class="replaceable"><code>storage</code></em>, если их не переопределят явные указания, заданные дополнительно в этой команде <code class="command">CREATE TYPE</code>.</p></dd><dt><span class="term"><em class="replaceable"><code>категория</code></em></span></dt><dd><p>Код категории (один символ ASCII) для этого типа. По умолчанию подразумевается <code class="literal">'U'</code> (что означает пользовательский тип, <span class="quote">«<span class="quote">User-defined</span>»</span>). Коды других стандартных категорий можно найти в <a class="xref" href="catalog-pg-type.html#CATALOG-TYPCATEGORY-TABLE" title="Таблица 53.65. Коды typcategory">Таблице 53.65</a>. Для нестандартных категорий можно выбрать другие ASCII-символы.</p></dd><dt><span class="term"><em class="replaceable"><code>предпочитаемый</code></em></span></dt><dd><p>Если значение этого параметра равно true, создаваемый тип будет предпочитаемым в своей категории. По умолчанию подразумевается false. Будьте очень осторожны, создавая новый предпочитаемый тип в существующей категории, так как это может поменять поведение выражений неожиданным образом.</p></dd><dt><span class="term"><em class="replaceable"><code>по_умолчанию</code></em></span></dt><dd><p>Значение по умолчанию для создаваемого типа данных. Если не указано, значением по умолчанию будет NULL.</p></dd><dt><span class="term"><em class="replaceable"><code>элемент</code></em></span></dt><dd><p>Создаваемый тип будет массивом; этот параметр определяет тип элементов массива.</p></dd><dt><span class="term"><em class="replaceable"><code>разделитель</code></em></span></dt><dd><p>Символ, разделяющий значения в массивах, образованных из значений создаваемого типа.</p></dd><dt><span class="term"><em class="replaceable"><code>сортируемый</code></em></span></dt><dd><p>Если значение этого параметра равно true, в операциях с создаваемым типом может учитываться информация о правилах сортировки. По умолчанию подразумевается false.</p></dd></dl></div></div><div class="refsect1" id="SQL-CREATETYPE-NOTES"><h2>Замечания</h2><p>Так как на использование типа данных после создания не накладываются ограничения, объявление базового типа или типа-диапазона по сути даёт всем право на выполнение функций, упомянутых в определении типа. Обычно это не проблема для таких функций, какие бывают полезны в определении типов. Но прежде чем создать тип, преобразование которого во внешнюю форму и обратно будет использовать <span class="quote">«<span class="quote">секретную</span>»</span> информацию, стоит подумать дважды.</p><p>В <span class="productname">PostgreSQL</span> до версии 8.3 имя генерируемого типа-массива всегда образовалось из имени типа элемента и добавленного спереди символа подчёркивания (<code class="literal">_</code>). (Таким образом, допустимая максимальная длина имени типа была на символ меньше, чем длины других имён.) Хотя и сейчас имя типа массива чаще всего образуется таким образом, оно может быть и другим в случае достижения максимальной длины или конфликтов с именами пользовательских типов, начинающихся с подчёркивания. Поэтому полагаться на это соглашение в коде не рекомендуется. Вместо этого, имя типа массива, связанного с данным типом, следует определять по значению <code class="structname">pg_type</code>.<code class="structfield">typarray</code>.</p><p>Вообще же можно посоветовать не использовать имена типов и таблиц, начинающиеся с подчёркивания. Хотя сервер сможет сгенерировать другое имя, не конфликтующее с пользовательским, некоторая путаница всё же возможна, особенно со старыми клиентскими приложениями, которые могут полагать, что имя типа, начинающееся с подчёркивания, всегда относится к типу массива.</p><p>В <span class="productname">PostgreSQL</span> до версии 8.2 у <code class="literal">CREATE TYPE <em class="replaceable"><code>name</code></em></code> отсутствовала форма для создания типа-пустышки. Поэтому для создания нового базового типа требовалось сначала создать функцию ввода. При таком подходе <span class="productname">PostgreSQL</span> воспринимал тип возврата функции ввода как имя нового типа данных и неявно создавал тип-пустышку, на который затем можно было ссылаться в определениях остальных функций ввода/вывода. Этот подход по-прежнему работает, но считается устаревшим и может быть запрещён в будущих версиях. Кроме того, во избежание непреднамеренного заполнения каталогов типами-пустышками, появляющимися в результате простых опечаток в определении функций, тип-пустышка будет создаваться таким образом, только если функция ввода написана на C.</p><p>Начиная с <span class="productname">PostgreSQL</span> 16, рекомендуется, чтобы функции, принимающие базовые типы, возвращали <span class="quote">«<span class="quote">мягкие</span>»</span> ошибки с использованием механизма <code class="function">errsave()</code>/<code class="function">ereturn()</code> вместо выдачи исключений <code class="function">ereport()</code>, как в предыдущих версиях. За дополнительной информацией обратитесь к <code class="filename">src/backend/utils/fmgr/README</code>.</p></div><div class="refsect1" id="id-1.9.3.94.8"><h2>Примеры</h2><p>В этом примере создаётся составной тип, а затем он используется в определении функции: </p><pre class="programlisting">CREATE TYPE compfoo AS (f1 int, f2 text);

CREATE FUNCTION getfoo() RETURNS SETOF compfoo AS $$
    SELECT fooid, fooname FROM foo
$$ LANGUAGE SQL;</pre><p>В этом примере создаётся тип-перечисление, а затем он используется в определении таблицы: </p><pre class="programlisting">CREATE TYPE bug_status AS ENUM ('new', 'open', 'closed');

CREATE TABLE bug (
    id serial,
    description text,
    status bug_status
);</pre><p>В этом примере создаётся тип-диапазон: </p><pre class="programlisting">CREATE TYPE float8_range AS RANGE (subtype = float8, subtype_diff = float8mi);</pre><p>В следующем примере создаётся базовый тип данных <code class="type">box</code>, а затем он используется в определении таблицы: </p><pre class="programlisting">CREATE TYPE box;

CREATE FUNCTION my_box_in_function(cstring) RETURNS box AS ... ;
CREATE FUNCTION my_box_out_function(box) RETURNS cstring AS ... ;

CREATE TYPE box (
    INTERNALLENGTH = 16,
    INPUT = my_box_in_function,
    OUTPUT = my_box_out_function
);

CREATE TABLE myboxes (
    id integer,
    description box
);</pre><p>Если бы внутренней структурой <code class="type">box</code> был массив из четырёх элементов <code class="type">float4</code>, вместо этого можно было бы использовать определение: </p><pre class="programlisting">CREATE TYPE box (
    INTERNALLENGTH = 16,
    INPUT = my_box_in_function,
    OUTPUT = my_box_out_function,
    ELEMENT = float4
);</pre><p> В таком случае к числам, составляющим значение этого типа, можно было бы обращаться по индексу. В остальном поведение этого типа будет таким же.</p><p>В этом примере создаётся тип большого объекта, а затем он используется в определении таблицы: </p><pre class="programlisting">CREATE TYPE bigobj (
    INPUT = lo_filein, OUTPUT = lo_fileout,
    INTERNALLENGTH = VARIABLE
);
CREATE TABLE big_objs (
    id integer,
    obj bigobj
);</pre><p>Другие примеры, в том числе демонстрирующие подходящие функции ввода/вывода, можно найти в <a class="xref" href="xtypes.html" title="38.13. Пользовательские типы">Разделе 38.13</a>.</p></div><div class="refsect1" id="SQL-CREATETYPE-COMPATIBILITY"><h2>Совместимость</h2><p>Первая форма команды <code class="command">CREATE TYPE</code>, создающая составной тип, соответствует стандарту <acronym class="acronym">SQL</acronym>. Другие формы являются расширениями <span class="productname">PostgreSQL</span>. Для оператора <code class="command">CREATE TYPE</code> в стандарте <acronym class="acronym">SQL</acronym> также определены другие формы, не реализованные в <span class="productname">PostgreSQL</span>.</p><p>Возможность создавать составной тип без атрибутов — специфическое отклонение <span class="productname">PostgreSQL</span> от стандарта (как и аналогичная особенность команды <code class="command">CREATE TABLE</code>).</p></div><div class="refsect1" id="SQL-CREATETYPE-SEE-ALSO"><h2>См. также</h2><span class="simplelist"><a class="xref" href="sql-altertype.html" title="ALTER TYPE"><span class="refentrytitle">ALTER TYPE</span></a>, <a class="xref" href="sql-createdomain.html" title="CREATE DOMAIN"><span class="refentrytitle">CREATE DOMAIN</span></a>, <a class="xref" href="sql-createfunction.html" title="CREATE FUNCTION"><span class="refentrytitle">CREATE FUNCTION</span></a>, <a class="xref" href="sql-droptype.html" title="DROP TYPE"><span class="refentrytitle">DROP TYPE</span></a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-createtrigger.html" title="CREATE TRIGGER">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-createuser.html" title="CREATE USER">След.</a></td></tr><tr><td width="40%" align="left" valign="top">CREATE TRIGGER </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> CREATE USER</td></tr></table></div></body></html>