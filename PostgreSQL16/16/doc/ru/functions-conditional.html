<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>9.18. Условные выражения</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="functions-sequence.html" title="9.17. Функции для работы с последовательностями" /><link rel="next" href="functions-array.html" title="9.19. Функции и операторы для работы с массивами" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">9.18. Условные выражения</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="functions-sequence.html" title="9.17. Функции для работы с последовательностями">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="functions.html" title="Глава 9. Функции и операторы">Наверх</a></td><th width="60%" align="center">Глава 9. Функции и операторы</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="functions-array.html" title="9.19. Функции и операторы для работы с массивами">След.</a></td></tr></table><hr /></div><div class="sect1" id="FUNCTIONS-CONDITIONAL"><div class="titlepage"><div><div><h2 class="title" style="clear: both">9.18. Условные выражения <a href="#FUNCTIONS-CONDITIONAL" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="functions-conditional.html#FUNCTIONS-CASE">9.18.1. <code class="literal">CASE</code></a></span></dt><dt><span class="sect2"><a href="functions-conditional.html#FUNCTIONS-COALESCE-NVL-IFNULL">9.18.2. <code class="literal">COALESCE</code></a></span></dt><dt><span class="sect2"><a href="functions-conditional.html#FUNCTIONS-NULLIF">9.18.3. <code class="literal">NULLIF</code></a></span></dt><dt><span class="sect2"><a href="functions-conditional.html#FUNCTIONS-GREATEST-LEAST">9.18.4. <code class="literal">GREATEST</code> и <code class="literal">LEAST</code></a></span></dt></dl></div><a id="id-1.5.8.24.2" class="indexterm"></a><a id="id-1.5.8.24.3" class="indexterm"></a><p>В этом разделе описаны <acronym class="acronym">SQL</acronym>-совместимые условные выражения, которые поддерживаются в <span class="productname">PostgreSQL</span>.</p><div class="tip"><h3 class="title">Подсказка</h3><p>Если возможностей этих условных выражений оказывается недостаточно, вероятно, имеет смысл перейти к написанию серверных функций на более мощном языке программирования.</p></div><div class="note"><h3 class="title">Примечание</h3><p>Хотя конструкции <code class="token">COALESCE</code>, <code class="token">GREATEST</code> и <code class="token">LEAST</code> синтаксически похожи на функции, они не являются обычными функциями, и поэтому им нельзя передать в аргументах явно описанный массив <code class="token">VARIADIC</code>.</p></div><div class="sect2" id="FUNCTIONS-CASE"><div class="titlepage"><div><div><h3 class="title">9.18.1. <code class="literal">CASE</code> <a href="#FUNCTIONS-CASE" class="id_link">#</a></h3></div></div></div><p>Выражение <code class="token">CASE</code> в <acronym class="acronym">SQL</acronym> представляет собой общее условное выражение, напоминающее операторы if/else в других языках программирования: </p><pre class="synopsis">
CASE WHEN <em class="replaceable"><code>условие</code></em> THEN <em class="replaceable"><code>результат</code></em>
     [<span class="optional">WHEN ...</span>]
     [<span class="optional">ELSE <em class="replaceable"><code>результат</code></em></span>]
END
</pre><p>Предложения <code class="token">CASE</code> можно использовать везде, где допускаются выражения. Каждое <em class="replaceable"><code>условие</code></em> в нём представляет собой выражение, возвращающее результат типа <code class="type">boolean</code>. Если результатом выражения оказывается true, значением выражения <code class="token">CASE</code> становится <em class="replaceable"><code>результат</code></em>, следующий за условием, а остальная часть выражения <code class="token">CASE</code> не вычисляется. Если же условие не выполняется, за ним таким же образом проверяются все последующие предложения <code class="token">WHEN</code>. Если не выполняется ни одно из <em class="replaceable"><code>условий</code></em> <code class="token">WHEN</code>, значением <code class="token">CASE</code> становится <em class="replaceable"><code>результат</code></em>, записанный в предложении <code class="token">ELSE</code>. Если при этом предложение <code class="token">ELSE</code> отсутствует, результатом выражения будет NULL.</p><p>Пример: </p><pre class="screen">
SELECT * FROM test;

 a
---
 1
 2
 3


SELECT a,
       CASE WHEN a=1 THEN 'one'
            WHEN a=2 THEN 'two'
            ELSE 'other'
       END
    FROM test;

 a | case
---+-------
 1 | one
 2 | two
 3 | other
</pre><p>Типы данных всех выражений <em class="replaceable"><code>результатов</code></em> должны приводиться к одному выходному типу. Подробнее это описано в <a class="xref" href="typeconv-union-case.html" title="10.5. UNION, CASE и связанные конструкции">Разделе 10.5</a>.</p><p>Существует также <span class="quote">«<span class="quote">простая</span>»</span> форма выражения <code class="token">CASE</code>, разновидность вышеприведённой общей формы: </p><pre class="synopsis">
CASE <em class="replaceable"><code>выражение</code></em>
    WHEN <em class="replaceable"><code>значение</code></em> THEN <em class="replaceable"><code>результат</code></em>
    [<span class="optional">WHEN ...</span>]
    [<span class="optional">ELSE <em class="replaceable"><code>результат</code></em></span>]
END
</pre><p> В такой форме сначала вычисляется первое <em class="replaceable"><code>выражение</code></em>, а затем его результат сравнивается с выражениями <em class="replaceable"><code>значений</code></em> в предложениях <code class="token">WHEN</code>, пока не будет найдено равное ему. Если такого значения не находится, возвращается <em class="replaceable"><code>результат</code></em> предложения <code class="token">ELSE</code> (или NULL). Эта форма больше похожа на оператор <code class="function">switch</code>, существующий в языке C.</p><p>Показанный ранее пример можно записать по-другому, используя простую форму <code class="token">CASE</code>: </p><pre class="screen">
SELECT a,
       CASE a WHEN 1 THEN 'one'
              WHEN 2 THEN 'two'
              ELSE 'other'
       END
    FROM test;

 a | case
---+-------
 1 | one
 2 | two
 3 | other
</pre><p>В выражении <code class="token">CASE</code> вычисляются только те подвыражения, которые необходимы для получения результата. Например, так можно избежать ошибки деления на ноль: </p><pre class="programlisting">SELECT ... WHERE CASE WHEN x &lt;&gt; 0 THEN y/x &gt; 1.5 ELSE false END;</pre><div class="note"><h3 class="title">Примечание</h3><p>Как было описано в <a class="xref" href="sql-expressions.html#SYNTAX-EXPRESS-EVAL" title="4.2.14. Правила вычисления выражений">Подразделе 4.2.14</a>, всё же возможны ситуации, когда подвыражения вычисляются на разных этапах, так что железной гарантии, что в <span class="quote">«<span class="quote"><code class="token">CASE</code> вычисляются только необходимые подвыражения</span>»</span>, в принципе нет. Например, константное подвыражение <code class="literal">1/0</code> обычно вызывает ошибку деления на ноль на этапе планирования, хотя эта ветвь <code class="token">CASE</code> может вовсе не вычисляться во время выполнения.</p></div></div><div class="sect2" id="FUNCTIONS-COALESCE-NVL-IFNULL"><div class="titlepage"><div><div><h3 class="title">9.18.2. <code class="literal">COALESCE</code> <a href="#FUNCTIONS-COALESCE-NVL-IFNULL" class="id_link">#</a></h3></div></div></div><a id="id-1.5.8.24.8.2" class="indexterm"></a><a id="id-1.5.8.24.8.3" class="indexterm"></a><a id="id-1.5.8.24.8.4" class="indexterm"></a><pre class="synopsis"><code class="function">COALESCE</code>(<em class="replaceable"><code>значение</code></em> [<span class="optional">, ...</span>])</pre><p>Функция <code class="function">COALESCE</code> возвращает первый попавшийся аргумент, отличный от NULL. Если же все аргументы равны NULL, результатом тоже будет NULL. Это часто используется при отображении данных для подстановки некоторого значения по умолчанию вместо значений NULL: </p><pre class="programlisting">SELECT COALESCE(description, short_description, '(none)') ...</pre><p> Этот запрос вернёт значение <code class="varname">description</code>, если оно не равно NULL, либо <code class="varname">short_description</code>, если оно не NULL, и строку <code class="literal">(none)</code>, если оба эти значения равны NULL.</p><p>Аргументы должны быть приводимыми к одному общему типу, который и будет типом результата (подробнее об этом говорится в <a class="xref" href="typeconv-union-case.html" title="10.5. UNION, CASE и связанные конструкции">Разделе 10.5</a>).</p><p>Как и выражение <code class="token">CASE</code>, <code class="function">COALESCE</code> вычисляет только те аргументы, которые необходимы для получения результата; то есть, аргументы правее первого отличного от NULL аргумента не вычисляются. Эта функция соответствует стандарту SQL, а в некоторых других СУБД её аналоги называются <code class="function">NVL</code> и <code class="function">IFNULL</code>.</p></div><div class="sect2" id="FUNCTIONS-NULLIF"><div class="titlepage"><div><div><h3 class="title">9.18.3. <code class="literal">NULLIF</code> <a href="#FUNCTIONS-NULLIF" class="id_link">#</a></h3></div></div></div><a id="id-1.5.8.24.9.2" class="indexterm"></a><pre class="synopsis"><code class="function">NULLIF</code>(<em class="replaceable"><code>значение1</code></em>, <em class="replaceable"><code>значение2</code></em>)</pre><p>Функция <code class="function">NULLIF</code> выдаёт значение NULL, если <em class="replaceable"><code>значение1</code></em> равно <em class="replaceable"><code>значение2</code></em>; в противном случае она возвращает <em class="replaceable"><code>значение1</code></em>. Это может быть полезно для реализации обратной операции к <code class="function">COALESCE</code>. В частности, для примера, показанного выше: </p><pre class="programlisting">SELECT NULLIF(value, '(none)') ...</pre><p> В данном примере если <code class="literal">value</code> равно <code class="literal">(none)</code>, выдаётся null, а иначе возвращается значение <code class="literal">value</code>.</p><p>Два её аргумента должны быть сравнимых типов. Если говорить точнее, они сравниваются точно так же, как сравнивались бы в записи <code class="literal"><em class="replaceable"><code>значение1</code></em> = <em class="replaceable"><code>значение2</code></em></code>, так что для этих типов должен существовать подходящий оператор <code class="literal">=</code>.</p><p>Результат будет иметь тот же тип, что и первый аргумент, но есть одна тонкость. Эта функция фактически возвращает первый аргумент подразумеваемого оператора <code class="literal">=</code>, который в некоторых случаях преобразуется к типу второго аргумента. Например, <code class="literal">NULLIF(1, 2.2)</code> возвращает <code class="type">numeric</code>, так как оператор <code class="type">integer</code> <code class="literal">=</code> <code class="type">numeric</code> не существует, существует только оператор <code class="type">numeric</code> <code class="literal">=</code> <code class="type">numeric</code>.</p></div><div class="sect2" id="FUNCTIONS-GREATEST-LEAST"><div class="titlepage"><div><div><h3 class="title">9.18.4. <code class="literal">GREATEST</code> и <code class="literal">LEAST</code> <a href="#FUNCTIONS-GREATEST-LEAST" class="id_link">#</a></h3></div></div></div><a id="id-1.5.8.24.10.2" class="indexterm"></a><a id="id-1.5.8.24.10.3" class="indexterm"></a><pre class="synopsis"><code class="function">GREATEST</code>(<em class="replaceable"><code>значение</code></em> [<span class="optional">, ...</span>])</pre><pre class="synopsis"><code class="function">LEAST</code>(<em class="replaceable"><code>значение</code></em> [<span class="optional">, ...</span>])</pre><p>Функции <code class="function">GREATEST</code> и <code class="function">LEAST</code> выбирают наибольшее или наименьшее значение из списка выражений. Все эти выражения должны приводиться к общему типу данных, который станет типом результата (подробнее об этом в <a class="xref" href="typeconv-union-case.html" title="10.5. UNION, CASE и связанные конструкции">Разделе 10.5</a>).</p><p>Значения NULL в этом списке игнорируются, так что результат выражения будет равен NULL, только если все его аргументы равны NULL. (Это отклонение от стандарта SQL. Согласно стандарту, возвращается значение NULL, если какой-либо аргумент равен NULL. Подобным образом ведут себя и некоторые другие базы данных.)</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="functions-sequence.html" title="9.17. Функции для работы с последовательностями">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="functions.html" title="Глава 9. Функции и операторы">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="functions-array.html" title="9.19. Функции и операторы для работы с массивами">След.</a></td></tr><tr><td width="40%" align="left" valign="top">9.17. Функции для работы с последовательностями </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 9.19. Функции и операторы для работы с массивами</td></tr></table></div></body></html>