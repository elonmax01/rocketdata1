<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>26.3. Непрерывное архивирование и восстановление на момент времени (Point-in-Time Recovery, PITR)</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="backup-file.html" title="26.2. Резервное копирование на уровне файлов" /><link rel="next" href="high-availability.html" title="Глава 27. Отказоустойчивость, балансировка нагрузки и репликация" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">26.3. Непрерывное архивирование и восстановление на момент времени (Point-in-Time Recovery, PITR)</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="backup-file.html" title="26.2. Резервное копирование на уровне файлов">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="backup.html" title="Глава 26. Резервное копирование и восстановление">Наверх</a></td><th width="60%" align="center">Глава 26. Резервное копирование и восстановление</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="high-availability.html" title="Глава 27. Отказоустойчивость, балансировка нагрузки и репликация">След.</a></td></tr></table><hr /></div><div class="sect1" id="CONTINUOUS-ARCHIVING"><div class="titlepage"><div><div><h2 class="title" style="clear: both">26.3. Непрерывное архивирование и восстановление на момент времени (Point-in-Time Recovery, PITR) <a href="#CONTINUOUS-ARCHIVING" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="continuous-archiving.html#BACKUP-ARCHIVING-WAL">26.3.1. Настройка архивирования WAL</a></span></dt><dt><span class="sect2"><a href="continuous-archiving.html#BACKUP-BASE-BACKUP">26.3.2. Создание базовой резервной копии</a></span></dt><dt><span class="sect2"><a href="continuous-archiving.html#BACKUP-LOWLEVEL-BASE-BACKUP">26.3.3. Создание базовой резервной копии через низкоуровневый API</a></span></dt><dt><span class="sect2"><a href="continuous-archiving.html#BACKUP-PITR-RECOVERY">26.3.4. Восстановление непрерывной архивной копии</a></span></dt><dt><span class="sect2"><a href="continuous-archiving.html#BACKUP-TIMELINES">26.3.5. Линии времени</a></span></dt><dt><span class="sect2"><a href="continuous-archiving.html#BACKUP-TIPS">26.3.6. Советы и примеры</a></span></dt><dt><span class="sect2"><a href="continuous-archiving.html#CONTINUOUS-ARCHIVING-CAVEATS">26.3.7. Ограничения</a></span></dt></dl></div><a id="id-1.6.13.7.2" class="indexterm"></a><a id="id-1.6.13.7.3" class="indexterm"></a><a id="id-1.6.13.7.4" class="indexterm"></a><p>Всё время в процессе работы <span class="productname">PostgreSQL</span> ведёт <em class="firstterm">журнал предзаписи</em> (WAL), который расположен в подкаталоге <code class="filename">pg_wal/</code> каталога с данными кластера баз данных. В этот журнал записываются все изменения, вносимые в файлы данных. Прежде всего, журнал существует для безопасного восстановления после краха сервера: если происходит крах, целостность СУБД может быть восстановлена в результате <span class="quote">«<span class="quote">воспроизведения</span>»</span> записей, зафиксированных после последней контрольной точки. Однако наличие журнала делает возможным использование третьей стратегии копирования баз данных: можно сочетать резервное копирование на уровне файловой системы с копированием файлов WAL. Если потребуется восстановить данные, мы можем восстановить копию файлов, а затем воспроизвести журнал из скопированных файлов WAL, и таким образом привести систему в нужное состояние. Такой подход более сложен для администрирования, чем любой из описанных выше, но он имеет значительные преимущества: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>В качестве начальной точки для восстановления необязательно иметь полностью согласованную копию на уровне файлов. Внутренняя несогласованность копии будет исправлена при воспроизведении журнала (практически то же самое происходит при восстановлении после краха). Таким образом, согласованный снимок файловой системы не требуется, вполне можно использовать <span class="application">tar</span> или похожие средства архивации.</p></li><li class="listitem"><p>Поскольку при воспроизведении можно обрабатывать неограниченную последовательность файлов WAL, непрерывную резервную копию можно получить, просто продолжая архивировать файлы WAL. Это особенно ценно для больших баз данных, полные резервные копии которых делать как минимум неудобно.</p></li><li class="listitem"><p>Воспроизводить все записи WAL до самого конца нет необходимости. Воспроизведение можно остановить в любой точке и получить целостный снимок базы данных на этот момент времени. Таким образом, данная технология поддерживает <em class="firstterm">восстановление на момент времени</em>: можно восстановить состояние базы данных на любое время с момента создания резервной копии.</p></li><li class="listitem"><p>Если непрерывно передавать последовательность файлов WAL другому серверу, получившему данные из базовой копии того же кластера, получается система <em class="firstterm">тёплого резерва</em>: в любой момент мы можем запустить второй сервер и он будет иметь практически текущую копию баз данных.</p></li></ul></div><div class="note"><h3 class="title">Примечание</h3><p>Программы <span class="application">pg_dump</span> и <span class="application">pg_dumpall</span> не создают копии на уровне файловой системы и не могут применяться как часть решения по непрерывной архивации. Создаваемые ими копии являются логическими и не содержат информации, необходимой для воспроизведения WAL.</p></div><p>Как и обычное резервное копирование файловой системы, этот метод позволяет восстанавливать только весь кластер баз данных целиком, но не его части. Кроме того, для архивов требуется большое хранилище: базовая резервная копия может быть объёмной, а нагруженные системы будут генерировать многие мегабайты трафика WAL, который необходимо архивировать. Тем не менее этот метод резервного копирования предпочитается во многих ситуациях, где необходима высокая надёжность.</p><p>Для успешного восстановления с применением непрерывного архивирования (также называемого <span class="quote">«<span class="quote">оперативным резервным копированием</span>»</span> многими разработчиками СУБД), вам необходима непрерывная последовательность заархивированных файлов WAL, начинающаяся не позже, чем с момента начала копирования. Так что для начала вы должны настроить и протестировать процедуру архивирования файлов WAL <span class="emphasis"><em>до того</em></span>, как получите первую базовую копию. Соответственно, сначала мы обсудим механику архивирования файлов WAL.</p><div class="sect2" id="BACKUP-ARCHIVING-WAL"><div class="titlepage"><div><div><h3 class="title">26.3.1. Настройка архивирования WAL <a href="#BACKUP-ARCHIVING-WAL" class="id_link">#</a></h3></div></div></div><p>В абстрактном смысле, запущенная СУБД <span class="productname">PostgreSQL</span> производит неограниченно длинную последовательность записей WAL. СУБД физически делит эту последовательность на <em class="firstterm">файлы сегментов</em> WAL, которые обычно имеют размер 16 МиБ (хотя размер сегмента может быть изменён при <span class="application">initdb</span>). Файлы сегментов получают цифровые имена, которые отражают их позицию в абстрактной последовательности WAL. Когда архивирование WAL не применяется, система обычно создаёт только несколько файлов сегментов и затем <span class="quote">«<span class="quote">перерабатывает</span>»</span> их, меняя номер в имени ставшего ненужным файла на больший. Предполагается, что файлы сегментов, содержимое которых предшествует последней контрольной точке, уже не представляют интереса и могут быть переработаны.</p><p>При архивировании данных WAL необходимо считывать содержимое каждого файла-сегмента, как только он заполняется, и сохранять эти данные куда-то, прежде чем файл-сегмент будет переработан и использован повторно. В зависимости от применения и доступного аппаратного обеспечения, возможны разные способы <span class="quote">«<span class="quote">сохранить данные куда-то</span>»</span>: можно скопировать файлы-сегменты в смонтированный по NFS каталог на другую машину, записать их на ленту (убедившись, что у вас есть способ идентифицировать исходное имя каждого файла) или собрать их в пакет и записать на CD, либо какие-то совсем другие варианты. Чтобы у администратора баз данных была гибкость в этом плане, <span class="productname">PostgreSQL</span> пытается не делать каких-либо предположений о том, как будет выполняться архивация. Вместо этого, <span class="productname">PostgreSQL</span> позволяет администратору указать команду оболочки или библиотеку архивирования, которая будет запускаться для копирования файла завершённого сегмента в нужное место. Её действие может заключаться в выполнении простых команд оболочки, включая <code class="literal">cp</code>, или в вызове нетривиальной функции на языке C — это решать вам.</p><p>Чтобы включить архивирование WAL, установите в параметре конфигурации <a class="xref" href="runtime-config-wal.html#GUC-WAL-LEVEL">wal_level</a> уровень <code class="literal">replica</code> или выше, в <a class="xref" href="runtime-config-wal.html#GUC-ARCHIVE-MODE">archive_mode</a> — значение <code class="literal">on</code> и задайте желаемую команду оболочки в параметре <a class="xref" href="runtime-config-wal.html#GUC-ARCHIVE-COMMAND">archive_command</a> или библиотеку архивирования в параметре <a class="xref" href="runtime-config-wal.html#GUC-ARCHIVE-LIBRARY">archive_library</a>. На практике эти параметры всегда задаются в файле <code class="filename">postgresql.conf</code>.</p><p>В <code class="varname">archive_command</code> символы <code class="literal">%p</code> заменяются полным путём к файлу, подлежащему архивации, а <code class="literal">%f</code> заменяются только именем файла. (Путь задаётся относительно текущего рабочего каталога, т. е. каталога данных кластера). Если в команду нужно включить сам символ <code class="literal">%</code>, запишите <code class="literal">%%</code>. Простейшая команда, которая может быть полезна: </p><pre class="programlisting">archive_command = 'test ! -f /mnt/server/archivedir/%f &amp;&amp; cp %p /mnt/server/archivedir/%f'  # Unix
archive_command = 'copy "%p" "C:\\server\\archivedir\\%f"'  # Windows</pre><p> Она будет копировать архивируемые сегменты WAL в каталог /mnt/server/archivedir. (Команда дана как пример, а не как рекомендация, и может работать не на всех платформах.) После замены параметров <code class="literal">%p</code> и <code class="literal">%f</code> фактически запускаемая команда может выглядеть так: </p><pre class="programlisting">test ! -f /mnt/server/archivedir/00000001000000A900000065 &amp;&amp; cp pg_wal/00000001000000A900000065 /mnt/server/archivedir/00000001000000A900000065</pre><p> Подобная команда будет генерироваться для каждого следующего архивируемого файла.</p><p>Команда архивирования будет запущена от имени того же пользователя, от имени которого работает сервер <span class="productname">PostgreSQL</span>. Поскольку архивируемые последовательности файлов WAL фактически содержат всё, что есть в вашей базе данных, вам нужно будет защитить архивируемые данные от посторонних глаз; например, сохраните архив в каталог, чтение которого запрещено для группы и остальных пользователей.</p><p>Важно, чтобы команда архивирования возвращала нулевой код завершения, если и только если она завершилась успешно. Получив нулевой результат, <span class="productname">PostgreSQL</span> будет полагать, что файл успешно заархивирован и удалит его или переработает. Однако ненулевой код состояния скажет <span class="productname">PostgreSQL</span>, что файл не заархивирован; попытки заархивировать его будут периодически повторяться, пока это не удастся.</p><p>Другой способ архивирования — использовать пользовательский модуль архивирования в качестве <code class="varname">archive_library</code>. Поскольку такие модули пишутся на языке <code class="literal">C</code>, создать собственный модуль гораздо сложнее, чем написать команду оболочки. Однако модули архивирования могут быть эффективнее, чем вызываемые команды оболочки, им доступны многие полезные ресурсы сервера. Дополнительная информация о модулях архивирования находится в <a class="xref" href="archive-modules.html" title="Глава 51. Модули архивирования">Главе 51</a>.</p><p>Когда команда архивирования завершается сигналом (отличным от <span class="systemitem">SIGTERM</span>, получаемого при штатном отключении сервера) или при возникновении ошибки оболочки (например, если команда не найдена) либо если функция архивирования выдаёт ошибку уровня <code class="literal">ERROR</code> или <code class="literal">FATAL</code>, процесс архиватора прерывается и перезапускается управляющим процессом postmaster. В таких случаях в <a class="xref" href="monitoring-stats.html#PG-STAT-ARCHIVER-VIEW" title="Таблица 28.22. Представление pg_stat_archiver">pg_stat_archiver</a> не сообщается об ошибке.</p><p>Команды и библиотеки архивирования обычно разрабатываются так, чтобы не допускать перезаписи любых существующих архивных файлов. Это важная мера безопасности, позволяющая сохранить целостность архива в случае ошибки администратора (например, если архивируемые данные двух разных серверов будут сохраняться в одном каталоге). Рекомендуется протестировать предлагаемую библиотеку архивирования, чтобы убедиться, что она не перезаписывает существующий файл.</p><p>В редких случаях <span class="productname">PostgreSQL</span> может попытаться повторно архивировать ранее заархивированный файл WAL. Например, если система выходит из строя до того, как сервер делает надёжную запись об успешном архивировании, он пытается снова заархивировать файл после перезапуска (при условии, что архивирование всё ещё включено). Когда команда или библиотека архивирования обнаруживает существовавший файл, первая должна возвращать нулевой статус, а вторая — <code class="literal">true</code>, если содержимое файла WAL полностью совпадает с содержимым существующего архива, который находится в хранилище. Если содержимое существующего файла отличается от содержимого архивируемого файла WAL, команда или библиотека архивирования <span class="emphasis"><em>должны</em></span> возвращать ненулевой статус или <code class="literal">false</code> соответственно.</p><p>Рекомендуется протестировать команду архивирования, чтобы убедиться, что она действительно не перезаписывает существующие файлы. В показанной выше команде для Unix для этого добавлен отдельный шаг <code class="command">test</code>. На некоторых платформах Unix у <code class="command">cp</code> есть ключ <code class="option">-i</code>, который позволяет сделать то же самое менее явно. Но не проверив, какой код состояния при этом возвращается, полагаться на этот ключ не следует. (В частности, GNU <code class="command">cp</code> возвратит нулевой код состояния, если используется ключ <code class="option">-i</code> и целевой файл существует, а это <span class="emphasis"><em>не то</em></span>, что нужно.)</p><p>Разрабатывая схему архивирования, подумайте, что произойдёт, если команда или библиотека архивирования начнёт постоянно выдавать ошибку, потому что требуется вмешательство оператора или для архивирования не хватает места. Например, это может произойти, если вы записываете архивы на ленточное устройство без механизма автозамены; когда лента заполняется полностью, больше ничего архивироваться не будет, пока вы не замените кассету. Вы должны убедиться, что любые возникающие ошибки или обращения к человеку (оператору) обрабатываются так, чтобы проблема решалась достаточно быстро. Пока она не разрешится, каталог <code class="filename">pg_wal/</code> продолжит наполняться файлами-сегментами WAL. (Если файловая система, в которой находится каталог <code class="filename">pg_wal/</code> заполнится до конца, <span class="productname">PostgreSQL</span> завершит свою работу аварийно. Зафиксированные транзакции не потеряются, но база данных не будет работать, пока вы не освободите место.)</p><p>Не важно, с какой скоростью работает команда или библиотека архивирования, если только она не ниже средней скорости, с которой сервер генерирует записи WAL. Обычно работа продолжается, даже если процесс архивирования немного отстаёт. Если же архивирование отстаёт значительно, это приводит к увеличению объёма данных, которые могут быть потеряны в случае аварии. При этом каталог <code class="filename">pg_wal/</code> будет содержать большое количество ещё не заархивированных файлов-сегментов, которые в конце концов могут занять всё доступное дисковое пространство. Поэтому рекомендуется контролировать процесс архивации и следить за тем, чтобы он выполнялся как задумано.</p><p>При написании команды или библиотеки архивирования вы должны иметь в виду, что имена файлов для архивирования могут иметь длину до 64 символов и содержать любые комбинации из цифр, точек и букв ASCII. Сохранять исходный относительный путь (<code class="literal">%p</code>) необязательно, но необходимо сохранять имя файла (<code class="literal">%f</code>).</p><p>Обратите внимание, что хотя архивирование WAL позволяет сохранить любые изменения данных, произведённые в базе данных <span class="productname">PostgreSQL</span>, оно не затрагивает изменения, внесённые в конфигурационные файлы (такие как <code class="filename">postgresql.conf</code>, <code class="filename">pg_hba.conf</code> и <code class="filename">pg_ident.conf</code>), поскольку эти изменения выполняются вручную, а не через SQL. Поэтому имеет смысл разместить конфигурационные файлы там, где они будут заархивированы обычными процедурами копирования файлов. Как перемещать конфигурационные файлы, рассказывается в <a class="xref" href="runtime-config-file-locations.html" title="20.2. Расположения файлов">Разделе 20.2</a>.</p><p>Команда или функция архивирования вызывается, только когда сегмент WAL заполнен до конца. Таким образом, если сервер постоянно генерирует небольшой трафик WAL (или есть продолжительные периоды, когда это происходит), между завершением транзакций и их безопасным сохранением в архиве может образоваться большая задержка. Чтобы ограничить время жизни неархивированных данных, можно установить <a class="xref" href="runtime-config-wal.html#GUC-ARCHIVE-TIMEOUT">archive_timeout</a>, чтобы сервер переключался на новый файл сегмента WAL как минимум с заданной частотой. Заметьте, что неполные файлы, архивируемые досрочно из-за принудительного переключения по тайм-ауту, будут иметь тот же размер, что и заполненные файлы. Таким образом, устанавливать очень маленький <code class="varname">archive_timeout</code> неразумно — это приведёт к замусориванию архивного хранилища. Обычно подходящее значение <code class="varname">archive_timeout</code> — минута или около того.</p><p>Также вы можете принудительно переключить сегмент WAL вручную с помощью <code class="function">pg_switch_wal</code>, если хотите, чтобы только что завершённая транзакция заархивировалась как можно скорее. Другие полезные функции, относящиеся к управлению WAL, перечисляются в <a class="xref" href="functions-admin.html#FUNCTIONS-ADMIN-BACKUP-TABLE" title="Таблица 9.91. Функции управления резервным копированием">Таблице 9.91</a>.</p><p>Когда <code class="varname">wal_level</code> имеет значение <code class="literal">minimal</code>, некоторые команды SQL выполняются в обход журнала WAL, как описывается в <a class="xref" href="populate.html#POPULATE-PITR" title="14.4.7. Отключите архивацию WAL и потоковую репликацию">Подразделе 14.4.7</a>. Если архивирование или потоковая репликация были включены во время выполнения таких операторов, WAL не будет содержать информацию, необходимую для восстановления. (На восстановление после краха это не распространяется). Поэтому <code class="varname">wal_level</code> можно изменить только при запуске сервера. Однако для изменения параметра <code class="varname">archive_command</code> или <code class="varname">archive_library</code> достаточно перезагрузить файл конфигурации. Если вы используете для архивирования команду оболочки и хотите на время остановить архивирование, это можно сделать, например, задав в качестве значения <code class="varname">archive_command</code> пустую строку (''). В результате файлы WAL будут накапливаться в каталоге <code class="filename">pg_wal/</code>, пока не будет восстановлена действующая команда <code class="varname">archive_command</code>.</p></div><div class="sect2" id="BACKUP-BASE-BACKUP"><div class="titlepage"><div><div><h3 class="title">26.3.2. Создание базовой резервной копии <a href="#BACKUP-BASE-BACKUP" class="id_link">#</a></h3></div></div></div><p>Проще всего получить базовую резервную копию, используя программу <a class="xref" href="app-pgbasebackup.html" title="pg_basebackup"><span class="refentrytitle"><span class="application">pg_basebackup</span></span></a>. Эта программа сохраняет базовую копию в виде обычных файлов или в архиве tar. Если гибкости <a class="xref" href="app-pgbasebackup.html" title="pg_basebackup"><span class="refentrytitle"><span class="application">pg_basebackup</span></span></a> не хватает, вы также можете получить базовую резервную копию, используя низкоуровневый API (см. <a class="xref" href="continuous-archiving.html#BACKUP-LOWLEVEL-BASE-BACKUP" title="26.3.3. Создание базовой резервной копии через низкоуровневый API">Подраздел 26.3.3</a>).</p><p>Продолжительность создания резервной копии обычно не имеет большого значения. Однако если вы эксплуатируете сервер с отключённым режимом <code class="varname">full_page_writes</code>, вы можете заметить падение производительности в процессе резервного копирования, так как режим <code class="varname">full_page_writes</code> включается принудительно на время резервного копирования.</p><p>Чтобы резервной копией можно было пользоваться, нужно сохранить все файлы сегментов WAL, сгенерированные во время и после копирования файлов. Для облегчения этой задачи, процесс создания базовой резервной копии записывает <em class="firstterm">файл истории резервного копирования</em>, который немедленно сохраняется в области архивации WAL. Данный файл получает имя по имени файла первого сегмента WAL, который потребуется для восстановления скопированных файлов. Например, если начальный файл WAL назывался <code class="literal">0000000100001234000055CD</code>, файл истории резервного копирования получит имя <code class="literal">0000000100001234000055CD.007C9330.backup</code>. (Вторая часть имени файла обозначает точную позицию внутри файла WAL и обычно может быть проигнорирована.) Как только вы заархивировали копии файлов данных и файлов сегментов WAL, полученных в процессе копирования (по сведениям в файле истории резервного копирования), все заархивированные сегменты WAL с именами, меньшими по номеру, становятся ненужными для восстановления файловой копии и могут быть удалены. Но всё же рассмотрите возможность хранения нескольких наборов резервных копий, чтобы быть абсолютно уверенными, что вы сможете восстановить ваши данные.</p><p>Файл истории резервного копирования — это просто небольшой текстовый файл. В него записывается метка, которая была передана <a class="xref" href="app-pgbasebackup.html" title="pg_basebackup"><span class="refentrytitle"><span class="application">pg_basebackup</span></span></a>, а также время и текущие сегменты WAL в момент начала и завершения резервной копии. Если вы связали с данной меткой соответствующий файл дампа, то заархивированного файла истории достаточно, чтобы найти файл дампа, нужный для восстановления.</p><p>Поскольку необходимо хранить все заархивированные файлы WAL с момента последней базовой резервной копии, интервал базового резервного копирования обычно выбирается в зависимости от того, сколько места может быть выделено для архива файлов WAL. Также стоит отталкиваться от того, сколько вы готовы ожидать восстановления, если оно понадобится — системе придётся воспроизвести все эти сегменты WAL, а этот процесс может быть долгим, если с момента последней базовой копии прошло много времени.</p></div><div class="sect2" id="BACKUP-LOWLEVEL-BASE-BACKUP"><div class="titlepage"><div><div><h3 class="title">26.3.3. Создание базовой резервной копии через низкоуровневый API <a href="#BACKUP-LOWLEVEL-BASE-BACKUP" class="id_link">#</a></h3></div></div></div><p>Процедура создания базовой резервной копии с использованием низкоуровневого API содержит чуть больше шагов, чем метод <a class="xref" href="app-pgbasebackup.html" title="pg_basebackup"><span class="refentrytitle"><span class="application">pg_basebackup</span></span></a>, но всё же относительно проста. Очень важно, чтобы эти шаги выполнялись по порядку, и следующий шаг выполнялся, только если предыдущий успешен.</p><p>Несколько процессов резервного копирования могут быть запущены параллельно (используя данный API или <a class="xref" href="app-pgbasebackup.html" title="pg_basebackup"><span class="refentrytitle"><span class="application">pg_basebackup</span></span></a>).</p><p>
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Убедитесь, что архивирование WAL включено и работает.</p></li><li class="listitem"><p>Подключитесь к серверу (к любой базе данных) как пользователь с правами на выполнение <code class="function">pg_backup_start</code> (суперпользователь или пользователь, которому дано право <code class="literal">EXECUTE</code> для этой функции) и выполните команду: </p><pre class="programlisting">SELECT pg_backup_start(label =&gt; 'label', fast =&gt; false);</pre><p> где <code class="literal">label</code> — любая метка, по которой можно однозначно идентифицировать данную операцию резервного копирования. Соединение, через которое вызывается <code class="function">pg_backup_start</code>, должно поддерживаться до окончания резервного копирования, иначе этот процесс будет автоматически прерван.</p><p>Резервное копирование всегда запускается в начале контрольной точки. По умолчанию <code class="function">pg_backup_start</code> будет ждать следующей запланированной контрольной точки, что может занять длительное время (см. конфигурационные параметры <a class="xref" href="runtime-config-wal.html#GUC-CHECKPOINT-COMPLETION-TARGET">checkpoint_completion_target</a> и <a class="xref" href="runtime-config-wal.html#GUC-CHECKPOINT-COMPLETION-TARGET">checkpoint_completion_target</a>). Обычно это вполне приемлемо, так как при этом минимизируется влияние на выполнение других запросов. Если же вы хотите начать резервное копирование максимально быстро, передайте во втором параметре <code class="function">pg_backup_start</code> значение <code class="literal">true</code>. В этом случае контрольная точка будет выполнена немедленно без ограничения объёма ввода/вывода.</p></li><li class="listitem"><p>Скопируйте файлы, используя любое удобное средство резервного копирования, например, <span class="application">tar</span> или <span class="application">cpio</span> (не <span class="application">pg_dump</span> или <span class="application">pg_dumpall</span>). В процессе копирования останавливать работу базы данных не требуется, это ничего не даёт. В <a class="xref" href="continuous-archiving.html#BACKUP-LOWLEVEL-BASE-BACKUP-DATA" title="26.3.3.1. Копирование каталога данных">Подразделе 26.3.3.1</a> описано, что следует учитывать в процессе копирования.</p></li><li class="listitem"><p>Через то же подключение, что и раньше, выполните команду: </p><pre class="programlisting">SELECT * FROM pg_backup_stop(wait_for_archive =&gt; true);</pre><p> При этом сервер выйдет из режима резервного копирования. Ведущий сервер вместе с этим автоматически переключится на следующий сегмент WAL. На ведомом автоматическое переключение сегментов WAL невозможно, поэтому вы можете выполнить <code class="function">pg_switch_wal</code> на ведущем, чтобы произвести переключение вручную. Такое переключение позволяет получить готовый к архивированию последний сегмент WAL, записанный в процессе резервного копирования.</p><p>Функция <code class="function">pg_backup_stop</code> возвратит одну строку с тремя значениями. Второе из них нужно записать в файл <code class="filename">backup_label</code> в корневой каталог резервной копии. Третье значение, если оно не пустое, должно быть записано в файл <code class="filename">tablespace_map</code>. Эти файлы крайне важны для восстановления копии и должны записываться байт за байтом без изменений, для чего может потребоваться открыть файл в двоичном редакторе.</p></li><li class="listitem"><p>Как только файлы сегментов WAL, активные во время создания резервной копии, будут заархивированы, процедура резервного копирования будет завершена. Функция <code class="function">pg_backup_stop</code> в первом значении результата указывает, какой последний сегмент требуется для формирования полного набора файлов резервной копии. На ведущем сервере, если включён режим архивации (параметр <code class="varname">archive_mode</code>) и аргумент <code class="literal">wait_for_archive</code> равен <code class="literal">true</code>, функция <code class="function">pg_backup_stop</code> не завершится, пока не будет заархивирован последний сегмент. На ведомом параметр <code class="varname">archive_mode</code> должен иметь значение <code class="literal">always</code>, чтобы функция <code class="function">pg_backup_stop</code> ожидала архивации. Эти файлы будут заархивированы автоматически, так как вы ранее задали значение <code class="varname">archive_library</code> или <code class="varname">archive_command</code>. Чаще всего это происходит быстро, но мы советуем наблюдать за системой архивации и проверять, не возникают ли задержки. Если архивирование остановится из-за ошибок команды или библиотеки архивации, попытки архивации будут продолжаться до успешного завершения, и только тогда резервное копирование окончится. Если вы хотите ограничить время выполнения <code class="function">pg_backup_stop</code>, установите соответствующее значение в <code class="varname">statement_timeout</code>, но заметьте, что в случае прерывания <code class="function">pg_backup_stop</code> по времени резервная копия может оказаться негодной.</p><p>Если в процедуре резервного копирования предусмотрено отслеживание и архивация всех файлов сегментов WAL, необходимых для резервной копии, то в аргументе <code class="literal">wait_for_archive</code> (по умолчанию равном true) можно передать false, чтобы функция <code class="function">pg_backup_stop</code> завершилась сразу, как только в WAL будет помещена запись о завершении копирования. По умолчанию <code class="function">pg_backup_stop</code> будет ждать окончания архивации всех файлов WAL, что может занять некоторое время. Использовать этот параметр следует с осторожностью: если архивация WAL не контролируется, в резервной копии могут оказаться не все необходимые файлы WAL и её нельзя будет восстановить.</p></li></ol></div><p>
    </p><div class="sect3" id="BACKUP-LOWLEVEL-BASE-BACKUP-DATA"><div class="titlepage"><div><div><h4 class="title">26.3.3.1. Копирование каталога данных <a href="#BACKUP-LOWLEVEL-BASE-BACKUP-DATA" class="id_link">#</a></h4></div></div></div><p>Некоторые средства резервного копирования файлов выдают предупреждения или ошибки, если файлы, которые они пытаются скопировать, изменяются в процессе копирования. При получении базовой резервной копии активной базы данных это вполне нормально и не является ошибкой. Однако вам нужно знать, как отличить ошибки такого рода от реальных ошибок. Например, некоторые версии <span class="application">rsync</span> возвращают отдельный код завершения для ситуации <span class="quote">«<span class="quote">исчезнувшие исходные файлы</span>»</span>, и вы можете написать управляющий скрипт, который примет этот код как не ошибочный. Также некоторые версии GNU <span class="application">tar</span> возвращают код завершения, неотличимый от кода критической ошибки, если файл был усечён, когда <span class="application">tar</span> копировал его. К счастью, GNU <span class="application">tar</span> версий 1.16 и более поздних завершается с кодом 1, если файл был изменён во время копирования, и 2 в случае других ошибок. С GNU <span class="application">tar</span> версии 1.23 и более поздними, вы можете использовать следующие ключи <code class="literal">--warning=no-file-changed --warning=no-file-removed</code>, чтобы скрыть соответствующие предупреждения.</p><p>Убедитесь, что ваша резервная копия включает все файлы из каталога кластера баз данных (например, <code class="filename">/usr/local/pgsql/data</code>). Если вы используете табличные пространства, которые находятся не внутри этого каталога, не забудьте включить и их в резервную копию (также важно, чтобы при создании резервной копии символьные ссылки сохранялись как ссылки, иначе табличные пространства будут повреждены при восстановлении).</p><p>Однако следует исключить из резервной копии файлы в подкаталоге данных кластера <code class="filename">pg_wal/</code>. Эту небольшую корректировку стоит внести для снижения риска ошибок при восстановлении. Это легко организовать, если <code class="filename">pg_wal/</code> — символическая ссылка на каталог за пределами каталога данных (так часто делают из соображений производительности). Также имеет смысл исключить файлы <code class="filename">postmaster.pid</code> и <code class="filename">postmaster.opts</code>, содержащие информацию о работающем процессе <span class="application">postmaster</span> (а не о том процессе <span class="application">postmaster</span>, который будет восстанавливать эту копию). (Эти файлы могут ввести <span class="application">pg_ctl</span> в заблуждение.)</p><p>Часто также стоит исключать из резервной копии каталог <code class="filename">pg_replslot/</code> кластера, чтобы слоты репликации, существующие на главном сервере, не попадали в копию. В противном случае при последующем восстановлении копии на резервном сервере может получиться так, что он будет неограниченно долго сохранять файлы WAL, а главный не будет очищаться, если он следит за горячим резервом, так как клиенты этих слотов репликации будут продолжать подключаться и изменять состояние слотов на главном, а не резервном сервере. Даже если резервная копия предназначена только для создания нового главного сервера, копирование слотов репликации вряд ли принесёт пользу, так как к моменту включения в работу этого нового сервера содержимое этих слотов станет абсолютно неактуальным.</p><p>Содержимое каталогов <code class="filename">pg_dynshmem/</code>, <code class="filename">pg_notify/</code>, <code class="filename">pg_serial/</code>, <code class="filename">pg_snapshots/</code>, <code class="filename">pg_stat_tmp/</code> и <code class="filename">pg_subtrans/</code> (но не сами эти каталоги) можно исключить из резервной копии, так как оно будет инициализировано при запуске главного процесса.</p><p>Из резервной копии можно исключить и файлы и подкаталоги с именами, начинающимся с <code class="filename">pgsql_tmp</code>. Эти файлы удаляются при запуске главного процесса, а каталоги создаются по мере необходимости.</p><p>Из резервной копии могут быть исключены файлы <code class="filename">pg_internal.init</code>. Такие файлы содержат кешируемые данные отношения и всегда перестраиваются при восстановлении.</p><p>В файл метки резервной копии записывается строка метки, заданная при вызове <code class="function">pg_backup_start</code>, время запуска функции <code class="function">pg_backup_start</code> и имя начального файла WAL. Таким образом, в случае сомнений можно заглянуть внутрь архива резервной копии и точно определить, в каком сеансе резервного копирования он был создан. Файл карты табличных пространств содержит имена символических ссылок, как они существуют в каталоге <code class="filename">pg_tblspc/</code>, и полный путь каждой символической ссылки. Эти файлы не только к вашему сведению; их существование и содержание важны для правильного проведения процесса восстановления системы.</p><p>Вы также можете создать резервную копию, когда сервер остановлен. В этом случае, вы, очевидно, не сможете вызвать <code class="function">pg_backup_start</code> или <code class="function">pg_backup_stop</code>, и следовательно, вам надо будет самостоятельно как-то идентифицировать резервные копии и понимать, какие файлы WAL должны быть заархивированы. Поэтому обычно всё-таки лучше следовать вышеописанной процедуре непрерывного архивирования.</p></div></div><div class="sect2" id="BACKUP-PITR-RECOVERY"><div class="titlepage"><div><div><h3 class="title">26.3.4. Восстановление непрерывной архивной копии <a href="#BACKUP-PITR-RECOVERY" class="id_link">#</a></h3></div></div></div><p>Допустим, худшее случилось, и вам необходимо восстановить базу данных из резервной копии. Порядок действий таков: </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Остановите сервер баз данных, если он запущен.</p></li><li class="listitem"><p>Если у вас есть место для этого, скопируйте весь текущий каталог кластера баз данных и все табличные пространства во временный каталог на случай, если они вам понадобятся. Учтите, что эта мера предосторожности требует, чтобы свободного места на диске было достаточно для размещения двух копий существующих данных. Если места недостаточно, необходимо сохранить как минимум содержимое подкаталога <code class="filename">pg_wal</code> каталога кластера, так как он может содержать файлы WAL, не попавшие в архив перед остановкой системы.</p></li><li class="listitem"><p>Удалите все существующие файлы и подкаталоги из каталога кластера и из корневых каталогов используемых табличных пространств.</p></li><li class="listitem"><p>Восстановите файлы базы данных из резервной копии файлов. Важно, чтобы у восстановленных файлов были правильные разрешения и правильный владелец (пользователь, запускающий сервер, а не <code class="literal">root</code>!). Если вы используете табличные пространства, убедитесь также, что символьные ссылки в <code class="filename">pg_tblspc/</code> восстановились корректно.</p></li><li class="listitem"><p>Удалите все файлы из <code class="filename">pg_wal/</code>; они восстановились из резервной копии файлов и поэтому, скорее всего, будут старее текущих. Если вы вовсе не архивировали <code class="filename">pg_wal/</code>, создайте этот каталог с правильными правами доступа, но если это была символьная ссылка, восстановите её.</p></li><li class="listitem"><p>Если на шаге 2 вы сохранили незаархивированные файлы с сегментами WAL, скопируйте их в <code class="filename">pg_wal/</code>. (Лучше всего именно копировать, а не перемещать их, чтобы у вас остались неизменённые файлы на случай, если возникнет проблема и всё придётся начинать сначала.)</p></li><li class="listitem"><p>Установите параметры восстановления в <code class="filename">postgresql.conf</code> (см. <a class="xref" href="runtime-config-wal.html#RUNTIME-CONFIG-WAL-ARCHIVE-RECOVERY" title="20.5.5. Восстановление из архива">Подраздел 20.5.5</a>) и создайте файл <code class="filename">recovery.signal</code> в каталоге данных кластера. Вы можете также временно изменить <code class="filename">pg_hba.conf</code>, чтобы обычные пользователи не могли подключиться, пока вы не будете уверены, что восстановление завершилось успешно.</p></li><li class="listitem"><p>Запустите сервер. Сервер запустится в режиме восстановления и начнёт считывать необходимые ему архивные файлы WAL. Если восстановление будет прервано из-за внешней ошибки, сервер можно просто перезапустить и он продолжит восстановление. По завершении процесса восстановления сервер удалит файл <code class="filename">recovery.signal</code> (чтобы предотвратить повторный запуск режима восстановления), а затем перейдёт к обычной работе с базой данных.</p></li><li class="listitem"><p>Просмотрите содержимое базы данных, чтобы убедиться, что вы вернули её к желаемому состоянию. Если это не так, вернитесь к шагу 1. Если всё хорошо, разрешите пользователям подключаться к серверу, восстановив обычный файл <code class="filename">pg_hba.conf</code>.</p></li></ol></div><p>Ключевой момент этой процедуры заключается в создании конфигурации восстановления, описывающей, как будет выполняться восстановление и до какой точки. Единственное, что совершенно необходимо задать — это команду <code class="varname">restore_command</code>, которая говорит <span class="productname">PostgreSQL</span>, как получать из архива файл-сегменты WAL. Как и <code class="varname">archive_command</code>, это командная строка для оболочки. Она может содержать символы <code class="literal">%f</code>, которые заменятся именем требующегося файла WAL, и <code class="literal">%p</code>, которые заменятся целевым путём для копирования этого файла. (Путь задаётся относительно текущего рабочего каталога, т. е. каталога кластера данных.) Если вам нужно включить в команду сам символ <code class="literal">%</code>, напишите <code class="literal">%%</code>. Простейшая команда, которая может быть полезна, такая: </p><pre class="programlisting">restore_command = 'cp /mnt/server/archivedir/%f %p'</pre><p> Эта команда копирует заархивированные ранее сегменты WAL из каталога <code class="filename">/mnt/server/archivedir</code>. Разумеется, вы можете использовать что-то более сложное, возможно, даже скрипт оболочки, который укажет оператору установить соответствующую ленту.</p><p>Важно, чтобы данная команда возвращала ненулевой код возврата в случае ошибки. Эта команда <span class="emphasis"><em>будет</em></span> вызываться и с запросом файлов, отсутствующих в архиве; в этом случае она должна вернуть ненулевое значение и это считается штатной ситуацией. В исключительной ситуации, когда команда была прервана сигналом (кроме <span class="systemitem">SIGTERM</span>, который применяется в процессе остановки сервера базы данных) или произошла ошибка оболочки (например, команда не найдена), восстановление будет прервано и сервер не запустится.</p><p>Не все запрашиваемые файлы будут сегментами WAL; следует также ожидать запросов файлов с суффиксом <code class="literal">.history</code>. Также учтите, что базовое имя пути <code class="literal">%p</code> будет отличаться от <code class="literal">%f</code>; не думайте, что они взаимозаменяемы.</p><p>Сегменты WAL, которые не найдутся в архиве, система будет искать в <code class="filename">pg_wal/</code>; благодаря этому можно использовать последние незаархивированные сегменты. Однако файлы в <code class="filename">pg_wal/</code> будут менее предпочтительными, если такие сегменты окажутся в архиве.</p><p>Обычно при восстановлении обрабатываются все доступные сегменты WAL и, таким образом, база данных восстанавливается до последнего момента времени (или максимально близкого к нему, в зависимости от наличия сегментов WAL). Таким образом, восстановление обычно завершается с сообщением <span class="quote">«<span class="quote">файл не найден</span>»</span>; точный текст сообщения об ошибке зависит от того, что делает <code class="varname">restore_command</code>. Вы также можете увидеть сообщение об ошибке в начале восстановления для файла с именем типа <code class="filename">00000001.history</code>. Это также нормально и обычно не говорит о какой-либо проблеме при восстановлении в простых ситуациях; подробнее об этом рассказывается в <a class="xref" href="continuous-archiving.html#BACKUP-TIMELINES" title="26.3.5. Линии времени">Подразделе 26.3.5</a>.</p><p>Если вы хотите восстановить базу на какой-то момент времени (скажем, до момента, когда неопытный администратор базы данных удалил основную таблицу транзакций), просто укажите требуемую <a class="link" href="runtime-config-wal.html#RUNTIME-CONFIG-WAL-RECOVERY-TARGET" title="20.5.6. Цель восстановления">точку остановки</a>. Вы можете задать эту точку, иначе называемую <span class="quote">«<span class="quote">целью восстановления</span>»</span>, по дате/времени, именованной точке восстановления или определённому идентификатору транзакции. На момент написания этой документации полезными могут быть только указания даты/времени или имени точки восстановления, пока нет никаких средств, позволяющих точно определить, какой идентификатор транзакции нужно выбрать.</p><div class="note"><h3 class="title">Примечание</h3><p>Точка останова должна указывать на момент после окончания базового копирования, т. е. после времени завершения <code class="function">pg_backup_stop</code>. Использовать базовую резервную копию для восстановления на момент времени, когда она ещё только создавалась, нельзя. (Чтобы восстановить данные на этот момент времени, придётся вернуться к предыдущей базовой резервной копии и накатывать изменения с этой позиции.)</p></div><p>Если при восстановлении обнаруживаются повреждённые данные WAL, восстановление прерывается в этом месте и сервер не запускается. В этом случае процесс восстановления можно перезапустить с начала, указав <span class="quote">«<span class="quote">цель восстановления</span>»</span> до точки повреждения, чтобы восстановление могло завершиться нормально. Если восстановление завершается ошибкой из-за внешней причины, например, из-за краха системы или недоступности архива WAL, его можно просто перезапустить, и оно продолжится с того места, где было прервано. Перезапуск восстановления реализован по тому же принципу, что и контрольные точки при обычной работе: сервер периодически сохраняет всё текущее состояние на диске и отражает это в файле <code class="filename">pg_control</code>, чтобы уже обработанные данные WAL не приходилось сканировать снова.</p></div><div class="sect2" id="BACKUP-TIMELINES"><div class="titlepage"><div><div><h3 class="title">26.3.5. Линии времени <a href="#BACKUP-TIMELINES" class="id_link">#</a></h3></div></div></div><a id="id-1.6.13.7.13.2" class="indexterm"></a><p>Возможность восстановить базу данных на некий предыдущий момент времени создаёт некоторые сложности, сродни научно-фантастическим историям о путешествиях во времени и параллельных мирах. Например, предположим, что в начальной истории базы данных вы удалили важную таблицу в 17:15 во вторник, но осознали эту ошибку только в среду в полдень. Вы можете спокойно взять резервную копию, восстановить данные на 17:14 во вторник и запустить сервер. В <span class="emphasis"><em>этой</em></span> истории мира базы данных вы никогда не удаляли вышеупомянутую таблицу. Но предположим, что позже вы заметили, что это была не такая уж хорошая идея и захотели вернуться к утру среды в первоначальной истории базы данных. Вы не сможете сделать это, если в процессе работы базы данных она успеет перезаписать какие-либо файлы-сегменты WAL, приводящие к моменту времени, к которому вы хотите вернуться теперь. Таким образом, для получения желаемого результата необходимо как-то отличать последовательности записей WAL, добавленные после восстановления на какой-то момент времени от тех, что существовали в начальной истории базы данных.</p><p>Для решения этой проблемы в <span class="productname">PostgreSQL</span> есть такое понятие, как <em class="firstterm">линия времени</em>. Всякий раз, когда завершается восстановление из архива, создаётся новая линия времени, позволяющая идентифицировать последовательность записей WAL, добавленных после этого восстановления. Номер линии времени включается в имя файлов-сегментов WAL, так что файлы новой линии времени не перезаписывают данные WAL, сгенерированные предыдущими линиями времени. Например, <code class="literal">00000001</code> в имени файла WAL <code class="filename">0000000100001234000055CD</code> — это идентификатор линии времени в шестнадцатеричном формате. (Обратите внимание, что в других контекстах, например в сообщениях журнала сервера, идентификаторы линии времени обычно выводятся в десятичном формате.)</p><p>Фактически можно архивировать много различных линий времени. Хотя это может показаться бесполезной возможностью, на самом деле она часто бывает спасительной. Представьте, что вы не определились, какую точку времени выбрать для восстановления, и таким образом должны проводить восстановление методом проб и ошибок, пока не найдёте лучший момент для ответвления от старой истории. Без линий времени этот процесс быстро стал бы очень запутанным. А благодаря линиям времени можно вернуться к <span class="emphasis"><em>любому</em></span> предыдущему состоянию, включая состояния в ветках линий времени, покинутых ранее.</p><p>Каждый раз, когда образуется новая линия времени, <span class="productname">PostgreSQL</span> создаёт файл <span class="quote">«<span class="quote">истории линии времени</span>»</span>, показывающий, от какой линии времени ответвилась данная и когда. Эти файлы истории нужны, чтобы система могла выбрать правильные файлы-сегменты WAL при восстановлении из архива, содержащего несколько линий времени. Таким образом, они помещаются в область архивов WAL так же, как и файлы сегментов WAL. Файлы истории представляют собой небольшие текстовые файлы, так что они не занимают много места и их вполне можно сохранять неограниченно долго (в отличие от файлов сегментов, имеющих большой размер). Если хотите, вы можете добавлять в файл истории комментарии, свои собственные заметки о том, как и почему была создана эта конкретная линия времени. Такие комментарии будут особенно ценны, если в результате экспериментов у вас образуется хитросплетение разных линий времени.</p><p>По умолчанию восстановление осуществляется до самой последней линии времени, найденной в архиве. Если вы хотите восстановить состояние на линии времени, которая была текущей, когда создавалась копия, либо на какой-либо дочерней линии времени (то есть хотите вернуться к некоторому состоянию, которое тоже было получено в результате попытки восстановления), вам необходимо указать <code class="literal">current</code> или идентификатор целевой линии времени в <a class="xref" href="runtime-config-wal.html#GUC-RECOVERY-TARGET-TIMELINE">recovery_target_timeline</a>. Восстановить состояние на линии времени, ответвившейся раньше, чем была сделана базовая резервная копия, нельзя.</p></div><div class="sect2" id="BACKUP-TIPS"><div class="titlepage"><div><div><h3 class="title">26.3.6. Советы и примеры <a href="#BACKUP-TIPS" class="id_link">#</a></h3></div></div></div><p>Ниже мы дадим несколько советов по настройке непрерывного архивирования.</p><div class="sect3" id="BACKUP-STANDALONE"><div class="titlepage"><div><div><h4 class="title">26.3.6.1. Обособленные горячие резервные копии <a href="#BACKUP-STANDALONE" class="id_link">#</a></h4></div></div></div><p>Средства резервного копирования <span class="productname">PostgreSQL</span> можно применять для создания обособленных горячих копий. Эти копии нельзя использовать для восстановления на момент времени, но создаются и восстанавливаются они обычно гораздо быстрее, чем дампы <span class="application">pg_dump</span>. (Они также намного больше, чем дампы <span class="application">pg_dump</span>, так что в некоторых случаях выигрыш в скорости может быть потерян.)</p><p>Как и базовые резервные копии, обособленную горячую копию проще всего получить, используя программу <a class="xref" href="app-pgbasebackup.html" title="pg_basebackup"><span class="refentrytitle"><span class="application">pg_basebackup</span></span></a>. Если вы вызовете эту программу с параметром <code class="literal">-X</code>, в эту копию автоматически будет включён весь журнал предзаписи, необходимый для её использования, так что никакие особые действия для восстановления не потребуются.</p></div><div class="sect3" id="COMPRESSED-ARCHIVE-LOGS"><div class="titlepage"><div><div><h4 class="title">26.3.6.2. Сжатие журналов в архиве <a href="#COMPRESSED-ARCHIVE-LOGS" class="id_link">#</a></h4></div></div></div><p>Если размер архива имеет большое значение, можно воспользоваться <span class="application">gzip</span> и сжимать архивные файлы: </p><pre class="programlisting">archive_command = 'gzip &lt; %p &gt; /mnt/server/archivedir/%f.gz'</pre><p> При этом для восстановления придётся использовать <span class="application">gunzip</span>: </p><pre class="programlisting">restore_command = 'gunzip &lt; /mnt/server/archivedir/%f.gz &gt; %p'</pre></div><div class="sect3" id="BACKUP-SCRIPTS"><div class="titlepage"><div><div><h4 class="title">26.3.6.3. Скрипты <code class="varname">archive_command</code> <a href="#BACKUP-SCRIPTS" class="id_link">#</a></h4></div></div></div><p>Многие в качестве команды <code class="varname">archive_command</code> используют скрипты, так что запись в <code class="filename">postgresql.conf</code> оказывается очень простой: </p><pre class="programlisting">archive_command = 'local_backup_script.sh "%p" "%f"'</pre><p> Применять отдельный файла скрипта целесообразно всегда, когда вы хотите использовать в процедуре архивирования несколько команд. Это позволяет управлять сложностью этой процедуры в рамках одного скрипта, который можно написать на любом популярном языке скриптов, например на <span class="application">bash</span> или <span class="application">perl</span>.</p><p>В частности, с помощью скриптов можно решить такие задачи: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Копирование данных в безопасное внешнее хранилище</p></li><li class="listitem"><p>Пакетная обработка файлов WAL, чтобы они передавались каждые три часа, а не по одному</p></li><li class="listitem"><p>Взаимодействие с другими приложениями резервного копирования и восстановления</p></li><li class="listitem"><p>Взаимодействие со средствами мониторинга, регистрация ошибок</p></li></ul></div><div class="tip"><h3 class="title">Подсказка</h3><p>Когда в <code class="varname">archive_command</code> используется скрипт, желательно включить <a class="xref" href="runtime-config-logging.html#GUC-LOGGING-COLLECTOR">logging_collector</a>. Тогда все сообщения, которые скрипт выведет в <span class="systemitem">stderr</span>, будут записываться в журнал сервера баз данных, что позволит легко диагностировать ошибки в сложных конфигурациях.</p></div></div></div><div class="sect2" id="CONTINUOUS-ARCHIVING-CAVEATS"><div class="titlepage"><div><div><h3 class="title">26.3.7. Ограничения <a href="#CONTINUOUS-ARCHIVING-CAVEATS" class="id_link">#</a></h3></div></div></div><p>На момент написания документации методика непрерывного архивирования имеет несколько ограничений. Они могут быть ликвидированы в будущих версиях: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Если во время создания базовой резервной копии выполняется команда <a class="link" href="sql-createdatabase.html" title="CREATE DATABASE"><code class="command">CREATE DATABASE</code></a>, а затем база-шаблон, задействованная в <code class="command">CREATE DATABASE</code>, изменяется, пока продолжается копирование, возможно, что при восстановлении эти изменения распространятся также и на созданную базу данных. Конечно, это нежелательно. Во избежание подобных рисков, лучше всего не изменять никакие базы-шаблоны во время получения базовой резервной копии.</p></li><li class="listitem"><p>Команды <a class="link" href="sql-createtablespace.html" title="CREATE TABLESPACE"><code class="command">CREATE TABLESPACE</code></a> записываются в WAL с абсолютным путём и, таким образом, при воспроизведении WAL будут выполнены с тем же абсолютным путём. Это может быть нежелательно, если WAL воспроизводится на другой машине. Но опасность есть, даже если WAL воспроизводится на той же машине, но в другом каталоге данных: при воспроизведении будет так же перезаписано содержимое исходных табличных пространств. Во избежание потенциальных проблем такого рода лучше всего делать новую базовую резервную копию после создания или удаления табличных пространств.</p></li></ul></div><p>Также следует заметить, что стандартный формат <acronym class="acronym">WAL</acronym> не очень компактный, так как включает много снимков дисковых страниц. Эти снимки страниц предназначены для поддержки восстановления после сбоя, на случай, если понадобится исправить страницы, записанные на диск частично. В зависимости от аппаратного и программного обеспечения вашей системы, риск частичной записи может быть достаточно мал, так что его можно игнорировать, и в этом случае можно существенно уменьшить общий объём архивируемых файлов WAL, выключив снимки страниц с помощью параметра <a class="xref" href="runtime-config-wal.html#GUC-FULL-PAGE-WRITES">full_page_writes</a>. (Прежде чем делать это, прочтите замечания и предупреждения в <a class="xref" href="wal.html" title="Глава 30. Надёжность и журнал предзаписи">Главе 30</a>.) Выключение снимков страниц не препятствует использованию WAL для восстановления PITR. Одним из направлений разработки в будущем является сжатие архивируемых данных WAL путём удаления ненужных копий страниц даже при включённом режиме <code class="varname">full_page_writes</code>. Тем временем администраторы могут сократить количество снимков страниц, включаемых в WAL, увеличив параметры интервала контрольных точек в разумных пределах.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="backup-file.html" title="26.2. Резервное копирование на уровне файлов">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="backup.html" title="Глава 26. Резервное копирование и восстановление">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="high-availability.html" title="Глава 27. Отказоустойчивость, балансировка нагрузки и репликация">След.</a></td></tr><tr><td width="40%" align="left" valign="top">26.2. Резервное копирование на уровне файлов </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> Глава 27. Отказоустойчивость, балансировка нагрузки и репликация</td></tr></table></div></body></html>