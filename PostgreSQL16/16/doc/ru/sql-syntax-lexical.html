<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>4.1. Лексическая структура</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sql-syntax.html" title="Глава 4. Синтаксис SQL" /><link rel="next" href="sql-expressions.html" title="4.2. Выражения значения" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">4.1. Лексическая структура</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-syntax.html" title="Глава 4. Синтаксис SQL">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-syntax.html" title="Глава 4. Синтаксис SQL">Наверх</a></td><th width="60%" align="center">Глава 4. Синтаксис SQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-expressions.html" title="4.2. Выражения значения">След.</a></td></tr></table><hr /></div><div class="sect1" id="SQL-SYNTAX-LEXICAL"><div class="titlepage"><div><div><h2 class="title" style="clear: both">4.1. Лексическая структура <a href="#SQL-SYNTAX-LEXICAL" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS">4.1.1. Идентификаторы и ключевые слова</a></span></dt><dt><span class="sect2"><a href="sql-syntax-lexical.html#SQL-SYNTAX-CONSTANTS">4.1.2. Константы</a></span></dt><dt><span class="sect2"><a href="sql-syntax-lexical.html#SQL-SYNTAX-OPERATORS">4.1.3. Операторы</a></span></dt><dt><span class="sect2"><a href="sql-syntax-lexical.html#SQL-SYNTAX-SPECIAL-CHARS">4.1.4. Специальные знаки</a></span></dt><dt><span class="sect2"><a href="sql-syntax-lexical.html#SQL-SYNTAX-COMMENTS">4.1.5. Комментарии</a></span></dt><dt><span class="sect2"><a href="sql-syntax-lexical.html#SQL-PRECEDENCE">4.1.6. Приоритеты операторов</a></span></dt></dl></div><a id="id-1.5.3.5.2" class="indexterm"></a><p>SQL-программа состоит из последовательности <em class="firstterm">команд</em>. Команда, в свою очередь, представляет собой последовательность <em class="firstterm">компонентов</em>, оканчивающуюся точкой с запятой (<span class="quote">«<span class="quote">;</span>»</span>). Конец входного потока также считается концом команды. Какие именно компоненты допустимы для конкретной команды, зависит от её синтаксиса.</p><p>Компонентом команды может быть <em class="firstterm">ключевое слово</em>, <em class="firstterm">идентификатор</em>, <em class="firstterm">идентификатор в кавычках</em>, <em class="firstterm">строка</em> (или константа) или специальный символ. Компоненты обычно разделяются пробельными символами (пробел, табуляция, перевод строки), но это не требуется, если нет неоднозначности (например, когда спецсимвол оказывается рядом с компонентом другого типа).</p><p>Например, следующий текст является правильной (синтаксически) SQL-программой: </p><pre class="programlisting">SELECT * FROM MY_TABLE;
UPDATE MY_TABLE SET A = 5;
INSERT INTO MY_TABLE VALUES (3, 'hi there');</pre><p> Это последовательность трёх команд, по одной в строке (хотя их можно было разместить и в одну строку или наоборот, разделить команды на несколько строк).</p><p>Кроме этого, SQL-программы могут содержать <em class="firstterm">комментарии</em>. Они не являются компонентами команд, а по сути равносильны пробельным символам.</p><p>Синтаксис SQL не очень строго определяет, какие компоненты идентифицируют команды, а какие — их операнды или параметры. Первые несколько компонентов обычно содержат имя команды, так что в данном примере мы можем говорить о командах <span class="quote">«<span class="quote">SELECT</span>»</span>, <span class="quote">«<span class="quote">UPDATE</span>»</span> и <span class="quote">«<span class="quote">INSERT</span>»</span>. Но например, команда <code class="command">UPDATE</code> требует, чтобы также в определённом положении всегда стоял компонент <code class="token">SET</code>, а <code class="command">INSERT</code> в приведённом виде требует наличия компонента <code class="token">VALUES</code>. Точные синтаксические правила для каждой команды описаны в <a class="xref" href="reference.html" title="Часть VI. Справочное руководство">Части VI</a>.</p><div class="sect2" id="SQL-SYNTAX-IDENTIFIERS"><div class="titlepage"><div><div><h3 class="title">4.1.1. Идентификаторы и ключевые слова <a href="#SQL-SYNTAX-IDENTIFIERS" class="id_link">#</a></h3></div></div></div><a id="id-1.5.3.5.8.2" class="indexterm"></a><a id="id-1.5.3.5.8.3" class="indexterm"></a><a id="id-1.5.3.5.8.4" class="indexterm"></a><p>Показанные выше команды содержали компоненты <code class="token">SELECT</code>, <code class="token">UPDATE</code> и <code class="token">VALUES</code>, которые являются примерами <em class="firstterm">ключевых слов</em>, то есть слов, имеющих фиксированное значение в языке SQL. Компоненты <code class="token">MY_TABLE</code> и <code class="token">A</code> являются примерами <em class="firstterm">идентификаторов</em>. Они идентифицируют имена таблиц, столбцов или других объектов баз данных, в зависимости от того, где они используются. Поэтому иногда их называют просто <span class="quote">«<span class="quote">именами</span>»</span>. Ключевые слова и идентификаторы имеют одинаковую лексическую структуру, то есть, не зная языка, нельзя определить, является ли некоторый компонент ключевым словом или идентификатором. Полный список ключевых слов приведён в <a class="xref" href="sql-keywords-appendix.html" title="Приложение C. Ключевые слова SQL">Приложении C</a>.</p><p>Идентификаторы и ключевые слова SQL должны начинаться с буквы (<code class="literal">a</code>-<code class="literal">z</code>, хотя допускаются также не латинские буквы и буквы с диакритическими знаками) или подчёркивания (<code class="literal">_</code>). Последующими символами в идентификаторе или ключевом слове могут быть буквы, цифры (<code class="literal">0</code>-<code class="literal">9</code>), знаки доллара (<code class="literal">$</code>) или подчёркивания. Заметьте, что строго следуя букве стандарта SQL, знаки доллара нельзя использовать в идентификаторах, так что их использование вредит переносимости приложений. В стандарте SQL гарантированно не будет ключевых слов с цифрами и начинающихся или заканчивающихся подчёркиванием, так что идентификаторы такого вида защищены от возможных конфликтов с будущими расширениями стандарта.</p><p><a id="id-1.5.3.5.8.7.1" class="indexterm"></a> Система выделяет для идентификатора не более <code class="symbol">NAMEDATALEN</code>-1 байт, а более длинные имена усекаются. По умолчанию <code class="symbol">NAMEDATALEN</code> равно 64, так что максимальная длина идентификатора равна 63 байтам. Если этого недостаточно, этот предел можно увеличить, изменив константу <code class="symbol">NAMEDATALEN</code> в файле <code class="filename">src/include/pg_config_manual.h</code>.</p><p><a id="id-1.5.3.5.8.8.1" class="indexterm"></a> Ключевые слова и идентификаторы без кавычек воспринимаются системой без учёта регистра. Таким образом: </p><pre class="programlisting">UPDATE MY_TABLE SET A = 5;</pre><p> равносильно записи: </p><pre class="programlisting">uPDaTE my_TabLE SeT a = 5;</pre><p> Часто используется неформальное соглашение записывать ключевые слова заглавными буквами, а имена строчными, например: </p><pre class="programlisting">UPDATE my_table SET a = 5;</pre><p><a id="id-1.5.3.5.8.9.1" class="indexterm"></a> Есть и другой тип идентификаторов: <em class="firstterm">отделённые идентификаторы</em> или <em class="firstterm">идентификаторы в кавычках</em>. Они образуются при заключении обычного набора символов в двойные кавычки (<code class="literal">"</code>). Такие идентификаторы всегда будут считаться идентификаторами, но не ключевыми словами. Так <code class="literal">"select"</code> можно использовать для обозначения столбца или таблицы <span class="quote">«<span class="quote">select</span>»</span>, тогда как <code class="literal">select</code> без кавычек будет воспринят как ключевое слово и приведёт к ошибке разбора команды в месте, где ожидается имя таблицы или столбца. Тот же пример можно переписать с идентификаторами в кавычках следующим образом: </p><pre class="programlisting">UPDATE "my_table" SET "a" = 5;</pre><p>Идентификаторы в кавычках могут содержать любые символы, за исключением символа с кодом 0. (Чтобы включить в такой идентификатор кавычки, продублируйте их.) Это позволяет создавать таблицы и столбцы с именами, которые иначе были бы невозможны, например, с пробелами или амперсандами. Ограничение длины при этом сохраняется.</p><p>Идентификатор, заключённый в кавычки, становится зависимым от регистра, тогда как идентификаторы без кавычек всегда переводятся в нижний регистр. Например, идентификаторы <code class="literal">FOO</code>, <code class="literal">foo</code> и <code class="literal">"foo"</code> считаются одинаковыми в <span class="productname">PostgreSQL</span>, но <code class="literal">"Foo"</code> и <code class="literal">"FOO"</code> отличны друг от друга и от предыдущих трёх. (Приведение имён без кавычек к нижнему регистру, как это делает <span class="productname">PostgreSQL</span>, несовместимо со стандартом SQL, который говорит о том, что имена должны приводиться к верхнему регистру. То есть, согласно стандарту <code class="literal">foo</code> должно быть эквивалентно <code class="literal">"FOO"</code>, а не <code class="literal">"foo"</code>. Поэтому при создании переносимых приложений рекомендуется либо всегда заключать определённое имя в кавычки, либо не заключать никогда.)</p><a id="id-1.5.3.5.8.12" class="indexterm"></a><p>Ещё один вариант идентификаторов в кавычках позволяет использовать символы Unicode по их кодам. Такой идентификатор начинается с <code class="literal">U&amp;</code> (строчная или заглавная U и амперсанд), а затем сразу без пробелов идёт двойная кавычка, например <code class="literal">U&amp;"foo"</code>. (Заметьте, что при этом возникает неоднозначность с оператором <code class="literal">&amp;</code>. Чтобы её избежать, окружайте этот оператор пробелами.) Затем в кавычках можно записывать символы Unicode двумя способами: обратная косая черта, а за ней код символа из четырёх шестнадцатеричных цифр, либо обратная косая черта, знак плюс, а затем код из шести шестнадцатеричных цифр. Например, идентификатор <code class="literal">"data"</code> можно записать так: </p><pre class="programlisting">U&amp;"d\0061t\+000061"</pre><p> В следующем менее тривиальном примере закодировано русское слово <span class="quote">«<span class="quote">слон</span>»</span>, записанное кириллицей: </p><pre class="programlisting">U&amp;"\0441\043B\043E\043D"</pre><p>Если вы хотите использовать не обратную косую черту, а другой спецсимвол, его можно указать, добавив <code class="literal">UESCAPE</code> <a id="id-1.5.3.5.8.14.2" class="indexterm"></a> после строки, например: </p><pre class="programlisting">U&amp;"d!0061t!+000061" UESCAPE '!'</pre><p> В качестве спецсимвола можно выбрать любой символ, кроме шестнадцатеричной цифры, знака плюс, апострофа, кавычки или пробельного символа. Заметьте, что спецсимвол заключается не в двойные кавычки, а в апострофы, после <code class="literal">UESCAPE</code>.</p><p>Чтобы сделать спецсимволом знак апострофа, напишите его дважды.</p><p>Записывать суррогатные пары UTF-16 и таким образом составлять символы с кодами больше чем U+FFFF можно либо в четырёх-, либо в шестизначной форме, хотя наличие шестизначной формы технически делает это ненужным. (Суррогатные пары не сохраняются непосредственно, а объединяются в один символ, который затем кодируется в UTF-8.)</p><p>Когда кодировка сервера — не UTF-8, символ с кодом, указанным этой спецпоследовательностью, преобразуется в фактическую кодировку сервера; если такое преобразование невозможно, выдаётся ошибка.</p></div><div class="sect2" id="SQL-SYNTAX-CONSTANTS"><div class="titlepage"><div><div><h3 class="title">4.1.2. Константы <a href="#SQL-SYNTAX-CONSTANTS" class="id_link">#</a></h3></div></div></div><a id="id-1.5.3.5.9.2" class="indexterm"></a><p>В <span class="productname">PostgreSQL</span> есть три типа констант <em class="firstterm">подразумеваемых типов</em>: строки, битовые строки и числа. Константы можно также записывать, указывая типы явно, что позволяет представить их более точно и обработать более эффективно. Эти варианты рассматриваются в следующих подразделах.</p><div class="sect3" id="SQL-SYNTAX-STRINGS"><div class="titlepage"><div><div><h4 class="title">4.1.2.1. Строковые константы <a href="#SQL-SYNTAX-STRINGS" class="id_link">#</a></h4></div></div></div><a id="id-1.5.3.5.9.4.2" class="indexterm"></a><p><a id="id-1.5.3.5.9.4.3.1" class="indexterm"></a> Строковая константа в SQL — это обычная последовательность символов, заключённая в апострофы (<code class="literal">'</code>), например: <code class="literal">'Это строка'</code>. Чтобы включить апостроф в строку, напишите в ней два апострофа рядом, например: <code class="literal">'Жанна д''Арк'</code>. Заметьте, это <span class="emphasis"><em>не</em></span> то же самое, что двойная кавычка (<code class="literal">"</code>).</p><p>Две строковые константы, разделённые пробельными символами <span class="emphasis"><em>и минимум одним переводом строки</em></span>, объединяются в одну и обрабатываются, как если бы строка была записана в одной константе. Например: </p><pre class="programlisting">SELECT 'foo'
'bar';</pre><p> эквивалентно: </p><pre class="programlisting">SELECT 'foobar';</pre><p> но эта запись: </p><pre class="programlisting">SELECT 'foo'      'bar';</pre><p> считается синтаксической ошибкой. (Это несколько странное поведение определено в стандарте <acronym class="acronym">SQL</acronym>, <span class="productname">PostgreSQL</span> просто следует ему.)</p></div><div class="sect3" id="SQL-SYNTAX-STRINGS-ESCAPE"><div class="titlepage"><div><div><h4 class="title">4.1.2.2. Строковые константы со спецпоследовательностями в стиле C <a href="#SQL-SYNTAX-STRINGS-ESCAPE" class="id_link">#</a></h4></div></div></div><a id="id-1.5.3.5.9.5.2" class="indexterm"></a><a id="id-1.5.3.5.9.5.3" class="indexterm"></a><p><span class="productname">PostgreSQL</span> также принимает <span class="quote">«<span class="quote">спецпоследовательности</span>»</span>, что является расширением стандарта SQL. Строка со спецпоследовательностями начинается с буквы <code class="literal">E</code> (заглавной или строчной), стоящей непосредственно перед апострофом, например: <code class="literal">E'foo'</code>. (Когда константа со спецпоследовательностью разбивается на несколько строк, букву <code class="literal">E</code> нужно поставить только перед первым открывающим апострофом.) Внутри таких строк символ обратной косой черты (<code class="literal">\</code>) начинает C-подобные <em class="firstterm">спецпоследовательности</em>, в которых сочетание обратной косой черты со следующим символом(ами) даёт определённое байтовое значение, как показано в <a class="xref" href="sql-syntax-lexical.html#SQL-BACKSLASH-TABLE" title="Таблица 4.1. Спецпоследовательности">Таблице 4.1</a>.</p><div class="table" id="SQL-BACKSLASH-TABLE"><p class="title"><strong>Таблица 4.1. Спецпоследовательности</strong></p><div class="table-contents"><table class="table" summary="Спецпоследовательности" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Спецпоследовательность</th><th>Интерпретация</th></tr></thead><tbody><tr><td><code class="literal">\b</code></td><td>символ «забой»</td></tr><tr><td><code class="literal">\f</code></td><td>подача формы</td></tr><tr><td><code class="literal">\n</code></td><td>новая строка</td></tr><tr><td><code class="literal">\r</code></td><td>возврат каретки</td></tr><tr><td><code class="literal">\t</code></td><td>табуляция</td></tr><tr><td><code class="literal">\<em class="replaceable"><code>o</code></em></code>, <code class="literal">\<em class="replaceable"><code>oo</code></em></code>, <code class="literal">\<em class="replaceable"><code>ooo</code></em></code> (<em class="replaceable"><code>o</code></em> = 0–7)</td><td>восьмеричное значение байта</td></tr><tr><td><code class="literal">\x<em class="replaceable"><code>h</code></em></code>, <code class="literal">\x<em class="replaceable"><code>hh</code></em></code> (<em class="replaceable"><code>h</code></em> = 0–9, A–F)</td><td>шестнадцатеричное значение байта</td></tr><tr><td><code class="literal">\u<em class="replaceable"><code>xxxx</code></em></code>, <code class="literal">\U<em class="replaceable"><code>xxxxxxxx</code></em></code> (<em class="replaceable"><code>x</code></em> = 0–9, A–F)</td><td>16- или 32-битный шестнадцатеричный код символа Unicode</td></tr></tbody></table></div></div><br class="table-break" /><p>Любой другой символ, идущий после обратной косой черты, воспринимается буквально. Таким образом, чтобы включить в строку обратную косую черту, нужно написать две косых черты (<code class="literal">\\</code>). Так же можно включить в строку апостроф, написав <code class="literal">\'</code>, в дополнение к обычному способу <code class="literal">''</code>.</p><p>Вы должны позаботиться, чтобы байтовые последовательности, которые вы создаёте таким образом, особенно в восьмеричной и шестнадцатеричной записи, образовывали допустимые символы в серверной кодировке. Также может быть полезно использовать спецпоследовательности Unicode или альтернативную запись, описанную в <a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-STRINGS-UESCAPE" title="4.1.2.3. Строковые константы со спецпоследовательностями Unicode">Подразделе 4.1.2.3</a>; в этом случае сервер будет проверять, возможно ли преобразовать указанный символ.</p><div class="caution"><h3 class="title">Внимание</h3><p>Если параметр конфигурации <a class="xref" href="runtime-config-compatible.html#GUC-STANDARD-CONFORMING-STRINGS">standard_conforming_strings</a> имеет значение <code class="literal">off</code>, <span class="productname">PostgreSQL</span> распознаёт обратную косую черту как спецсимвол и в обычных строках, и в строках со спецпоследовательностями. Однако в версии <span class="productname">PostgreSQL</span> 9.1 по умолчанию принято значение <code class="literal">on</code>, и в этом случае обратная косая черта распознаётся только в спецстроках. Это поведение больше соответствует стандарту, хотя может нарушить работу приложений, рассчитанных на предыдущий режим, когда обратная косая черта распознавалась везде. В качестве временного решения вы можете изменить этот параметр на <code class="literal">off</code>, но лучше уйти от такой практики. Если вам нужно, чтобы обратная косая черта представляла специальный символ, задайте строковую константу с <code class="literal">E</code>.</p><p>В дополнение к <code class="varname">standard_conforming_strings</code> поведением обратной косой черты в строковых константах управляют параметры <a class="xref" href="runtime-config-compatible.html#GUC-ESCAPE-STRING-WARNING">escape_string_warning</a> и <a class="xref" href="runtime-config-compatible.html#GUC-BACKSLASH-QUOTE">backslash_quote</a>.</p></div><p>Строковая константа не может включать символ с кодом 0.</p></div><div class="sect3" id="SQL-SYNTAX-STRINGS-UESCAPE"><div class="titlepage"><div><div><h4 class="title">4.1.2.3. Строковые константы со спецпоследовательностями Unicode <a href="#SQL-SYNTAX-STRINGS-UESCAPE" class="id_link">#</a></h4></div></div></div><a id="id-1.5.3.5.9.6.2" class="indexterm"></a><p><span class="productname">PostgreSQL</span> также поддерживает ещё один вариант спецпоследовательностей, позволяющий включать в строки символы Unicode по их кодам. Строковая константа со спецпоследовательностями Unicode начинается с <code class="literal">U&amp;</code> (строчная или заглавная U и амперсанд), а затем сразу без пробелов идёт апостроф, например <code class="literal">U&amp;'foo'</code>. (Заметьте, что при этом возникает неоднозначность с оператором <code class="literal">&amp;</code>. Чтобы её избежать, окружайте этот оператор пробелами.) Затем в апострофах можно записывать символы Unicode двумя способами: обратная косая черта, а за ней код символа из четырёх шестнадцатеричных цифр, либо обратная косая черта, знак плюс, а затем код из шести шестнадцатеричных цифр. Например, строку <code class="literal">'data'</code> можно записать так:</p><pre class="programlisting">U&amp;'d\0061t\+000061'</pre><p> В следующем менее тривиальном примере закодировано русское слово <span class="quote">«<span class="quote">слон</span>»</span>, записанное кириллицей: </p><pre class="programlisting">U&amp;'\0441\043B\043E\043D'</pre><p>Если вы хотите использовать не обратную косую черту, а другой спецсимвол, его можно указать, добавив <code class="literal">UESCAPE</code><a id="id-1.5.3.5.9.6.4.2" class="indexterm"></a> после строки, например: </p><pre class="programlisting">U&amp;'d!0061t!+000061' UESCAPE '!'</pre><p> В качестве спецсимвола можно выбрать любой символ, кроме шестнадцатеричной цифры, знака плюс, апострофа, кавычки или пробельного символа.</p><p>Чтобы включить спецсимвол в строку буквально, напишите его дважды.</p><p>Записывать суррогатные пары UTF-16 и таким образом составлять символы с кодами больше чем U+FFFF можно либо в четырёх-, либо в шестизначной форме, хотя наличие шестизначной формы технически делает это ненужным. (Суррогатные пары не сохраняются непосредственно, а объединяются в один символ, который затем кодируется в UTF-8.)</p><p>Когда кодировка сервера — не UTF-8, символ с кодом, указанным этой спецпоследовательностью, преобразуется в фактическую кодировку сервера; если такое преобразование невозможно, выдаётся ошибка.</p><p>Также заметьте, что спецпоследовательности Unicode в строковых константах работают, только когда параметр конфигурации <a class="xref" href="runtime-config-compatible.html#GUC-STANDARD-CONFORMING-STRINGS">standard_conforming_strings</a> равен <code class="literal">on</code>. Это объясняется тем, что иначе клиентские программы, проверяющие SQL-операторы, можно будет ввести в заблуждение и эксплуатировать это как уязвимость, например, для SQL-инъекций. Если этот параметр имеет значение <code class="literal">off</code>, эти спецпоследовательности будут вызывать ошибку.</p></div><div class="sect3" id="SQL-SYNTAX-DOLLAR-QUOTING"><div class="titlepage"><div><div><h4 class="title">4.1.2.4. Строковые константы, заключённые в доллары <a href="#SQL-SYNTAX-DOLLAR-QUOTING" class="id_link">#</a></h4></div></div></div><a id="id-1.5.3.5.9.7.2" class="indexterm"></a><p>Хотя стандартный синтаксис для строковых констант обычно достаточно удобен, он может плохо читаться, когда строка содержит много апострофов, так как каждый такой символ приходится дублировать. Чтобы и в таких случаях запросы оставались читаемыми, <span class="productname">PostgreSQL</span> предлагает ещё один способ записи строковых констант — <span class="quote">«<span class="quote">заключение строк в доллары</span>»</span>. Строковая константа, заключённая в доллары, начинается со знака доллара (<code class="literal">$</code>), необязательного <span class="quote">«<span class="quote">тега</span>»</span> из нескольких символов и ещё одного знака доллара, затем содержит обычную последовательность символов, составляющую строку, и оканчивается знаком доллара, тем же тегом и замыкающим знаком доллара. Например, строку <span class="quote">«<span class="quote">Жанна д'Арк</span>»</span> можно записать в долларах двумя способами: </p><pre class="programlisting">$$Жанна д'Арк$$
$SomeTag$Жанна д'Арк$SomeTag$</pre><p> Заметьте, что внутри такой строки апострофы не нужно записывать особым образом. На самом деле, в строке, заключённой в доллары, все символы можно записывать в чистом виде: содержимое строки всегда записывается буквально. Ни обратная косая черта, ни даже знак доллара не являются спецсимволами, если только они не образуют последовательность, соответствующую открывающему тегу.</p><p>Строковые константы в долларах можно вкладывать друг в друга, выбирая на разных уровнях вложенности разные теги. Чаще всего это используется при написании определений функций. Например: </p><pre class="programlisting">$function$
BEGIN
    RETURN ($1 ~ $q$[\t\r\n\v\\]$q$);
END;
$function$</pre><p> Здесь последовательность <code class="literal">$q$[\t\r\n\v\\]$q$</code> представляет в долларах текстовую строку <code class="literal">[\t\r\n\v\\]</code>, которая будет обработана, когда <span class="productname">PostgreSQL</span> будет выполнять эту функцию. Но так как эта последовательность не соответствует внешнему тегу в долларах (<code class="literal">$function$</code>), с точки зрения внешней строки это просто обычные символы внутри константы.</p><p>Тег строки в долларах, если он присутствует, должен соответствовать правилам, определённым для идентификаторов без кавычек, и к тому же не должен содержать знак доллара. Теги регистрозависимы, так что <code class="literal">$tag$String content$tag$</code> — правильная строка, а <code class="literal">$TAG$String content$tag$</code> — нет.</p><p>Строка в долларах, следующая за ключевым словом или идентификатором, должна отделяться от него пробельными символами, иначе доллар будет считаться продолжением предыдущего идентификатора.</p><p>Заключение строк в доллары не является частью стандарта SQL, но часто это более удобный способ записывать сложные строки, чем стандартный вариант с апострофами. Он особенно полезен, когда нужно представить строковую константу внутри другой строки, что часто требуется в определениях процедурных функций. Ограничившись только апострофами, каждую обратную косую черту в приведённом примере пришлось бы записывать четырьмя такими символами, которые бы затем уменьшились до двух при разборе внешней строки, и наконец до одного при обработке внутренней строки во время выполнения функции.</p></div><div class="sect3" id="SQL-SYNTAX-BIT-STRINGS"><div class="titlepage"><div><div><h4 class="title">4.1.2.5. Битовые строковые константы <a href="#SQL-SYNTAX-BIT-STRINGS" class="id_link">#</a></h4></div></div></div><a id="id-1.5.3.5.9.8.2" class="indexterm"></a><p>Битовые строковые константы похожи на обычные с дополнительной буквой <code class="literal">B</code> (заглавной или строчной), добавленной непосредственно перед открывающим апострофом (без промежуточных пробелов), например: <code class="literal">B'1001'</code>. В битовых строковых константах допускаются лишь символы <code class="literal">0</code> и <code class="literal">1</code>.</p><p>Битовые константы могут быть записаны и по-другому, в шестнадцатеричном виде, с начальной буквой <code class="literal">X</code> (заглавной или строчной), например: <code class="literal">X'1FF'</code>. Такая запись эквивалентна двоичной, только четыре двоичных цифры заменяются одной шестнадцатеричной.</p><p>Обе формы записи допускают перенос строк так же, как и обычные строковые константы. Однако заключать в доллары битовые строки нельзя.</p></div><div class="sect3" id="SQL-SYNTAX-CONSTANTS-NUMERIC"><div class="titlepage"><div><div><h4 class="title">4.1.2.6. Числовые константы <a href="#SQL-SYNTAX-CONSTANTS-NUMERIC" class="id_link">#</a></h4></div></div></div><a id="id-1.5.3.5.9.9.2" class="indexterm"></a><p>Числовые константы могут быть заданы в следующем общем виде: </p><pre class="synopsis">
<em class="replaceable"><code>цифры</code></em>
<em class="replaceable"><code>цифры</code></em>.[<span class="optional"><em class="replaceable"><code>цифры</code></em></span>][<span class="optional">e[<span class="optional">+-</span>]<em class="replaceable"><code>цифры</code></em></span>]
[<span class="optional"><em class="replaceable"><code>цифры</code></em></span>].<em class="replaceable"><code>цифры</code></em>[<span class="optional">e[<span class="optional">+-</span>]<em class="replaceable"><code>цифры</code></em></span>]
<em class="replaceable"><code>цифры</code></em>e[<span class="optional">+-</span>]<em class="replaceable"><code>цифры</code></em>
</pre><p> где <em class="replaceable"><code>цифры</code></em> — это одна или несколько десятичных цифр (0..9). До или после десятичной точки (при её наличии) должна быть минимум одна цифра. Как минимум одна цифра должна следовать за обозначением экспоненты (<code class="literal">e</code>), если оно присутствует. В числовой константе не может быть пробелов или других символов, за исключением символов подчёркивания, которые могут использоваться для визуальной группировки, как описано ниже. Обратите внимание на то, что любой знак минус или плюс в начале строки не считается частью числа — это оператор, применённый к константе.</p><p>Несколько примеров допустимых числовых констант: </p><div class="literallayout"><p><br />
42<br />
3.5<br />
4.<br />
.001<br />
5e2<br />
1.925e-3<br />
</p></div><p>Кроме того, недесятичные целочисленные константы принимаются в следующих формах: </p><pre class="synopsis">
0x<em class="replaceable"><code>hexdigits</code></em>
0o<em class="replaceable"><code>octdigits</code></em>
0b<em class="replaceable"><code>bindigits</code></em>
</pre><p> где <em class="replaceable"><code>hexdigits</code></em> — одна или более шестнадцатеричных цифр (0-9, A-F), <em class="replaceable"><code>octdigits</code></em> — одна или более восьмеричных цифр (0-7) и <em class="replaceable"><code>bindigits</code></em> — одна или более двоичных цифр (0 или 1). Шестнадцатеричные цифры и префиксы могут указываться в верхнем или нижнем регистре. Обратите внимание на то, что недесятичные формы могут принимать не числа с дробной частью, а только целые числа.</p><p>Несколько примеров допустимых недесятичных целочисленных констант: </p><div class="literallayout"><p><br />
0b100101<br />
0B10011001<br />
0o273<br />
0O755<br />
0x42f<br />
0XFFFF<br />
</p></div><p>Для визуальной группировки между цифрами можно вставлять символы подчёркивания. Они не влияют на значение константы. Например: </p><div class="literallayout"><p><br />
1_500_000_000<br />
0b10001000_00000000<br />
0o_1_755<br />
0xFFFF_FFFF<br />
1.618_034<br />
</p></div><p> Запрещается указывать символы подчёркивания в начале или в конце числовой константы или группы цифр (то есть сразу перед или после десятичной точки или обозначения экспоненты), а также более одного символа подчёркивания подряд.</p><p><a id="id-1.5.3.5.9.9.8.1" class="indexterm"></a> <a id="id-1.5.3.5.9.9.8.2" class="indexterm"></a> <a id="id-1.5.3.5.9.9.8.3" class="indexterm"></a> Числовая константа, не содержащая точки и экспоненты, изначально рассматривается как константа типа <code class="type">integer</code>, если её значение умещается в 32-битный тип <code class="type">integer</code>; затем как константа типа <code class="type">bigint</code>, если её значение умещается в 64-битный <code class="type">bigint</code>; в противном случае она принимает тип <code class="type">numeric</code>. Константы, содержащие десятичные точки и/или экспоненты, всегда считаются константами типа <code class="type">numeric</code>.</p><p>Изначально назначенный тип данных числовой константы это только отправная точка для алгоритмов определения типа. В большинстве случаев константа будет автоматически приведена к наиболее подходящему типу для данного контекста. При необходимости вы можете принудительно интерпретировать числовое значение как значение определённого типа, приведя его тип к нужному.<a id="id-1.5.3.5.9.9.9.1" class="indexterm"></a> Например, вы можете сделать, чтобы числовое значение рассматривалось как имеющее тип <code class="type">real</code> (<code class="type">float4</code>), написав: </p><pre class="programlisting">REAL '1.23'  -- строковый стиль
1.23::REAL   -- стиль PostgreSQL (исторический)</pre><p> На самом деле это только частные случаи синтаксиса приведения типов, который будет рассматриваться далее.</p></div><div class="sect3" id="SQL-SYNTAX-CONSTANTS-GENERIC"><div class="titlepage"><div><div><h4 class="title">4.1.2.7. Константы других типов <a href="#SQL-SYNTAX-CONSTANTS-GENERIC" class="id_link">#</a></h4></div></div></div><a id="id-1.5.3.5.9.10.2" class="indexterm"></a><p>Константу <span class="emphasis"><em>обычного</em></span> типа можно ввести одним из следующих способов: </p><pre class="synopsis">
<em class="replaceable"><code>type</code></em> '<em class="replaceable"><code>string</code></em>'
'<em class="replaceable"><code>string</code></em>'::<em class="replaceable"><code>type</code></em>
CAST ( '<em class="replaceable"><code>string</code></em>' AS <em class="replaceable"><code>type</code></em> )
</pre><p> Текст строковой константы передаётся процедуре преобразования ввода для типа, обозначенного здесь <em class="replaceable"><code>type</code></em>. Результатом становится константа указанного типа. Явное приведение типа можно опустить, если нужный тип константы определяется однозначно (например, когда она присваивается непосредственно столбцу таблицы), так как в этом случае приведение происходит автоматически.</p><p>Строковую константу можно записать, используя как обычный синтаксис SQL, так и формат с долларами.</p><p>Также можно записать приведение типов, используя синтаксис функций: </p><pre class="synopsis">
<em class="replaceable"><code>typename</code></em> ( '<em class="replaceable"><code>string</code></em>' )
</pre><p>но это работает не для всех имён типов; подробнее об этом написано в <a class="xref" href="sql-expressions.html#SQL-SYNTAX-TYPE-CASTS" title="4.2.9. Приведения типов">Подразделе 4.2.9</a>.</p><p>Конструкцию <code class="literal">::</code>, <code class="literal">CAST()</code> и синтаксис вызова функции можно также использовать для преобразования типов обычных выражений во время выполнения, как описано в <a class="xref" href="sql-expressions.html#SQL-SYNTAX-TYPE-CASTS" title="4.2.9. Приведения типов">Подразделе 4.2.9</a>. Во избежание синтаксической неопределённости, запись <code class="literal"><em class="replaceable"><code>тип</code></em> '<em class="replaceable"><code>строка</code></em>'</code> можно использовать только для указания типа простой текстовой константы. Ещё одно ограничение записи <code class="literal"><em class="replaceable"><code>тип</code></em> '<em class="replaceable"><code>строка</code></em>'</code>: она не работает для массивов; для таких констант следует использовать <code class="literal">::</code> или <code class="literal">CAST()</code>.</p><p>Синтаксис <code class="literal">CAST()</code> соответствует SQL, а запись <code class="literal"><em class="replaceable"><code>type</code></em> '<em class="replaceable"><code>string</code></em>'</code> является обобщением стандарта: в SQL такой синтаксис поддерживает только некоторые типы данных, но <span class="productname">PostgreSQL</span> позволяет использовать его для всех. Синтаксис с <code class="literal">::</code> имеет исторические корни в <span class="productname">PostgreSQL</span>, как и запись в виде вызова функции.</p></div></div><div class="sect2" id="SQL-SYNTAX-OPERATORS"><div class="titlepage"><div><div><h3 class="title">4.1.3. Операторы <a href="#SQL-SYNTAX-OPERATORS" class="id_link">#</a></h3></div></div></div><a id="id-1.5.3.5.10.2" class="indexterm"></a><p>Имя оператора образует последовательность не более чем <code class="symbol">NAMEDATALEN</code>-1 (по умолчанию 63) символов из следующего списка: </p><div class="literallayout"><p><br />
+ - * / &lt; &gt; = ~ ! @ # % ^ &amp; | ` ?<br />
</p></div><p> Однако для имён операторов есть ещё несколько ограничений: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Сочетания символов <code class="literal">--</code> и <code class="literal">/*</code> не могут присутствовать в имени оператора, так как они будут обозначать начало комментария.</p></li><li class="listitem"><p>Многосимвольное имя оператора не может заканчиваться знаком <code class="literal">+</code> или <code class="literal">-</code>, если только оно не содержит также один из этих символов: </p><div class="literallayout"><p><br />
~ ! @ # % ^ &amp; | ` ?<br />
</p></div><p> Например, <code class="literal">@-</code> — допустимое имя оператора, а <code class="literal">*-</code> — нет. Благодаря этому ограничению, <span class="productname">PostgreSQL</span> может разбирать корректные SQL-запросы без пробелов между компонентами.</p></li></ul></div><p>Записывая нестандартные SQL-операторы, обычно нужно отделять имена соседних операторов пробелами для однозначности. Например, если вы определили префиксный оператор с именем <code class="literal">@</code>, вы не можете написать <code class="literal">X*@Y</code>, а должны написать <code class="literal">X* @Y</code>, чтобы <span class="productname">PostgreSQL</span> однозначно прочитал это как два оператора, а не один.</p></div><div class="sect2" id="SQL-SYNTAX-SPECIAL-CHARS"><div class="titlepage"><div><div><h3 class="title">4.1.4. Специальные знаки <a href="#SQL-SYNTAX-SPECIAL-CHARS" class="id_link">#</a></h3></div></div></div><p>Некоторые не алфавитно-цифровые символы имеют специальное значение, но при этом не являются операторами. Подробнее их использование будет рассмотрено при описании соответствующего элемента синтаксиса. Здесь они упоминаются только для сведения и обобщения их предназначения. </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Знак доллара (<code class="literal">$</code>), предваряющий число, используется для представления позиционного параметра в теле определения функции или подготовленного оператора. В других контекстах знак доллара может быть частью идентификатора или строковой константы, заключённой в доллары.</p></li><li class="listitem"><p>Круглые скобки (<code class="literal">()</code>) имеют обычное значение и применяются для группировки выражений и повышения приоритета операций. В некоторых случаях скобки — это необходимая часть синтаксиса определённых SQL-команд.</p></li><li class="listitem"><p>Квадратные скобки (<code class="literal">[]</code>) применяются для выделения элементов массива. Подробнее массивы рассматриваются в <a class="xref" href="arrays.html" title="8.15. Массивы">Разделе 8.15</a>.</p></li><li class="listitem"><p>Запятые (<code class="literal">,</code>) используются в некоторых синтаксических конструкциях для разделения элементов списка.</p></li><li class="listitem"><p>Точка с запятой (<code class="literal">;</code>) завершает команду SQL. Она не может находиться нигде внутри команды, за исключением строковых констант или идентификаторов в кавычках.</p></li><li class="listitem"><p>Двоеточие (<code class="literal">:</code>) применяется для выборки <span class="quote">«<span class="quote">срезов</span>»</span> массивов (см. <a class="xref" href="arrays.html" title="8.15. Массивы">Раздел 8.15</a>.) В некоторых диалектах SQL (например, в Embedded SQL) двоеточие может быть префиксом в имени переменной.</p></li><li class="listitem"><p>Звёздочка (<code class="literal">*</code>) используется в некоторых контекстах как обозначение всех полей строки или составного значения. Она также имеет специальное значение, когда используется как аргумент некоторых агрегатных функций, а именно функций, которым не нужны явные параметры.</p></li><li class="listitem"><p>Точка (<code class="literal">.</code>) используется в числовых константах, а также для отделения имён схемы, таблицы и столбца.</p></li></ul></div></div><div class="sect2" id="SQL-SYNTAX-COMMENTS"><div class="titlepage"><div><div><h3 class="title">4.1.5. Комментарии <a href="#SQL-SYNTAX-COMMENTS" class="id_link">#</a></h3></div></div></div><a id="id-1.5.3.5.12.2" class="indexterm"></a><p>Комментарий — это последовательность символов, которая начинается с двух минусов и продолжается до конца строки, например: </p><pre class="programlisting">-- Это стандартный комментарий SQL</pre><p>Кроме этого, блочные комментарии можно записывать в стиле C: </p><pre class="programlisting">/* многострочный комментарий
 * с вложенностью: /* вложенный блок комментария */
 */</pre><p> где комментарий начинается с <code class="literal">/*</code> и продолжается до соответствующего вхождения <code class="literal">*/</code>. Блочные комментарии можно вкладывать друг в друга, как разрешено по стандарту SQL (но не разрешено в C), так что вы можете комментировать большие блоки кода, которые при этом уже могут содержать блоки комментариев.</p><p>Комментарий удаляется из входного потока в начале синтаксического анализа и фактически заменяется пробелом.</p></div><div class="sect2" id="SQL-PRECEDENCE"><div class="titlepage"><div><div><h3 class="title">4.1.6. Приоритеты операторов <a href="#SQL-PRECEDENCE" class="id_link">#</a></h3></div></div></div><a id="id-1.5.3.5.13.2" class="indexterm"></a><p>В <a class="xref" href="sql-syntax-lexical.html#SQL-PRECEDENCE-TABLE" title="Таблица 4.2. Приоритет операторов (от большего к меньшему)">Таблице 4.2</a> показаны приоритеты и очерёдность операторов, действующие в <span class="productname">PostgreSQL</span>. Большинство операторов имеют одинаковый приоритет и вычисляются слева направо. Приоритет и очерёдность операторов жёстко фиксированы в синтаксическом анализаторе. Если вы хотите, чтобы выражение с несколькими операторами разбиралось не в том порядке, который диктуют эти приоритеты, добавьте скобки.</p><div class="table" id="SQL-PRECEDENCE-TABLE"><p class="title"><strong>Таблица 4.2. Приоритет операторов (от большего к меньшему)</strong></p><div class="table-contents"><table class="table" summary="Приоритет операторов (от большего к меньшему)" border="1"><colgroup><col class="col1" /><col class="col2" /><col class="col3" /></colgroup><thead><tr><th>Оператор/элемент</th><th>Очерёдность</th><th>Описание</th></tr></thead><tbody><tr><td><code class="token">.</code></td><td>слева-направо</td><td>разделитель имён таблицы и столбца</td></tr><tr><td><code class="token">::</code></td><td>слева-направо</td><td>приведение типов в стиле <span class="productname">PostgreSQL</span></td></tr><tr><td><code class="token">[</code> <code class="token">]</code></td><td>слева-направо</td><td>выбор элемента массива</td></tr><tr><td><code class="token">+</code> <code class="token">-</code></td><td>справа-налево</td><td>унарный плюс, унарный минус</td></tr><tr><td><code class="token">COLLATE</code></td><td>слева-направо</td><td>выбор правила сортировки</td></tr><tr><td><code class="token">AT</code></td><td>слева-направо</td><td><code class="literal">AT TIME ZONE</code></td></tr><tr><td><code class="token">^</code></td><td>слева-направо</td><td>возведение в степень</td></tr><tr><td><code class="token">*</code> <code class="token">/</code> <code class="token">%</code></td><td>слева-направо</td><td>умножение, деление, остаток от деления</td></tr><tr><td><code class="token">+</code> <code class="token">-</code></td><td>слева-направо</td><td>сложение, вычитание</td></tr><tr><td>(любой другой оператор)</td><td>слева-направо</td><td>все другие встроенные и пользовательские операторы</td></tr><tr><td><code class="token">BETWEEN</code> <code class="token">IN</code> <code class="token">LIKE</code> <code class="token">ILIKE</code> <code class="token">SIMILAR</code></td><td> </td><td>проверка диапазона, проверка членства, сравнение строк</td></tr><tr><td><code class="token">&lt;</code> <code class="token">&gt;</code> <code class="token">=</code> <code class="token">&lt;=</code> <code class="token">&gt;=</code> <code class="token">&lt;&gt;</code>
</td><td> </td><td>операторы сравнения</td></tr><tr><td><code class="token">IS</code> <code class="token">ISNULL</code> <code class="token">NOTNULL</code></td><td> </td><td><code class="literal">IS TRUE</code>, <code class="literal">IS FALSE</code>, <code class="literal">IS NULL</code>, <code class="literal">IS DISTINCT FROM</code> и т. д.</td></tr><tr><td><code class="token">NOT</code></td><td>справа-налево</td><td>логическое отрицание</td></tr><tr><td><code class="token">AND</code></td><td>слева-направо</td><td>логическая конъюнкция</td></tr><tr><td><code class="token">OR</code></td><td>слева-направо</td><td>логическая дизъюнкция</td></tr></tbody></table></div></div><br class="table-break" /><p>Заметьте, что правила приоритета операторов также применяются к операторам, определённым пользователем с теми же именами, что и вышеперечисленные встроенные операторы. Например, если вы определите оператор <span class="quote">«<span class="quote">+</span>»</span> для некоторого нестандартного типа данных, он будет иметь тот же приоритет, что и встроенный оператор <span class="quote">«<span class="quote">+</span>»</span>, независимо от того, что он у вас делает.</p><p>Когда в конструкции <code class="literal">OPERATOR</code> используется имя оператора со схемой, например так: </p><pre class="programlisting">SELECT 3 OPERATOR(pg_catalog.+) 4;</pre><p> тогда <code class="literal">OPERATOR</code> имеет приоритет по умолчанию, соответствующий в <a class="xref" href="sql-syntax-lexical.html#SQL-PRECEDENCE-TABLE" title="Таблица 4.2. Приоритет операторов (от большего к меньшему)">Таблице 4.2</a> строке <span class="quote">«<span class="quote">любой другой оператор</span>»</span>. Это не зависит от того, какие именно операторы находятся в конструкции <code class="literal">OPERATOR()</code>.</p><div class="note"><h3 class="title">Примечание</h3><p>В <span class="productname">PostgreSQL</span> до версии 9.5 действовали немного другие правила приоритета операторов. В частности, операторы <code class="token">&lt;=</code>, <code class="token">&gt;=</code> и <code class="token">&lt;&gt;</code> обрабатывались по общему правилу; проверки <code class="literal">IS</code> имели более высокий приоритет; а <code class="literal">NOT BETWEEN</code> и связанные конструкции работали несогласованно — в некоторых случаях приоритетнее оказывался оператор <code class="literal">NOT</code>, а не <code class="literal">BETWEEN</code>. Эти правила были изменены для лучшего соответствия стандарту SQL и для уменьшения путаницы из-за несогласованной обработки логически равнозначных конструкций. В большинстве случаев эти изменения никак не проявятся, либо могут привести к ошибкам типа <span class="quote">«<span class="quote">нет такого оператора</span>»</span>, которые можно разрешить, добавив скобки. Однако возможны особые случаи, когда запрос будет разобран без ошибки, но его поведение может измениться.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-syntax.html" title="Глава 4. Синтаксис SQL">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-syntax.html" title="Глава 4. Синтаксис SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-expressions.html" title="4.2. Выражения значения">След.</a></td></tr><tr><td width="40%" align="left" valign="top">Глава 4. Синтаксис SQL </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 4.2. Выражения значения</td></tr></table></div></body></html>