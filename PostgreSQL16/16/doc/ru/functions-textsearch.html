<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>9.13. Функции и операторы текстового поиска</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="functions-net.html" title="9.12. Функции и операторы для работы с сетевыми адресами" /><link rel="next" href="functions-uuid.html" title="9.14. Функции генерирования UUID" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">9.13. Функции и операторы текстового поиска</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="functions-net.html" title="9.12. Функции и операторы для работы с сетевыми адресами">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="functions.html" title="Глава 9. Функции и операторы">Наверх</a></td><th width="60%" align="center">Глава 9. Функции и операторы</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="functions-uuid.html" title="9.14. Функции генерирования UUID">След.</a></td></tr></table><hr /></div><div class="sect1" id="FUNCTIONS-TEXTSEARCH"><div class="titlepage"><div><div><h2 class="title" style="clear: both">9.13. Функции и операторы текстового поиска <a href="#FUNCTIONS-TEXTSEARCH" class="id_link">#</a></h2></div></div></div><a id="id-1.5.8.19.2" class="indexterm"></a><a id="id-1.5.8.19.3" class="indexterm"></a><p>В <a class="xref" href="functions-textsearch.html#TEXTSEARCH-OPERATORS-TABLE" title="Таблица 9.42. Операторы текстового поиска">Таблице 9.42</a>, <a class="xref" href="functions-textsearch.html#TEXTSEARCH-FUNCTIONS-TABLE" title="Таблица 9.43. Функции текстового поиска">Таблице 9.43</a> и <a class="xref" href="functions-textsearch.html#TEXTSEARCH-FUNCTIONS-DEBUG-TABLE" title="Таблица 9.44. Функции отладки текстового поиска">Таблице 9.44</a> собраны все существующие функции и операторы, предназначенные для полнотекстового поиска. Во всех деталях возможности полнотекстового поиска в <span class="productname">PostgreSQL</span> описаны в <a class="xref" href="textsearch.html" title="Глава 12. Полнотекстовый поиск">Главе 12</a>.</p><div class="table" id="TEXTSEARCH-OPERATORS-TABLE"><p class="title"><strong>Таблица 9.42. Операторы текстового поиска</strong></p><div class="table-contents"><table class="table" summary="Операторы текстового поиска" border="1"><colgroup><col /></colgroup><thead><tr><th class="func_table_entry"><p class="func_signature">Оператор</p>
       <p>Описание</p>
       <p>Пример(ы)</p></th></tr></thead><tbody><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">tsvector</code> <code class="literal">@@</code> <code class="type">tsquery</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p class="func_signature">
        <code class="type">tsquery</code> <code class="literal">@@</code> <code class="type">tsvector</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>Аргумент <code class="type">tsvector</code> соответствует аргументу <code class="type">tsquery</code>? (Аргументы могут передаваться в любом порядке.)</p>
       <p>
        <code class="literal">to_tsvector('fat cats ate rats') @@ to_tsquery('cat &amp; rat')</code>
        → <code class="returnvalue">t</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">text</code> <code class="literal">@@</code> <code class="type">tsquery</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>Переданная текстовая строка, неявно преобразованная функцией <code class="function">to_tsvector()</code>, соответствует <code class="type">tsquery</code>?</p>
       <p>
        <code class="literal">'fat cats ate rats' @@ to_tsquery('cat &amp; rat')</code>
        → <code class="returnvalue">t</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">tsvector</code> <code class="literal">@@@</code> <code class="type">tsquery</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p class="func_signature">
        <code class="type">tsquery</code> <code class="literal">@@@</code> <code class="type">tsvector</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>Это устаревший синоним для <code class="literal">@@</code>.</p>
       <p>
        <code class="literal">to_tsvector('fat cats ate rats') @@@ to_tsquery('cat &amp; rat')</code>
        → <code class="returnvalue">t</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">tsvector</code> <code class="literal">||</code> <code class="type">tsvector</code>
        → <code class="returnvalue">tsvector</code>
       </p>
       <p>Соединяет два значения <code class="type">tsvector</code>. Если в обоих значениях содержатся позиции лексем, позиции во втором при совмещении корректируются.</p>
       <p>
        <code class="literal">'a:1 b:2'::tsvector || 'c:1 d:2 b:3'::tsvector</code>
        → <code class="returnvalue">'a':1 'b':2,5 'c':3 'd':4</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">tsquery</code> <code class="literal">&amp;&amp;</code> <code class="type">tsquery</code>
        → <code class="returnvalue">tsquery</code>
       </p>
       <p>Вычисляет конъюнкцию двух значений <code class="type">tsquery</code>, получая тем самым запрос, которому будут соответствовать документы, соответствующие обоим входным запросам.</p>
       <p>
        <code class="literal">'fat | rat'::tsquery &amp;&amp; 'cat'::tsquery</code>
        → <code class="returnvalue">( 'fat' | 'rat' ) &amp; 'cat'</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">tsquery</code> <code class="literal">||</code> <code class="type">tsquery</code>
        → <code class="returnvalue">tsquery</code>
       </p>
       <p>Вычисляет дизъюнкцию двух значений <code class="type">tsquery</code>, получая тем самым запрос, которому будут соответствовать документы, соответствующие любому из входных запросов.</p>
       <p>
        <code class="literal">'fat | rat'::tsquery || 'cat'::tsquery</code>
        → <code class="returnvalue">'fat' | 'rat' | 'cat'</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="literal">!!</code> <code class="type">tsquery</code>
        → <code class="returnvalue">tsquery</code>
       </p>
       <p>Вычисляет отрицание <code class="type">tsquery</code>, получая тем самым запрос, которому будут соответствовать документы, не соответствующие входному запросу.</p>
       <p>
        <code class="literal">!! 'cat'::tsquery</code>
        → <code class="returnvalue">!'cat'</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">tsquery</code> <code class="literal">&lt;-&gt;</code> <code class="type">tsquery</code>
        → <code class="returnvalue">tsquery</code>
       </p>
       <p>Конструирует фразовый запрос, которому будут соответствовать документы, содержащие подряд идущие лексемы, удовлетворяющие двум входным запросам.</p>
       <p>
        <code class="literal">to_tsquery('fat') &lt;-&gt; to_tsquery('rat')</code>
        → <code class="returnvalue">'fat' &lt;-&gt; 'rat'</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">tsquery</code> <code class="literal">@&gt;</code> <code class="type">tsquery</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>Первый запрос типа <code class="type">tsquery</code> содержит второй? (При этом учитывается только факт нахождения всех лексем из одного запроса в другом; операторы их сочетания игнорируются.)</p>
       <p>
        <code class="literal">'cat'::tsquery @&gt; 'cat &amp; rat'::tsquery</code>
        → <code class="returnvalue">f</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">tsquery</code> <code class="literal">&lt;@</code> <code class="type">tsquery</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>Первый запрос типа <code class="type">tsquery</code> содержится во втором? (При этом учитывается только факт нахождения всех лексем из одного запроса в другом; операторы их сочетания игнорируются.)</p>
       <p>
        <code class="literal">'cat'::tsquery &lt;@ 'cat &amp; rat'::tsquery</code>
        → <code class="returnvalue">t</code>
       </p>
       <p>
        <code class="literal">'cat'::tsquery &lt;@ '!cat &amp; rat'::tsquery</code>
        → <code class="returnvalue">t</code>
       </p></td></tr></tbody></table></div></div><br class="table-break" /><p>Помимо этих специализированных операторов, для типов <code class="type">tsvector</code> и <code class="type">tsquery</code> имеются обычные операторы сравнения, показанные в <a class="xref" href="functions-comparison.html#FUNCTIONS-COMPARISON-OP-TABLE" title="Таблица 9.1. Операторы сравнения">Таблице 9.1</a>. Они не очень полезны для поиска, но позволяют, в частности, создавать индексы по столбцам этих типов.</p><div class="table" id="TEXTSEARCH-FUNCTIONS-TABLE"><p class="title"><strong>Таблица 9.43. Функции текстового поиска</strong></p><div class="table-contents"><table class="table" summary="Функции текстового поиска" border="1"><colgroup><col /></colgroup><thead><tr><th class="func_table_entry"><p class="func_signature">Функция</p>
       <p>Описание</p>
       <p>Пример(ы)</p></th></tr></thead><tbody><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.19.7.2.2.1.1.1.1" class="indexterm"></a> <code class="function">array_to_tsvector</code> ( <code class="type">text[]</code> ) → <code class="returnvalue">tsvector</code></p>
       <p>Преобразует массив текстовых строк в <code class="type">tsvector</code>. Переданные строки используются в виде лексем как есть, без дополнительной обработки. Элементы массива не должны быть пустыми строками или <code class="literal">NULL</code>.</p>
       <p>
        <code class="literal">array_to_tsvector('{fat,cat,rat}'::text[])</code>
        → <code class="returnvalue">'cat' 'fat' 'rat'</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.19.7.2.2.2.1.1.1" class="indexterm"></a> <code class="function">get_current_ts_config</code> ( ) → <code class="returnvalue">regconfig</code></p>
       <p>Возвращает OID текущей конфигурации текстового поиска по умолчанию (задаваемой параметром <a class="xref" href="runtime-config-client.html#GUC-DEFAULT-TEXT-SEARCH-CONFIG">default_text_search_config</a>).</p>
       <p>
        <code class="literal">get_current_ts_config()</code>
        → <code class="returnvalue">english</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.19.7.2.2.3.1.1.1" class="indexterm"></a> <code class="function">length</code> ( <code class="type">tsvector</code> ) → <code class="returnvalue">integer</code></p>
       <p>Возвращает число лексем в значении <code class="type">tsvector</code>.</p>
       <p>
        <code class="literal">length('fat:2,4 cat:3 rat:5A'::tsvector)</code>
        → <code class="returnvalue">3</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.19.7.2.2.4.1.1.1" class="indexterm"></a> <code class="function">numnode</code> ( <code class="type">tsquery</code> ) → <code class="returnvalue">integer</code></p>
       <p>Возвращает число лексем и операторов в запросе <code class="type">tsquery</code>.</p>
       <p>
        <code class="literal">numnode('(fat &amp; rat) | cat'::tsquery)</code>
        → <code class="returnvalue">5</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.19.7.2.2.5.1.1.1" class="indexterm"></a> <code class="function">plainto_tsquery</code> ( [<span class="optional"><em class="parameter"><code>config</code></em> <code class="type">regconfig</code>, </span>] <em class="parameter"><code>query</code></em> <code class="type">text</code> ) → <code class="returnvalue">tsquery</code></p>
       <p>Преобразует текст в <code class="type">tsquery</code>, выполняя нормализацию слов согласно конфигурации по умолчанию или указанной явно. Знаки пунктуации во входной строке при этом игнорируются (в данном случае она не определяет операторы запроса). Результирующему запросу будут соответствовать документы, содержащие все слова этого текста, кроме стоп-слов.</p>
       <p>
        <code class="literal">plainto_tsquery('english', 'The Fat Rats')</code>
        → <code class="returnvalue">'fat' &amp; 'rat'</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.19.7.2.2.6.1.1.1" class="indexterm"></a> <code class="function">phraseto_tsquery</code> ( [<span class="optional"><em class="parameter"><code>config</code></em> <code class="type">regconfig</code>, </span>] <em class="parameter"><code>query</code></em> <code class="type">text</code> ) → <code class="returnvalue">tsquery</code></p>
       <p>Преобразует текст в <code class="type">tsquery</code>, выполняя нормализацию слов согласно конфигурации по умолчанию или указанной явно. Знаки пунктуации во входной строке при этом игнорируются (в данном случае она не определяет операторы запроса). Результирующему запросу будут соответствовать фразы, содержащие последовательность слов этого текста, кроме стоп-слов.</p>
       <p>
        <code class="literal">phraseto_tsquery('english', 'The Fat Rats')</code>
        → <code class="returnvalue">'fat' &lt;-&gt; 'rat'</code>
       </p>
       <p>
        <code class="literal">phraseto_tsquery('english', 'The Cat and Rats')</code>
        → <code class="returnvalue">'cat' &lt;2&gt; 'rat'</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.19.7.2.2.7.1.1.1" class="indexterm"></a> <code class="function">websearch_to_tsquery</code> ( [<span class="optional"><em class="parameter"><code>config</code></em> <code class="type">regconfig</code>, </span>] <em class="parameter"><code>query</code></em> <code class="type">text</code> ) → <code class="returnvalue">tsquery</code></p>
       <p>Преобразует текст в <code class="type">tsquery</code>, выполняя нормализацию слов согласно конфигурации по умолчанию или указанной явно. Последовательности слов в кавычках преобразуются в проверки фраз. Слово <span class="quote">«<span class="quote">or</span>»</span> воспринимается как оператор OR (ИЛИ), а символ минуса преобразуется в оператор NOT (НЕ); другие знаки пунктуации игнорируются. Это примерно соответствует поведению ряда распространённых средств поиска в вебе.</p>
       <p>
        <code class="literal">websearch_to_tsquery('english', '"fat rat" or cat dog')</code>
        → <code class="returnvalue">'fat' &lt;-&gt; 'rat' | 'cat' &amp; 'dog'</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.19.7.2.2.8.1.1.1" class="indexterm"></a> <code class="function">querytree</code> ( <code class="type">tsquery</code> ) → <code class="returnvalue">text</code></p>
       <p>Формирует представление индексируемой части <code class="type">tsquery</code>. Если возвращается пустой результат или просто <code class="literal">T</code>, это означает, что запрос не индексируемый.</p>
       <p>
        <code class="literal">querytree('foo &amp; ! bar'::tsquery)</code>
        → <code class="returnvalue">'foo'</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.19.7.2.2.9.1.1.1" class="indexterm"></a> <code class="function">setweight</code> ( <em class="parameter"><code>vector</code></em> <code class="type">tsvector</code>, <em class="parameter"><code>weight</code></em> <code class="type">"char"</code> ) → <code class="returnvalue">tsvector</code></p>
       <p>Назначает вес, указанный в аргументе <em class="parameter"><code>weight</code></em>, каждому элементу аргумента <em class="parameter"><code>vector</code></em>.</p>
       <p>
        <code class="literal">setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A')</code>
        → <code class="returnvalue">'cat':3A 'fat':2A,4A 'rat':5A</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.19.7.2.2.10.1.1.1" class="indexterm"></a> <code class="function">setweight</code> ( <em class="parameter"><code>vector</code></em> <code class="type">tsvector</code>, <em class="parameter"><code>weight</code></em> <code class="type">"char"</code>, <em class="parameter"><code>lexemes</code></em> <code class="type">text[]</code> ) → <code class="returnvalue">tsvector</code></p>
       <p>Назначает вес, указанный в аргументе <em class="parameter"><code>weight</code></em>, элементам аргумента <em class="parameter"><code>vector</code></em>, перечисленным в аргументе <em class="parameter"><code>lexemes</code></em>. Строки в <em class="parameter"><code>lexemes</code></em> принимаются в виде лексем как есть, без дальнейшей обработки. Строки, не соответствующие ни одной лексеме в <em class="parameter"><code>vector</code></em>, игнорируются.</p>
       <p>
        <code class="literal">setweight('fat:2,4 cat:3 rat:5,6B'::tsvector, 'A', '{cat,rat}')</code>
        → <code class="returnvalue">'cat':3A 'fat':2,4 'rat':5A,6A</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.19.7.2.2.11.1.1.1" class="indexterm"></a> <code class="function">strip</code> ( <code class="type">tsvector</code> ) → <code class="returnvalue">tsvector</code></p>
       <p>Убирает позиции и веса из значения <code class="type">tsvector</code>.</p>
       <p>
        <code class="literal">strip('fat:2,4 cat:3 rat:5A'::tsvector)</code>
        → <code class="returnvalue">'cat' 'fat' 'rat'</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.19.7.2.2.12.1.1.1" class="indexterm"></a> <code class="function">to_tsquery</code> ( [<span class="optional"><em class="parameter"><code>config</code></em> <code class="type">regconfig</code>, </span>] <em class="parameter"><code>query</code></em> <code class="type">text</code> ) → <code class="returnvalue">tsquery</code></p>
       <p>Преобразует текст в <code class="type">tsquery</code>, выполняя нормализацию слов согласно конфигурации по умолчанию или указанной явно. Слова должны разделяться операторами <code class="type">tsquery</code>.</p>
       <p>
        <code class="literal">to_tsquery('english', 'The &amp; Fat &amp; Rats')</code>
        → <code class="returnvalue">'fat' &amp; 'rat'</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.19.7.2.2.13.1.1.1" class="indexterm"></a> <code class="function">to_tsvector</code> ( [<span class="optional"><em class="parameter"><code>config</code></em> <code class="type">regconfig</code>, </span>] <em class="parameter"><code>document</code></em> <code class="type">text</code> ) → <code class="returnvalue">tsvector</code></p>
       <p>Преобразует текст в <code class="type">tsvector</code>, выполняя нормализацию слов согласно конфигурации по умолчанию или указанной явно. Результат будет включать информацию о позициях слов.</p>
       <p>
        <code class="literal">to_tsvector('english', 'The Fat Rats')</code>
        → <code class="returnvalue">'fat':2 'rat':3</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">to_tsvector</code> ( [<span class="optional"><em class="parameter"><code>config</code></em> <code class="type">regconfig</code>, </span>] <em class="parameter"><code>document</code></em> <code class="type">json</code> ) → <code class="returnvalue">tsvector</code></p>
       <p class="func_signature"><code class="function">to_tsvector</code> ( [<span class="optional"><em class="parameter"><code>config</code></em> <code class="type">regconfig</code>, </span>] <em class="parameter"><code>document</code></em> <code class="type">jsonb</code> ) → <code class="returnvalue">tsvector</code></p>
       <p>Преобразует каждое строковое значение в документе JSON в значение <code class="type">tsvector</code>, выполняя нормализацию слов согласно конфигурации по умолчанию или указанной явно. В результате выдаются полученные значения, соединённые вместе в порядке следования в документе. При вычислении выдаваемых позиций слов считается, что между каждой парой строковых значений находится одно стоп-слово. (Учтите, что в случае с <code class="type">jsonb</code> <span class="quote">«<span class="quote">порядок следования в документе</span>»</span> полей объекта JSON зависит от реализации; это наглядно показано в примере.)</p>
       <p>
        <code class="literal">to_tsvector('english', '{"aa": "The Fat Rats", "b": "dog"}'::json)</code>
        → <code class="returnvalue">'dog':5 'fat':2 'rat':3</code>
       </p>
       <p>
        <code class="literal">to_tsvector('english', '{"aa": "The Fat Rats", "b": "dog"}'::jsonb)</code>
        → <code class="returnvalue">'dog':1 'fat':4 'rat':5</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.19.7.2.2.15.1.1.1" class="indexterm"></a> <code class="function">json_to_tsvector</code> ( [<span class="optional"><em class="parameter"><code>config</code></em> <code class="type">regconfig</code>, </span>] <em class="parameter"><code>document</code></em> <code class="type">json</code>, <em class="parameter"><code>filter</code></em> <code class="type">jsonb</code> ) → <code class="returnvalue">tsvector</code></p>
       <p class="func_signature"><a id="id-1.5.8.19.7.2.2.15.1.2.1" class="indexterm"></a> <code class="function">jsonb_to_tsvector</code> ( [<span class="optional"><em class="parameter"><code>config</code></em> <code class="type">regconfig</code>, </span>] <em class="parameter"><code>document</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>filter</code></em> <code class="type">jsonb</code> ) → <code class="returnvalue">tsvector</code></p>
       <p>Выбирает из JSON-документа все элементы, соответствующие фильтру <em class="parameter"><code>filter</code></em>, и преобразует каждый в значение <code class="type">tsvector</code>, нормализуя их согласно конфигурации по умолчанию или указанной явно. В результате выдаются полученные значения, соединённые вместе в порядке следования в документе. При вычислении выдаваемых позиций слов считается, что между каждой парой строковых значений находится одно стоп-слово. (Учтите, что в случае с <code class="type">jsonb</code> <span class="quote">«<span class="quote">порядок следования в документе</span>»</span> полей объекта JSON зависит от реализации.) В параметре <em class="parameter"><code>filter</code></em> должен передаваться массив <code class="type">jsonb</code>, содержащий ноль или более следующих ключевых слов: <code class="literal">"string"</code> (включить все строковые значения), <code class="literal">"numeric"</code> (все числовые значения), <code class="literal">"boolean"</code> (все логические значения), <code class="literal">"key"</code> (все ключи) или <code class="literal">"all"</code> (включить всё вышеперечисленное). В качестве особого значения <em class="parameter"><code>filter</code></em> принимается простое JSON-значение, содержащее одно из этих ключевых слов.</p>
       <p>
        <code class="literal">json_to_tsvector('english', '{"a": "The Fat Rats", "b": 123}'::json, '["string", "numeric"]')</code>
        → <code class="returnvalue">'123':5 'fat':2 'rat':3</code>
       </p>
       <p>
        <code class="literal">json_to_tsvector('english', '{"cat": "The Fat Rats", "dog": 123}'::json, '"all"')</code>
        → <code class="returnvalue">'123':9 'cat':1 'dog':7 'fat':4 'rat':5</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.19.7.2.2.16.1.1.1" class="indexterm"></a> <code class="function">ts_delete</code> ( <em class="parameter"><code>vector</code></em> <code class="type">tsvector</code>, <em class="parameter"><code>lexeme</code></em> <code class="type">text</code> ) → <code class="returnvalue">tsvector</code></p>
       <p>Удаляет все вхождения лексемы, задаваемой аргументом <em class="parameter"><code>lexeme</code></em>, из значения <em class="parameter"><code>vector</code></em>. Строка <em class="parameter"><code>lexeme</code></em> принимается в виде лексемы как есть, без дальнейшей обработки.</p>
       <p>
        <code class="literal">ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, 'fat')</code>
        → <code class="returnvalue">'cat':3 'rat':5A</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">ts_delete</code> ( <em class="parameter"><code>vector</code></em> <code class="type">tsvector</code>, <em class="parameter"><code>lexemes</code></em> <code class="type">text[]</code> ) → <code class="returnvalue">tsvector</code></p>
       <p>Удаляет все вхождения лексем, переданных в параметре <em class="parameter"><code>lexemes</code></em>, из параметра <em class="parameter"><code>vector</code></em>. Строки в <em class="parameter"><code>lexemes</code></em> принимаются в виде лексем как есть, без дальнейшей обработки. Строки, которые не соответствуют никаким лексемам в <em class="parameter"><code>vector</code></em>, игнорируются.</p>
       <p>
        <code class="literal">ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, ARRAY['fat','rat'])</code>
        → <code class="returnvalue">'cat':3</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.19.7.2.2.18.1.1.1" class="indexterm"></a> <code class="function">ts_filter</code> ( <em class="parameter"><code>vector</code></em> <code class="type">tsvector</code>, <em class="parameter"><code>weights</code></em> <code class="type">"char"[]</code> ) → <code class="returnvalue">tsvector</code></p>
       <p>Выбирает из значения <em class="parameter"><code>vector</code></em> только элементы с весами, перечисленными в массиве <em class="parameter"><code>weights</code></em>.</p>
       <p>
        <code class="literal">ts_filter('fat:2,4 cat:3b,7c rat:5A'::tsvector, '{a,b}')</code>
        → <code class="returnvalue">'cat':3B 'rat':5A</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.19.7.2.2.19.1.1.1" class="indexterm"></a> <code class="function">ts_headline</code> ( [<span class="optional"><em class="parameter"><code>config</code></em> <code class="type">regconfig</code>, </span>] <em class="parameter"><code>document</code></em> <code class="type">text</code>, <em class="parameter"><code>query</code></em> <code class="type">tsquery</code> [<span class="optional">, <em class="parameter"><code>options</code></em> <code class="type">text</code></span>] ) → <code class="returnvalue">text</code></p>
       <p>Выводит в виде выдержек соответствующие поисковому запросу <em class="parameter"><code>query</code></em> фрагменты содержимого <em class="parameter"><code>document</code></em>, которое должно быть просто текстом, а не значением <code class="type">tsvector</code>. Слова в документе перед поиском нормализуются согласно конфигурации по умолчанию или указанной явно. Использование этой функции рассматривается в <a class="xref" href="textsearch-controls.html#TEXTSEARCH-HEADLINE" title="12.3.4. Выделение результатов">Подразделе 12.3.4</a>; также там описываются возможные значения <em class="parameter"><code>options</code></em>.</p>
       <p>
        <code class="literal">ts_headline('The fat cat ate the rat.', 'cat')</code>
        → <code class="returnvalue">The fat &lt;b&gt;cat&lt;/b&gt; ate the rat.</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">ts_headline</code> ( [<span class="optional"><em class="parameter"><code>config</code></em> <code class="type">regconfig</code>, </span>] <em class="parameter"><code>document</code></em> <code class="type">json</code>, <em class="parameter"><code>query</code></em> <code class="type">tsquery</code> [<span class="optional">, <em class="parameter"><code>options</code></em> <code class="type">text</code></span>] ) → <code class="returnvalue">text</code></p>
       <p class="func_signature"><code class="function">ts_headline</code> ( [<span class="optional"><em class="parameter"><code>config</code></em> <code class="type">regconfig</code>, </span>] <em class="parameter"><code>document</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>query</code></em> <code class="type">tsquery</code> [<span class="optional">, <em class="parameter"><code>options</code></em> <code class="type">text</code></span>] ) → <code class="returnvalue">text</code></p>
       <p>Выводит в виде выдержек соответствующие поисковому запросу <em class="parameter"><code>query</code></em> вхождения, найденные в строковых значениях внутри JSON-документа <em class="parameter"><code>document</code></em>. За подробностями обратитесь к <a class="xref" href="textsearch-controls.html#TEXTSEARCH-HEADLINE" title="12.3.4. Выделение результатов">Подразделу 12.3.4</a>.</p>
       <p>
        <code class="literal">ts_headline('{"cat":"raining cats and dogs"}'::jsonb, 'cat')</code>
        → <code class="returnvalue">{"cat": "raining &lt;b&gt;cats&lt;/b&gt; and dogs"}</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.19.7.2.2.21.1.1.1" class="indexterm"></a> <code class="function">ts_rank</code> ( [<span class="optional"><em class="parameter"><code>weights</code></em> <code class="type">real[]</code>, </span>] <em class="parameter"><code>vector</code></em> <code class="type">tsvector</code>, <em class="parameter"><code>query</code></em> <code class="type">tsquery</code> [<span class="optional">, <em class="parameter"><code>normalization</code></em> <code class="type">integer</code></span>] ) → <code class="returnvalue">real</code></p>
       <p>Вычисляет оценку, показывающую, в какой степени значение <em class="parameter"><code>vector</code></em> соответствует запросу <em class="parameter"><code>query</code></em>. За подробностями обратитесь к <a class="xref" href="textsearch-controls.html#TEXTSEARCH-RANKING" title="12.3.3. Ранжирование результатов поиска">Подразделу 12.3.3</a>.</p>
       <p>
        <code class="literal">ts_rank(to_tsvector('raining cats and dogs'), 'cat')</code>
        → <code class="returnvalue">0.06079271</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.19.7.2.2.22.1.1.1" class="indexterm"></a> <code class="function">ts_rank_cd</code> ( [<span class="optional"><em class="parameter"><code>weights</code></em> <code class="type">real[]</code>, </span>] <em class="parameter"><code>vector</code></em> <code class="type">tsvector</code>, <em class="parameter"><code>query</code></em> <code class="type">tsquery</code> [<span class="optional">, <em class="parameter"><code>normalization</code></em> <code class="type">integer</code></span>] ) → <code class="returnvalue">real</code></p>
       <p>Вычисляет по алгоритму расчёта плотности покрытия оценку, показывающую, в какой степени значение <em class="parameter"><code>vector</code></em> соответствует запросу <em class="parameter"><code>query</code></em> За подробностями обратитесь к <a class="xref" href="textsearch-controls.html#TEXTSEARCH-RANKING" title="12.3.3. Ранжирование результатов поиска">Подразделу 12.3.3</a>.</p>
       <p>
        <code class="literal">ts_rank_cd(to_tsvector('raining cats and dogs'), 'cat')</code>
        → <code class="returnvalue">0.1</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.19.7.2.2.23.1.1.1" class="indexterm"></a> <code class="function">ts_rewrite</code> ( <em class="parameter"><code>query</code></em> <code class="type">tsquery</code>, <em class="parameter"><code>target</code></em> <code class="type">tsquery</code>, <em class="parameter"><code>substitute</code></em> <code class="type">tsquery</code> ) → <code class="returnvalue">tsquery</code></p>
       <p>Заменяет в аргументе <em class="parameter"><code>query</code></em> вхождения <em class="parameter"><code>target</code></em> значением <em class="parameter"><code>substitute</code></em>. За подробностями обратитесь к <a class="xref" href="textsearch-features.html#TEXTSEARCH-QUERY-REWRITING" title="12.4.2.1. Перезапись запросов">Подразделу 12.4.2.1</a>.</p>
       <p>
        <code class="literal">ts_rewrite('a &amp; b'::tsquery, 'a'::tsquery, 'foo|bar'::tsquery)</code>
        → <code class="returnvalue">'b' &amp; ( 'foo' | 'bar' )</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">ts_rewrite</code> ( <em class="parameter"><code>query</code></em> <code class="type">tsquery</code>, <em class="parameter"><code>select</code></em> <code class="type">text</code> ) → <code class="returnvalue">tsquery</code></p>
       <p>Заменяет фрагменты запроса <em class="parameter"><code>query</code></em>, извлекая искомое вхождение и замену для него с помощью команды <code class="command">SELECT</code>. За подробностями обратитесь к <a class="xref" href="textsearch-features.html#TEXTSEARCH-QUERY-REWRITING" title="12.4.2.1. Перезапись запросов">Подразделу 12.4.2.1</a>.</p>
       <p>
        <code class="literal">SELECT ts_rewrite('a &amp; b'::tsquery, 'SELECT t,s FROM aliases')</code>
        → <code class="returnvalue">'b' &amp; ( 'foo' | 'bar' )</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.19.7.2.2.25.1.1.1" class="indexterm"></a> <code class="function">tsquery_phrase</code> ( <em class="parameter"><code>query1</code></em> <code class="type">tsquery</code>, <em class="parameter"><code>query2</code></em> <code class="type">tsquery</code> ) → <code class="returnvalue">tsquery</code></p>
       <p>Конструирует фразовый запрос, который будет находить подряд идущие лексемы, удовлетворяющие запросам <em class="parameter"><code>query1</code></em> и <em class="parameter"><code>query2</code></em> (как делает оператор <code class="literal">&lt;-&gt;</code>).</p>
       <p>
        <code class="literal">tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'))</code>
        → <code class="returnvalue">'fat' &lt;-&gt; 'cat'</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">tsquery_phrase</code> ( <em class="parameter"><code>query1</code></em> <code class="type">tsquery</code>, <em class="parameter"><code>query2</code></em> <code class="type">tsquery</code>, <em class="parameter"><code>distance</code></em> <code class="type">integer</code> ) → <code class="returnvalue">tsquery</code></p>
       <p>Конструирует фразовый запрос, который будет находить вхождения, удовлетворяющие запросам <em class="parameter"><code>query1</code></em> и <em class="parameter"><code>query2</code></em>, на расстоянии ровно в <em class="parameter"><code>distance</code></em> лексем друг от друга.</p>
       <p>
        <code class="literal">tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'), 10)</code>
        → <code class="returnvalue">'fat' &lt;10&gt; 'cat'</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.19.7.2.2.27.1.1.1" class="indexterm"></a> <code class="function">tsvector_to_array</code> ( <code class="type">tsvector</code> ) → <code class="returnvalue">text[]</code></p>
       <p>Преобразует <code class="type">tsvector</code> в массив лексем.</p>
       <p>
        <code class="literal">tsvector_to_array('fat:2,4 cat:3 rat:5A'::tsvector)</code>
        → <code class="returnvalue">{cat,fat,rat}</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.19.7.2.2.28.1.1.1" class="indexterm"></a> <code class="function">unnest</code> ( <code class="type">tsvector</code> ) → <code class="returnvalue">setof record</code> ( <em class="parameter"><code>lexeme</code></em> <code class="type">text</code>, <em class="parameter"><code>positions</code></em> <code class="type">smallint[]</code>, <em class="parameter"><code>weights</code></em> <code class="type">text</code> )</p>
       <p>Разворачивает <code class="type">tsvector</code> в набор строк, по одной лексеме в строке.</p>
       <p>
        <code class="literal">select * from unnest('cat:3 fat:2,4 rat:5A'::tsvector)</code>
        → <code class="returnvalue"></code>
</p><pre class="programlisting"> lexeme | positions | weights
--------+-----------+---------
 cat    | {3}       | {D}
 fat    | {2,4}     | {D,D}
 rat    | {5}       | {A}</pre><p>
       </p></td></tr></tbody></table></div></div><br class="table-break" /><div class="note"><h3 class="title">Примечание</h3><p>Все функции текстового поиска, принимающие необязательный аргумент <code class="type">regconfig</code>, будут использовать конфигурацию, указанную в параметре <a class="xref" href="runtime-config-client.html#GUC-DEFAULT-TEXT-SEARCH-CONFIG">default_text_search_config</a>, когда этот аргумент опущен.</p></div><p>Функции в <a class="xref" href="functions-textsearch.html#TEXTSEARCH-FUNCTIONS-DEBUG-TABLE" title="Таблица 9.44. Функции отладки текстового поиска">Таблице 9.44</a> перечислены отдельно, так как они не очень полезны в традиционных операциях поиска. Они предназначены в основном для разработки и отладки новых конфигураций текстового поиска.</p><div class="table" id="TEXTSEARCH-FUNCTIONS-DEBUG-TABLE"><p class="title"><strong>Таблица 9.44. Функции отладки текстового поиска</strong></p><div class="table-contents"><table class="table" summary="Функции отладки текстового поиска" border="1"><colgroup><col /></colgroup><thead><tr><th class="func_table_entry"><p class="func_signature">Функция</p>
       <p>Описание</p>
       <p>Пример(ы)</p></th></tr></thead><tbody><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.19.10.2.2.1.1.1.1" class="indexterm"></a> <code class="function">ts_debug</code> ( [<span class="optional"><em class="parameter"><code>config</code></em> <code class="type">regconfig</code>, </span>] <em class="parameter"><code>document</code></em> <code class="type">text</code> ) → <code class="returnvalue">setof record</code> ( <em class="parameter"><code>alias</code></em> <code class="type">text</code>, <em class="parameter"><code>description</code></em> <code class="type">text</code>, <em class="parameter"><code>token</code></em> <code class="type">text</code>, <em class="parameter"><code>dictionaries</code></em> <code class="type">regdictionary[]</code>, <em class="parameter"><code>dictionary</code></em> <code class="type">regdictionary</code>, <em class="parameter"><code>lexemes</code></em> <code class="type">text[]</code> )</p>
       <p>Извлекает из текста <em class="parameter"><code>document</code></em> фрагменты, нормализуя их согласно конфигурации текстового поиска по умолчанию или указанной явно, и выдаёт информацию о том, как был обработан каждый фрагмент. За подробностями обратитесь к <a class="xref" href="textsearch-debugging.html#TEXTSEARCH-CONFIGURATION-TESTING" title="12.8.1. Тестирование конфигурации">Подразделу 12.8.1</a>.</p>
       <p>
        <code class="literal">ts_debug('english', 'The Brightest supernovaes')</code>
        → <code class="returnvalue">(asciiword,"Word, all ASCII",The,{​english_stem​},​english_stem,{}) ...</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.19.10.2.2.2.1.1.1" class="indexterm"></a> <code class="function">ts_lexize</code> ( <em class="parameter"><code>dict</code></em> <code class="type">regdictionary</code>, <em class="parameter"><code>token</code></em> <code class="type">text</code> ) → <code class="returnvalue">text[]</code></p>
       <p>Возвращает массив заменяющих лексем, если слово, заданное аргументом <em class="parameter"><code>token</code></em>, есть в словаре, пустой массив, если это стоп-слово, которое есть в словаре, либо NULL, если такого слова нет. За подробностями обратитесь к <a class="xref" href="textsearch-debugging.html#TEXTSEARCH-DICTIONARY-TESTING" title="12.8.3. Тестирование словаря">Подразделу 12.8.3</a>.</p>
       <p>
        <code class="literal">ts_lexize('english_stem', 'stars')</code>
        → <code class="returnvalue">{star}</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.19.10.2.2.3.1.1.1" class="indexterm"></a> <code class="function">ts_parse</code> ( <em class="parameter"><code>parser_name</code></em> <code class="type">text</code>, <em class="parameter"><code>document</code></em> <code class="type">text</code> ) → <code class="returnvalue">setof record</code> ( <em class="parameter"><code>tokid</code></em> <code class="type">integer</code>, <em class="parameter"><code>token</code></em> <code class="type">text</code> )</p>
       <p>Извлекает фрагменты из текста <em class="parameter"><code>document</code></em>, применяя анализатор с указанным именем. За подробностями обратитесь к <a class="xref" href="textsearch-debugging.html#TEXTSEARCH-PARSER-TESTING" title="12.8.2. Тестирование анализатора">Подразделу 12.8.2</a>.</p>
       <p>
        <code class="literal">ts_parse('default', 'foo - bar')</code>
        → <code class="returnvalue">(1,foo) ...</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">ts_parse</code> ( <em class="parameter"><code>parser_oid</code></em> <code class="type">oid</code>, <em class="parameter"><code>document</code></em> <code class="type">text</code> ) → <code class="returnvalue">setof record</code> ( <em class="parameter"><code>tokid</code></em> <code class="type">integer</code>, <em class="parameter"><code>token</code></em> <code class="type">text</code> )</p>
       <p>Извлекает фрагменты из текста <em class="parameter"><code>document</code></em>, применяя анализатор с указанным OID. За подробностями обратитесь к <a class="xref" href="textsearch-debugging.html#TEXTSEARCH-PARSER-TESTING" title="12.8.2. Тестирование анализатора">Подразделу 12.8.2</a>.</p>
       <p>
        <code class="literal">ts_parse(3722, 'foo - bar')</code>
        → <code class="returnvalue">(1,foo) ...</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.19.10.2.2.5.1.1.1" class="indexterm"></a> <code class="function">ts_token_type</code> ( <em class="parameter"><code>parser_name</code></em> <code class="type">text</code> ) → <code class="returnvalue">setof record</code> ( <em class="parameter"><code>tokid</code></em> <code class="type">integer</code>, <em class="parameter"><code>alias</code></em> <code class="type">text</code>, <em class="parameter"><code>description</code></em> <code class="type">text</code> )</p>
       <p>Возвращает таблицу, описывающую все типы фрагментов, которые может распознать анализатор с указанным именем. За подробностями обратитесь к <a class="xref" href="textsearch-debugging.html#TEXTSEARCH-PARSER-TESTING" title="12.8.2. Тестирование анализатора">Подразделу 12.8.2</a>.</p>
       <p>
        <code class="literal">ts_token_type('default')</code>
        → <code class="returnvalue">(1,asciiword,"Word, all ASCII") ...</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">ts_token_type</code> ( <em class="parameter"><code>parser_oid</code></em> <code class="type">oid</code> ) → <code class="returnvalue">setof record</code> ( <em class="parameter"><code>tokid</code></em> <code class="type">integer</code>, <em class="parameter"><code>alias</code></em> <code class="type">text</code>, <em class="parameter"><code>description</code></em> <code class="type">text</code> )</p>
       <p>Возвращает таблицу, описывающую все типы фрагментов, которые может распознать анализатор с указанным OID. За подробностями обратитесь к <a class="xref" href="textsearch-debugging.html#TEXTSEARCH-PARSER-TESTING" title="12.8.2. Тестирование анализатора">Подразделу 12.8.2</a>.</p>
       <p>
        <code class="literal">ts_token_type(3722)</code>
        → <code class="returnvalue">(1,asciiword,"Word, all ASCII") ...</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.19.10.2.2.7.1.1.1" class="indexterm"></a> <code class="function">ts_stat</code> ( <em class="parameter"><code>sqlquery</code></em> <code class="type">text</code> [<span class="optional">, <em class="parameter"><code>weights</code></em> <code class="type">text</code></span>] ) → <code class="returnvalue">setof record</code> ( <em class="parameter"><code>word</code></em> <code class="type">text</code>, <em class="parameter"><code>ndoc</code></em> <code class="type">integer</code>, <em class="parameter"><code>nentry</code></em> <code class="type">integer</code> )</p>
       <p>Выполняет запрос <em class="parameter"><code>sqlquery</code></em>, который должен возвращать единственный столбец <code class="type">tsvector</code>, и выдаёт статистику по каждой отдельной лексеме, содержащейся в данных. За подробностями обратитесь к <a class="xref" href="textsearch-features.html#TEXTSEARCH-STATISTICS" title="12.4.4. Сбор статистики по документу">Подразделу 12.4.4</a>.</p>
       <p>
        <code class="literal">ts_stat('SELECT vector FROM apod')</code>
        → <code class="returnvalue">(foo,10,15) ...</code>
       </p></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="functions-net.html" title="9.12. Функции и операторы для работы с сетевыми адресами">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="functions.html" title="Глава 9. Функции и операторы">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="functions-uuid.html" title="9.14. Функции генерирования UUID">След.</a></td></tr><tr><td width="40%" align="left" valign="top">9.12. Функции и операторы для работы с сетевыми адресами </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 9.14. Функции генерирования UUID</td></tr></table></div></body></html>