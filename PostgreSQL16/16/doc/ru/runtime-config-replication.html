<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>20.6. Репликация</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="runtime-config-wal.html" title="20.5. Журнал предзаписи" /><link rel="next" href="runtime-config-query.html" title="20.7. Планирование запросов" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">20.6. Репликация</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="runtime-config-wal.html" title="20.5. Журнал предзаписи">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="runtime-config.html" title="Глава 20. Настройка сервера">Наверх</a></td><th width="60%" align="center">Глава 20. Настройка сервера</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="runtime-config-query.html" title="20.7. Планирование запросов">След.</a></td></tr></table><hr /></div><div class="sect1" id="RUNTIME-CONFIG-REPLICATION"><div class="titlepage"><div><div><h2 class="title" style="clear: both">20.6. Репликация <a href="#RUNTIME-CONFIG-REPLICATION" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="runtime-config-replication.html#RUNTIME-CONFIG-REPLICATION-SENDER">20.6.1. Передающие серверы</a></span></dt><dt><span class="sect2"><a href="runtime-config-replication.html#RUNTIME-CONFIG-REPLICATION-PRIMARY">20.6.2. Главный сервер</a></span></dt><dt><span class="sect2"><a href="runtime-config-replication.html#RUNTIME-CONFIG-REPLICATION-STANDBY">20.6.3. Ведомые серверы</a></span></dt><dt><span class="sect2"><a href="runtime-config-replication.html#RUNTIME-CONFIG-REPLICATION-SUBSCRIBER">20.6.4. Подписчики</a></span></dt></dl></div><p>Эти параметры управляют поведением встроенных механизмов <em class="firstterm">потоковой репликации</em> (см. <a class="xref" href="warm-standby.html#STREAMING-REPLICATION" title="27.2.5. Потоковая репликация">Подраздел 27.2.5</a>) и <em class="firstterm">логической репликации</em> (см. <a class="xref" href="logical-replication.html" title="Глава 31. Логическая репликация">Главу 31</a>).</p><p>В <em class="firstterm">потоковой репликации</em> один сервер является ведущим, а другие — ведомыми. Ведущий сервер всегда передаёт, а ведомые всегда принимают данные репликации, но когда настроена каскадная репликация (см. <a class="xref" href="warm-standby.html#CASCADING-REPLICATION" title="27.2.7. Каскадная репликация">Подраздел 27.2.7</a>), ведомые серверы могут быть и передающими. Следующие параметры в основном относятся к передающим и ведомым серверам, хотя некоторые параметры имеют смысл только для ведущего. Все эти параметры могут быть разными в рамках одного кластера, если это требуется.</p><p>Для <span class="emphasis"><em>логической репликации</em></span> <em class="firstterm">публикующие серверы</em> (серверы, выполняющие <a class="link" href="sql-createpublication.html" title="CREATE PUBLICATION"><code class="command">CREATE PUBLICATION</code></a>) передают данные репликации <em class="firstterm">подписчикам</em> (серверам, выполняющим <a class="link" href="sql-createsubscription.html" title="CREATE SUBSCRIPTION"><code class="command">CREATE SUBSCRIPTION</code></a>). Серверы также могут быть публикующими и подписчиками одновременно. Обратите внимание, что в следующих разделах публикующие серверы называются «передающими серверами» или «передатчиками». За дополнительной информацией о параметрах конфигурации логической репликации обратитесь к <a class="xref" href="logical-replication-config.html" title="31.10. Параметры конфигурации">Разделу 31.10</a>.</p><div class="sect2" id="RUNTIME-CONFIG-REPLICATION-SENDER"><div class="titlepage"><div><div><h3 class="title">20.6.1. Передающие серверы <a href="#RUNTIME-CONFIG-REPLICATION-SENDER" class="id_link">#</a></h3></div></div></div><p>Эти параметры можно задать на любом сервере, который передаёт данные репликации одному или нескольким ведомым. Ведущий сервер всегда является передающим, так что на нём они должны задаваться всегда. Роль и значение этих параметров не меняются после того, как ведомый сервер становится ведущим.</p><div class="variablelist"><dl class="variablelist"><dt id="GUC-MAX-WAL-SENDERS"><span class="term"><code class="varname">max_wal_senders</code> (<code class="type">integer</code>) <a id="id-1.6.7.9.5.3.1.1.3" class="indexterm"></a></span> <a href="#GUC-MAX-WAL-SENDERS" class="id_link">#</a></dt><dd><p>Задаёт максимально допустимое число одновременных подключений ведомых серверов или клиентов потокового копирования (т. е. максимальное количество одновременно работающих процессов передачи WAL). Значение по умолчанию — <code class="literal">10</code>. При значении <code class="literal">0</code> репликация отключается. В случае неожиданного отключения клиента потоковой передачи слот подключения может оставаться занятым до достижения тайм-аута, так что этот параметр должен быть немного больше максимально допустимого числа клиентов, чтобы отключившиеся клиенты могли переподключиться немедленно. Задать этот параметр можно только при запуске сервера. Чтобы к данному серверу могли подключаться ведомые, уровень <code class="varname">wal_level</code> должен быть <code class="literal">replica</code> или выше.</p><p>Для ведомого сервера значение этого параметра должно быть больше или равно значению на ведущем. В противном случае на ведомом сервере не будут разрешены запросы.</p></dd><dt id="GUC-MAX-REPLICATION-SLOTS"><span class="term"><code class="varname">max_replication_slots</code> (<code class="type">integer</code>) <a id="id-1.6.7.9.5.3.2.1.3" class="indexterm"></a></span> <a href="#GUC-MAX-REPLICATION-SLOTS" class="id_link">#</a></dt><dd><p>Задаёт максимальное число слотов репликации (см. <a class="xref" href="warm-standby.html#STREAMING-REPLICATION-SLOTS" title="27.2.6. Слоты репликации">Подраздел 27.2.6</a>), которое сможет поддерживать сервер. Значение по умолчанию — 10. Этот параметр можно задать только при запуске сервера. Если заданное значение данного параметра будет меньше, чем число уже существующих слотов репликации, сервер не запустится. Чтобы слоты репликации можно было использовать, нужно также установить в <code class="varname">wal_level</code> уровень <code class="literal">replica</code> или выше.</p><p>Обратите внимание, что этот параметр также применяется на стороне подписчика, но с другим значением.</p></dd><dt id="GUC-WAL-KEEP-SIZE"><span class="term"><code class="varname">wal_keep_size</code> (<code class="type">integer</code>) <a id="id-1.6.7.9.5.3.3.1.3" class="indexterm"></a></span> <a href="#GUC-WAL-KEEP-SIZE" class="id_link">#</a></dt><dd><p>Задаёт минимальный объём прошлых файлов WAL, который будет сохраняться в каталоге <code class="filename">pg_wal</code>, чтобы ведомый сервер мог выбрать их при потоковой репликации. Если ведомый сервер, подключённый к передающему, отстаёт больше чем на <code class="varname">wal_keep_size</code> мегабайт, передающий может удалить сегменты WAL, всё ещё необходимые ведомому, и в этом случае соединение репликации прервётся. В результате этого затем также будут прерваны зависимые соединения. (Однако ведомый сервер сможет восстановиться, выбрав этот сегмент из архива, если осуществляется архивация WAL.)</p><p>Этот параметр задаёт только минимальный объём сегментов, который будет сохраняться в каталоге <code class="filename">pg_wal</code>; для архивации WAL или для восстановления с момента контрольной точки может потребоваться сохранить больше сегментов. Если <code class="varname">wal_keep_size</code> равен нулю (это значение по умолчанию), система не сохраняет никакие дополнительные сегменты для ведомых серверов, поэтому число старых сегментов WAL, доступных для ведомых, зависит от положения предыдущей контрольной точки и состояния архивации WAL. Если это значение задаётся без единиц измерения, оно считается заданным в мегабайтах. Задать этот параметр можно только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера.</p></dd><dt id="GUC-MAX-SLOT-WAL-KEEP-SIZE"><span class="term"><code class="varname">max_slot_wal_keep_size</code> (<code class="type">integer</code>) <a id="id-1.6.7.9.5.3.4.1.3" class="indexterm"></a></span> <a href="#GUC-MAX-SLOT-WAL-KEEP-SIZE" class="id_link">#</a></dt><dd><p>Задаёт максимальный размер файлов WAL, который может оставаться в каталоге <code class="filename">pg_wal</code> для <a class="link" href="warm-standby.html#STREAMING-REPLICATION-SLOTS" title="27.2.6. Слоты репликации">слотов репликации</a> после выполнения контрольной точки. Со значением <code class="varname">max_slot_wal_keep_size</code>, равным -1 (по умолчанию), для слотов репликации может сохраняться неограниченный объём файлов WAL. При неотрицательном значении, если позиция restart_lsn для слота репликации отстаёт от текущего LSN более чем на заданное количество мегабайт, использующий этот слот ведомый сервер может лишиться возможности продолжить репликацию вследствие удаления нужных ему файлов WAL. Доступность WAL для слотов репликации показывается в представлении <a class="link" href="view-pg-replication-slots.html" title="54.19. pg_replication_slots">pg_replication_slots</a>. Если это значение указано без единиц измерения, оно считается заданным в мегабайтах. Данный параметр можно задать только в файле <code class="filename">postgresql.conf</code> или в командной строке сервера.</p></dd><dt id="GUC-WAL-SENDER-TIMEOUT"><span class="term"><code class="varname">wal_sender_timeout</code> (<code class="type">integer</code>) <a id="id-1.6.7.9.5.3.5.1.3" class="indexterm"></a></span> <a href="#GUC-WAL-SENDER-TIMEOUT" class="id_link">#</a></dt><dd><p>Задаёт период времени, по истечении которого прерываются неактивные соединения репликации. Это помогает передающему серверу обнаружить сбой ведомого или разрывы сети. Если это значение задаётся без единиц измерения, оно считается заданным в миллисекундах. Значение по умолчанию — 60 секунд. При значении, равном нулю, тайм-аут отключается.</p><p>Если узлы кластера распределены географически, его можно гибко настроить, используя разные значения в разных расположениях. Маленькие значения полезны для более быстрого обнаружения потери ведомого, подключённого по скоростному каналу, а большие — для более надёжного определения состояния ведомого, расположенного в удалённой сети, соединение с которой характеризуется большими задержками.</p></dd><dt id="GUC-TRACK-COMMIT-TIMESTAMP"><span class="term"><code class="varname">track_commit_timestamp</code> (<code class="type">boolean</code>) <a id="id-1.6.7.9.5.3.6.1.3" class="indexterm"></a></span> <a href="#GUC-TRACK-COMMIT-TIMESTAMP" class="id_link">#</a></dt><dd><p>Включает запись времени фиксации транзакций. Этот параметр можно задать только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера. По умолчанию этот параметр имеет значение <code class="literal">off</code>.</p></dd></dl></div></div><div class="sect2" id="RUNTIME-CONFIG-REPLICATION-PRIMARY"><div class="titlepage"><div><div><h3 class="title">20.6.2. Главный сервер <a href="#RUNTIME-CONFIG-REPLICATION-PRIMARY" class="id_link">#</a></h3></div></div></div><p>Эти параметры можно задать на главном/ведущем сервере, который должен передавать данные репликации одному или нескольким ведомым. Заметьте, что помимо этих параметров на ведущем сервере должен быть правильно установлен <a class="xref" href="runtime-config-wal.html#GUC-WAL-LEVEL">wal_level</a>, а также может быть включена архивация WAL (см. <a class="xref" href="runtime-config-wal.html#RUNTIME-CONFIG-WAL-ARCHIVING" title="20.5.3. Архивация">Подраздел 20.5.3</a>). Значения этих параметров на ведомых серверах не важны, хотя их можно подготовить заранее, на случай, если ведомый сервер придётся сделать ведущим.</p><div class="variablelist"><dl class="variablelist"><dt id="GUC-SYNCHRONOUS-STANDBY-NAMES"><span class="term"><code class="varname">synchronous_standby_names</code> (<code class="type">string</code>) <a id="id-1.6.7.9.6.3.1.1.3" class="indexterm"></a></span> <a href="#GUC-SYNCHRONOUS-STANDBY-NAMES" class="id_link">#</a></dt><dd><p>Определяет список ведомых серверов, которые могут поддерживать <em class="firstterm">синхронную репликацию</em>, как описано в <a class="xref" href="warm-standby.html#SYNCHRONOUS-REPLICATION" title="27.2.8. Синхронная репликация">Подразделе 27.2.8</a>. Активных синхронных ведомых серверов может быть один или несколько; транзакции, ожидающие фиксации, будут завершаться только после того, как эти ведомые подтвердят получение их данных. Синхронными ведомыми будут те, имена которых указаны в этом списке и которые подключены к ведущему и принимают поток данных в реальном времени (что показывает признак <code class="literal">streaming</code> в представлении <a class="link" href="monitoring-stats.html#MONITORING-PG-STAT-REPLICATION-VIEW" title="28.2.4. pg_stat_replication"><code class="structname">pg_stat_replication</code></a>). Указание нескольких имён ведомых серверов позволяет обеспечить очень высокую степень доступности и защиту от потери данных.</p><p>Именем ведомого сервера в этом контексте считается значение <code class="varname">application_name</code> ведомого сервера, задаваемое в свойствах подключения. При организации физической репликации оно должно задаваться в строке <code class="varname">primary_conninfo</code>; по умолчанию это значение параметра <a class="xref" href="runtime-config-logging.html#GUC-CLUSTER-NAME">cluster_name</a>, если он задан, или <code class="literal">walreceiver</code> в противном случае. Для логической репликации его можно задать в строке подключения для подписки (по умолчанию это имя подписки). Как задать его для других потребителей потоков репликации, вы можете узнать в их документации.</p><p>Этот параметр принимает список ведомых серверов в одной из следующих форм: </p><pre class="synopsis">
[FIRST] <em class="replaceable"><code>число_синхронных</code></em> ( <em class="replaceable"><code>имя_ведомого</code></em> [, ...] )
ANY <em class="replaceable"><code>число_синхронных</code></em> ( <em class="replaceable"><code>имя_ведомого</code></em> [, ...] )
<em class="replaceable"><code>имя_ведомого</code></em> [, ...]
</pre><p> здесь <em class="replaceable"><code>число_синхронных</code></em> — число синхронных ведомых серверов, от которых необходимо дожидаться ответов для завершения транзакций, а <em class="replaceable"><code>имя_ведомого</code></em> — имя ведомого сервера. Слова <code class="literal">FIRST</code> и <code class="literal">ANY</code> задают метод выбора синхронных ведомых из перечисленных серверов.</p><p>Ключевое слово <code class="literal">FIRST</code>, в сочетании с <em class="replaceable"><code>числом_синхронных</code></em>, выбирает синхронную репликацию на основе приоритетов, когда транзакции фиксируются только после того, как их записи в WAL реплицируются на <em class="replaceable"><code>число_синхронных</code></em> ведомых серверов, выбираемых согласно приоритетам. Например, со значением <code class="literal">FIRST 3 (s1, s2, s3, s4)</code> для фиксации транзакции необходимо дождаться ответа от трёх наиболее приоритетных из серверов <code class="literal">s1</code>, <code class="literal">s2</code>, <code class="literal">s3</code> и <code class="literal">s4</code>. Ведомые серверы, имена которых идут в этом списке первыми, будут иметь больший приоритет и будут считаться синхронными. Серверы, следующие в списке за ними, будут считаться потенциальными синхронными. Если один из текущих синхронных серверов по какой-то причине отключается, он немедленно будет заменён следующим сервером с наибольшим приоритетом. Ключевое слово <code class="literal">FIRST</code> может быть опущено.</p><p>Ключевое слово <code class="literal">ANY</code>, в сочетании с <em class="replaceable"><code>числом_синхронных</code></em>, выбирает синхронную репликацию на основе кворума, когда транзакции фиксируются только после того, как их записи в WAL реплицируются на <span class="emphasis"><em>как минимум</em></span> <em class="replaceable"><code>число_синхронных</code></em> перечисленных серверов. Например, со значением <code class="literal">ANY 3 (s1, s2, s3, s4)</code> для фиксации транзакции необходимо дождаться ответа от как минимум трёх из серверов <code class="literal">s1</code>, <code class="literal">s2</code>, <code class="literal">s3</code> и <code class="literal">s4</code>.</p><p>Ключевые слова <code class="literal">FIRST</code> и <code class="literal">ANY</code> воспринимаются без учёта регистра. Если такое же имя оказывается у одного из ведомых серверов, его <em class="replaceable"><code>имя_ведомого</code></em> нужно заключить в двойные кавычки.</p><p>Третья форма использовалась в <span class="productname">PostgreSQL</span> до версии 9.6 и по-прежнему поддерживается. По сути она равнозначна первой с <code class="literal">FIRST</code> и <em class="replaceable"><code>числом_синхронным</code></em>, равным 1. Например, <code class="literal">FIRST 1 (s1, s2)</code> и <code class="literal">s1, s2</code> действуют одинаково: в качестве синхронного ведомого выбирается либо <code class="literal">s1</code>, либо <code class="literal">s2</code>.</p><p>Специальному элементу <code class="literal">*</code> соответствует имя любого ведомого.</p><p>Уникальность имён ведомых серверов не контролируется. В случае дублирования имён более приоритетным будет один из серверов с подходящим именем, хотя какой именно, не определено.</p><div class="note"><h3 class="title">Примечание</h3><p>Каждое <em class="replaceable"><code>имя_ведомого</code></em> должно задаваться в виде допустимого идентификатора SQL, кроме <code class="literal">*</code>. При необходимости его можно заключать в кавычки. Но заметьте, что идентификаторы <em class="replaceable"><code>имя_ведомого</code></em> сравниваются с именами приложений без учёта регистра, независимо от того, заключены ли они в кавычки или нет.</p></div><p>Если имена синхронных ведомых серверов не определены, синхронная репликация не включается и фиксируемые транзакции не будут ждать репликации. Это поведение по умолчанию. Даже когда синхронная репликация включена, для отдельных транзакций можно отключить ожидание репликации, задав для параметра <a class="xref" href="runtime-config-wal.html#GUC-SYNCHRONOUS-COMMIT">synchronous_commit</a> значение <code class="literal">local</code> или <code class="literal">off</code>.</p><p>Задать этот параметр можно только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера.</p></dd></dl></div></div><div class="sect2" id="RUNTIME-CONFIG-REPLICATION-STANDBY"><div class="titlepage"><div><div><h3 class="title">20.6.3. Ведомые серверы <a href="#RUNTIME-CONFIG-REPLICATION-STANDBY" class="id_link">#</a></h3></div></div></div><p>Эти параметры управляют поведением <a class="link" href="warm-standby.html#STANDBY-SERVER-OPERATION" title="27.2.2. Работа резервного сервера">ведомого сервера</a>, который будет получать данные репликации. На ведущем сервере они не играют никакой роли.</p><div class="variablelist"><dl class="variablelist"><dt id="GUC-PRIMARY-CONNINFO"><span class="term"><code class="varname">primary_conninfo</code> (<code class="type">string</code>) <a id="id-1.6.7.9.7.3.1.1.3" class="indexterm"></a></span> <a href="#GUC-PRIMARY-CONNINFO" class="id_link">#</a></dt><dd><p>Указывает строку подключения резервного сервера к передающему. Формат строки описан в <a class="xref" href="libpq-connect.html#LIBPQ-CONNSTRING" title="34.1.1. Строки параметров подключения">Подразделе 34.1.1</a>. Вместо опущенных параметров подключения используются соответствующие переменные окружения (см. <a class="xref" href="libpq-envars.html" title="34.15. Переменные окружения">Раздел 34.15</a>). Если же и переменные не установлены, используются значения по умолчанию.</p><p>В строке подключения должно задаваться имя (или адрес) передающего сервера, а также номер порта, если он отличается от подразумеваемого по умолчанию ведущим. Также в ней указывается имя пользователя, соответствующее роли с необходимыми правами на передающем сервере (см. <a class="xref" href="warm-standby.html#STREAMING-REPLICATION-AUTHENTICATION" title="27.2.5.1. Аутентификация">Подраздел 27.2.5.1</a>). Если сервер осуществляет аутентификацию по паролю, дополнительно потребуется задать пароль. Его можно указать как в строке <code class="varname">primary_conninfo</code>, так и отдельно, в файле <code class="filename">~/.pgpass</code> на резервном сервере (для базы данных <code class="literal">replication</code>). В строке <code class="varname">primary_conninfo</code> имя базы данных задавать не нужно.</p><p>Задать этот параметр можно только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера. Если значение данного параметра меняется во время работы процесса-приёмника WAL, этому процессу посылается сигнал для отключения, и ожидается, что он перезапустится с новым значением (если только определена непустая строка <code class="varname">primary_conninfo</code>). Этот параметр оказывает влияние только при работе сервера в режиме ведомого.</p></dd><dt id="GUC-PRIMARY-SLOT-NAME"><span class="term"><code class="varname">primary_slot_name</code> (<code class="type">string</code>) <a id="id-1.6.7.9.7.3.2.1.3" class="indexterm"></a></span> <a href="#GUC-PRIMARY-SLOT-NAME" class="id_link">#</a></dt><dd><p>Дополнительно задаёт заранее созданный слот, который будет использоваться при подключении к передающему серверу по протоколу потоковой репликации для управления освобождением ресурсов вышестоящего узла (см. <a class="xref" href="warm-standby.html#STREAMING-REPLICATION-SLOTS" title="27.2.6. Слоты репликации">Подраздел 27.2.6</a>). Задать этот параметр можно только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера. Если значение данного параметра меняется во время работы процесса-приёмника WAL, этому процессу посылается сигнал для отключения, и ожидается, что он перезапустится с новым значением. Этот параметр не действует, если строка <code class="varname">primary_conninfo</code> не определена или сервер работает не в режиме ведомого.</p></dd><dt id="GUC-HOT-STANDBY"><span class="term"><code class="varname">hot_standby</code> (<code class="type">boolean</code>) <a id="id-1.6.7.9.7.3.3.1.3" class="indexterm"></a></span> <a href="#GUC-HOT-STANDBY" class="id_link">#</a></dt><dd><p>Определяет, можно ли будет подключаться к серверу и выполнять запросы в процессе восстановления, как описано в <a class="xref" href="hot-standby.html" title="27.4. Горячий резерв">Разделе 27.4</a>. Значение по умолчанию — <code class="literal">on</code> (подключения разрешаются). Задать этот параметр можно только при запуске сервера. Данный параметр играет роль только в режиме ведомого сервера или при восстановлении архива.</p></dd><dt id="GUC-MAX-STANDBY-ARCHIVE-DELAY"><span class="term"><code class="varname">max_standby_archive_delay</code> (<code class="type">integer</code>) <a id="id-1.6.7.9.7.3.4.1.3" class="indexterm"></a></span> <a href="#GUC-MAX-STANDBY-ARCHIVE-DELAY" class="id_link">#</a></dt><dd><p>В режиме горячего резерва этот параметр определяет, как долго должен ждать ведомый сервер, прежде чем отменять запросы, конфликтующие с очередными изменениями в WAL, как описано в <a class="xref" href="hot-standby.html#HOT-STANDBY-CONFLICT" title="27.4.2. Обработка конфликтов запросов">Подразделе 27.4.2</a>. Задержка <code class="varname">max_standby_archive_delay</code> применяется при обработке данных WAL, считываемых из архива (не текущих данных). Если это значение задаётся без единиц измерения, оно считается заданным в миллисекундах. Значение по умолчанию равно 30 секундам. При значении, равном -1, ведомый может ждать завершения конфликтующих запросов неограниченное время. Задать этот параметр можно только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера.</p><p>Заметьте, что параметр <code class="varname">max_standby_archive_delay</code> определяет не максимальное время, которое отводится для выполнения каждого запроса, а максимальное общее время, за которое должны быть применены изменения из одного сегмента WAL. Таким образом, если один запрос привёл к значительной задержке при обработке сегмента WAL, остальным конфликтующим запросам будет отведено гораздо меньше времени.</p></dd><dt id="GUC-MAX-STANDBY-STREAMING-DELAY"><span class="term"><code class="varname">max_standby_streaming_delay</code> (<code class="type">integer</code>) <a id="id-1.6.7.9.7.3.5.1.3" class="indexterm"></a></span> <a href="#GUC-MAX-STANDBY-STREAMING-DELAY" class="id_link">#</a></dt><dd><p>В режиме горячего резерва этот параметр определяет, как долго должен ждать ведомый сервер, прежде чем отменять запросы, конфликтующие с очередными изменениями в WAL, как описано в <a class="xref" href="hot-standby.html#HOT-STANDBY-CONFLICT" title="27.4.2. Обработка конфликтов запросов">Подразделе 27.4.2</a>. Задержка <code class="varname">max_standby_streaming_delay</code> применяется при обработке данных WAL, поступающих при потоковой репликации. Если это значение задаётся без единиц измерения, оно считается заданным в миллисекундах. Значение по умолчанию равно 30 секундам. При значении, равном -1, ведомый может ждать завершения конфликтующих запросов неограниченное время. Задать этот параметр можно только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера.</p><p>Заметьте, что параметр <code class="varname">max_standby_streaming_delay</code> определяет не максимальное время, которое отводится для выполнения каждого запроса, а максимальное общее время, за которое должны быть применены изменения из WAL после получения от главного сервера. Таким образом, если один запрос привёл к значительной задержке, остальным конфликтующим запросам будет отводиться гораздо меньше времени, пока резервный сервер не догонит главный.</p></dd><dt id="GUC-WAL-RECEIVER-CREATE-TEMP-SLOT"><span class="term"><code class="varname">wal_receiver_create_temp_slot</code> (<code class="type">boolean</code>) <a id="id-1.6.7.9.7.3.6.1.3" class="indexterm"></a></span> <a href="#GUC-WAL-RECEIVER-CREATE-TEMP-SLOT" class="id_link">#</a></dt><dd><p>Определяет, должен ли процесс-приёмник WAL создавать временный слот репликации на удалённом сервере в случаях, когда постоянный слот репликации не настроен (не задан в <a class="xref" href="runtime-config-replication.html#GUC-PRIMARY-SLOT-NAME">primary_slot_name</a>). По умолчанию этот параметр отключён. Задать этот параметр можно только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера. Если значение данного параметра меняется во время работы процесса-приёмника WAL, этому процессу посылается сигнал для отключения, и ожидается, что он перезапустится с новым значением.</p></dd><dt id="GUC-WAL-RECEIVER-STATUS-INTERVAL"><span class="term"><code class="varname">wal_receiver_status_interval</code> (<code class="type">integer</code>) <a id="id-1.6.7.9.7.3.7.1.3" class="indexterm"></a></span> <a href="#GUC-WAL-RECEIVER-STATUS-INTERVAL" class="id_link">#</a></dt><dd><p>Определяет минимальную частоту, с которой процесс, принимающий WAL на ведомом сервере, будет сообщать о состоянии репликации ведущему или вышестоящему ведомому, где это состояние можно наблюдать в представлении <a class="link" href="monitoring-stats.html#MONITORING-PG-STAT-REPLICATION-VIEW" title="28.2.4. pg_stat_replication"><code class="structname">pg_stat_replication</code></a>. В этом сообщении передаются следующие позиции в журнале предзаписи: позиция изменений записанных, изменений, сохранённых на диске, и изменений применённых. Значение параметра определяет максимальный интервал между сообщениями. Сообщения о состоянии передаются при каждом продвижении позиций записанных или сохранённых на диске изменений, или с интервалом, заданным этим параметром, если он имеет ненулевое значение. В некоторых случаях сообщения о состоянии отправляются без учёта данного параметра; например, когда завершается обработка существующего WAL или когда переменная <code class="varname">synchronous_commit</code> имеет значение <code class="literal">remote_apply</code>. Таким образом, последняя переданная позиция применённых изменений может немного отставать от фактической в текущий момент. Если это значение задаётся без единиц измерения, оно считается заданным в секундах. Значение по умолчанию равно 10 секундам. Задать этот параметр можно только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера.</p></dd><dt id="GUC-HOT-STANDBY-FEEDBACK"><span class="term"><code class="varname">hot_standby_feedback</code> (<code class="type">boolean</code>) <a id="id-1.6.7.9.7.3.8.1.3" class="indexterm"></a></span> <a href="#GUC-HOT-STANDBY-FEEDBACK" class="id_link">#</a></dt><dd><p>Определяет, будет ли сервер горячего резерва сообщать ведущему или вышестоящему ведомому о запросах, которые он выполняет в данный момент. Это позволяет исключить необходимость отмены запросов, вызванную очисткой записей, но при некоторых типах нагрузки это может приводить к раздуванию базы данных на ведущем сервере. Эти сообщения о запросах будут отправляться не чаще, чем раз в интервал, задаваемый параметром <code class="varname">wal_receiver_status_interval</code>. Значение данного параметра по умолчанию — <code class="literal">off</code>. Задать этот параметр можно только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера.</p><p>Если используется каскадная репликация, сообщения о запросах передаются выше, пока в итоге не достигнут ведущего сервера. На промежуточных серверах эта информация больше никак не задействуется.</p><p>Этот параметр не переопределяет поведение <code class="varname">old_snapshot_threshold</code>, установленное на ведущем сервере; снимок на ведомом сервере, имеющий возраст больше заданного указанным параметром на ведущем, может стать недействительным, что приведёт к отмене транзакций на ведомом. Это объясняется тем, что предназначение <code class="varname">old_snapshot_threshold</code> заключается в указании абсолютного ограничения времени, в течение которого могут накапливаться мёртвые строки, которое иначе могло бы нарушаться из-за конфигурации ведомого.</p></dd><dt id="GUC-WAL-RECEIVER-TIMEOUT"><span class="term"><code class="varname">wal_receiver_timeout</code> (<code class="type">integer</code>) <a id="id-1.6.7.9.7.3.9.1.3" class="indexterm"></a></span> <a href="#GUC-WAL-RECEIVER-TIMEOUT" class="id_link">#</a></dt><dd><p>Задаёт период времени, по истечении которого прерываются неактивные соединения репликации. Это помогает принимающему ведомому серверу обнаружить сбой ведущего или разрыв сети. Если это значение задаётся без единиц измерения, оно считается заданным в миллисекундах. Значение по умолчанию — 60 секунд. При значении, равном нулю, тайм-аут отключается. Задать этот параметр можно только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера.</p></dd><dt id="GUC-WAL-RETRIEVE-RETRY-INTERVAL"><span class="term"><code class="varname">wal_retrieve_retry_interval</code> (<code class="type">integer</code>) <a id="id-1.6.7.9.7.3.10.1.3" class="indexterm"></a></span> <a href="#GUC-WAL-RETRIEVE-RETRY-INTERVAL" class="id_link">#</a></dt><dd><p>Определяет, сколько ведомый сервер должен ждать поступления данных WAL из любых источников (потоковая репликация, локальный <code class="filename">pg_wal</code> или архив WAL), прежде чем повторять попытку получения WAL. Если это значение задаётся без единиц измерения, оно считается заданным в миллисекундах. Значение по умолчанию — 5 секунд. Задать этот параметр можно только в <code class="filename">postgresql.conf</code> или в командной строке сервера.</p><p>Этот параметр полезен в конфигурациях, когда для узла в схеме восстановления нужно регулировать время ожидания новых данных WAL. Например, при восстановлении архива можно ускорить реакцию на появление нового файла WAL, уменьшив значение этого параметра. В системе с низкой активностью WAL увеличение этого параметра приведёт к сокращению числа запросов, необходимых для отслеживания архивов WAL, что может быть полезно в облачных окружениях, где учитывается число обращений к инфраструктуре.</p><p>В логической репликации этот параметр также ограничивает частоту перезапуска неудачного рабочего процесса применения изменений репликации.</p></dd><dt id="GUC-RECOVERY-MIN-APPLY-DELAY"><span class="term"><code class="varname">recovery_min_apply_delay</code> (<code class="type">integer</code>) <a id="id-1.6.7.9.7.3.11.1.3" class="indexterm"></a></span> <a href="#GUC-RECOVERY-MIN-APPLY-DELAY" class="id_link">#</a></dt><dd><p>По умолчанию ведомый сервер восстанавливает записи WAL передающего настолько быстро, насколько это возможно. Иногда полезно иметь возможность задать задержку при копировании данных, например, для устранения ошибок, связанных с потерей данных. Этот параметр позволяет отложить восстановление на заданное время. Например, если установить значение <code class="literal">5min</code>, ведомый сервер будет воспроизводить фиксацию транзакции не раньше, чем через 5 минут (судя по его системным часам) после времени фиксации, сообщённого ведущим. Если это значение задаётся без единиц измерения, оно считается заданным в миллисекундах. Значение по умолчанию равно нулю, то есть задержка не добавляется.</p><p>Возможна ситуация, когда задержка репликации между серверами превышает значение этого параметра. В этом случае дополнительная задержка не добавляется. Заметьте, что задержка вычисляется как разница между меткой времени, записанной в WAL на ведущем сервере, и текущим временем на ведомом. Запаздывание передачи, связанное с задержками в сети или каскадной репликацией, может существенно сократить реальное время ожидания. Если время на главном и ведомом сервере не синхронизировано, это может приводить к применению записей ранее ожидаемого, однако это не очень важно, потому что полезные значения этого параметра намного больше, чем обычно бывает разница во времени между двумя серверами.</p><p>Задержка применяется лишь для записей WAL, представляющих фиксацию транзакций. Остальные записи проигрываются незамедлительно, так как их эффект не будет заметен до применения соответствующей записи о фиксации транзакции, благодаря правилам видимости MVCC.</p><p>Задержка добавляется, как только восстанавливаемая база данных достигает согласованного состояния, и исключается, когда ведущий сервер переключается в режим основного. После переключения ведущий сервер завершает восстановление незамедлительно.</p><p>Записи WAL должны храниться на резервном сервере, пока они не будут применены. Таким образом, чем больше задержка, тем больший объём файлов WAL необходимо накапливать, и тем больше дискового пространства потребуется для каталога <code class="filename">pg_wal</code> на ведомом сервере.</p><p>Данный параметр предназначен для применения в конфигурациях с потоковой репликацией; однако если он задан, он будет учитываться во всех случаях, кроме восстановления после сбоя. Задержка, устанавливаемая этим параметром, влияет и на работу механизма <code class="varname">hot_standby_feedback</code>, что может привести к раздуванию базы на главном сервере; использовать данный параметр при включении этого механизма следует с осторожностью. </p><div class="warning"><h3 class="title">Предупреждение</h3><p>Этот параметр влияет на синхронную репликацию, когда <code class="varname">synchronous_commit</code> имеет значение <code class="literal">remote_apply</code>; каждый <code class="literal">COMMIT</code> будет ждать подтверждения применения.</p></div><p>Задать этот параметр можно только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера.</p></dd></dl></div></div><div class="sect2" id="RUNTIME-CONFIG-REPLICATION-SUBSCRIBER"><div class="titlepage"><div><div><h3 class="title">20.6.4. Подписчики <a href="#RUNTIME-CONFIG-REPLICATION-SUBSCRIBER" class="id_link">#</a></h3></div></div></div><p>Эти параметры управляют поведением подписчика логической репликации. На публикующем сервере они не играют роли. За подробностями обратитесь к <a class="xref" href="logical-replication-config.html" title="31.10. Параметры конфигурации">Разделу 31.10</a></p><div class="variablelist"><dl class="variablelist"><dt id="GUC-MAX-REPLICATION-SLOTS-SUBSCRIBER"><span class="term"><code class="varname">max_replication_slots</code> (<code class="type">integer</code>) <a id="id-1.6.7.9.8.3.1.1.3" class="indexterm"></a></span> <a href="#GUC-MAX-REPLICATION-SLOTS-SUBSCRIBER" class="id_link">#</a></dt><dd><p>Указывает, сколько источников репликации (см. <a class="xref" href="replication-origins.html" title="Глава 50. Отслеживание прогресса репликации">Главу 50</a>) можно отслеживать одновременно, по сути ограничивая количество подписок на логическую репликацию, которые могут быть созданы на сервере. Если установленное значение будет меньше, чем текущее количество отслеживаемых источников репликации (показываемое в <a class="link" href="view-pg-replication-origin-status.html" title="54.18. pg_replication_origin_status">pg_replication_origin_status</a>), сервер не запустится. Значение параметра <code class="literal">max_replication_slots</code> должно быть не менее числа подписок, добавляемого подписчику, плюс некоторый резерв для синхронизации таблиц.</p><p>Обратите внимание, что этот параметр также применяется на стороне передающего сервера, но с другим значением.</p></dd><dt id="GUC-MAX-LOGICAL-REPLICATION-WORKERS"><span class="term"><code class="varname">max_logical_replication_workers</code> (<code class="type">integer</code>) <a id="id-1.6.7.9.8.3.2.1.3" class="indexterm"></a></span> <a href="#GUC-MAX-LOGICAL-REPLICATION-WORKERS" class="id_link">#</a></dt><dd><p>Задаёт максимально возможное число рабочих процессов логической репликации. В это число входят как ведущие и параллельные рабочие процессы, применяющие изменения, так и процессы, синхронизирующие таблицы.</p><p>Рабочие процессы логической репликации берутся из пула, контролируемого параметром <code class="varname">max_worker_processes</code>.</p><p>Значение по умолчанию — 4. Этот параметр можно задать только при запуске сервера.</p></dd><dt id="GUC-MAX-SYNC-WORKERS-PER-SUBSCRIPTION"><span class="term"><code class="varname">max_sync_workers_per_subscription</code> (<code class="type">integer</code>) <a id="id-1.6.7.9.8.3.3.1.3" class="indexterm"></a></span> <a href="#GUC-MAX-SYNC-WORKERS-PER-SUBSCRIPTION" class="id_link">#</a></dt><dd><p>Максимальное число рабочих процессов, выполняющих синхронизацию, для одной подписки. Этот параметр управляет степенью распараллеливания копирования начальных данных в процессе инициализации подписки или при добавлении новых таблиц.</p><p>В настоящее время одну таблицу может обрабатывать только один рабочий процесс синхронизации.</p><p>Рабочие процессы синхронизации берутся из пула, контролируемого параметром <code class="varname">max_logical_replication_workers</code>.</p><p>Значение по умолчанию — 2. Задать этот параметр можно только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера.</p></dd><dt id="GUC-MAX-PARALLEL-APPLY-WORKERS-PER-SUBSCRIPTION"><span class="term"><code class="varname">max_parallel_apply_workers_per_subscription</code> (<code class="type">integer</code>) <a id="id-1.6.7.9.8.3.4.1.3" class="indexterm"></a></span> <a href="#GUC-MAX-PARALLEL-APPLY-WORKERS-PER-SUBSCRIPTION" class="id_link">#</a></dt><dd><p>Максимальное число параллельных рабочих процессов, применяющих изменения, для одной подписки. Этот параметр управляет степенью распараллеливания для потоковой передачи незавершённых транзакций с параметром подписки <code class="literal">streaming = parallel</code>.</p><p>Рабочие процессы применения изменений берутся из пула, контролируемого параметром <code class="varname">max_logical_replication_workers</code>.</p><p>Значение по умолчанию — 2. Задать этот параметр можно только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера.</p></dd></dl></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="runtime-config-wal.html" title="20.5. Журнал предзаписи">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="runtime-config.html" title="Глава 20. Настройка сервера">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="runtime-config-query.html" title="20.7. Планирование запросов">След.</a></td></tr><tr><td width="40%" align="left" valign="top">20.5. Журнал предзаписи </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 20.7. Планирование запросов</td></tr></table></div></body></html>