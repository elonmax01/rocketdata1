<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>67.3. Опорные функции B-деревьев</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="btree-behavior.html" title="67.2. Поведение классов операторов B-дерева" /><link rel="next" href="btree-implementation.html" title="67.4. Реализация" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">67.3. Опорные функции B-деревьев</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="btree-behavior.html" title="67.2. Поведение классов операторов B-дерева">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="btree.html" title="Глава 67. Индексы B-деревья">Наверх</a></td><th width="60%" align="center">Глава 67. Индексы B-деревья</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="btree-implementation.html" title="67.4. Реализация">След.</a></td></tr></table><hr /></div><div class="sect1" id="BTREE-SUPPORT-FUNCS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">67.3. Опорные функции B-деревьев <a href="#BTREE-SUPPORT-FUNCS" class="id_link">#</a></h2></div></div></div><p>Как показано в <a class="xref" href="xindex.html#XINDEX-BTREE-SUPPORT-TABLE" title="Таблица 38.9. Опорные функции B-деревьев">Таблице 38.9</a>, btree определяет одну необходимую и четыре необязательных опорных функции. Таким образом, пользователь может задать пять методов:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="function">order</code></span></dt><dd><p>Для всех комбинаций типов данных, для которых семейство операторов btree предоставляет операторы сравнения, оно должно предоставлять опорную функцию сравнения в <code class="structname">pg_amproc</code> с номером 1 и c <code class="structfield">amproclefttype</code>/<code class="structfield">amprocrighttype</code>, равными левому и правому типу сравнения (то есть тем же типам данных, с которыми соответствующие операторы зарегистрированы в <code class="structname">pg_amop</code>). Эта функция сравнения должна принимать два отличных от NULL значения <em class="replaceable"><code>A</code></em> и <em class="replaceable"><code>B</code></em> и возвращать значение <code class="type">int32</code>, которое будет <code class="literal">&lt;</code> <code class="literal">0</code>, <code class="literal">0</code> или <code class="literal">&gt;</code> <code class="literal">0</code>, когда <em class="replaceable"><code>A</code></em> <code class="literal">&lt;</code> <em class="replaceable"><code>B</code></em>, <em class="replaceable"><code>A</code></em> <code class="literal">=</code> <em class="replaceable"><code>B</code></em> или <em class="replaceable"><code>A</code></em> <code class="literal">&gt;</code> <em class="replaceable"><code>B</code></em>, соответственно. Результат NULL не допускается: все значения типа данных должны быть сравнимыми. Примеры можно найти в <code class="filename">src/backend/access/nbtree/nbtcompare.c</code>.</p><p>Если сравниваемые значения имеют сортируемый тип данных, опорной функции сравнения будет передан OID соответствующего правила сортировки через стандартный механизм <code class="function">PG_GET_COLLATION()</code>.</p></dd><dt><span class="term"><code class="function">sortsupport</code></span></dt><dd><p>Дополнительно семейство операторов btree может предоставить функции <em class="firstterm">поддержки сортировки</em>, которые регистрируются под номером опорной функции 2. Эти функции позволяют реализовывать сравнения для целей сортировки гораздо эффективнее, чем это возможно при прямолинейном вызове функции поддержки сравнения. Задействованные в этом программные интерфейсы определены в <code class="filename">src/include/utils/sortsupport.h</code>.</p></dd><dt><span class="term"><code class="function">in_range</code></span></dt><dd><a id="id-1.10.18.5.3.3.2.1" class="indexterm"></a><a id="id-1.10.18.5.3.3.2.2" class="indexterm"></a><p>Дополнительно семейство операторов btree может предоставить опорные функции <em class="firstterm">in_range</em>, которые регистрируются под номером 3. Они не используются в ходе операций с индексом btree; вместо этого они расширяют семантику семейства операторов, чтобы оно могло поддерживать оконные предложения <code class="literal">RANGE</code> <em class="replaceable"><code>смещение</code></em> <code class="literal">PRECEDING</code> и <code class="literal">RANGE</code> <em class="replaceable"><code>смещение</code></em> <code class="literal">FOLLOWING</code> (см. <a class="xref" href="sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS" title="4.2.8. Вызовы оконных функций">Подраздел 4.2.8</a>). По сути они предоставляют дополнительную информацию, позволяющую добавлять или вычитать <em class="replaceable"><code>смещение</code></em> в соответствии с порядком сортировки, принятым в семействе.</p><p>Функция <code class="function">in_range</code> должна иметь сигнатуру </p><pre class="synopsis">
in_range(<em class="replaceable"><code>значение</code></em> type1, <em class="replaceable"><code>база</code></em> type1, <em class="replaceable"><code>смещение</code></em> type2, <em class="replaceable"><code>вычитание</code></em> bool, <em class="replaceable"><code>меньше</code></em> bool)
returns bool
</pre><p> <em class="replaceable"><code>Значение</code></em> и <em class="replaceable"><code>база</code></em> должны быть одного типа данных, и этот тип должен поддерживаться семейством операторов (то есть это должен быть тип, для которого реализуется сортировка). Однако <em class="replaceable"><code>смещение</code></em> может быть другого типа, который никаким другим образом не поддерживается данным семейством. Например, встроенное семейство <code class="literal">time_ops</code> предоставляет функцию, для которой <em class="replaceable"><code>смещение</code></em> имеет тип <code class="type">interval</code>. Семейство может предоставлять функции <code class="function">in_range</code> для любых из своих поддерживаемых типов и одного или нескольких типов <em class="replaceable"><code>смещений</code></em>. Каждая функция <code class="function">in_range</code> должна регистрироваться в <code class="structname">pg_amproc</code> с полем <code class="structfield">amproclefttype</code>, равным <code class="type">type1</code>, и <code class="structfield">amprocrighttype</code>, равным <code class="type">type2</code>.</p><p>Суть действия функции <code class="function">in_range</code> зависит от двух логических флагов. Она должна прибавить или вычесть из <em class="replaceable"><code>базы</code></em> <em class="replaceable"><code>смещение</code></em>, а затем сравнить <em class="replaceable"><code>значение</code></em> с результатом следующим образом: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>если <code class="literal">!</code><em class="replaceable"><code>вычитание</code></em> и <code class="literal">!</code><em class="replaceable"><code>меньше</code></em>, возвращается <em class="replaceable"><code>значение</code></em> <code class="literal">&gt;=</code> (<em class="replaceable"><code>база</code></em> <code class="literal">+</code> <em class="replaceable"><code>смещение</code></em>)</p></li><li class="listitem"><p>если <code class="literal">!</code><em class="replaceable"><code>вычитание</code></em> и <em class="replaceable"><code>меньше</code></em>, возвращается <em class="replaceable"><code>значение</code></em> <code class="literal">&lt;=</code> (<em class="replaceable"><code>база</code></em> <code class="literal">+</code> <em class="replaceable"><code>смещение</code></em>)</p></li><li class="listitem"><p>если <em class="replaceable"><code>вычитание</code></em> и <code class="literal">!</code><em class="replaceable"><code>меньше</code></em>, возвращается <em class="replaceable"><code>значение</code></em> <code class="literal">&gt;=</code> (<em class="replaceable"><code>база</code></em> <code class="literal">-</code> <em class="replaceable"><code>смещение</code></em>)</p></li><li class="listitem"><p>если <em class="replaceable"><code>вычитание</code></em> и <em class="replaceable"><code>меньше</code></em>, возвращается <em class="replaceable"><code>значение</code></em> <code class="literal">&lt;=</code> (<em class="replaceable"><code>база</code></em> <code class="literal">-</code> <em class="replaceable"><code>смещение</code></em>)</p></li></ul></div><p> Прежде чем делать это, функция должна проверить знак <em class="replaceable"><code>смещения</code></em> и, если оно отрицательное, выдать ошибку <code class="literal">ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE</code> (22013) с текстом ошибки <span class="quote">«<span class="quote">invalid preceding or following size in window function</span>»</span> (неверная предшествующая или последующая величина в оконной функции). (Это требуется стандартом SQL, но нестандартные семейства операторов могут проигнорировать данное ограничение, так как оно не несёт большой смысловой нагрузки.) Проверка этого требования делегируется функции <code class="function">in_range</code>, чтобы коду ядра не требовалось понимать, что означает <span class="quote">«<span class="quote">меньше нуля</span>»</span> для произвольного типа данных.</p><p>Кроме того, функции <code class="function">in_range</code>, если это практично, могут не выдавать ошибку, когда операция <em class="replaceable"><code>база</code></em> <code class="literal">+</code> <em class="replaceable"><code>смещение</code></em> или <em class="replaceable"><code>база</code></em> <code class="literal">-</code> <em class="replaceable"><code>смещение</code></em> приводит к переполнению. Правильный результат сравнения можно получить, даже если это значение выходит за границы допустимого диапазона этого типа данных. Заметьте, что если для типа данных определены такие понятия, как <span class="quote">«<span class="quote">бесконечность</span>»</span> и <span class="quote">«<span class="quote">NaN</span>»</span>, могут потребоваться дополнительные меры для обеспечения согласованности результатов <code class="function">in_range</code> с обычным порядком сортировки данного семейства операторов.</p><p>Результаты функции <code class="function">in_range</code> должны соответствовать порядку сортировки, устанавливаемому семейством операторов. Точнее говоря, при любых фиксированных аргументах <em class="replaceable"><code>смещение</code></em> и <em class="replaceable"><code>вычитание</code></em> справедливо: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Если <code class="function">in_range</code> с <em class="replaceable"><code>меньше</code></em> = true возвращает true для некоторого <em class="replaceable"><code>значения1</code></em> и <em class="replaceable"><code>базы</code></em>, true должно возвращаться для каждого <em class="replaceable"><code>значения2</code></em> <code class="literal">&lt;=</code> <em class="replaceable"><code>значению1</code></em> с той же <em class="replaceable"><code>базой</code></em>.</p></li><li class="listitem"><p>Если <code class="function">in_range</code> с <em class="replaceable"><code>меньше</code></em> = true возвращает false для некоторого <em class="replaceable"><code>значения1</code></em> и <em class="replaceable"><code>базы</code></em>, false должно возвращаться для любого <em class="replaceable"><code>значения2</code></em> <code class="literal">&gt;=</code> <em class="replaceable"><code>значению1</code></em> с той же <em class="replaceable"><code>базой</code></em>.</p></li><li class="listitem"><p>Если <code class="function">in_range</code> с <em class="replaceable"><code>меньше</code></em> = true возвращает true для некоторого <em class="replaceable"><code>значения</code></em> и <em class="replaceable"><code>базы1</code></em>, true должно возвращаться для каждой <em class="replaceable"><code>базы2</code></em> <code class="literal">&gt;=</code> <em class="replaceable"><code>базе1</code></em> с тем же <em class="replaceable"><code>значением</code></em>.</p></li><li class="listitem"><p>Если <code class="function">in_range</code> с <em class="replaceable"><code>меньше</code></em> = true возвращает false для некоторого <em class="replaceable"><code>значения</code></em> и <em class="replaceable"><code>базы1</code></em>, false должно возвращаться для любой <em class="replaceable"><code>базы2</code></em> <code class="literal">&lt;=</code> <em class="replaceable"><code>базе1</code></em> с тем же <em class="replaceable"><code>значением</code></em>.</p></li></ul></div><p> Аналогичные утверждения с противоположными условиями должны выполняться при <em class="replaceable"><code>меньше</code></em> = false.</p><p>Если упорядочиваемый тип (<code class="type">type1</code>) является сортируемым, функции <code class="function">in_range</code> будет передан OID соответствующего правила сортировки через стандартный механизм PG_GET_COLLATION().</p><p>Функции <code class="function">in_range</code> не должны обрабатывать NULL в аргументах и обычно помечаются как строгие.</p></dd><dt><span class="term"><code class="function">equalimage</code></span></dt><dd><p>Дополнительно семейство операторов btree может предоставить опорные функции <code class="function">equalimage</code> (<span class="quote">«<span class="quote">равенство подразумевает равенство образов</span>»</span>), регистрируемые под номером 4. Эти функции позволяют коду ядра определить, безопасно ли применять исключение дубликатов в B-дереве. В настоящее время функции <code class="function">equalimage</code> вызываются только при построении или перестроении индекса.</p><p>Функция <code class="function">equalimage</code> должна иметь сигнатуру </p><pre class="synopsis">
equalimage(<em class="replaceable"><code>opcintype</code></em> <code class="type">oid</code>) returns bool
</pre><p> Её результатом будет статическая информация о классе операторов и правиле сортировки. Результат <code class="literal">true</code> означает, что функция <code class="function">order</code> для класса операторов будет возвращать <code class="literal">0</code> (признак равенства аргументов), только когда аргументы <em class="replaceable"><code>A</code></em> и <em class="replaceable"><code>B</code></em> взаимозаменяемы без потери семантической информации. Если функция <code class="function">equalimage</code> не определена или она возвращает <code class="literal">false</code>, рассчитывать на выполнение данного условия нельзя.</p><p>В аргументе <em class="replaceable"><code>opcintype</code></em> передаётся <code class="literal"><code class="structname">pg_type</code>.oid</code> типа данных, индексируемого данным классом операторов. Это сделано для удобства повторного использования нижележащей функции <code class="function">equalimage</code> в разных классах операторов. Если тип <em class="replaceable"><code>opcintype</code></em> поддерживает правила сортировки, функции <code class="function">equalimage</code> будет передан OID соответствующего правила через стандартный механизм <code class="function">PG_GET_COLLATION()</code>.</p><p>С точки зрения класса операторов возвращаемое значение <code class="literal">true</code> означает, что возможно безопасное применение исключения дубликатов (или оно безопасно для правила сортировки, OID которого был передан функции <code class="function">equalimage</code>). Однако код ядра будет считать исключение дубликатов безопасным для индекса, только если для <span class="emphasis"><em>каждого</em></span> столбца в этом индексе используется класс операторов, регистрирующий функцию <code class="function">equalimage</code>, и все эти функции при вызове возвращают <code class="literal">true</code>.</p><p>Равенство образов <span class="emphasis"><em>почти</em></span> равнозначно простому битовому равенству. Но есть одно небольшое различие: когда индексируется тип данных varlena, представление двух равных образов на диске может отличаться из-за различного применения сжатия <acronym class="acronym">TOAST</acronym> к входным данным. Говоря формально, когда функция <code class="function">equalimage</code> класса операторов возвращает <code class="literal">true</code>, можно полагать, что функция на C <code class="literal">datum_image_eq()</code> гарантированно будет согласованной с функцией <code class="function">order</code> класса операторов (при условии передачи обеим функциям одинакового OID правила сортировки).</p><p>Код ядра в принципе не может сделать какие-то выводы о свойстве класса операторов <span class="quote">«<span class="quote">равенство подразумевает равенство образов</span>»</span> в семействе операторов для множества типов, анализируя другие классы операторов в том же семействе. Также не имеет смысла регистрировать межтиповую функцию <code class="function">equalimage</code> для семейства операторов, и при попытке сделать это произойдёт ошибка. Это связано с тем, что свойство <span class="quote">«<span class="quote">равенство подразумевает равенство образов</span>»</span> зависит не только от семантики сортировки/равенства, определяемой в некоторой степени на уровне семейства операторов. Вообще говоря, это свойство относится к конкретному типу и должно рассматриваться отдельно.</p><p>Для классов операторов, поставляемых в базовом продукте <span class="productname">PostgreSQL</span>, принято соглашение регистрировать универсальную функцию <code class="function">equalimage</code>. Большинство классов операторов регистрируют в качестве такой функции <code class="function">btequalimage()</code>, которая устанавливает, что исключение дубликатов безопасно без дополнительных условий. Операторы классов для типов данных, поддерживающих правила сортировки, например, для типа <code class="type">text</code>, регистрируют функцию <code class="function">btvarstrequalimage()</code>, которая устанавливает, что исключение дубликатов безопасно с детерминированными правилами сортировки. Для сохранения порядка в сторонних расширениях также рекомендуется регистрировать их собственные функции <code class="function">equalimage</code>.</p></dd><dt><span class="term"><code class="function">options</code></span></dt><dd><p>В дополнение семейство операторов btree может предоставить опорные функции <code class="function">options</code> (<span class="quote">«<span class="quote">параметры класса операторов</span>»</span>), регистрируемые под номером 5. Эти функции позволяют определить набор видимых пользователю параметров, управляющих поведением класса операторов.</p><p>Опорная функция <code class="function">options</code> должна иметь сигнатуру </p><pre class="synopsis">
options(<em class="replaceable"><code>relopts</code></em> <code class="type">local_relopts *</code>) returns void
</pre><p> Этой функции передаётся указатель на структуру <em class="replaceable"><code>local_relopts</code></em>, в которую нужно внести набор параметров, относящихся к классу операторов. Обращаться к этим параметрам из других опорных функций можно с помощью макросов <code class="literal">PG_HAS_OPCLASS_OPTIONS()</code> и <code class="literal">PG_GET_OPCLASS_OPTIONS()</code>.</p><p>В настоящее время опорная функция <code class="function">options</code> не определена ни для одного из классов операторов btree. Сама организация B-дерева не позволяет гибко менять представление ключей, как это возможно с GiST, SP-GiST, GIN и BRIN. Поэтому с существующим методом доступа к индексу-B-дереву для функции <code class="function">options</code> нет полезных применений. Тем не менее эта опорная функция была добавлена для B-дерева ради единообразия и не исключено, что она окажется полезной по мере развития реализации B-дерева в <span class="productname">PostgreSQL</span>.</p></dd></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="btree-behavior.html" title="67.2. Поведение классов операторов B-дерева">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="btree.html" title="Глава 67. Индексы B-деревья">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="btree-implementation.html" title="67.4. Реализация">След.</a></td></tr><tr><td width="40%" align="left" valign="top">67.2. Поведение классов операторов B-дерева </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 67.4. Реализация</td></tr></table></div></body></html>