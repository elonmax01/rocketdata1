<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>75.2. Исходные данные системных каталогов</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="system-catalog-declarations.html" title="75.1. Правила объявления системных каталогов" /><link rel="next" href="bki-format.html" title="75.3. Формат файла BKI" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">75.2. Исходные данные системных каталогов</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="system-catalog-declarations.html" title="75.1. Правила объявления системных каталогов">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="bki.html" title="Глава 75. Объявление и начальное содержимое системных каталогов">Наверх</a></td><th width="60%" align="center">Глава 75. Объявление и начальное содержимое системных каталогов</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="bki-format.html" title="75.3. Формат файла BKI">След.</a></td></tr></table><hr /></div><div class="sect1" id="SYSTEM-CATALOG-INITIAL-DATA"><div class="titlepage"><div><div><h2 class="title" style="clear: both">75.2. Исходные данные системных каталогов <a href="#SYSTEM-CATALOG-INITIAL-DATA" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="system-catalog-initial-data.html#SYSTEM-CATALOG-INITIAL-DATA-FORMAT">75.2.1. Формат файла данных</a></span></dt><dt><span class="sect2"><a href="system-catalog-initial-data.html#SYSTEM-CATALOG-OID-ASSIGNMENT">75.2.2. Назначение OID</a></span></dt><dt><span class="sect2"><a href="system-catalog-initial-data.html#SYSTEM-CATALOG-OID-REFERENCES">75.2.3. Поиск OID по ссылке</a></span></dt><dt><span class="sect2"><a href="system-catalog-initial-data.html#SYSTEM-CATALOG-AUTO-ARRAY-TYPES">75.2.4. Автоматическое создание типов массивов</a></span></dt><dt><span class="sect2"><a href="system-catalog-initial-data.html#SYSTEM-CATALOG-RECIPES">75.2.5. Рецепты по редактированию файлов данных</a></span></dt></dl></div><p>Для каждого каталога, с которым связаны вручную создаваемые исходные данные, (не все каталоги такие) имеется соответствующий файл <code class="literal">.dat</code>, содержащий эти данные в редактируемом формате.</p><div class="sect2" id="SYSTEM-CATALOG-INITIAL-DATA-FORMAT"><div class="titlepage"><div><div><h3 class="title">75.2.1. Формат файла данных <a href="#SYSTEM-CATALOG-INITIAL-DATA-FORMAT" class="id_link">#</a></h3></div></div></div><p>Каждый файл <code class="literal">.dat</code> содержит описания структур данных Perl, в результате вычисления которых (функцией eval) в памяти формируется структура данных, состоящая из массива хеш-ссылок, соответствующих каждой строке каталога. Немного модифицированная выдержка из <code class="filename">pg_database.dat</code> иллюстрирует основные моменты:</p><pre class="programlisting">
[

# A comment could appear here.
{ oid =&gt; '1', oid_symbol =&gt; 'Template1DbOid',
  descr =&gt; 'database\'s default template',
  datname =&gt; 'template1', encoding =&gt; 'ENCODING',
  datlocprovider =&gt; 'LOCALE_PROVIDER', datistemplate =&gt; 't',
  datallowconn =&gt; 't', datconnlimit =&gt; '-1', datfrozenxid =&gt; '0',
  datminmxid =&gt; '1', dattablespace =&gt; 'pg_default', datcollate =&gt; 'LC_COLLATE',
  datctype =&gt; 'LC_CTYPE', daticulocale =&gt; 'ICU_LOCALE', datacl =&gt; '_null_' },

]
</pre><p>Замечания:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Общий формат файла: открывающая квадратная скобка, один или более наборов фигурных скобок, каждый из которых представляет строку каталога, и закрывающая квадратная скобка. После каждой закрывающей фигурной скобки должна идти запятая.</p></li><li class="listitem"><p>В каждой строке каталога записываются разделённые запятыми пары <em class="replaceable"><code>ключ</code></em> <code class="literal">=&gt;</code> <em class="replaceable"><code>значение</code></em>. В качестве <em class="replaceable"><code>ключа</code></em> принимаются имена столбцов каталога, а также ключи метаданных <code class="literal">oid</code>, <code class="literal">array_type_oid</code>, <code class="literal">oid_symbol</code> и <code class="literal">descr</code>. (Использование <code class="literal">oid</code> и <code class="literal">oid_symbol</code> описывается в <a class="xref" href="system-catalog-initial-data.html#SYSTEM-CATALOG-OID-ASSIGNMENT" title="75.2.2. Назначение OID">Подразделе 75.2.2</a>, а <code class="literal">array_type_oid</code> — в <a class="xref" href="system-catalog-initial-data.html#SYSTEM-CATALOG-AUTO-ARRAY-TYPES" title="75.2.4. Автоматическое создание типов массивов">Подразделе 75.2.4</a>. В <code class="literal">descr</code> задаётся строка с описанием объекта, которое будет вставлено в <code class="structname">pg_description</code> или <code class="structname">pg_shdescription</code>.) Ключи метаданных могут опускаться, но ключ для каждого столбца каталога должен присутствовать, если только в файле <code class="literal">.h</code> данного каталога для столбца не задано значение по умолчанию. (Для иллюстрации в показанном выше примере опущено поле <code class="structfield">datdba</code>, так как в <code class="filename">pg_database.h</code> для него задаётся подходящее значение по умолчанию.)</p></li><li class="listitem"><p>Все значения должны заключаться в апострофы. Апострофы внутри значений экранируются обратной косой чертой. Обратные косые черты в данных могут, но не обязательно должны дублироваться; это соответствует правилам Perl по оформлению простых строковых констант. Заметьте, что обратные косые черты, фигурирующие в данных, будут обрабатываться сканером исходных данных как символы экранирования, согласно тем же правилам записи строковых констант (см. <a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-STRINGS-ESCAPE" title="4.1.2.2. Строковые константы со спецпоследовательностями в стиле C">Подраздел 4.1.2.2</a>); например, <code class="literal">\t</code> преобразуется в символ табуляции. Если вы хотите получить именно обратную косую черту в окончательном значении, вам надо будет написать четыре этих символа: Perl отбрасывает два и оставляет <code class="literal">\\</code> сканеру исходных данных.</p></li><li class="listitem"><p>Значения NULL представляются как <code class="literal">_null_</code>. (Заметьте, что создать значение с именно такой строкой невозможно.)</p></li><li class="listitem"><p>Комментарии предваряются знаком <code class="literal">#</code> и должны размещаться в отдельных строках.</p></li><li class="listitem"><p>Значения полей, выражающие OID других записей каталога, должны представляться символьными именами, а не числовыми кодами OID. (В примере выше такое символьное значение задаётся для поля <code class="structfield">dattablespace</code>.) Об этом рассказывается в <a class="xref" href="system-catalog-initial-data.html#SYSTEM-CATALOG-OID-REFERENCES" title="75.2.3. Поиск OID по ссылке">Подразделе 75.2.3</a>.</p></li><li class="listitem"><p>Так как хеши являются неупорядоченной структурой данных, порядок полей и расположение строк не имеют семантической значимости. Однако для поддержания согласованного представления мы установили несколько правил, которые применяет скрипт форматирования <code class="filename">reformat_dat_file.pl</code>: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>В каждой паре фигурных скобок сначала по порядку идут поля метаданных <code class="literal">oid</code>, <code class="literal">oid_symbol</code>, <code class="literal">array_type_oid</code> и <code class="literal">descr</code> (в случае наличия), а за ними собственные поля каталога в определённом для них порядке.</p></li><li class="listitem"><p>Переводы строк при необходимости вставляются между полями для ограничения длины строки 80 символами, если это возможно. Перевод строки также вставляется между полями метаданных и обычными полями.</p></li><li class="listitem"><p>Если в файле <code class="literal">.h</code> каталога задаётся значение по умолчанию для столбца и то же значение указано в записи данных, <code class="filename">reformat_dat_file.pl</code> уберёт его из файла данных. Таким образом обеспечивается компактное представление данных.</p></li><li class="listitem"><p>Скрипт <code class="filename">reformat_dat_file.pl</code> сохраняет пустые строки и строки комментариев в неизменном виде.</p></li></ul></div><p> Скрипт <code class="filename">reformat_dat_file.pl</code> рекомендуется запускать перед сохранением изменений в данных каталога. Им удобно пользоваться, просто выполняя <code class="literal">make reformat-dat-files</code> в <code class="filename">src/include/catalog/</code>.</p></li><li class="listitem"><p>Если вы хотите добавить новый метод уменьшения представления данных, вы должны реализовать его в <code class="filename">reformat_dat_file.pl</code> и также научить <code class="function">Catalog::ParseData()</code> разворачивать данные в полное представление.</p></li></ul></div></div><div class="sect2" id="SYSTEM-CATALOG-OID-ASSIGNMENT"><div class="titlepage"><div><div><h3 class="title">75.2.2. Назначение OID <a href="#SYSTEM-CATALOG-OID-ASSIGNMENT" class="id_link">#</a></h3></div></div></div><p>Строке каталога, фигурирующей в исходных данных, можно вручную присвоить OID, добавив поле метаданных <code class="literal">oid =&gt; <em class="replaceable"><code>nnnn</code></em></code>. Более того, когда строке присваивается OID, для этого OID можно создать макрос C, добавив поле метаданных <code class="literal">oid_symbol =&gt; <em class="replaceable"><code>имя</code></em></code>.</p><p>Предварительно загружаемым строкам каталога должны заранее назначаться OID, если на них по OID ссылаются другие предварительно загружаемые строки. Назначать OID также требуется, если на OID нужно будет ссылаться из кода на C. В отсутствие этих условий поле метаданных <code class="literal">oid</code> можно опустить, и тогда загрузочный код назначит OID автоматически. На практике мы обычно явно назначаем OID для всех строк в определённом каталоге (даже если фактически присутствуют ссылки только на часть из них) либо не назначаем их вовсе.</p><p>Указание фактического числового значения любого OID в коде на C считается крайне нежелательным; вместо этого всегда следует использовать макрос. Прямые обращения к OID в <code class="structname">pg_proc</code> требуются достаточно часто, поэтому был создан специальный механизм, создающий необходимые макросы автоматически; см. <code class="filename">src/backend/utils/Gen_fmgrtab.pl</code>. С аналогичной целью предусмотрен (но по историческим причинам реализован по-другому) метод создания макросов для OID в <code class="structname">pg_type</code>. Как следствие, записи <code class="literal">oid_symbol</code> в этих двух каталогах добавлять не нужно. Подобным образом в <code class="structname">pg_class</code> автоматически включаются макросы для OID системных каталогов и индексов. Для остальных системных каталогов все нужные вам макросы с <code class="literal">oid_symbol</code> вы должны добавлять вручную.</p><p>Чтобы найти свободный OID для новой предварительно загружаемой строки, запустите скрипт <code class="filename">src/include/catalog/unused_oids</code>. Он выводит диапазоны неиспользуемых OID, включающие граничные значения (например, выведенная строка <code class="literal">45-900</code> означает, что OID с 45 по 900 включительно ещё не задействованы). В настоящее время для назначения вручную зарезервированы значения OID 1–9999; скрипт <code class="filename">unused_oids</code> просто просматривает заголовки каталогов и файлы <code class="filename">.dat</code> и проверяет, какие значения в них отсутствуют. Для поиска ошибок вы можете воспользоваться скриптом <code class="filename">duplicate_oids</code>. (Скрипт <code class="filename">genbki.pl</code> назначит OID всем строкам, которым он не был назначен вручную, и также выявит дублирующиеся OID во время компиляции.)</p><p>Выбирая значения OID для разрабатываемой модификации кода, которая скорее всего не будет принята сразу, рекомендуется использовать группу более-менее последовательных OID, начиная с некоторого случайного числа в диапазоне 8000—9999. Это уменьшит риск конфликтов OID с другими параллельными разработками. Чтобы сохранить диапазон 8000—9999 для использования в процессе разработки после того, как модификация кода вносится в основной репозиторий git, привнесённые с ней новые значения OID должны быть перенумерованы и заменены свободными номерами ниже этого диапазона. Обычно это будет происходить в конце каждого цикла разработки; таким образом, разом перенумеруются все OID, появившиеся в коде в течение завершающегося цикла. Для этого может применяться скрипт <code class="filename">renumber_oids.pl</code>. Этот скрипт также может быть полезен, если окажется, что некоторая ещё разрабатываемая модификация конфликтует с недавно внесёнными изменениями.</p><p>Из этого положения о возможной перенумерации значений OID, вносимых модификациями, следует, что выбранные в них изначально значения OID не должны считаться стабильными, пока эта модификация не будет включена в официальный выпуск. После выпуска мы не будем менять вручную назначенные OID объектов, так как это может повлечь самые разные проблемы совместимости.</p><p>Если скрипту <code class="filename">genbki.pl</code> требуется назначить OID элементу каталога, для которого OID не назначен вручную, он выбирает значение в диапазоне 10000—11999. Счётчик OID сервера получает значение 10000 на стадии начальной инициализации. Поэтому все объекты, создаваемые в ходе начальной инициализации, также получают OID в данном диапазоне. (Обычный механизм назначения OID позаботится о предотвращении конфликтов).</p><p>Объекты с OID ниже <code class="symbol">FirstUnpinnedObjectId</code> (12000) считаются <span class="quote">«<span class="quote">закреплёнными</span>»</span>, то есть они не могут быть удалены. (Существует небольшое количество исключений, жёстко заданных в <code class="function">IsPinnedObject()</code>.) Когда <span class="application">initdb</span> доходит до фазы создания незакреплённых объектов, значение счётчика OID увеличивается до <code class="symbol">FirstUnpinnedObjectId</code>. Таким образом, объекты, созданные на более поздних этапах <span class="application">initdb</span>, например объекты, созданные при выполнении сценария <code class="filename">information_schema.sql</code>, не будут закреплёнными, а все объекты, известные <code class="filename">genbki.pl</code>, будут.</p><p>В процессе обычной работы сервер назначает OID от 16384 и выше. Тем самым гарантируется, что диапазон 10000—16383 свободен для значений OID, назначаемых автоматически скриптом <code class="filename">genbki.pl</code> или во время работы <span class="application">initdb</span>. Эти автоматически назначаемые OID не считаются стабильными и могут меняться от одного кластера к другому.</p></div><div class="sect2" id="SYSTEM-CATALOG-OID-REFERENCES"><div class="titlepage"><div><div><h3 class="title">75.2.3. Поиск OID по ссылке <a href="#SYSTEM-CATALOG-OID-REFERENCES" class="id_link">#</a></h3></div></div></div><p>Вообще говоря, из одной строки исходного каталога можно сослаться на другую, просто указав предопределённый OID целевой строки в поле ссылки. Однако политика проекта не приветствует такой подход, так как он провоцирует ошибки, а подобные ссылки сложны для восприятия и могут нарушиться при перенумерации OID. Поэтому в <code class="filename">genbki.pl</code> реализованы механизмы записи символических ссылок, работающие по следующим правилам:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Для использования символических ссылок в некотором столбце каталога требуется добавить указание <code class="literal">BKI_LOOKUP(<em class="replaceable"><code>правило_поиска</code></em>)</code> в определение этого столбца, где <em class="replaceable"><code>правило_поиска</code></em> ­­­­­­— имя целевого каталога, например <code class="literal">pg_proc</code>. Указание <code class="literal">BKI_LOOKUP</code> может быть добавлено к столбцам типа <code class="type">Oid</code>, <code class="type">regproc</code>, <code class="type">oidvector</code> или <code class="type">Oid[]</code>; в последних двух случаях поиск будет выполняться для каждого элемента массива.</p></li><li class="listitem"><p>Также допускается указание <code class="literal">BKI_LOOKUP(encoding)</code> для целочисленных столбцов, позволяющее обращаться к кодировкам символов (в настоящее время кодировкам не соответствуют OID в каталоге, но скрипту <code class="filename">genbki.pl</code> известен их набор).</p></li><li class="listitem"><p>Для некоторых столбцов каталога в качестве значений могут допускаться не только корректные ссылки, но и нули. Для таких столбцов вместо <code class="literal">BKI_LOOKUP</code> укажите <code class="literal">BKI_LOOKUP_OPT</code>. Это позволит задать <code class="literal">0</code> в качестве значения столбца. (Если столбец объявлен как <code class="type">regproc</code>, вы можете написать <code class="literal">-</code> вместо <code class="literal">0</code>.) За исключением этого особого случая, все записи в столбце <code class="literal">BKI_LOOKUP</code> должны содержать символьные ссылки. <code class="filename">genbki.pl</code> предупредит о нераспознанных именах.</p></li><li class="listitem"><p>Большинство типов объектов каталога представляются просто своими именами. Заметьте, что имена типов должны в точности соответствовать полям <code class="structfield">typname</code> в записях <code class="structname">pg_type</code>; псевдонимы типов использовать нельзя, например, нельзя написать <code class="literal">integer</code> вместо <code class="literal">int4</code>.</p></li><li class="listitem"><p>Функция может быть представлена своим значением <code class="structfield">proname</code>, если оно уникально среди записей <code class="filename">pg_proc.dat</code> (это работает как ввод значения типа regproc). В противном случае её нужно представить как <em class="replaceable"><code>proname(имя_типа_аргумента,имя_типа_аргумента,...)</code></em>, как в regprocedure. Имена типов аргументов должны записываться в точности так, как они фигурируют в поле <code class="structfield">proargtypes</code> в <code class="filename">pg_proc.dat</code>. Не добавляйте в эту строку пробелы.</p></li><li class="listitem"><p>Операторы представляются в виде <em class="replaceable"><code>oprname(левый_тип,правый_тип)</code></em>, при этом имена типов записываются в точности так, как они фигурируют в полях <code class="structfield">oprleft</code> и <code class="structfield">oprright</code> в <code class="filename">pg_operator.dat</code>. (Вместо опущенного операнда унарного оператора записывается <code class="literal">0</code>.)</p></li><li class="listitem"><p>Имена классов операторов и семейств операторов уникальны только в рамках определённого метода доступа, так что они представляются в виде <em class="replaceable"><code>имя_метода_доступа</code></em><code class="literal">/</code><em class="replaceable"><code>имя_объекта</code></em>.</p></li><li class="listitem"><p>Ни в одном из этих случаев не поддерживается указание схемы; все объекты, создаваемые на стадии начальной загрузки, будут принадлежать схеме <code class="literal">pg_catalog</code>.</p></li></ul></div><p>Скрипт <code class="filename">genbki.pl</code> разрешает все символические ссылки при запуске и помещает в формируемый файл BKI обычные числовые OID. Таким образом, при начальной загрузке отпадает необходимость в разрешении имён.</p><p>Желательно добавить в определение столбцов с OID макрос <code class="literal">BKI_LOOKUP</code> или <code class="literal">BKI_LOOKUP_OPT</code>, даже если в каталоге нет исходных данных, требующих поиска для распознавания. Благодаря этому, <code class="filename">genbki.pl</code> сохранит существующую в системных каталогах связь по внешнему ключу. Эта информация используется в регрессионных тестах для выявления некорректных записей. Также обратите внимание на макросы <code class="literal">DECLARE_FOREIGN_KEY</code>, <code class="literal">DECLARE_FOREIGN_KEY_OPT</code>, <code class="literal">DECLARE_ARRAY_FOREIGN_KEY</code> и <code class="literal">DECLARE_ARRAY_FOREIGN_KEY_OPT</code>, позволяющие обозначить связи по внешним ключам, которые слишком сложны для <code class="literal">BKI_LOOKUP</code> (обычно внешние ключи со связями по нескольким столбцам).</p></div><div class="sect2" id="SYSTEM-CATALOG-AUTO-ARRAY-TYPES"><div class="titlepage"><div><div><h3 class="title">75.2.4. Автоматическое создание типов массивов <a href="#SYSTEM-CATALOG-AUTO-ARRAY-TYPES" class="id_link">#</a></h3></div></div></div><p>Для большинства скалярных типов данных должны создаваться соответствующие типы массивов (то есть стандартный тип массива переменной длины с элементами скалярного типа, ссылка на который содержится в поле <code class="structfield">typarray</code> скалярного типа <code class="structname">pg_type</code>). Как правило, скрипт <code class="filename">genbki.pl</code> может создать запись в <code class="structname">pg_type</code> для типа массива автоматически.</p><p>Для использования этой возможности достаточно записать <code class="literal">array_type_oid =&gt; <em class="replaceable"><code>nnnn</code></em></code> в поле метаданных записи <code class="structname">pg_type</code> для скалярного типа, указав OID, который будет использоваться для типа массива. После этого поле <code class="structfield">typarray</code> можно не задавать, так как этот OID окажется в нём автоматически.</p><p>В качестве имени сгенерированного типа массива выбирается имя скалярного типа с добавленным спереди подчёркиванием. Другие поля в записи массива заполняются из определений <code class="literal">BKI_ARRAY_DEFAULT(<em class="replaceable"><code>значение</code></em>)</code> в <code class="filename">pg_type.h</code> или, если соответствующего определения нет, копируются из скалярного типа. (Поле <code class="structfield">typalign</code> заполняется особым образом.) Затем в полях <code class="structfield">typelem</code> и <code class="structfield">typarray</code> двух записей устанавливаются перекрёстные ссылки друг на друга.</p></div><div class="sect2" id="SYSTEM-CATALOG-RECIPES"><div class="titlepage"><div><div><h3 class="title">75.2.5. Рецепты по редактированию файлов данных <a href="#SYSTEM-CATALOG-RECIPES" class="id_link">#</a></h3></div></div></div><p>Ниже приведены некоторые предложения по оптимальному решению некоторых распространённых задач при изменении файлов каталогов.</p><p><strong>Добавление в каталог нового столбца со значением по умолчанию: </strong>Добавьте столбец в заголовочный файл с указанием <code class="literal">BKI_DEFAULT(<em class="replaceable"><code>значение</code></em>)</code>. Файл данных потребуется редактировать, только если в каких-либо существующих строках в добавленном поле должно быть не значение по умолчанию.</p><p><strong>Указание значения по умолчанию для существующего столбца, который его не имел: </strong>Добавьте указание <code class="literal">BKI_DEFAULT</code> в заголовочный файл, а затем выполните <code class="literal">make reformat-dat-files</code> для удаления ставших избыточными записей поля.</p><p><strong>Удаление столбца, со значением по умолчанию или без: </strong>Удалите столбец из заголовочного файла, а затем выполните <code class="literal">make reformat-dat-files</code> для удаления ставших избыточными записей поля.</p><p><strong>Изменение или удаление существующего значения по умолчанию: </strong>Просто изменить заголовочный файл недостаточно, так как при этом текущие данные будут интерпретироваться некорректно. Сначала выполните <code class="literal">make expand-dat-files</code>, чтобы перезаписать в файлах данных все явно заданные значения по умолчанию, затем удалите или измените указания <code class="literal">BKI_DEFAULT</code>, и в завершение выполните <code class="literal">make reformat-dat-files</code> для повторного удаления избыточных полей.</p><p><strong>Разовая массовая модификация: </strong>Скрипт <code class="filename">reformat_dat_file.pl</code> можно скорректировать для выполнения самых разных массовых модификаций. Просмотрев в нём блочные комментарии, вы найдёте место, куда можно вставить модифицирующий код. В следующем примере мы произведём объединение двух логических полей в <code class="structname">pg_proc</code> в символьном поле: </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Добавьте новый столбец со значением по умолчанию в <code class="filename">pg_proc.h</code>: </p><pre class="programlisting">+    /* see PROKIND_ categories below */
+    char        prokind BKI_DEFAULT(f);</pre></li><li class="listitem"><p>Создайте на основе <code class="filename">reformat_dat_file.pl</code> новый скрипт, который вставит соответствующие значения «на лету»: </p><pre class="programlisting">-           # At this point we have the full row in memory as a hash
-           # and can do any operations we want. As written, it only
-           # removes default values, but this script can be adapted to
-           # do one-off bulk-editing.
+           # One-off change to migrate to prokind
+           # Default has already been filled in by now, so change to other
+           # values as appropriate
+           if ($values{proisagg} eq 't')
+           {
+               $values{prokind} = 'a';
+           }
+           elsif ($values{proiswindow} eq 't')
+           {
+               $values{prokind} = 'w';
+           }</pre></li><li class="listitem"><p>Запустите новый скрипт: </p><pre class="programlisting">$ cd src/include/catalog
$ perl  rewrite_dat_with_prokind.pl  pg_proc.dat</pre><p> После этого в файле <code class="filename">pg_proc.dat</code> окажутся все три столбца, <code class="structfield">prokind</code>, <code class="structfield">proisagg</code> и <code class="structfield">proiswindow</code>, хотя они будут фигурировать только в тех строках, где им присваиваются не значения по умолчанию, а любые другие значения.</p></li><li class="listitem"><p>Удалите старые столбцы из <code class="filename">pg_proc.h</code>: </p><pre class="programlisting">-    /* is it an aggregate? */
-    bool        proisagg BKI_DEFAULT(f);
-
-    /* is it a window function? */
-    bool        proiswindow BKI_DEFAULT(f);</pre></li><li class="listitem"><p>Наконец, выполните <code class="literal">make reformat-dat-files</code> для удаления ненужных старых записей из <code class="filename">pg_proc.dat</code>.</p></li></ol></div><p> Примеры кода, производящего массовые модификации, вы можете найти в скриптах <code class="filename">convert_oid2name.pl</code> и <code class="filename">remove_pg_type_oid_symbols.pl</code>, вложенных в сообщение: <a class="ulink" href="https://www.postgresql.org/message-id/CAJVSVGVX8gXnPm+Xa=DxR7kFYprcQ1tNcCT5D0O3ShfnM6jehA@mail.gmail.com" target="_top">https://www.postgresql.org/message-id/CAJVSVGVX8gXnPm+Xa=DxR7kFYprcQ1tNcCT5D0O3ShfnM6jehA@mail.gmail.com</a></p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="system-catalog-declarations.html" title="75.1. Правила объявления системных каталогов">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="bki.html" title="Глава 75. Объявление и начальное содержимое системных каталогов">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="bki-format.html" title="75.3. Формат файла BKI">След.</a></td></tr><tr><td width="40%" align="left" valign="top">75.1. Правила объявления системных каталогов </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 75.3. Формат файла <acronym class="acronym">BKI</acronym></td></tr></table></div></body></html>