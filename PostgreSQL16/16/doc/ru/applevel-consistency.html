<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>13.4. Проверки целостности данных на уровне приложения</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="explicit-locking.html" title="13.3. Явные блокировки" /><link rel="next" href="mvcc-serialization-failure-handling.html" title="13.5. Обработка сбоев сериализации" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">13.4. Проверки целостности данных на уровне приложения</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="explicit-locking.html" title="13.3. Явные блокировки">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="mvcc.html" title="Глава 13. Управление конкурентным доступом">Наверх</a></td><th width="60%" align="center">Глава 13. Управление конкурентным доступом</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="mvcc-serialization-failure-handling.html" title="13.5. Обработка сбоев сериализации">След.</a></td></tr></table><hr /></div><div class="sect1" id="APPLEVEL-CONSISTENCY"><div class="titlepage"><div><div><h2 class="title" style="clear: both">13.4. Проверки целостности данных на уровне приложения <a href="#APPLEVEL-CONSISTENCY" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="applevel-consistency.html#SERIALIZABLE-CONSISTENCY">13.4.1. Обеспечение согласованности в сериализуемых транзакциях</a></span></dt><dt><span class="sect2"><a href="applevel-consistency.html#NON-SERIALIZABLE-CONSISTENCY">13.4.2. Применение явных блокировок для обеспечения согласованности</a></span></dt></dl></div><p>Используя транзакции Read Committed, очень сложно обеспечить целостность данных с точки зрения бизнес-логики, так как представление данных смещается с каждым оператором и даже один оператор может не ограничиваться своим снимком состояния в случае конфликта записи.</p><p>Хотя транзакция Repeatable Read получает стабильное представление данных в процессе выполнения, с использованием снимков <acronym class="acronym">MVCC</acronym> для проверки целостности данных всё же связаны тонкие моменты, включая так называемые <em class="firstterm">конфликты чтения/записи</em>. Если одна транзакция записывает данные, а другая в это же время пытается их прочитать (до или после записи), она не может увидеть результат работы первой. В таком случае создаётся впечатление, что читающая транзакция выполняется первой вне зависимости от того, какая из них была начата или зафиксирована раньше. Если этим всё и ограничивается, нет никаких проблем, но если читающая транзакция также пишет данные, которые читает параллельная транзакция, получается, что теперь эта транзакция будет исполняться, как будто она запущена перед другими вышеупомянутыми. Если же транзакция, которая должна исполняться как последняя, на самом деле зафиксирована первой, в графе упорядоченных транзакций легко может возникнуть цикл. И когда он возникает, проверки целостности не будут работать правильно без дополнительных мер.</p><p>Как было сказано в <a class="xref" href="transaction-iso.html#XACT-SERIALIZABLE" title="13.2.3. Уровень изоляции Serializable">Подразделе 13.2.3</a>, сериализуемые транзакции представляют собой те же транзакции Repeatable Read, но дополненные неблокирующим механизмом отслеживания опасных условий конфликтов чтения/записи. Когда выявляется условие, приводящее к циклу в порядке транзакций, одна из этих транзакций откатывается и этот цикл таким образом разрывается.</p><div class="sect2" id="SERIALIZABLE-CONSISTENCY"><div class="titlepage"><div><div><h3 class="title">13.4.1. Обеспечение согласованности в сериализуемых транзакциях <a href="#SERIALIZABLE-CONSISTENCY" class="id_link">#</a></h3></div></div></div><p>Если для всех операций чтения и записи, нуждающихся в согласованном представлении данных, используются транзакции уровня изоляции Serializable, это обеспечивает необходимую согласованность без дополнительных усилий. Приложения из других окружений, применяющие сериализуемые транзакции для обеспечения целостности, в <span class="productname">PostgreSQL</span> в этом смысле будут <span class="quote">«<span class="quote">просто работать</span>»</span>.</p><p>Применение этого подхода избавляет программистов приложений от лишних сложностей, если приложение использует инфраструктуру, которая автоматически повторяет транзакции в случае отката из-за сбоев сериализации. Возможно, <code class="literal">serializable</code> стоит даже установить в качестве уровня изоляции по умолчанию (<code class="literal">default_transaction_isolation</code>). Также имеет смысл принять меры для предотвращения использования других уровней изоляции, непреднамеренного или с целью обойти проверки целостности, например проверять уровень изоляции в триггерах.</p><p>Рекомендации по увеличению быстродействия приведены в <a class="xref" href="transaction-iso.html#XACT-SERIALIZABLE" title="13.2.3. Уровень изоляции Serializable">Подразделе 13.2.3</a>.</p><div class="warning"><h3 class="title">Предупреждение: сериализуемые транзакции и репликация данных</h3><p>Защита целостности с применением сериализуемых транзакций пока ещё не поддерживается в режиме горячего резерва (<a class="xref" href="hot-standby.html" title="27.4. Горячий резерв">Раздел 27.4</a>) или логических реплик. Поэтому там, где применяется горячий резерв или логическая репликация, следует использовать уровень Repeatable Read и явные блокировки на главном сервере.</p></div></div><div class="sect2" id="NON-SERIALIZABLE-CONSISTENCY"><div class="titlepage"><div><div><h3 class="title">13.4.2. Применение явных блокировок для обеспечения согласованности <a href="#NON-SERIALIZABLE-CONSISTENCY" class="id_link">#</a></h3></div></div></div><p>Когда возможны несериализуемые операции записи, для обеспечения целостности строк и защиты от одновременных изменений, следует использовать <code class="command">SELECT FOR UPDATE</code>, <code class="command">SELECT FOR SHARE</code> или соответствующий оператор <code class="command">LOCK TABLE</code>. (<code class="command">SELECT FOR UPDATE</code> и <code class="command">SELECT FOR SHARE</code> защищают от параллельных изменений только возвращаемые строки, тогда как <code class="command">LOCK TABLE</code> блокирует всю таблицу.) Это следует учитывать, перенося в <span class="productname">PostgreSQL</span> приложения из других СУБД.</p><p>Мигрируя в <span class="productname">PostgreSQL</span> из других СУБД также следует учитывать, что команда <code class="command">SELECT FOR UPDATE</code> сама по себе не гарантирует, что параллельная транзакция не изменит или не удалит выбранную строку. Для получения такой гарантии в <span class="productname">PostgreSQL</span> нужно именно изменить эту строку, даже если никакие значения в ней менять не требуется. <code class="command">SELECT FOR UPDATE</code> <span class="emphasis"><em>временно блокирует</em></span> другие транзакции, не давая им получить ту же блокировку или выполнить команды <code class="command">UPDATE</code> или <code class="command">DELETE</code>, которые бы повлияли на заблокированную строку, но как только транзакция, владеющая этой блокировкой, фиксируется или откатывается, заблокированная транзакция сможет выполнить конфликтующую операцию, если только для данной строки действительно не был выполнен <code class="command">UPDATE</code>, пока транзакция владела блокировкой.</p><p>Реализация глобальной целостности с использованием несериализуемых транзакций <acronym class="acronym">MVCC</acronym> требует более вдумчивого подхода. Например, банковскому приложению может потребоваться проверить, равняется ли сумма всех расходов в одной таблице сумме приходов в другой, при том, что обе таблицы активно изменяются. Просто сравнивать результаты двух успешных последовательных команд <code class="literal">SELECT sum(...)</code> в режиме Read Committed нельзя, так как вторая команда может захватить результаты транзакций, пропущенных первой. Подсчитывая суммы в одной транзакции Repeatable Read, можно получить точную картину только для транзакций, которые были зафиксированы до начала данной, но при этом может возникнуть законный вопрос — будет ли этот результат актуален тогда, когда он будет выдан. Если транзакция Repeatable Read сама вносит какие-то изменения, прежде чем проверять равенство сумм, полезность этой проверки становится ещё более сомнительной, так как при проверке будут учитываться некоторые, но не все изменения, произошедшие после начала транзакции. В таких случаях предусмотрительный разработчик может заблокировать все таблицы, задействованные в проверке, чтобы получить картину действительности, не вызывающую сомнений. Для этого применяется блокировка <code class="literal">SHARE</code> (или более строгая), которая гарантирует, что в заблокированной таблице не будет незафиксированных изменений, за исключением тех, что внесла текущая транзакция.</p><p>Также заметьте, что, применяя явные блокировки для предотвращения параллельных операций записи, следует использовать либо режим Read Committed, либо в режиме Repeatable Read обязательно получать блокировки прежде, чем выполнять запросы. Блокировка, получаемая транзакцией Repeatable Read, гарантирует, что никакая другая транзакция, изменяющая таблицу, не выполняется, но если снимок состояния, полученный транзакцией, предшествует блокировке, он может не включать на данный момент уже зафиксированные изменения. Снимок состояния в транзакции Repeatable Read создаётся фактически на момент начала первой команды выборки или изменения данных (<code class="literal">SELECT</code>, <code class="literal">INSERT</code>, <code class="literal">UPDATE</code>, <code class="literal">DELETE</code> или <code class="literal">MERGE</code>), так что получить явные блокировки можно до того, как он будет сформирован.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="explicit-locking.html" title="13.3. Явные блокировки">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="mvcc.html" title="Глава 13. Управление конкурентным доступом">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="mvcc-serialization-failure-handling.html" title="13.5. Обработка сбоев сериализации">След.</a></td></tr><tr><td width="40%" align="left" valign="top">13.3. Явные блокировки </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 13.5. Обработка сбоев сериализации</td></tr></table></div></body></html>