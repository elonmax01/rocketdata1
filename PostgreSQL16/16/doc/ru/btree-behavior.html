<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>67.2. Поведение классов операторов B-дерева</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="btree-intro.html" title="67.1. Введение" /><link rel="next" href="btree-support-funcs.html" title="67.3. Опорные функции B-деревьев" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">67.2. Поведение классов операторов B-дерева</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="btree-intro.html" title="67.1. Введение">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="btree.html" title="Глава 67. Индексы B-деревья">Наверх</a></td><th width="60%" align="center">Глава 67. Индексы B-деревья</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="btree-support-funcs.html" title="67.3. Опорные функции B-деревьев">След.</a></td></tr></table><hr /></div><div class="sect1" id="BTREE-BEHAVIOR"><div class="titlepage"><div><div><h2 class="title" style="clear: both">67.2. Поведение классов операторов B-дерева <a href="#BTREE-BEHAVIOR" class="id_link">#</a></h2></div></div></div><p>Как показано в <a class="xref" href="xindex.html#XINDEX-BTREE-STRAT-TABLE" title="Таблица 38.3. Стратегии B-дерева">Таблице 38.3</a>, класс операторов btree должен предоставить пять операторов сравнения, <code class="literal">&lt;</code>, <code class="literal">&lt;=</code>, <code class="literal">=</code>, <code class="literal">&gt;=</code> и <code class="literal">&gt;</code>. Хотя можно было ожидать, что частью этого класса будет и оператор <code class="literal">&lt;&gt;</code>, но это не так, потому что использовать <code class="literal">&lt;&gt;</code> в предложении WHERE для поиска по индексу практически бесполезно. (Для некоторых целей планировщик условно относит оператор <code class="literal">&lt;&gt;</code> к классу операторов btree, но он находит данный оператор как отрицание оператора <code class="literal">=</code>, а не обращаясь к <code class="structname">pg_amop</code>.)</p><p>Когда несколько типов данных имеют практически одинаковую семантику сортировки, их классы операторов можно сгруппировать в семейство операторов. Это полезно тем, что позволяет планировщику делать выводы о межтиповых сравнениях. Каждый класс операторов в семействе должен содержать операторы для одного своего типа входных данных (и сопутствующие опорные функции), тогда как межтиповые операторы сравнения и опорные функции являются <span class="quote">«<span class="quote">слабо</span>»</span> связанными с семейством. В семейство рекомендуется включать полный набор межтиповых операторов, чтобы планировщик мог представить любые условия, которые он может вывести, используя транзитивность.</p><p>Семейство операторов btree должно удовлетворять нескольким базовым положениям:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Оператор <code class="literal">=</code> должен представлять отношение эквивалентности; то есть для всех отличных от NULL значений <em class="replaceable"><code>A</code></em>, <em class="replaceable"><code>B</code></em>, <em class="replaceable"><code>C</code></em> определённого типа данных: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><em class="replaceable"><code>A</code></em> <code class="literal">=</code> <em class="replaceable"><code>A</code></em> — истина (<em class="firstterm">рефлексивность</em>)</p></li><li class="listitem"><p>если <em class="replaceable"><code>A</code></em> <code class="literal">=</code> <em class="replaceable"><code>B</code></em>, то <em class="replaceable"><code>B</code></em> <code class="literal">=</code> <em class="replaceable"><code>A</code></em> (<em class="firstterm">симметрия</em>)</p></li><li class="listitem"><p>если <em class="replaceable"><code>A</code></em> <code class="literal">=</code> <em class="replaceable"><code>B</code></em> и <em class="replaceable"><code>B</code></em> <code class="literal">=</code> <em class="replaceable"><code>C</code></em>, то <em class="replaceable"><code>A</code></em> <code class="literal">=</code> <em class="replaceable"><code>C</code></em> (<em class="firstterm">транзитивность</em>)</p></li></ul></div></li><li class="listitem"><p>Оператор <code class="literal">&lt;</code> должен представлять отношение строгого упорядочивания; то есть для всех отличных от NULL значений <em class="replaceable"><code>A</code></em>, <em class="replaceable"><code>B</code></em>, <em class="replaceable"><code>C</code></em>: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><em class="replaceable"><code>A</code></em> <code class="literal">&lt;</code> <em class="replaceable"><code>A</code></em> — ложно (<em class="firstterm">антирефлексивность</em>)</p></li><li class="listitem"><p>если <em class="replaceable"><code>A</code></em> <code class="literal">&lt;</code> <em class="replaceable"><code>B</code></em> и <em class="replaceable"><code>B</code></em> <code class="literal">&lt;</code> <em class="replaceable"><code>C</code></em>, то <em class="replaceable"><code>A</code></em> <code class="literal">&lt;</code> <em class="replaceable"><code>C</code></em> (<em class="firstterm">транзитивность</em>)</p></li></ul></div></li><li class="listitem"><p>Более того, упорядочивание действует глобально; то есть для любых отличных от NULL значений <em class="replaceable"><code>A</code></em>, <em class="replaceable"><code>B</code></em>: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>истинным является ровно одно из условий: <em class="replaceable"><code>A</code></em> <code class="literal">&lt;</code> <em class="replaceable"><code>B</code></em>, <em class="replaceable"><code>A</code></em> <code class="literal">=</code> <em class="replaceable"><code>B</code></em> или <em class="replaceable"><code>B</code></em> <code class="literal">&lt;</code> <em class="replaceable"><code>A</code></em> (<em class="firstterm">трихотомия</em>)</p></li></ul></div><p> (Разумеется, определение функции, осуществляющей сравнение, вытекает из закона трихотомии.)</p></li></ul></div><p>Остальные три оператора определяются через операторы <code class="literal">=</code> и <code class="literal">&lt;</code> очевидным образом и должны работать согласованно с последними.</p><p>Для семейства операторов, поддерживающего несколько типов данных, вышеперечисленные законы должны выполняться при значениях <em class="replaceable"><code>A</code></em>, <em class="replaceable"><code>B</code></em>, <em class="replaceable"><code>C</code></em>, относящихся к любым типам из семейства. Транзитивность обеспечить сложнее всего, так как в ситуациях с разными типами она требует согласованного поведения двух или трёх различных операторов. Так например, в одном семействе операторов не смогут работать типы <code class="type">float8</code> и <code class="type">numeric</code>, по крайней мере при текущем подходе, когда значения <code class="type">numeric</code> преобразуются во <code class="type">float8</code> для сравнения с <code class="type">float8</code>. Из-за ограниченной точности типа <code class="type">float8</code> различные значения <code class="type">numeric</code> могут оказаться равными одному значению <code class="type">float8</code>, что нарушит закон транзитивности.</p><p>Ещё одно требование для семейства, рассчитанного на несколько типов данных, состоит в том, что любое неявное или двоично-совместимое приведение, которое определено между типами, включёнными в семейство операторов, не должно менять соответствующий порядок сортировки.</p><p>Должно быть достаточно понятно, почему индекс-B-дерево требует выполнения этих законов для одного типа данных: без этого упорядочивание ключей невозможно. Кроме того, для поиска в индексе по ключу другого типа данных необходимо, чтобы значения двух типов сравнивались корректно. Расширение семейства до трёх или более типов данных не является обязательным для самого механизма индекса btree, но может быть полезным для планировщика в целях оптимизации.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="btree-intro.html" title="67.1. Введение">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="btree.html" title="Глава 67. Индексы B-деревья">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="btree-support-funcs.html" title="67.3. Опорные функции B-деревьев">След.</a></td></tr><tr><td width="40%" align="left" valign="top">67.1. Введение </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 67.3. Опорные функции B-деревьев</td></tr></table></div></body></html>