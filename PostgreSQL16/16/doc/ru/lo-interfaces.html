<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>35.3. Клиентские интерфейсы</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="lo-implementation.html" title="35.2. Особенности реализации" /><link rel="next" href="lo-funcs.html" title="35.4. Серверные функции" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">35.3. Клиентские интерфейсы</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="lo-implementation.html" title="35.2. Особенности реализации">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="largeobjects.html" title="Глава 35. Большие объекты">Наверх</a></td><th width="60%" align="center">Глава 35. Большие объекты</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="lo-funcs.html" title="35.4. Серверные функции">След.</a></td></tr></table><hr /></div><div class="sect1" id="LO-INTERFACES"><div class="titlepage"><div><div><h2 class="title" style="clear: both">35.3. Клиентские интерфейсы <a href="#LO-INTERFACES" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="lo-interfaces.html#LO-CREATE">35.3.1. Создание большого объекта</a></span></dt><dt><span class="sect2"><a href="lo-interfaces.html#LO-IMPORT">35.3.2. Импорт большого объекта</a></span></dt><dt><span class="sect2"><a href="lo-interfaces.html#LO-EXPORT">35.3.3. Экспорт большого объекта</a></span></dt><dt><span class="sect2"><a href="lo-interfaces.html#LO-OPEN">35.3.4. Открытие существующего большого объекта</a></span></dt><dt><span class="sect2"><a href="lo-interfaces.html#LO-WRITE">35.3.5. Запись данных в большой объект</a></span></dt><dt><span class="sect2"><a href="lo-interfaces.html#LO-READ">35.3.6. Чтение данных из большого объекта</a></span></dt><dt><span class="sect2"><a href="lo-interfaces.html#LO-SEEK">35.3.7. Перемещение в большом объекте</a></span></dt><dt><span class="sect2"><a href="lo-interfaces.html#LO-TELL">35.3.8. Получение текущего положения в большом объекте</a></span></dt><dt><span class="sect2"><a href="lo-interfaces.html#LO-TRUNCATE">35.3.9. Усечение большого объекта</a></span></dt><dt><span class="sect2"><a href="lo-interfaces.html#LO-CLOSE">35.3.10. Закрытие дескриптора большого объекта</a></span></dt><dt><span class="sect2"><a href="lo-interfaces.html#LO-UNLINK">35.3.11. Удаление большого объекта</a></span></dt></dl></div><p>В этом разделе описываются средства, которые предоставляет клиентская библиотека <span class="productname">PostgreSQL</span> <span class="application">libpq</span> для обращения к большим объектам. Интерфейс работы с большими объектами <span class="productname">PostgreSQL</span> создан по подобию интерфейса файловых систем <acronym class="acronym">Unix</acronym>, так что он включает аналоги функций <code class="function">open</code>, <code class="function">read</code>, <code class="function">write</code>, <code class="function">lseek</code> и т. д.</p><p>Все операции с большими объектами с применением этих функций <span class="emphasis"><em>должны</em></span> иметь место в блоке транзакции SQL, так как дескрипторы больших объектов актуальны только во время транзакции. Операции записи, в том числе <code class="function">lo_open</code> в режиме <code class="symbol">INV_WRITE</code>, не допускаются в читающих транзакциях.</p><p>Если при выполнении одной из этих функций происходит ошибка, эта функция возвращает значение, иначе невозможное, обычно 0 или -1. Сообщение, описывающее ошибку, сохраняется в объекте соединения; получить его можно с помощью <a class="xref" href="libpq-status.html#LIBPQ-PQERRORMESSAGE"><code class="function">PQerrorMessage</code></a>.</p><p>Клиентские приложения, которые используют эти функции, должны включать заголовочный файл <code class="filename">libpq/libpq-fs.h</code> и компоноваться с библиотекой <span class="application">libpq</span>.</p><p>Клиентские приложения не могут использовать эти функции, когда соединение libpq находится в конвейерном режиме.</p><div class="sect2" id="LO-CREATE"><div class="titlepage"><div><div><h3 class="title">35.3.1. Создание большого объекта <a href="#LO-CREATE" class="id_link">#</a></h3></div></div></div><p><a id="id-1.7.4.8.7.2.1" class="indexterm"></a> Функция </p><pre class="synopsis">
Oid lo_create(PGconn *conn, Oid lobjId);
</pre><p> создаёт новый большой объект. В <em class="replaceable"><code>lobjId</code></em> можно задать назначаемый ему OID; при этом произойдёт ошибка, если этот OID уже присвоен какому-либо большому объекту. Если в <em class="replaceable"><code>lobjId</code></em> передаётся <code class="symbol">InvalidOid</code> (ноль), <code class="function">lo_create</code> присваивает большому объекту свободный OID. Возвращаемым значением будет OID, назначенный новому большому объекту, либо <code class="symbol">InvalidOid</code> (ноль) в случае ошибки.</p><p>Пример: </p><pre class="programlisting">inv_oid = lo_create(conn, desired_oid);</pre><p><a id="id-1.7.4.8.7.4.1" class="indexterm"></a> Старая функция </p><pre class="synopsis">
Oid lo_creat(PGconn *conn, int mode);
</pre><p> также создаёт новый большой объект, всегда присваивая ему неиспользуемый OID. Возвращаемое значение — это OID, присвоенный новому большому объекту, или <code class="symbol">InvalidOid</code> (ноль) в случае ошибки.</p><p>В <span class="productname">PostgreSQL</span> версии 8.1 и выше <em class="replaceable"><code>режим</code></em> игнорируется, так что вызов <code class="function">lo_creat</code> полностью равнозначен вызову <code class="function">lo_create</code> с нулевым вторым аргументом. Однако едва ли стоит использовать <code class="function">lo_creat</code>, если вам не нужно работать с серверами версии ниже 8.1. Чтобы работать с таким старым сервером, вы должны использовать <code class="function">lo_creat</code>, а не <code class="function">lo_create</code>, и передать в аргументе <em class="replaceable"><code>режим</code></em> значение <code class="symbol">INV_READ</code>, <code class="symbol">INV_WRITE</code> или <code class="symbol">INV_READ</code> <code class="literal">|</code> <code class="symbol">INV_WRITE</code>. (Эти символические константы определены в заголовочном файле <code class="filename">libpq/libpq-fs.h</code>.)</p><p>Пример: </p><pre class="programlisting">inv_oid = lo_creat(conn, INV_READ|INV_WRITE);</pre></div><div class="sect2" id="LO-IMPORT"><div class="titlepage"><div><div><h3 class="title">35.3.2. Импорт большого объекта <a href="#LO-IMPORT" class="id_link">#</a></h3></div></div></div><p><a id="id-1.7.4.8.8.2.1" class="indexterm"></a> Чтобы импортировать в качестве большого объекта файл операционной системы, вызовите </p><pre class="synopsis">
Oid lo_import(PGconn *conn, const char *filename);
</pre><p> В <em class="replaceable"><code>filename</code></em> задаётся имя файла в операционной системе, который будет импортирован как большой объект. Возвращаемым значением будет OID, назначенный новому большому объекту, либо <code class="symbol">InvalidOid</code> (ноль) в случае ошибки. Заметьте, что этот файл читает библиотека клиентского интерфейса, а не сервер; таким образом, он должен существовать в файловой системе на стороне клиента и быть доступным для чтения клиентскому приложению.</p><p><a id="id-1.7.4.8.8.3.1" class="indexterm"></a> Функция </p><pre class="synopsis">
Oid lo_import_with_oid(PGconn *conn, const char *filename, Oid lobjId);
</pre><p> также импортирует новый большой объект. В <em class="replaceable"><code>lobjId</code></em> можно задать назначаемый ему OID; при этом произойдёт ошибка, если этот OID уже присвоен какому-либо большому объекту. Если в <em class="replaceable"><code>lobjId</code></em> передаётся <code class="symbol">InvalidOid</code> (ноль), <code class="function">lo_import_with_oid</code> присваивает большому объекту свободный OID (так же, как и <code class="function">lo_import</code>). Возвращаемым значением будет OID, назначенный новому большому объекту, либо <code class="symbol">InvalidOid</code> (ноль) в случае ошибки.</p><p>Функция <code class="function">lo_import_with_oid</code> появилась в <span class="productname">PostgreSQL</span> 8.4 и вызывает внутри <code class="function">lo_create</code>, появившуюся в 8.1; если попытаться выполнить её с сервером версии 8.0 или ранней, она завершится ошибкой и возвратит <code class="symbol">InvalidOid</code>.</p></div><div class="sect2" id="LO-EXPORT"><div class="titlepage"><div><div><h3 class="title">35.3.3. Экспорт большого объекта <a href="#LO-EXPORT" class="id_link">#</a></h3></div></div></div><p><a id="id-1.7.4.8.9.2.1" class="indexterm"></a> Чтобы экспортировать большой объект в файл операционной системы, вызовите </p><pre class="synopsis">
int lo_export(PGconn *conn, Oid lobjId, const char *filename);
</pre><p> В аргументе <em class="parameter"><code>lobjId</code></em> задаётся OID экспортируемого большого объекта, а в аргументе <em class="parameter"><code>filename</code></em> задаётся имя файла в операционной системе. Заметьте, что файл записывается библиотекой клиентского интерфейса, а не сервером. Возвращает 1 при успешном выполнении, -1 при ошибке.</p></div><div class="sect2" id="LO-OPEN"><div class="titlepage"><div><div><h3 class="title">35.3.4. Открытие существующего большого объекта <a href="#LO-OPEN" class="id_link">#</a></h3></div></div></div><p><a id="id-1.7.4.8.10.2.1" class="indexterm"></a> Чтобы открыть существующий большой объект для чтения или записи, вызовите </p><pre class="synopsis">
int lo_open(PGconn *conn, Oid lobjId, int mode);
</pre><p> В аргументе <em class="parameter"><code>lobjId</code></em> задаётся OID открываемого большого объекта. Биты в аргументе <em class="parameter"><code>mode</code></em> определяют, открывается ли файл для чтения (<code class="symbol">INV_READ</code>), для записи (<code class="symbol">INV_WRITE</code>), либо для чтения/записи. (Эти константы определяются в заголовочном файле <code class="filename">libpq/libpq-fs.h</code>.) Функция <code class="function">lo_open</code> возвращает дескриптор большого объекта (неотрицательный) для последующего использования в функциях <code class="function">lo_read</code>, <code class="function">lo_write</code>, <code class="function">lo_lseek</code>, <code class="function">lo_lseek64</code>, <code class="function">lo_tell</code>, <code class="function">lo_tell64</code>, <code class="function">lo_truncate</code>, <code class="function">lo_truncate64</code> и <code class="function">lo_close</code>. Этот дескриптор актуален только до завершения текущей транзакции. В случае ошибки возвращается -1.</p><p>В настоящее время сервер не различает режимы <code class="symbol">INV_WRITE</code> и <code class="symbol">INV_READ</code> <code class="literal">|</code> <code class="symbol">INV_WRITE</code>: с таким дескриптором можно читать данные в любом случае. Однако есть значительное отличие этих режимов от одиночного <code class="symbol">INV_READ</code>: с дескриптором <code class="symbol">INV_READ</code> записывать данные нельзя, а данные, считываемые через него, будут отражать содержимое большого объекта в снимке транзакции, который был активен при выполнении <code class="function">lo_open</code>, то есть не будут включать изменения, произведённые позже этой или другими транзакциями. При чтении с дескриптором <code class="symbol">INV_WRITE</code> возвращаются данные, отражающие все изменения, произведённые другими зафиксированными транзакциями, а также текущей транзакцией. Это подобно различиям режимов <code class="literal">REPEATABLE READ</code> и <code class="literal">READ COMMITTED</code> для обычных команд SQL <code class="command">SELECT</code>.</p><p>Функция <code class="function">lo_open</code> завершится ошибкой, если пользователь не имеет права <code class="literal">SELECT</code> для данного большого объекта или если указан флаг <code class="symbol">INV_WRITE</code> и отсутствует право <code class="literal">UPDATE</code>. (До <span class="productname">PostgreSQL</span> 11 права проверялись при первом фактическом вызове функции чтения или записи с этим дескриптором.) Отключить новые проверки можно с помощью параметра времени выполнения <a class="xref" href="runtime-config-compatible.html#GUC-LO-COMPAT-PRIVILEGES">lo_compat_privileges</a>.</p><p>Пример: </p><pre class="programlisting">inv_fd = lo_open(conn, inv_oid, INV_READ|INV_WRITE);</pre></div><div class="sect2" id="LO-WRITE"><div class="titlepage"><div><div><h3 class="title">35.3.5. Запись данных в большой объект <a href="#LO-WRITE" class="id_link">#</a></h3></div></div></div><p><a id="id-1.7.4.8.11.2.1" class="indexterm"></a> Функция </p><pre class="synopsis">
int lo_write(PGconn *conn, int fd, const char *buf, size_t len);
</pre><p> записывает <em class="parameter"><code>len</code></em> байт из буфера <em class="parameter"><code>buf</code></em> (который должен иметь размер <em class="parameter"><code>len</code></em>) в дескриптор большого объекта <em class="parameter"><code>fd</code></em>. В <em class="parameter"><code>fd</code></em> должно передаваться значение, возвращённое предыдущим вызовом <code class="function">lo_open</code>. Возвращает эта функция число фактически записанных байт (в текущей реализации это всегда <em class="parameter"><code>len</code></em>, если только не произошла ошибка). В случае ошибки возвращается значение -1.</p><p>Хотя параметр <em class="parameter"><code>len</code></em> объявлен как <code class="type">size_t</code>, эта функция не принимает значение длины, превышающее <code class="literal">INT_MAX</code>. На практике всё равно лучше передавать данные фрагментами не больше нескольких мегабайт.</p></div><div class="sect2" id="LO-READ"><div class="titlepage"><div><div><h3 class="title">35.3.6. Чтение данных из большого объекта <a href="#LO-READ" class="id_link">#</a></h3></div></div></div><p><a id="id-1.7.4.8.12.2.1" class="indexterm"></a> Функция </p><pre class="synopsis">
int lo_read(PGconn *conn, int fd, char *buf, size_t len);
</pre><p> читает до <em class="parameter"><code>len</code></em> байт из дескриптора большого объекта <em class="parameter"><code>fd</code></em> в буфер <em class="parameter"><code>buf</code></em> (который должен иметь размер <em class="parameter"><code>len</code></em>). В <em class="parameter"><code>fd</code></em> должно передаваться значение, возвращённое предыдущим вызовом <code class="function">lo_open</code>. Возвращает эта функция число фактически прочитанных байт; это число должно быть меньше <em class="parameter"><code>len</code></em>, если при чтении был достигнут конец объекта. В случае ошибки возвращается -1.</p><p>Хотя параметр <em class="parameter"><code>len</code></em> объявлен как <code class="type">size_t</code>, эта функция не принимает значение длины, превышающее <code class="literal">INT_MAX</code>. На практике всё равно лучше передавать данные фрагментами не больше нескольких мегабайт.</p></div><div class="sect2" id="LO-SEEK"><div class="titlepage"><div><div><h3 class="title">35.3.7. Перемещение в большом объекте <a href="#LO-SEEK" class="id_link">#</a></h3></div></div></div><p><a id="id-1.7.4.8.13.2.1" class="indexterm"></a> Чтобы изменить текущее положение чтения или записи, связанное с дескриптором большого объекта, вызовите </p><pre class="synopsis">
int lo_lseek(PGconn *conn, int fd, int offset, int whence);
</pre><p> Эта функция перемещает указатель текущего положения для дескриптора большого объекта <em class="parameter"><code>fd</code></em> в новое положение, заданное аргументом <em class="parameter"><code>offset</code></em>. Для аргумента <em class="parameter"><code>whence</code></em> задаются значения <code class="symbol">SEEK_SET</code> (перемещение от начала объекта), <code class="symbol">SEEK_CUR</code> (перемещение от текущего положения) и <code class="symbol">SEEK_END</code> (перемещение от конца объекта). Возвращает эта функция новое положение указателя, либо -1 в случае ошибки.</p><p><a id="id-1.7.4.8.13.3.1" class="indexterm"></a> Оперируя с большими объектами, размер которых превышает 2 ГБ, используйте </p><pre class="synopsis">
pg_int64 lo_lseek64(PGconn *conn, int fd, pg_int64 offset, int whence);
</pre><p> Эта функция действует так же, как и <code class="function">lo_lseek</code>, но может принять значение <em class="parameter"><code>offset</code></em>, превышающее 2 ГБ, и/или вернуть результат, превышающий 2 ГБ. Заметьте, что если новое положение указателя оказывается за границей в 2ГБ, функция <code class="function">lo_lseek</code> выдаёт ошибку.</p><p>Функция <code class="function">lo_lseek64</code> появилась в <span class="productname">PostgreSQL</span> 9.3. Если попытаться выполнить её с сервером более старой версии, произойдёт ошибка и будет возвращено -1.</p></div><div class="sect2" id="LO-TELL"><div class="titlepage"><div><div><h3 class="title">35.3.8. Получение текущего положения в большом объекте <a href="#LO-TELL" class="id_link">#</a></h3></div></div></div><p><a id="id-1.7.4.8.14.2.1" class="indexterm"></a> Чтобы получить текущее положение чтения или записи для дескриптора большого объекта, вызовите </p><pre class="synopsis">
int lo_tell(PGconn *conn, int fd);
</pre><p> Если возникает ошибка, возвращается -1.</p><p><a id="id-1.7.4.8.14.3.1" class="indexterm"></a> Оперируя с большими объектами, размер которых может превышать 2 ГБ, используйте </p><pre class="synopsis">
pg_int64 lo_tell64(PGconn *conn, int fd);
</pre><p> Эта функция действует так же, как <code class="function">lo_tell</code>, но может выдавать результат, превышающий 2 ГБ. Заметьте, что <code class="function">lo_tell</code> выдаёт ошибку, если текущее положение чтения/записи оказывается за границей в 2 ГБ.</p><p>Функция <code class="function">lo_tell64</code> появилась в <span class="productname">PostgreSQL</span> 9.3. Если попытаться выполнить её с сервером более старой версии, произойдёт ошибка и будет возвращено -1.</p></div><div class="sect2" id="LO-TRUNCATE"><div class="titlepage"><div><div><h3 class="title">35.3.9. Усечение большого объекта <a href="#LO-TRUNCATE" class="id_link">#</a></h3></div></div></div><p><a id="id-1.7.4.8.15.2.1" class="indexterm"></a> Чтобы усечь большой объект до требуемой длины, вызовите </p><pre class="synopsis">
int lo_truncate(PGconn *conn, int fd, size_t len);
</pre><p> Эта функция усекает большой объект с дескриптором <em class="parameter"><code>fd</code></em> до длины <em class="parameter"><code>len</code></em>. В <em class="parameter"><code>fd</code></em> должно передаваться значение, возвращённое предыдущим вызовом <code class="function">lo_open</code>. Если <em class="parameter"><code>len</code></em> превышает текущую длину большого объекта, большой объект расширяется до заданной длины нулевыми байтами ('\0'). В случае успеха <code class="function">lo_truncate</code> возвращает ноль, а при ошибке возвращается -1.</p><p>Положение чтения/записи, связанное с дескриптором <em class="parameter"><code>fd</code></em>, при этом не меняется.</p><p>Хотя параметр <em class="parameter"><code>len</code></em> объявлен как <code class="type">size_t</code>, <code class="function">lo_truncate</code> не принимает значение длины, превышающее <code class="literal">INT_MAX</code>.</p><p><a id="id-1.7.4.8.15.5.1" class="indexterm"></a> Оперируя с большими объектами, размер которых может превышать 2 ГБ, используйте </p><pre class="synopsis">
int lo_truncate64(PGconn *conn, int fd, pg_int64 len);
</pre><p> Эта функция действует так же, как <code class="function">lo_truncate</code>, но может принимать значения <em class="parameter"><code>len</code></em>, превышающие 2 ГБ.</p><p>Функция <code class="function">lo_truncate</code> появилась в <span class="productname">PostgreSQL</span> 8.3; если попытаться выполнить её с сервером более старой версии, произойдёт ошибка и будет возвращено -1.</p><p>Функция <code class="function">lo_truncate64</code> появилась в <span class="productname">PostgreSQL</span> 9.3; если попытаться выполнить её с сервером более старой версии, произойдёт ошибка и будет возвращено -1.</p></div><div class="sect2" id="LO-CLOSE"><div class="titlepage"><div><div><h3 class="title">35.3.10. Закрытие дескриптора большого объекта <a href="#LO-CLOSE" class="id_link">#</a></h3></div></div></div><p><a id="id-1.7.4.8.16.2.1" class="indexterm"></a> Дескриптор большого объекта можно закрыть, вызвав </p><pre class="synopsis">
int lo_close(PGconn *conn, int fd);
</pre><p> Здесь <em class="parameter"><code>fd</code></em> — дескриптор большого объекта, возвращённый функцией <code class="function">lo_open</code>. В случае успеха <code class="function">lo_close</code> возвращает ноль. При ошибке возвращается -1.</p><p>Все дескрипторы больших объектов, остающиеся открытыми в конце транзакции, закрываются автоматически.</p></div><div class="sect2" id="LO-UNLINK"><div class="titlepage"><div><div><h3 class="title">35.3.11. Удаление большого объекта <a href="#LO-UNLINK" class="id_link">#</a></h3></div></div></div><p><a id="id-1.7.4.8.17.2.1" class="indexterm"></a> Чтобы удалить большой объект из базы данных, вызовите </p><pre class="synopsis">
int lo_unlink(PGconn *conn, Oid lobjId);
</pre><p> В аргументе <em class="parameter"><code>lobjId</code></em> задаётся OID большого объекта, который нужно удалить. В случае успеха возвращается 1, а в случае ошибки -1.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="lo-implementation.html" title="35.2. Особенности реализации">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="largeobjects.html" title="Глава 35. Большие объекты">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="lo-funcs.html" title="35.4. Серверные функции">След.</a></td></tr><tr><td width="40%" align="left" valign="top">35.2. Особенности реализации </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 35.4. Серверные функции</td></tr></table></div></body></html>