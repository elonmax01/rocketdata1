<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>28.4. Отслеживание выполнения</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="monitoring-locks.html" title="28.3. Просмотр информации о блокировках" /><link rel="next" href="dynamic-trace.html" title="28.5. Динамическая трассировка" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">28.4. Отслеживание выполнения</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="monitoring-locks.html" title="28.3. Просмотр информации о блокировках">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="monitoring.html" title="Глава 28. Мониторинг работы СУБД">Наверх</a></td><th width="60%" align="center">Глава 28. Мониторинг работы СУБД</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="dynamic-trace.html" title="28.5. Динамическая трассировка">След.</a></td></tr></table><hr /></div><div class="sect1" id="PROGRESS-REPORTING"><div class="titlepage"><div><div><h2 class="title" style="clear: both">28.4. Отслеживание выполнения <a href="#PROGRESS-REPORTING" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="progress-reporting.html#ANALYZE-PROGRESS-REPORTING">28.4.1. Отслеживание выполнения ANALYZE</a></span></dt><dt><span class="sect2"><a href="progress-reporting.html#CLUSTER-PROGRESS-REPORTING">28.4.2. Отслеживание выполнения CLUSTER</a></span></dt><dt><span class="sect2"><a href="progress-reporting.html#COPY-PROGRESS-REPORTING">28.4.3. Отслеживание выполнения COPY</a></span></dt><dt><span class="sect2"><a href="progress-reporting.html#CREATE-INDEX-PROGRESS-REPORTING">28.4.4. Отслеживание выполнения CREATE INDEX</a></span></dt><dt><span class="sect2"><a href="progress-reporting.html#VACUUM-PROGRESS-REPORTING">28.4.5. Отслеживание выполнения VACUUM</a></span></dt><dt><span class="sect2"><a href="progress-reporting.html#BASEBACKUP-PROGRESS-REPORTING">28.4.6. Отслеживание выполнение базового копирования</a></span></dt></dl></div><p>В <span class="productname">PostgreSQL</span> имеется возможность отслеживать выполнение определённых команд. В настоящее время такое отслеживание поддерживается только для команд <code class="command">ANALYZE</code>, <code class="command">CLUSTER</code>, <code class="command">CREATE INDEX</code>, <code class="command">VACUUM</code>, <code class="command">COPY</code> и <a class="xref" href="protocol-replication.html#PROTOCOL-REPLICATION-BASE-BACKUP">BASE_BACKUP</a> (то есть для команды репликации, которую выполняет <a class="xref" href="app-pgbasebackup.html" title="pg_basebackup"><span class="refentrytitle"><span class="application">pg_basebackup</span></span></a>). В будущем эта поддержка может быть расширена.</p><div class="sect2" id="ANALYZE-PROGRESS-REPORTING"><div class="titlepage"><div><div><h3 class="title">28.4.1. Отслеживание выполнения ANALYZE <a href="#ANALYZE-PROGRESS-REPORTING" class="id_link">#</a></h3></div></div></div><a id="id-1.6.15.9.3.2" class="indexterm"></a><p>Во время выполнения <code class="command">ANALYZE</code> представление <code class="structname">pg_stat_progress_analyze</code> будет содержать по одной строке для каждого обслуживающего процесса, выполняющего эту команду. Таблицы ниже показывают, какая информация будет отслеживаться, и поясняют, как её интерпретировать.</p><div class="table" id="PG-STAT-PROGRESS-ANALYZE-VIEW"><p class="title"><strong>Таблица 28.37. Представление <code class="structname">pg_stat_progress_analyze</code></strong></p><div class="table-contents"><table class="table" summary="Представление pg_stat_progress_analyze" border="1"><colgroup><col /></colgroup><thead><tr><th class="catalog_table_entry"><p class="column_definition">Тип столбца</p>
      <p>Описание</p></th></tr></thead><tbody><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">pid</code> <code class="type">integer</code>
      </p>
      <p>Идентификатор (PID) обслуживающего процесса</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">datid</code> <code class="type">oid</code>
      </p>
      <p>OID базы данных, к которой подключён этот обслуживающий процесс.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">datname</code> <code class="type">name</code>
      </p>
      <p>Имя базы данных, к которой подключён этот обслуживающий процесс.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">relid</code> <code class="type">oid</code>
      </p>
      <p>OID анализируемой таблицы.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">phase</code> <code class="type">text</code>
      </p>
      <p>Текущая фаза обработки. См. <a class="xref" href="progress-reporting.html#ANALYZE-PHASES" title="Таблица 28.38. Фазы ANALYZE">Таблицу 28.38</a>.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">sample_blks_total</code> <code class="type">bigint</code>
      </p>
      <p>Общее количество блоков кучи, которые попадут в выборку.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">sample_blks_scanned</code> <code class="type">bigint</code>
      </p>
      <p>Количество просканированных блоков кучи.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">ext_stats_total</code> <code class="type">bigint</code>
      </p>
      <p>Количество объектов расширенной статистики.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">ext_stats_computed</code> <code class="type">bigint</code>
      </p>
      <p>Количество вычисленных объектов расширенной статистики. Этот счётчик увеличивается только в фазе <code class="literal">computing extended statistics</code> (вычисление расширенной статистики).</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">child_tables_total</code> <code class="type">bigint</code>
      </p>
      <p>Количество дочерних таблиц.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">child_tables_done</code> <code class="type">bigint</code>
      </p>
      <p>Количество просканированных дочерних таблиц. Этот счётчик увеличивается только в фазе <code class="literal">acquiring inherited sample rows</code> (извлечение строк выборки через наследование).</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">current_child_table_relid</code> <code class="type">oid</code>
      </p>
      <p>OID дочерней таблицы, сканируемой в данный момент. Это поле содержит актуальное значение только в фазе <code class="literal">acquiring inherited sample rows</code> (извлечение строк выборки через наследование).</p></td></tr></tbody></table></div></div><br class="table-break" /><div class="table" id="ANALYZE-PHASES"><p class="title"><strong>Таблица 28.38. Фазы ANALYZE</strong></p><div class="table-contents"><table class="table" summary="Фазы ANALYZE" border="1"><colgroup><col class="col1" /><col class="col2" /></colgroup><thead><tr><th>Фаза</th><th>Описание</th></tr></thead><tbody><tr><td><code class="literal">initializing</code></td><td>Команда готовится начать сканирование кучи. Эта фаза должна быть очень быстрой.</td></tr><tr><td><code class="literal">acquiring sample rows</code></td><td>Команда сканирует таблицу с указанным <code class="structfield">relid</code>, считывая строки выборки.</td></tr><tr><td><code class="literal">acquiring inherited sample rows</code></td><td>Команда сканирует дочерние таблицы, считывая строки выборки. Выполнение процедуры в этой фазе отражается в столбцах <code class="structfield">child_tables_total</code>, <code class="structfield">child_tables_done</code> и <code class="structfield">current_child_table_relid</code>.</td></tr><tr><td><code class="literal">computing statistics</code></td><td>Команда вычисляет статистику по строкам выборки, полученным при сканировании таблицы.</td></tr><tr><td><code class="literal">computing extended statistics</code></td><td>Команда вычисляет расширенную статистику по строкам выборки, полученным при сканировании таблицы.</td></tr><tr><td><code class="literal">finalizing analyze</code></td><td>Команда вносит изменения в <code class="structname">pg_class</code>. После этой фазы <code class="command">ANALYZE</code> завершит работу.</td></tr></tbody></table></div></div><br class="table-break" /><div class="note"><h3 class="title">Примечание</h3><p>Заметьте, что когда <code class="command">ANALYZE</code> обрабатывает секционированную таблицу, все её секции также рекурсивно анализируются. В этом случае сначала сообщается о ходе выполнения <code class="command">ANALYZE</code> для родительской таблицы, которое сопровождается сбором наследуемой статистики, а затем о ходе обработки каждой её секции.</p></div></div><div class="sect2" id="CLUSTER-PROGRESS-REPORTING"><div class="titlepage"><div><div><h3 class="title">28.4.2. Отслеживание выполнения CLUSTER <a href="#CLUSTER-PROGRESS-REPORTING" class="id_link">#</a></h3></div></div></div><a id="id-1.6.15.9.4.2" class="indexterm"></a><p>Во время выполнения <code class="command">CLUSTER</code> или <code class="command">VACUUM FULL</code> представление <code class="structname">pg_stat_progress_cluster</code> будет содержать по одной строке для каждого обслуживающего процесса, выполняющего любую из этих команд. Таблицы ниже показывают, какая информация будет отслеживаться, и поясняют, как её интерпретировать.</p><div class="table" id="PG-STAT-PROGRESS-CLUSTER-VIEW"><p class="title"><strong>Таблица 28.39. Представление <code class="structname">pg_stat_progress_cluster</code></strong></p><div class="table-contents"><table class="table" summary="Представление pg_stat_progress_cluster" border="1"><colgroup><col /></colgroup><thead><tr><th class="catalog_table_entry"><p class="column_definition">Тип столбца</p>
      <p>Описание</p></th></tr></thead><tbody><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">pid</code> <code class="type">integer</code>
      </p>
      <p>Идентификатор (PID) обслуживающего процесса</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">datid</code> <code class="type">oid</code>
      </p>
      <p>OID базы данных, к которой подключён этот обслуживающий процесс.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">datname</code> <code class="type">name</code>
      </p>
      <p>Имя базы данных, к которой подключён этот обслуживающий процесс.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">relid</code> <code class="type">oid</code>
      </p>
      <p>OID обрабатываемой таблицы.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">command</code> <code class="type">text</code>
      </p>
      <p>Выполняемая команда: <code class="literal">CLUSTER</code> или <code class="literal">VACUUM FULL</code>.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">phase</code> <code class="type">text</code>
      </p>
      <p>Текущая фаза обработки. См. <a class="xref" href="progress-reporting.html#CLUSTER-PHASES" title="Таблица 28.40. Фазы CLUSTER и VACUUM FULL">Таблицу 28.40</a>.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">cluster_index_relid</code> <code class="type">oid</code>
      </p>
      <p>Если таблица сканируется по индексу, это поле содержит OID данного индекса, а иначе — 0.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">heap_tuples_scanned</code> <code class="type">bigint</code>
      </p>
      <p>Число просканированных кортежей кучи. Этот счётчик увеличивается только в фазе <code class="literal">seq scanning heap</code>, <code class="literal">index scanning heap</code> или <code class="literal">writing new heap</code>.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">heap_tuples_written</code> <code class="type">bigint</code>
      </p>
      <p>Число записанных кортежей кучи. Этот счётчик увеличивается только в фазе <code class="literal">seq scanning heap</code>, <code class="literal">index scanning heap</code> или <code class="literal">writing new heap</code>.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">heap_blks_total</code> <code class="type">bigint</code>
      </p>
      <p>Общее число блоков кучи в таблице. Это число отражает состояние в начале фазы <code class="literal">seq scanning heap</code>.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">heap_blks_scanned</code> <code class="type">bigint</code>
      </p>
      <p>Число просканированных блоков кучи. Этот счётчик увеличивается только в фазе <code class="literal">seq scanning heap</code>.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">index_rebuild_count</code> <code class="type">bigint</code>
      </p>
      <p>Число перестроенных индексов. Это счётчик увеличивается только в фазе <code class="literal">rebuilding index</code>.</p></td></tr></tbody></table></div></div><br class="table-break" /><div class="table" id="CLUSTER-PHASES"><p class="title"><strong>Таблица 28.40. Фазы CLUSTER и VACUUM FULL</strong></p><div class="table-contents"><table class="table" summary="Фазы CLUSTER и VACUUM FULL" border="1"><colgroup><col class="col1" /><col class="col2" /></colgroup><thead><tr><th>Фаза</th><th>Описание</th></tr></thead><tbody><tr><td><code class="literal">initializing</code></td><td>Команда готовится начать сканирование кучи. Эта фаза должна быть очень быстрой.</td></tr><tr><td><code class="literal">seq scanning heap</code></td><td>Команда в данный момент сканирует таблицу последовательным образом.</td></tr><tr><td><code class="literal">index scanning heap</code></td><td><code class="command">CLUSTER</code> в данный момент сканирует таблицу по индексу.</td></tr><tr><td><code class="literal">sorting tuples</code></td><td><code class="command">CLUSTER</code> в данный момент сортирует кортежи.</td></tr><tr><td><code class="literal">writing new heap</code></td><td><code class="command">CLUSTER</code> в данный момент записывает новую кучу.</td></tr><tr><td><code class="literal">swapping relation files</code></td><td>Команда в данный момент переставляет только что построенные файлы на место.</td></tr><tr><td><code class="literal">rebuilding index</code></td><td>Команда в данный момент перестраивает индекс.</td></tr><tr><td><code class="literal">performing final cleanup</code></td><td>Команда выполняет окончательную очистку. После этой фазы <code class="command">CLUSTER</code> или <code class="command">VACUUM FULL</code> завершит работу.</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect2" id="COPY-PROGRESS-REPORTING"><div class="titlepage"><div><div><h3 class="title">28.4.3. Отслеживание выполнения COPY <a href="#COPY-PROGRESS-REPORTING" class="id_link">#</a></h3></div></div></div><a id="id-1.6.15.9.5.2" class="indexterm"></a><p>Во время выполнения <code class="command">COPY</code> представление <code class="structname">pg_stat_progress_copy</code> будет содержать по одной строке для каждого обслуживающего процесса, выполняющего эту команду. Таблицы ниже показывают, какая информация будет отслеживаться, и поясняют, как её интерпретировать.</p><div class="table" id="PG-STAT-PROGRESS-COPY-VIEW"><p class="title"><strong>Таблица 28.41. Представление <code class="structname">pg_stat_progress_copy</code></strong></p><div class="table-contents"><table class="table" summary="Представление pg_stat_progress_copy" border="1"><colgroup><col /></colgroup><thead><tr><th class="catalog_table_entry"><p class="column_definition">Тип столбца</p>
      <p>Описание</p></th></tr></thead><tbody><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">pid</code> <code class="type">integer</code>
      </p>
      <p>Идентификатор (PID) обслуживающего процесса</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">datid</code> <code class="type">oid</code>
      </p>
      <p>OID базы данных, к которой подключён этот обслуживающий процесс.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">datname</code> <code class="type">name</code>
      </p>
      <p>Имя базы данных, к которой подключён этот обслуживающий процесс.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">relid</code> <code class="type">oid</code>
      </p>
      <p>OID таблицы, в которой выполняется команда <code class="command">COPY</code>. При копировании из запроса <code class="command">SELECT</code> это поле содержит <code class="literal">0</code>.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">command</code> <code class="type">text</code>
      </p>
      <p>Выполняемая команда: <code class="literal">COPY FROM</code> или <code class="literal">COPY TO</code>.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">type</code> <code class="type">text</code>
      </p>
      <p>Метод ввода/вывода, посредством которого считываются или записываются данные: <code class="literal">FILE</code>, <code class="literal">PROGRAM</code>, <code class="literal">PIPE</code> (для <code class="command">COPY FROM STDIN</code> и <code class="command">COPY TO STDOUT</code>) или <code class="literal">CALLBACK</code> (используется, например, во время начальной синхронизации таблицы при логической репликации).</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">bytes_processed</code> <code class="type">bigint</code>
      </p>
      <p>Число байт, уже обработанных командой <code class="command">COPY</code>.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">bytes_total</code> <code class="type">bigint</code>
      </p>
      <p>Размер исходного файла для команды <code class="command">COPY FROM</code> в байтах. Если определить размер нельзя, это поле содержит <code class="literal">0</code>.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">tuples_processed</code> <code class="type">bigint</code>
      </p>
      <p>Число кортежей, уже обработанных командой <code class="command">COPY</code>.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">tuples_excluded</code> <code class="type">bigint</code>
      </p>
      <p>Количество необработанных кортежей, которые были исключены предложением <code class="command">WHERE</code> команды <code class="command">COPY</code>.</p></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect2" id="CREATE-INDEX-PROGRESS-REPORTING"><div class="titlepage"><div><div><h3 class="title">28.4.4. Отслеживание выполнения CREATE INDEX <a href="#CREATE-INDEX-PROGRESS-REPORTING" class="id_link">#</a></h3></div></div></div><a id="id-1.6.15.9.6.2" class="indexterm"></a><p>Во время выполнения <code class="command">CREATE INDEX</code> или <code class="command">REINDEX</code> представление <code class="structname">pg_stat_progress_create_index</code> будет содержать по одной строке для каждого обслуживающего процесса, создающего индексы в этот момент. Таблицы ниже показывают, какая информация будет отслеживаться, и поясняют, как её интерпретировать.</p><div class="table" id="PG-STAT-PROGRESS-CREATE-INDEX-VIEW"><p class="title"><strong>Таблица 28.42. Представление <code class="structname">pg_stat_progress_create_index</code></strong></p><div class="table-contents"><table class="table" summary="Представление pg_stat_progress_create_index" border="1"><colgroup><col /></colgroup><thead><tr><th class="catalog_table_entry"><p class="column_definition">Тип столбца</p>
      <p>Описание</p></th></tr></thead><tbody><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">pid</code> <code class="type">integer</code>
      </p>
      <p>Идентификатор серверного процесса, создающего индексы.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">datid</code> <code class="type">oid</code>
      </p>
      <p>OID базы данных, к которой подключён этот обслуживающий процесс.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">datname</code> <code class="type">name</code>
      </p>
      <p>Имя базы данных, к которой подключён этот обслуживающий процесс.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">relid</code> <code class="type">oid</code>
      </p>
      <p>OID таблицы, в которой создаётся индекс.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">index_relid</code> <code class="type">oid</code>
      </p>
      <p>OID создаваемого или перестраиваемого индекса. При выполнении <code class="command">CREATE INDEX</code> в неблокирующем режиме содержит 0.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">command</code> <code class="type">text</code>
      </p>
      <p>Определённый тип команды: <code class="literal">CREATE INDEX</code>, <code class="literal">CREATE INDEX CONCURRENTLY</code>, <code class="literal">REINDEX</code> или <code class="literal">REINDEX CONCURRENTLY</code>.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">phase</code> <code class="type">text</code>
      </p>
      <p>Текущая фаза создания индекса. См. <a class="xref" href="progress-reporting.html#CREATE-INDEX-PHASES" title="Таблица 28.43. Фазы CREATE INDEX">Таблицу 28.43</a>.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">lockers_total</code> <code class="type">bigint</code>
      </p>
      <p>Общее число процессов, потребовавших ожидания, если таковые имеются.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">lockers_done</code> <code class="type">bigint</code>
      </p>
      <p>Число процессов, ожидание которых уже завершено.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">current_locker_pid</code> <code class="type">bigint</code>
      </p>
      <p>Идентификатор процесса, удерживающего конфликтующую блокировку в данный момент.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">blocks_total</code> <code class="type">bigint</code>
      </p>
      <p>Общее число блоков, которые должны быть обработаны в текущей фазе.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">blocks_done</code> <code class="type">bigint</code>
      </p>
      <p>Число блоков, уже обработанных в текущей фазе.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">tuples_total</code> <code class="type">bigint</code>
      </p>
      <p>Общее число кортежей, которые должны быть обработаны в текущей фазе.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">tuples_done</code> <code class="type">bigint</code>
      </p>
      <p>Число кортежей, уже обработанных в текущей фазе.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">partitions_total</code> <code class="type">bigint</code>
      </p>
      <p>Общее количество секций, для которых должен быть создан или прикреплён индекс, включая как прямые, так и косвенные секции. Имеет значение <code class="literal">0</code>, когда выполняется <code class="literal">REINDEX</code> или если индекс не секционирован.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">partitions_done</code> <code class="type">bigint</code>
      </p>
      <p>Количество секций, для которых уже был создан или прикреплён индекс, включая как прямые, так и косвенные секции. Имеет значение <code class="literal">0</code>, когда выполняется <code class="literal">REINDEX</code> или если индекс не секционирован.</p></td></tr></tbody></table></div></div><br class="table-break" /><div class="table" id="CREATE-INDEX-PHASES"><p class="title"><strong>Таблица 28.43. Фазы CREATE INDEX</strong></p><div class="table-contents"><table class="table" summary="Фазы CREATE INDEX" border="1"><colgroup><col class="col1" /><col class="col2" /></colgroup><thead><tr><th>Фаза</th><th>Описание</th></tr></thead><tbody><tr><td><code class="literal">initializing</code></td><td>Инициализация — процедура <code class="command">CREATE INDEX</code> или <code class="command">REINDEX</code> подготавливается к созданию индекса. Эта фаза должна быть очень быстрой.</td></tr><tr><td><code class="literal">waiting for writers before build</code></td><td>Ожидание окончания записи перед построением — процедура <code class="command">CREATE INDEX CONCURRENTLY</code> или <code class="command">REINDEX CONCURRENTLY</code> ожидает завершения транзакций, которые удерживают блокировки записи и могут читать таблицу. Эта фаза пропускается при выполнении операции в неблокирующем режиме. Выполнение процедуры в этой фазе отражается в столбцах <code class="structname">lockers_total</code>, <code class="structname">lockers_done</code> и <code class="structname">current_locker_pid</code>.</td></tr><tr><td><code class="literal">building index</code></td><td>Построение индекса — код, реализующий метод доступа, строит индекс. В этой фазе методы доступа, поддерживающие отслеживание процесса, передают свои данные о текущем состоянии, и в этом столбце видна внутренняя фаза. Обычно ход построения индекса отражается в столбцах <code class="structname">blocks_total</code> и <code class="structname">blocks_done</code>, но также могут меняться и столбцы <code class="structname">tuples_total</code> и <code class="structname">tuples_done</code>.</td></tr><tr><td><code class="literal">waiting for writers before validation</code></td><td>Ожидание окончания записи перед проверкой — процедура <code class="command">CREATE INDEX CONCURRENTLY</code> или <code class="command">REINDEX CONCURRENTLY</code> ожидает завершения транзакций, которые удерживают блокировки записи и могут записывать в таблицу. Эта фаза пропускается при выполнении операции в неблокирующем режиме. Выполнение процедуры в этой фазе отражается в столбцах <code class="structname">lockers_total</code>, <code class="structname">lockers_done</code> и <code class="structname">current_locker_pid</code>.</td></tr><tr><td><code class="literal">index validation: scanning index</code></td><td>Проверка индекса: сканирование — процедура <code class="command">CREATE INDEX CONCURRENTLY</code> сканирует индекс, находя кортежи, требующие проверки. Эта фаза пропускается при выполнении операции в неблокирующем режиме. Выполнение процедуры в этой фазе отражается в столбцах <code class="structname">blocks_total</code> (показывающем общий размер индекса) и <code class="structname">blocks_done</code>.</td></tr><tr><td><code class="literal">index validation: sorting tuples</code></td><td>Проверка индекса: сортировка кортежей — процедура <code class="command">CREATE INDEX CONCURRENTLY</code> сортирует результат фазы сканирования индекса.</td></tr><tr><td><code class="literal">index validation: scanning table</code></td><td>Проверка индекса: сканирование таблицы — процедура <code class="command">CREATE INDEX CONCURRENTLY</code> сканирует таблицу, чтобы проверить кортежи индекса, собранные в предыдущих двух фазах. Эта фаза пропускается при выполнении операции в неблокирующем режиме. Выполнение процедуры в этой фазе отражается в столбцах <code class="structname">blocks_total</code> (показывающем общий размер таблицы) и <code class="structname">blocks_done</code>.</td></tr><tr><td><code class="literal">waiting for old snapshots</code></td><td>Ожидание старых снимков — процедура <code class="command">CREATE INDEX CONCURRENTLY</code> или <code class="command">REINDEX CONCURRENTLY</code> ожидает освобождения снимков теми транзакциями, которые могут видеть содержимое таблицы. Эта фаза пропускается при выполнении операции в неблокирующем режиме. Выполнение процедуры в этой фазе отражается в столбцах <code class="structname">lockers_total</code>, <code class="structname">lockers_done</code> и <code class="structname">current_locker_pid</code>.</td></tr><tr><td><code class="literal">waiting for readers before marking dead</code></td><td>Ожидание завершения чтения перед отключением старого индекса — процедура <code class="command">REINDEX CONCURRENTLY</code> ожидает завершения транзакций, которые удерживают блокировки чтения, прежде чем пометить старый индекс как нерабочий. Эта фаза пропускается при выполнении операции в неблокирующем режиме. Выполнение процедуры в этой фазе отражается в столбцах <code class="structname">lockers_total</code>, <code class="structname">lockers_done</code> и <code class="structname">current_locker_pid</code>.</td></tr><tr><td><code class="literal">waiting for readers before dropping</code></td><td>Ожидание завершения чтения перед удалением старого индекса — процедура <code class="command">REINDEX CONCURRENTLY</code> ожидает завершения транзакций, которые удерживают блокировки чтения, прежде чем удалить старый индекс. Эта фаза пропускается при выполнении операции в неблокирующем режиме. Выполнение процедуры в этой фазе отражается в столбцах <code class="structname">lockers_total</code>, <code class="structname">lockers_done</code> и <code class="structname">current_locker_pid</code>.</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect2" id="VACUUM-PROGRESS-REPORTING"><div class="titlepage"><div><div><h3 class="title">28.4.5. Отслеживание выполнения VACUUM <a href="#VACUUM-PROGRESS-REPORTING" class="id_link">#</a></h3></div></div></div><a id="id-1.6.15.9.7.2" class="indexterm"></a><p>В процессе выполнения <code class="command">VACUUM</code> представление <code class="structname">pg_stat_progress_vacuum</code> будет содержать по одной строке для каждого обслуживающего процесса (включая рабочие процессы автоочистки), производящего очистку в данный момент. Таблицы ниже показывают, какая информация будет отслеживаться, и поясняют, как её интерпретировать. Выполнение команд <code class="command">VACUUM FULL</code> отслеживается через <code class="structname">pg_stat_progress_cluster</code>, так как и <code class="command">VACUUM FULL</code>, и <code class="command">CLUSTER</code> перезаписывают таблицу, тогда как обычная команда <code class="command">VACUUM</code> модифицирует её саму. См. <a class="xref" href="progress-reporting.html#CLUSTER-PROGRESS-REPORTING" title="28.4.2. Отслеживание выполнения CLUSTER">Подраздел 28.4.2</a>.</p><div class="table" id="PG-STAT-PROGRESS-VACUUM-VIEW"><p class="title"><strong>Таблица 28.44. Представление <code class="structname">pg_stat_progress_vacuum</code></strong></p><div class="table-contents"><table class="table" summary="Представление pg_stat_progress_vacuum" border="1"><colgroup><col /></colgroup><thead><tr><th class="catalog_table_entry"><p class="column_definition">Тип столбца</p>
      <p>Описание</p></th></tr></thead><tbody><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">pid</code> <code class="type">integer</code>
      </p>
      <p>Идентификатор (PID) обслуживающего процесса</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">datid</code> <code class="type">oid</code>
      </p>
      <p>OID базы данных, к которой подключён этот обслуживающий процесс.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">datname</code> <code class="type">name</code>
      </p>
      <p>Имя базы данных, к которой подключён этот обслуживающий процесс.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">relid</code> <code class="type">oid</code>
      </p>
      <p>OID очищаемой таблицы.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">phase</code> <code class="type">text</code>
      </p>
      <p>Текущая фаза очистки. См. <a class="xref" href="progress-reporting.html#VACUUM-PHASES" title="Таблица 28.45. Фазы VACUUM">Таблицу 28.45</a>.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">heap_blks_total</code> <code class="type">bigint</code>
      </p>
      <p>Общее число блоков кучи в таблице. Это число отражает состояние в начале сканирования; блоки, добавленные позже, не будут (и не должны) обрабатываться текущей командой <code class="command">VACUUM</code>.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">heap_blks_scanned</code> <code class="type">bigint</code>
      </p>
      <p>Число просканированных блоков кучи. Так как для оптимизации сканирования применяется <a class="link" href="storage-vm.html" title="73.4. Карта видимости">карта видимости</a>, некоторые блоки могут пропускаться без осмотра; пропущенные блоки входят в это общее число, так что по завершении очистки это число станет равно <code class="structfield">heap_blks_total</code>. Этот счётчик увеличивается только в фазе <code class="literal">scanning heap</code>.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">heap_blks_vacuumed</code> <code class="type">bigint</code>
      </p>
      <p>Число очищенных блоков кучи. Если в таблице нет индексов, этот счётчик увеличивается только в фазе <code class="literal">vacuuming heap</code> (очистка кучи). Блоки, не содержащие «мёртвых» кортежей, при этом пропускаются, так что этот счётчик иногда может увеличиваться резкими рывками.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">index_vacuum_count</code> <code class="type">bigint</code>
      </p>
      <p>Количество завершённых циклов очистки индекса.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">max_dead_tuples</code> <code class="type">bigint</code>
      </p>
      <p>Число «мёртвых» кортежей, которое мы можем сохранить, прежде чем потребуется выполнить цикл очистки индекса, в зависимости от <a class="xref" href="runtime-config-resource.html#GUC-MAINTENANCE-WORK-MEM">maintenance_work_mem</a>.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">num_dead_tuples</code> <code class="type">bigint</code>
      </p>
      <p>Число «мёртвых» кортежей, собранных со времени последнего цикла очистки индекса.</p></td></tr></tbody></table></div></div><br class="table-break" /><div class="table" id="VACUUM-PHASES"><p class="title"><strong>Таблица 28.45. Фазы VACUUM</strong></p><div class="table-contents"><table class="table" summary="Фазы VACUUM" border="1"><colgroup><col class="col1" /><col class="col2" /></colgroup><thead><tr><th>Фаза</th><th>Описание</th></tr></thead><tbody><tr><td><code class="literal">initializing</code></td><td>Инициализация — <code class="command">VACUUM</code> готовится начать сканирование кучи. Эта фаза должна быть очень быстрой.</td></tr><tr><td><code class="literal">scanning heap</code></td><td>Сканирование кучи — <code class="command">VACUUM</code> в настоящее время сканирует кучу. При этом будет очищена и, если требуется, дефрагментирована каждая страница, а возможно, также будет произведена заморозка. Отслеживать процесс сканирования можно, следя за содержимым столбца <code class="structfield">heap_blks_scanned</code>.</td></tr><tr><td><code class="literal">vacuuming indexes</code></td><td>Очистка индексов — <code class="command">VACUUM</code> в настоящее время очищает индексы. Если у таблицы есть какие-либо индексы, эта фаза будет наблюдаться минимум единожды в процессе очистки, после того, как куча будет просканирована полностью. Она может повторяться несколько раз в процессе очистки, если объёма <a class="xref" href="runtime-config-resource.html#GUC-MAINTENANCE-WORK-MEM">maintenance_work_mem</a> (или, в случае автоочистки, <a class="xref" href="runtime-config-resource.html#GUC-AUTOVACUUM-WORK-MEM">autovacuum_work_mem</a>, если он задан) оказывается недостаточно для сохранения всех найденных «мёртвых» кортежей.</td></tr><tr><td><code class="literal">vacuuming heap</code></td><td>Очистка кучи — <code class="command">VACUUM</code> в настоящее время очищает кучу. Очистка кучи отличается от сканирования, так как она происходит после каждой операции очистки индексов. Если <code class="structfield">heap_blks_scanned</code> меньше чем <code class="structfield">heap_blks_total</code>, система вернётся к сканированию кучи после завершения этой фазы; в противном случае она начнёт уборку индексов.</td></tr><tr><td><code class="literal">cleaning up indexes</code></td><td>Уборка индексов — <code class="command">VACUUM</code> в настоящее время производит уборку в индексах. Это происходит после завершения полного сканирования кучи и очистки индексов и кучи.</td></tr><tr><td><code class="literal">truncating heap</code></td><td>Усечение кучи — <code class="command">VACUUM</code> в настоящее время усекает кучу, чтобы возвратить операционной системе объём пустых страниц в конце отношения. Это происходит после уборки индексов.</td></tr><tr><td><code class="literal">performing final cleanup</code></td><td>Выполнение окончательной очистки — <code class="command">VACUUM</code> выполняет окончательную очистку. На этой стадии <code class="command">VACUUM</code> очищает карту свободного пространства, обновляет статистику в <code class="literal">pg_class</code> и передаёт информацию системе накопительной статистики. После этой фазы <code class="command">VACUUM</code> завершит свою работу.</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect2" id="BASEBACKUP-PROGRESS-REPORTING"><div class="titlepage"><div><div><h3 class="title">28.4.6. Отслеживание выполнение базового копирования <a href="#BASEBACKUP-PROGRESS-REPORTING" class="id_link">#</a></h3></div></div></div><a id="id-1.6.15.9.8.2" class="indexterm"></a><p>Когда приложение <span class="application">pg_basebackup</span> или подобное выполняет базовое копирование, представление <code class="structname">pg_stat_progress_basebackup</code> будет содержать по одной строке для каждого процесса-передатчика WAL, выполняющего в данный момент команду репликации <code class="command">BASE_BACKUP</code> и передающего копируемые данные. Таблицы ниже показывают, какая информация будет отслеживаться, и поясняют, как её интерпретировать.</p><div class="table" id="PG-STAT-PROGRESS-BASEBACKUP-VIEW"><p class="title"><strong>Таблица 28.46. Представление <code class="structname">pg_stat_progress_basebackup</code></strong></p><div class="table-contents"><table class="table" summary="Представление pg_stat_progress_basebackup" border="1"><colgroup><col /></colgroup><thead><tr><th class="catalog_table_entry"><p class="column_definition">Тип столбца</p>
      <p>Описание</p></th></tr></thead><tbody><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">pid</code> <code class="type">integer</code>
      </p>
      <p>Идентификатор процесса-передатчика WAL.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">phase</code> <code class="type">text</code>
      </p>
      <p>Текущая фаза обработки. См. <a class="xref" href="progress-reporting.html#BASEBACKUP-PHASES" title="Таблица 28.47. Фазы базового копирования">Таблицу 28.47</a>.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">backup_total</code> <code class="type">bigint</code>
      </p>
      <p>Общий объём данных, который будет передан. Оценка этого объёма выдаётся на момент начала фазы <code class="literal">streaming database files</code> (передача файлов данных). Заметьте, что это лишь приблизительная оценка, так как база данных может измениться в фазе <code class="literal">streaming database files</code> и в резервную копию позже может быть добавлен WAL. Это значение устанавливается равным <code class="structfield">backup_streamed</code>, когда фактически переданный объём начинает превышать рассчитанный предварительно. Когда расчёт оценки в <span class="application">pg_basebackup</span> отключён (то есть передан параметр <code class="literal">--no-estimate-size</code>), это поле содержит <code class="literal">NULL</code>.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">backup_streamed</code> <code class="type">bigint</code>
      </p>
      <p>Объём переданных данных. Этот показатель увеличивается только в фазе <code class="literal">streaming database files</code> (передача файлов данных) или <code class="literal">transferring wal files</code> (передача файлов WAL).</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">tablespaces_total</code> <code class="type">bigint</code>
      </p>
      <p>Общее число табличных пространств, которые будут переданы.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">tablespaces_streamed</code> <code class="type">bigint</code>
      </p>
      <p>Число переданных табличных пространств. Этот счётчик увеличивается только в фазе <code class="literal">streaming database files</code> (передача файлов данных).</p></td></tr></tbody></table></div></div><br class="table-break" /><div class="table" id="BASEBACKUP-PHASES"><p class="title"><strong>Таблица 28.47. Фазы базового копирования</strong></p><div class="table-contents"><table class="table" summary="Фазы базового копирования" border="1"><colgroup><col class="col1" /><col class="col2" /></colgroup><thead><tr><th>Фаза</th><th>Описание</th></tr></thead><tbody><tr><td><code class="literal">initializing</code></td><td>Процесс-передатчик WAL готовится начать копирование. Эта фаза должна быть очень быстрой.</td></tr><tr><td><code class="literal">waiting for checkpoint to finish</code></td><td>Процесс-передатчик WAL в настоящий момент выполняет <code class="function">pg_backup_start</code>, чтобы подготовиться к получению базовой копии, и ждёт завершения контрольной точки для начала копирования.</td></tr><tr><td><code class="literal">estimating backup size</code></td><td>Процесс-передатчик WAL в настоящий момент оценивает общее количество файлов данных, которые будут передаваться при создании базовой копии.</td></tr><tr><td><code class="literal">streaming database files</code></td><td>Процесс-передатчик WAL в настоящий момент передаёт файлы данных в качестве содержимого базовой резервной копии.</td></tr><tr><td><code class="literal">waiting for wal archiving to finish</code></td><td>Процесс-передатчик WAL в настоящий момент выполняет <code class="function">pg_backup_stop</code>, чтобы закончить копирование, и ждёт успешного завершения архивации всех файлов WAL, необходимых для базовой копии. Если при запуске <span class="application">pg_basebackup</span> был указан параметр <code class="literal">--wal-method=none</code> или <code class="literal">--wal-method=stream</code>, резервное копирования заканчивается сразу после данной фазы.</td></tr><tr><td><code class="literal">transferring wal files</code></td><td>Процесс-передатчик WAL в настоящее время переносит все файлы WAL, заполненные во время копирования. Эта фаза следует за фазой <code class="literal">waiting for wal archiving to finish</code>, только если при запуске <span class="application">pg_basebackup</span> указывался параметр <code class="literal">--wal-method=fetch</code>. По окончании этой фазы резервное копирование завершается.</td></tr></tbody></table></div></div><br class="table-break" /></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="monitoring-locks.html" title="28.3. Просмотр информации о блокировках">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="monitoring.html" title="Глава 28. Мониторинг работы СУБД">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="dynamic-trace.html" title="28.5. Динамическая трассировка">След.</a></td></tr><tr><td width="40%" align="left" valign="top">28.3. Просмотр информации о блокировках </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 28.5. Динамическая трассировка</td></tr></table></div></body></html>