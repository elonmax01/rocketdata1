<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>59.2. Подпрограммы обёртки сторонних данных</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="fdw-functions.html" title="59.1. Функции обёрток сторонних данных" /><link rel="next" href="fdw-helpers.html" title="59.3. Вспомогательные функции для обёрток сторонних данных" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">59.2. Подпрограммы обёртки сторонних данных</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="fdw-functions.html" title="59.1. Функции обёрток сторонних данных">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="fdwhandler.html" title="Глава 59. Написание обёртки сторонних данных">Наверх</a></td><th width="60%" align="center">Глава 59. Написание обёртки сторонних данных</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="fdw-helpers.html" title="59.3. Вспомогательные функции для обёрток сторонних данных">След.</a></td></tr></table><hr /></div><div class="sect1" id="FDW-CALLBACKS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">59.2. Подпрограммы обёртки сторонних данных <a href="#FDW-CALLBACKS" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="fdw-callbacks.html#FDW-CALLBACKS-SCAN">59.2.1. Подпрограммы FDW для сканирования сторонних таблиц</a></span></dt><dt><span class="sect2"><a href="fdw-callbacks.html#FDW-CALLBACKS-JOIN-SCAN">59.2.2. Подпрограммы FDW для сканирования сторонних соединений</a></span></dt><dt><span class="sect2"><a href="fdw-callbacks.html#FDW-CALLBACKS-UPPER-PLANNING">59.2.3. Подпрограммы FDW для планирования обработки после сканирования/соединения</a></span></dt><dt><span class="sect2"><a href="fdw-callbacks.html#FDW-CALLBACKS-UPDATE">59.2.4. Подпрограммы FDW для изменения данных в сторонних таблицах</a></span></dt><dt><span class="sect2"><a href="fdw-callbacks.html#FDW-CALLBACKS-TRUNCATE">59.2.5. Подпрограммы FDW для <code class="command">TRUNCATE</code></a></span></dt><dt><span class="sect2"><a href="fdw-callbacks.html#FDW-CALLBACKS-ROW-LOCKING">59.2.6. Подпрограммы FDW для блокировки строк</a></span></dt><dt><span class="sect2"><a href="fdw-callbacks.html#FDW-CALLBACKS-EXPLAIN">59.2.7. Подпрограммы FDW для <code class="command">EXPLAIN</code></a></span></dt><dt><span class="sect2"><a href="fdw-callbacks.html#FDW-CALLBACKS-ANALYZE">59.2.8. Подпрограммы FDW для <code class="command">ANALYZE</code></a></span></dt><dt><span class="sect2"><a href="fdw-callbacks.html#FDW-CALLBACKS-IMPORT">59.2.9. Подпрограммы FDW для <code class="command">IMPORT FOREIGN SCHEMA</code></a></span></dt><dt><span class="sect2"><a href="fdw-callbacks.html#FDW-CALLBACKS-PARALLEL">59.2.10. Подпрограммы FDW для параллельного выполнения</a></span></dt><dt><span class="sect2"><a href="fdw-callbacks.html#FDW-CALLBACKS-ASYNC">59.2.11. Подпрограммы FDW для асинхронного выполнения</a></span></dt><dt><span class="sect2"><a href="fdw-callbacks.html#FDW-CALLBACKS-REPARAMETERIZE-PATHS">59.2.12. Подпрограммы FDW для изменения параметризации путей</a></span></dt></dl></div><p>Функция-обработчик FDW возвращает структуру <code class="structname">FdwRoutine</code> (выделенную с помощью palloc), содержащую указатели на подпрограммы, которые реализуют описанные ниже функции. Из всех функций обязательными являются только те, что касаются сканирования, а остальные могут отсутствовать.</p><p>Тип структуры <code class="structname">FdwRoutine</code> объявлен в <code class="filename">src/include/foreign/fdwapi.h</code>, там же можно узнать дополнительные подробности.</p><div class="sect2" id="FDW-CALLBACKS-SCAN"><div class="titlepage"><div><div><h3 class="title">59.2.1. Подпрограммы FDW для сканирования сторонних таблиц <a href="#FDW-CALLBACKS-SCAN" class="id_link">#</a></h3></div></div></div><pre class="programlisting">void
GetForeignRelSize(PlannerInfo *root,
                  RelOptInfo *baserel,
                  Oid foreigntableid);</pre><p> Выдаёт оценку размера отношения для сторонней таблицы. Она вызывается в начале планирования запроса, в котором сканируется сторонняя таблица. В параметре <code class="literal">root</code> передаётся общая информация планировщика о запросе, в <code class="literal">baserel</code> — информация о данной таблице, а в <code class="literal">foreigntableid</code> — OID записи в <code class="structname">pg_class</code> для данной таблицы. (Значение <code class="literal">foreigntableid</code> можно получить и из структуры данных планировщика, но простоты ради оно передаётся явно.)</p><p>Эта функция должна записать в <code class="literal">baserel-&gt;rows</code> ожидаемое число строк, которое будет получено при сканировании таблицы, с учётом фильтра, заданного ограничением выборки. Изначально в <code class="literal">baserel-&gt;rows</code> содержится просто постоянная оценка по умолчанию, которую следует заменить, если это вообще возможно. Функция также может поменять значение <code class="literal">baserel-&gt;width</code>, если она может дать лучшую оценку среднего размера строки результата. (Начальное значение зависит от типов столбцов и от среднего размера значений в них, рассчитанного при последнем <code class="command">ANALYZE</code>.) Также эта функция может изменить значение <code class="literal">baserel-&gt;tuples</code>, если она может дать лучшую оценку общего количества строк в сторонней таблице. (Начальное значение берётся из поля <code class="structname">pg_class</code>.<code class="structfield">reltuples</code>, которое содержит общее количество строк, полученное при последнем <code class="command">ANALYZE</code>; или <code class="literal">-1</code>, если <code class="command">ANALYZE</code> для этой сторонней таблицы ещё не выполнялся.)</p><p>За дополнительными сведениями обратитесь к <a class="xref" href="fdw-planning.html" title="59.4. Планирование запросов с обёртками сторонних данных">Разделу 59.4</a>.</p><pre class="programlisting">void
GetForeignPaths(PlannerInfo *root,
                RelOptInfo *baserel,
                Oid foreigntableid);</pre><p> Формирует возможные пути доступа для сканирования сторонней таблицы. Эта функция вызывается при планировании запроса. Ей передаются те же параметры, что и функции <code class="function">GetForeignRelSize</code>, которая к этому времени уже будет вызвана.</p><p>Эта функция должна выдать минимум один путь доступа (узел <code class="structname">ForeignPath</code>) для сканирования сторонней таблицы и должна вызвать <code class="function">add_path</code>, чтобы добавить каждый такой путь в <code class="literal">baserel-&gt;pathlist</code>. Для формирования узлов <code class="structname">ForeignPath</code> рекомендуется вызывать <code class="function">create_foreignscan_path</code>. Данная функция может выдавать несколько путей доступа, то есть путей, для которых по заданным <code class="literal">pathkeys</code> можно получить уже отсортированный результат. Каждый путь доступа должен содержать оценки стоимости и может содержать любую частную информацию FDW, необходимую для выбора целевого метода сканирования.</p><p>За дополнительными сведениями обратитесь к <a class="xref" href="fdw-planning.html" title="59.4. Планирование запросов с обёртками сторонних данных">Разделу 59.4</a>.</p><pre class="programlisting">ForeignScan *
GetForeignPlan(PlannerInfo *root,
               RelOptInfo *baserel,
               Oid foreigntableid,
               ForeignPath *best_path,
               List *tlist,
               List *scan_clauses,
               Plan *outer_plan);</pre><p> Создаёт узел плана <code class="structname">ForeignScan</code> из выбранного пути доступа к сторонней таблице. Эта функция вызывается в конце планирования запроса. Ей передаются те же параметры, что и <code class="function">GetForeignRelSize</code>, плюс выбранный путь <code class="structname">ForeignPath</code> (до этого сформированный функциями <code class="function">GetForeignPaths</code>, <code class="function">GetForeignJoinPaths</code> или <code class="function">GetForeignUpperPaths</code>), целевой список, который должен быть выдан этим узлом плана, условия ограничения, которые должны применяться для данного узла, и внешний вложенный подплан <code class="structname">ForeignScan</code>, применяемый для перепроверок, выполняемых функцией <code class="function">RecheckForeignScan</code>. (Если путь задаётся для соединения, а не для базового отношения, в <code class="literal">foreigntableid</code> передаётся <code class="literal">InvalidOid</code>.)</p><p>Эта функция должна создать и выдать узел плана <code class="structname">ForeignScan</code>; для формирования этого узла рекомендуется использовать <code class="function">make_foreignscan</code>.</p><p>За дополнительными сведениями обратитесь к <a class="xref" href="fdw-planning.html" title="59.4. Планирование запросов с обёртками сторонних данных">Разделу 59.4</a>.</p><pre class="programlisting">void
BeginForeignScan(ForeignScanState *node,
                 int eflags);</pre><p> Начинает сканирование сторонней таблицы. Эта функция вызывается при запуске исполнителя. Она должна выполнить все подготовительные действия, необходимые для осуществления сканирования, но не должна собственно производить сканирование (оно должно начаться с первым вызовом <code class="function">IterateForeignScan</code>). Узел <code class="structname">ForeignScanState</code> уже был создан, но его поле <code class="structfield">fdw_state</code> по-прежнему NULL. Информацию о сканируемой таблице можно получить через узел <code class="structname">ForeignScanState</code> (в частности, из нижележащего узла <code class="structname">ForeignScan</code>, содержащего частную информацию FDW, заданную функцией <code class="function">GetForeignPlan</code>). Параметр <code class="literal">eflags</code> содержит битовые флаги, описывающие режим работы исполнителя для этого узла плана.</p><p>Заметьте, что когда <code class="literal">(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</code> не равно нулю, эта функция не должна выполнять какие-либо внешне проявляющиеся действия; она должна сделать только то, что необходимо для получения состояния узла, подходящего для <code class="function">ExplainForeignScan</code> и <code class="function">EndForeignScan</code>.</p><pre class="programlisting">TupleTableSlot *
IterateForeignScan(ForeignScanState *node);</pre><p> Выбирает одну строку из стороннего источника и возвращает её в слоте таблицы кортежей (для этой цели следует использовать <code class="structfield">ScanTupleSlot</code>, переданный с узлом). Когда строки заканчиваются, возвращает NULL. Инфраструктура слотов таблицы кортежей позволяет возвращать как физические, так и виртуальные кортежи; в большинстве случаев второй вариант предпочтительнее с точки зрения производительности. Заметьте, что эта функция вызывается в контексте кратковременной памяти, который будет сбрасываться между вызовами. Если вам нужна более долгоживущая память, создайте соответствующий контекст в <code class="function">BeginForeignScan</code> либо используйте <code class="structfield">es_query_cxt</code> из структуры <code class="structname">EState</code>, переданной с узлом.</p><p>Возвращаемые строки должны соответствовать целевому списку <code class="structfield">fdw_scan_tlist</code>, если он передаётся, а в противном случае — типу строки сканируемой сторонней таблицы. Если вы решите для оптимизации не возвращать ненужные столбцы, в их позиции нужно вставить NULL, либо сформировать список <code class="structfield">fdw_scan_tlist</code> без этих столбцов.</p><p>Заметьте, что для исполнителя <span class="productname">PostgreSQL</span> не важно, удовлетворяют ли возвращаемые строки каким-либо ограничениям, определённым для сторонней таблицы — но это важно для планировщика, так что запросы могут оптимизироваться некорректно, если в сторонней таблице будут видны строки, не удовлетворяющие объявленному ограничению. Если ограничение нарушается, тогда как пользователь объявил, что оно должно выполняться, может быть уместно сообщить об ошибке (точно так же, как и при несовпадении типов данных).</p><pre class="programlisting">void
ReScanForeignScan(ForeignScanState *node);</pre><p> Перезапускает сканирование с начала. Заметьте, что значения параметров, от которых зависит сканирование, могли измениться, так что новое сканирование не обязательно вернёт те же строки.</p><pre class="programlisting">void
EndForeignScan(ForeignScanState *node);</pre><p> Завершает сканирование и освобождает ресурсы. Обычно при этом не нужно освобождать память, выделенную через palloc, но например, открытые файлы и подключения к удалённым серверам следует закрыть.</p></div><div class="sect2" id="FDW-CALLBACKS-JOIN-SCAN"><div class="titlepage"><div><div><h3 class="title">59.2.2. Подпрограммы FDW для сканирования сторонних соединений <a href="#FDW-CALLBACKS-JOIN-SCAN" class="id_link">#</a></h3></div></div></div><p>Если FDW поддерживает соединения на удалённой стороне (вместо того, чтобы считывать данные обеих таблиц и выполнять соединения локально), она должна предоставить эту реализующую подпрограмму:</p><pre class="programlisting">void
GetForeignJoinPaths(PlannerInfo *root,
                    RelOptInfo *joinrel,
                    RelOptInfo *outerrel,
                    RelOptInfo *innerrel,
                    JoinType jointype,
                    JoinPathExtraData *extra);</pre><p> Формирует возможные пути доступа для соединения двух (и более) сторонних таблиц, принадлежащих одному стороннему серверу. Эта необязательная функция вызывается во время планирования запроса. Как и <code class="function">GetForeignPaths</code>, эта функция должна построить пути <code class="structname">ForeignPath</code> для переданного <code class="literal">joinrel</code> (для построения путей используйте <code class="function">create_foreign_join_path</code>) и вызвать <code class="function">add_path</code>, чтобы добавить эти пути в набор путей, подходящих для соединения. Но, в отличие от <code class="function">GetForeignPaths</code>, эта функция не обязательно должна возвращать минимум один путь, так как всегда возможен альтернативный путь с локальным соединением таблиц.</p><p>Заметьте, что эта функция будет вызываться неоднократно для одного и того же соединения с разными комбинациями внутреннего и внешнего отношений; минимизировать двойную работу должна сама FDW.</p><p>Если для соединения выбирается путь <code class="structname">ForeignPath</code>, он будет представлять весь процесс соединения; пути, сформированные для задействованных таблиц и подчинённых соединений, в нём применяться не будут. Далее этот путь соединения обрабатывается во многом так же, как и путь сканирования одной сторонней таблицы. Одно различие состоит в том, что <code class="structfield">scanrelid</code> результирующего плана узла <code class="structname">ForeignScan</code> должно быть равно нулю, так как он не представляет какое-либо одно отношение; вместо этого набор соединяемых отношений представляется в поле <code class="structfield">fs_relids</code> узла <code class="structname">ForeignScan</code>. (Это поле заполняется автоматически кодом ядра планировщика, так что FDW делать это не нужно.) Ещё одно отличие в том, что список столбцов для удалённого соединения нельзя получить из системных каталогов и поэтому FDW должна выдать в <code class="structfield">fdw_scan_tlist</code> требуемый список узлов <code class="structfield">TargetEntry</code>, представляющий набор столбцов, которые будут выдаваться во время выполнения в возвращаемых кортежах.</p><div class="note"><h3 class="title">Примечание</h3><p>Начиная с <span class="productname">PostgreSQL</span> 16, в <code class="structfield">fs_relids</code> учитываются наборы строк, полученные в результате внешних соединений, если они были задействованы в данном соединении. Новое поле <code class="structfield">fs_base_relids</code> включает только базовые отношения, то есть копирует старую семантику <code class="structfield">fs_relids</code>.</p></div><p>За дополнительными сведениями обратитесь к <a class="xref" href="fdw-planning.html" title="59.4. Планирование запросов с обёртками сторонних данных">Разделу 59.4</a>.</p></div><div class="sect2" id="FDW-CALLBACKS-UPPER-PLANNING"><div class="titlepage"><div><div><h3 class="title">59.2.3. Подпрограммы FDW для планирования обработки после сканирования/соединения <a href="#FDW-CALLBACKS-UPPER-PLANNING" class="id_link">#</a></h3></div></div></div><p>Если FDW поддерживает удалённое выполнение операций после сканирования/соединения, например, удалённое агрегирование, она должна предоставить эту реализующую подпрограмму:</p><pre class="programlisting">void
GetForeignUpperPaths(PlannerInfo *root,
                     UpperRelationKind stage,
                     RelOptInfo *input_rel,
                     RelOptInfo *output_rel,
                     void *extra);</pre><p> Формирует возможные пути доступа для обработки <em class="firstterm">верхнего отношения</em>. Этот термин планировщика подразумевает любую обработку запросов после сканирования/соединения, в частности, агрегирование, вычисление оконных функций, сортировку и изменение таблиц. Эта необязательная функция вызывается во время планирования запроса. В настоящее время она вызывается, только если все базовые отношения, задействованные в запросе, относятся к одной FDW. Эта функция должна построить пути <code class="structname">ForeignPath</code> для любых действий после сканирования/соединения, которые FDW умеет выполнять удалённо (для построения путей используйте <code class="function">create_foreign_upper_path</code>), и вызвать <code class="function">add_path</code>, чтобы добавить эти пути к указанному верхнему отношению. Как и <code class="function">GetForeignJoinPaths</code>, эта функция не обязательно должна возвращать какие-либо пути, так как всегда возможны пути с локальной обработкой.</p><p>Параметр <code class="literal">stage</code> определяет, какой шаг после сканирования/соединения рассматривается в данный момент. Параметр <code class="literal">output_rel</code> указывает на верхнее отношение, которое должно получить пути, представляющие вычисление этого шага, а <code class="literal">input_rel</code> — на отношение, представляющее входные данные для этого шага. В параметре <code class="literal">extra</code> передаётся дополнительная информация; в настоящее время он устанавливается только для <code class="literal">UPPERREL_PARTIAL_GROUP_AGG</code> и <code class="literal">UPPERREL_GROUP_AGG</code> (в этом случае указывает на структуру <code class="literal">GroupPathExtraData</code>) и для <code class="literal">UPPERREL_FINAL</code> (тогда он указывает на структуру <code class="literal">FinalPathExtraData</code>). Заметьте, что пути <code class="structname">ForeignPath</code>, добавляемые в <code class="literal">output_rel</code>, обычно не будут напрямую зависеть от путей <code class="literal">input_rel</code>, так как ожидается, что они будут обрабатываться снаружи. Однако изучить пути, построенные для предыдущего шага обработки, может быть полезно для исключения лишних операций при планировании.</p><p>За дополнительными сведениями обратитесь к <a class="xref" href="fdw-planning.html" title="59.4. Планирование запросов с обёртками сторонних данных">Разделу 59.4</a>.</p></div><div class="sect2" id="FDW-CALLBACKS-UPDATE"><div class="titlepage"><div><div><h3 class="title">59.2.4. Подпрограммы FDW для изменения данных в сторонних таблицах <a href="#FDW-CALLBACKS-UPDATE" class="id_link">#</a></h3></div></div></div><p>Если FDW поддерживает запись в сторонние таблицы, она должна предоставить некоторые или все подпрограммы, реализующие следующие функции, в зависимости от потребностей и возможностей FDW:</p><pre class="programlisting">void
AddForeignUpdateTargets(PlannerInfo *root,
                        Index rtindex,
                        RangeTblEntry *target_rte,
                        Relation target_relation);</pre><p> Операции <code class="command">UPDATE</code> и <code class="command">DELETE</code> выполняются со строками, ранее выбранными функциями сканирования таблицы. FDW может потребоваться дополнительная информация, например, ID строки или значения столбцов первичного ключа, чтобы точно знать, какую именно строку нужно изменить или удалить. Для этого данная функция может добавить дополнительные скрытые или <span class="quote">«<span class="quote">отбросовые</span>»</span> целевые столбцы в список столбцов, которые должны быть получены из сторонней таблицы во время <code class="command">UPDATE</code> или <code class="command">DELETE</code>.</p><p>Для этого создайте структуру <code class="structname">Var</code>, представляющую нужное дополнительное значение, и передайте её функции <code class="function">add_row_identity_var</code> вместе с именем отбросового столбца. (Это можно сделать несколько раз, если требуется добавить несколько столбцов.) Имя отбросового столбца в каждой структуре <code class="structname">Var</code> должно быть уникальным, за исключением случая с одноимёнными структурами Var, отличающимися только значением <code class="structfield">varno</code> — в таких структурах имена могут и должны быть одинаковыми. Основная система использует следующие имена отбросовых столбцов: <code class="literal">tableoid</code> для столбца <code class="structfield">tableoid</code> таблицы, <code class="literal">ctid</code> или <code class="literal">ctid<em class="replaceable"><code>N</code></em></code> для <code class="structfield">ctid</code>, <code class="literal">wholerow</code> для переменной <code class="structname">Var</code>, содержащей целую строку и отмеченной <code class="structfield">vartype</code> = <code class="type">RECORD</code>, и <code class="literal">wholerow<em class="replaceable"><code>N</code></em></code> для переменной <code class="structname">Var</code>, содержащей целую строку, с <code class="structfield">vartype</code>, равным объявленному типу строки таблицы. По возможности используйте эти имена повторно (планировщик объединит повторяющиеся запросы для идентичных отбросовых столбцов). Если вам нужен другой тип отбросового столбца, помимо уже используемых, будет разумно выбрать имя с префиксом вашего имени расширения, чтобы избежать конфликтов с другими FDW.</p><p>Если указатель <code class="function">AddForeignUpdateTargets</code> равен <code class="literal">NULL</code>, дополнительные целевые выражения не добавляются. (Это делает невозможным реализацию операций <code class="command">DELETE</code>, хотя операция <code class="command">UPDATE</code> может быть всё же возможна, если FDW идентифицирует строки, полагаясь на то, что первичный ключ не меняется.)</p><pre class="programlisting">List *
PlanForeignModify(PlannerInfo *root,
                  ModifyTable *plan,
                  Index resultRelation,
                  int subplan_index);</pre><p> Выполняет любые дополнительные действия планирования, необходимые для добавления, изменения или удаления в сторонней таблице. Эта функция формирует частную информацию FDW, которая будет добавлена в узел плана <code class="structname">ModifyTable</code>, осуществляющий изменение. Эта информация должна возвращаться в списке (<code class="literal">List</code>); она будет доставлена в функцию <code class="function">BeginForeignModify</code> на стадии выполнения.</p><p>В <code class="literal">root</code> передаётся общая информация планировщика о запросе, а в <code class="literal">plan</code> — узел плана <code class="structname">ModifyTable</code>, заполненный, не считая поля <code class="structfield">fdwPrivLists</code>. Параметр <code class="literal">resultRelation</code> указывает на целевую стороннюю таблицу по номеру в списке отношений, а <code class="literal">subplan_index</code> определяет целевое отношение в данном узле <code class="structname">ModifyTable</code>, начиная с нуля; воспользуйтесь этим индексом, обращаясь к вложенным структурам узла <code class="literal">plan</code>, соответствующим целевым отношениям.</p><p>За дополнительными сведениями обратитесь к <a class="xref" href="fdw-planning.html" title="59.4. Планирование запросов с обёртками сторонних данных">Разделу 59.4</a>.</p><p>Если указатель <code class="function">PlanForeignModify</code> равен <code class="literal">NULL</code>, дополнительные действия во время планирования не предпринимаются, и в качестве <code class="literal">fdw_private</code> в <code class="function">BeginForeignModify</code> поступит NULL.</p><pre class="programlisting">void
BeginForeignModify(ModifyTableState *mtstate,
                   ResultRelInfo *rinfo,
                   List *fdw_private,
                   int subplan_index,
                   int eflags);</pre><p> Начинает выполнение операции изменения данных в сторонней таблице. Эта подпрограмма выполняется при запуске исполнителя. Она должна выполнять любые подготовительные действия, необходимые для того, чтобы собственно произвести изменения в таблице. Впоследствии для кортежей, которые будут вставляться, изменяться или удаляться, будет вызываться <code class="function">ExecForeignInsert/ExecForeignBatchInsert</code>, <code class="function">ExecForeignUpdate</code> или <code class="function">ExecForeignDelete</code>.</p><p>В параметре <code class="literal">mtstate</code> передаётся общее состояние выполняемого плана узла <code class="structname">ModifyTable</code>; через эту структуру доступны глобальные сведения о плане и состояние выполнения. В <code class="literal">rinfo</code> передаётся структура <code class="structname">ResultRelInfo</code>, описывающая целевую стороннюю таблицу. (Если FDW нужно сохранить частное состояние, необходимое для этой операции, она может воспользоваться полем <code class="structfield">ri_FdwState</code> структуры <code class="structname">ResultRelInfo</code>.) В <code class="literal">fdw_private</code> передаются частные данные, если они были сформированы процедурой <code class="function">PlanForeignModify</code>. Параметр <code class="literal">subplan_index</code> определяет целевое отношение в данном узле <code class="structname">ModifyTable</code>, а в <code class="literal">eflags</code> передаются битовые флаги, описывающие режим работы исполнителя для этого узла плана.</p><p>Заметьте, что когда <code class="literal">(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</code> не равно нулю, эта функция не должна выполнять какие-либо внешне проявляющиеся действия; она должна сделать только то, что необходимо для получения состояния узла, подходящего для <code class="function">ExplainForeignModify</code> и <code class="function">EndForeignModify</code>.</p><p>Если указатель на <code class="function">BeginForeignModify</code> равен <code class="literal">NULL</code>, никакое действие при запуске исполнителя не выполняется.</p><pre class="programlisting">TupleTableSlot *
ExecForeignInsert(EState *estate,
                  ResultRelInfo *rinfo,
                  TupleTableSlot *slot,
                  TupleTableSlot *planSlot);</pre><p> Вставляет один кортеж в стороннюю таблицу. В <code class="literal">estate</code> передаётся глобальное состояние выполнения запроса, а в <code class="literal">rinfo</code> — структура <code class="structname">ResultRelInfo</code>, описывающая целевую стороннюю таблицу. Параметр <code class="literal">slot</code> содержит кортеж, который должен быть вставлен; он будет соответствовать определению типа строки сторонней таблицы. Параметр <code class="literal">planSlot</code> содержит кортеж, сформированный вложенным планом узла <code class="structname">ModifyTable</code>; он отличается от <code class="literal">slot</code> тем, что может содержать дополнительные <span class="quote">«<span class="quote">отбросовые</span>»</span> столбцы. (Значение <code class="literal">planSlot</code> обычно не очень интересно для операций <code class="command">INSERT</code>, но оно представлено для полноты.)</p><p>Возвращаемым значением будет либо слот, содержащий данные, которые были фактически вставлены (они могут отличаться от переданных данных, например, в результате действий триггеров), либо NULL, если никакая строка фактически не была вставлена (опять же, обычно в результате действий триггеров). Чтобы вернуть результат, также можно использовать передаваемый на вход <code class="literal">slot</code>.</p><p>Данные в возвращаемом слоте используются, только если оператор <code class="command">INSERT</code> содержит предложение <code class="literal">RETURNING</code>, задействуется представление с указанием <code class="literal">WITH CHECK OPTION</code> либо если для сторонней таблицы определён триггер <code class="literal">AFTER ROW</code>. Триггерам нужны все столбцы, но FDW может для оптимизации не возвращать некоторые или все, в зависимости от содержания предложения <code class="literal">RETURNING</code> или ограничения <code class="literal">WITH CHECK OPTION</code>. Так или иначе, какой-либо слот необходимо вернуть, чтобы отметить, что операция успешна, иначе число возвращённых запросом строк будет неверным.</p><p>Если указатель на <code class="function">ExecForeignInsert</code> равен <code class="literal">NULL</code>, вставить данные в стороннюю таблицу не удастся, в ответ будет выдаваться сообщение об ошибке.</p><p>Заметьте, что эта функция также вызывается при добавлении кортежей, перенаправленных в секцию в сторонней таблице, или при выполнении <code class="command">COPY FROM</code> со сторонней таблицей. В данных случаях она вызывается не так, как при выполнении обычного <code class="command">INSERT</code>. Ниже описаны функции обратного вызова, позволяющие реализовать поддержку этих операций в обёртке сторонних данных.</p><pre class="programlisting">TupleTableSlot **
ExecForeignBatchInsert(EState *estate,
                       ResultRelInfo *rinfo,
                       TupleTableSlot **slots,
                       TupleTableSlot **planSlots,
                       int *numSlots);</pre><p> Вставляет сразу несколько кортежей в стороннюю таблицу. Этой функции передаются по сути те же параметры, что <code class="function">ExecForeignInsert</code>, но в <code class="literal">slots</code> и <code class="literal">planSlots</code> передаются массивы кортежей, а <code class="literal">*numSlots</code> задаёт количество кортежей в этих массивах.</p><p>Возвращаемым значением будет массив слотов, содержащих данные, которые были фактически вставлены (они могут отличаться от переданных данных, например, в результате действий триггеров). Чтобы вернуть результат, также можно использовать передаваемый на вход массив <code class="literal">slots</code>. Количество успешно вставленных кортежей выдаётся в <code class="literal">*numSlots</code>.</p><p>Данные в возвращаемом слоте используются, только если при выполнении оператора <code class="command">INSERT</code> задействуется представление с указанием <code class="literal">WITH CHECK OPTION</code> или если для сторонней таблицы определён триггер <code class="literal">AFTER ROW</code>. Триггерам нужны все столбцы, но FDW может для оптимизации не возвращать некоторые или все, в зависимости от содержания ограничений <code class="literal">WITH CHECK OPTION</code>.</p><p>Если указатель на <code class="function">ExecForeignBatchInsert</code> или <code class="function">GetForeignModifyBatchSize</code> равен <code class="literal">NULL</code>, для добавления данных в стороннюю таблицу вместо данной функции будет использоваться функция <code class="function">ExecForeignInsert</code>. Данная функция также не используется, если в <code class="command">INSERT</code> присутствует предложение <code class="literal">RETURNING</code>.</p><p>Заметьте, что эта функция также вызывается при добавлении кортежей, перенаправленных в секцию в сторонней таблице, или при выполнении <code class="command">COPY FROM</code> со сторонней таблицей. В данных случаях она вызывается не так, как при выполнении обычного <code class="command">INSERT</code>. Ниже описаны функции обратного вызова, позволяющие реализовать поддержку этих операций в обёртке сторонних данных.</p><pre class="programlisting">int
GetForeignModifyBatchSize(ResultRelInfo *rinfo);</pre><p> Выдаёт максимальное количество кортежей, которое может быть обработано за один вызов функции <code class="function">ExecForeignBatchInsert</code> для указанной сторонней таблицы. Исполнитель передаёт не более данного количества кортежей в <code class="function">ExecForeignBatchInsert</code>. <code class="literal">rinfo</code> — это структура <code class="structname">ResultRelInfo</code>, описывающая целевую стороннюю таблицу. Ожидается, что FDW даст пользователю возможность задать этот параметр на уровне стороннего сервера и/или таблицы, либо будет использоваться некоторое фиксированное значение.</p><p>Если указатель на <code class="function">ExecForeignInsert</code> или <code class="function">GetForeignModifyBatchSize</code> равен <code class="literal">NULL</code>, для добавления данных в стороннюю таблицу будет использоваться функция <code class="function">ExecForeignInsert</code>.</p><pre class="programlisting">TupleTableSlot *
ExecForeignUpdate(EState *estate,
                  ResultRelInfo *rinfo,
                  TupleTableSlot *slot,
                  TupleTableSlot *planSlot);</pre><p> Изменяет один кортеж в сторонней таблице. В <code class="literal">estate</code> передаётся глобальное состояние выполнения запроса, а в <code class="literal">rinfo</code> — структура <code class="structname">ResultRelInfo</code>, описывающая целевую стороннюю таблицу. Параметр <code class="literal">slot</code> содержит новые данные для кортежа; он будет соответствовать определению типа строки сторонней таблицы. Параметр <code class="literal">planSlot</code> содержит кортеж, сформированный вложенным планом узла <code class="structname">ModifyTable</code>. Он отличается от <code class="literal">slot</code> тем, что содержит только новые значения для столбцов, изменённых в результате запроса, поэтому не следует обращаться к элементам <code class="literal">planSlot</code> по номерам атрибутов сторонней таблицы. Кроме того, <code class="literal">planSlot</code> обычно содержит дополнительные <span class="quote">«<span class="quote">отбросовые</span>»</span> столбцы. В частности, в этом слоте можно получить любые отбросовые столбцы, запрошенные в <code class="function">AddForeignUpdateTargets</code>.</p><p>Возвращаемым значением будет либо слот, содержащий строку в состоянии после изменения (её содержимое может отличаться от переданного, например, в результате действий триггеров), либо NULL, если никакая строка фактически не была изменена (опять же, обычно в результате действий триггеров). Чтобы вернуть результат, также можно использовать передаваемый на вход <code class="literal">slot</code>.</p><p>Данные в возвращаемом слоте используются, только если оператор <code class="command">UPDATE</code> содержит предложение <code class="literal">RETURNING</code>, задействуется представление с указанием <code class="literal">WITH CHECK OPTION</code> либо если для сторонней таблицы определён триггер <code class="literal">AFTER ROW</code>. Триггерам нужны все столбцы, но FDW может для оптимизации не возвращать некоторые или все, в зависимости от содержания предложения <code class="literal">RETURNING</code> или ограничения <code class="literal">WITH CHECK OPTION</code>. Так или иначе, какой-либо слот необходимо вернуть, чтобы отметить, что операция успешна, иначе число возвращённых запросом строк будет неверным.</p><p>Если указатель на <code class="function">ExecForeignUpdate</code> равен <code class="literal">NULL</code>, изменить данные в сторонней таблице не удастся, а в ответ будет выдаваться сообщение об ошибке.</p><pre class="programlisting">TupleTableSlot *
ExecForeignDelete(EState *estate,
                  ResultRelInfo *rinfo,
                  TupleTableSlot *slot,
                  TupleTableSlot *planSlot);</pre><p> Удаляет один кортеж из сторонней таблицы. В <code class="literal">estate</code> передаётся глобальное состояние выполнения запроса, а в <code class="literal">rinfo</code> — структура <code class="structname">ResultRelInfo</code>, описывающая целевую стороннюю таблицу. Параметр <code class="literal">slot</code> при вызове не содержит ничего полезного, но в эту структуру можно поместить возвращаемый кортеж. Параметр <code class="literal">planSlot</code> содержит кортеж, сформированный вложенным планом узла <code class="structname">ModifyTable</code>; в частности, в нём могут содержаться отбросовые столбцы, запрошенные в <code class="function">AddForeignUpdateTargets</code>. Отбросовые столбцы необходимы, чтобы определить, какой именно кортеж удалять.</p><p>Возвращаемым значением будет либо слот, содержащий строку, которая была удалена, либо NULL, если не удалена никакая строка (обычно в результате действия триггеров). Для размещения возвращаемого кортежа можно использовать передаваемый на вход <code class="literal">slot</code>.</p><p>Данные в возвращаемом слоте используются, только если запрос <code class="command">DELETE</code> содержит предложение <code class="literal">RETURNING</code> или для сторонней таблицы определён триггер <code class="literal">AFTER ROW</code>. Триггерам нужны все столбцы, но для предложения <code class="literal">RETURNING</code> FDW может ради оптимизации не возвращать некоторые или все столбцы, в зависимости от его содержания. Так или иначе, какой-либо слот необходимо вернуть, чтобы отметить, что операция успешна, иначе возвращённое число строк будет неверным.</p><p>Если указатель на <code class="function">ExecForeignDelete</code> равен <code class="literal">NULL</code>, удалить данные из сторонней таблицы не удастся, а в ответ будет выдаваться сообщение об ошибке.</p><pre class="programlisting">void
EndForeignModify(EState *estate,
                 ResultRelInfo *rinfo);</pre><p> Завершает изменение данных в таблице и освобождает ресурсы. Обычно при этом не нужно освобождать память, выделенную через palloc, но например, открытые файлы и подключения к удалённым серверам следует закрыть.</p><p>Если указатель на <code class="function">EndForeignModify</code> равен <code class="literal">NULL</code>, никакое действие при завершении исполнителя не выполняется.</p><p>Кортежи, вставляемые в секционированную таблицу командами <code class="command">INSERT</code> и <code class="command">COPY FROM</code>, направляются в соответствующие секции. Если обёртка сторонних данных поддерживает перенаправление в секции в сторонних таблицах, она также должна предоставить описанные ниже обработчики. Эти функции также вызываются, когда результат <code class="command">COPY FROM</code> помещается в стороннюю таблицу.</p><pre class="programlisting">void
BeginForeignInsert(ModifyTableState *mtstate,
                   ResultRelInfo *rinfo);</pre><p> Начинает выполнение операции добавления данных в сторонней таблице. Эта подпрограмма вызывается непосредственно перед тем, как первый кортеж будет вставлен в стороннюю таблицу — и когда это секция, выбранная для размещения кортежа, и когда это целевое отношение команды <code class="command">COPY FROM</code>. Она должна выполнять любые подготовительные действия, необходимые перед собственно добавлением данных. Впоследствии для кортежей, добавляемых в стороннюю таблицу, будет вызываться обработчик <code class="function">ExecForeignInsert</code> или <code class="function">ExecForeignBatchInsert</code>.</p><p>В параметре <code class="literal">mtstate</code> передаётся общее состояние выполняемого плана узла <code class="structname">ModifyTable</code>; через эту структуру доступна глобальная информация о плане и состоянии выполнения. В <code class="literal">rinfo</code> передаётся структура <code class="structname">ResultRelInfo</code>, описывающая целевую стороннюю таблицу. (Если FDW нужно сохранить частное состояние, необходимое для этой операции, она может воспользоваться полем <code class="structfield">ri_FdwState</code> структуры <code class="structname">ResultRelInfo</code>.)</p><p>Когда этот обработчик вызывается командой <code class="command">COPY FROM</code>, связанные с планом глобальные данные в <code class="literal">mtstate</code> не передаются. При этом параметр <code class="literal">planSlot</code> обработчика <code class="function">ExecForeignInsert</code>, впоследствии вызываемого для каждого вставляемого кортежа, равен <code class="literal">NULL</code> — и когда сторонняя таблица является секцией, выбранной для помещения кортежа, и когда это целевое отношение данной команды.</p><p>Если указатель на <code class="function">BeginForeignInsert</code> равен <code class="literal">NULL</code>, никакое действие при инициализации не выполняется.</p><p>Заметьте, что если обёртка сторонних данных не поддерживает перенаправление кортежей в секции и/или операцию <code class="command">COPY FROM</code> со сторонними таблицами, эта функция или вызываемая за ней <code class="function">ExecForeignInsert/ExecForeignBatchInsert</code> должны выдать соответствующую ошибку.</p><pre class="programlisting">void
EndForeignInsert(EState *estate,
                 ResultRelInfo *rinfo);</pre><p> Завершает операцию добавления и освобождает ресурсы. Обычно при этом не нужно освобождать память, выделенную через palloc, но например, открытые файлы и подключения к удалённым серверам следует закрыть.</p><p>Если указатель на <code class="function">EndForeignInsert</code> равен <code class="literal">NULL</code>, никакое действие при завершении не выполняется.</p><pre class="programlisting">int
IsForeignRelUpdatable(Relation rel);</pre><p> Сообщает, какие операции изменения данных поддерживает указанная сторонняя таблица. Возвращаемое значение должно быть битовой маской кодов событий, обозначающих операции, поддерживаемые таблицей, и заданных в перечислении <code class="literal">CmdType</code>; то есть, <code class="literal">(1 &lt;&lt; CMD_UPDATE) = 4</code> для <code class="command">UPDATE</code>, <code class="literal">(1 &lt;&lt; CMD_INSERT) = 8</code> для <code class="command">INSERT</code> и <code class="literal">(1 &lt;&lt; CMD_DELETE) = 16</code> для <code class="command">DELETE</code>.</p><p>Если указатель на <code class="function">IsForeignRelUpdatable</code> равен <code class="literal">NULL</code>, предполагается, что сторонние таблицы позволяют добавлять, изменять и удалять строки, если FDW предоставляет процедуры для функций <code class="function">ExecForeignInsert</code>, <code class="function">ExecForeignUpdate</code> или <code class="function">ExecForeignDelete</code>, соответственно. Данная функция необходима, только если FDW поддерживает операции изменения для одних таблиц и не поддерживает для других. (Хотя для этого можно выдать ошибку в подпрограмме, выполняющей операцию, а не задействовать эту функцию. Однако данная функция позволяет корректно отражать поддержку изменений в представлениях <code class="literal">information_schema</code>.)</p><p>Некоторые операции добавления, изменений и удаления данных в сторонних таблицах можно соптимизировать, применив альтернативный набор интерфейсов. Обычные интерфейсы для операций добавления, изменения и удаления выбирают строки с удалённого сервера, а затем модифицируют их по одной. В некоторых случаях такой подход «строка за строкой» необходим, но он может быть не самым эффективным. Если есть возможность определить на стороннем сервере, какие строки должны модифицироваться, собственно не считывая их, и если никакие локальные структуры (локальные триггеры уровня строк, хранимые генерируемые столбцы или ограничения <code class="literal">WITH CHECK OPTION</code> из родительских представлений) на эту операцию не влияют, её можно организовать так, чтобы она выполнялась целиком на удалённом сервере. Это позволяют осуществить описанные ниже интерфейсы.</p><pre class="programlisting">bool
PlanDirectModify(PlannerInfo *root,
                 ModifyTable *plan,
                 Index resultRelation,
                 int subplan_index);</pre><p> Определяет, возможно ли безопасно выполнить прямую модификацию на удалённом сервере. Если да, возвращает <code class="literal">true</code>, произведя требуемые для этого операции планирования. В противном случае возвращает <code class="literal">false</code>. Эта необязательная функция вызывается во время планирования запроса. Если результат этой функции положительный, на стадии выполнения будут вызываться <code class="function">BeginDirectModify</code>, <code class="function">IterateDirectModify</code> и <code class="function">EndDirectModify</code>. Иначе модификация таблиц будет осуществляться посредством функций изменения, описанных выше. Данная функция принимает те же параметры, что и <code class="function">PlanForeignModify</code>.</p><p>Для осуществления прямой модификации на удалённом сервере эта функция должна подставить в целевой подплан узел <code class="structname">ForeignScan</code>, выполняющий прямую модификацию на удалённом сервере. Значения полей <code class="structfield">operation</code> и <code class="structfield">resultRelation</code> структуры <code class="structname">ForeignScan</code> должны быть заданы соответствующим образом. В поле <code class="structfield">operation</code> должно быть установлено соответствующее значение перечисления <code class="literal">CmdType</code>: то есть, <code class="literal">CMD_UPDATE</code> для <code class="command">UPDATE</code>, <code class="literal">CMD_INSERT</code> для <code class="command">INSERT</code> и <code class="literal">CMD_DELETE</code> для <code class="command">DELETE</code>; в поле <code class="structfield">resultRelation</code> нужно скопировать аргумент <code class="literal">resultRelation</code>.</p><p>За дополнительными сведениями обратитесь к <a class="xref" href="fdw-planning.html" title="59.4. Планирование запросов с обёртками сторонних данных">Разделу 59.4</a>.</p><p>Если указатель на <code class="function">PlanDirectModify</code> равен <code class="literal">NULL</code>, сервер не будет пытаться произвести прямую модификацию.</p><pre class="programlisting">void
BeginDirectModify(ForeignScanState *node,
                  int eflags);</pre><p> Подготавливает прямую модификацию на удалённом сервере. Эта функция вызывается при запуске исполнителя. Она должна выполнить все подготовительные действия, необходимые для осуществления прямой модификации (модификация должна начаться с первым вызовом <code class="function">IterateDirectModify</code>). Узел <code class="structname">ForeignScanState</code> уже был создан, но его поле <code class="structfield">fdw_state</code> по-прежнему NULL. Информацию о модифицируемой таблице можно получить через узел <code class="structname">ForeignScanState</code> (в частности, из нижележащего узла <code class="structname">ForeignScan</code>, содержащего частную информацию FDW, заданную функцией <code class="function">PlanDirectModify</code>). Параметр <code class="literal">eflags</code> содержит битовые флаги, описывающие режим работы исполнителя для этого узла плана.</p><p>Заметьте, что когда <code class="literal">(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</code> не равно нулю, эта функция не должна выполнять какие-либо внешне проявляющиеся действия; она должна сделать только то, что необходимо для получения состояния узла, подходящего для <code class="function">ExplainDirectModify</code> и <code class="function">EndDirectModify</code>.</p><p>Если указатель на <code class="function">BeginDirectModify</code> равен <code class="literal">NULL</code>, сервер не будет пытаться произвести прямую модификацию.</p><pre class="programlisting">TupleTableSlot *
IterateDirectModify(ForeignScanState *node);</pre><p> Когда в запросе <code class="command">INSERT</code>, <code class="command">UPDATE</code> или <code class="command">DELETE</code> отсутствует предложение <code class="literal">RETURNING</code>, просто возвращает NULL после прямой модификации на удалённом сервере. Когда в запросе есть это предложение, выбирает одну строку результата с данными, требующимися для вычисления <code class="literal">RETURNING</code>, и возвращает её в слоте таблицы кортежей (для этой цели следует использовать <code class="structfield">ScanTupleSlot</code>, переданный с узлом). Данные, которые были фактически добавлены, изменены или удалены, нужно сохранить в <code class="literal">node-&gt;resultRelInfo-&gt;ri_projectReturning-&gt;pi_exprContext-&gt;ecxt_scantuple</code>. Возвращает NULL, если строк больше нет. Заметьте, что эта функция вызывается в контексте кратковременной памяти, который будет сбрасываться между вызовами. Если вам нужна более долгоживущая память, создайте соответствующий контекст в <code class="function">BeginDirectModify</code> либо используйте <code class="structfield">es_query_cxt</code> из переданной с узлом структуры <code class="structname">EState</code>.</p><p>Возвращаемые строки должны соответствовать целевому списку <code class="structfield">fdw_scan_tlist</code>, если он передаётся, а в противном случае — типу строки изменяемой сторонней таблицы. Если вы решите для оптимизации не возвращать ненужные столбцы, не требующиеся для получения <code class="literal">RETURNING</code>, в их позиции нужно вставить NULL, либо сформировать список <code class="structfield">fdw_scan_tlist</code> без этих столбцов.</p><p>Независимо от того, есть ли в запросе это предложение или нет, число строк, возвращаемых запросом, должно увеличиваться самой FDW. Когда этого предложения в запросе нет, FDW должна также увеличивать число строк для узла <code class="structname">ForeignScanState</code> в случае <code class="command">EXPLAIN ANALYZE</code>.</p><p>Если указатель на <code class="function">IterateDirectModify</code> равен <code class="literal">NULL</code>, сервер не будет пытаться произвести прямую модификацию.</p><pre class="programlisting">void
EndDirectModify(ForeignScanState *node);</pre><p> Очищает ресурсы после непосредственной модификации на удалённом сервере. Обычно при этом не нужно освобождать память, выделенную через palloc, но например, открытые файлы и подключения к удалённому серверу следует закрыть.</p><p>Если указатель на <code class="function">EndDirectModify</code> равен <code class="literal">NULL</code>, сервер не будет пытаться произвести прямую модификацию.</p></div><div class="sect2" id="FDW-CALLBACKS-TRUNCATE"><div class="titlepage"><div><div><h3 class="title">59.2.5. Подпрограммы FDW для <code class="command">TRUNCATE</code> <a href="#FDW-CALLBACKS-TRUNCATE" class="id_link">#</a></h3></div></div></div><pre class="programlisting">void
ExecForeignTruncate(List *rels,
                    DropBehavior behavior,
                    bool restart_seqs);</pre><p> Опустошает сторонние таблицы. Эта функция вызывается, когда для сторонней таблицы выполняется <a class="xref" href="sql-truncate.html" title="TRUNCATE"><span class="refentrytitle">TRUNCATE</span></a>. В <code class="literal">rels</code> передаётся список структур <code class="structname">Relation</code>, описывающих сторонние таблицы, подлежащие опустошению.</p><p>Значением <code class="literal">behavior</code> может быть либо <code class="literal">DROP_RESTRICT</code>, либо <code class="literal">DROP_CASCADE</code>, в зависимости от того, какое указание (<code class="literal">RESTRICT</code> или <code class="literal">CASCADE</code>, соответственно) присутствовало в исходной команде <code class="command">TRUNCATE</code>.</p><p>Если <code class="literal">restart_seqs</code> имеет значение <code class="literal">true</code>, в исходной команде <code class="command">TRUNCATE</code> было запрошено поведение <code class="literal">RESTART IDENTITY</code>, в противном случае было запрошено поведение <code class="literal">CONTINUE IDENTITY</code>.</p><p>Заметьте, что параметры <code class="literal">ONLY</code>, указанные в исходной команде <code class="command">TRUNCATE</code>, не передаются в функцию <code class="function">ExecForeignTruncate</code>. Подобным образом работают функции-обработчики <code class="command">SELECT</code>, <code class="command">UPDATE</code> и <code class="command">DELETE</code> для сторонней таблицы.</p><p><code class="function">ExecForeignTruncate</code> вызывается отдельно для каждого стороннего сервера, на котором должны опустошаться сторонние таблицы. Это означает, что все сторонние таблицы, включённые в <code class="literal">rels</code>, должны относиться к одному серверу.</p><p>Если указатель на <code class="function">ExecForeignTruncate</code> равен <code class="literal">NULL</code>, опустошить данные в сторонней таблице не удастся, а в ответ будет выдаваться сообщение об ошибке.</p></div><div class="sect2" id="FDW-CALLBACKS-ROW-LOCKING"><div class="titlepage"><div><div><h3 class="title">59.2.6. Подпрограммы FDW для блокировки строк <a href="#FDW-CALLBACKS-ROW-LOCKING" class="id_link">#</a></h3></div></div></div><p>Если FDW желает поддержать функцию <em class="firstterm">поздней блокировки строк</em> (описанную в <a class="xref" href="fdw-row-locking.html" title="59.5. Блокировка строк в обёртках сторонних данных">Разделе 59.5</a>), она должна предоставить следующие реализующие подпрограммы:</p><pre class="programlisting">RowMarkType
GetForeignRowMarkType(RangeTblEntry *rte,
                      LockClauseStrength strength);</pre><p> Сообщает, какой вариант пометки строк будет использоваться для сторонней таблицы. Здесь <code class="literal">rte</code> представляет узел <code class="structname">RangeTblEntry</code> для таблицы, а <code class="literal">strength</code> описывает силу блокировки, запрошенную соответствующим предложением <code class="literal">FOR UPDATE/SHARE</code>, если оно имеется. Результатом должно быть значение перечисления <code class="literal">RowMarkType</code>.</p><p>Эта функция вызывается в процессе планирования запроса для каждой сторонней таблицы, которая участвует в запросе <code class="command">UPDATE</code>, <code class="command">DELETE</code> или <code class="command">SELECT FOR UPDATE/SHARE</code>, и не является целевой в запросе <code class="command">UPDATE</code> или <code class="command">DELETE</code>.</p><p>Если указатель <code class="function">GetForeignRowMarkType</code> равен <code class="literal">NULL</code>, всегда выбирается вариант <code class="literal">ROW_MARK_COPY</code>. (Вследствие этого, функция <code class="function">RefetchForeignRow</code> никогда не будет вызываться, так что и её задавать не нужно.)</p><p>За подробностями обратитесь к <a class="xref" href="fdw-row-locking.html" title="59.5. Блокировка строк в обёртках сторонних данных">Разделу 59.5</a>.</p><pre class="programlisting">void
RefetchForeignRow(EState *estate,
                  ExecRowMark *erm,
                  Datum rowid,
                  TupleTableSlot *slot,
                  bool *updated);</pre><p> Повторно считывает один кортеж из сторонней таблицы после блокировки, если она требуется. В <code class="literal">estate</code> передаётся глобальное состояние выполнения запроса. В <code class="literal">erm</code> передаётся структура <code class="structname">ExecRowMark</code>, описывающая целевую стороннюю таблицу и тип запрашиваемой блокировки (если она требуется). В параметре <code class="literal">slot</code> при вызове не содержится ничего полезного, но в него можно поместить возвращаемый кортеж. Параметр <code class="literal">updated</code> является выходным.</p><p>Эта функция должна сохранить кортеж в переданном слоте или очистить его, если получить блокировку строки не удаётся. Тип запрашиваемой блокировки строки определяется значением <code class="literal">erm-&gt;markType</code>, которое было до этого возвращено функцией <code class="function">GetForeignRowMarkType</code>. (Вариант <code class="literal">ROW_MARK_REFERENCE</code> означает, что нужно просто повторно выбрать кортеж, не запрашивая никакую блокировку, а <code class="literal">ROW_MARK_COPY</code> никогда не поступает в эту подпрограмму.)</p><p>Кроме того, переменной <code class="literal">*updated</code> следует присвоить <code class="literal">true</code>, если была считана изменённая версия кортежа, а не версия, полученная ранее. (Если FDW не знает этого наверняка, рекомендуется всегда возвращать <code class="literal">true</code>.)</p><p>Заметьте, что по умолчанию в случае неудачи при попытке получить блокировку строки должна выдаваться ошибка; пустой слот может возвращаться, только если в <code class="literal">erm-&gt;waitPolicy</code> выбран вариант <code class="literal">SKIP LOCKED</code>.</p><p>В <code class="literal">rowid</code> передаётся значение <code class="structfield">ctid</code>, полученное ранее для строки, которую нужно считать повторно. Хотя значение <code class="literal">rowid</code> передаётся в виде <code class="type">Datum</code>, в настоящее время это может быть только <code class="type">tid</code>. Такой интерфейс функции выбран с расчётом на то, чтобы в будущем в качестве идентификаторов строк могли приниматься и другие типы данных.</p><p>Если указатель на <code class="function">RefetchForeignRow</code> равен <code class="literal">NULL</code>, повторно выбрать данные не удастся, в ответ будет выдаваться сообщение об ошибке.</p><p>За подробностями обратитесь к <a class="xref" href="fdw-row-locking.html" title="59.5. Блокировка строк в обёртках сторонних данных">Разделу 59.5</a>.</p><pre class="programlisting">bool
RecheckForeignScan(ForeignScanState *node,
                   TupleTableSlot *slot);</pre><p> Перепроверяет, соответствует ли по-прежнему ранее возвращённый кортеж применимым условиям сканирования и соединения, и возможно выдаёт изменённую версию кортежа. Для обёрток сторонних данных, которые не выносят соединение наружу, обычно удобнее присвоить этому указателю <code class="literal">NULL</code> и задать <code class="structfield">fdw_recheck_quals</code>. Однако когда внешние соединения выносятся наружу, недостаточно повторно применить к результирующему кортежу проверки, относящиеся ко всем базовым таблицам, даже если присутствуют все атрибуты, так как невыполнение некоторого условия может приводить и к обнулению некоторых атрибутов, а не только исключению этого кортежа. <code class="literal">RecheckForeignScan</code> может перепроверить условия и возвратить true, если они по-прежнему выполняются, или false в противном случае, но также она может записать в переданный слот кортеж на замену предыдущему.</p><p>Чтобы вынести соединение наружу, обёртка сторонних данных обычно конструирует альтернативный план локального соединения, применяемый только для перепроверок; он становится внешним подпланом узла <code class="literal">ForeignScan</code>. Когда требуется перепроверка, может быть выполнен этот подплан и результирующий кортеж сохранён в слоте. Этот план может не быть эффективным, так как ни одна базовая таблица не выдаст больше одной строки; например, он может реализовывать все соединения в виде вложенных циклов. Для поиска подходящего локального пути соединения в существующих путях можно воспользоваться функцией <code class="literal">GetExistingLocalJoinPath</code>. Функция <code class="literal">GetExistingLocalJoinPath</code> ищет непараметризованный путь в списке путей заданного отношения соединения. (Если такой путь не находится, она возвращает NULL, и в этом случае обёртка сторонних данных может построить локальный путь сама или решить не создавать пути доступа для этого соединения.)</p></div><div class="sect2" id="FDW-CALLBACKS-EXPLAIN"><div class="titlepage"><div><div><h3 class="title">59.2.7. Подпрограммы FDW для <code class="command">EXPLAIN</code> <a href="#FDW-CALLBACKS-EXPLAIN" class="id_link">#</a></h3></div></div></div><pre class="programlisting">void
ExplainForeignScan(ForeignScanState *node,
                   ExplainState *es);</pre><p> Дополняет вывод <code class="command">EXPLAIN</code> для сканирования сторонней таблицы. Эта функция может вызывать <code class="function">ExplainPropertyText</code> и связанные функции и добавлять поля в вывод <code class="command">EXPLAIN</code>. Поля флагов в <code class="literal">es</code> позволяют определить, что именно выводить, а для выдачи статистики времени выполнения в случае с <code class="command">EXPLAIN ANALYZE</code> можно проанализировать состояние узла <code class="structname">ForeignScanState</code>.</p><p>Если указатель <code class="function">ExplainForeignScan</code> равен <code class="literal">NULL</code>, никакая дополнительная информация при <code class="command">EXPLAIN</code> не выводится.</p><pre class="programlisting">void
ExplainForeignModify(ModifyTableState *mtstate,
                     ResultRelInfo *rinfo,
                     List *fdw_private,
                     int subplan_index,
                     struct ExplainState *es);</pre><p> Дополняет вывод <code class="command">EXPLAIN</code> для изменений в сторонней таблице. Эта функция может вызывать <code class="function">ExplainPropertyText</code> и связанные функции и добавлять поля в вывод <code class="command">EXPLAIN</code>. Поля флагов в <code class="literal">es</code> позволяют определить, что именно выводить, а для выдачи статистики времени выполнения в случае с <code class="command">EXPLAIN ANALYZE</code> можно проанализировать состояние узла <code class="structname">ModifyTableState</code>. Первые четыре аргумента у этой функции те же, что и у <code class="function">BeginForeignModify</code>.</p><p>Если указатель <code class="function">ExplainForeignModify</code> равен <code class="literal">NULL</code>, никакая дополнительная информация при <code class="command">EXPLAIN</code> не выводится.</p><pre class="programlisting">void
ExplainDirectModify(ForeignScanState *node,
                    ExplainState *es);</pre><p> Дополняет вывод <code class="command">EXPLAIN</code> для прямой модификации данных на удалённом сервере. Эта функция может вызывать <code class="function">ExplainPropertyText</code> и связанные функции и добавлять поля в вывод <code class="command">EXPLAIN</code>. Поля флагов в <code class="literal">es</code> позволяют определить, что именно выводить, а для выдачи статистики времени выполнения в случае <code class="command">EXPLAIN ANALYZE</code> можно проанализировать состояние узла <code class="structname">ForeignScanState</code>.</p><p>Если указатель <code class="function">ExplainDirectModify</code> равен <code class="literal">NULL</code>, никакая дополнительная информация при <code class="command">EXPLAIN</code> не выводится.</p></div><div class="sect2" id="FDW-CALLBACKS-ANALYZE"><div class="titlepage"><div><div><h3 class="title">59.2.8. Подпрограммы FDW для <code class="command">ANALYZE</code> <a href="#FDW-CALLBACKS-ANALYZE" class="id_link">#</a></h3></div></div></div><pre class="programlisting">bool
AnalyzeForeignTable(Relation relation,
                    AcquireSampleRowsFunc *func,
                    BlockNumber *totalpages);</pre><p> Эта функция вызывается, когда для сторонней таблицы выполняется <a class="xref" href="sql-analyze.html" title="ANALYZE"><span class="refentrytitle">ANALYZE</span></a>. Если FDW может собрать статистику для этой сторонней таблицы, эта функция должна вернуть <code class="literal">true</code> и передать в <em class="parameter"><code>func</code></em> указатель на функцию, которая будет выдавать строки выборки из таблицы, а в <em class="parameter"><code>totalpages</code></em> ожидаемый размер таблицы в страницах. В противном случае эта функция должна вернуть <code class="literal">false</code>.</p><p>Если FDW не поддерживает сбор статистики ни для каких таблиц, в <code class="function">AnalyzeForeignTable</code> можно установить значение <code class="literal">NULL</code>.</p><p>Функция выдачи выборки, если она предоставляется, должна иметь следующую сигнатуру: </p><pre class="programlisting">int
AcquireSampleRowsFunc(Relation relation,
                      int elevel,
                      HeapTuple *rows,
                      int targrows,
                      double *totalrows,
                      double *totaldeadrows);</pre><p> Она должна выбирать из таблицы максимум <em class="parameter"><code>targrows</code></em> строк и помещать их в переданный вызывающим кодом массив <em class="parameter"><code>rows</code></em>. Возвращать она должна фактическое число выбранных строк. Кроме того, эта функция должна сохранить общее количество актуальных и «мёртвых»строк в таблице в выходных параметрах <em class="parameter"><code>totalrows</code></em> и <em class="parameter"><code>totaldeadrows</code></em>, соответственно. (Если для данной FDW нет понятия «мёртвых» строк, в <em class="parameter"><code>totaldeadrows</code></em> нужно записать 0.)</p></div><div class="sect2" id="FDW-CALLBACKS-IMPORT"><div class="titlepage"><div><div><h3 class="title">59.2.9. Подпрограммы FDW для <code class="command">IMPORT FOREIGN SCHEMA</code> <a href="#FDW-CALLBACKS-IMPORT" class="id_link">#</a></h3></div></div></div><pre class="programlisting">List *
ImportForeignSchema(ImportForeignSchemaStmt *stmt, Oid serverOid);</pre><p> Получает список команд, создающих сторонние таблицы. Эта функция вызывается при выполнении команды <a class="xref" href="sql-importforeignschema.html" title="IMPORT FOREIGN SCHEMA"><span class="refentrytitle">IMPORT FOREIGN SCHEMA</span></a>; ей передаётся дерево разбора этого оператора и OID целевого стороннего сервера. Она должна вернуть набор строк C, в каждой из которых должна содержаться команда <a class="xref" href="sql-createforeigntable.html" title="CREATE FOREIGN TABLE"><span class="refentrytitle">CREATE FOREIGN TABLE</span></a>. Эти строки будут разобраны и выполнены ядром сервера.</p><p>В структуре <code class="structname">ImportForeignSchemaStmt</code> поле <code class="structfield">remote_schema</code> задаёт имя удалённой схемы, из которой импортируются таблицы. Поле <code class="structfield">list_type</code> устанавливает, как фильтровать имена таблиц: вариант <code class="literal">FDW_IMPORT_SCHEMA_ALL</code> означает, что нужно импортировать все таблицы в удалённой схеме (в этом случае поле <code class="structfield">table_list</code> пустое), <code class="literal">FDW_IMPORT_SCHEMA_LIMIT_TO</code> означает, что нужно импортировать только таблицы, перечисленные в <code class="structfield">table_list</code>, и <code class="literal">FDW_IMPORT_SCHEMA_EXCEPT</code> означает, что нужно исключить таблицы, перечисленные в списке <code class="structfield">table_list</code>. В поле <code class="structfield">options</code> передаётся список параметров для процесса импорта. Значение этих параметров определяется самой FDW. Например, у FDW может быть параметр, определяющий, нужно ли сохранять у импортируемых столбцов атрибут <code class="literal">NOT NULL</code>. Эти параметры могут не иметь ничего общего с параметрами, которые принимает FDW в качестве параметров объектов базы.</p><p>FDW может игнорировать поле <code class="structfield">local_schema</code> в <code class="structname">ImportForeignSchemaStmt</code>, так как ядро сервера само вставит это имя в разобранные команды <code class="command">CREATE FOREIGN TABLE</code>.</p><p>Также, FDW может не выполнять сама фильтрацию по полям <code class="structfield">list_type</code> и <code class="structfield">table_list</code>, так как ядро сервера автоматически пропустит все возвращённые команды для таблиц, исключённых по заданным критериям. Однако часто лучше сразу избежать лишней работы, не формируя команды для исключаемых таблиц. Для проверки, удовлетворяет ли фильтру заданное имя сторонней таблицы, может быть полезна функция <code class="function">IsImportableForeignTable()</code>.</p><p>Если FDW не поддерживает импорт определений таблиц, указателю <code class="function">ImportForeignSchema</code> можно присвоить <code class="literal">NULL</code>.</p></div><div class="sect2" id="FDW-CALLBACKS-PARALLEL"><div class="titlepage"><div><div><h3 class="title">59.2.10. Подпрограммы FDW для параллельного выполнения <a href="#FDW-CALLBACKS-PARALLEL" class="id_link">#</a></h3></div></div></div><p>Узел <code class="structname">ForeignScan</code> может, хотя это не требуется, поддерживать параллельное выполнение. Параллельный <code class="structname">ForeignScan</code> будет выполняться в нескольких процессах и должен возвращать одну строку только единожды. Для этого взаимодействующие процессы могут координировать свои действия через фиксированного размера блоки в динамической разделяемой памяти. Эта разделяемая память не будет гарантированно отображаться по одному адресу в разных процессах, так что она не может содержать указатели. Все следующие функции являются необязательными, но большинство из них необходимы при реализации поддержки параллельного выполнения.</p><pre class="programlisting">bool
IsForeignScanParallelSafe(PlannerInfo *root, RelOptInfo *rel,
                          RangeTblEntry *rte);</pre><p> Проверяет, будет ли сканирование выполняться параллельным исполнителем. Эта функция будет вызываться, только когда планировщик считает, что параллельный план принципиально возможен, и должна возвращать true, если такое сканирование может безопасно выполняться параллельным исполнителем. Обычно это не так, если удалённый источник данных является транзакционным. Но возможно исключение, когда в подключении рабочего процесса к этому источнику каким-то образом используется тот же транзакционный контекст, что и в ведущем процессе.</p><p>Если эта функция не определена, считается, что сканирование должно происходить в ведущем процессе. Заметьте, что возвращённое значение true не означает, что само сканирование может выполняться в параллельном режиме, а только то, что сканирование будет производится в параллельном исполнителе. Таким образом, может быть полезно определить этот обработчик, даже если параллельное выполнение не поддерживается.</p><pre class="programlisting">Size
EstimateDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt);</pre><p> Оценивает объём динамической разделяемой памяти, которая потребуется для параллельной операции. Это значение может превышать объём, который будет занят фактически, но не должно быть меньше. Возвращаемое значение задаётся в байтах. Эта функция является необязательной и может быть опущена, если не требуется; но в этом случае должны быть также опущены следующие три функции, так как для FDW не будет выделена разделяемая память.</p><pre class="programlisting">void
InitializeDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt,
                         void *coordinate);</pre><p> Инициализирует динамическую разделяемую память, которая потребуется для параллельной операции. <code class="literal">coordinate</code> указывает на область разделяемой памяти размера, равного возвращаемому значению <code class="function">EstimateDSMForeignScan</code>. Эта функция является необязательной и может быть опущена, если не требуется.</p><pre class="programlisting">void
ReInitializeDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt,
                           void *coordinate);</pre><p> Заново инициализирует динамическую разделяемую память, требуемую для параллельной операции, перед тем как будет повторно просканирован узел чтения сторонних данных. Эта функция является необязательной и может быть опущена, если не требуется. В этой функции рекомендуется сбрасывать только общее состояние, а в функции <code class="function">ReScanForeignScan</code> сбрасывать только локальное. В настоящее время эта функция будет вызываться перед <code class="function">ReScanForeignScan</code>, но лучше на этот порядок не рассчитывать.</p><pre class="programlisting">void
InitializeWorkerForeignScan(ForeignScanState *node, shm_toc *toc,
                            void *coordinate);</pre><p> Инициализирует локальное состояние параллельного исполнителя на основе общего состояния, заданного ведущим исполнителем во время <code class="function">InitializeDSMForeignScan</code>. Эта функция является необязательной и может быть опущена, если не требуется.</p><pre class="programlisting">void
ShutdownForeignScan(ForeignScanState *node);</pre><p> Освобождает ресурсы, когда становится понятно, что этот узел больше не будет выполняться. Этот обработчик вызывается не во всех случаях; иногда может вызываться только <code class="literal">EndForeignScan</code>. Так как сегмент DSM, используемый параллельным запросом, освобождается сразу после вызова этого обработчика, обёртки сторонних данных, которым нужно выполнять некоторые действия до ликвидации сегмента DSM, должны реализовывать этот метод.</p></div><div class="sect2" id="FDW-CALLBACKS-ASYNC"><div class="titlepage"><div><div><h3 class="title">59.2.11. Подпрограммы FDW для асинхронного выполнения <a href="#FDW-CALLBACKS-ASYNC" class="id_link">#</a></h3></div></div></div><p>Узел <code class="structname">ForeignScan</code> может дополнительно поддерживать асинхронное выполнение, как описано в файле <code class="filename">src/backend/executor/README</code>. Перечисленные ниже функции являются необязательными, но все они нужны для обеспечения поддержки асинхронного выполнения.</p><pre class="programlisting">bool
IsForeignPathAsyncCapable(ForeignPath *path);</pre><p> Проверяет, возможно ли для данного пути <code class="structname">ForeignPath</code> асинхронное сканирование нижележащего стороннего отношения. Эта функция будет вызываться только в конце планирования запроса, если данный путь является прямым потомком пути <code class="structname">AppendPath</code> и когда планировщик считает, что асинхронное выполнение улучшает производительность. Если для данного пути возможно асинхронное сканирование, эта функция должна возвращать true.</p><p>Если эта функция не определена, предполагается, что для данного пути стороннее отношение сканируется с помощью функции <code class="function">IterateForeignScan</code>. (Это означает, что функции обратного вызова, описанные ниже, никогда не будут вызываться, поэтому их также не нужно задавать.)</p><pre class="programlisting">void
ForeignAsyncRequest(AsyncRequest *areq);</pre><p> Асинхронно выдаёт один кортеж из узла <code class="structname">ForeignScan</code>. <code class="literal">areq</code> — это структура <code class="structname">AsyncRequest</code>, описывающая узел <code class="structname">ForeignScan</code> и родительский узел <code class="structname">Append</code>, запросивший у него кортеж. Эта функция должна поместить кортеж в слот, переданный в <code class="literal">areq-&gt;result</code>, и записать <code class="literal">true</code> в <code class="literal">areq-&gt;request_complete</code>, если кортеж готов. Если же он ещё не готов и необходимо дождаться внешнего по отношению к главному серверу события, например получения данных из сети, эта функция должна записать <code class="literal">false</code> в <code class="literal">areq-&gt;request_complete</code> и <code class="literal">true</code> в <code class="literal">areq-&gt;callback_pending</code>, чтобы для узла <code class="structname">ForeignScan</code> были вызваны описанные ниже функции-обработчики. Если кортежей больше нет, нужно передать в качестве слота NULL или пустой слот, а в <code class="literal">areq-&gt;request_complete</code> записать <code class="literal">true</code>. Для формирования выходных параметров в <code class="literal">areq</code> рекомендуется использовать функцию <code class="function">ExecAsyncRequestDone</code> или <code class="function">ExecAsyncRequestPending</code>.</p><pre class="programlisting">void
ForeignAsyncConfigureWait(AsyncRequest *areq);</pre><p> Настраивает событие файлового дескриптора, которого хочет дождаться узел <code class="structname">ForeignScan</code>. Эта функция будет вызываться, только когда <code class="structname">ForeignScan</code> установил флаг <code class="literal">areq-&gt;callback_pending</code>, и должна добавить событие в набор <code class="structfield">as_eventset</code> родительского узла <code class="structname">Append</code>, описываемого параметром <code class="literal">areq</code>. См. комментарии к функции <code class="function">ExecAsyncConfigureWait</code> в файле <code class="filename">src/backend/executor/execAsync.c</code> для получения дополнительной информации. Когда произойдёт событие файлового дескриптора, будет вызвана функция <code class="function">ForeignAsyncNotify</code>.</p><pre class="programlisting">void
ForeignAsyncNotify(AsyncRequest *areq);</pre><p> Обрабатывает соответствующее произошедшее событие, затем асинхронно выдаёт один кортеж из узла <code class="structname">ForeignScan</code>. Эта функция должна устанавливать выходные параметры в <code class="literal">areq</code> так же, как это делает функция <code class="function">ForeignAsyncRequest</code>.</p></div><div class="sect2" id="FDW-CALLBACKS-REPARAMETERIZE-PATHS"><div class="titlepage"><div><div><h3 class="title">59.2.12. Подпрограммы FDW для изменения параметризации путей <a href="#FDW-CALLBACKS-REPARAMETERIZE-PATHS" class="id_link">#</a></h3></div></div></div><pre class="programlisting">List *
ReparameterizeForeignPathByChild(PlannerInfo *root, List *fdw_private,
                                 RelOptInfo *child_rel);</pre><p> Эта функция вызывается при преобразовании пути, параметризованного самым верхним родителем данного дочернего отношения <code class="literal">child_rel</code>, в путь, параметризованный дочерним отношением. Она используется для изменения параметров любых путей или трансляции любых узлов выражений, сохранённых в поле <code class="literal">fdw_private</code> переданной структуры <code class="structname">ForeignPath</code>. Этот обработчик может по мере необходимости использовать <code class="literal">reparameterize_path_by_child</code>, <code class="literal">adjust_appendrel_attrs</code> или <code class="literal">adjust_appendrel_attrs_multilevel</code>.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="fdw-functions.html" title="59.1. Функции обёрток сторонних данных">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="fdwhandler.html" title="Глава 59. Написание обёртки сторонних данных">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="fdw-helpers.html" title="59.3. Вспомогательные функции для обёрток сторонних данных">След.</a></td></tr><tr><td width="40%" align="left" valign="top">59.1. Функции обёрток сторонних данных </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 59.3. Вспомогательные функции для обёрток сторонних данных</td></tr></table></div></body></html>