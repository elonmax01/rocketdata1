<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>36.8. Обработка ошибок</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="ecpg-descriptors.html" title="36.7. Использование областей дескрипторов" /><link rel="next" href="ecpg-preproc.html" title="36.9. Директивы препроцессора" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">36.8. Обработка ошибок</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="ecpg-descriptors.html" title="36.7. Использование областей дескрипторов">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="ecpg.html" title="Глава 36. ECPG — Встраиваемый SQL в C">Наверх</a></td><th width="60%" align="center">Глава 36. <span class="application">ECPG</span> — Встраиваемый <acronym class="acronym">SQL</acronym> в C</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="ecpg-preproc.html" title="36.9. Директивы препроцессора">След.</a></td></tr></table><hr /></div><div class="sect1" id="ECPG-ERRORS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">36.8. Обработка ошибок <a href="#ECPG-ERRORS" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="ecpg-errors.html#ECPG-WHENEVER">36.8.1. Установка обработчиков</a></span></dt><dt><span class="sect2"><a href="ecpg-errors.html#ECPG-SQLCA">36.8.2. sqlca</a></span></dt><dt><span class="sect2"><a href="ecpg-errors.html#ECPG-SQLSTATE-SQLCODE">36.8.3. <code class="literal">SQLSTATE</code> и <code class="literal">SQLCODE</code></a></span></dt></dl></div><p>В этом разделе описывается, как можно обрабатывать исключительные условия и предупреждения в программе со встраиваемым SQL. Для этого предназначены два средства, которые могут дополнять друг друга. </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Можно настроить функции-обработчики для обработки предупреждений и ошибок, воспользовавшись командой <code class="literal">WHENEVER</code>.</li><li class="listitem">Подробную информацию об ошибке или предупреждении можно получить через переменную <code class="varname">sqlca</code>.</li></ul></div><div class="sect2" id="ECPG-WHENEVER"><div class="titlepage"><div><div><h3 class="title">36.8.1. Установка обработчиков <a href="#ECPG-WHENEVER" class="id_link">#</a></h3></div></div></div><p>Один простой метод перехвата ошибок и предупреждений заключается в назначении определённого действия, которое будет выполняться при некотором условии. В общем виде: </p><pre class="programlisting">EXEC SQL WHENEVER <em class="replaceable"><code>условие</code></em> <em class="replaceable"><code>действие</code></em>;</pre><p>Здесь <em class="replaceable"><code>условие</code></em> может быть следующим: </p><div class="variablelist"><dl class="variablelist"><dt id="ECPG-WHENEVER-SQLERROR"><span class="term"><code class="literal">SQLERROR</code></span> <a href="#ECPG-WHENEVER-SQLERROR" class="id_link">#</a></dt><dd><p>Указанное действие вызывается, когда при выполнении SQL-оператора происходит ошибка.</p></dd><dt id="ECPG-WHENEVER-SQLWARNING"><span class="term"><code class="literal">SQLWARNING</code></span> <a href="#ECPG-WHENEVER-SQLWARNING" class="id_link">#</a></dt><dd><p>Указанное действие вызывается, когда при выполнении SQL-оператора выдаётся предупреждение.</p></dd><dt id="ECPG-WHENEVER-NOT-FOUND"><span class="term"><code class="literal">NOT FOUND</code></span> <a href="#ECPG-WHENEVER-NOT-FOUND" class="id_link">#</a></dt><dd><p>Указанное действие вызывается, когда SQL-оператор получает или обрабатывает ноль строк. (Это обстоятельство не считается ошибкой, но бывает полезно отследить его.)</p></dd></dl></div><p><em class="replaceable"><code>действие</code></em> может быть следующим: </p><div class="variablelist"><dl class="variablelist"><dt id="ECPG-WHENEVER-CONTINUE"><span class="term"><code class="literal">CONTINUE</code></span> <a href="#ECPG-WHENEVER-CONTINUE" class="id_link">#</a></dt><dd><p>Это фактически означает, что условие игнорируется. Это поведение по умолчанию.</p></dd><dt id="ECPG-WHENEVER-GOTO"><span class="term"><code class="literal">GOTO <em class="replaceable"><code>метка</code></em></code><br /></span><span class="term"><code class="literal">GO TO <em class="replaceable"><code>метка</code></em></code></span> <a href="#ECPG-WHENEVER-GOTO" class="id_link">#</a></dt><dd><p>Перейти к указанной метке (используя оператор <code class="literal">goto</code> языка C).</p></dd><dt id="ECPG-WHENEVER-SQLPRINT"><span class="term"><code class="literal">SQLPRINT</code></span> <a href="#ECPG-WHENEVER-SQLPRINT" class="id_link">#</a></dt><dd><p>Вывести сообщение в устройство стандартного вывода. Это полезно для простых программ или при разработке прототипов. Содержание этого сообщения не настраивается.</p></dd><dt id="ECPG-WHENEVER-STOP"><span class="term"><code class="literal">STOP</code></span> <a href="#ECPG-WHENEVER-STOP" class="id_link">#</a></dt><dd><p>Вызвать <code class="literal">exit(1)</code>, что приведёт к завершению программы.</p></dd><dt id="ECPG-WHENEVER-DO-BREAK"><span class="term"><code class="literal">DO BREAK</code></span> <a href="#ECPG-WHENEVER-DO-BREAK" class="id_link">#</a></dt><dd><p>Выполнить оператор <code class="literal">break</code> языка C. Этот вариант следует использовать только в циклах или операторах <code class="literal">switch</code>.</p></dd><dt id="ECPG-WHENEVER-DO-CONTINUE"><span class="term"><code class="literal">DO CONTINUE</code></span> <a href="#ECPG-WHENEVER-DO-CONTINUE" class="id_link">#</a></dt><dd><p>Выполнить оператор <code class="literal">continue</code> языка C. Этот вариант следует использовать только в циклах. Данный оператор передаёт управление в начало цикла.</p></dd><dt id="ECPG-WHENEVER-CALL"><span class="term"><code class="literal">CALL <em class="replaceable"><code>имя</code></em> (<em class="replaceable"><code>аргументы</code></em>)</code><br /></span><span class="term"><code class="literal">DO <em class="replaceable"><code>имя</code></em> (<em class="replaceable"><code>аргументы</code></em>)</code></span> <a href="#ECPG-WHENEVER-CALL" class="id_link">#</a></dt><dd><p>Вызвать указанные функции C с заданными аргументами. (Эти вызовы имеют смысловые отличия от <code class="literal">CALL</code> и <code class="literal">DO</code> в обычной грамматике PostgreSQL.)</p></dd></dl></div><p> В стандарте SQL описаны только действия <code class="literal">CONTINUE</code> и <code class="literal">GOTO</code> (и <code class="literal">GO TO</code>).</p><p>Ниже показан простой пример использования этих команд. Эта конструкция выводит простое сообщение при выдаче предупреждения и прерывает программу в случае ошибки: </p><pre class="programlisting">EXEC SQL WHENEVER SQLWARNING SQLPRINT;
EXEC SQL WHENEVER SQLERROR STOP;</pre><p>Оператор <code class="literal">EXEC SQL WHENEVER</code> является директивой препроцессора SQL, а не оператором языка C. Устанавливаемое им действие при ошибках или предупреждениях применяется ко всем встраиваемым SQL-операторам ниже точки, где устанавливается обработчик, если только это действие не было изменено после первой команды <code class="literal">EXEC SQL WHENEVER</code>, и до SQL-оператора, вызвавшего это условие, вне зависимости от хода выполнения программы на C. Поэтому обе следующие программы на C не дадут желаемого эффекта: </p><pre class="programlisting">/*
 * НЕПРАВИЛЬНО
 */
int main(int argc, char *argv[])
{
    ...
    if (verbose) {
        EXEC SQL WHENEVER SQLWARNING SQLPRINT;
    }
    ...
    EXEC SQL SELECT ...;
    ...
}</pre><p> </p><pre class="programlisting">/*
 * НЕПРАВИЛЬНО
 */
int main(int argc, char *argv[])
{
    ...
    set_error_handler();
    ...
    EXEC SQL SELECT ...;
    ...
}

static void set_error_handler(void)
{
    EXEC SQL WHENEVER SQLERROR STOP;
}</pre></div><div class="sect2" id="ECPG-SQLCA"><div class="titlepage"><div><div><h3 class="title">36.8.2. sqlca <a href="#ECPG-SQLCA" class="id_link">#</a></h3></div></div></div><p>Для более гибкой обработки ошибок в интерфейсе встраиваемого SQL представлена глобальная переменная с именем <code class="varname">sqlca</code> (SQL Communication Area, Область сведений SQL), имеющая следующую структуру: </p><pre class="programlisting">struct
{
    char sqlcaid[8];
    long sqlabc;
    long sqlcode;
    struct
    {
        int sqlerrml;
        char sqlerrmc[SQLERRMC_LEN];
    } sqlerrm;
    char sqlerrp[8];
    long sqlerrd[6];
    char sqlwarn[8];
    char sqlstate[5];
} sqlca;</pre><p> (В многопоточной программе каждый поток автоматически получает собственную копию <code class="varname">sqlca</code>. Это работает подобно стандартной в C глобальной переменной <code class="varname">errno</code>.)</p><p>Структура <code class="varname">sqlca</code> покрывает и предупреждения, и ошибки. Если в процессе выполнения оператора выдаётся несколько предупреждений или ошибок, <code class="varname">sqlca</code> будет содержать сведения только о последнем(ей) из них.</p><p>Если последний оператор <acronym class="acronym">SQL</acronym> выполняется без ошибки, <code class="literal">sqlca.sqlcode</code> будет содержать 0, а <code class="literal">sqlca.sqlstate</code> — <code class="literal">"00000"</code>. Если выдаётся предупреждение или ошибка, в <code class="literal">sqlca.sqlcode</code> будет содержаться отрицательное число, а <code class="literal">sqlca.sqlstate</code> будет отличаться от <code class="literal">"00000"</code>. Положительное значение <code class="literal">sqlca.sqlcode</code> устанавливается при нейтральном событии, например, когда последний запрос возвращает ноль строк. Поля <code class="literal">sqlcode</code> и <code class="literal">sqlstate</code> представляют две различные схемы кодов ошибок; подробнее они описаны ниже.</p><p>Если последний SQL-оператор был успешным, в <code class="literal">sqlca.sqlerrd[1]</code> содержится OID обработанной строки (если это уместно), а в <code class="literal">sqlca.sqlerrd[2]</code> количество обработанных или возвращённых строк (если это уместно для команды).</p><p>В случае ошибки или предупреждения <code class="literal">sqlca.sqlerrm.sqlerrmc</code> будет содержать строку, описывающую ошибку. Поле <code class="literal">sqlca.sqlerrm.sqlerrml</code> содержит длину сообщения об ошибке, которое хранится в <code class="literal">sqlca.sqlerrm.sqlerrmc</code> (результат функции <code class="function">strlen()</code>, который не очень интересен для программиста C). Заметьте, что некоторые сообщения могут не умещаться в массив <code class="literal">sqlerrmc</code> фиксированного размера; они будут обрезаться.</p><p>В случае предупреждения, в <code class="literal">sqlca.sqlwarn[2]</code> записывается символ <code class="literal">W</code>. (Во всех других случаях значение будет отличным от <code class="literal">W</code>.) Символ <code class="literal">W</code> в <code class="literal">sqlca.sqlwarn[1]</code> показывает, что значение было обрезано при сохранении в переменной среды С. <code class="literal">W</code> в <code class="literal">sqlca.sqlwarn[0]</code> устанавливается, если предупреждение отмечается в каком-либо другом элементе массива.</p><p>Поля <code class="structfield">sqlcaid</code>, <code class="structfield">sqlabc</code>, <code class="structfield">sqlerrp</code> и остальные элементы <code class="structfield">sqlerrd</code> и <code class="structfield">sqlwarn</code> в настоящее время не содержат полезной информации.</p><p>Структура <code class="varname">sqlca</code> не определена в стандарте SQL, но реализована в нескольких других СУБД SQL. Принципиально она определяется одинаково, но если вы хотите, чтобы ваши приложения были переносимыми, тщательно изучите различия реализаций.</p><p>В следующем примере, демонстрирующем применение <code class="literal">WHENEVER</code> в сочетании с <code class="varname">sqlca</code>, выводится содержимое <code class="varname">sqlca</code> при возникновении ошибки. Это может быть полезно для отладки или в прототипах, пока не реализован более <span class="quote">«<span class="quote">дружественный пользователю</span>»</span> обработчик ошибок. </p><pre class="programlisting">EXEC SQL WHENEVER SQLERROR CALL print_sqlca();

void
print_sqlca()
{
    fprintf(stderr, "==== sqlca ====\n");
    fprintf(stderr, "sqlcode: %ld\n", sqlca.sqlcode);
    fprintf(stderr, "sqlerrm.sqlerrml: %d\n", sqlca.sqlerrm.sqlerrml);
    fprintf(stderr, "sqlerrm.sqlerrmc: %s\n", sqlca.sqlerrm.sqlerrmc);
    fprintf(stderr, "sqlerrd: %ld %ld %ld %ld %ld %ld\n", sqlca.sqlerrd[0],sqlca.sqlerrd[1],sqlca.sqlerrd[2],
                                                          sqlca.sqlerrd[3],sqlca.sqlerrd[4],sqlca.sqlerrd[5]);
    fprintf(stderr, "sqlwarn: %d %d %d %d %d %d %d %d\n", sqlca.sqlwarn[0], sqlca.sqlwarn[1], sqlca.sqlwarn[2],
                                                          sqlca.sqlwarn[3], sqlca.sqlwarn[4], sqlca.sqlwarn[5],
                                                          sqlca.sqlwarn[6], sqlca.sqlwarn[7]);
    fprintf(stderr, "sqlstate: %5s\n", sqlca.sqlstate);
    fprintf(stderr, "===============\n");
}</pre><p> Результат может выглядеть следующим образом (при ошибке, вызванной опечаткой в имени таблицы): </p><pre class="screen">
==== sqlca ====
sqlcode: -400
sqlerrm.sqlerrml: 49
sqlerrm.sqlerrmc: relation "pg_databasep" does not exist on line 38
sqlerrd: 0 0 0 0 0 0
sqlwarn: 0 0 0 0 0 0 0 0
sqlstate: 42P01
===============
</pre></div><div class="sect2" id="ECPG-SQLSTATE-SQLCODE"><div class="titlepage"><div><div><h3 class="title">36.8.3. <code class="literal">SQLSTATE</code> и <code class="literal">SQLCODE</code> <a href="#ECPG-SQLSTATE-SQLCODE" class="id_link">#</a></h3></div></div></div><p>Поля <code class="literal">sqlca.sqlstate</code> и <code class="literal">sqlca.sqlcode</code> отражают две различные схемы, представляющие коды ошибок. Обе схемы пришли из стандарта SQL, но схема <code class="literal">SQLCODE</code> была признана устаревшей в редакции SQL-92 и исключена в последующих редакциях. Поэтому в новых приложениях настоятельно рекомендуется использовать <code class="literal">SQLSTATE</code>.</p><p><code class="literal">SQLSTATE</code> задаётся в массиве из пяти символов. Эти пять символов содержат цифры или буквы в верхнем регистре, представляющие коды различных условий ошибок и предупреждений. <code class="literal">SQLSTATE</code> определяется по иерархической схеме: первые два символа обозначают общий класс условия, а следующие три — подкласс общего условия. Успешное состояние обозначается кодом <code class="literal">00000</code>. По большей части коды <code class="literal">SQLSTATE</code> определены в стандарте SQL. Сервер <span class="productname">PostgreSQL</span> поддерживает коды ошибок <code class="literal">SQLSTATE</code> естественным образом; поэтому используя во всех приложениях именно эту схему кодов ошибок, можно добиться высокой степени согласованности. За дальнейшими сведениями обратитесь к <a class="xref" href="errcodes-appendix.html" title="Приложение A. Коды ошибок PostgreSQL">Приложению A</a>.</p><p><code class="literal">SQLCODE</code> — устаревшая схема, в которой коды ошибок представлены просто целыми числами. Значение 0 обозначает успешное завершение, положительное значение — успешное завершение с дополнительной информацией, а отрицательное говорит об ошибке. В стандарте SQL определено только положительное значение +100, показывающее, что последняя команда вернула или затронула ноль строк, но отрицательные значения не определены. Таким образом, с этой схемой нельзя рассчитывать на переносимость и она не имеет иерархической структуры. Исторически сложилось, что процессор встраиваемого SQL для <span class="productname">PostgreSQL</span> назначает некоторые определённые значения <code class="literal">SQLCODE</code> для собственного использования; они перечислены ниже с числовыми значениями и символьными именами. Помните, что эти коды несовместимы с другими реализациями SQL. Поэтому для упрощения перевода приложений на схему <code class="literal">SQLSTATE</code> вместе с этими кодами перечисляются соответствующие значения <code class="literal">SQLSTATE</code>. Однако однозначного соответствия один-к-одному или один-ко-многим между этими двумя схемами не существует (на самом деле это соответствие многие-ко-многим), поэтому следует свериться со списком <code class="literal">SQLSTATE</code> в <a class="xref" href="errcodes-appendix.html" title="Приложение A. Коды ошибок PostgreSQL">Приложении A</a> в каждом случае.</p><p><code class="literal">SQLCODE</code> может принимать следующие значения: </p><div class="variablelist"><dl class="variablelist"><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-NO-ERROR"><span class="term">0 (<code class="symbol">ECPG_NO_ERROR</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-NO-ERROR" class="id_link">#</a></dt><dd><p>Показывает, что ошибки нет. (SQLSTATE 00000)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-NOT-FOUND"><span class="term">100 (<code class="symbol">ECPG_NOT_FOUND</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-NOT-FOUND" class="id_link">#</a></dt><dd><p>Это нейтральное условие, показывающее, что последняя команда вернула или обработала ноль строк, либо курсор достиг конца. (SQLSTATE 02000)</p><p>Выбирая данные из курсора в цикле, можно проверять этот код, чтобы понять, когда нужно прервать цикл, следующим образом: </p><pre class="programlisting">while (1)
{
    EXEC SQL FETCH ... ;
    if (sqlca.sqlcode == ECPG_NOT_FOUND)
        break;
}</pre><p> Но <code class="literal">WHENEVER NOT FOUND DO BREAK</code> внутри по сути делает это же, поэтому такое явное условие обычно ничем не лучше.</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-OUT-OF-MEMORY"><span class="term">-12 (<code class="symbol">ECPG_OUT_OF_MEMORY</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-OUT-OF-MEMORY" class="id_link">#</a></dt><dd><p>Указывает, что закончилась виртуальная память. Числовое значение определено как <code class="literal">-ENOMEM</code>. (SQLSTATE YE001)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-UNSUPPORTED"><span class="term">-200 (<code class="symbol">ECPG_UNSUPPORTED</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-UNSUPPORTED" class="id_link">#</a></dt><dd><p>Указывает, что препроцессор сгенерировал код, который не понимает библиотека. Возможно, вы используете несовместимые версии препроцессора и библиотеки. (SQLSTATE YE002)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-TOO-MANY-ARGUMENTS"><span class="term">-201 (<code class="symbol">ECPG_TOO_MANY_ARGUMENTS</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-TOO-MANY-ARGUMENTS" class="id_link">#</a></dt><dd><p>Это означает, что в команде было указано больше переменных среды, чем она ожидает. (SQLSTATE 07001 или 07002)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-TOO-FEW-ARGUMENTS"><span class="term">-202 (<code class="symbol">ECPG_TOO_FEW_ARGUMENTS</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-TOO-FEW-ARGUMENTS" class="id_link">#</a></dt><dd><p>Это означает, что в команде было указано меньше переменных среды, чем она ожидает. (SQLSTATE 07001 или 07002)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-TOO-MANY-MATCHES"><span class="term">-203 (<code class="symbol">ECPG_TOO_MANY_MATCHES</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-TOO-MANY-MATCHES" class="id_link">#</a></dt><dd><p>Это означает, что запрос вернул несколько строк, но оператор был подготовлен только для одной строки результата (например, потому что переданные переменные — не массивы). (SQLSTATE 21000)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-INT-FORMAT"><span class="term">-204 (<code class="symbol">ECPG_INT_FORMAT</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-INT-FORMAT" class="id_link">#</a></dt><dd><p>Переменная среды C типа <code class="type">int</code> и данные в базе имеют разные типы, и в этих данных содержится значение, которое нельзя преобразовать в <code class="type">int</code>. Для этого преобразования библиотека использует функцию <code class="function">strtol()</code>. (SQLSTATE 42804)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-UINT-FORMAT"><span class="term">-205 (<code class="symbol">ECPG_UINT_FORMAT</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-UINT-FORMAT" class="id_link">#</a></dt><dd><p>Переменная среды C типа <code class="type">unsigned int</code> и данные в базе имеют разные типы, и в этих данных содержится значение, которое нельзя преобразовать в <code class="type">unsigned int</code>. Для этого преобразования библиотека использует функцию <code class="function">strtoul()</code>. (SQLSTATE 42804)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-FLOAT-FORMAT"><span class="term">-206 (<code class="symbol">ECPG_FLOAT_FORMAT</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-FLOAT-FORMAT" class="id_link">#</a></dt><dd><p>Переменная среды C типа <code class="type">float</code> и данные в базе имеют разные типы, и в этих данных содержится значение, которое нельзя преобразовать во <code class="type">float</code>. Для этого преобразования библиотека использует функцию <code class="function">strtod()</code>. (SQLSTATE 42804)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-NUMERIC-FORMAT"><span class="term">-207 (<code class="symbol">ECPG_NUMERIC_FORMAT</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-NUMERIC-FORMAT" class="id_link">#</a></dt><dd><p>Переменная среды C типа <code class="type">numeric</code> и данные в базе имеют разные типы, и в этих данных содержится значение, которое нельзя преобразовать в <code class="type">numeric</code>. (SQLSTATE 42804)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-INTERVAL-FORMAT"><span class="term">-208 (<code class="symbol">ECPG_INTERVAL_FORMAT</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-INTERVAL-FORMAT" class="id_link">#</a></dt><dd><p>Переменная среды C типа <code class="type">interval</code> и данные в базе имеют разные типы, и в этих данных содержится значение, которое нельзя преобразовать в <code class="type">interval</code>. (SQLSTATE 42804)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-DATE-FORMAT"><span class="term">-209 (<code class="symbol">ECPG_DATE_FORMAT</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-DATE-FORMAT" class="id_link">#</a></dt><dd><p>Переменная среды C типа <code class="type">date</code> и данные в базе имеют разные типы, и в этих данных содержится значение, которое нельзя преобразовать в <code class="type">date</code>. (SQLSTATE 42804)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-TIMESTAMP-FORMAT"><span class="term">-210 (<code class="symbol">ECPG_TIMESTAMP_FORMAT</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-TIMESTAMP-FORMAT" class="id_link">#</a></dt><dd><p>Переменная среды C типа <code class="type">timestamp</code> и данные в базе имеют разные типы, и в этих данных содержится значение, которое нельзя преобразовать в <code class="type">timestamp</code>. (SQLSTATE 42804)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-CONVERT-BOOL"><span class="term">-211 (<code class="symbol">ECPG_CONVERT_BOOL</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-CONVERT-BOOL" class="id_link">#</a></dt><dd><p>Это означает, что переменная среды C имеет тип <code class="type">bool</code>, а значение в базе данных отличается от <code class="literal">'t'</code> или <code class="literal">'f'</code>. (SQLSTATE 42804)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-EMPTY"><span class="term">-212 (<code class="symbol">ECPG_EMPTY</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-EMPTY" class="id_link">#</a></dt><dd><p>Серверу <span class="productname">PostgreSQL</span> был передан пустой оператор. (Этого обычно не должно происходить в программе со встраиваемым SQL, так что это может указывать на внутреннюю ошибку.) (SQLSTATE YE002)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-MISSING-INDICATOR"><span class="term">-213 (<code class="symbol">ECPG_MISSING_INDICATOR</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-MISSING-INDICATOR" class="id_link">#</a></dt><dd><p>Возвращено значение NULL, но переменная-индикатор NULL не задана. (SQLSTATE 22002)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-NO-ARRAY"><span class="term">-214 (<code class="symbol">ECPG_NO_ARRAY</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-NO-ARRAY" class="id_link">#</a></dt><dd><p>Там, где требуется массив, была передана обычная переменная. (SQLSTATE 42804)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-DATA-NOT-ARRAY"><span class="term">-215 (<code class="symbol">ECPG_DATA_NOT_ARRAY</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-DATA-NOT-ARRAY" class="id_link">#</a></dt><dd><p>База данных возвратила обычную переменную там, где требуется значение-массив. (SQLSTATE 42804)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-ARRAY-INSERT"><span class="term">-216 (<code class="symbol">ECPG_ARRAY_INSERT</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-ARRAY-INSERT" class="id_link">#</a></dt><dd><p>Не удалось вставить значение в массив. (SQLSTATE 42804)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-NO-CONN"><span class="term">-220 (<code class="symbol">ECPG_NO_CONN</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-NO-CONN" class="id_link">#</a></dt><dd><p>Программа попыталась использовать несуществующее подключение. (SQLSTATE 08003)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-NOT-CONN"><span class="term">-221 (<code class="symbol">ECPG_NOT_CONN</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-NOT-CONN" class="id_link">#</a></dt><dd><p>Программа попыталась использовать подключение, которое существует, но не было открыто. (Это внутренняя ошибка.) (SQLSTATE YE002)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-INVALID-STMT"><span class="term">-230 (<code class="symbol">ECPG_INVALID_STMT</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-INVALID-STMT" class="id_link">#</a></dt><dd><p>Оператор, который вы пытаетесь выполнить, не был подготовлен. (SQLSTATE 26000)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-INFORMIX-DUPLICATE-KEY"><span class="term">-239 (<code class="symbol">ECPG_INFORMIX_DUPLICATE_KEY</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-INFORMIX-DUPLICATE-KEY" class="id_link">#</a></dt><dd><p>Ошибка повторяющегося ключа, нарушение ограничения уникальности (режим совместимости с Informix). (SQLSTATE 23505)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-UNKNOWN-DESCRIPTOR"><span class="term">-240 (<code class="symbol">ECPG_UNKNOWN_DESCRIPTOR</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-UNKNOWN-DESCRIPTOR" class="id_link">#</a></dt><dd><p>Указанный дескриптор не найден. Оператор, который вы пытаетесь использовать, не был подготовлен. (SQLSTATE 33000)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-INVALID-DESCRIPTOR-INDEX"><span class="term">-241 (<code class="symbol">ECPG_INVALID_DESCRIPTOR_INDEX</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-INVALID-DESCRIPTOR-INDEX" class="id_link">#</a></dt><dd><p>Указанный индекс дескриптора вне диапазона. (SQLSTATE 07009)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-UNKNOWN-DESCRIPTOR-ITEM"><span class="term">-242 (<code class="symbol">ECPG_UNKNOWN_DESCRIPTOR_ITEM</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-UNKNOWN-DESCRIPTOR-ITEM" class="id_link">#</a></dt><dd><p>Запрошен неверный элемент дескриптора. (Это внутренняя ошибка.) (SQLSTATE YE002)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-VAR-NOT-NUMERIC"><span class="term">-243 (<code class="symbol">ECPG_VAR_NOT_NUMERIC</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-VAR-NOT-NUMERIC" class="id_link">#</a></dt><dd><p>При выполнении динамического оператора база данных возвратила числовое значение, тогда как переменная среды C — не числовая. (SQLSTATE 07006)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-VAR-NOT-CHAR"><span class="term">-244 (<code class="symbol">ECPG_VAR_NOT_CHAR</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-VAR-NOT-CHAR" class="id_link">#</a></dt><dd><p>При выполнении динамического оператора база данных возвратила не числовое значение, тогда как переменная среды C — числовая. (SQLSTATE 07006)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-INFORMIX-SUBSELECT-NOT-ONE"><span class="term">-284 (<code class="symbol">ECPG_INFORMIX_SUBSELECT_NOT_ONE</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-INFORMIX-SUBSELECT-NOT-ONE" class="id_link">#</a></dt><dd><p>Результат подзапроса представлен не одной строкой (режим совместимости с Informix). (SQLSTATE 21000)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-PGSQL"><span class="term">-400 (<code class="symbol">ECPG_PGSQL</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-PGSQL" class="id_link">#</a></dt><dd><p>Ошибка произошла на стороне сервера <span class="productname">PostgreSQL</span>. В тексте ошибки содержится сообщение об ошибке от сервера <span class="productname">PostgreSQL</span>.</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-TRANS"><span class="term">-401 (<code class="symbol">ECPG_TRANS</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-TRANS" class="id_link">#</a></dt><dd><p>Сервер <span class="productname">PostgreSQL</span> сообщает, что клиент не может запускать, фиксировать или отменять транзакцию. (SQLSTATE 08007)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-CONNECT"><span class="term">-402 (<code class="symbol">ECPG_CONNECT</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-CONNECT" class="id_link">#</a></dt><dd><p>Попытка подключения к базе данных была неудачной. (SQLSTATE 08001)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-DUPLICATE-KEY"><span class="term">-403 (<code class="symbol">ECPG_DUPLICATE_KEY</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-DUPLICATE-KEY" class="id_link">#</a></dt><dd><p>Ошибка повторяющегося ключа, нарушение ограничения уникальности. (SQLSTATE 23505)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-SUBSELECT-NOT-ONE"><span class="term">-404 (<code class="symbol">ECPG_SUBSELECT_NOT_ONE</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-SUBSELECT-NOT-ONE" class="id_link">#</a></dt><dd><p>Результат подзапроса представлен не одной строкой. (SQLSTATE 21000)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-WARNING-UNKNOWN-PORTAL"><span class="term">-602 (<code class="symbol">ECPG_WARNING_UNKNOWN_PORTAL</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-WARNING-UNKNOWN-PORTAL" class="id_link">#</a></dt><dd><p>Указано неверное имя курсора. (SQLSTATE 34000)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-WARNING-IN-TRANSACTION"><span class="term">-603 (<code class="symbol">ECPG_WARNING_IN_TRANSACTION</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-WARNING-IN-TRANSACTION" class="id_link">#</a></dt><dd><p>Транзакция в процессе выполнения. (SQLSTATE 25001)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-WARNING-NO-TRANSACTION"><span class="term">-604 (<code class="symbol">ECPG_WARNING_NO_TRANSACTION</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-WARNING-NO-TRANSACTION" class="id_link">#</a></dt><dd><p>Нет активной (выполняющейся) транзакции. (SQLSTATE 25P01)</p></dd><dt id="ECPG-SQLSTATE-SQLCODE-ECPG-WARNING-PORTAL-EXISTS"><span class="term">-605 (<code class="symbol">ECPG_WARNING_PORTAL_EXISTS</code>)</span> <a href="#ECPG-SQLSTATE-SQLCODE-ECPG-WARNING-PORTAL-EXISTS" class="id_link">#</a></dt><dd><p>Было указано имя существующего курсора. (SQLSTATE 42P03)</p></dd></dl></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ecpg-descriptors.html" title="36.7. Использование областей дескрипторов">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="ecpg.html" title="Глава 36. ECPG — Встраиваемый SQL в C">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="ecpg-preproc.html" title="36.9. Директивы препроцессора">След.</a></td></tr><tr><td width="40%" align="left" valign="top">36.7. Использование областей дескрипторов </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 36.9. Директивы препроцессора</td></tr></table></div></body></html>