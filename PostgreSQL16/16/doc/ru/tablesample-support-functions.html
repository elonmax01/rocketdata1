<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>60.1. Опорные функции метода извлечения выборки</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="tablesample-method.html" title="Глава 60. Написание метода извлечения выборки таблицы" /><link rel="next" href="custom-scan.html" title="Глава 61. Написание провайдера нестандартного сканирования" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">60.1. Опорные функции метода извлечения выборки</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="tablesample-method.html" title="Глава 60. Написание метода извлечения выборки таблицы">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="tablesample-method.html" title="Глава 60. Написание метода извлечения выборки таблицы">Наверх</a></td><th width="60%" align="center">Глава 60. Написание метода извлечения выборки таблицы</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="custom-scan.html" title="Глава 61. Написание провайдера нестандартного сканирования">След.</a></td></tr></table><hr /></div><div class="sect1" id="TABLESAMPLE-SUPPORT-FUNCTIONS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">60.1. Опорные функции метода извлечения выборки <a href="#TABLESAMPLE-SUPPORT-FUNCTIONS" class="id_link">#</a></h2></div></div></div><p>Функция-обработчик TSM возвращает структуру <code class="type">TsmRoutine</code> (выделенную вызовом palloc) с указателями на опорные функции, описанные ниже. Большинство этих функций обязательные, но некоторые — нет, и их указатели могут быть равны NULL.</p><pre class="programlisting">void
SampleScanGetSampleSize (PlannerInfo *root,
                         RelOptInfo *baserel,
                         List *paramexprs,
                         BlockNumber *pages,
                         double *tuples);</pre><p> Эта функция вызывается во время планирования. Она должна рассчитать число страниц отношения, которые будут прочитаны при простом сканировании, и число кортежей, выбираемых при сканировании. (Например, эти числа можно получить, оценив процент выбираемых данных, а затем умножив <code class="literal">baserel-&gt;pages</code> и <code class="literal">baserel-&gt;tuples</code> на это значение и округлив результат до целых.) Список <code class="literal">paramexprs</code> содержит выражения, переданные в параметрах предложению <code class="literal">TABLESAMPLE</code>. Если для целей оценивания нужны их значения, рекомендуется воспользоваться <code class="function">estimate_expression_value()</code>, чтобы попытаться свести эти выражения к константам; но данная функция должна выдавать оценку размера, даже если это не удастся, и не должна выдавать ошибку, даже если считает переданные значения неверными (помните, что это только приблизительные оценки чисел, которые будут получены во время выполнения). Параметры <code class="literal">pages</code> и <code class="literal">tuples</code> являются выходными.</p><pre class="programlisting">void
InitSampleScan (SampleScanState *node,
                int eflags);</pre><p> Выполняет инициализацию перед выполнением узла плана SampleScan. Эта функция вызывается при запуске исполнителя. Она должна выполнить все подготовительные действия, необходимые для начала обработки. Узел <code class="structname">SampleScanState</code> уже был создан, но его поле <code class="structfield">tsm_state</code> содержит NULL. Функция <code class="function">InitSampleScan</code> может выделить через palloc область для любых внутренних данных, нужных методу извлечения выборки, и сохранить указатель на неё в <code class="literal">node-&gt;tsm_state</code>. Информацию о сканируемой таблице можно получить через другие поля узла <code class="structname">SampleScanState</code> (но заметьте, что дескриптор сканирования <code class="literal">node-&gt;ss.ss_currentScanDesc</code> ещё не настроен). Параметр <code class="literal">eflags</code> содержит битовые флаги, описывающие режим работы исполнителя для этого узла плана.</p><p>Когда <code class="literal">(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</code> не равно нулю, собственно сканирование не будет выполняться, поэтому эта функция должна сделать только то, что необходимо для получения состояния узла, подходящего для <code class="command">EXPLAIN</code> и <code class="function">EndSampleScan</code>.</p><p>Эту функцию можно опустить (присвоить указателю NULL), тогда вся инициализация, необходимая для метода извлечения выборки, должна иметь место в <code class="function">BeginSampleScan</code>.</p><pre class="programlisting">void
BeginSampleScan (SampleScanState *node,
                 Datum *params,
                 int nparams,
                 uint32 seed);</pre><p> Начинает выполнение сканирования выборки. Эта функция вызывается непосредственно перед первой попыткой выбрать кортеж и может вызываться повторно, если потребуется перезапустить сканирование. Информацию о сканируемой таблице можно получить через поля узла <code class="structname">SampleScanState</code> (но заметьте, что дескриптор сканирования <code class="literal">node-&gt;ss.ss_currentScanDesc</code> ещё не настроен). Массив <code class="literal">params</code>, длины <code class="literal">nparams</code>, содержит значения параметров, переданных в предложении <code class="literal">TABLESAMPLE</code>. Их количество и типы задаются в списке <code class="literal">parameterTypes</code> метода выборки, и они гарантированно не равны NULL. Параметр <code class="literal">seed</code> содержит значение затравки, которое этот метод должен учитывать при генерации любых случайных чисел; это либо хеш, полученный из значения <code class="literal">REPEATABLE</code>, если оно было передано, либо результат <code class="literal">random()</code> в противном случае.</p><p>Эта функция может скорректировать поля <code class="literal">node-&gt;use_bulkread</code> и <code class="literal">node-&gt;use_pagemode</code>. Если поле <code class="literal">node-&gt;use_bulkread</code> равно <code class="literal">true</code> (это значение по умолчанию), при сканировании будет использоваться стратегия доступа к буферу, ориентированная на переработку буферов после использования. Может быть разумным присвоить ему <code class="literal">false</code>, если при сканировании будет просматриваться только небольшой процент страниц. Если поле <code class="literal">node-&gt;use_pagemode</code> равно <code class="literal">true</code> (это значение по умолчанию), при сканировании проверка видимости будет выполняться в один проход для всех кортежей на каждой просматриваемой странице. Может иметь смысл присвоить ему <code class="literal">false</code>, если при сканировании выбирается только небольшой процент кортежей на странице. В результате будет выполняться меньше проверок видимости кортежей, хотя каждая проверка будет дороже, так как потребует расширенную блокировку.</p><p>Если метод выборки помечен как <code class="literal">repeatable_across_scans</code>, он должен быть способен выбирать при повторном сканировании тот же набор кортежей, что был выбран в первый раз, то есть новый вызов <code class="function">BeginSampleScan</code> должен приводить к выборке тех же кортежей, что и предыдущий (если параметры <code class="literal">TABLESAMPLE</code> и значение затравки не меняются).</p><pre class="programlisting">BlockNumber
NextSampleBlock (SampleScanState *node, BlockNumber nblocks);</pre><p> Возвращает номер блока следующей сканируемой страницы либо <code class="literal">InvalidBlockNumber</code>, если страниц для сканирования не осталось.</p><p>Эту функцию можно опустить (присвоить её указателю NULL), в этом случае код ядра произведёт последовательное сканирование всего отношения. Такое сканирование может быть синхронизированным, так что метод выборки не должен полагать, что страницы отношения каждый раз просматриваются в одном и том же порядке.</p><pre class="programlisting">OffsetNumber
NextSampleTuple (SampleScanState *node,
                 BlockNumber blockno,
                 OffsetNumber maxoffset);</pre><p> Возвращает номер смещения следующего кортежа, выбираемого с указанной страницы, либо <code class="literal">InvalidOffsetNumber</code>, если кортежей для выборки не осталось. В <code class="literal">maxoffset</code> задаётся максимальный номер смещения, допустимый на этой странице.</p><div class="note"><h3 class="title">Примечание</h3><p><code class="function">NextSampleTuple</code> не говорит явно, для каких из номеров смещений в диапазоне <code class="literal">1 .. maxoffset</code> действительно содержатся актуальные кортежи. Это обычно не проблема, так как код ядра игнорирует запросы на выборку несуществующих или невидимых кортежей; это не должно приводить к отклонениям в выборке. Однако при необходимости функция может прочитать в поле <code class="literal">node-&gt;donetuples</code> количество кортежей, которые оказались актуальными и видимыми, из числа тех, что она выдала.</p></div><div class="note"><h3 class="title">Примечание</h3><p>Функция <code class="function">NextSampleTuple</code> <span class="emphasis"><em>не</em></span> должна полагать, что в <code class="literal">blockno</code> будет получен тот же номер страницы, что был выдан при последнем вызове <code class="function">NextSampleBlock</code>. Этот номер определённо был выдан при каком-то предыдущем вызове <code class="function">NextSampleBlock</code>, но код ядра может вызывать <code class="function">NextSampleBlock</code> перед тем, как собственно сканировать страницы, для поддержки упреждающего чтения. Однако можно рассчитывать на то, что как только начнётся выборка кортежей с одной данной страницы, все последующие вызовы <code class="function">NextSampleTuple</code> будут обращаться к этой странице, пока не будет возвращено значение <code class="literal">InvalidOffsetNumber</code>.</p></div><pre class="programlisting">void
EndSampleScan (SampleScanState *node);</pre><p> Завершает сканирование и освобождает ресурсы. Обычно при этом не нужно освобождать память, выделенную через palloc, но все видимые извне ресурсы должны быть очищены. Эту функцию чаще всего можно опустить (присвоить её указателю NULL), если таких ресурсов нет.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="tablesample-method.html" title="Глава 60. Написание метода извлечения выборки таблицы">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="tablesample-method.html" title="Глава 60. Написание метода извлечения выборки таблицы">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="custom-scan.html" title="Глава 61. Написание провайдера нестандартного сканирования">След.</a></td></tr><tr><td width="40%" align="left" valign="top">Глава 60. Написание метода извлечения выборки таблицы </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> Глава 61. Написание провайдера нестандартного сканирования</td></tr></table></div></body></html>