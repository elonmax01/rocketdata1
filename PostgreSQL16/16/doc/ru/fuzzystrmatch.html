<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>F.17. fuzzystrmatch — вычисление схожести и расстояния между строками</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="file-fdw.html" title="F.16. file_fdw — обращение к файлам данных в файловой системе сервера" /><link rel="next" href="hstore.html" title="F.18. hstore — тип данных hstore для хранения пар ключ-значение" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">F.17. fuzzystrmatch — вычисление схожести и расстояния между строками</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="file-fdw.html" title="F.16. file_fdw — обращение к файлам данных в файловой системе сервера">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="contrib.html" title="Приложение F. Дополнительно поставляемые модули и расширения">Наверх</a></td><th width="60%" align="center">Приложение F. Дополнительно поставляемые модули и расширения</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="hstore.html" title="F.18. hstore — тип данных hstore для хранения пар ключ-значение">След.</a></td></tr></table><hr /></div><div class="sect1" id="FUZZYSTRMATCH"><div class="titlepage"><div><div><h2 class="title" style="clear: both">F.17. fuzzystrmatch — вычисление схожести и расстояния между строками <a href="#FUZZYSTRMATCH" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="fuzzystrmatch.html#FUZZYSTRMATCH-SOUNDEX">F.17.1. Soundex</a></span></dt><dt><span class="sect2"><a href="fuzzystrmatch.html#FUZZYSTRMATCH-DAITCH-MOKOTOFF">F.17.2. Daitch-Mokotoff Soundex</a></span></dt><dt><span class="sect2"><a href="fuzzystrmatch.html#FUZZYSTRMATCH-LEVENSHTEIN">F.17.3. Левенштейн</a></span></dt><dt><span class="sect2"><a href="fuzzystrmatch.html#FUZZYSTRMATCH-METAPHONE">F.17.4. Metaphone</a></span></dt><dt><span class="sect2"><a href="fuzzystrmatch.html#FUZZYSTRMATCH-DOUBLE-METAPHONE">F.17.5. Double Metaphone</a></span></dt></dl></div><a id="id-1.11.7.27.2" class="indexterm"></a><p>Модуль <code class="filename">fuzzystrmatch</code> содержит несколько функций для вычисления схожести и расстояния между строками.</p><div class="caution"><h3 class="title">Внимание</h3><p>В настоящее время функции <code class="function">soundex</code>, <code class="function">metaphone</code>, <code class="function">dmetaphone</code> и <code class="function">dmetaphone_alt</code> плохо работают с многобайтными кодировками (в частности, с UTF-8). Используйте функции <code class="function">daitch_mokotoff</code> или <code class="function">levenshtein</code> в работе с такими данными.</p></div><p>Данный модуль считается <span class="quote">«<span class="quote">доверенным</span>»</span>, то есть его могут устанавливать обычные пользователи, имеющие право <code class="literal">CREATE</code> в текущей базе данных.</p><div class="sect2" id="FUZZYSTRMATCH-SOUNDEX"><div class="titlepage"><div><div><h3 class="title">F.17.1. Soundex <a href="#FUZZYSTRMATCH-SOUNDEX" class="id_link">#</a></h3></div></div></div><p>Система Soundex позволяет вычислить похожие по звучанию имена, приводя их к одинаковым кодам. Изначально она использовалась для обработки данных переписи населения США в 1880, 1900 и 1910 г. Заметьте, что эта система не очень полезна для неанглоязычных имён.</p><p>Модуль <code class="filename">fuzzystrmatch</code> предоставляет две функции для работы с кодами Soundex:</p><a id="id-1.11.7.27.6.4" class="indexterm"></a><a id="id-1.11.7.27.6.5" class="indexterm"></a><pre class="synopsis">soundex(text) returns text
difference(text, text) returns int</pre><p>Функция <code class="function">soundex</code> преобразует строку в код Soundex. Функция <code class="function">difference</code> преобразует две строки в их коды Soundex и затем сообщает количество совпадающих позиций в этих кодах. Так как коды Soundex состоят из четырёх символов, результатом может быть число от нуля до четырёх (0 обозначает полное несоответствие, а 4 — точное совпадение). (Таким образом, имя этой функции не вполне корректное — лучшим именем для неё было бы <code class="function">similarity</code>.)</p><p>Несколько примеров использования:</p><pre class="programlisting">SELECT soundex('hello world!');

SELECT soundex('Anne'), soundex('Ann'), difference('Anne', 'Ann');
SELECT soundex('Anne'), soundex('Andrew'), difference('Anne', 'Andrew');
SELECT soundex('Anne'), soundex('Margaret'), difference('Anne', 'Margaret');

CREATE TABLE s (nm text);

INSERT INTO s VALUES ('john');
INSERT INTO s VALUES ('joan');
INSERT INTO s VALUES ('wobbly');
INSERT INTO s VALUES ('jack');

SELECT * FROM s WHERE soundex(nm) = soundex('john');

SELECT * FROM s WHERE difference(s.nm, 'john') &gt; 2;</pre></div><div class="sect2" id="FUZZYSTRMATCH-DAITCH-MOKOTOFF"><div class="titlepage"><div><div><h3 class="title">F.17.2. Daitch-Mokotoff Soundex <a href="#FUZZYSTRMATCH-DAITCH-MOKOTOFF" class="id_link">#</a></h3></div></div></div><p>Как и исходная система Soundex, система Daitch-Mokotoff Soundex сопоставляет похожие по звучанию имена и преобразует их в один и тот же код. Однако Daitch-Mokotoff Soundex значительно полезнее для неанглийских имён, чем исходная система. Основные улучшения по сравнению с исходной системой перечислены ниже: </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p>Код основан на первых шести значимых буквах, а не на четырёх.</p></li><li class="listitem" style="list-style-type: disc"><p>Буква или комбинация букв сопоставляется с десятью возможными кодами, а не с семью.</p></li><li class="listitem" style="list-style-type: disc"><p>Если две последовательные буквы имеют один звук, они заменяются цифрой.</p></li><li class="listitem" style="list-style-type: disc"><p>Когда буква или комбинация букв могут иметь разные звуки, генерируется несколько кодов, чтобы охватить все возможные варианты.</p></li></ul></div><a id="id-1.11.7.27.7.3" class="indexterm"></a><p>Эта функция генерирует коды Daitch-Mokotoff Soundex для входных данных:</p><pre class="synopsis">daitch_mokotoff(<em class="parameter"><code>source</code></em> text) returns text[]</pre><p>Результат может содержать один или несколько кодов в зависимости от количества возможных вариантов произношения, поэтому он представляется в виде массива.</p><p>Поскольку код Daitch-Mokotoff Soundex состоит всего из 6 цифр, рекомендуется передавать в <em class="parameter"><code>source</code></em> одно слово или имя.</p><p>Несколько примеров:</p><pre class="programlisting">SELECT daitch_mokotoff('George');
 daitch_mokotoff
-----------------
 {595000}

SELECT daitch_mokotoff('John');
 daitch_mokotoff
-----------------
 {160000,460000}

SELECT daitch_mokotoff('Bierschbach');
                      daitch_mokotoff
-----------------------------------------------------------
 {794575,794574,794750,794740,745750,745740,747500,747400}

SELECT daitch_mokotoff('Schwartzenegger');
 daitch_mokotoff
-----------------
 {479465}</pre><p>Для сопоставления отдельных имён возвращаемые текстовые массивы могут сравниваться напрямую с использованием оператора <code class="literal">&amp;&amp;</code>: любое пересечение можно считать совпадением. Для повышения эффективности можно использовать индекс GIN, см. <a class="xref" href="gin.html" title="Глава 70. Индексы GIN">Главу 70</a> и следующий пример:</p><pre class="programlisting">CREATE TABLE s (nm text);
CREATE INDEX ix_s_dm ON s USING gin (daitch_mokotoff(nm)) WITH (fastupdate = off);

INSERT INTO s (nm) VALUES
  ('Schwartzenegger'),
  ('John'),
  ('James'),
  ('Steinman'),
  ('Steinmetz');

SELECT * FROM s WHERE daitch_mokotoff(nm) &amp;&amp; daitch_mokotoff('Swartzenegger');
SELECT * FROM s WHERE daitch_mokotoff(nm) &amp;&amp; daitch_mokotoff('Jane');
SELECT * FROM s WHERE daitch_mokotoff(nm) &amp;&amp; daitch_mokotoff('Jens');</pre><p>Для индексации и сопоставления любого количества имён в любом порядке можно использовать функции полнотекстового поиска. См. <a class="xref" href="textsearch.html" title="Глава 12. Полнотекстовый поиск">Главу 12</a> и следующий пример:</p><pre class="programlisting">CREATE FUNCTION soundex_tsvector(v_name text) RETURNS tsvector
BEGIN ATOMIC
  SELECT to_tsvector('simple',
                     string_agg(array_to_string(daitch_mokotoff(n), ' '), ' '))
  FROM regexp_split_to_table(v_name, '\s+') AS n;
END;

CREATE FUNCTION soundex_tsquery(v_name text) RETURNS tsquery
BEGIN ATOMIC
  SELECT string_agg('(' || array_to_string(daitch_mokotoff(n), '|') || ')', '&amp;')::tsquery
  FROM regexp_split_to_table(v_name, '\s+') AS n;
END;

CREATE TABLE s (nm text);
CREATE INDEX ix_s_txt ON s USING gin (soundex_tsvector(nm)) WITH (fastupdate = off);

INSERT INTO s (nm) VALUES
  ('John Doe'),
  ('Jane Roe'),
  ('Public John Q.'),
  ('George Best'),
  ('John Yamson');

SELECT * FROM s WHERE soundex_tsvector(nm) @@ soundex_tsquery('john');
SELECT * FROM s WHERE soundex_tsvector(nm) @@ soundex_tsquery('jane doe');
SELECT * FROM s WHERE soundex_tsvector(nm) @@ soundex_tsquery('john public');
SELECT * FROM s WHERE soundex_tsvector(nm) @@ soundex_tsquery('besst, giorgio');
SELECT * FROM s WHERE soundex_tsvector(nm) @@ soundex_tsquery('Jameson John');</pre><p>Если желательно избежать пересчёта кодов Soundex при перепроверке индекса, вместо индекса по выражению можно использовать индекс по отдельному столбцу. Для этого можно использовать хранимый генерируемый столбец; см. <a class="xref" href="ddl-generated-columns.html" title="5.3. Генерируемые столбцы">Раздел 5.3</a>.</p></div><div class="sect2" id="FUZZYSTRMATCH-LEVENSHTEIN"><div class="titlepage"><div><div><h3 class="title">F.17.3. Левенштейн <a href="#FUZZYSTRMATCH-LEVENSHTEIN" class="id_link">#</a></h3></div></div></div><p>Эта функция вычисляет расстояние Левенштейна между двумя строками:</p><a id="id-1.11.7.27.8.3" class="indexterm"></a><a id="id-1.11.7.27.8.4" class="indexterm"></a><pre class="synopsis">levenshtein(source text, target text, ins_cost int, del_cost int, sub_cost int) returns int
levenshtein(source text, target text) returns int
levenshtein_less_equal(source text, target text, ins_cost int, del_cost int, sub_cost int, max_d int) returns int
levenshtein_less_equal(source text, target text, max_d int) returns int</pre><p>И в <code class="literal">source</code>, и в <code class="literal">target</code> может быть передана любая строка, отличная от NULL, не длиннее 255 символов. Параметры стоимости (ins_cost, del_cost, sub_cost) определяют цену добавления, удаления или замены символов, соответственно. Эти параметры можно опустить, как во второй версии функции; в этом случае все они по умолчанию равны 1.</p><p>Функция <code class="function">levenshtein_less_equal</code> является ускоренной версией функции Левенштейна, предназначенной для использования, только когда интерес представляют небольшие расстояния. Если фактическое расстояние меньше или равно <code class="literal">max_d</code>, то <code class="function">levenshtein_less_equal</code> возвращает точное его значение; в противном случае она возвращает значение, большее чем <code class="literal">max_d</code>. Если значение <code class="literal">max_d</code> отрицательное, она работает так же, как функция <code class="function">levenshtein</code>.</p><p>Примеры:</p><pre class="screen">test=# SELECT levenshtein('GUMBO', 'GAMBOL');
 levenshtein
-------------
           2
(1 row)

test=# SELECT levenshtein('GUMBO', 'GAMBOL', 2, 1, 1);
 levenshtein
-------------
           3
(1 row)

test=# SELECT levenshtein_less_equal('extensive', 'exhaustive', 2);
 levenshtein_less_equal
------------------------
                      3
(1 row)

test=# SELECT levenshtein_less_equal('extensive', 'exhaustive', 4);
 levenshtein_less_equal
------------------------
                      4
(1 row)</pre></div><div class="sect2" id="FUZZYSTRMATCH-METAPHONE"><div class="titlepage"><div><div><h3 class="title">F.17.4. Metaphone <a href="#FUZZYSTRMATCH-METAPHONE" class="id_link">#</a></h3></div></div></div><p>Metaphone, как и Soundex, построен на идее составления кода, представляющего входную строку. Две строки признаются похожими, если их коды совпадают.</p><p>Эта функция вычисляет код метафона входной строки:</p><a id="id-1.11.7.27.9.4" class="indexterm"></a><pre class="synopsis">metaphone(source text, max_output_length int) returns text</pre><p>В качестве <code class="literal">source</code> должна передаваться строка, отличная от NULL, не длиннее 255 символов. Параметр <code class="literal">max_output_length</code> задаёт максимальную длину выходного кода метафона; если код оказывается длиннее, он обрезается до этой длины.</p><p>Пример:</p><pre class="screen">test=# SELECT metaphone('GUMBO', 4);
 metaphone
-----------
 KM
(1 row)</pre></div><div class="sect2" id="FUZZYSTRMATCH-DOUBLE-METAPHONE"><div class="titlepage"><div><div><h3 class="title">F.17.5. Double Metaphone <a href="#FUZZYSTRMATCH-DOUBLE-METAPHONE" class="id_link">#</a></h3></div></div></div><p>Алгоритм Double Metaphone (Двойной метафон) вычисляет две строки <span class="quote">«<span class="quote">похожего звучания</span>»</span> для заданной строки — <span class="quote">«<span class="quote">первичную</span>»</span> и <span class="quote">«<span class="quote">альтернативную</span>»</span>. В большинстве случаев они совпадают, но для неанглоязычных имён в особенности они могут быть весьма различными, в зависимости от произношения. Эти функции вычисляют первичный и альтернативный коды:</p><a id="id-1.11.7.27.10.3" class="indexterm"></a><a id="id-1.11.7.27.10.4" class="indexterm"></a><pre class="synopsis">dmetaphone(source text) returns text
dmetaphone_alt(source text) returns text</pre><p>Длина входных строк может быть любой.</p><p>Пример:</p><pre class="screen">test=# SELECT dmetaphone('gumbo');
 dmetaphone
------------
 KMP
(1 row)</pre></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="file-fdw.html" title="F.16. file_fdw — обращение к файлам данных в файловой системе сервера">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="contrib.html" title="Приложение F. Дополнительно поставляемые модули и расширения">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="hstore.html" title="F.18. hstore — тип данных hstore для хранения пар ключ-значение">След.</a></td></tr><tr><td width="40%" align="left" valign="top">F.16. file_fdw — обращение к файлам данных в файловой системе сервера </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> F.18. hstore — тип данных <code class="type">hstore</code> для хранения пар ключ-значение</td></tr></table></div></body></html>