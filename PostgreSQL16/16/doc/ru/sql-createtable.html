<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CREATE TABLE</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sql-createsubscription.html" title="CREATE SUBSCRIPTION" /><link rel="next" href="sql-createtableas.html" title="CREATE TABLE AS" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">CREATE TABLE</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-createsubscription.html" title="CREATE SUBSCRIPTION">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><th width="60%" align="center">Команды SQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-createtableas.html" title="CREATE TABLE AS">След.</a></td></tr></table><hr /></div><div class="refentry" id="SQL-CREATETABLE"><div class="titlepage"></div><a id="id-1.9.3.85.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">CREATE TABLE</span></h2><p>CREATE TABLE — создать таблицу</p></div><div class="refsynopsisdiv"><h2>Синтаксис</h2><pre class="synopsis">CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <em class="replaceable"><code>имя_таблицы</code></em> ( [
  { <em class="replaceable"><code>имя_столбца</code></em> <em class="replaceable"><code>тип_данных</code></em> [ STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN | DEFAULT } ] [ COMPRESSION <em class="replaceable"><code>метод_сжатия</code></em> ] [ COLLATE <em class="replaceable"><code>правило_сортировки</code></em> ] [ <em class="replaceable"><code>ограничение_столбца</code></em> [ ... ] ]
    | <em class="replaceable"><code>ограничение_таблицы</code></em>
    | LIKE <em class="replaceable"><code>исходная_таблица</code></em> [ <em class="replaceable"><code>вариант_копирования</code></em> ... ] }
    [, ... ]
] )
[ INHERITS ( <em class="replaceable"><code>таблица_родитель</code></em> [, ... ] ) ]
[ PARTITION BY { RANGE | LIST | HASH } ( { <em class="replaceable"><code>имя_столбца</code></em> | ( <em class="replaceable"><code>выражение</code></em> ) } [ COLLATE <em class="replaceable"><code>правило_сортировки</code></em> ] [ <em class="replaceable"><code>класс_операторов</code></em> ] [, ... ] ) ]
[ USING <em class="replaceable"><code>метод</code></em> ]
[ WITH ( <em class="replaceable"><code>параметр_хранения</code></em> [= <em class="replaceable"><code>значение</code></em>] [, ... ] ) | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <em class="replaceable"><code>табл_пространство</code></em> ]

CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <em class="replaceable"><code>имя_таблицы</code></em>
    OF <em class="replaceable"><code>имя_типа</code></em> [ (
  { <em class="replaceable"><code>имя_столбца</code></em> [ WITH OPTIONS ] [ <em class="replaceable"><code>ограничение_столбца</code></em> [ ... ] ]
    | <em class="replaceable"><code>ограничение_таблицы</code></em> }
    [, ... ]
) ]
[ PARTITION BY { RANGE | LIST | HASH } ( { <em class="replaceable"><code>имя_столбца</code></em> | ( <em class="replaceable"><code>выражение</code></em> ) } [ COLLATE <em class="replaceable"><code>правило_сортировки</code></em> ] [ <em class="replaceable"><code>класс_операторов</code></em> ] [, ... ] ) ]
[ USING <em class="replaceable"><code>метод</code></em> ]
[ WITH ( <em class="replaceable"><code>параметр_хранения</code></em> [= <em class="replaceable"><code>значение</code></em>] [, ... ] ) | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <em class="replaceable"><code>табл_пространство</code></em> ]

CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <em class="replaceable"><code>имя_таблицы</code></em>
    PARTITION OF <em class="replaceable"><code>таблица_родитель</code></em> [ (
  { <em class="replaceable"><code>имя_столбца</code></em> [ WITH OPTIONS ] [ <em class="replaceable"><code>ограничение_столбца</code></em> [ ... ] ]
    | <em class="replaceable"><code>ограничение_таблицы</code></em> }
    [, ... ]
) ] { FOR VALUES <em class="replaceable"><code>указание_границ_секции</code></em> | DEFAULT }
[ PARTITION BY { RANGE | LIST | HASH } ( { <em class="replaceable"><code>имя_столбца</code></em> | ( <em class="replaceable"><code>выражение</code></em> ) } [ COLLATE <em class="replaceable"><code>правило_сортировки</code></em> ] [ <em class="replaceable"><code>класс_операторов</code></em> ] [, ... ] ) ]
[ USING <em class="replaceable"><code>метод</code></em> ]
[ WITH ( <em class="replaceable"><code>параметр_хранения</code></em> [= <em class="replaceable"><code>значение</code></em>] [, ... ] ) | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <em class="replaceable"><code>табл_пространство</code></em> ]

<span class="phrase">Здесь <em class="replaceable"><code>ограничение_столбца</code></em>:</span>

[ CONSTRAINT <em class="replaceable"><code>имя_ограничения</code></em> ]
{ NOT NULL |
  NULL |
  CHECK ( <em class="replaceable"><code>выражение</code></em> ) [ NO INHERIT ] |
  DEFAULT <em class="replaceable"><code>выражение_по_умолчанию</code></em> |
  GENERATED ALWAYS AS ( <em class="replaceable"><code>генерирующее_выражение</code></em> ) STORED |
  GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <em class="replaceable"><code>параметры_последовательности</code></em> ) ] |
  UNIQUE [ NULLS [ NOT ] DISTINCT ] <em class="replaceable"><code>параметры_индекса</code></em> |
  PRIMARY KEY <em class="replaceable"><code>параметры_индекса</code></em> |
  REFERENCES <em class="replaceable"><code>целевая_таблица</code></em> [ ( <em class="replaceable"><code>целевой_столбец</code></em> ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
    [ ON DELETE <em class="replaceable"><code>ссылочное_действие</code></em> ] [ ON UPDATE <em class="replaceable"><code>ссылочное_действие</code></em> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<span class="phrase">и <em class="replaceable"><code>ограничение_таблицы</code></em>:</span>

[ CONSTRAINT <em class="replaceable"><code>имя_ограничения</code></em> ]
{ CHECK ( <em class="replaceable"><code>выражение</code></em> ) [ NO INHERIT ] |
  UNIQUE [ NULLS [ NOT ] DISTINCT ] ( <em class="replaceable"><code>имя_столбца</code></em> [, ... ] ) <em class="replaceable"><code>параметры_индекса</code></em> |
  PRIMARY KEY ( <em class="replaceable"><code>имя_столбца</code></em> [, ... ] ) <em class="replaceable"><code>параметры_индекса</code></em> |
  EXCLUDE [ USING <em class="replaceable"><code>индексный_метод</code></em> ] ( <em class="replaceable"><code>элемент_исключения</code></em> WITH <em class="replaceable"><code>оператор</code></em> [, ... ] ) <em class="replaceable"><code>параметры_индекса</code></em> [ WHERE ( <em class="replaceable"><code>предикат</code></em> ) ] |
  FOREIGN KEY ( <em class="replaceable"><code>имя_столбца</code></em> [, ... ] ) REFERENCES <em class="replaceable"><code>целевая_таблица</code></em> [ ( <em class="replaceable"><code>целевой_столбец</code></em> [, ... ] ) ]
    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE <em class="replaceable"><code>ссылочное_действие</code></em> ] [ ON UPDATE <em class="replaceable"><code>ссылочное_действие</code></em> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<span class="phrase">и <em class="replaceable"><code>вариант_копирования</code></em>:</span>

{ INCLUDING | EXCLUDING } { COMMENTS | COMPRESSION | CONSTRAINTS | DEFAULTS | GENERATED | IDENTITY | INDEXES | STATISTICS | STORAGE | ALL }

<span class="phrase">и <em class="replaceable"><code>указание_границ_секции</code></em>:</span>

IN ( <em class="replaceable"><code>выражение_границ_секции</code></em> [, ...] ) |
FROM ( { <em class="replaceable"><code>выражение_границ_секции</code></em> | MINVALUE | MAXVALUE } [, ...] )
  TO ( { <em class="replaceable"><code>выражение_границ_секции</code></em> | MINVALUE | MAXVALUE } [, ...] ) |
WITH ( MODULUS <em class="replaceable"><code>числовая_константа</code></em>, REMAINDER <em class="replaceable"><code>числовая_константа</code></em> )

<span class="phrase"><em class="replaceable"><code>параметры_индекса</code></em> в ограничениях <code class="literal">UNIQUE</code>, <code class="literal">PRIMARY KEY</code> и <code class="literal">EXCLUDE</code>:</span>

[ INCLUDE ( <em class="replaceable"><code>имя_столбца</code></em> [, ... ] ) ]
[ WITH ( <em class="replaceable"><code>параметр_хранения</code></em> [= <em class="replaceable"><code>значение</code></em>] [, ... ] ) ]
[ USING INDEX TABLESPACE <em class="replaceable"><code>табл_пространство</code></em> ]

<span class="phrase"><em class="replaceable"><code>элемент_исключения</code></em> в ограничении <code class="literal">EXCLUDE</code>:</span>

{ <em class="replaceable"><code>имя_столбца</code></em> | ( <em class="replaceable"><code>выражение</code></em> ) } [ COLLATE <em class="replaceable"><code>правило_сортировки</code></em> ] [ <em class="replaceable"><code>класс_операторов</code></em> [ ( <em class="replaceable"><code>параметр_класса_оп</code></em> = <em class="replaceable"><code>значение</code></em> [, ... ] ) ] ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]

<span class="phrase"><em class="replaceable"><code>ссылочное_действие</code></em> в ограничении <code class="literal">FOREIGN KEY</code>/<code class="literal">REFERENCES</code>:</span>

{ NO ACTION | RESTRICT | CASCADE | SET NULL [ ( <em class="replaceable"><code>имя_столбца</code></em> [, ... ] ) ] | SET DEFAULT [ ( <em class="replaceable"><code>имя_столбца</code></em> [, ... ] ) ] }</pre></div><div class="refsect1" id="SQL-CREATETABLE-DESCRIPTION"><h2>Описание</h2><p><code class="command">CREATE TABLE</code> создаёт новую, изначально пустую таблицу в текущей базе данных. Владельцем таблицы будет пользователь, выполнивший эту команду.</p><p>Если задано имя схемы (например, <code class="literal">CREATE TABLE myschema.mytable ...</code>), таблица создаётся в указанной схеме, в противном случае — в текущей. Временные таблицы существуют в специальной схеме, так что при создании таких таблиц имя схемы задать нельзя. Имя таблицы должно отличаться от имён других отношений (таблиц, последовательностей, индексов, представлений, материализованных представлений или сторонних таблиц) в этой схеме.</p><p><code class="command">CREATE TABLE</code> также автоматически создаёт составной тип данных, соответствующий одной строке таблицы. Таким образом, имя таблицы не может совпадать с именем существующего типа в этой же схеме.</p><p>Необязательные предложения ограничений задают ограничения (проверки), которым должны удовлетворять добавляемые или изменяемые строки, чтобы операция добавления или изменения была выполнена успешно. Ограничение представляет собой SQL-объект, помогающий некоторым способом определить множество допустимых значений в таблице.</p><p>Определить ограничения можно двумя способами: в виде ограничений таблицы и в виде ограничений столбца. Ограничение столбца определяется как часть определения столбца, а ограничение таблицы не привязывается к конкретному столбцу и может задействовать несколько столбцов. Любые ограничения столбцов можно также записать в виде ограничения таблицы, они введены просто для удобства записи в случаях, когда ограничение затрагивает только один столбец.</p><p>Чтобы создать таблицу, необходимо иметь право <code class="literal">USAGE</code> для типов всех столбцов или типа в предложении <code class="literal">OF</code>, соответственно.</p></div><div class="refsect1" id="id-1.9.3.85.6"><h2>Параметры</h2><div class="variablelist"><dl class="variablelist"><dt id="SQL-CREATETABLE-TEMPORARY"><span class="term"><code class="literal">TEMPORARY</code> или <code class="literal">TEMP</code></span> <a href="#SQL-CREATETABLE-TEMPORARY" class="id_link">#</a></dt><dd><p>С таким указанием таблица создаётся как временная. Временные таблицы автоматически удаляются в конце сеанса или могут удаляться в конце текущей транзакции (см. описание <code class="literal">ON COMMIT</code> ниже). В путь поиска по умолчанию первой включается временная схема, поэтому постоянная таблица с тем же именем не будет выбираться для новых планов запросов, пока существует временная (если имя задаётся без указания схемы). Все индексы, создаваемые для временной таблицы, автоматически также становятся временными.</p><p><a class="link" href="routine-vacuuming.html#AUTOVACUUM" title="25.1.6. Демон автоочистки">Демон автоочистки</a> не может прочитать и, как следствие, сжимать и анализировать временные таблицы. По этой причине соответствующие операции очистки и анализа следует выполнять, вызывая SQL-команды в рамках сеанса. Например, если временную таблицу планируется использовать в сложных запросах, будет разумным выполнить для неё <code class="command">ANALYZE</code> после того, как она будет наполнена.</p><p>По желанию можно добавить указание <code class="literal">GLOBAL</code> или <code class="literal">LOCAL</code> перед <code class="literal">TEMPORARY</code> или <code class="literal">TEMP</code>. В настоящее время это не имеет значения для <span class="productname">PostgreSQL</span> и считается устаревшей возможностью; см. раздел <a class="xref" href="sql-createtable.html#SQL-CREATETABLE-COMPATIBILITY" title="Совместимость">Совместимость</a> ниже.</p></dd><dt id="SQL-CREATETABLE-UNLOGGED"><span class="term"><code class="literal">UNLOGGED</code></span> <a href="#SQL-CREATETABLE-UNLOGGED" class="id_link">#</a></dt><dd><p>С этим указанием таблица создаётся как нежурналируемая. Данные, записываемые в нежурналируемые таблицы, не проходят через журнал предзаписи (см. <a class="xref" href="wal.html" title="Глава 30. Надёжность и журнал предзаписи">Главу 30</a>), в результате чего такие таблицы работают гораздо быстрее обычных. Однако они не защищены от сбоя; при сбое или аварийном отключении сервера нежурналируемая таблица автоматически усекается. Кроме того, содержимое нежурналируемой таблицы не реплицируется на ведомые серверы. Любые индексы, создаваемые для нежурналируемой таблицы, автоматически становятся нежурналируемыми.</p><p>С этим указанием все последовательности, создаваемые вместе с нежурналируемой таблицей (для столбцов идентификаторов или столбцов serial), также создаются нежурналируемыми.</p></dd><dt id="SQL-CREATETABLE-PARMS-IF-NOT-EXISTS"><span class="term"><code class="literal">IF NOT EXISTS</code></span> <a href="#SQL-CREATETABLE-PARMS-IF-NOT-EXISTS" class="id_link">#</a></dt><dd><p>Не считать ошибкой, если отношение с таким именем уже существует. В этом случае будет выдано замечание. Заметьте, что нет никакой гарантии, что существующее отношение как-то соотносится с тем, которое могло бы быть создано.</p></dd><dt id="SQL-CREATETABLE-PARMS-TABLE-NAME"><span class="term"><em class="replaceable"><code>имя_таблицы</code></em></span> <a href="#SQL-CREATETABLE-PARMS-TABLE-NAME" class="id_link">#</a></dt><dd><p>Имя создаваемой таблицы (возможно, дополненное схемой).</p></dd><dt id="SQL-CREATETABLE-PARMS-TYPE-NAME"><span class="term"><code class="literal">OF <em class="replaceable"><code>имя_типа</code></em></code></span> <a href="#SQL-CREATETABLE-PARMS-TYPE-NAME" class="id_link">#</a></dt><dd><p>Создаёт <em class="firstterm">типизированную таблицу</em>, структура которой определяется указанным составным типом (его имя может быть дополнено схемой). Типизированная таблица привязана к породившему её типу; например, при удалении типа (командой <code class="literal">DROP TYPE ... CASCADE</code>) будет удалена и эта таблица.</p><p>Когда создаётся типизированная таблица, типы данных её столбцов определяются нижележащим составным типом, а не задаются командой <code class="literal">CREATE TABLE</code>. Но <code class="literal">CREATE TABLE</code> может добавить в таблицу значения по умолчанию и ограничения, а также задать параметры её хранения.</p></dd><dt id="SQL-CREATETABLE-PARMS-COLUMN-NAME"><span class="term"><em class="replaceable"><code>имя_столбца</code></em></span> <a href="#SQL-CREATETABLE-PARMS-COLUMN-NAME" class="id_link">#</a></dt><dd><p>Имя столбца, создаваемого в новой таблице.</p></dd><dt id="SQL-CREATETABLE-PARMS-DATA-TYPE"><span class="term"><em class="replaceable"><code>тип_данных</code></em></span> <a href="#SQL-CREATETABLE-PARMS-DATA-TYPE" class="id_link">#</a></dt><dd><p>Тип данных столбца (может включать определение массива с этим типом). За дополнительными сведениями о типах данных, которые поддерживает <span class="productname">PostgreSQL</span>, обратитесь к <a class="xref" href="datatype.html" title="Глава 8. Типы данных">Главе 8</a>.</p></dd><dt id="SQL-CREATETABLE-PARMS-COLLATE"><span class="term"><code class="literal">COLLATE <em class="replaceable"><code>правило_сортировки</code></em></code></span> <a href="#SQL-CREATETABLE-PARMS-COLLATE" class="id_link">#</a></dt><dd><p>Предложение <code class="literal">COLLATE</code> назначает правило сортировки для столбца (который должен иметь тип, поддерживающий сортировку). Если оно отсутствует, используется правило сортировки по умолчанию, установленное для типа данных столбца.</p></dd><dt id="SQL-CREATETABLE-PARMS-STORAGE"><span class="term">
     <code class="literal">STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN | DEFAULT }</code>
     <a id="id-1.9.3.85.6.2.9.1.2" class="indexterm"></a>
    </span> <a href="#SQL-CREATETABLE-PARMS-STORAGE" class="id_link">#</a></dt><dd><p>Эта форма устанавливает режим хранения столбца. Она определяет, хранятся ли данные внутри таблицы или в отдельной таблице <acronym class="acronym">TOAST</acronym> и сжимаются ли они. Режим <code class="literal">PLAIN</code> должен применяться для значений фиксированной длины, таких как <code class="type">integer</code>; это вариант хранения внутри, без сжатия. Режим <code class="literal">MAIN</code> применяется для хранения внутри, но сжатых данных, <code class="literal">EXTERNAL</code> — для внешнего хранения несжатых данных, а <code class="literal">EXTENDED</code> — для внешнего хранения сжатых данных. С указанием <code class="literal">DEFAULT</code> будет использоваться режим по умолчанию для типа данных столбца. <code class="literal">EXTENDED</code> используется по умолчанию для большинства типов данных, поддерживающих хранилище не <code class="literal">PLAIN</code>. Применение <code class="literal">EXTERNAL</code> позволяет ускорить операции с подстроками на очень больших значениях <code class="type">text</code> и <code class="type">bytea</code>, за счёт проигрыша в объёме хранилища. За дополнительными сведениями обратитесь к <a class="xref" href="storage-toast.html" title="73.2. TOAST">Разделу 73.2</a>.</p></dd><dt id="SQL-CREATETABLE-PARMS-COMPRESSION"><span class="term"><code class="literal">COMPRESSION <em class="replaceable"><code>метод_сжатия</code></em></code></span> <a href="#SQL-CREATETABLE-PARMS-COMPRESSION" class="id_link">#</a></dt><dd><p>Указание <code class="literal">COMPRESSION</code> задаёт метод сжатия для столбца. Сжатие поддерживается только для типов данных переменной длины и применяется только для столбцов с режимом хранения <code class="literal">main</code> или <code class="literal">extended</code>. (О режимах хранения столбцов рассказывается в <a class="xref" href="sql-altertable.html" title="ALTER TABLE"><span class="refentrytitle">ALTER TABLE</span></a>.) Заданное для секционированной таблицы это свойство не оказывает прямого действия, так как такие таблицы сами по себе не содержат данные, но установленное значение будут наследовать её новые секции. Поддерживаются следующие методы сжатия: <code class="literal">pglz</code> и <code class="literal">lz4</code>. (<code class="literal">lz4</code> поддерживается, только если <span class="productname">PostgreSQL</span> был собран с ключом <code class="option">--with-lz4</code>.) Кроме того, <em class="replaceable"><code>метод_сжатия</code></em> может принимать значение <code class="literal">default</code>, явно выбирающее поведение по умолчанию — когда применяемый метод определяется значением <a class="xref" href="runtime-config-client.html#GUC-DEFAULT-TOAST-COMPRESSION">default_toast_compression</a> во время добавления данных.</p></dd><dt id="SQL-CREATETABLE-PARMS-INHERITS"><span class="term"><code class="literal">INHERITS ( <em class="replaceable"><code>таблица_родитель</code></em> [, ... ] )</code></span> <a href="#SQL-CREATETABLE-PARMS-INHERITS" class="id_link">#</a></dt><dd><p>Необязательное предложение <code class="literal">INHERITS</code> определяет список таблиц, от которых новая таблица будет автоматически наследовать все столбцы. Родительские таблицы могут быть обычными или сторонними таблицами.</p><p>При использовании <code class="literal">INHERITS</code> создаётся постоянная связь дочерней таблицы с родительскими. Изменения схемы в родительских таблицах обычно также отражаются в дочерних, и по умолчанию при чтении родительских таблиц в результат включаются данные дочерней таблицы.</p><p>Когда в нескольких родительских таблицах оказываются столбцы с одним именем, происходит ошибка, за исключением случая, когда типы данных всех этих столбцов в таблицах совпадают. В этом случае одноимённые столбцы объединяются и формируют один столбец в новой таблице. Если имя столбца новой таблицы совпадает с именем одного из унаследованных столбцов, их типы так же должны совпадать, и в этом случае определения столбцов тоже сливаются в одну. Если в новой таблице явно указывается значение по умолчанию для нового столбца, это значение переопределяет любые значения по умолчанию, унаследованные этим столбцом. В противном случае, если значения по умолчанию определяются в разных родительских таблицах, эти определения должны совпадать, иначе произойдёт ошибка.</p><p>Ограничения <code class="literal">CHECK</code> объединяются вместе по сути так же, как и столбцы: если несколько родительских таблиц и/или определение новой таблицы содержат одноимённые ограничения <code class="literal">CHECK</code>, этим ограничениям должны соответствовать одинаковые выражения проверки, в противном случае произойдёт ошибка. В случае совпадения выражения, эти ограничения с данным выражением объединяются в одно. При этом ограничения со свойством <code class="literal">NO INHERIT</code> в родительской таблице исключаются из рассмотрения. Заметьте, что безымянное ограничение <code class="literal">CHECK</code> в новой таблице никогда не сливается с другими, так как для него всегда выбирается уникальное имя.</p><p>Параметры <code class="literal">STORAGE</code> для столбца так же копируются из родительских таблиц.</p><p>Если столбец в родительской таблице является столбцом идентификации, это свойство не наследуется. Если требуется, в дочерней таблице этот столбец можно объявить столбцом идентификации.</p></dd><dt id="SQL-CREATETABLE-PARMS-PARTITION-BY"><span class="term"><code class="literal">PARTITION BY { RANGE | LIST | HASH } ( { <em class="replaceable"><code>имя_столбца</code></em> | ( <em class="replaceable"><code>выражение</code></em> ) } [ <em class="replaceable"><code>класс_операторов</code></em> ] [, ...] )</code></span> <a href="#SQL-CREATETABLE-PARMS-PARTITION-BY" class="id_link">#</a></dt><dd><p>Необязательное предложение <code class="literal">PARTITION BY</code> задаёт стратегию секционирования таблицы. Таблица, созданная с этим указанием, называется <em class="firstterm">секционируемой</em> таблицей. Задаваемый в скобках список столбцов или выражений формирует <em class="firstterm">ключ разбиения</em> таблицы. Для разбиения по диапазонам или по хешу ключ разбиения может включать несколько столбцов или выражений (до 32, но этот предел можно изменить при сборке <span class="productname">PostgreSQL</span>), но для разбиения по спискам ключ должен состоять из одного столбца или выражения.</p><p>Для секционирования по диапазонам и по спискам нужен класс операторов B-дерева, тогда как для секционирования по хешу требуется класс операторов хеширования. Если класс операторов не задан явно, будет применён класс операторов по умолчанию для соответствующего типа; в случае отсутствия такого класса выдаётся ошибка. Для секционирования по хешу применяемый класс операторов должен реализовывать опорную функцию 2 (см. <a class="xref" href="xindex.html#XINDEX-SUPPORT" title="38.16.3. Опорные процедуры метода индекса">Подраздел 38.16.3</a>).</p><p>Секционируемая таблица разделяется на подтаблицы (называемые секциями), которые создаются отдельными командами <code class="literal">CREATE TABLE</code>. Сама по себе секционируемая таблица не содержит данных. Строка данных, вставляемая в эту таблицу, перенаправляется в секцию в зависимости от значений столбцов или выражений в ключе разбиения. Если значениям в новой строке не соответствует ни одна из существующих секций, возникает ошибка.</p><p>Секционируемые таблицы не поддерживают ограничения <code class="literal">EXCLUDE</code>; однако вы можете определить такие ограничения в отдельных секциях.</p><p>Узнать больше о секционировании таблиц можно в <a class="xref" href="ddl-partitioning.html" title="5.11. Секционирование таблиц">Разделе 5.11</a>.</p></dd><dt id="SQL-CREATETABLE-PARTITION"><span class="term"><code class="literal">PARTITION OF <em class="replaceable"><code>таблица_родитель</code></em> { FOR VALUES <em class="replaceable"><code>указание_границ_секции</code></em> | DEFAULT }</code></span> <a href="#SQL-CREATETABLE-PARTITION" class="id_link">#</a></dt><dd><p>Создаёт таблицу в виде <em class="firstterm">секции</em> указанной родительской таблицы. Таблицу можно создать либо как секцию для определённых значений (используя <code class="literal">FOR VALUES</code>), либо как секцию по умолчанию (используя <code class="literal">DEFAULT</code>). Это указание неприемлемо для таблиц, секционируемых по хешу. В создаваемую секцию копируются все индексы, ограничения и пользовательские триггеры уровня строк.</p><p>Здесь <em class="replaceable"><code>указание_границ_секции</code></em> должно соответствовать методу и ключу секционирования родительской таблицы и не должно конфликтовать с любой существующей секцией того же родителя. Вариант указания с <code class="literal">IN</code> используется для секционирования по спискам, тогда как вариант с <code class="literal">FROM</code> и <code class="literal">TO</code> для секционирования по диапазонам, а с <code class="literal">WITH</code> — для секционирования по хешу.</p><p><em class="replaceable"><code>выражение_границ_секции</code></em> — любое выражение без переменных (подзапросы, оконные, агрегатные и возвращающие множества функции в нём не допускаются). Его тип данных должен подходить для соответствующего столбца в ключе секционирования. Это выражение вычисляется единожды во время создания таблицы, поэтому в нём могут вызываться даже изменчивые функции, например <code class="literal"><code class="function">CURRENT_TIMESTAMP</code></code>.</p><p>При создании секции с разбиением по спискам возможно указать, что столбец ключа разбиения может содержать NULL, включив в список секции <code class="literal">NULL</code>. Однако у отдельно взятой родительской таблицы может быть не больше одной такой секции. Для диапазонных секций <code class="literal">NULL</code> задать нельзя.</p><p>При создании диапазонной секции нижняя граница, задаваемая во <code class="literal">FROM</code>, включается в диапазон, а верхняя граница, задаваемая в <code class="literal">TO</code> — исключается. То есть, значения, задаваемые в списке <code class="literal">FROM</code>, являются допустимыми значениями соответствующих столбцов ключа разбиения для этой секции, а значения в списке <code class="literal">TO</code> — нет. Заметьте, что это утверждение должно восприниматься с учётом правил сравнения строк таблицы (см. <a class="xref" href="functions-comparisons.html#ROW-WISE-COMPARISON" title="9.24.5. Сравнение конструкторов строк">Подраздел 9.24.5</a>). Например, с разбиением <code class="literal">PARTITION BY RANGE (x,y)</code>, секция с границами <code class="literal">FROM (1, 2) TO (3, 4)</code> примет <code class="literal">x=1</code> с любым значением <code class="literal">y&gt;=2</code>, <code class="literal">x=2</code> с любым <code class="literal">y</code>, отличным от NULL, и <code class="literal">x=3</code> с любым <code class="literal">y&lt;4</code>.</p><p>Специальные значения <code class="literal">MINVALUE</code> и <code class="literal">MAXVALUE</code> могут использоваться при создании диапазонной секции для указания, что нижняя или верхняя граница для значений столбца отсутствует. Например, секция, определённая с указанием <code class="literal">FROM (MINVALUE) TO (10)</code>, будет принимать любые значения меньше 10, а секция, определённая с указанием <code class="literal">FROM (10) TO (MAXVALUE)</code>, — любые значения, которые больше или равны 10.</p><p>При создании диапазонной секции с более чем одним столбцом может также иметь смысл использовать <code class="literal">MAXVALUE</code> в определении нижней границы, а <code class="literal">MINVALUE</code> — верхней. Например, секция, определённая с указанием <code class="literal">FROM (0, MAXVALUE) TO (10, MAXVALUE)</code>, будет принимать любые строки, в которых первый столбец ключа разбиения больше 0 и меньше или равен 10. Подобным образом, секция, определённая с указанием <code class="literal">FROM ('a', MINVALUE) TO ('b', MINVALUE)</code>, будет принимать строки, в которых первый столбец ключа разбиения начинается с «a».</p><p>Заметьте, что если для одного столбца в границе секции задаётся <code class="literal">MINVALUE</code> или <code class="literal">MAXVALUE</code>, то же значение должно применяться и для всех последующих столбцов. Например, граница <code class="literal">(10, MINVALUE, 0)</code> будет некорректной; допустимая граница: <code class="literal">(10, MINVALUE, MINVALUE)</code>.</p><p>Также заметьте, что для некоторых типов элементов, таких как <code class="literal">timestamp</code>, наряду с другими значениями допускается значение "infinity" (бесконечность). Оно отличается от вариантов <code class="literal">MINVALUE</code> и <code class="literal">MAXVALUE</code>, которые на самом деле не обозначают значения, которые можно сохранить, а просто говорят о том, это значение не ограничено. <code class="literal">MAXVALUE</code> можно воспринимать как значение, которое больше любого другого, включая "бесконечность", а <code class="literal">MINVALUE</code> меньше любого другого значения, включая "минус бесконечность". Таким образом, диапазон <code class="literal">FROM ('infinity') TO (MAXVALUE)</code> не будет пустым, а будет принимать ровно одно значение — «infinity».</p><p>С указанием <code class="literal">DEFAULT</code> таблица присоединяется к родительской таблице как секция по умолчанию. Для таблиц, разбиваемых по хешу, это указание не поддерживается. Ключ разбиения, не попадающий ни в одну из секций данного родителя, будет отправлен в секцию по умолчанию.</p><p>Когда у таблицы есть секция по умолчанию (<code class="literal">DEFAULT</code>) и к ней добавляется новая секция, требуется просканировать секцию по умолчанию и убедиться в том, что она не содержит строки, которые должны относиться к новой секции. Если она содержит большое количество строк, это сканирование может быть длительным. Сканирование не будет выполняться, если секция по умолчанию является сторонней таблицей или в ней есть ограничение, гарантирующее отсутствие в этой секции строк, подлежащих перемещению в новую секцию.</p><p>При создании секции с разбиением по хешу должен задаваться модуль и остаток. Модулем должно быть положительное число, а остатком неотрицательное число, меньшее модуля. Обычно при начальной настройке таблицы с секционированием по хешу нужно выбрать модуль, равный количеству секций, и назначить каждой секции этот модуль и разные остатки (см. примеры ниже). Однако секциям можно назначить и разные модули, с условием, что модули, назначенные секциям таблицы, разбиваемой по хешу, являются делителями следующих больших модулей. Это позволяет постепенно увеличивать число секций, не производя полное перемещение всех данных. Например, предположим, что у вас есть таблица, разбиваемая по хешу на 8 секций, для каждой из которых назначен модуль 8, и возникла необходимость увеличить число секций до 16. Вы можете отсоединить одну из секций по модулю 8, создать две новые секции по модулю 16, покрывающих ту же часть пространства ключа (одну с остатком, равным остатку отсоединённой секции, а вторую с остатком, равным тому же остатку плюс 8), и вновь наполнить их данными. Вы можете повторять эту операцию (возможно, позже) для остальных секций по модулю 8, пока все они не будут заменены. Хотя и при таком подходе может потребоваться перемещать большие объёмы данных на каждом этапе, это всё же лучше, чем создавать абсолютно новую таблицу и перемещать все данные сразу.</p><p>В секции должны содержаться столбцы с теми же именами и типами, что и в секционированной таблице, к которой она относится. Изменение имён и типов столбцов в секционируемой таблице будет автоматически распространяться во все секции. Ограничения <code class="literal">CHECK</code> будут наследоваться автоматически всеми секциями, но для отдельных секций могут быть заданы дополнительные ограничения <code class="literal">CHECK</code>; дополнительные ограничения с теми же именами и условиями, как в родительской таблице, будут объединены с родительским ограничением. Также независимо для каждой секции могут быть заданы значения по умолчанию. Но заметьте, что значение по умолчанию, заданное на уровне секции, не будет действовать при добавлении строк через секционированную таблицу.</p><p>Строки, добавляемые в секционированную таблицу, будут автоматически перенаправляться в соответствующую секцию. Если подходящей секции не найдётся, произойдёт ошибка.</p><p>Такие операции, как <code class="command">TRUNCATE</code>, обычно затрагивают и саму таблицу, и каскадно распространяются на все дочерние секции, но могут также выполняться в отдельных секциях.</p><p>Обратите внимание, что для создания секции с использованием <code class="literal">PARTITION OF</code> требуется применение блокировки <code class="literal">ACCESS EXCLUSIVE</code> для родительской секционированной таблицы. Аналогично для удаления секции с помощью <code class="literal">DROP TABLE</code> требуется установить блокировку <code class="literal">ACCESS EXCLUSIVE</code> в родительской таблице. Для выполнения этих операций с менее строгой блокировкой можно использовать команду <a class="link" href="sql-altertable.html" title="ALTER TABLE"><code class="command">ALTER TABLE ATTACH/DETACH PARTITION</code></a>, тем самым снизив влияние на параллельные операции с секционированной таблицей.</p></dd><dt id="SQL-CREATETABLE-PARMS-LIKE"><span class="term"><code class="literal">LIKE <em class="replaceable"><code>исходная_таблица</code></em> [ <em class="replaceable"><code>вариант_копирования</code></em> ... ]</code></span> <a href="#SQL-CREATETABLE-PARMS-LIKE" class="id_link">#</a></dt><dd><p>Предложение <code class="literal">LIKE</code> определяет таблицу, из которой в новую таблицу будут автоматически скопированы все имена столбцов, их типы данных и их ограничения на NULL.</p><p>В отличие от <code class="literal">INHERITS</code>, новая и исходная таблица становятся полностью независимыми после завершения создания. Изменения в исходной таблице не отражаются в новой, а данные новой таблицы не включаются в результат чтения исходной.</p><p>Кроме того, в отличие от <code class="literal">INHERITS</code>, столбцы и ограничения, копируемые командой <code class="literal">LIKE</code>, не объединяются с одноимёнными столбцами и ограничениями. Если дублирующееся имя указывается явно или возникает в другом предложении <code class="literal">LIKE</code>, происходит ошибка.</p><p>Необязательные предложения <em class="replaceable"><code>вариант_копирования</code></em> указывают, какие дополнительные свойства исходной таблицы будут копироваться. Указание <code class="literal">INCLUDING</code> копирует заданное свойство, а <code class="literal">EXCLUDING</code> исключает его. По умолчанию подразумевается <code class="literal">EXCLUDING</code>. Если к одному типу объекта относятся несколько указаний, будет применяться последнее. Допустимые указания: </p><div class="variablelist"><dl class="variablelist"><dt id="SQL-CREATETABLE-PARMS-LIKE-OPT-COMMENTS"><span class="term"><code class="literal">INCLUDING COMMENTS</code></span> <a href="#SQL-CREATETABLE-PARMS-LIKE-OPT-COMMENTS" class="id_link">#</a></dt><dd><p>Копировать комментарии для скопированных столбцов, ограничений и индексов. По умолчанию комментарии не копируются, вследствие чего скопированные столбцы и ограничения в новой таблице оказываются без комментариев.</p></dd><dt id="SQL-CREATETABLE-PARMS-LIKE-OPT-COMPRESSION"><span class="term"><code class="literal">INCLUDING COMPRESSION</code></span> <a href="#SQL-CREATETABLE-PARMS-LIKE-OPT-COMPRESSION" class="id_link">#</a></dt><dd><p>Копировать метод сжатия для столбцов. По умолчанию указания метода сжатия не копируются, вследствие чего для новых столбцов выбирается метод сжатия по умолчанию.</p></dd><dt id="SQL-CREATETABLE-PARMS-LIKE-OPT-CONSTRAINTS"><span class="term"><code class="literal">INCLUDING CONSTRAINTS</code></span> <a href="#SQL-CREATETABLE-PARMS-LIKE-OPT-CONSTRAINTS" class="id_link">#</a></dt><dd><p>Копировать ограничения-проверки (<code class="literal">CHECK</code>). В данном контексте ограничения на уровне столбцов и на уровне таблицы не различаются. Ограничения NOT NULL копируются в новую таблицу всегда.</p></dd><dt id="SQL-CREATETABLE-PARMS-LIKE-OPT-DEFAULTS"><span class="term"><code class="literal">INCLUDING DEFAULTS</code></span> <a href="#SQL-CREATETABLE-PARMS-LIKE-OPT-DEFAULTS" class="id_link">#</a></dt><dd><p>Копировать выражения значений по умолчанию в определениях копируемых столбцов. Без этого указания выражения по умолчанию не копируются, вследствие чего в новой таблице скопированные столбцы получают значения по умолчанию NULL. Заметьте, что при копировании подобных выражений, в которых вызываются функции, модифицирующие БД, как например <code class="function">nextval</code>, может образовываться функциональная связь исходной таблицы с новой.</p></dd><dt id="SQL-CREATETABLE-PARMS-LIKE-OPT-GENERATED"><span class="term"><code class="literal">INCLUDING GENERATED</code></span> <a href="#SQL-CREATETABLE-PARMS-LIKE-OPT-GENERATED" class="id_link">#</a></dt><dd><p>Копировать выражения, генерирующие значения для копируемых столбцов. По умолчанию все новые столбцы будут обычными базовыми столбцами.</p></dd><dt id="SQL-CREATETABLE-PARMS-LIKE-OPT-IDENTITY"><span class="term"><code class="literal">INCLUDING IDENTITY</code></span> <a href="#SQL-CREATETABLE-PARMS-LIKE-OPT-IDENTITY" class="id_link">#</a></dt><dd><p>Копировать характеристики идентификации в определениях копируемых столбцов. Для каждого столбца идентификации в новой таблице создаётся новая последовательность, не зависящая от последовательностей, связанных со старой таблицей.</p></dd><dt id="SQL-CREATETABLE-PARMS-LIKE-OPT-INDEXES"><span class="term"><code class="literal">INCLUDING INDEXES</code></span> <a href="#SQL-CREATETABLE-PARMS-LIKE-OPT-INDEXES" class="id_link">#</a></dt><dd><p>Создавать в новой таблице индексы, ограничения <code class="literal">PRIMARY KEY</code>, <code class="literal">UNIQUE</code> и <code class="literal">EXCLUDE</code>, существующие в исходной таблице. Имена для новых индексов и ограничений выбираются согласно стандартным правилам, независимо от того, как назывались исходные. (Это позволяет избежать потенциальных конфликтов с именами новых индексов.)</p></dd><dt id="SQL-CREATETABLE-PARMS-LIKE-OPT-STATISTICS"><span class="term"><code class="literal">INCLUDING STATISTICS</code></span> <a href="#SQL-CREATETABLE-PARMS-LIKE-OPT-STATISTICS" class="id_link">#</a></dt><dd><p>Копировать в новую таблицу расширенную статистику.</p></dd><dt id="SQL-CREATETABLE-PARMS-LIKE-OPT-STORAGE"><span class="term"><code class="literal">INCLUDING STORAGE</code></span> <a href="#SQL-CREATETABLE-PARMS-LIKE-OPT-STORAGE" class="id_link">#</a></dt><dd><p>Копировать параметры <code class="literal">STORAGE</code> в определениях копируемых столбцов. По умолчанию параметры <code class="literal">STORAGE</code> исключаются, вследствие чего скопированные столбцы в новой таблице получают параметры по умолчанию, определённые соответствующим типом. Подробнее параметры <code class="literal">STORAGE</code> описаны в <a class="xref" href="storage-toast.html" title="73.2. TOAST">Разделе 73.2</a>.</p></dd><dt id="SQL-CREATETABLE-PARMS-LIKE-OPT-ALL"><span class="term"><code class="literal">INCLUDING ALL</code></span> <a href="#SQL-CREATETABLE-PARMS-LIKE-OPT-ALL" class="id_link">#</a></dt><dd><p>Указание <code class="literal">INCLUDING ALL</code> является сокращённым вариантом выбора всех имеющихся отдельных параметров. (После <code class="literal">INCLUDING ALL</code> можно дополнительно добавить предложения <code class="literal">EXCLUDING</code>, чтобы выбрать все параметры, за исключением некоторых.)</p></dd></dl></div><p>Предложение <code class="literal">LIKE</code> может также применяться для копирования определений столбцов из представлений, сторонних таблиц и составных типов. Неприменимые параметры (например, <code class="literal">INCLUDING INDEXES</code> для представления) при этом игнорируются.</p></dd><dt id="SQL-CREATETABLE-PARMS-CONSTRAINT"><span class="term"><code class="literal">CONSTRAINT <em class="replaceable"><code>имя_ограничения</code></em></code></span> <a href="#SQL-CREATETABLE-PARMS-CONSTRAINT" class="id_link">#</a></dt><dd><p>Необязательное имя столбца или ограничения таблицы. При нарушении ограничения его имя будет выводиться в сообщении об ошибках, так что имена ограничений вида <code class="literal">столбец должен быть положительным</code> могут сообщить полезную информацию об ограничении клиентскому приложению. (Имена ограничений, включающие пробелы, необходимо заключать в двойные кавычки.) Если имя ограничения не указано, система генерирует имя автоматически.</p></dd><dt id="SQL-CREATETABLE-PARMS-NOT-NULL"><span class="term"><code class="literal">NOT NULL</code></span> <a href="#SQL-CREATETABLE-PARMS-NOT-NULL" class="id_link">#</a></dt><dd><p>Данный столбец не принимает значения NULL.</p></dd><dt id="SQL-CREATETABLE-PARMS-NULL"><span class="term"><code class="literal">NULL</code></span> <a href="#SQL-CREATETABLE-PARMS-NULL" class="id_link">#</a></dt><dd><p>Данный столбец может содержать значения NULL (по умолчанию).</p><p>Это предложение предназначено только для совместимости с нестандартными базами данных SQL. Использовать его в новых приложениях не рекомендуется.</p></dd><dt id="SQL-CREATETABLE-PARMS-CHECK"><span class="term"><code class="literal">CHECK ( <em class="replaceable"><code>выражение</code></em> ) [ NO INHERIT ]</code></span> <a href="#SQL-CREATETABLE-PARMS-CHECK" class="id_link">#</a></dt><dd><p>В ограничении <code class="literal">CHECK</code> задаётся выражение, возвращающее логический результат, по которому определяется, будет ли успешна операция добавления или изменения для конкретных строк. Операция выполняется успешно, если результат выражения равен TRUE или UNKNOWN. Если же для какой-нибудь строки, задействованной в операции добавления или изменения, будет получен результат FALSE, возникает ошибка, и эта операция не меняет ничего в базе данных. Ограничение-проверка, заданное как ограничение столбца, должно ссылаться только на значение самого столбца, тогда как ограничение на уровне таблицы может ссылаться и на несколько столбцов.</p><p>В настоящее время выражения <code class="literal">CHECK</code> не могут содержать подзапросы или ссылаться на какие-либо переменные, кроме как на столбцы текущей строки (см. <a class="xref" href="ddl-constraints.html#DDL-CONSTRAINTS-CHECK-CONSTRAINTS" title="5.4.1. Ограничения-проверки">Подраздел 5.4.1</a>). Также допустима ссылка на системный столбец <code class="literal">tableoid</code>, но не на другие системные столбцы.</p><p>Ограничение с пометкой <code class="literal">NO INHERIT</code> не будет наследоваться дочерними таблицами.</p><p>Когда для таблицы задано несколько ограничений <code class="literal">CHECK</code>, они будут проверяться для каждой строки в алфавитном порядке имён после проверки ограничений <code class="literal">NOT NULL</code>. (До версии 9.5 в <span class="productname">PostgreSQL</span> не было установлено никакого определённого порядка обработки ограничений <code class="literal">CHECK</code>.)</p></dd><dt id="SQL-CREATETABLE-PARMS-DEFAULT"><span class="term"><code class="literal">DEFAULT <em class="replaceable"><code>выражение_по_умолчанию</code></em></code></span> <a href="#SQL-CREATETABLE-PARMS-DEFAULT" class="id_link">#</a></dt><dd><p>Предложение <code class="literal">DEFAULT</code> задаёт значение по умолчанию для столбца, в определении которого оно присутствует. Значение задаётся выражением без переменных (в частности, перекрёстные ссылки на другие столбцы текущей таблицы в нём не допускаются). Также не допускаются подзапросы. Тип данных выражения, задающего значение по умолчанию, должен соответствовать типу данных столбца.</p><p>Это выражение будет использоваться во всех операциях добавления данных, в которых не задаётся значение данного столбца. Если значение по умолчанию не определено, таким значением будет NULL.</p></dd><dt id="SQL-CREATETABLE-PARMS-GENERATED-STORED"><span class="term"><code class="literal">GENERATED ALWAYS AS ( <em class="replaceable"><code>генерирующее_выражение</code></em> ) STORED</code><a id="id-1.9.3.85.6.2.20.1.2" class="indexterm"></a></span> <a href="#SQL-CREATETABLE-PARMS-GENERATED-STORED" class="id_link">#</a></dt><dd><p>Это предложение создаёт столбец как <em class="firstterm">генерируемый</em>. В такой столбец нельзя записать данные, а при чтении его возвращается результат указанного выражения.</p><p>Ключевое слово <code class="literal">STORED</code> отмечает, что этот столбец будет вычисляться при записи и сохраняться на диске.</p><p>Генерирующее выражение может обращаться к другим столбцам таблицы, но не к другим генерируемым столбцам. Все функции и операторы в нём должны быть постоянными. Обращаться к другим таблицам в таких выражениях нельзя.</p></dd><dt id="SQL-CREATETABLE-PARMS-GENERATED-IDENTITY"><span class="term"><code class="literal">GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <em class="replaceable"><code>параметры_последовательности</code></em> ) ]</code></span> <a href="#SQL-CREATETABLE-PARMS-GENERATED-IDENTITY" class="id_link">#</a></dt><dd><p>С этим предложением столбец создаётся как <em class="firstterm">столбец идентификации</em>. С ним будет связана неявная последовательность, из которой этот столбец будет автоматически получать значения в новых строках. Такому столбцу неявно назначается свойство <code class="literal">NOT NULL</code>.</p><p>Предложения <code class="literal">ALWAYS</code> и <code class="literal">BY DEFAULT</code> определяют, как явно заданные пользователем значения будут обрабатываться командами <code class="command">INSERT</code> и <code class="command">UPDATE</code>.</p><p>В команде <code class="command">INSERT</code>, в случае выбора <code class="literal">ALWAYS</code>, пользовательское значение используется, только если в этой команде указано <code class="literal">OVERRIDING SYSTEM VALUE</code>. С предложением <code class="literal">BY DEFAULT</code> пользовательскому значению отдаётся предпочтение. За подробностями обратитесь к описанию <a class="xref" href="sql-insert.html" title="INSERT"><span class="refentrytitle">INSERT</span></a>. (В команде <code class="command">COPY</code> пользовательские значения используются всегда, вне зависимости от выбранного здесь варианта.)</p><p>В команде <code class="command">UPDATE</code>, в случае выбора <code class="literal">ALWAYS</code>, попытка поместить в столбец любое значение, отличное от <code class="literal">DEFAULT</code>, будет отвергнута. Если выбран вариант <code class="literal">BY DEFAULT</code>, столбец может быть изменён обычным образом. (Предложение <code class="literal">OVERRIDING</code> для команды <code class="command">UPDATE</code> отсутствует.)</p><p>Используя необязательное предложение <em class="replaceable"><code>параметры_последовательности</code></em>, можно переопределить свойства последовательности. За подробностями обратитесь к <a class="xref" href="sql-createsequence.html" title="CREATE SEQUENCE"><span class="refentrytitle">CREATE SEQUENCE</span></a>.</p></dd><dt id="SQL-CREATETABLE-PARMS-UNIQUE"><span class="term"><code class="literal">UNIQUE [ NULLS [ NOT ] DISTINCT ]</code> (ограничение столбца)<br /></span><span class="term"><code class="literal">UNIQUE [ NULLS [ NOT ] DISTINCT ] ( <em class="replaceable"><code>имя_столбца</code></em> [, ... ] )</code> [<span class="optional"><code class="literal">INCLUDE ( <em class="replaceable"><code>имя_столбца</code></em> [, ...])</code></span>] (ограничение таблицы)</span> <a href="#SQL-CREATETABLE-PARMS-UNIQUE" class="id_link">#</a></dt><dd><p>Ограничение <code class="literal">UNIQUE</code> определяет, что группа из одного или нескольких столбцов таблицы может содержать только уникальные значения. Ограничение уникальности для таблицы ведёт себя точно так же, как ограничение для столбца, но может охватывать несколько столбцов. Таким образом, ограничение уникальности гарантирует, что любые две строки таблицы различаются как минимум в этих столбцах.</p><p>При проверке ограничения уникальности значения NULL не считаются равными, если не указан параметр <code class="literal">NULLS NOT DISTINCT</code>.</p><p>В каждом ограничении уникальности должен задаваться набор столбцов, отличный от набора любого другого ограничения уникальности или первичного ключа в данной таблице. (Избыточные ограничения уникальности будут просто игнорироваться.)</p><p>При установлении ограничения уникальности в многоуровневой иерархии секционирования в определение ограничения должны включаться все столбцы ключа разбиения целевой секционированной таблицы, а также столбцы всех подчинённых секционированных таблиц.</p><p>При добавлении ограничения уникальности автоматически будет создан уникальный индекс-B-дерево по столбцу или группе столбцов, перечисленных в ограничении.</p><p>Необязательное предложение <code class="literal">INCLUDE</code> добавляет к этому индексу один или несколько столбцов, составляющих просто <span class="quote">«<span class="quote">дополнительную нагрузку</span>»</span>: для них уникальность не будет требоваться, и искать значения в них по данному индексу нельзя. Однако их содержимое может быть получено при сканировании только индекса. Заметьте, что хотя ограничение по неключевым столбцам не контролируется, оно всё же зависит от них. Как следствие, некоторые операции с этими столбцами (например, <code class="literal">DROP COLUMN</code>) могут повлечь каскадное удаление индекса и ограничения.</p></dd><dt id="SQL-CREATETABLE-PARMS-PRIMARY-KEY"><span class="term"><code class="literal">PRIMARY KEY</code> (ограничение столбца)<br /></span><span class="term"><code class="literal">PRIMARY KEY ( <em class="replaceable"><code>имя_столбца</code></em> [, ... ] )</code> [<span class="optional"><code class="literal">INCLUDE ( <em class="replaceable"><code>имя_столбца</code></em> [, ...])</code></span>] (ограничение таблицы)</span> <a href="#SQL-CREATETABLE-PARMS-PRIMARY-KEY" class="id_link">#</a></dt><dd><p>Ограничение <code class="literal">PRIMARY KEY</code> определяет, что столбец или столбцы таблицы могут содержать только уникальные (без повторений) значения, отличные от NULL. Для таблицы может быть задан только один первичный ключ, будь то ограничение столбца или ограничение таблицы.</p><p>В определении первичного ключа должен задаваться набор столбцов, отличный от набора любого другого ограничения уникальности, установленного для данной таблицы. (В противном случае уникальное ограничение оказывается избыточным и будет отброшено.)</p><p><code class="literal">PRIMARY KEY</code> устанавливает для данных те же ограничения, что и сочетание <code class="literal">UNIQUE</code> и <code class="literal">NOT NULL</code>, но созданный по набору столбцов первичный ключ также даёт метаинформацию о конструкции схемы, так как он подразумевает, что другие таблицы могут ссылаться на этот набор столбцов как на уникальный идентификатор строк.</p><p>Определяемые для секционированной таблицы ограничения <code class="literal">PRIMARY KEY</code> подчиняются тем же требованиям, что и ограничения <code class="literal">UNIQUE</code>.</p><p>При добавлении ограничения <code class="literal">PRIMARY KEY</code> автоматически будет создан уникальный индекс-B-дерево по столбцу или группе столбцов, перечисленных в ограничении.</p><p>Необязательное предложение <code class="literal">INCLUDE</code> добавляет к этому индексу один или несколько столбцов, составляющих просто <span class="quote">«<span class="quote">дополнительную нагрузку</span>»</span>: для них уникальность не будет требоваться, и искать значения в них по данному индексу нельзя. Однако их содержимое может быть получено при сканировании только индекса. Заметьте, что хотя ограничение по неключевым столбцам не контролируется, оно всё же зависит от них. Как следствие, некоторые операции с этими столбцами (например, <code class="literal">DROP COLUMN</code>) могут повлечь каскадное удаление индекса и ограничения.</p></dd><dt id="SQL-CREATETABLE-EXCLUDE"><span class="term"><code class="literal">EXCLUDE [ USING <em class="replaceable"><code>индексный_метод</code></em> ] ( <em class="replaceable"><code>элемент_исключения</code></em> WITH <em class="replaceable"><code>оператор</code></em> [, ... ] ) <em class="replaceable"><code>параметры_индекса</code></em> [ WHERE ( <em class="replaceable"><code>предикат</code></em> ) ]</code></span> <a href="#SQL-CREATETABLE-EXCLUDE" class="id_link">#</a></dt><dd><p>Предложение <code class="literal">EXCLUDE</code> определяет ограничение-исключение, которое гарантирует, что для любых двух строк, сравниваемых по указанным столбцам или выражениям с указанными операторами, результат не будет равен <code class="literal">TRUE</code> для всех сравнений. Если все указанные операторы проверяют равенство, это ограничение равносильно ограничению <code class="literal">UNIQUE</code>, хотя обычное ограничение уникальности будет работать быстрее. С другой стороны, в ограничениях-исключениях можно задавать более общие условия, чем простое условие на равенство. Например, можно задать ограничение, требующее, чтобы никакие две строки в таблице не содержали пересекающихся кругов (см. <a class="xref" href="datatype-geometric.html" title="8.8. Геометрические типы">Раздел 8.8</a>), применив оператор <code class="literal">&amp;&amp;</code>. Кроме того, операторы должны быть коммутативными.</p><p>Ограничения-исключения реализуются с помощью индексов, так что каждый указанный в них оператор должен быть связан с соответствующим классом операторов (см. <a class="xref" href="indexes-opclass.html" title="11.10. Семейства и классы операторов">Раздел 11.10</a>) для <em class="replaceable"><code>индексного_метода</code></em>. В каждом <em class="replaceable"><code>элементе_исключения</code></em> можно дополнительно указать класс оператора и/или параметры сортировки, подробно описанные в <a class="xref" href="sql-createindex.html" title="CREATE INDEX"><span class="refentrytitle">CREATE INDEX</span></a>.</p><p>Индексный метод доступа должен поддерживать <code class="literal">amgettuple</code> (см. <a class="xref" href="indexam.html" title="Глава 64. Определение интерфейса для индексных методов доступа">Главу 64</a>); в настоящее время это означает, что индексы <acronym class="acronym">GIN</acronym> для этого не подходят. Хотя в ограничении-исключении можно использовать B-деревья и хеш-индексы, в этом мало смысла, так как такой подход ничем не лучше обычного ограничения уникальности. Так что на практике методом доступа всегда будет <acronym class="acronym">GiST</acronym> или <acronym class="acronym">SP-GiST</acronym>.</p><p>Параметр <em class="replaceable"><code>предикат</code></em> позволяет указать ограничение-исключение для подмножества таблицы; внутри при этом создаётся частичный индекс. Заметьте, что предикат необходимо заключить в скобки.</p></dd><dt id="SQL-CREATETABLE-PARMS-REFERENCES"><span class="term"><code class="literal">REFERENCES <em class="replaceable"><code>внешняя_таблица</code></em> [ ( <em class="replaceable"><code>внешний_столбец</code></em> ) ] [ MATCH <em class="replaceable"><code>тип_совпадения</code></em> ] [ ON DELETE <em class="replaceable"><code>ссылочное_действие</code></em> ] [ ON UPDATE <em class="replaceable"><code>ссылочное_действие</code></em> ]</code> (ограничение столбца)<br /></span><span class="term"><code class="literal">FOREIGN KEY ( <em class="replaceable"><code>имя_столбца</code></em> [, ... ] ) REFERENCES <em class="replaceable"><code>внешняя_таблица</code></em> [ ( <em class="replaceable"><code>внешний_столбец</code></em> [, ... ] ) ] [ MATCH <em class="replaceable"><code>тип_совпадения</code></em> ] [ ON DELETE <em class="replaceable"><code>ссылочное_действие</code></em> ] [ ON UPDATE <em class="replaceable"><code>ссылочное_действие</code></em> ]</code> (ограничение таблицы)</span> <a href="#SQL-CREATETABLE-PARMS-REFERENCES" class="id_link">#</a></dt><dd><p>Эти предложения определяют ограничение внешнего ключа, требующее, чтобы группа из одного или нескольких столбцов новой таблицы содержала только такие значения, которым соответствуют значения в заданных столбцах некоторой строки во внешней таблице. Если список <em class="replaceable"><code>целевых_столбцов</code></em> опущен, в качестве него используется первичный ключ <em class="replaceable"><code>целевой_таблицы</code></em>. Если же он задан, в качестве целевых столбцов должны указываться столбцы неоткладываемого уникального ограничения или первичного ключа во внешней таблице, либо столбцы нечастичного уникального индекса. При этом пользователь должен иметь право <code class="literal">REFERENCES</code> во внешней таблице (либо для всей таблицы, либо только для целевых столбцов). Для добавления ограничения внешнего ключа требуется блокировка <code class="literal">SHARE ROW EXCLUSIVE</code> в целевой таблице. Обратите внимание, что нельзя определить ограничения внешнего ключа, связывающие временные и постоянные таблицы.</p><p>Значения, вставляемые в ссылающиеся столбцы, сверяются со значениями во внешних столбцах внешней таблицы с учётом заданного типа совпадения. Возможны три типа совпадения: <code class="literal">MATCH FULL</code> (полное совпадение), <code class="literal">MATCH PARTIAL</code> (частичное совпадение) и тип по умолчанию, <code class="literal">MATCH SIMPLE</code> (простое совпадение). С <code class="literal">MATCH FULL</code> ни один из столбцов составного внешнего ключа не может содержать NULL, кроме случая, когда все внешние столбцы NULL; в этом случае строка может не иметь соответствия во внешней таблице. С <code class="literal">MATCH SIMPLE</code> любой из столбцов внешнего ключа может содержать NULL; при этом строка с NULL в одном из таких столбцов может не иметь соответствия во внешней таблице. Тип <code class="literal">MATCH PARTIAL</code> ещё не реализован. (Разумеется, чтобы вопросы со сравнением NULL не возникали, к столбцам, ссылающимся на внешние, можно применить ограничения <code class="literal">NOT NULL</code>.)</p><p>Кроме того, при изменении значений во внешних столбцах с данными в столбцах этой таблицы могут производиться определённые действия. Предложение <code class="literal">ON DELETE</code> задаёт действие, производимое при удалении некоторой строки во внешней таблице. Предложение <code class="literal">ON UPDATE</code> подобным образом задаёт действие, производимое при изменении значения в целевых столбцах внешней таблицы. Если строка изменена, но это изменение не затронуло целевые столбцы, никакое действие не производится. Ссылочные действия, кроме <code class="literal">NO ACTION</code>, нельзя сделать откладываемыми, даже если ограничение объявлено как откладываемое. Для каждого предложения возможные следующие варианты действий: </p><div class="variablelist"><dl class="variablelist"><dt id="SQL-CREATETABLE-PARMS-REFERENCES-REFACT-NO-ACTION"><span class="term"><code class="literal">NO ACTION</code></span> <a href="#SQL-CREATETABLE-PARMS-REFERENCES-REFACT-NO-ACTION" class="id_link">#</a></dt><dd><p>Выдать ошибку, показывающую, что при удалении или изменении записи произойдёт нарушение ограничения внешнего ключа. Для отложенных ограничений ошибка произойдёт в момент проверки ограничения, если строки, ссылающиеся на эту запись, по-прежнему будут существовать. Этот вариант действия подразумевается по умолчанию.</p></dd><dt id="SQL-CREATETABLE-PARMS-REFERENCES-REFACT-RESTRICT"><span class="term"><code class="literal">RESTRICT</code></span> <a href="#SQL-CREATETABLE-PARMS-REFERENCES-REFACT-RESTRICT" class="id_link">#</a></dt><dd><p>Выдать ошибку, показывающую, что при удалении или изменении записи произойдёт нарушение ограничения внешнего ключа. Этот вариант подобен <code class="literal">NO ACTION</code>, но эта проверка будет неоткладываемой.</p></dd><dt id="SQL-CREATETABLE-PARMS-REFERENCES-REFACT-CASCADE"><span class="term"><code class="literal">CASCADE</code></span> <a href="#SQL-CREATETABLE-PARMS-REFERENCES-REFACT-CASCADE" class="id_link">#</a></dt><dd><p>Удалить все строки, ссылающиеся на удаляемую запись, либо поменять значения в ссылающихся столбцах на новые значения во внешних столбцах, в соответствии с операцией.</p></dd><dt id="SQL-CREATETABLE-PARMS-REFERENCES-REFACT-SET-NULL"><span class="term"><code class="literal">SET NULL [ ( <em class="replaceable"><code>имя_столбца</code></em> [, ... ] ) ]</code></span> <a href="#SQL-CREATETABLE-PARMS-REFERENCES-REFACT-SET-NULL" class="id_link">#</a></dt><dd><p>Установить во всех ссылающихся столбцах или в указанном подмножестве ссылающихся столбцов значения null. Подмножество столбцов можно указать только для действий <code class="literal">ON DELETE</code>.</p></dd><dt id="SQL-CREATETABLE-PARMS-REFERENCES-REFACT-SET-DEFAULT"><span class="term"><code class="literal">SET DEFAULT [ ( <em class="replaceable"><code>имя_столбца</code></em> [, ... ] ) ]</code></span> <a href="#SQL-CREATETABLE-PARMS-REFERENCES-REFACT-SET-DEFAULT" class="id_link">#</a></dt><dd><p>Установить во всех ссылающихся столбцах или в указанном подмножестве ссылающихся столбцов значения по умолчанию. Подмножество столбцов можно указать только для действий <code class="literal">ON DELETE</code>. (Если значения по умолчанию отличны от NULL, во внешней таблице должна быть строка, соответствующая набору этих значений; в противном случае операция завершится ошибкой.)</p></dd></dl></div><p>Если внешние столбцы меняются часто, будет разумным добавить индекс для ссылающихся столбцов, чтобы действия по обеспечению ссылочной целостности, связанные с ограничением внешнего ключа, выполнялись более эффективно.</p></dd><dt id="SQL-CREATETABLE-PARMS-DEFERRABLE"><span class="term"><code class="literal">DEFERRABLE</code><br /></span><span class="term"><code class="literal">NOT DEFERRABLE</code></span> <a href="#SQL-CREATETABLE-PARMS-DEFERRABLE" class="id_link">#</a></dt><dd><p>Это предложение определяет, может ли ограничение быть отложенным. Неоткладываемое ограничение будет проверяться немедленно после каждой команды. Проверка откладываемых ограничений может быть отложена до завершения транзакции (обычно с помощью команды <a class="link" href="sql-set-constraints.html" title="SET CONSTRAINTS"><code class="command">SET CONSTRAINTS</code></a>). По умолчанию подразумевается вариант <code class="literal">NOT DEFERRABLE</code>. В настоящее время это предложение принимают только ограничения <code class="literal">UNIQUE</code>, <code class="literal">PRIMARY KEY</code>, <code class="literal">EXCLUDE</code> и <code class="literal">REFERENCES</code> (внешний ключ). Ограничения <code class="literal">NOT NULL</code> и <code class="literal">CHECK</code> не могут быть отложенными. Заметьте, что откладываемые ограничения не могут применяться в качестве решающих при конфликте в операторе <code class="command">INSERT</code> с предложением <code class="literal">ON CONFLICT DO UPDATE</code>.</p></dd><dt id="SQL-CREATETABLE-PARMS-INITIALLY"><span class="term"><code class="literal">INITIALLY IMMEDIATE</code><br /></span><span class="term"><code class="literal">INITIALLY DEFERRED</code></span> <a href="#SQL-CREATETABLE-PARMS-INITIALLY" class="id_link">#</a></dt><dd><p>Для откладываемых ограничений это предложение определяет, когда ограничение должно проверяться по умолчанию. Ограничение с характеристикой <code class="literal">INITIALLY IMMEDIATE</code> (подразумеваемой по умолчанию) проверяется после каждого оператора. Ограничение <code class="literal">INITIALLY DEFERRED</code>, напротив, проверяется только в конце транзакции. Время проверки ограничения можно изменить явно с помощью команды <a class="link" href="sql-set-constraints.html" title="SET CONSTRAINTS"><code class="command">SET CONSTRAINTS</code></a>.</p></dd><dt id="SQL-CREATETABLE-METHOD"><span class="term"><code class="literal">USING <em class="replaceable"><code>метод</code></em></code></span> <a href="#SQL-CREATETABLE-METHOD" class="id_link">#</a></dt><dd><p>Это дополнительное предложение задаёт табличный метод доступа, который будет использоваться для сохранения содержимого новой таблицы; типом этого метода доступа должен быть <code class="literal">TABLE</code>. Подробнее об этом рассказывается в <a class="xref" href="tableam.html" title="Глава 63. Определение интерфейса для табличных методов доступа">Главе 63</a>. В случае отсутствия этого указания для новой таблицы выбирается метод доступа по умолчанию. За подробностями обратитесь к <a class="xref" href="runtime-config-client.html#GUC-DEFAULT-TABLE-ACCESS-METHOD">default_table_access_method</a>.</p></dd><dt id="SQL-CREATETABLE-PARMS-WITH"><span class="term"><code class="literal">WITH ( <em class="replaceable"><code>параметр_хранения</code></em> [= <em class="replaceable"><code>значение</code></em>] [, ... ] )</code></span> <a href="#SQL-CREATETABLE-PARMS-WITH" class="id_link">#</a></dt><dd><p>Это предложение определяет дополнительные параметры хранения для таблицы или индекса; за подробностями обратитесь к разделу <a class="xref" href="sql-createtable.html#SQL-CREATETABLE-STORAGE-PARAMETERS" title="Параметры хранения">Параметры хранения</a> ниже. В целях обратной совместимости предложение <code class="literal">WITH</code> для таблицы также может содержать указание <code class="literal">OIDS=FALSE</code>, отмечающее, что строки новой таблицы не должны содержать OID (идентификатор объекта); указание <code class="literal">OIDS=TRUE</code> более не поддерживается</p></dd><dt id="SQL-CREATETABLE-PARMS-WITHOUT-OIDS"><span class="term"><code class="literal">WITHOUT OIDS</code></span> <a href="#SQL-CREATETABLE-PARMS-WITHOUT-OIDS" class="id_link">#</a></dt><dd><p>Обеспечивающий обратную совместимость синтаксис создания таблицы с характеристикой <code class="literal">WITHOUT OIDS</code>; создание таблицы с указанием <code class="literal">WITH OIDS</code> более не поддерживается.</p></dd><dt id="SQL-CREATETABLE-PARMS-ON-COMMIT"><span class="term"><code class="literal">ON COMMIT</code></span> <a href="#SQL-CREATETABLE-PARMS-ON-COMMIT" class="id_link">#</a></dt><dd><p>Поведением временных таблиц в конце блока транзакции позволяет управлять предложение <code class="literal">ON COMMIT</code>, которое принимает три параметра: </p><div class="variablelist"><dl class="variablelist"><dt id="SQL-CREATETABLE-PARMS-ON-COMMIT-PRESERVE-ROWS"><span class="term"><code class="literal">PRESERVE ROWS</code></span> <a href="#SQL-CREATETABLE-PARMS-ON-COMMIT-PRESERVE-ROWS" class="id_link">#</a></dt><dd><p>Никакое специальное действие в конце транзакции не выполняется. Это поведение по умолчанию.</p></dd><dt id="SQL-CREATETABLE-PARMS-ON-COMMIT-DELETE-ROWS"><span class="term"><code class="literal">DELETE ROWS</code></span> <a href="#SQL-CREATETABLE-PARMS-ON-COMMIT-DELETE-ROWS" class="id_link">#</a></dt><dd><p>Все строки в этой временной таблице будут удаляться в конце каждого блока транзакции. По сути, при каждой фиксации транзакции будет автоматически выполняться <a class="link" href="sql-truncate.html" title="TRUNCATE"><code class="command">TRUNCATE</code></a>. В случае секционированной таблицы это действие не распространяется на её секции.</p></dd><dt id="SQL-CREATETABLE-PARMS-ON-COMMIT-DROP"><span class="term"><code class="literal">DROP</code></span> <a href="#SQL-CREATETABLE-PARMS-ON-COMMIT-DROP" class="id_link">#</a></dt><dd><p>Временная таблица будет удалена в конце текущего блока транзакции. Если это секционированная таблица, будут удалены и все её секции. Если у таблицы есть потомки в иерархии наследования, они также будут удалены.</p></dd></dl></div></dd><dt id="SQL-CREATETABLE-TABLESPACE"><span class="term"><code class="literal">TABLESPACE <em class="replaceable"><code>табл_пространство</code></em></code></span> <a href="#SQL-CREATETABLE-TABLESPACE" class="id_link">#</a></dt><dd><p>Здесь <em class="replaceable"><code>табл_пространство</code></em> — имя табличного пространства, в котором будет создаваться новая таблица. Если оно не указано, выбирается <a class="xref" href="runtime-config-client.html#GUC-DEFAULT-TABLESPACE">default_tablespace</a> для обычных или <a class="xref" href="runtime-config-client.html#GUC-TEMP-TABLESPACES">temp_tablespaces</a> для временных таблиц. Если же этот параметр задаётся для секционируемой таблицы, то ввиду того, что ей самой табличное пространство не требуется, заданное имя переопределяет значение <code class="literal">default_tablespace</code> (табличное пространство по умолчанию), которое применяется для всех создаваемых секций в случае отсутствия явного указания.</p></dd><dt id="SQL-CREATETABLE-PARMS-USING-INDEX-TABLESPACE"><span class="term"><code class="literal">USING INDEX TABLESPACE <em class="replaceable"><code>табл_пространство</code></em></code></span> <a href="#SQL-CREATETABLE-PARMS-USING-INDEX-TABLESPACE" class="id_link">#</a></dt><dd><p>Это предложение позволяет выбрать табличное пространство, в котором будут создаваться индексы, связанные с ограничениями <code class="literal">UNIQUE</code>, <code class="literal">PRIMARY KEY</code> или <code class="literal">EXCLUDE</code>. Если оно не указано, выбирается <a class="xref" href="runtime-config-client.html#GUC-DEFAULT-TABLESPACE">default_tablespace</a> или <a class="xref" href="runtime-config-client.html#GUC-TEMP-TABLESPACES">temp_tablespaces</a>, если таблица временная.</p></dd></dl></div><div class="refsect2" id="SQL-CREATETABLE-STORAGE-PARAMETERS"><h3>Параметры хранения</h3><a id="id-1.9.3.85.6.3.2" class="indexterm"></a><p>Предложение <code class="literal">WITH</code> позволяет установить <em class="firstterm">параметры хранения</em> для таблиц и индексов, связанных с ограничениями <code class="literal">UNIQUE</code>, <code class="literal">PRIMARY KEY</code> и <code class="literal">EXCLUDE</code>. Параметры хранения для индексов документированы в <a class="xref" href="sql-createindex.html" title="CREATE INDEX"><span class="refentrytitle">CREATE INDEX</span></a>. Поддерживаемые в настоящее время параметры хранения для таблиц перечислены ниже. Как показано, для многих параметров существует дополнительный параметр с тем же именем и префиксом <code class="literal">toast.</code>, который управляет поведением вторичной таблицы <acronym class="acronym">TOAST</acronym>, если она есть (за дополнительными сведениями о TOAST обратитесь к <a class="xref" href="storage-toast.html" title="73.2. TOAST">Разделу 73.2</a>). Если значение некоторого параметра задано для таблицы, а значение равнозначного параметра <code class="literal">toast.</code> не определено, для таблицы TOAST будет применяться значение параметра основной таблицы. Возможность задания этих параметров для секционированных таблиц не поддерживается, но вы можете задать их для отдельных конечных секций.</p><div class="variablelist"><dl class="variablelist"><dt id="RELOPTION-FILLFACTOR"><span class="term"><code class="varname">fillfactor</code> (<code class="type">integer</code>) <a id="id-1.9.3.85.6.3.4.1.1.3" class="indexterm"></a></span> <a href="#RELOPTION-FILLFACTOR" class="id_link">#</a></dt><dd><p>Фактор заполнения для таблицы, задаваемый в процентах, от 10 до 100. Значение по умолчанию — 100 (плотное заполнение). При меньшем факторе заполнения операции <code class="command">INSERT</code> упаковывают данные в страницы только до заданного процента; оставшееся место резервируется для изменения строк на этой странице. В результате <code class="command">UPDATE</code> получает шанс поместить изменённую копию строки в ту же страницу, что и исходную, что гораздо эффективнее, чем размещать её на другой странице, и увеличивает возможности для внесения изменений по схеме <a class="link" href="storage-hot.html" title="73.7. Кортежи только в куче (Heap-Only Tuples, HOT)">кортежи только в куче</a>. Для таблиц, записи в которых никогда не меняются, лучшим выбором будет плотное заполнение, но для активно изменяемых таблиц лучше выбрать меньший фактор заполнения. Этот параметр нельзя задать для таблиц TOAST.</p></dd><dt id="RELOPTION-TOAST-TUPLE-TARGET"><span class="term"><code class="literal">toast_tuple_target</code> (<code class="type">integer</code>) <a id="id-1.9.3.85.6.3.4.2.1.3" class="indexterm"></a></span> <a href="#RELOPTION-TOAST-TUPLE-TARGET" class="id_link">#</a></dt><dd><p>Параметр toast_tuple_target задаёт минимальную длину кортежа, после превышения которой мы будем пытаться сжимать и/или переносить значения больших столбцов в таблицы TOAST и до которой мы будем пытаться сократить размер кортежа после перехода к TOAST. Это затрагивает столбцы с пометкой External (внешние, которые могут переноситься), Main (основные, которые могут сжиматься) или Extended (расширенные, которые могут и сжиматься, и просто переноситься) и касается только новых кортежей. На существующие кортежи это не влияет. По умолчанию этот параметр имеет значение, позволяющее разместить минимум 4 кортежа в блоке, что при стандартном размере блока составляет 2040 байт. Допустимые значения лежат в интервале от 128 байт до (размер_блока - заголовок), по умолчанию 8160 байт. Изменение этого значения может не отражаться на очень коротких и очень длинных кортежах. Заметьте, что выбранное по умолчанию значение часто близко к оптимальному, и весьма вероятно, что изменение этого параметра в некоторых случаях будет иметь отрицательный эффект. Для таблиц TOAST этот параметр задать нельзя.</p></dd><dt id="RELOPTION-PARALLEL-WORKERS"><span class="term"><code class="literal">parallel_workers</code> (<code class="type">integer</code>) <a id="id-1.9.3.85.6.3.4.3.1.3" class="indexterm"></a></span> <a href="#RELOPTION-PARALLEL-WORKERS" class="id_link">#</a></dt><dd><p>Данный параметр задаёт число рабочих процессов, которые должны задействоваться при параллельном сканировании таблицы. Если это значение не задано, система будет определять его, исходя из размера отношения. Фактическое число рабочих процессов, выбранное планировщиком или служебными операторами, выполняющими параллельное сканирование, может быть меньше, например, вследствие ограничения <a class="xref" href="runtime-config-resource.html#GUC-MAX-WORKER-PROCESSES">max_worker_processes</a>.</p></dd><dt id="RELOPTION-AUTOVACUUM-ENABLED"><span class="term"><code class="literal">autovacuum_enabled</code>, <code class="literal">toast.autovacuum_enabled</code> (<code class="type">boolean</code>) <a id="id-1.9.3.85.6.3.4.4.1.4" class="indexterm"></a></span> <a href="#RELOPTION-AUTOVACUUM-ENABLED" class="id_link">#</a></dt><dd><p>Включает или отключает демон автоочистки для определённой таблицы. Со значением true демон автоочистки будет автоматически выполнять операции <code class="command">VACUUM</code> и/или <code class="command">ANALYZE</code> в этой таблице, согласно правилам, описанным в <a class="xref" href="routine-vacuuming.html#AUTOVACUUM" title="25.1.6. Демон автоочистки">Подразделе 25.1.6</a>. Со значением false эта таблица не будет подвергаться автоочистке, если только это не потребуется для предотвращения зацикливания идентификаторов транзакций. Более подробно предотвращение зацикливания описывается в <a class="xref" href="routine-vacuuming.html#VACUUM-FOR-WRAPAROUND" title="25.1.5. Предотвращение ошибок из-за зацикливания счётчика транзакций">Подразделе 25.1.5</a>. Заметьте, что демон автоочистки не будет запускаться вовсе (если только это не потребуется для предотвращения зацикливания), если параметр <a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM">autovacuum</a> имеет значение false; это нельзя переопределить, установив параметры хранения для отдельных таблиц. Таким образом, явно устанавливать для этого параметра значение <code class="literal">true</code> практически не имеет смысла — полезно только значение <code class="literal">false</code>.</p></dd><dt id="RELOPTION-VACUUM-INDEX-CLEANUP"><span class="term"><code class="literal">vacuum_index_cleanup</code>, <code class="literal">toast.vacuum_index_cleanup</code> (<code class="type">enum</code>) <a id="id-1.9.3.85.6.3.4.5.1.4" class="indexterm"></a></span> <a href="#RELOPTION-VACUUM-INDEX-CLEANUP" class="id_link">#</a></dt><dd><p>Включает или отключает очистку индекса при выполнении в этой таблице операции <code class="command">VACUUM</code>. Значение по умолчанию — <code class="literal">AUTO</code>. Значение <code class="literal">OFF</code> отключаёт очистку индекса, <code class="literal">ON</code> — включает, а со значением <code class="literal">AUTO</code> решение об очистке принимается динамически при каждом выполнении <code class="command">VACUUM</code>. Динамический выбор позволяет избежать во время <code class="command">VACUUM</code> ненужного сканирования индексов, в результате которого удаляются лишь несколько мёртвых кортежей. Принудительное безусловное отключение очистки индексов может очень существенно ускорить <code class="command">VACUUM</code>, но также может привести к значительному раздуванию индексов при частых изменениях данных в таблице. Если для команды <a class="link" href="sql-vacuum.html" title="VACUUM"><code class="command">VACUUM</code></a> задаётся параметр <code class="literal">INDEX_CLEANUP</code>, он переопределяет значение <code class="varname">vacuum_index_cleanup</code>.</p></dd><dt id="RELOPTION-VACUUM-TRUNCATE"><span class="term"><code class="literal">vacuum_truncate</code>, <code class="literal">toast.vacuum_truncate</code> (<code class="type">boolean</code>) <a id="id-1.9.3.85.6.3.4.6.1.4" class="indexterm"></a></span> <a href="#RELOPTION-VACUUM-TRUNCATE" class="id_link">#</a></dt><dd><p>Включает или отключает процедуру отсечения пустых страниц в конце таблицы в процессе очистки. Значение по умолчанию — <code class="literal">true</code> (вкл.). Когда этот параметр включён, операции <code class="command">VACUUM</code> и автоочистка пытаются отсечь пустые страницы, чтобы освободившееся место возвратилось операционной системе. Заметьте, что для этого отсечения требуется блокировка таблицы на уровне <code class="literal">ACCESS EXCLUSIVE</code>. Явно заданный параметр <code class="literal">TRUNCATE</code> команды <a class="link" href="sql-vacuum.html" title="VACUUM"><code class="command">VACUUM</code></a> переопределяет значение данного параметра.</p></dd><dt id="RELOPTION-AUTOVACUUM-VACUUM-THRESHOLD"><span class="term"><code class="literal">autovacuum_vacuum_threshold</code>, <code class="literal">toast.autovacuum_vacuum_threshold</code> (<code class="type">integer</code>) <a id="id-1.9.3.85.6.3.4.7.1.4" class="indexterm"></a></span> <a href="#RELOPTION-AUTOVACUUM-VACUUM-THRESHOLD" class="id_link">#</a></dt><dd><p>Значение параметра <a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-VACUUM-THRESHOLD">autovacuum_vacuum_threshold</a> для таблицы.</p></dd><dt id="RELOPTION-AUTOVACUUM-VACUUM-SCALE-FACTOR"><span class="term"><code class="literal">autovacuum_vacuum_scale_factor</code>, <code class="literal">toast.autovacuum_vacuum_scale_factor</code> (<code class="type">floating point</code>) <a id="id-1.9.3.85.6.3.4.8.1.4" class="indexterm"></a></span> <a href="#RELOPTION-AUTOVACUUM-VACUUM-SCALE-FACTOR" class="id_link">#</a></dt><dd><p>Значение параметра <a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-VACUUM-SCALE-FACTOR">autovacuum_vacuum_scale_factor</a> для таблицы.</p></dd><dt id="RELOPTION-AUTOVACUUM-VACUUM-INSERT-THRESHOLD"><span class="term"><code class="literal">autovacuum_vacuum_insert_threshold</code>, <code class="literal">toast.autovacuum_vacuum_insert_threshold</code> (<code class="type">integer</code>) <a id="id-1.9.3.85.6.3.4.9.1.4" class="indexterm"></a></span> <a href="#RELOPTION-AUTOVACUUM-VACUUM-INSERT-THRESHOLD" class="id_link">#</a></dt><dd><p>Значение параметра <a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-VACUUM-INSERT-THRESHOLD">autovacuum_vacuum_insert_threshold</a> для таблицы. Особое значение -1 отключает очистку, вызываемую добавлением данных.</p></dd><dt id="RELOPTION-AUTOVACUUM-VACUUM-INSERT-SCALE-FACTOR"><span class="term"><code class="literal">autovacuum_vacuum_insert_scale_factor</code>, <code class="literal">toast.autovacuum_vacuum_insert_scale_factor</code> (<code class="type">floating point</code>) <a id="id-1.9.3.85.6.3.4.10.1.4" class="indexterm"></a></span> <a href="#RELOPTION-AUTOVACUUM-VACUUM-INSERT-SCALE-FACTOR" class="id_link">#</a></dt><dd><p>Значение параметра <a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-VACUUM-INSERT-SCALE-FACTOR">autovacuum_vacuum_insert_scale_factor</a> для таблицы.</p></dd><dt id="RELOPTION-AUTOVACUUM-ANALYZE-THRESHOLD"><span class="term"><code class="literal">autovacuum_analyze_threshold</code> (<code class="type">integer</code>) <a id="id-1.9.3.85.6.3.4.11.1.3" class="indexterm"></a></span> <a href="#RELOPTION-AUTOVACUUM-ANALYZE-THRESHOLD" class="id_link">#</a></dt><dd><p>Значение параметра <a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-ANALYZE-THRESHOLD">autovacuum_analyze_threshold</a> для таблицы.</p></dd><dt id="RELOPTION-AUTOVACUUM-ANALYZE-SCALE-FACTOR"><span class="term"><code class="literal">autovacuum_analyze_scale_factor</code> (<code class="type">floating point</code>) <a id="id-1.9.3.85.6.3.4.12.1.3" class="indexterm"></a></span> <a href="#RELOPTION-AUTOVACUUM-ANALYZE-SCALE-FACTOR" class="id_link">#</a></dt><dd><p>Значение параметра <a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-ANALYZE-SCALE-FACTOR">autovacuum_analyze_scale_factor</a> для таблицы.</p></dd><dt id="RELOPTION-AUTOVACUUM-VACUUM-COST-DELAY"><span class="term"><code class="literal">autovacuum_vacuum_cost_delay</code>, <code class="literal">toast.autovacuum_vacuum_cost_delay</code> (<code class="type">floating point</code>) <a id="id-1.9.3.85.6.3.4.13.1.4" class="indexterm"></a></span> <a href="#RELOPTION-AUTOVACUUM-VACUUM-COST-DELAY" class="id_link">#</a></dt><dd><p>Значение параметра <a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-VACUUM-COST-DELAY">autovacuum_vacuum_cost_delay</a> для таблицы.</p></dd><dt id="RELOPTION-AUTOVACUUM-VACUUM-COST-LIMIT"><span class="term"><code class="literal">autovacuum_vacuum_cost_limit</code>, <code class="literal">toast.autovacuum_vacuum_cost_limit</code> (<code class="type">integer</code>) <a id="id-1.9.3.85.6.3.4.14.1.4" class="indexterm"></a></span> <a href="#RELOPTION-AUTOVACUUM-VACUUM-COST-LIMIT" class="id_link">#</a></dt><dd><p>Значение параметра <a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-VACUUM-COST-LIMIT">autovacuum_vacuum_cost_limit</a> для таблицы.</p></dd><dt id="RELOPTION-AUTOVACUUM-FREEZE-MIN-AGE"><span class="term"><code class="literal">autovacuum_freeze_min_age</code>, <code class="literal">toast.autovacuum_freeze_min_age</code> (<code class="type">integer</code>) <a id="id-1.9.3.85.6.3.4.15.1.4" class="indexterm"></a></span> <a href="#RELOPTION-AUTOVACUUM-FREEZE-MIN-AGE" class="id_link">#</a></dt><dd><p>Значение параметра <a class="xref" href="runtime-config-client.html#GUC-VACUUM-FREEZE-MIN-AGE">vacuum_freeze_min_age</a> для таблицы. Учтите, что система будет игнорировать установленные для таблиц значения <code class="literal">autovacuum_freeze_min_age</code>, превышающие половину системного <a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-FREEZE-MAX-AGE">autovacuum_freeze_max_age</a>.</p></dd><dt id="RELOPTION-AUTOVACUUM-FREEZE-MAX-AGE"><span class="term"><code class="literal">autovacuum_freeze_max_age</code>, <code class="literal">toast.autovacuum_freeze_max_age</code> (<code class="type">integer</code>) <a id="id-1.9.3.85.6.3.4.16.1.4" class="indexterm"></a></span> <a href="#RELOPTION-AUTOVACUUM-FREEZE-MAX-AGE" class="id_link">#</a></dt><dd><p>Значение параметра <a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-FREEZE-MAX-AGE">autovacuum_freeze_max_age</a> для таблицы. Учтите, что система будет игнорировать установленные для таблиц значения <code class="literal">autovacuum_freeze_max_age</code>, превышающие значение системного параметра (они могут быть только меньше).</p></dd><dt id="RELOPTION-AUTOVACUUM-FREEZE-TABLE-AGE"><span class="term"><code class="literal">autovacuum_freeze_table_age</code>, <code class="literal">toast.autovacuum_freeze_table_age</code> (<code class="type">integer</code>) <a id="id-1.9.3.85.6.3.4.17.1.4" class="indexterm"></a></span> <a href="#RELOPTION-AUTOVACUUM-FREEZE-TABLE-AGE" class="id_link">#</a></dt><dd><p>Значение параметра <a class="xref" href="runtime-config-client.html#GUC-VACUUM-FREEZE-TABLE-AGE">vacuum_freeze_table_age</a> для таблицы.</p></dd><dt id="RELOPTION-AUTOVACUUM-MULTIXACT-FREEZE-MIN-AGE"><span class="term"><code class="literal">autovacuum_multixact_freeze_min_age</code>, <code class="literal">toast.autovacuum_multixact_freeze_min_age</code> (<code class="type">integer</code>) <a id="id-1.9.3.85.6.3.4.18.1.4" class="indexterm"></a></span> <a href="#RELOPTION-AUTOVACUUM-MULTIXACT-FREEZE-MIN-AGE" class="id_link">#</a></dt><dd><p>Значение параметра <a class="xref" href="runtime-config-client.html#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE">vacuum_multixact_freeze_min_age</a> для таблицы. Учтите, что демон автоочистки будет игнорировать установленные для таблиц значения <code class="literal">autovacuum_multixact_freeze_min_age</code>, превышающие половину значения системного параметра <a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE">autovacuum_multixact_freeze_max_age</a>.</p></dd><dt id="RELOPTION-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE"><span class="term"><code class="literal">autovacuum_multixact_freeze_max_age</code>, <code class="literal">toast.autovacuum_multixact_freeze_max_age</code> (<code class="type">integer</code>) <a id="id-1.9.3.85.6.3.4.19.1.4" class="indexterm"></a></span> <a href="#RELOPTION-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE" class="id_link">#</a></dt><dd><p>Значение параметра <a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE">autovacuum_multixact_freeze_max_age</a> для таблицы. Учтите, что система автоочистки будет игнорировать установленные для таблиц параметры <code class="literal">autovacuum_multixact_freeze_max_age</code>, превышающие системный параметр (они могут быть только меньше).</p></dd><dt id="RELOPTION-AUTOVACUUM-MULTIXACT-FREEZE-TABLE-AGE"><span class="term"><code class="literal">autovacuum_multixact_freeze_table_age</code>, <code class="literal">toast.autovacuum_multixact_freeze_table_age</code> (<code class="type">integer</code>) <a id="id-1.9.3.85.6.3.4.20.1.4" class="indexterm"></a></span> <a href="#RELOPTION-AUTOVACUUM-MULTIXACT-FREEZE-TABLE-AGE" class="id_link">#</a></dt><dd><p>Значения параметра <a class="xref" href="runtime-config-client.html#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE">vacuum_multixact_freeze_table_age</a> для таблицы.</p></dd><dt id="RELOPTION-LOG-AUTOVACUUM-MIN-DURATION"><span class="term"><code class="literal">log_autovacuum_min_duration</code>, <code class="literal">toast.log_autovacuum_min_duration</code> (<code class="type">integer</code>) <a id="id-1.9.3.85.6.3.4.21.1.4" class="indexterm"></a></span> <a href="#RELOPTION-LOG-AUTOVACUUM-MIN-DURATION" class="id_link">#</a></dt><dd><p>Значения параметра <a class="xref" href="runtime-config-logging.html#GUC-LOG-AUTOVACUUM-MIN-DURATION">log_autovacuum_min_duration</a> для таблицы.</p></dd><dt id="RELOPTION-USER-CATALOG-TABLE"><span class="term"><code class="literal">user_catalog_table</code> (<code class="type">boolean</code>) <a id="id-1.9.3.85.6.3.4.22.1.3" class="indexterm"></a></span> <a href="#RELOPTION-USER-CATALOG-TABLE" class="id_link">#</a></dt><dd><p>Объявляет таблицу как дополнительную таблицу каталога, например для целей логической репликации. За подробностями обратитесь к <a class="xref" href="logicaldecoding-output-plugin.html#LOGICALDECODING-CAPABILITIES" title="49.6.2. Возможности">Подразделу 49.6.2</a>. Для таблиц TOAST этот параметр задать нельзя.</p></dd></dl></div></div></div><div class="refsect1" id="SQL-CREATETABLE-NOTES"><h2>Замечания</h2><p><span class="productname">PostgreSQL</span> автоматически создаёт индекс, гарантирующий уникальность, для каждого ограничения уникальности и ограничения первичного ключа. Поэтому явно создавать индекс для столбцов первичного ключа не требуется. (За дополнительными сведениями обратитесь к <a class="xref" href="sql-createindex.html" title="CREATE INDEX"><span class="refentrytitle">CREATE INDEX</span></a>.)</p><p>Ограничения уникальности и первичные ключи в текущей реализации не наследуются. Вследствие этого ограничения уникальности довольно плохо сочетаются с наследованием.</p><p>В таблице не может быть больше 1600 столбцов. (На практике фактический предел обычно ниже из-за ограничения на длину записи.)</p></div><div class="refsect1" id="SQL-CREATETABLE-EXAMPLES"><h2>Примеры</h2><p>Создание таблицы <code class="structname">films</code> и таблицы <code class="structname">distributors</code>: </p><pre class="programlisting">CREATE TABLE films (
    code        char(5) CONSTRAINT firstkey PRIMARY KEY,
    title       varchar(40) NOT NULL,
    did         integer NOT NULL,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute
);

CREATE TABLE distributors (
     did    integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
     name   varchar(40) NOT NULL CHECK (name &lt;&gt; '')
);</pre><p>Создание таблицы с двумерным массивом: </p><pre class="programlisting">CREATE TABLE array_int (
    vector  int[][]
);</pre><p>Определение ограничения уникальности для таблицы <code class="literal">films</code>. Ограничения уникальности могут быть определены для одного или нескольких столбцов таблицы: </p><pre class="programlisting">CREATE TABLE films (
    code        char(5),
    title       varchar(40),
    did         integer,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute,
    CONSTRAINT production UNIQUE(date_prod)
);</pre><p>Определение ограничения-проверки для столбца: </p><pre class="programlisting">CREATE TABLE distributors (
    did     integer CHECK (did &gt; 100),
    name    varchar(40)
);</pre><p>Определение ограничения-проверки для таблицы: </p><pre class="programlisting">CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    CONSTRAINT con1 CHECK (did &gt; 100 AND name &lt;&gt; '')
);</pre><p>Определение ограничения первичного ключа для таблицы <code class="structname">films</code>: </p><pre class="programlisting">CREATE TABLE films (
    code        char(5),
    title       varchar(40),
    did         integer,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute,
    CONSTRAINT code_title PRIMARY KEY(code,title)
);</pre><p>Определение ограничения первичного ключа для таблицы <code class="structname">distributors</code>. Следующие два примера равнозначны, но в первом используется синтаксис ограничений для таблицы, а во втором — для столбца: </p><pre class="programlisting">CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    PRIMARY KEY(did)
);

CREATE TABLE distributors (
    did     integer PRIMARY KEY,
    name    varchar(40)
);</pre><p>Определение значений по умолчанию: для столбца <code class="literal">name</code> значением по умолчанию будет строка, для столбца <code class="literal">did</code> — следующее значение объекта последовательности, а для <code class="literal">modtime</code> — время, когда была вставлена запись: </p><pre class="programlisting">CREATE TABLE distributors (
    name      varchar(40) DEFAULT 'Luso Films',
    did       integer DEFAULT nextval('distributors_serial'),
    modtime   timestamp DEFAULT current_timestamp
);</pre><p>Определение двух ограничений <code class="literal">NOT NULL</code> для столбцов таблицы <code class="classname">distributors</code>, при этом одному ограничению даётся явное имя: </p><pre class="programlisting">CREATE TABLE distributors (
    did     integer CONSTRAINT no_null NOT NULL,
    name    varchar(40) NOT NULL
);</pre><p>Определение ограничения уникальности для столбца <code class="literal">name</code>: </p><pre class="programlisting">CREATE TABLE distributors (
    did     integer,
    name    varchar(40) UNIQUE
);</pre><p> То же самое условие, но в виде ограничения таблицы: </p><pre class="programlisting">CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    UNIQUE(name)
);</pre><p>Создание такой же таблицы с фактором заполнения 70% для таблицы и её уникального индекса: </p><pre class="programlisting">CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    UNIQUE(name) WITH (fillfactor=70)
)
WITH (fillfactor=70);</pre><p>Создание таблицы <code class="structname">circles</code> с ограничением-исключением, не допускающим пересечения двух кругов: </p><pre class="programlisting">CREATE TABLE circles (
    c circle,
    EXCLUDE USING gist (c WITH &amp;&amp;)
);</pre><p>Создание таблицы <code class="structname">cinemas</code> в табличном пространстве <code class="structname">diskvol1</code>: </p><pre class="programlisting">CREATE TABLE cinemas (
        id serial,
        name text,
        location text
) TABLESPACE diskvol1;</pre><p>Создание составного типа и типизированной таблицы: </p><pre class="programlisting">CREATE TYPE employee_type AS (name text, salary numeric);

CREATE TABLE employees OF employee_type (
    PRIMARY KEY (name),
    salary WITH OPTIONS DEFAULT 1000
);</pre><p>Создание таблицы, секционируемой по диапазонам: </p><pre class="programlisting">CREATE TABLE measurement (
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (logdate);</pre><p>Создание таблицы, секционируемой по диапазонам, с ключом разбиения, включающим несколько столбцов: </p><pre class="programlisting">CREATE TABLE measurement_year_month (
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (EXTRACT(YEAR FROM logdate), EXTRACT(MONTH FROM logdate));</pre><p>Создание таблицы, секционируемой по спискам: </p><pre class="programlisting">CREATE TABLE cities (
    city_id      bigserial not null,
    name         text not null,
    population   bigint
) PARTITION BY LIST (left(lower(name), 1));</pre><p>Создание таблицы, секционируемой по хешу: </p><pre class="programlisting">CREATE TABLE orders (
    order_id     bigint not null,
    cust_id      bigint not null,
    status       text
) PARTITION BY HASH (order_id);</pre><p>Создание секции таблицы, секционируемой по диапазонам: </p><pre class="programlisting">CREATE TABLE measurement_y2016m07
    PARTITION OF measurement (
    unitsales DEFAULT 0
) FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');</pre><p>Создание нескольких секций для таблицы, секционируемой по диапазонам, с ключом разбиения, включающим несколько столбцов: </p><pre class="programlisting">CREATE TABLE measurement_ym_older
    PARTITION OF measurement_year_month
    FOR VALUES FROM (MINVALUE, MINVALUE) TO (2016, 11);

CREATE TABLE measurement_ym_y2016m11
    PARTITION OF measurement_year_month
    FOR VALUES FROM (2016, 11) TO (2016, 12);

CREATE TABLE measurement_ym_y2016m12
    PARTITION OF measurement_year_month
    FOR VALUES FROM (2016, 12) TO (2017, 01);

CREATE TABLE measurement_ym_y2017m01
    PARTITION OF measurement_year_month
    FOR VALUES FROM (2017, 01) TO (2017, 02);</pre><p>Создание секции таблицы, секционируемой по спискам: </p><pre class="programlisting">CREATE TABLE cities_ab
    PARTITION OF cities (
    CONSTRAINT city_id_nonzero CHECK (city_id != 0)
) FOR VALUES IN ('a', 'b');</pre><p>Создание секции таблицы, секционируемой по спискам (при этом сама секция также создаётся секционируемой), и добавление секции в неё: </p><pre class="programlisting">CREATE TABLE cities_ab
    PARTITION OF cities (
    CONSTRAINT city_id_nonzero CHECK (city_id != 0)
) FOR VALUES IN ('a', 'b') PARTITION BY RANGE (population);

CREATE TABLE cities_ab_10000_to_100000
    PARTITION OF cities_ab FOR VALUES FROM (10000) TO (100000);</pre><p>Создание секций таблицы, секционируемой по хешу: </p><pre class="programlisting">CREATE TABLE orders_p1 PARTITION OF orders
    FOR VALUES WITH (MODULUS 4, REMAINDER 0);
CREATE TABLE orders_p2 PARTITION OF orders
    FOR VALUES WITH (MODULUS 4, REMAINDER 1);
CREATE TABLE orders_p3 PARTITION OF orders
    FOR VALUES WITH (MODULUS 4, REMAINDER 2);
CREATE TABLE orders_p4 PARTITION OF orders
    FOR VALUES WITH (MODULUS 4, REMAINDER 3);</pre><p>Создание секции по умолчанию: </p><pre class="programlisting">CREATE TABLE cities_partdef
    PARTITION OF cities DEFAULT;</pre></div><div class="refsect1" id="SQL-CREATETABLE-COMPATIBILITY"><h2>Совместимость</h2><p>Команда <code class="command">CREATE TABLE</code> соответствует стандарту <acronym class="acronym">SQL</acronym>, с описанными ниже исключениями.</p><div class="refsect2" id="id-1.9.3.85.9.3"><h3>Временные таблицы</h3><p>Хотя синтаксис <code class="literal">CREATE TEMPORARY TABLE</code> подобен аналогичному в стандарте SQL, результат получается другим. В стандарте временные таблицы определяются только один раз и существуют (изначально пустые) в каждом сеансе, в котором они используются. <span class="productname">PostgreSQL</span> вместо этого требует, чтобы каждый сеанс выполнял собственную команду <code class="literal">CREATE TEMPORARY TABLE</code> для каждой временной таблицы, которая будет использоваться. Это позволяет использовать в разных сеансах таблицы с одинаковыми именами для разных целей, тогда как при подходе, регламентированном стандартом, все экземпляры временной таблицы с одним именем должны иметь одинаковую табличную структуру.</p><p>Поведение временных таблиц, описанное в стандарте, в большинстве своём игнорируют и другие СУБД, так что в этом отношении <span class="productname">PostgreSQL</span> ведёт себя так же, как и ряд других СУБД.</p><p>В стандарте SQL также разделяются глобальные и локальные временные таблицы — в локальной временной таблице содержится отдельный набор данных для каждого модуля SQL в отдельном сеансе, хотя её определение так же разделяется между ними. Так как в <span class="productname">PostgreSQL</span> модули SQL не поддерживаются, это различие в <span class="productname">PostgreSQL</span> не существует.</p><p>Совместимости ради, <span class="productname">PostgreSQL</span> принимает ключевые слова <code class="literal">GLOBAL</code> и <code class="literal">LOCAL</code> в объявлении временной таблицы, но в настоящее время они никак не действуют. Использовать их не рекомендуется, так как в будущих версиях <span class="productname">PostgreSQL</span> может быть принята их интерпретация, более близкая к стандарту.</p><p>Предложение <code class="literal">ON COMMIT</code> для временных таблиц тоже подобно описанному в стандарте SQL, но есть некоторые отличия. Если предложение <code class="literal">ON COMMIT</code> опущено, в SQL подразумевается поведение <code class="literal">ON COMMIT DELETE ROWS</code>. Однако в <span class="productname">PostgreSQL</span> по умолчанию действует <code class="literal">ON COMMIT PRESERVE ROWS</code>. Параметр <code class="literal">ON COMMIT DROP</code> в стандарте SQL отсутствует.</p></div><div class="refsect2" id="id-1.9.3.85.9.4"><h3>Неотложенные ограничения уникальности</h3><p>Когда ограничение <code class="literal">UNIQUE</code> или <code class="literal">PRIMARY KEY</code> не является отложенным, <span class="productname">PostgreSQL</span> проверяет уникальность непосредственно в момент добавления или изменения строки. Стандарт SQL говорит, что уникальность должна обеспечиваться только в конце оператора; это различие проявляется, например когда одна команда изменяет множество ключевых значений. Чтобы получить поведение, оговоренное стандартом, объявите ограничение как откладываемое (<code class="literal">DEFERRABLE</code>), но не отложенное (т. е., <code class="literal">INITIALLY IMMEDIATE</code>). Учтите, что этот вариант может быть значительно медленнее, чем немедленная проверка ограничений.</p></div><div class="refsect2" id="id-1.9.3.85.9.5"><h3>Ограничения-проверки для столбцов</h3><p>Стандарт SQL говорит, что ограничение <code class="literal">CHECK</code>, определяемое для столбца, может ссылаться только на столбец, с которым оно связано; только ограничения <code class="literal">CHECK</code> для таблиц могут ссылаться на несколько столбцов. В <span class="productname">PostgreSQL</span> этого ограничения нет; он воспринимает ограничения-проверки для столбцов и таблиц одинаково.</p></div><div class="refsect2" id="id-1.9.3.85.9.6"><h3>Ограничение <code class="literal">EXCLUDE</code></h3><p>Ограничения <code class="literal">EXCLUDE</code> являются расширением <span class="productname">PostgreSQL</span>.</p></div><div class="refsect2" id="id-1.9.3.85.9.7"><h3>Ограничения внешнего ключа</h3><p>Возможность указывать списки столбцов в действиях внешнего ключа <code class="literal">SET DEFAULT</code> и <code class="literal">SET NULL</code> является расширением <span class="productname">PostgreSQL</span>.</p><p>Возможность ограничения внешнего ключа ссылаться на столбцы уникального индекса вместо столбцов первичного ключа или ограничения уникальности является расширением <span class="productname">PostgreSQL</span>.</p></div><div class="refsect2" id="id-1.9.3.85.9.8"><h3><code class="literal">NULL</code> <span class="quote">«<span class="quote">Ограничение</span>»</span></h3><p><span class="quote">«<span class="quote">Ограничение</span>»</span> <code class="literal">NULL</code> (на самом деле это не ограничение) является расширением <span class="productname">PostgreSQL</span> стандарта SQL, которое реализовано для совместимости с некоторыми другими СУБД (и для симметрии с ограничением <code class="literal">NOT NULL</code>). Так как это поведение по умолчанию для любого столбца, его присутствие не несёт смысловой нагрузки.</p></div><div class="refsect2" id="id-1.9.3.85.9.9"><h3>Имена ограничений</h3><p>В стандарте SQL говорится, что имена ограничений таблицы и ограничений домена должны быть уникальными в схеме, содержащей эту таблицу или домен. Однако <span class="productname">PostgreSQL</span> менее строг: он требует только, чтобы имена были уникальны среди ограничений, присоединённых к данной конкретной таблице или домену. Но такого послабления нет для ограничений, построенных на индексах (ограничений <code class="literal">UNIQUE</code>, <code class="literal">PRIMARY KEY</code> и <code class="literal">EXCLUDE</code>), так как ограничение и связанный с ним индекс имеют одно имя, а имена индексов должны быть уникальны среди всех отношений в их схеме.</p><p>В настоящее время в <span class="productname">PostgreSQL</span> ограничения <code class="literal">NOT NULL</code> вообще не имеют имён, так что на них требования уникальности не распространяются. Однако это может поменяться в будущих выпусках.</p></div><div class="refsect2" id="id-1.9.3.85.9.10"><h3>Наследование</h3><p>Множественное наследование посредством <code class="literal">INHERITS</code> является языковым расширением <span class="productname">PostgreSQL</span>. SQL:1999 и более поздние стандарты определяют единичное наследование с другим синтаксисом и смыслом. Наследование в стиле SQL:1999 пока ещё не поддерживается в <span class="productname">PostgreSQL</span>.</p></div><div class="refsect2" id="id-1.9.3.85.9.11"><h3>Таблицы с нулём столбцов</h3><p><span class="productname">PostgreSQL</span> позволяет создать таблицу без столбцов (например, <code class="literal">CREATE TABLE foo();</code>). Это расширение стандарта SQL, который не допускает таблицы с нулём столбцов. Таблицы с нулём столбцов сами по себе не очень полезны, но если их запретить, возникают странные особые ситуации с командой <code class="command">ALTER TABLE DROP COLUMN</code>, так что лучшим вариантом кажется игнорировать это требование стандарта.</p></div><div class="refsect2" id="id-1.9.3.85.9.12"><h3>Множество столбцов идентификации</h3><p><span class="productname">PostgreSQL</span> позволяет иметь в таблице более одного столбца идентификации. В стандарте же говорится, что в таблице может быть максимум один столбец идентификации. Это ограничение ослаблено в основном для большей гибкости при выполнении изменений в схеме или миграции. Заметьте, что команда <code class="command">INSERT</code> поддерживает только одно предложение переопределения значения, применяемое ко всему оператору, так что с несколькими столбцами идентификации различное поведение не поддерживается должным образом.</p></div><div class="refsect2" id="id-1.9.3.85.9.13"><h3>Генерируемые столбцы</h3><p>Указание <code class="literal">STORED</code> отсутствует в стандарте, но используется и в других реализациях баз данных SQL. Стандарт SQL не предусматривает хранение генерируемых столбцов.</p></div><div class="refsect2" id="id-1.9.3.85.9.14"><h3>Предложение <code class="literal">LIKE</code></h3><p>Хотя предложение <code class="literal">LIKE</code> описано в стандарте SQL, многие варианты его использования, допустимые в <span class="productname">PostgreSQL</span>, в стандарте не описаны, а некоторые предусмотренные в стандарте возможности не реализованы в <span class="productname">PostgreSQL</span>.</p></div><div class="refsect2" id="id-1.9.3.85.9.15"><h3>Предложение <code class="literal">WITH</code></h3><p>Предложение <code class="literal">WITH</code> является расширением <span class="productname">PostgreSQL</span>; в стандарте параметры хранения не оговариваются.</p></div><div class="refsect2" id="id-1.9.3.85.9.16"><h3>Табличные пространства</h3><p>Концепция табличных пространств в <span class="productname">PostgreSQL</span> отсутствует в стандарте. Как следствие, предложения <code class="literal">TABLESPACE</code> и <code class="literal">USING INDEX TABLESPACE</code> являются расширениями.</p></div><div class="refsect2" id="id-1.9.3.85.9.17"><h3>Типизированные таблицы</h3><p>Типизированные таблицы реализуют подмножество стандарта SQL. Согласно стандарту, типизированная таблица содержит столбцы, соответствующие нижележащему составному типу, и ещё один столбец, ссылающийся на себя. <span class="productname">PostgreSQL</span> не поддерживает ссылающиеся на себя столбцы явно.</p></div><div class="refsect2" id="id-1.9.3.85.9.18"><h3>Предложение <code class="literal">PARTITION BY</code></h3><p>Предложение <code class="literal">PARTITION BY</code> является расширением <span class="productname">PostgreSQL</span>.</p></div><div class="refsect2" id="id-1.9.3.85.9.19"><h3>Предложение <code class="literal">PARTITION OF</code></h3><p>Предложение <code class="literal">PARTITION OF</code> является расширением <span class="productname">PostgreSQL</span>.</p></div></div><div class="refsect1" id="id-1.9.3.85.10"><h2>См. также</h2><span class="simplelist"><a class="xref" href="sql-altertable.html" title="ALTER TABLE"><span class="refentrytitle">ALTER TABLE</span></a>, <a class="xref" href="sql-droptable.html" title="DROP TABLE"><span class="refentrytitle">DROP TABLE</span></a>, <a class="xref" href="sql-createtableas.html" title="CREATE TABLE AS"><span class="refentrytitle">CREATE TABLE AS</span></a>, <a class="xref" href="sql-createtablespace.html" title="CREATE TABLESPACE"><span class="refentrytitle">CREATE TABLESPACE</span></a>, <a class="xref" href="sql-createtype.html" title="CREATE TYPE"><span class="refentrytitle">CREATE TYPE</span></a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-createsubscription.html" title="CREATE SUBSCRIPTION">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-createtableas.html" title="CREATE TABLE AS">След.</a></td></tr><tr><td width="40%" align="left" valign="top">CREATE SUBSCRIPTION </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> CREATE TABLE AS</td></tr></table></div></body></html>