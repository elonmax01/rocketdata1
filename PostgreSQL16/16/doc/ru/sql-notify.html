<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>NOTIFY</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sql-move.html" title="MOVE" /><link rel="next" href="sql-prepare.html" title="PREPARE" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">NOTIFY</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-move.html" title="MOVE">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><th width="60%" align="center">Команды SQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-prepare.html" title="PREPARE">След.</a></td></tr></table><hr /></div><div class="refentry" id="SQL-NOTIFY"><div class="titlepage"></div><a id="id-1.9.3.158.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">NOTIFY</span></h2><p>NOTIFY — сгенерировать уведомление</p></div><div class="refsynopsisdiv"><h2>Синтаксис</h2><pre class="synopsis">NOTIFY <em class="replaceable"><code>канал</code></em> [ , <em class="replaceable"><code>сообщение</code></em> ]</pre></div><div class="refsect1" id="id-1.9.3.158.5"><h2>Описание</h2><p>Команда <code class="command">NOTIFY</code> отправляет событие уведомления вместе с дополнительной строкой <span class="quote">«<span class="quote">сообщения</span>»</span> всем клиентским приложениям, которые до этого выполнили в текущей базе данных <code class="command">LISTEN <em class="replaceable"><code>канал</code></em></code> с указанным именем канала. Уведомления видны всем пользователям.</p><p><code class="command">NOTIFY</code> предоставляет простой механизм межпроцессного взаимодействия для множества процессов, работающих с одной базой данных <span class="productname">PostgreSQL</span>. Вместе с уведомлением может быть передана строка сообщения, а передавая дополнительные данные через таблицы базы данных, можно создать более высокоуровневые механизмы обмена структурированными данными.</p><p>Информация, передаваемая клиенту с уведомлением, включает имя канала уведомлений, <acronym class="acronym">PID</acronym> серверного процесса, управляющего сеансом, который выдал уведомление, и строку сообщения (она будет пустой, если сообщение не задано).</p><p>Выбор подходящих имён каналов и их назначения — дело проектировщика базы данных. Обычно имя канала совпадает с именем какой-либо таблицы в базе, а событие уведомления по сути означает <span class="quote">«<span class="quote">я изменила эту таблицу, посмотрите, что она содержит теперь</span>»</span>. Однако команды <code class="command">NOTIFY</code> и <code class="command">LISTEN</code> не навязывают именно такой подход. Например, проектировщик базы данных может выбрать разные имена каналов, чтобы сигнализировать о разных типах изменений в одной таблице. Кроме того, строку сообщения тоже можно использовать для выделения различных событий.</p><p>Если требуется сигнализировать о факте изменений в определённой таблице, используя <code class="command">NOTIFY</code>, можно применить полезный программный приём — поместить <code class="command">NOTIFY</code> в триггер уровня оператора, который будет срабатывать при изменениях в таблице. При таком подходе уведомление будет выдаваться автоматически, так что прикладной программист не рискует случайно оставить какое-либо изменение без уведомления.</p><p>Транзакции оказывают значительное влияние на работу <code class="command">NOTIFY</code>. Во-первых, если <code class="command">NOTIFY</code> выполняется внутри транзакции, уведомления доставляются получателям после фиксирования транзакции и только в этом случае. Это разумно, так как в случае прерывания транзакции действие всех команд в ней аннулируется, включая <code class="command">NOTIFY</code>. Однако это может обескуражить тех, кто ожидает, что уведомления будут приходить немедленно. Во-вторых, если ожидающий сеанс получает уведомление внутри транзакции, это событие не будет доставлено подключённому клиенту до завершения (фиксации или отката) транзакции. Это опять же объясняется тем, что если уведомление будет доставлено в рамках транзакции, которая затем будет прервана, может возникнуть желание как-то отменить его — но сервер не может <span class="quote">«<span class="quote">забрать назад</span>»</span> уведомление после того, как оно было отправлено клиенту. Поэтому уведомления доставляются только между транзакциями. Учитывая вышесказанное, в приложениях, применяющих <code class="command">NOTIFY</code> для сигнализации в реальном времени, следует минимизировать размер транзакций.</p><p>Если в рамках одной транзакции в один канал поступило несколько уведомлений с одинаковым сообщением, подписчикам доставляется только один экземпляр уведомления. Если же сообщения различаются, уведомления будут всегда доставляться по отдельности. Так же уведомления, поступающие от разных транзакций, никогда не будут объединены в одно. Не считая фильтрации последующих экземпляров дублирующихся уведомлений, <code class="command">NOTIFY</code> гарантирует, что уведомления от одной транзакции всегда доставляются в том же порядке, в каком были отправлены. Также гарантируется, что сообщения от разных транзакций поступают в порядке фиксирования этих транзакций.</p><p>Часто бывает, что клиент, выполнивший <code class="command">NOTIFY</code>, ожидает уведомления на этом же канале. В этом случае он получит своё же уведомление, как и любой другой сеанс, ожидающий уведомления. В зависимости от логики приложения, это может привести к бессмысленным операциям, например, поиску изменений в таблице, которые и были внесены этим же сеансом. Этой дополнительной работы можно избежать, если проверить, не совпадает ли <acronym class="acronym">PID</acronym> сигнализирующего процесса (указанный в данных события) с собственным <acronym class="acronym">PID</acronym> сеанса (его можно узнать, обратившись к <span class="application">libpq</span>). Если они совпадают, значит сеанс получил уведомление о собственных действиях, так что его можно игнорировать.</p></div><div class="refsect1" id="id-1.9.3.158.6"><h2>Параметры</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>канал</code></em></span></dt><dd><p>Имя канала для передачи уведомления (любой идентификатор).</p></dd><dt><span class="term"><em class="replaceable"><code>сообщение</code></em></span></dt><dd><p>Строка <span class="quote">«<span class="quote">сообщения</span>»</span>, которая будет передана вместе с уведомлением. Она должна задаваться простой текстовой константой. В стандартной конфигурации её длина должна быть меньше 8000 байт. (Если требуется передать двоичные данные или большой объём информации, лучше поместить их в таблицу базы данных и передать ключ этой записи.)</p></dd></dl></div></div><div class="refsect1" id="id-1.9.3.158.7"><h2>Замечания</h2><p>Уведомления, которые были отправлены, но ещё не обработаны всеми ожидающими сеансами, содержатся в очереди. Если эта очередь переполняется, транзакции, в которых вызывается <code class="command">NOTIFY</code>, будут завершены ошибкой при попытке фиксации. Очередь довольно велика (8 ГБ в стандартной конфигурации), так что её размера должно хватать практически во всех случаях, но если в сеансе выполняется <code class="command">LISTEN</code>, а затем продолжается очень длительная транзакция, очередь не очищается. Как только эта очередь заполняется наполовину, в журнал записываются предупреждения, в которых указывается, какой сеанс препятствует очистке очереди. В этом случае следует добиться завершения текущей транзакции в указанном сеансе, чтобы очередь была очищена.</p><p>Функция <code class="function">pg_notification_queue_usage</code> показывает, какой процент очереди в данный момент занят ожидающими уведомлениями. За дополнительными сведениями обратитесь к <a class="xref" href="functions-info.html" title="9.26. Системные информационные функции и операторы">Разделу 9.26</a>.</p><p>Транзакция, в которой выполняется <code class="command">NOTIFY</code>, не может быть подготовлена для двухфазной фиксации.</p><div class="refsect2" id="id-1.9.3.158.7.5"><h3>pg_notify</h3><a id="id-1.9.3.158.7.5.2" class="indexterm"></a><p>Также отправить уведомление можно, используя функцию <code class="literal"><code class="function">pg_notify</code>(<code class="type">text</code>, <code class="type">text</code>)</code>. Эта функция принимает в первом аргументе имя канала, а во втором текст сообщения. Гораздо удобнее использовать её, когда требуется работать с динамическими именами каналов и сообщениями.</p></div></div><div class="refsect1" id="id-1.9.3.158.8"><h2>Примеры</h2><p>Демонстрация процедуры ожидания/получения уведомления в <span class="application">psql</span>: </p><pre class="programlisting">LISTEN virtual;
NOTIFY virtual;
Asynchronous notification "virtual" received from server process with PID 8448.
NOTIFY virtual, 'This is the payload';
Asynchronous notification "virtual" with payload "This is the payload" received from server process with PID 8448.

LISTEN foo;
SELECT pg_notify('fo' || 'o', 'pay' || 'load');
Asynchronous notification "foo" with payload "payload" received from server process with PID 14728.</pre></div><div class="refsect1" id="id-1.9.3.158.9"><h2>Совместимость</h2><p>Оператор <code class="command">NOTIFY</code> отсутствует в стандарте SQL.</p></div><div class="refsect1" id="id-1.9.3.158.10"><h2>См. также</h2><span class="simplelist"><a class="xref" href="sql-listen.html" title="LISTEN"><span class="refentrytitle">LISTEN</span></a>, <a class="xref" href="sql-unlisten.html" title="UNLISTEN"><span class="refentrytitle">UNLISTEN</span></a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-move.html" title="MOVE">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-prepare.html" title="PREPARE">След.</a></td></tr><tr><td width="40%" align="left" valign="top">MOVE </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> PREPARE</td></tr></table></div></body></html>