<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>59.5. Блокировка строк в обёртках сторонних данных</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="fdw-planning.html" title="59.4. Планирование запросов с обёртками сторонних данных" /><link rel="next" href="tablesample-method.html" title="Глава 60. Написание метода извлечения выборки таблицы" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">59.5. Блокировка строк в обёртках сторонних данных</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="fdw-planning.html" title="59.4. Планирование запросов с обёртками сторонних данных">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="fdwhandler.html" title="Глава 59. Написание обёртки сторонних данных">Наверх</a></td><th width="60%" align="center">Глава 59. Написание обёртки сторонних данных</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="tablesample-method.html" title="Глава 60. Написание метода извлечения выборки таблицы">След.</a></td></tr></table><hr /></div><div class="sect1" id="FDW-ROW-LOCKING"><div class="titlepage"><div><div><h2 class="title" style="clear: both">59.5. Блокировка строк в обёртках сторонних данных <a href="#FDW-ROW-LOCKING" class="id_link">#</a></h2></div></div></div><p>Если нижележащий механизм хранения FDW поддерживает концепцию блокировки отдельных строк, предотвращающую одновременное изменение этих строк, обычно имеет смысл реализовать в FDW установление блокировок на уровне строк в приближении, настолько близком к обычным таблицам <span class="productname">PostgreSQL</span>, насколько это возможно и практично. При этом нужно учитывать ряд замечаний.</p><p>Первое важное решение, которое нужно принять — будет ли реализована <em class="firstterm">ранняя блокировка</em> или <em class="firstterm">поздняя блокировка</em>. С ранней блокировкой строка блокируется, когда впервые считывается из нижележащего хранилища, тогда как с поздней блокировкой строка блокируется, только когда известно, что её нужно заблокировать. (Различие возникает из-за того, что некоторые строки могут быть отброшены локально проверяемыми условиями ограничений или соединений.) Ранняя блокировка гораздо проще и не требует дополнительных обращений к удалённому хранилищу, но может вызывать блокировку строк, которые можно было бы не блокировать, что может повлечь учащение конфликтов и даже неожиданные взаимоблокировки. Кроме того, поздняя блокировка возможна, только если блокируемая строка может быть однозначно идентифицирована позже. Поэтому в идентификаторе строки следует идентифицировать определённую версию строки, как это делает TID в <span class="productname">PostgreSQL</span>.</p><p>По умолчанию <span class="productname">PostgreSQL</span> игнорирует возможности блокировки, обращаясь к FDW, но FDW может установить ранние блокировки и без явной поддержки со стороны ядра. Функции, описанные в <a class="xref" href="fdw-callbacks.html#FDW-CALLBACKS-ROW-LOCKING" title="59.2.6. Подпрограммы FDW для блокировки строк">Подразделе 59.2.6</a>, которые были добавлены в API в <span class="productname">PostgreSQL</span> 9.5, позволяют FDW применять поздние блокировки, если она этого пожелает.</p><p>Также следует учесть, что в режиме изоляции <code class="literal">READ COMMITTED</code> серверу <span class="productname">PostgreSQL</span> может потребоваться перепроверить условия ограничений и соединения с изменённой версией некоторого целевого кортежа. Для перепроверки условий соединения требуется повторно получить копии исходных строк, которые ранее были соединены в целевой кортеж. В случае со стандартными таблицами <span class="productname">PostgreSQL</span> для этого в список столбцов, проходящих через соединение, включаются TID из исходных таблиц, а затем исходные строки извлекаются заново при необходимости. При таком подходе набор данных соединения остаётся компактным, но требуется недорогая операция повторного чтения строк, а также возможность однозначно идентифицировать повторно считываемую версию строки по TID. Поэтому по умолчанию при работе со сторонними таблицами в список столбцов, проходящих через соединение, включается копия всей строки, извлекаемой из сторонней таблицы. Это не накладывает специальных требований на FDW, но может привести к снижению производительности при соединении слиянием или по хешу. FDW, которая может удовлетворить требованиям повторного чтения, может реализовать первый вариант.</p><p>Для команд <code class="command">UPDATE</code> или <code class="command">DELETE</code> со сторонней таблицей рекомендуется, чтобы операция <code class="literal">ForeignScan</code> в целевой таблице выполняла раннюю блокировку строк, которые она выбирает, возможно, используя аналог <code class="command">SELECT FOR UPDATE</code>. FDW может определить, является ли таблица целевой таблицей команд <code class="command">UPDATE</code>/<code class="command">DELETE</code>, во время планирования, сравнив её relid с <code class="literal">root-&gt;parse-&gt;resultRelation</code>, или во время планирования, вызвав <code class="function">ExecRelationIsTargetRelation()</code>. Также возможно выполнять позднюю блокировку в обработчике <code class="function">ExecForeignUpdate</code> или <code class="function">ExecForeignDelete</code>, но специальной поддержки для этого нет.</p><p>Для сторонних таблиц, блокировка которых запрашивается командой <code class="command">SELECT FOR UPDATE/SHARE</code>, операция <code class="literal">ForeignScan</code> так же может произвести раннюю блокировку, выбрав кортежи, используя аналог <code class="command">SELECT FOR UPDATE/SHARE</code>. Чтобы вместо этого произвести позднюю блокировку, предоставьте подпрограммы-обработчики, описанные в <a class="xref" href="fdw-callbacks.html#FDW-CALLBACKS-ROW-LOCKING" title="59.2.6. Подпрограммы FDW для блокировки строк">Подразделе 59.2.6</a>. В <code class="function">GetForeignRowMarkType</code> выберите вариант отметки строк <code class="literal">ROW_MARK_EXCLUSIVE</code>, <code class="literal">ROW_MARK_NOKEYEXCLUSIVE</code>, <code class="literal">ROW_MARK_SHARE</code> или <code class="literal">ROW_MARK_KEYSHARE</code>, в зависимости от запрошенной силы блокировки. (Код ядра будет работать одинаково при любом из этих четырёх вариантов.) Затем вы сможете определить, должна ли сторонняя таблица блокироваться командой этого типа, вызвав функцию <code class="function">get_plan_rowmark</code> во время планирования либо <code class="function">ExecFindRowMark</code> во время выполнения; нужно проверить не только, что возвращённая структура rowmark отлична от NULL, но и что её поле <code class="structfield">strength</code> не равно <code class="literal">LCS_NONE</code>.</p><p>Наконец, для сторонних таблиц, задействованных в командах <code class="command">UPDATE</code>, <code class="command">DELETE</code> или <code class="command">SELECT FOR UPDATE/SHARE</code>, но не требующих блокировки строк, можно переопределить поведение по умолчанию, заключающееся в копировании строк целиком, выбрав в <code class="function">GetForeignRowMarkType</code> вариант <code class="literal">ROW_MARK_REFERENCE</code>, получив значение силы блокировки <code class="literal">LCS_NONE</code>. В результате <code class="function">RefetchForeignRow</code> будет вызываться с таким значением <code class="structfield">markType</code>; она должна будет заново считывать строку, не запрашивая новую блокировку. (Если вы реализуете функцию <code class="function">GetForeignRowMarkType</code>, но не хотите повторно считывать незаблокированные строки, выберите для <code class="literal">LCS_NONE</code> вариант <code class="literal">ROW_MARK_COPY</code>.)</p><p>Дополнительные сведения можно получить в <code class="filename">src/include/nodes/lockoptions.h</code>, в комментариях к <code class="type">RowMarkType</code> и <code class="type">PlanRowMark</code> в <code class="filename">src/include/nodes/plannodes.h</code>, и в комментариях к <code class="type">ExecRowMark</code> в <code class="filename">src/include/nodes/execnodes.h</code>.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="fdw-planning.html" title="59.4. Планирование запросов с обёртками сторонних данных">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="fdwhandler.html" title="Глава 59. Написание обёртки сторонних данных">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="tablesample-method.html" title="Глава 60. Написание метода извлечения выборки таблицы">След.</a></td></tr><tr><td width="40%" align="left" valign="top">59.4. Планирование запросов с обёртками сторонних данных </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> Глава 60. Написание метода извлечения выборки таблицы</td></tr></table></div></body></html>