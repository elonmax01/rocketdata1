<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>69.3. Расширяемость</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="spgist-builtin-opclasses.html" title="69.2. Встроенные классы операторов" /><link rel="next" href="spgist-implementation.html" title="69.4. Реализация" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">69.3. Расширяемость</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="spgist-builtin-opclasses.html" title="69.2. Встроенные классы операторов">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="spgist.html" title="Глава 69. Индексы SP-GiST">Наверх</a></td><th width="60%" align="center">Глава 69. Индексы SP-GiST</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="spgist-implementation.html" title="69.4. Реализация">След.</a></td></tr></table><hr /></div><div class="sect1" id="SPGIST-EXTENSIBILITY"><div class="titlepage"><div><div><h2 class="title" style="clear: both">69.3. Расширяемость <a href="#SPGIST-EXTENSIBILITY" class="id_link">#</a></h2></div></div></div><p><acronym class="acronym">SP-GiST</acronym> предлагает интерфейс с высоким уровнем абстракции и таким образом требует от разработчика метода доступа реализовать только методы, специфичные для конкретного типа данных. Ядро <acronym class="acronym">SP-GiST</acronym> отвечает за эффективную схему обращений к диску и поиск в структуре дерева, а также берёт на себя заботу о параллельном доступе и поддержке журнала.</p><p>Кортежи в листьях дерева <acronym class="acronym">SP-GiST</acronym> обычно содержат значения того же типа данных, что и индексируемый столбец, но могут содержать и неточное представление индексируемого столбца. На верхнем уровне эти кортежи содержат исходное индексируемое значение данных, но на более нижних могут содержать только часть значения, например, суффикс. В этом случае опорные функции класса операторов должны уметь восстанавливать исходное значение, собирая его из внутренних кортежей, которые нужно пройти для достижения уровня конкретного листа.</p><p>Когда создаётся индекс <acronym class="acronym">SP-GiST</acronym> с неключевыми столбцами (<code class="literal">INCLUDE</code>), значения этих столбцов также будут храниться в кортежах уровня листьев. Класс операторов <acronym class="acronym">SP-GiST</acronym> не обращает внимания на неключевые столбцы, поэтому здесь они рассматриваться не будут.</p><p>Внутренние кортежи устроены сложнее, так как они представляют собой точки разветвления в дереве поиска. Каждый внутренний кортеж содержит набор из одного или нескольких <em class="firstterm">узлов</em>, представляющих группы сходных значений листьев. Узел содержит ответвление, приводящее либо к другому, внутреннему кортежу нижнего уровня, либо к короткому списку кортежей в листьях, лежащих в одной странице индекса. Для каждого узла обычно задаётся <em class="firstterm">метка</em>, описывающая его; например, в префиксном дереве меткой может быть очередной символ в строковом значении. (С другой стороны, класс операторов может опускать метки узлов, если он имеет дело с фиксированным набором узлов во всех внутренних кортежах; см. <a class="xref" href="spgist-implementation.html#SPGIST-NULL-LABELS" title="69.4.2. SP-GiST без меток узлов">Подраздел 69.4.2</a>.) Дополнительно внутренний кортеж может хранить <em class="firstterm">префикс</em>, описывающий все его члены. В префиксном дереве это может быть общий префикс всех представленных ниже строк. Значением префикса не обязательно должен быть префикс, а могут быть любые данные, требующиеся классу операторов; например, в дереве квадрантов это может быть центральная точка, от которой отмеряются четыре квадранта. В этом случае внутренний кортеж дерева квадрантов будет также содержать четыре узла, соответствующие квадрантам вокруг этой центральной точки.</p><p>Некоторые алгоритмы деревьев требует знания уровня (или глубины) текущего кортежа, так что ядро <acronym class="acronym">SP-GiST</acronym> даёт возможность классам операторов контролировать число уровней при спуске по дереву. Также имеется поддержка пошагового восстановления представленного значения, когда это требуется, и передачи вниз дополнительных данных (так называемых <em class="firstterm">переходящих значений</em>) при спуске.</p><div class="note"><h3 class="title">Примечание</h3><p>Ядро <acronym class="acronym">SP-GiST</acronym> берёт на себя заботу о значениях NULL. Хотя в индексах <acronym class="acronym">SP-GiST</acronym> не хранятся записи для NULL в индексируемых столбцах, это скрыто от кода класса операторов; записи индексов или условия поиска с NULL никогда не передаются методам класса операторов. (Предполагается, что операторы <acronym class="acronym">SP-GiST</acronym> строгие и не могут возвращать положительный результат для значений NULL.) Поэтому значения NULL здесь больше обсуждаться не будут.</p></div><p>Класс операторов индекса для <acronym class="acronym">SP-GiST</acronym> должен предоставить пять методов и может дополнительно предоставить ещё два. Все пять обязательных методов должны по единому соглашению принимать два аргумента <code class="type">internal</code>, первым из которых будет указатель на структуру C, содержащую входные значения для опорного метода, а вторым — указатель на структуру C, в которую должны помещаться выходные значения. Четыре из этих методов должны возвращать просто <code class="type">void</code>, так как их результаты помещаются в выходную структуру; однако <code class="function">leaf_consistent</code> возвращает результат <code class="type">boolean</code>. Эти методы не должны менять никакие поля в их входных структурах. Выходная структура всегда обнуляется перед вызовом пользовательского метода. Необязательный шестой метод <code class="function">compress</code> принимает в единственном аргументе значение <code class="type">datum</code>, подлежащее индексированию, и возвращает значение, подходящее для физического хранения в кортеже уровня листьев. Необязательный седьмой метод <code class="function">options</code> принимает указатель типа <code class="type">internal</code> на структуру C, в которую должны помещаться параметры для класса операторов, и возвращает <code class="type">void</code>.</p><p>Пользователь должен определить следующие пять обязательных методов:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="function">config</code></span></dt><dd><p>Возвращает статическую информацию о реализации индекса, включая OID типов данных префикса и метки узла.</p><p>В <acronym class="acronym">SQL</acronym> эта функция должна объявляться так: </p><pre class="programlisting">CREATE FUNCTION my_config(internal, internal) RETURNS void ...</pre><p> В первом аргументе передаётся указатель на структуру <code class="structname">spgConfigIn</code> языка C, содержащие входные данные для функции. Во втором аргументе передаётся указатель на структуру <code class="structname">spgConfigOut</code> языка C, в которую функция должна поместить результат. </p><pre class="programlisting">typedef struct spgConfigIn
{
    Oid         attType;        /* Индексируемый тип данных */
} spgConfigIn;

typedef struct spgConfigOut
{
    Oid         prefixType;     /* Тип данных префикса во внутренних кортежах */
    Oid         labelType;      /* Тип данных метки узла во внутренних кортежах */
    Oid         leafType;       /* Тип данных в кортежах уровня листьев */
    bool        canReturnData;  /* Класс операторов может восстановить исходные данные */
    bool        longValuesOK;   /* Класс может принимать значения, не умещающиеся на одной странице */
} spgConfigOut;</pre><p> Поле <code class="structfield">attType</code> передаётся для поддержки полиморфных классов операторов; для обычных классов операторов с фиксированным типом оно будет всегда содержать одно значение и поэтому его можно просто игнорировать.</p><p>Для классов операторов, не использующих префиксы, в <code class="structfield">prefixType</code> можно установить <code class="literal">VOIDOID</code>. Подобным образом, для классов операторов, не использующих метки узлов, в <code class="structfield">labelType</code> тоже можно установить <code class="literal">VOIDOID</code>. Признак <code class="structfield">canReturnData</code> следует установить, если класс операторов может восстановить изначально переданное в индекс значение. Признак <code class="structfield">longValuesOK</code> должен устанавливаться, только если <code class="structfield">attType</code> переменной длины и класс операторов может фрагментировать длинные значения, повторяя суффиксы (см. <a class="xref" href="spgist-implementation.html#SPGIST-LIMITS" title="69.4.1. Ограничения SP-GiST">Подраздел 69.4.1</a>).</p><p>Значение <code class="structfield">leafType</code> должно соответствовать типу хранения индекса, заданному в поле <code class="structfield">opckeytype</code> записи, которая описывает этот класс операторов в каталоге. (Обратите внимание, что <code class="structfield">opckeytype</code> может быть нулевым, тогда тип хранения определяется входным типом класса операторов, как бывает чаще всего.) Для обеспечения обратной совместимости методу <code class="function">config</code> разрешается задать <code class="structfield">leafType</code> другое значение (которое и будет использоваться); в результате содержимое индекса нельзя будет правильно идентифицировать в каталогах, поэтому данная возможность считается устаревшей. Кроме того, допускается оставить <code class="structfield">leafType</code> неинициализированным (нулевым), что будет означать, что тип хранения индекса определяется значением <code class="structfield">opckeytype</code>.</p><p>Когда <code class="structfield">attType</code> и <code class="structfield">leafType</code> различаются, должен предоставляться необязательный метод <code class="function">compress</code>. Метод <code class="function">compress</code> отвечает за преобразование данных, подлежащих индексации, из типа <code class="structfield">attType</code> в тип <code class="structfield">leafType</code>.</p></dd><dt><span class="term"><code class="function">choose</code></span></dt><dd><p>Выбирает метод для добавления нового значения во внутренний кортеж.</p><p>В <acronym class="acronym">SQL</acronym> эта функция должна объявляться так: </p><pre class="programlisting">CREATE FUNCTION my_choose(internal, internal) RETURNS void ...</pre><p> В первом аргументе передаётся указатель на структуру <code class="structname">spgChooseIn</code> языка C, содержащую входные данные для функции. Во втором аргументе передаётся указатель на структуру <code class="structname">spgChooseOut</code>, в которую функция должна поместить результат. </p><pre class="programlisting">typedef struct spgChooseIn
{
    Datum       datum;          /* исходное значение, которое должно индексироваться */
    Datum       leafDatum;      /* текущее значение, которое должно сохраниться в листе */
    int         level;          /* текущий уровень (начиная с нуля) */

    /* Данные из текущего внутреннего кортежа */
    bool        allTheSame;     /* кортеж с признаком все-равны? */
    bool        hasPrefix;      /* у кортежа есть префикс? */
    Datum       prefixDatum;    /* если да, то это значение префикса */
    int         nNodes;         /* число узлов во внутреннем кортеже */
    Datum      *nodeLabels;     /* значения меток узлов (NULL, если их нет) */
} spgChooseIn;

typedef enum spgChooseResultType
{
    spgMatchNode = 1,           /* спуститься в существующий узел */
    spgAddNode,                 /* добавить узел во внутренний кортеж */
    spgSplitTuple               /* разделить внутренний кортеж (изменить его префикс) */
} spgChooseResultType;

typedef struct spgChooseOut
{
    spgChooseResultType resultType;     /* код действия, см. выше */
    union
    {
        struct                  /* результаты для spgMatchNode */
        {
            int         nodeN;      /* спуститься к этому узлу (нумерация с 0) */
            int         levelAdd;   /* шаг увеличения уровня */
            Datum       restDatum;  /* новое значение листа */
        }           matchNode;
        struct                  /* результаты для spgAddNode */
        {
            Datum       nodeLabel;  /* метка нового узла */
            int         nodeN;      /* куда вставлять её (нумерация с 0) */
        }           addNode;
        struct                  /* результаты для spgSplitTuple */
        {
            /* Информация для формирования нового внутреннего кортежа верхнего уровня с одним дочерним кортежем */
            bool        prefixHasPrefix;    /* кортеж должен иметь префикс? */
            Datum       prefixPrefixDatum;  /* если да, его значение */
            int         prefixNNodes;       /* число узлов */
            Datum      *prefixNodeLabels;   /* их метки (или NULL, если
                                             * меток нет) */
            int         childNodeN;         /* узел, который получит дочерний кортеж */

            /* Информация для формирования нового внутреннего кортежа нижнего уровня со всеми старыми узлами */
            bool        postfixHasPrefix;   /* кортеж должен иметь префикс? */
            Datum       postfixPrefixDatum; /* если да, его значение */
        }           splitTuple;
    }           result;
} spgChooseOut;</pre><p> В <code class="structfield">datum</code> передаётся исходное значение типа <code class="structname">spgConfigIn</code>.<code class="structfield">attType</code>, которое должно быть вставлено в индекс. В <code class="structfield">leafDatum</code> содержится значение типа <code class="structname">spgConfigOut</code>.<code class="structfield">leafType</code>, изначально представляющее собой результат метода <code class="function">compress</code>, применённого к <code class="structfield">datum</code>, если метод <code class="function">compress</code> реализован, а иначе — собственно значение <code class="structfield">datum</code>. <code class="structfield">leafDatum</code> может быть другим на нижних уровнях дерева, если его изменят функции <code class="function">choose</code> или <code class="function">picksplit</code>. Когда поиск места добавления достигает страницы уровня листа, в создаваемом кортеже листа сохраняется текущее значение <code class="structfield">leafDatum</code>. В <code class="structfield">level</code> задаётся текущий уровень внутреннего кортежа, начиная с нуля для уровня корня. Признак <code class="structfield">allTheSame</code> устанавливается, если текущий внутренний кортеж содержит несколько равнозначных узлов (см. <a class="xref" href="spgist-implementation.html#SPGIST-ALL-THE-SAME" title="69.4.3. Внутренние кортежи «все-равны»">Подраздел 69.4.3</a>). Признак <code class="structfield">hasPrefix</code> устанавливается, если текущий внутренний кортеж содержит префикс; в этом случае в <code class="structfield">prefixDatum</code> задаётся его значение. Поле <code class="structfield">nNodes</code> задаёт число дочерних узлов, содержащихся во внутреннем кортеже, а <code class="structfield">nodeLabels</code> представляет массив их меток или NULL, если меток у них нет.</p><p>Функция <code class="function">choose</code> может определить, соответствует ли новое значение одному из существующих дочерних узлов, или что нужно добавить новый дочерний узел, или что новое значение не согласуется с префиксом кортежа и внутренний кортеж нужно разделить, чтобы получить менее ограничивающий префикс.</p><p>Если новое значение соответствует одному из существующих дочерних узлов, установите в <code class="structfield">resultType</code> значение <code class="literal">spgMatchNode</code>. Установите в <code class="structfield">nodeN</code> номер этого узла в массиве узлов (нумерация начинается с нуля). Установите в <code class="structfield">levelAdd</code> значение, на которое должен увеличиваться уровень (<code class="structfield">level</code>) при спуске через этот узел, либо оставьте его нулевым, если класс операторов не отслеживает уровни. Установите <code class="structfield">restDatum</code>, равным <code class="structfield">leafDatum</code>, если класс операторов не меняет значения данных от уровня к уровню, а в противном случае запишите в него изменённое значение, которое должно использоваться в качестве <code class="structfield">leafDatum</code> на следующем уровне.</p><p>Если нужно добавить новый дочерний узел, установите в <code class="structfield">resultType</code> значение <code class="literal">spgAddNode</code>. В <code class="structfield">nodeLabel</code> задайте метку для нового узла, а в <code class="structfield">nodeN</code> позицию (отсчитываемую от нуля), в которую должен вставляться узел в массиве узлов. После того как узел будет добавлен, функция <code class="function">choose</code> вызывается снова с изменённым внутренним кортежем; в результате этого вызова должен быть получен результат <code class="literal">spgMatchNode</code>.</p><p>Если новое значение не согласуется с префиксом кортежа, установите в <code class="structfield">resultType</code> значение <code class="literal">spgSplitTuple</code>. Это действие приводит к перемещению всех существующих узлов в новый внутренний кортеж нижнего уровня и замене существующего внутреннего кортежа кортежем, содержащим одну ссылку вниз на новый внутренний кортеж. Установите признак <code class="structfield">prefixHasPrefix</code>, чтобы указать, должен ли новый верхний кортеж иметь префикс, и если да, задайте в <code class="structfield">prefixPrefixDatum</code> значение префикса. Это новое значение префикса должно быть в достаточной мере менее ограничивающим, чем исходное, чтобы в индекс было принято новое значение. Запишите в <code class="structfield">prefixNNodes</code> число требующихся узлов в новом кортеже, а в <code class="structfield">prefixNodeLabels</code> — указатель на выделенный через palloc массив с их метками или NULL, если метки узлов не нужны. Заметьте, что общий размер нового кортежа верхнего уровня не должен превышать общий размер кортежа, который он замещает; это ограничивает длины нового префикса и новых меток. Установите в <code class="structfield">childNodeN</code> индекс (начиная с нуля) узла, который будет ссылаться на новый внутренний кортеж нижнего уровня. Установите признак <code class="structfield">postfixHasPrefix</code>, чтобы указать, должен ли новый внутренний кортеж нижнего уровня иметь префикс, и если да, задайте в <code class="structfield">postfixPrefixDatum</code> значение префикса. Сочетание этих двух префиксов и метки узла, ссылающегося вниз, (если она есть) должно иметь то же значение, что и исходный префикс, так как нет возможности ни изменить метки узлов, перемещённых в новый кортеж нижнего уровня, ни изменить какие-либо нижние записи индекса. После того как узел разделён, функция <code class="function">choose</code> будет вызвана снова с заменяемым внутренним кортежем. При этом вызове может быть возвращён результат <code class="literal">spgAddNode</code>, если подходящий узел не был создан действием <code class="literal">spgSplitTuple</code>. В конце концов <code class="function">choose</code> должна вернуть <code class="literal">spgMatchNode</code>, чтобы операция добавления могла перейти на следующий уровень.</p></dd><dt><span class="term"><code class="function">picksplit</code></span></dt><dd><p>Выбирает, как создать новый внутренний кортеж по набору кортежей в листьях.</p><p>В <acronym class="acronym">SQL</acronym> эта функция должна объявляться так: </p><pre class="programlisting">CREATE FUNCTION my_picksplit(internal, internal) RETURNS void ...</pre><p> В первом аргументе передаётся указатель на структуру <code class="structname">spgPickSplitIn</code> языка C, содержащую входные данные для функции. Во втором аргументе передаётся указатель на структуру <code class="structname">spgPickSplitOut</code> языка C, в которую функция должна поместить результат. </p><pre class="programlisting">typedef struct spgPickSplitIn
{
    int         nTuples;        /* число кортежей в листьях */
    Datum      *datums;         /* их значения (массив длины nTuples) */
    int         level;          /* текущий уровень (отсчитывая от 0) */
} spgPickSplitIn;

typedef struct spgPickSplitOut
{
    bool        hasPrefix;      /* новый внутренний кортеж должен иметь префикс? */
    Datum       prefixDatum;    /* если да, его значение */

    int         nNodes;         /* число узлов для нового внутреннего кортежа */
    Datum      *nodeLabels;     /* их метки (или NULL, если их нет) */

    int        *mapTuplesToNodes;   /* номер узла для каждого кортежа в листе */
    Datum      *leafTupleDatums;    /* значения, помещаемые в каждый новый кортеж */
} spgPickSplitOut;</pre><p> В <code class="structfield">nTuples</code> задаётся число предоставленных кортежей уровня листьев, а в <code class="structfield">datums</code> — массив их значений типа <code class="structname">spgConfigOut</code>.<code class="structfield">leafType</code>. В <code class="structfield">level</code> указывается текущий уровень, который должны разделять все кортежи листьев, и который станет уровнем нового внутреннего кортежа.</p><p>Установите признак <code class="structfield">hasPrefix</code>, чтобы указать, должен ли новый внутренний кортеж иметь префикс, и если да, задайте в <code class="structfield">prefixDatum</code> значение префикса. Установите в <code class="structfield">nNodes</code> количество узлов, которые будут содержаться во внутреннем кортеже, а в <code class="structfield">nodeLabels</code> — массив значений их меток либо NULL, если узлам не нужны метки. Поместите в <code class="structfield">mapTuplesToNodes</code> указатель на массив, назначающий номера узлов (начиная с нуля) каждому кортежу листа. В <code class="structfield">leafTupleDatums</code> передайте массив значений, которые должны быть сохранены в новых кортежах листьев (они будут совпадать со входными значениями (<code class="structfield">datums</code>), если класс операторов не изменяет значения от уровня к следующему). Заметьте, что функция <code class="function">picksplit</code> сама должна выделить память, используя palloc, для массивов <code class="structfield">nodeLabels</code>, <code class="structfield">mapTuplesToNodes</code> и <code class="structfield">leafTupleDatums</code>.</p><p>Если передаётся несколько кортежей листьев, ожидается, что функция <code class="function">picksplit</code> классифицирует их и разделит на несколько узлов; иначе нельзя будет разнести кортежи листьев по разным страницам, что является конечной целью этой операции. Таким образом, если <code class="function">picksplit</code> в итоге помещает все кортежи листьев в один узел, ядро SP-GiST меняет это решение и создаёт внутренний кортеж, в котором кортежи листьев связываются случайным образом с несколькими узлами с одинаковыми метками. Такой кортеж помечается флагом <code class="literal">allTheSame</code>, показывающим, что все узлы равны. Функции <code class="function">choose</code> и <code class="function">inner_consistent</code> должны работать с такими внутренними кортежами особым образом. За дополнительными сведениями обратитесь к <a class="xref" href="spgist-implementation.html#SPGIST-ALL-THE-SAME" title="69.4.3. Внутренние кортежи «все-равны»">Подразделу 69.4.3</a>.</p><p><code class="function">picksplit</code> может применяться к одному кортежу на уровне листьев, только когда функция <code class="function">config</code> установила в <code class="structfield">longValuesOK</code> значение true и было передано входное значение, большее страницы. В этом случае цель операции — отделить префикс и получить новое, более короткое значение для листа. Этот вызов будет повторяться, пока значение уровня листа не уменьшится настолько, чтобы уместиться в странице. За дополнительными сведениями обратитесь к <a class="xref" href="spgist-implementation.html#SPGIST-LIMITS" title="69.4.1. Ограничения SP-GiST">Подразделу 69.4.1</a>.</p></dd><dt><span class="term"><code class="function">inner_consistent</code></span></dt><dd><p>Возвращает набор узлов (ветвей), по которым надо продолжать поиск.</p><p>В <acronym class="acronym">SQL</acronym> эта функция должна объявляться так: </p><pre class="programlisting">CREATE FUNCTION my_inner_consistent(internal, internal) RETURNS void ...</pre><p> В первом аргументе передаётся указатель на структуру <code class="structname">spgInnerConsistentIn</code> языка C, содержащую входные данные для функции. Во втором аргументе передаётся указатель на структуру <code class="structname">spgInnerConsistentOut</code> языка C, в которую функция должна поместить результат. </p><pre class="programlisting">typedef struct spgInnerConsistentIn
{
    ScanKey     scankeys;       /* массив операторов и искомых значений */
    ScanKey     orderbys;       /* массив операторов упорядочивания и
                                 * сравниваемых значений */
    int         nkeys;          /* длина массива scankeys */
    int         norderbys;      /* длина массива orderbys */

    Datum       reconstructedValue;     /* значение, восстановленное для родителя */
    void       *traversalValue; /* переходящее значение, специфичное для класса операторов */
    MemoryContext traversalMemoryContext;   /* переходящие значения нужно помещать сюда */
    int         level;          /* текущий уровень (отсчитывается от нуля) */
    bool        returnData;     /* нужно ли возвращать исходные данные? */

    /* Данные из текущего внутреннего кортежа */
    bool        allTheSame;     /* кортеж с признаком все-равны? */
    bool        hasPrefix;      /* у кортежа есть префикс? */
    Datum       prefixDatum;    /* если да, то это значение префикса */
    int         nNodes;         /* число узлов во внутреннем кортеже */
    Datum      *nodeLabels;     /* значения меток узлов (NULL, если их нет) */
} spgInnerConsistentIn;

typedef struct spgInnerConsistentOut
{
    int         nNodes;         /* число дочерних узлов, которые нужно посетить */
    int        *nodeNumbers;    /* их номера в массиве узлов */
    int        *levelAdds;      /* шаги увеличения уровня для этих узлов */
    Datum      *reconstructedValues;    /* связанные восстановленные значения */
    void      **traversalValues;        /* переходящие значения, специфичные для класса операторов */
    double    **distances;              /* связанные расстояния */
} spgInnerConsistentOut;</pre><p> Массив <code class="structfield">scankeys</code> длины <code class="structfield">nkeys</code> описывает условия поиска по индексу. Эти условия объединяются операцией И — найдены должны быть только те записи, которые удовлетворяют всем условиям. (Заметьте, что с <code class="structfield">nkeys</code> = 0 подразумевается, что запросу удовлетворяют все записи в индексе.) Обычно эту функцию интересуют только поля <code class="structfield">sk_strategy</code> и <code class="structfield">sk_argument</code> в каждой записи массива, в которых определяется соответственно индексируемый оператор и искомое значение. В частности, нет необходимости проверять <code class="structfield">sk_flags</code>, чтобы распознать NULL в искомом значении, так как ядро SP-GiST отфильтрует такие условия. Массив <code class="structfield">orderbys</code> длины <code class="structfield">norderbys</code> подобным образом описывает упорядочивающие операторы (если они есть). В <code class="structfield">reconstructedValue</code> передаётся значение, восстановленное для родительского кортежа; это может быть <code class="literal">(Datum) 0</code> на уровне корня или если функция <code class="function">inner_consistent</code> не установила значение на предыдущем уровне. В <code class="structfield">traversalValue</code> передаётся указатель на переходящие данные, полученные из предыдущего вызова <code class="function">inner_consistent</code> для родительского кортежа индекса, либо NULL на уровне корня. Поле <code class="structfield">traversalMemoryContext</code> указывает на контекст памяти, в котором нужно сохранить выходные переходящие данные (см. ниже). В <code class="structfield">level</code> передаётся уровень текущего внутреннего кортежа (уровень корня считается нулевым). Флаг <code class="structfield">returnData</code> устанавливается, когда для этого запроса нужно получить восстановленные данные; это возможно, только если функция <code class="function">config</code> установила признак <code class="structfield">canReturnData</code>. Признак <code class="structfield">allTheSame</code> устанавливается, если текущий внутренний кортеж имеет пометку <span class="quote">«<span class="quote">все-равны</span>»</span>; в этом случае все узлы имеют одну метку (если имеют) и значит, либо все они, либо никакой не соответствует запросу (см. <a class="xref" href="spgist-implementation.html#SPGIST-ALL-THE-SAME" title="69.4.3. Внутренние кортежи «все-равны»">Подраздел 69.4.3</a>). Признак <code class="structfield">hasPrefix</code> устанавливается, если текущий внутренний кортеж содержит префикс; в этом случае в <code class="structfield">prefixDatum</code> находится его значение. В <code class="structfield">nNodes</code> задаётся число дочерних узлов, содержащихся во внутреннем кортеже, а в <code class="structfield">nodeLabels</code> — массив их меток либо NULL, если они не имеют меток.</p><p>В <code class="structfield">nNodes</code> нужно записать число дочерних узлов, которые потребуется посетить при поиске, а в <code class="structfield">nodeNumbers</code> — массив их индексов. Если класс операторов отслеживает уровни, в <code class="structfield">levelAdds</code> нужно передать массив с шагами увеличения уровня при посещении каждого узла. (Часто шаг будет одним для всех узлов, но может быть и по-другому, поэтому применяется массив.) Если потребовалось восстановить значения, поместите в <code class="structfield">reconstructedValues</code> массив значений, восстановленных для каждого дочернего узла, который нужно посетить; в противном случае оставьте <code class="structfield">reconstructedValues</code> равным NULL. Предполагается, что восстановленные значения имеют тип <code class="structname">spgConfigOut</code>.<code class="structfield">leafType</code>. (Однако ядро системы ничего не будет делать с ними, кроме как, возможно, копировать, поэтому они должны иметь такие же <code class="literal">typlen</code> и <code class="literal">typbyval</code>, что и <code class="structfield">leafType</code>.) Если выполняется поиск с упорядочиванием, поместите в <code class="structfield">distances</code> массив расстояний в соответствии с массивом <code class="structfield">orderbys</code> (узлы с меньшими расстояниями будут обрабатываться первыми). В противном случае оставьте в этом поле NULL. Если желательно передать дополнительные данные (<span class="quote">«<span class="quote">переходящие значения</span>»</span>) на нижние уровни при поиске по дереву, поместите в <code class="structfield">traversalValues</code> указатель на массив соответствующих переходящих значений, по одному для каждого дочернего узла, который нужно посетить; в противном случае оставьте в <code class="structfield">traversalValues</code> значение NULL. Заметьте, что функция <code class="function">inner_consistent</code> сама должна выделять память, используя palloc, для массивов <code class="structfield">nodeNumbers</code>, <code class="structfield">levelAdds</code>, <code class="structfield">distances</code>, <code class="structfield">reconstructedValues</code> и <code class="structfield">traversalValues</code> в текущем контексте памяти. Однако выходные переходящие значения, на которые указывает массив <code class="structfield">traversalValues</code>, должны размещаться в контексте <code class="structfield">traversalMemoryContext</code>. При этом каждое переходящее значения должно располагаться в отдельном блоке памяти palloc.</p></dd><dt><span class="term"><code class="function">leaf_consistent</code></span></dt><dd><p>Возвращает true, если кортеж листа удовлетворяет запросу.</p><p>В <acronym class="acronym">SQL</acronym> эта функция должна объявляться так: </p><pre class="programlisting">CREATE FUNCTION my_leaf_consistent(internal, internal) RETURNS bool ...</pre><p> В первом аргументе передаётся указатель на структуру <code class="structname">spgLeafConsistentIn</code> языка C, содержащую входные данные для функции. Во втором аргументе передаётся указатель на структуру <code class="structname">spgLeafConsistentOut</code> языка C, в которую функция должна поместить результат. </p><pre class="programlisting">typedef struct spgLeafConsistentIn
{
    ScanKey     scankeys;       /* массив операторов и искомых значений */
    ScanKey     orderbys;       /* массив операторов упорядочивания и
                                 * сравниваемых значений */
    int         nkeys;          /* длина массива scankeys */
    int         norderbys;      /* длина массива orderbys */

    Datum       reconstructedValue;     /* значение, восстановленное для родителя */
    void       *traversalValue; /* переходящее значение, специфичное для класса операторов */
    int         level;          /* текущий уровень (отсчитывая от нуля) */
    bool        returnData;     /* нужно ли возвращать исходные данные? */

    Datum       leafDatum;      /* значение в кортеже листа */
} spgLeafConsistentIn;

typedef struct spgLeafConsistentOut
{
    Datum       leafValue;        /* восстановленные исходные данные, при наличии */
    bool        recheck;          /* true, если оператор нужно перепроверить */
    bool        recheckDistances; /* true, если расстояния нужно перепроверить */
    double     *distances;        /* связанные расстояния */
} spgLeafConsistentOut;</pre><p> Массив <code class="structfield">scankeys</code> длины <code class="structfield">nkeys</code> описывает условия поиска по индексу. Эти условия объединяются операцией И — запросу удовлетворяют только те записи в индексе, которые удовлетворяют всем этим условиям. (Заметьте, что с <code class="structfield">nkeys</code> = 0 подразумевается, что запросу удовлетворяют все записи в индексе.) Обычно эту функцию интересуют только поля <code class="structfield">sk_strategy</code> и <code class="structfield">sk_argument</code> в каждой записи массива, в которых определяются соответственно индексируемый оператор и искомое значение. В частности, нет необходимости проверять <code class="structfield">sk_flags</code>, чтобы распознать NULL в искомом значении, так как ядро SP-GiST отфильтрует такие условия. Массив <code class="structfield">orderbys</code> длины <code class="structfield">norderbys</code> подобным образом описывает упорядочивающие операторы. В <code class="structfield">reconstructedValue</code> передаётся значение, восстановленное для родительского кортежа; это может быть <code class="literal">(Datum) 0</code> на уровне корня или если функция <code class="function">inner_consistent</code> не установила значение на предыдущем уровне. В <code class="structfield">traversalValue</code> передаётся указатель на переходящие данные, полученные из предыдущего вызова <code class="function">inner_consistent</code> для родительского кортежа индекса, либо NULL на уровне корня. В <code class="structfield">level</code> передаётся уровень текущего внутреннего кортежа (уровень корня считается нулевым). Флаг <code class="structfield">returnData</code> устанавливается, когда для этого запроса нужно получить восстановленные данные; это возможно, только если функция <code class="function">config</code> установила признак <code class="structfield">canReturnData</code>. В <code class="structfield">leafDatum</code> передаётся значение ключа, записанное в текущем кортеже листа.</p><p>Эта функция должна вернуть <code class="literal">true</code>, если кортеж листа соответствует запросу, или <code class="literal">false</code> в противном случае. В случае положительного результата, если в поле <code class="structfield">returnData</code> передано <code class="literal">true</code>, нужно поместить в <code class="structfield">leafValue</code> значение (типа <code class="structname">spgConfigIn</code>.<code class="structfield">attType</code>), изначально переданное для индексации в этот кортеж. Кроме того, флагу <code class="structfield">recheck</code> можно присвоить <code class="literal">true</code>, если соответствие неточное, так что для установления точного результата проверки нужно повторно применить оператор(ы) к собственно кортежу данных. Если выполняется упорядочивающий поиск, поместите в <code class="structfield">distances</code> массив со значениями расстояния, соответствующими массиву <code class="structfield">orderbys</code>. В противном случае оставьте в этом поле NULL. Если хотя бы одно из возвращаемых расстояний определено неточно, присвойте true полю <code class="structfield">recheckDistances</code>. В этом случае исполнитель вычислит точные расстояния после получения кортежа из кучи и переупорядочит кортежи, если потребуется.</p></dd></dl></div><p>Дополнительно пользователь может определить методы:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="function">Datum compress(Datum in)</code></span></dt><dd><p>Преобразует элемент данных в формат, подходящий для физического хранения в кортеже уровня листьев в индексе. Эта функция принимает значение типа <code class="structname">spgConfigIn</code>.<code class="structfield">attType</code> и возвращает значение типа <code class="structname">spgConfigOut</code>.<code class="structfield">leafType</code>. Возвращаемое значение не должно содержать указатель на внешние TOAST-данные.</p><p>Обратите внимание, что метод <code class="function">compress</code> применяется только к сохраняемым значениям. Методы, оценивающие согласованность, получают сканируемые в запросе ключи (<code class="structfield">scankeys</code>) неизменёнными, без обработки функцией <code class="function">compress</code>.</p></dd><dt><span class="term"><code class="function">options</code></span></dt><dd><p>Определяет набор видимых пользователю параметров, управляющих поведением класса операторов.</p><p>В <acronym class="acronym">SQL</acronym> эта функция должна объявляться так: </p><pre class="programlisting">CREATE OR REPLACE FUNCTION my_options(internal)
RETURNS void
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;</pre><p>Этой функции передаётся указатель на структуру <code class="structname">local_relopts</code>, в которую нужно внести набор параметров, относящихся к классу операторов. Обращаться к этим параметрам из других опорных функций можно с помощью макросов <code class="literal">PG_HAS_OPCLASS_OPTIONS()</code> и <code class="literal">PG_GET_OPCLASS_OPTIONS()</code>.</p><p>Так как в <acronym class="acronym">SP-GiST</acronym> представление ключа допускает гибкость, могут быть полезны параметры для настройки этого индекса.</p></dd></dl></div><p>Все опорные методы SP-GiST обычно вызываются в кратковременных контекстах памяти; то есть <code class="varname">CurrentMemoryContext</code> сбрасывается после обработки каждого кортежа. Таким образом, можно не заботиться об освобождении любых блоков памяти, выделенных функцией palloc. (Метод <code class="function">config</code> является исключением: в нём нужно не допускать утечек памяти. Но обычно метод <code class="function">config</code> не делает ничего, кроме как присваивает константы переданной структуре параметров.)</p><p>Если индексируемый столбец имеет сортируемый тип данных, правило сортировки индекса будет передаваться всем опорным методам, используя стандартный механизм <code class="function">PG_GET_COLLATION()</code>.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="spgist-builtin-opclasses.html" title="69.2. Встроенные классы операторов">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="spgist.html" title="Глава 69. Индексы SP-GiST">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="spgist-implementation.html" title="69.4. Реализация">След.</a></td></tr><tr><td width="40%" align="left" valign="top">69.2. Встроенные классы операторов </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 69.4. Реализация</td></tr></table></div></body></html>