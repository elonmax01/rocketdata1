<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>55.2. Поток сообщений</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="protocol-overview.html" title="55.1. Обзор" /><link rel="next" href="sasl-authentication.html" title="55.3. Аутентификация SASL" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">55.2. Поток сообщений</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="protocol-overview.html" title="55.1. Обзор">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="protocol.html" title="Глава 55. Клиент-серверный протокол">Наверх</a></td><th width="60%" align="center">Глава 55. Клиент-серверный протокол</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="sasl-authentication.html" title="55.3. Аутентификация SASL">След.</a></td></tr></table><hr /></div><div class="sect1" id="PROTOCOL-FLOW"><div class="titlepage"><div><div><h2 class="title" style="clear: both">55.2. Поток сообщений <a href="#PROTOCOL-FLOW" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="protocol-flow.html#PROTOCOL-FLOW-START-UP">55.2.1. Запуск</a></span></dt><dt><span class="sect2"><a href="protocol-flow.html#PROTOCOL-FLOW-SIMPLE-QUERY">55.2.2. Простое выполнение запросов</a></span></dt><dt><span class="sect2"><a href="protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY">55.2.3. Расширенное выполнение запросов</a></span></dt><dt><span class="sect2"><a href="protocol-flow.html#PROTOCOL-FLOW-PIPELINING">55.2.4. Конвейеризация</a></span></dt><dt><span class="sect2"><a href="protocol-flow.html#PROTOCOL-FLOW-FUNCTION-CALL">55.2.5. Вызов функций</a></span></dt><dt><span class="sect2"><a href="protocol-flow.html#PROTOCOL-COPY">55.2.6. Операции COPY</a></span></dt><dt><span class="sect2"><a href="protocol-flow.html#PROTOCOL-ASYNC">55.2.7. Асинхронные операции</a></span></dt><dt><span class="sect2"><a href="protocol-flow.html#PROTOCOL-FLOW-CANCELING-REQUESTS">55.2.8. Отмена выполняющихся запросов</a></span></dt><dt><span class="sect2"><a href="protocol-flow.html#PROTOCOL-FLOW-TERMINATION">55.2.9. Завершение</a></span></dt><dt><span class="sect2"><a href="protocol-flow.html#PROTOCOL-FLOW-SSL">55.2.10. Защита сеанса с <acronym class="acronym">SSL</acronym></a></span></dt><dt><span class="sect2"><a href="protocol-flow.html#PROTOCOL-FLOW-GSSAPI">55.2.11. Защита сеанса с <acronym class="acronym">GSSAPI</acronym></a></span></dt></dl></div><p>В этом разделе описывается поток сообщений и семантика каждого типа сообщений. (Подробнее точное представление каждого сообщения описывается в <a class="xref" href="protocol-message-formats.html" title="55.7. Форматы сообщений">Разделе 55.7</a>.) В зависимости от состояния соединения выделяются несколько различных разделов протокола: запуск, выполнение запросов, вызов функции, копирование (<code class="command">COPY</code>) и завершение. Есть также специальные средства для асинхронных операций (в частности, для уведомлений и отмены команд), которые могут выполняться в любой момент после этапа запуска.</p><div class="sect2" id="PROTOCOL-FLOW-START-UP"><div class="titlepage"><div><div><h3 class="title">55.2.1. Запуск <a href="#PROTOCOL-FLOW-START-UP" class="id_link">#</a></h3></div></div></div><p>Чтобы начать сеанс, клиент открывает подключение к серверу и передаёт стартовое сообщение. В этом сообщении содержатся имена пользователя и базы данных, к которой пользователь хочет подключиться; в нём также определяется, какая именно версия протокола будет использоваться. (Стартовое сообщение также может содержать дополнительные значения для параметров времени выполнения.) Проанализировав эту информацию и содержимое своих файлов конфигурации (в частности, <code class="filename">pg_hba.conf</code>), сервер определяет, можно ли предварительно разрешить это подключение, и какая дополнительная проверка подлинности требуется.</p><p>Затем сервер отправляет соответствующее сообщение с запросом аутентификации, на которое клиент должен ответить сообщением, подтверждающим его подлинность (например, по паролю). Для всех методов аутентификации, за исключением GSSAPI, SSPI и SASL, может быть максимум один запрос и один ответ. Для некоторых методов ответ клиента вообще не требуется, так что запрос аутентификации также не передаётся. Методы GSSAPI, SSPI и SASL для прохождения проверки подлинности могут потребовать выполнить серию обменов пакетами.</p><p>Цикл аутентификации заканчивает сервер, либо запрещая соединение (ErrorResponse), либо принимая его (отправляя AuthenticationOk).</p><p>Сервер может передавать в этой фазе следующие сообщения: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">ErrorResponse (Ошибочный ответ)</span></dt><dd><p>Попытка соединения была отвергнута. Сразу после этого сервер закрывает соединение.</p></dd><dt><span class="term">AuthenticationOk (Аутентификация пройдена)</span></dt><dd><p>Обмен сообщениями для проверки подлинности завершён успешно.</p></dd><dt><span class="term">AuthenticationKerberosV5 (Аутентификация Kerberos V5)</span></dt><dd><p>Клиент должен теперь принять участие в диалоге аутентификации по протоколу Kerberos V5 (здесь его детали не описывается, так как они относятся к спецификации Kerberos) с сервером. Если этот диалог завершается успешно, сервер отвечает AuthenticationOk, иначе — ErrorResponse. Этот вариант аутентификации больше не поддерживается.</p></dd><dt><span class="term">AuthenticationCleartextPassword (Аутентификация с открытым паролем)</span></dt><dd><p>Клиент должен передать в ответ сообщение PasswordMessage, содержащее пароль в открытом виде. Если пароль правильный, сервер отвечает ему AuthenticationOk, иначе — ErrorResponse.</p></dd><dt><span class="term">AuthenticationMD5Password (Аутентификация с паролем MD5)</span></dt><dd><p>Клиент должен передать в ответ сообщение PasswordMessage с результатом преобразования пароля (и имени пользователя) в хеш MD5 с последующим хешированием с четырёхбайтовым случайным значением соли, переданным в сообщении AuthenticationMD5Password. Если пароль правильный, сервер отвечает AuthenticationOk, иначе — ErrorResponse. Содержимое сообщения PasswordMessage можно вычислить в SQL как <code class="literal">concat('md5', md5(concat(md5(concat(password, username)), random-salt)))</code>. (Учтите, что функция <code class="function">md5()</code> возвращает результат в виде шестнадцатеричной строки.)</p></dd><dt><span class="term">AuthenticationGSS (Аутентификация GSS)</span></dt><dd><p>Клиент должен начать согласование GSSAPI. В ответ на это сообщение клиент отправляет GSSResponse с первой частью потока данных GSSAPI. Если потребуются дополнительные сообщения, сервер передаст в ответ AuthenticationGSSContinue.</p></dd><dt><span class="term">AuthenticationSSPI (Аутентификация SSPI)</span></dt><dd><p>Клиент должен начать согласование SSPI. В ответ на это сообщение клиент отправляет GSSResponse с первой частью потока данных SSPI. Если потребуются дополнительные сообщения, сервер передаст в ответ AuthenticationGSSContinue.</p></dd><dt><span class="term">AuthenticationGSSContinue (Продолжение аутентификации GSS)</span></dt><dd><p>Это сообщение содержит данные ответа на предыдущий шаг согласования GSSAPI или SSPI (AuthenticationGSS, AuthenticationSSPI или предыдущего AuthenticationGSSContinue). Если в структуре GSSAPI или SSPI в этом сообщении указывается, что для завершения аутентификации требуются дополнительные данные, клиент должен передать их в очередном сообщении GSSResponse. Если этим сообщением завершается проверка подлинности GSSAPI или SSPI, сервер затем передаёт AuthenticationOk, сообщая об успешной проверке подлинности, либо ErrorResponse, сообщая об ошибке.</p></dd><dt><span class="term">AuthenticationSASL (Аутентификация SASL)</span></dt><dd><p>Клиент должен начать согласование SASL, используя один из механизмов SASL, перечисленных в сообщении. В ответ на это сообщение клиент отправляет SASLInitialResponse с именем выбранного механизма и первой частью потока данных SASL. Если потребуются дополнительные сообщения, сервер передаст в ответ AuthenticationSASLContinue. За подробностями обратитесь к <a class="xref" href="sasl-authentication.html" title="55.3. Аутентификация SASL">Разделу 55.3</a>.</p></dd><dt><span class="term">AuthenticationSASLContinue (Продолжение аутентификации SASL)</span></dt><dd><p>Это сообщение содержит данные вызова с предыдущего шага согласования SASL (AuthenticationSASL или предыдущего AuthenticationSASLContinue). Клиент должен передать в ответ сообщение SASLResponse.</p></dd><dt><span class="term">AuthenticationSASLFinal (Окончание аутентификации SASL)</span></dt><dd><p>Аутентификация SASL завершена с дополнительными данными для клиента, специфичными для механизма. Затем сервер передаст сообщение AuthenticationOk, говорящее об успешной аутентификации, или ErrorResponse, говорящее об ошибке. Данное сообщение передаётся, только если механизм SASL должен в завершение передать с сервера клиенту дополнительные специфичные данные.</p></dd><dt><span class="term">NegotiateProtocolVersion</span></dt><dd><p>Сервер не поддерживает младшую версию протокола, запрошенную клиентом, но поддерживает более раннюю версию протокола; в этом сообщении указывается наибольшая поддерживаемая младшая версия. Это сообщение будет также передаваться, если клиент запросил в стартовом пакете неподдерживаемые параметры протокола (то есть, начинающиеся с <code class="literal">_pq_.</code>). За этим сообщением должен последовать или ответ ErrorResponse, или сообщение, говорящее об успехе или неудаче проверки подлинности.</p></dd></dl></div><p>Если клиент не поддерживает метод проверки подлинности, запрошенный сервером, он должен немедленно закрыть соединение.</p><p>Получив сообщение AuthenticationOk, клиент должен ждать дальнейших сообщений от сервера. В этой фазе запускается обслуживающий процесс, а клиент представляет собой просто заинтересованного наблюдателя. Попытка запуска может быть неудачной (и клиент получит ErrorResponse) либо сервер может отказать в поддержке запрошенной младшей версии протокола (NegotiateProtocolVersion), но в обычной ситуации обслуживающий процесс передаёт несколько сообщений ParameterStatus, BackendKeyData и, наконец, ReadyForQuery.</p><p>В ходе этой фазы обслуживающий процесс попытается применить все параметры времени выполнения, полученные в стартовом сообщении. Если это удастся, эти значения становятся сеансовыми значениями по умолчанию. При ошибке он передаёт ErrorResponse и завершается.</p><p>Обслуживающий процесс может передавать в этой фазе следующие сообщения: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">BackendKeyData (Данные ключа сервера)</span></dt><dd><p>В этом сообщении передаётся секретный ключ, который клиент должен сохранить, чтобы впоследствии иметь возможность выполнять запросы. Клиент не должен отвечать на это сообщение, он должен дожидаться сообщения ReadyForQuery.</p></dd><dt><span class="term">ParameterStatus (Состояние параметров)</span></dt><dd><p>Это сообщение говорит клиенту о текущих (начальных) значениях параметров обслуживающего процесса, например, <a class="xref" href="runtime-config-client.html#GUC-CLIENT-ENCODING">client_encoding</a> или <a class="xref" href="runtime-config-client.html#GUC-DATESTYLE">DateStyle</a>. Клиент может проигнорировать это сообщение или сохранить значения для дальнейшего использования; за дополнительными подробностями обратитесь к <a class="xref" href="protocol-flow.html#PROTOCOL-ASYNC" title="55.2.7. Асинхронные операции">Подразделу 55.2.7</a>. Клиент не должен отвечать на это сообщение, он должен дожидаться сообщения ReadyForQuery.</p></dd><dt><span class="term">ReadyForQuery (Готов к запросам)</span></dt><dd><p>Запуск завершён. Теперь клиент может выполнять команды.</p></dd><dt><span class="term">ErrorResponse (Ошибочный ответ)</span></dt><dd><p>Запуск не удался. Соединение закрывается после передачи этого сообщения.</p></dd><dt><span class="term">NoticeResponse (Ответ с замечанием)</span></dt><dd><p>Выдаётся предупреждающее сообщение. Клиент должен вывести это сообщение, но продолжать ожидать сообщения ReadyForQuery или ErrorResponse.</p></dd></dl></div><p>Сообщение ReadyForQuery в данной фазе ничем не отличается от сообщений, который передаёт сервер после каждого цикла команд. В зависимости от условий реализации клиента, можно воспринимать сообщение ReadyForQuery как начинающее цикл команд, либо как завершающее фазу запуска и каждый последующий цикл команд.</p></div><div class="sect2" id="PROTOCOL-FLOW-SIMPLE-QUERY"><div class="titlepage"><div><div><h3 class="title">55.2.2. Простое выполнение запросов <a href="#PROTOCOL-FLOW-SIMPLE-QUERY" class="id_link">#</a></h3></div></div></div><p>Цикл простого выполнения запросов начинает клиент, передавая серверу сообщение Query. Это сообщение включает команду (или команды) SQL, выраженную в виде текстовой строки. В ответ сервер передаёт одно или несколько сообщений, в зависимости от строки запроса, и завершает цикл сообщением ReadyForQuery. ReadyForQuery говорит клиенту, что он может безопасно передавать новую команду. (На самом деле клиент может передать следующую команду, не дожидаясь ReadyForQuery, но тогда он сам должен разобраться в ситуации, когда первая команда завершается ошибкой, а последующая выполняется успешно.)</p><p>Сервер может передавать в этой фазе следующие ответные сообщения: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">CommandComplete (Команда завершена)</span></dt><dd><p>Команда SQL выполнена нормально.</p></dd><dt><span class="term">CopyInResponse (Ответ входящего копирования)</span></dt><dd><p>Сервер готов копировать данные, получаемые от клиента, в таблицу; см. <a class="xref" href="protocol-flow.html#PROTOCOL-COPY" title="55.2.6. Операции COPY">Подраздел 55.2.6</a>.</p></dd><dt><span class="term">CopyOutResponse (Ответ исходящего копирования)</span></dt><dd><p>Сервер готов копировать данные из таблицы клиенту; см. <a class="xref" href="protocol-flow.html#PROTOCOL-COPY" title="55.2.6. Операции COPY">Подраздел 55.2.6</a>.</p></dd><dt><span class="term">RowDescription (Описание строк)</span></dt><dd><p>Показывает, что в ответ на запрос <code class="command">SELECT</code>, <code class="command">FETCH</code> и т. п. будут возвращены строки. В содержимом этого сообщения описывается структура столбцов этих строк. За ним для каждой строки, возвращаемой клиенту, следует сообщение DataRow.</p></dd><dt><span class="term">DataRow (Строка данных)</span></dt><dd><p>Одна строка из набора, возвращаемого запросом <code class="command">SELECT</code>, <code class="command">FETCH</code> и т. п.</p></dd><dt><span class="term">EmptyQueryResponse (Ответ на пустой запрос)</span></dt><dd><p>Была принята пустая строка запроса.</p></dd><dt><span class="term">ErrorResponse (Ошибочный ответ)</span></dt><dd><p>Произошла ошибка.</p></dd><dt><span class="term">ReadyForQuery (Готов к запросам)</span></dt><dd><p>Обработка строки запроса завершена. Чтобы отметить это, отправляется отдельное сообщение, так как строка запроса может содержать несколько команд SQL. (Сообщение CommandComplete говорит о завершении обработки одной команды SQL, а не всей строки.) ReadyForQuery передаётся всегда, и при успешном завершении обработки, и при ошибке.</p></dd><dt><span class="term">NoticeResponse (Ответ с замечанием)</span></dt><dd><p>Выдаётся предупреждение, связанное с запросом. Эти замечания дополняют другие ответы, то есть сервер, выдавая их, продолжает обрабатывать команду.</p></dd></dl></div><p>Ответ на запрос <code class="command">SELECT</code> (или другие запросы, возвращающие наборы строк, такие как <code class="command">EXPLAIN</code> и <code class="command">SHOW</code>) обычно состоит из RowDescription, нуля или нескольких сообщений DataRow, и завершающего CommandComplete. Для команды <code class="command">COPY</code> с вводом или выводом данных через клиента, применяется специальный протокол, описанный в <a class="xref" href="protocol-flow.html#PROTOCOL-COPY" title="55.2.6. Операции COPY">Подразделе 55.2.6</a>. Со всеми другими типами запросами обычно выдаётся только сообщение CommandComplete.</p><p>Так как строка запроса может содержать несколько запросов (разделённых точкой с запятой), до завершения обработки всей строки сервер может передать несколько серий таких ответов. Когда сервер завершает обработку всей строки и готов принять следующую строку запроса, он выдаёт сообщение ReadyForQuery.</p><p>Если получена полностью пустая строка запроса (не содержащая ничего, кроме пробельных символов), ответом будет EmptyQueryResponse с последующим ReadyForQuery.</p><p>В случае ошибки выдаётся ErrorResponse с последующим ReadyForQuery. Сообщение ErrorResponse прерывает дальнейшую обработку строки запроса (даже если в ней остались другие запросы). Заметьте, что оно может быть выдано и в середине последовательности сообщений, выдаваемых в ответ на отдельный запрос.</p><p>В случае простого выполнения запросов получаемые значения всегда передаются в текстовом формате, за исключением результатов команды <code class="command">FETCH</code> для курсора, объявленного с атрибутом <code class="literal">BINARY</code>. С такой командой значения передаются в двоичном формате. Какой именно формат используется, определяют коды формата, передаваемые в сообщении RowDescription.</p><p>Клиент должен быть готов принять сообщения ErrorResponse и NoticeResponse, ожидая любой другой тип сообщений. Также обратитесь к <a class="xref" href="protocol-flow.html#PROTOCOL-ASYNC" title="55.2.7. Асинхронные операции">Подразделу 55.2.7</a> за информацией о сообщениях, которые сервер может выдавать в ответ на внешние события.</p><p>Код клиента рекомендуется реализовывать в виде конечного автомата, который в любой момент будет принимать сообщения всех типов, имеющих смысл на данном этапе, но не программировать жёстко обработку точной последовательности сообщений.</p><div class="sect3" id="PROTOCOL-FLOW-MULTI-STATEMENT"><div class="titlepage"><div><div><h4 class="title">55.2.2.1. Несколько операторов в простом протоколе запросов <a href="#PROTOCOL-FLOW-MULTI-STATEMENT" class="id_link">#</a></h4></div></div></div><p>Когда простое сообщение Query содержит несколько SQL-операторов (разделённых точкой с запятой), эти операторы выполняются в одной транзакции, если только среди них нет явных команд управления транзакциями, меняющих это поведение. Например, если сообщение содержит </p><pre class="programlisting">INSERT INTO mytable VALUES(1);
SELECT 1/0;
INSERT INTO mytable VALUES(2);</pre><p>, то ошибка деления на ноль в <code class="command">SELECT</code> приведёт к откату результата первого <code class="command">INSERT</code>. Более того, вследствие прерывания обработки сообщения на первой ошибке, второй <code class="command">INSERT</code> не будет выполняться вовсе.</p><p>Если же сообщение содержит: </p><pre class="programlisting">BEGIN;
INSERT INTO mytable VALUES(1);
COMMIT;
INSERT INTO mytable VALUES(2);
SELECT 1/0;</pre><p> результат первого <code class="command">INSERT</code> фиксируется явной командой <code class="command">COMMIT</code>. Второй <code class="command">INSERT</code> и последующий <code class="command">SELECT</code> будут так же обрабатываться в одной транзакции, поэтому ошибка деления на ноль приведёт к откату второго <code class="command">INSERT</code>, и не затронет первый.</p><p>Для реализации этого поведения операторы в составном сообщении запроса выполняются в <em class="firstterm">неявном блоке транзакции</em>, если только в сообщении нет явного блока транзакции, в котором они должны выполняться. Основное отличие неявного блока транзакции от обычного состоит в том, что неявный блок автоматически закрывается в конце сообщения Query — либо неявно фиксируется при отсутствии ошибок, либо неявно откатывается в противном случае. Подобная неявная фиксация или отмена транзакции имеет место, когда оператор выполняется отдельно (вне блока транзакции).</p><p>Если в рамках сеанса уже начат блок транзакции (в результате выполнения оператора <code class="command">BEGIN</code> из некоторого предыдущего сообщения), сообщение Query просто продолжает этот блок независимо от того, содержится ли в нём один оператор или несколько. Однако если сообщение Query содержит команду <code class="command">COMMIT</code> или <code class="command">ROLLBACK</code>, закрывающую существующий блок транзакций, то все последующие команды в нём выполняются в неявном блоке транзакции. И напротив, если составное сообщение Query содержит команду <code class="command">BEGIN</code>, она начинает обычный блок транзакции, который будет закончен только явными командами <code class="command">COMMIT</code> или <code class="command">ROLLBACK</code>, в каком бы сообщении Query, текущем или последующих, они ни содержались. Если <code class="command">BEGIN</code> следует за операторами, которые выполнялись в неявном блоке транзакции, эти операторы не фиксируются немедленно; они задним числом включаются в новый обычный блок транзакции.</p><p>Операторы <code class="command">COMMIT</code> и <code class="command">ROLLBACK</code>, фигурирующие в неявном блоке транзакции, выполняются как обычно, закрывая неявный блок; однако при этом будет выдано предупреждение, так как <code class="command">COMMIT</code> или <code class="command">ROLLBACK</code> без предшествующего <code class="command">BEGIN</code> могут выполняться по ошибке. Если за этими операторами следуют другие, для них будет начат новый неявный блок транзакции.</p><p>Точки сохранения в неявных блоках транзакций не допускаются, так как они будут конфликтовать с правилом автоматического закрытия блока при любой ошибке.</p><p>Помните, что, вне зависимости от наличия любых команд управления транзакциями, выполнение сообщения Query останавливается при первой же ошибке. Таким образом, с данными командами: </p><pre class="programlisting">BEGIN;
SELECT 1/0;
ROLLBACK;</pre><p> в одном сообщении Query сеанс останется внутри прерванного обычного блока транзакции, так как команда <code class="command">ROLLBACK</code> не достигается после ошибки деления на ноль. Для приведения сеанса в порядок потребуется выполнить ещё один <code class="command">ROLLBACK</code>.</p><p>Также следует заметить, что первоначальный лексический и синтаксический анализ производится для всей строки запроса, прежде чем какая-либо её часть будет выполняться. Таким образом, простые ошибки (например, опечатка в ключевом слове) в последующих операторах могут привести к тому, что не будет выполнен и ни один из предшествующих операторов. Это обычно незаметно для пользователей, так как эти операторы откатились бы всё равно при выполнении в неявном блоке транзакции. Однако эта особенность может проявиться при попытке выполнить несколько транзакций в одном составном запросе. Например, если из-за опечатки предыдущий пример превратился в: </p><pre class="programlisting">BEGIN;
INSERT INTO mytable VALUES(1);
COMMIT;
INSERT INTO mytable VALUES(2);
SELCT 1/0;</pre><p> ни один из операторов не будет выполняться, и отличие проявится в том, что первый <code class="command">INSERT</code> не будет зафиксирован. Ошибки, выявленные на стадии семантического анализа или позже, например, опечатки в имени таблиц или столбца, такого влияния на выполнение не оказывают.</p></div></div><div class="sect2" id="PROTOCOL-FLOW-EXT-QUERY"><div class="titlepage"><div><div><h3 class="title">55.2.3. Расширенное выполнение запросов <a href="#PROTOCOL-FLOW-EXT-QUERY" class="id_link">#</a></h3></div></div></div><p>Расширенный протокол запросов разбивает вышеописанный простой протокол на несколько шагов. Результаты подготовительных шагов можно многократно использовать повторно для улучшения эффективности. Кроме того, он открывает дополнительные возможности, в частности, возможность передавать значения данных в отдельных параметрах вместо того, чтобы внедрять их непосредственно в строку запроса.</p><p>В расширенном протоколе клиент сначала передаёт сообщение Parse с текстовой строкой запроса и, возможно, некоторыми сведениями о типах параметров и именем целевого объекта подготовленного оператора (если имя пустое, создаётся безымянный подготовленный оператор). Ответом на это сообщение будет ParseComplete или ErrorResponse. Типы параметров указываются по OID; при отсутствии явного указания анализатор запроса пытается определить типы данных так же, как он делал бы для нетипизированных строковых констант.</p><div class="note"><h3 class="title">Примечание</h3><p>Тип данных параметра можно оставить неопределённым, задав для него значение ноль, либо сделав массив с OID типов параметров короче, чем набор символов параметров (<code class="literal">$</code><em class="replaceable"><code>n</code></em>), используемых в строке запроса. Другой особый случай — передача типа параметра как <code class="type">void</code> (то есть передача OID псевдотипа <code class="type">void</code>). Это предусмотрено для того, чтобы символы параметров можно было использовать для параметров функций, на самом деле представляющих собой параметры OUT. Обычно параметр <code class="type">void</code> нельзя использовать ни в каком контексте, но если такой параметр фигурирует в списке параметров функции, он фактически игнорируется. Например, вызову функции <code class="literal">foo($1,$2,$3,$4)</code> может соответствовать функция с аргументами IN и двумя OUT, если аргументы <code class="literal">$3</code> и <code class="literal">$4</code> объявлены как имеющие тип <code class="type">void</code>.</p></div><div class="note"><h3 class="title">Примечание</h3><p>Строка запроса, содержащаяся в сообщении Parse, не может содержать больше одного оператора SQL; иначе выдаётся синтаксическая ошибка. Это ограничение отсутствует в простом протоколе запросов, но присутствует в расширенном протоколе, так как добавление поддержки подготовленных операторов или порталов, содержащих несколько команд, неоправданно усложнило бы протокол.</p></div><p>В случае успешного создания именованный подготовленный оператор продолжает существовать до завершения текущего сеанса, если только он не будет уничтожен явно. Безымянный подготовленный оператор сохраняется только до следующей команды Parse, в которой целевым является безымянный оператор. (Заметьте, что простое сообщение Query также уничтожает безымянный оператор.) Именованные операторы должны явно закрываться, прежде чем их можно будет переопределить другим сообщением Parse, но для безымянных операторов это не требуется. Именованные подготовленные операторы также можно создавать и вызывать на уровне команд SQL, используя команды <code class="command">PREPARE</code> и <code class="command">EXECUTE</code>.</p><p>Когда подготовленный оператор существует, его можно подготовить к выполнению сообщением Bind. В сообщении Bind задаётся имя исходного подготовленного оператора (пустая строка подразумевает безымянный подготовленный оператор), имя целевого портала (пустая строка подразумевает безымянный портал) и значения для любых шаблонов параметров, представленных в подготовленном операторе. Набор передаваемых значений должен соответствовать набору параметров, требующихся для подготовленного оператора. (Если вы объявили параметры <code class="type">void</code> в сообщении Parse, передайте для них значения NULL в сообщении Bind.) Bind также принимает указание формата для данных, возвращаемых в результате запроса; формат можно указать для всех данных, либо для отдельных столбцов. Ответом на это сообщение будет BindComplete или ErrorResponse.</p><div class="note"><h3 class="title">Примечание</h3><p>Выбор между текстовым и двоичным форматом вывода определяется кодами формата, передаваемыми в Bind, вне зависимости от команды SQL. При использовании расширенного протокола запросов атрибут <code class="literal">BINARY</code> в объявлении курсоров не имеет значения.</p></div><p>Планирование запроса обычно имеет место при обработке сообщения Bind. Если подготовленный оператор не имеет параметров, либо он выполняется многократно, сервер может сохранить созданный план и использовать его повторно при последующих сообщениях Bind для того же подготовленного оператора. Однако он будет делать это, только если решит, что можно получить универсальный план, который не будет значительно неэффективнее планов, зависящих от конкретных значений параметров. С точки зрения протокола это происходит незаметно.</p><p>В случае успешного создания объект именованного портала продолжает существование до конца текущей транзакции, если только он не будет уничтожен явно. Безымянный портал уничтожается в конце транзакции или при выполнении следующей команды Bind, в которой в качестве целевого выбирается безымянный портал. (Заметьте, что простое сообщение Query также уничтожает безымянный портал.) Именованные порталы должны явно закрываться, прежде чем их можно будет явно переопределить другим сообщением Bind, но это не требуется для безымянных порталов. Именованные порталы также можно создавать и вызывать на уровне команд SQL, используя команды <code class="command">DECLARE CURSOR</code> и <code class="command">FETCH</code>.</p><p>Когда портал существует, его можно запустить на выполнение сообщением Execute. В сообщении Execute указывается имя портала (пустая строка подразумевает безымянный портал) и максимальное число результирующих строк (ноль означает <span class="quote">«<span class="quote">выбрать все строки</span>»</span>). Число результирующих строк имеет значение только для порталов, которые содержат команды, возвращающие наборы строк; в других случаях команда всегда выполняется до завершения и число строк игнорируется. В ответ на Execute могут быть получены те же сообщения, что описаны выше для запросов, выполняемых через простой протокол, за исключением того, что после Execute не выдаются сообщения ReadyForQuery и RowDescription.</p><p>Если операция Execute оканчивается до завершения выполнения портала (из-за достижения ненулевого ограничения на число строк), сервер отправляет сообщение PortalSuspended; появление этого сообщения говорит клиенту о том, что для завершения операции с данным порталом нужно выдать ещё одно сообщение Execute. Сообщение CommandComplete, говорящее о завершении исходной команды SQL, не передаётся до завершения выполнения портала. Таким образом, фаза Execute всегда заканчивается при появлении одного из сообщений: CommandComplete, EmptyQueryResponse (если портал был создан из пустой строки запроса), ErrorResponse или PortalSuspended.</p><p>В конце каждой серии сообщений расширенного протокола запросов клиент должен выдать сообщение Sync. Получив это сообщение без параметров, сервер закрывает текущую транзакцию, если команды выполняются не внутри блока транзакции <code class="command">BEGIN</code>/<code class="command">COMMIT</code> (под <span class="quote">«<span class="quote">закрытием</span>»</span> понимается фиксация при отсутствии ошибок или откат в противном случае). Затем он выдаёт ответ ReadyForQuery. Целью сообщения Sync является обозначение точки синхронизации для восстановления в случае ошибок. Если при обработке сообщений расширенного протокола запросов происходит ошибка, сервер выдаёт ErrorResponse, затем считывает и пропускает сообщения до Sync, после чего выдаёт ReadyForQuery и возвращается к обычной обработке сообщений. (Но заметьте, что он не будет пропускать следующие сообщения, если ошибка происходит <span class="emphasis"><em>в процессе</em></span> обработки Sync — это гарантирует, что для каждого Sync будет передаваться в точности одно сообщение ReadyForQuery.)</p><div class="note"><h3 class="title">Примечание</h3><p>Сообщение Sync не приводит к закрытию блока транзакции, открытого командой <code class="command">BEGIN</code>. Выявить эту ситуацию можно, используя информацию о состоянии транзакции, содержащуюся в сообщении ReadyForQuery.</p></div><p>В дополнение к этим фундаментальным и обязательным операциям, расширенный протокол запросов позволяет выполнить и несколько дополнительных операций.</p><p>В сообщении Describe (в вариации для портала) задаётся имя существующего портала (пустая строка обозначает безымянный портал). В ответ передаётся сообщение RowDescription, описывающее строки, которые будут возвращены при выполнении портала; либо сообщение NoData, если портал не содержит запроса, возвращающего строки; либо ErrorResponse, если такого портала нет.</p><p>В сообщении Describe (в вариации для оператора) задаётся имя существующего подготовленного оператора (пустая строка обозначает безымянный подготовленный оператор). В ответ передаётся сообщение ParameterDescription, описывающее параметры, требующиеся для оператора, за которым следует сообщение RowDescription, описывающее строки, которые будут возвращены, когда оператор будет собственно выполнен (или сообщение NoData, если оператор не возвратит строки). ErrorResponse выдаётся, если такой подготовленный оператор отсутствует. Заметьте, что так как команда Bind не выполнялась, сервер ещё не знает, в каком формате будут возвращаться столбцы; в этом случае поля кодов формата в сообщении RowDescription будут содержать нули.</p><div class="tip"><h3 class="title">Подсказка</h3><p>В большинстве случаев клиент должен выдать ту или иную вариацию Describe, прежде чем выдавать Execute, чтобы понять, как интерпретировать результаты, которые он получит.</p></div><p>Сообщение Close закрывает существующий подготовленный оператор или портал и освобождает связанные ресурсы. При попытке выполнить Close для имени несуществующего портала или оператора ошибки не будет. Ответ на это сообщение обычно CloseComplete, но может быть и ErrorResponse, если при освобождении ресурсов возникают проблемы. Заметьте, что при закрытии подготовленного оператора неявно закрываются все открытые порталы, которые были получены из этого оператора.</p><p>Сообщение Flush не приводит к генерации каких-либо данных, а указывает серверу передать все данные, находящиеся в очереди в его буферах вывода. Сообщение Flush клиент должен отправлять после любой команды расширенного протокола запросов, кроме Sync, если он желает проанализировать результаты этой команды, прежде чем выдавать следующие команды. Без Flush сообщения, возвращаемые сервером, будут объединяться вместе в минимальное количество пакетов с целью уменьшения сетевого трафика.</p><div class="note"><h3 class="title">Примечание</h3><p>Простое сообщение Query примерно равнозначно последовательности сообщений Parse, Bind, Describe (для портала), Execute, Close, Sync, с использованием объектов подготовленного оператора и портала без имён и без параметров. Одно из отличий состоит в том, что такое сообщение может содержать в строке запроса несколько операторов SQL, для каждого из которых по очереди автоматически выполняется последовательность Bind/Describe/Execute. Другое отличие заключается в том, что в ответ на него не приходят сообщения ParseComplete, BindComplete, CloseComplete или NoData.</p></div></div><div class="sect2" id="PROTOCOL-FLOW-PIPELINING"><div class="titlepage"><div><div><h3 class="title">55.2.4. Конвейеризация <a href="#PROTOCOL-FLOW-PIPELINING" class="id_link">#</a></h3></div></div></div><a id="id-1.10.6.7.6.2" class="indexterm"></a><p>Расширенный протокол запросов позволяет использовать <em class="firstterm">конвейеризацию</em>, то есть отправлять серию запросов, не ожидая завершения каждого предыдущего. При этом уменьшается количество сетевых операций, необходимых для выполнения данной последовательности запросов. Однако пользователь должен тщательно продумывать поведение в случае сбоя одного из шагов, поскольку последующие запросы уже будут отправлены на сервер.</p><p>Например, можно объединить всю последовательность запросов в одну транзакцию, заключив её в <code class="command">BEGIN</code> ... <code class="command">COMMIT</code>. Однако если какие-то команды должны выполняться независимо от остальных, этот способ не подходит.</p><p>Расширенный протокол запросов позволяет реализовать поведение в случае ошибки по-другому, исключив передачу сообщений Sync между зависимыми шагами. Поскольку после ошибки сервер пропускает командные сообщения до тех пор, пока не получит Sync, более поздние команды в конвейере автоматически пропускаются при сбое более ранней, при этом клиенту не нужно явно управлять этим с помощью <code class="command">BEGIN</code> и <code class="command">COMMIT</code>. Сегменты конвейера, фиксируемые независимо, можно разделять сообщениями Sync.</p><p>Если клиент не передаёт команду <code class="command">BEGIN</code> явно, то каждое сообщение Sync обычно вызывает неявное выполнение <code class="command">COMMIT</code> в случае успешного завершения предыдущих шагов или <code class="command">ROLLBACK</code> в случае сбоя. Однако есть несколько команд DDL (например, <code class="command">CREATE DATABASE</code>), которые нельзя выполнить внутри блока транзакции. Если такая команда выполняется в конвейере, она успешно выполнится, только если будет первой. Кроме того, в случае успешного выполнения она вызовет немедленную фиксацию для сохранения согласованности базы данных. Таким образом, если сразу за ней отправить Sync, никаких дополнительных действий это сообщение не вызовет, кроме ответа ReadyForQuery.</p><p>Применяя этот метод, факт завершения конвейера нужно определять, подсчитывая сообщения ReadyForQuery и ожидая достижения количества отправленных сообщений Sync. Вариант с подсчётом сообщений о завершении команд ненадёжен, так как некоторые команды могут пропускаться, так что такие сообщения выдаваться не будут.</p></div><div class="sect2" id="PROTOCOL-FLOW-FUNCTION-CALL"><div class="titlepage"><div><div><h3 class="title">55.2.5. Вызов функций <a href="#PROTOCOL-FLOW-FUNCTION-CALL" class="id_link">#</a></h3></div></div></div><p>Раздел протокола «Вызов функций» позволяет клиенту запросить непосредственный вызов любой функции, существующей в системном каталоге <code class="structname">pg_proc</code>. При этом клиент должен иметь право на выполнение этой функции.</p><div class="note"><h3 class="title">Примечание</h3><p>Этот раздел протокола считается устаревшим и в новом коде использовать его не следует. Примерно тот же результат можно получить, подготовив оператор с командой <code class="literal">SELECT function($1, ...)</code>. При таком подходе цикл вызова функции заменяется последовательностью Bind/Execute.</p></div><p>Цикл вызова функции начинает клиент, передавая серверу сообщение FunctionCall. Сервер возвращает одно или несколько сообщений ответа, в зависимости от результата вызова функции, и завершающее сообщение ReadyForQuery. ReadyForQuery говорит клиенту, что он может свободно передавать новый запрос или вызов функции.</p><p>Сервер может передавать в этой фазе следующие ответные сообщения: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">ErrorResponse (Ошибочный ответ)</span></dt><dd><p>Произошла ошибка.</p></dd><dt><span class="term">FunctionCallResponse (Ответ на вызов функции)</span></dt><dd><p>Вызов функции завершён и в этом сообщении передаётся её результат. (Заметьте, что протокол вызова функций позволяет выдать только один скалярный результат, но не кортеж или набор результатов.)</p></dd><dt><span class="term">ReadyForQuery (Готов к запросам)</span></dt><dd><p>Обработка вызова функции завершена. В ответ всегда передаётся ReadyForQuery, независимо от того, была ли функция выполнена успешно или с ошибкой.</p></dd><dt><span class="term">NoticeResponse (Ответ с замечанием)</span></dt><dd><p>Выдаётся предупреждение, связанное с вызовом функции. Эти замечания дополняют другие ответы, то есть сервер, выдавая их, продолжает обрабатывать вызов.</p></dd></dl></div></div><div class="sect2" id="PROTOCOL-COPY"><div class="titlepage"><div><div><h3 class="title">55.2.6. Операции COPY <a href="#PROTOCOL-COPY" class="id_link">#</a></h3></div></div></div><p>Команда <code class="command">COPY</code> позволяет обеспечить скоростную передачу данных на сервер или с сервера. Операции входящего и исходящего копирования переключают соединение на использование отдельного раздела протокола, которое завершается только в конце операции.</p><p>Режим входящего копирования (передача данных на сервер) включается, когда клиент выполняет SQL-оператор <code class="command">COPY FROM STDIN</code>. Переходя в этот режим, сервер передаёт клиенту сообщение CopyInResponse. После этого клиент должен передать ноль или более сообщений CopyData, образующих поток входных данных. (При этом границы сообщений не обязательно должны совпадать с границами строк данных, хотя часто имеет смысл выровнять их.) Клиент может завершить режим входящего копирования, передав либо сообщение CopyDone (говорящее об успешном завершении), либо CopyFail (которое приведёт к завершению SQL-оператора <code class="command">COPY</code> с ошибкой). При этом сервер вернётся в обычный режим обработки, в котором он находился до выполнения команды <code class="command">COPY</code> (это может быть простой или расширенный протокол запросов). Затем он отправит сообщение CommandComplete (в случае успешного завершения) или ErrorResponse (в противном случае).</p><p>В случае возникновения ошибки в режиме входящего копирования (включая получение сообщения CopyFail), сервер выдаёт сообщение ErrorResponse. Если команда <code class="command">COPY</code> была получена в сообщении расширенного запроса, сервер не будет обрабатывать последующие сообщения клиента, пока не получит сообщение Sync, после которого он выдаст ReadyForQuery и вернётся в обычный режим работы. Если команда <code class="command">COPY</code> была получена в сообщении простого запроса, остальная часть сообщения игнорируется и сразу выдаётся ReadyForQuery. В любом случае все последующие сообщения CopyData, CopyDone или CopyFail, поступающие от клиента, будут просто игнорироваться.</p><p>В режиме входящего копирования сервер игнорирует поступающие сообщения Flush и Sync. При поступлении сообщений любого другого типа, не связанного с копированием, возникает ошибка, приводящая к прерыванию режима входящего копирования, как описано выше. (Исключение для сообщений Flush и Sync сделано для удобства клиентских библиотек, которые всегда передают Flush или Sync после сообщения Execute, не проверяя, не запускается ли в нём команда <code class="command">COPY FROM STDIN</code>.)</p><p>Режим исходящего копирования (передача данных с сервера) включается, когда клиент выполняет SQL-оператор <code class="command">COPY TO STDOUT</code>. Переходя в этот режим, сервер передаёт клиенту сообщение CopyOutResponse, за ним ноль или более сообщений CopyData (всегда одно сообщение для каждой строки) и в завершение CopyDone. Затем сервер возвращается в обычный режим обработки, в котором он находился до выполнения команды <code class="command">COPY</code>, и передаёт CommandComplete. Клиент не может прервать передачу (кроме как закрыв соединение или выдав запрос Cancel), но он может игнорировать ненужные ему сообщения CopyData и CopyDone.</p><p>В случае обнаружения ошибки в режиме исходящего копирования, сервер выдаёт сообщение ErrorResponse и возвращается к обычной обработке. Клиент должен воспринимать поступление ErrorResponse как завершение режима исходящего копирования.</p><p>Между сообщениями CopyData могут поступать сообщения NoticeResponse и ParameterStatus; клиенты должны обрабатывать их и быть готовы принимать и другие типы асинхронных сообщений (см. <a class="xref" href="protocol-flow.html#PROTOCOL-ASYNC" title="55.2.7. Асинхронные операции">Подраздел 55.2.7</a>). В остальном, сообщения любых типов, кроме CopyData и CopyDone, могут восприниматься как завершающие режим исходящего копирования.</p><p>Есть ещё один режим копирования, называемый двусторонним копированием и обеспечивающий высокоскоростную передачу данных на <span class="emphasis"><em>и</em></span> с сервера. Двустороннее копирование запускается, когда клиент в режиме walsender выполняет оператор <code class="command">START_REPLICATION</code>. В ответ сервер передаёт клиенту сообщение CopyBothResponse. Затем и сервер, и клиент могут передавать друг другу сообщения CopyData, пока кто-то из них не завершит передачу сообщением CopyDone. Когда сообщение CopyDone передаёт клиент, соединение переходит из режима двустороннего в режим исходящего копирования и клиент больше не может передавать сообщения CopyData. Аналогично, когда сообщение CopyDone передаёт сервер, соединение переходит в режим входящего копирования и сервер больше не может передавать сообщения CopyData. Когда сообщения CopyDone переданы обеими сторонами, режим копирования завершается и сервер возвращается в режим обработки команд. В случае обнаружения ошибки на стороне сервера в режиме двустороннего копирования, сервер выдаёт сообщение ErrorResponse, пропускает следующие сообщения клиента, пока не будет получено сообщение Sync, а затем выдаёт ReadyForQuery и возвращается к обычной обработке. Клиент должен воспринимать получение ErrorResponse как завершение двустороннего копирования; в этом случае сообщение CopyDone посылаться не должно. За дополнительной информацией о разделе протокола, управляющем двусторонним копированием, обратитесь к <a class="xref" href="protocol-replication.html" title="55.4. Протокол потоковой репликации">Разделу 55.4</a>.</p><p>Сообщения CopyInResponse, CopyOutResponse и CopyBothResponse содержат поля, из которых клиент может узнать количество столбцов в строке и код формата для каждого столбца. (В текущей реализации для всех столбцов в заданной операции <code class="command">COPY</code> устанавливается один формат, но в конструкции сообщения это не заложено.)</p></div><div class="sect2" id="PROTOCOL-ASYNC"><div class="titlepage"><div><div><h3 class="title">55.2.7. Асинхронные операции <a href="#PROTOCOL-ASYNC" class="id_link">#</a></h3></div></div></div><p>Возможны ситуации, в которых сервер будет отправлять клиенту сообщения, не предполагаемые потоком команд в текущем режиме. Клиенты должны быть готовы принять эти сообщения в любой момент, даже не в процессе выполнения запроса. Как минимум, следует проверять такие сообщения, прежде чем начинать читать ответ на запрос.</p><p>Сообщения NoticeResponse могут выдаваться вследствие внешней активности; например, если администратор инициирует <span class="quote">«<span class="quote">быстрое</span>»</span> отключение баз данных, сервер отправит NoticeResponse, сигнализирующее об этом факте, прежде чем закрывать соединение. Соответственно, клиенты должны быть готовы всегда принять и вывести сообщения NoticeResponse, даже когда соединение фактически простаивает.</p><p>Сообщения ParameterStatus будут выдаваться всякий раз, когда меняется действующее значение одного из параметров, об изменении которых, по мнению сервера, должен знать клиент. Чаще всего это происходит в ответ на SQL-команду <code class="command">SET</code>, выполняемую клиентом и в таком случае это сообщение по сути синхронно — но состояние параметров может меняться и когда администратор изменяет файл конфигурации, а затем посылает серверу сигнал <span class="systemitem">SIGHUP</span>. Также, если действие команды <code class="command">SET</code> отменяется, клиенту передаётся сообщение ParameterStatus, в котором отражается текущее значение параметра.</p><p>В настоящее время есть жёстко зафиксированный набор параметров, при изменении которых выдаётся ParameterStatus: </p><table border="0" summary="Simple list" class="simplelist"><tr><td><code class="varname">application_name</code></td><td><code class="varname">is_superuser</code></td></tr><tr><td><code class="varname">client_encoding</code></td><td><code class="varname">scram_iterations</code></td></tr><tr><td><code class="varname">DateStyle</code></td><td><code class="varname">server_encoding</code></td></tr><tr><td><code class="varname">default_transaction_read_only</code></td><td><code class="varname">server_version</code></td></tr><tr><td><code class="varname">in_hot_standby</code></td><td><code class="varname">session_authorization</code></td></tr><tr><td><code class="varname">integer_datetimes</code></td><td><code class="varname">standard_conforming_strings</code></td></tr><tr><td><code class="varname">IntervalStyle</code></td><td><code class="varname">TimeZone</code></td></tr></table><p> (<code class="varname">server_encoding</code>, <code class="varname">TimeZone</code> и <code class="varname">integer_datetimes</code> не отслеживались до версии 8.0; <code class="varname">standard_conforming_strings</code> не отслеживался до 8.1; <code class="varname">IntervalStyle</code> — до версии 8.4; <code class="varname">application_name</code> — до версии 9.0; <code class="varname">default_transaction_read_only</code> и <code class="varname">in_hot_standby</code> — до версии 14; <code class="varname">scram_iterations</code> — до версии 16.) Заметьте, что <code class="varname">server_version</code>, <code class="varname">server_encoding</code> и <code class="varname">integer_datetimes</code> — это псевдопараметры, которые не могут меняться после запуска сервера. Этот набор может быть изменён в будущем или даже будет настраиваемым. Соответственно, клиент может просто игнорировать сообщения ParameterStatus для параметров, которые ему неизвестны или не представляют интереса.</p><p>Если клиент выполняет команду <code class="command">LISTEN</code>, сервер будет передавать ему сообщения NotificationResponse (не путайте с NoticeResponse!), когда для канала с тем же именем затем будет выполняться команда <code class="command">NOTIFY</code>.</p><div class="note"><h3 class="title">Примечание</h3><p>В настоящее время, сообщение NotificationResponse может быть передано только вне транзакции, так что оно не может оказаться в середине серии ответов на команду, хотя может поступить сразу после ReadyForQuery. Однако полагаться на это при проектировании логики клиента неразумно. Лучше разработать код так, чтобы NotificationResponse могло быть принято в любой фазе протокола.</p></div></div><div class="sect2" id="PROTOCOL-FLOW-CANCELING-REQUESTS"><div class="titlepage"><div><div><h3 class="title">55.2.8. Отмена выполняющихся запросов <a href="#PROTOCOL-FLOW-CANCELING-REQUESTS" class="id_link">#</a></h3></div></div></div><p>В процессе обработки запроса клиент может запросить отмену этого запроса. Запрос отмены не передаётся серверу непосредственно через открытое соединение из соображений эффективности: мы не хотим, чтобы сервер постоянно проверял поступающие от клиента сообщения в процессе выполнения запроса. Запросы отмены должны быть относительно редкими, поэтому мы выбрали для них не самый простой путь во избежание негативного влияния на обычный режим работы.</p><p>Чтобы запросить отмену запроса, клиент должен установить новое подключение к серверу и отправить ему сообщение CancelRequest, вместо StartupMessage, обычно передаваемого при установлении нового подключения. Сервер обработает полученную команду и закроет это подключение. По соображениям безопасности сервер не отвечает непосредственно на сообщение с запросом отмены.</p><p>Сообщение CancelRequest обрабатывается, только если оно содержит те же ключевые данные (PID и секретный ключ), что были переданы клиенту при запуске. Если PID и секретный ключ в запросе соответствуют данным выполняющегося в данный момент обслуживающего процесса, обработка текущего запроса в нём прерывается. (В существующей реализации это осуществляется путём передачи специального сигнала данному обслуживающему процессу.)</p><p>Сигнал отмены может подействовать, а может и не подействовать (например, если он поступит после того, как сервер завершит обработку запроса). Если отмена действительно происходит, текущая команда прерывается досрочно с сообщением об ошибке.</p><p>Вследствие такой организации, объясняемой соображениями безопасности и эффективности, клиент не может непосредственно определить, был ли запрос отмены успешен. Он должен продолжать ожидать ответа сервера на исходный запрос. Запрос отмены просто увеличивает вероятность того, что текущий запрос завершится быстрее, как и вероятность того, что он будет завершён не успешно, а с ошибкой.</p><p>Так как запрос отмены передаётся серверу через новое подключение к серверу, а не через обычный канал связи клиент-сервер, такие запросы могут выдавать любые процессы, а не только клиентский процесс, запрос которого требуется отменить. Это может дать дополнительную гибкость при построении многопроцессных приложений. Это также представляет собой угрозу безопасности, так как попытаться отменить запросы могут и неавторизованные пользователи. Для ликвидации этой угрозы в запросах отмены требуется передавать динамически генерируемый секретный ключ.</p></div><div class="sect2" id="PROTOCOL-FLOW-TERMINATION"><div class="titlepage"><div><div><h3 class="title">55.2.9. Завершение <a href="#PROTOCOL-FLOW-TERMINATION" class="id_link">#</a></h3></div></div></div><p>Обычная процедура мягкого завершения заключается в том, что клиент отправляет сообщение Terminate и немедленно закрывает соединение. Получая это сообщение, обслуживающий процесс закрывает соединение и завершается.</p><p>В редких случаях (например, при отключении базы данных по команде администратора) обслуживающий процесс может отключиться, даже если клиент не запрашивает этого. В таких случаях, перед тем, как закрыть соединение, этот процесс пытается передать сообщение с ошибкой или уведомлением, в котором будет указана причина отключения.</p><p>Другие сценарии завершения возникают с различными вариантами отказа, например, при критическом сбое с дампом памяти на одной или другой стороне, при потере канала соединения, потере синхронизации по границам сообщений и т. д. Если клиент или сервер обнаруживает, что соединение было неожиданно закрыто, он должен очистить ресурсы и завершиться. Клиент при этом может запустить новый обслуживающий процесс, переподключившись к серверу, если он сам хочет продолжать работу. Закрывать соединение также рекомендуется при получении сообщений нераспознанного типа, так как это может быть признаком потери синхронизации по границам сообщений.</p><p>При штатном или нештатном завершении сеанса любая открытая транзакция откатывается, а не фиксируется. Однако следует заметить, что при отключении клиента в процессе обработки запроса, отличного от <code class="command">SELECT</code>, обслуживающий процесс вероятнее всего завершит запрос, прежде чем заметит отключение. Если запрос выполняется не в блоке транзакции (вне последовательности <code class="command">BEGIN</code> ... <code class="command">COMMIT</code>), его результаты могут быть зафиксированы до того, как будет обнаружено отключение.</p></div><div class="sect2" id="PROTOCOL-FLOW-SSL"><div class="titlepage"><div><div><h3 class="title">55.2.10. Защита сеанса с <acronym class="acronym">SSL</acronym> <a href="#PROTOCOL-FLOW-SSL" class="id_link">#</a></h3></div></div></div><p>Если <span class="productname">PostgreSQL</span> был собран с поддержкой <acronym class="acronym">SSL</acronym>, взаимодействие клиента с сервером может быть зашифровано с применением <acronym class="acronym">SSL</acronym>. Это обеспечивает защиту на уровне канала в среде, где злоумышленники могут перехватить трафик сеанса. За дополнительными сведениями о шифровании трафика сеансов <span class="productname">PostgreSQL</span> с использованием <acronym class="acronym">SSL</acronym> обратитесь к <a class="xref" href="ssl-tcp.html" title="19.9. Защита соединений TCP/IP с применением SSL">Разделу 19.9</a>.</p><p>Чтобы начать сеанс с <acronym class="acronym">SSL</acronym>-шифрованием, клиент передаёт серверу вместо StartupMessage сообщение SSLRequest. В ответ сервер передаёт один байт, содержащий символ <code class="literal">S</code> или <code class="literal">N</code>, показывающий, что он желает, либо не желает включать <acronym class="acronym">SSL</acronym>, соответственно. Если клиент не удовлетворён ответом, он может закрыть соединение на этом этапе. Чтобы продолжить установление соединения после получения <code class="literal">S</code>, он выполняет начальное согласование <acronym class="acronym">SSL</acronym> с сервером (не описывается здесь, так как относится к протоколу <acronym class="acronym">SSL</acronym>). Если эта процедура выполняется успешно, он продолжает соединение, передавая обычное сообщение StartupMessage. При этом StartupMessage и все последующие данные будут защищены <acronym class="acronym">SSL</acronym>-шифрованием. Чтобы продолжить после получения <code class="literal">N</code>, клиент может передать обычное сообщение StartupMessage и дальше взаимодействовать с сервером без шифрования. (Клиент также может выдать сообщение GSSENCRequest после получения <code class="literal">N</code> и попытаться использовать шифрование <acronym class="acronym">GSSAPI</acronym> вместо <acronym class="acronym">SSL</acronym>.)</p><p>Клиент также должен быть готов обработать сообщение ErrorMessage, полученное от сервера в ответ на SSLRequest. Такая ситуация возможна, только если сервер имеет версию, которая ещё не поддерживала <acronym class="acronym">SSL</acronym> в <span class="productname">PostgreSQL</span>. (Такие серверы сейчас антикварная редкость, и скорее всего их уже не встретить в природе.) В этом случае соединение должно быть закрыто, но клиент может решить открыть новое соединение, не запрашивая <acronym class="acronym">SSL</acronym>-шифрование.</p><p>Когда <acronym class="acronym">SSL</acronym>-шифрование может быть включено, ожидается, что сервер передаст только один байт, содержащий символ <code class="literal">S</code>, а затем будет ожидать от клиента начала согласования <acronym class="acronym">SSL</acronym>. Если на этом этапе доступны для чтения дополнительные байты, это может означать, что злоумышленник пытается выполнить атаку с переполнением буфера (<a class="ulink" href="https://www.postgresql.org/support/security/CVE-2021-23222/" target="_top">CVE-2021-23222</a>). Код на стороне клиента должен либо прочитать ровно один байт, а затем передать сокет библиотеке SSL, либо, если были прочитаны дополнительные байты, считать это нарушением протокола.</p><p>Начальный запрос SSLRequest может также передаваться при установлении соединения, открываемого для передачи сообщения CancelRequest.</p><p>Так как в самом протоколе не предусмотрено принудительное включение <acronym class="acronym">SSL</acronym>-шифрования сервером, администратор может настроить сервер так, чтобы в качестве дополнительного условия при проверке подлинности клиента он не принимал незашифрованные сеансы.</p></div><div class="sect2" id="PROTOCOL-FLOW-GSSAPI"><div class="titlepage"><div><div><h3 class="title">55.2.11. Защита сеанса с <acronym class="acronym">GSSAPI</acronym> <a href="#PROTOCOL-FLOW-GSSAPI" class="id_link">#</a></h3></div></div></div><p>Если <span class="productname">PostgreSQL</span> был собран с поддержкой <acronym class="acronym">GSSAPI</acronym>, взаимодействие клиента с сервером может быть зашифровано с применением <acronym class="acronym">GSSAPI</acronym>. Это обеспечивает защиту на уровне канала в среде, где злоумышленники могут перехватить трафик сеанса. За дополнительными сведениями о шифровании трафика сеансов <span class="productname">PostgreSQL</span> с использованием <acronym class="acronym">GSSAPI</acronym> обратитесь к <a class="xref" href="gssapi-enc.html" title="19.10. Защита соединений TCP/IP с применением GSSAPI">Разделу 19.10</a>.</p><p>Чтобы установить соединение, зашифрованное <acronym class="acronym">GSSAPI</acronym>, клиент вначале посылает сообщение GSSENCRequest, а не StartupMessage. Сервер в ответ передаёт один байт с буквой <code class="literal">G</code> или <code class="literal">N</code>, показывающей соответственно, желает ли он использовать шифрование <acronym class="acronym">GSSAPI</acronym> или нет. Клиент может закрыть соединение в этот момент, если ответ его не устраивает. Чтобы продолжить после варианта <code class="literal">G</code>, используя GSSAPI на уровне C в соответствии со стандартом <a class="ulink" href="https://datatracker.ietf.org/doc/html/rfc2744" target="_top">RFC 2744</a> или равнозначным, выполните инициализацию <acronym class="acronym">GSSAPI</acronym>, вызывая <code class="function">gss_init_sec_context()</code> в цикле и отправляя результат на сервер, сначала без входных данных, а затем для всех поступающих от сервера данных, пока они не закончатся. Передавая результаты <code class="function">gss_init_sec_context()</code> серверу, добавьте перед сообщением его длину в виде четырёхбайтового целого в сетевом порядке байтов. Чтобы продолжить после получения <code class="literal">N</code>, клиент может передать обычное сообщение StartupMessage и дальше не использовать шифрование. (Клиент также может выдать сообщение SSLRequest после получения <code class="literal">N</code> и попытаться использовать шифрование <acronym class="acronym">SSL</acronym> вместо <acronym class="acronym">GSSAPI</acronym>.)</p><p>Клиент также должен быть готов обработать сообщение ErrorMessage, полученное от сервера в ответ на GSSENCRequest. Такая ситуация возможна, только если сервер имеет версию, которая ещё не поддерживала шифрование <acronym class="acronym">GSSAPI</acronym> в <span class="productname">PostgreSQL</span>. В этом случае соединение должно быть закрыто, но клиент может решить открыть новое соединение, не запрашивая шифрование <acronym class="acronym">GSSAPI</acronym>.</p><p>Когда <acronym class="acronym">GSSAPI</acronym>-шифрование может быть включено, ожидается, что сервер передаст только один байт, содержащий символ <code class="literal">G</code>, а затем будет ожидать от клиента согласование <acronym class="acronym">GSSAPI</acronym>. Если на этом этапе доступны для чтения дополнительные байты, это может означать, что злоумышленник пытается выполнить атаку с переполнением буфера (<a class="ulink" href="https://www.postgresql.org/support/security/CVE-2021-23222/" target="_top">CVE-2021-23222</a>). Код на стороне клиента должен либо прочитать ровно один байт, а затем передать сокет библиотеке GSSAPI, либо, если были прочитаны дополнительные байты, считать это нарушением протокола.</p><p>Начальный запрос GSSENCRequest может также передаваться при установлении соединения, открываемого для передачи сообщения CancelRequest.</p><p>Когда шифрование <acronym class="acronym">GSSAPI</acronym> установлено, используйте <code class="function">gss_wrap()</code> для шифрования обычного сообщения StartupMessage и всех последующих данных. Перед собственно зашифрованным результатом добавьте его длину в виде четырёхбайтового целого в сетевом порядке байтов. Учтите, что сервер будет принимать от клиента зашифрованные пакеты, только если они меньше 16 КБ; чтобы определить, укладывается ли зашифрованное сообщение в это ограничение, клиенту следует использовать функцию <code class="function">gss_wrap_size_limit()</code>, а чтобы разбить большие сообщения на части — последовательно вызывать <code class="function">gss_wrap()</code>. Сегменты незашифрованных данных обычно имеют размер 8 КБ, поэтому зашифрованные пакеты оказываются немного больше 8 КБ, но вполне умещаются в 16 КБ. Можно ожидать, что сервер также не будет передавать клиенту зашифрованные пакеты размером больше 16 КБ.</p><p>Так как в самом протоколе не предусмотрено принудительное включение <acronym class="acronym">GSSAPI</acronym>-шифрования сервером, администратор может настроить сервер так, чтобы в качестве дополнительного условия при проверке подлинности клиента он не принимал незашифрованные сеансы.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="protocol-overview.html" title="55.1. Обзор">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="protocol.html" title="Глава 55. Клиент-серверный протокол">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="sasl-authentication.html" title="55.3. Аутентификация SASL">След.</a></td></tr><tr><td width="40%" align="left" valign="top">55.1. Обзор </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 55.3. Аутентификация SASL</td></tr></table></div></body></html>