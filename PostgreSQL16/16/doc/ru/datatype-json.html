<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>8.14. Типы JSON</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="datatype-xml.html" title="8.13. Тип XML" /><link rel="next" href="arrays.html" title="8.15. Массивы" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">8.14. Типы <acronym class="acronym">JSON</acronym></th></tr><tr><td width="10%" align="left"><a accesskey="p" href="datatype-xml.html" title="8.13. Тип XML">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="datatype.html" title="Глава 8. Типы данных">Наверх</a></td><th width="60%" align="center">Глава 8. Типы данных</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="arrays.html" title="8.15. Массивы">След.</a></td></tr></table><hr /></div><div class="sect1" id="DATATYPE-JSON"><div class="titlepage"><div><div><h2 class="title" style="clear: both">8.14. Типы <acronym class="acronym">JSON</acronym> <a href="#DATATYPE-JSON" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="datatype-json.html#JSON-KEYS-ELEMENTS">8.14.1. Синтаксис вводимых и выводимых значений JSON</a></span></dt><dt><span class="sect2"><a href="datatype-json.html#JSON-DOC-DESIGN">8.14.2. Проектирование документов JSON</a></span></dt><dt><span class="sect2"><a href="datatype-json.html#JSON-CONTAINMENT">8.14.3. Проверки на вхождение и существование <code class="type">jsonb</code></a></span></dt><dt><span class="sect2"><a href="datatype-json.html#JSON-INDEXING">8.14.4. Индексация <code class="type">jsonb</code></a></span></dt><dt><span class="sect2"><a href="datatype-json.html#JSONB-SUBSCRIPTING">8.14.5. Обращение по индексу к элементам <code class="type">jsonb</code></a></span></dt><dt><span class="sect2"><a href="datatype-json.html#DATATYPE-JSON-TRANSFORMS">8.14.6. Трансформации</a></span></dt><dt><span class="sect2"><a href="datatype-json.html#DATATYPE-JSONPATH">8.14.7. Тип jsonpath</a></span></dt></dl></div><a id="id-1.5.7.22.2" class="indexterm"></a><a id="id-1.5.7.22.3" class="indexterm"></a><p>Типы JSON предназначены для хранения данных JSON (JavaScript Object Notation, Запись объекта JavaScript) согласно стандарту <a class="ulink" href="https://datatracker.ietf.org/doc/html/rfc7159" target="_top">RFC 7159</a>. Такие данные можно хранить и в типе <code class="type">text</code>, но типы JSON лучше тем, что проверяют, соответствует ли вводимое значение формату JSON. Для работы с ними есть также несколько специальных функций и операторов; см. <a class="xref" href="functions-json.html" title="9.16. Функции и операторы JSON">Раздел 9.16</a>.</p><p>В <span class="productname">PostgreSQL</span> имеются два типа для хранения данных JSON: <code class="type">json</code> и <code class="type">jsonb</code>. Для реализации эффективного механизма запросов к этим типам данных в <span class="productname">PostgreSQL</span> также имеется тип <code class="type">jsonpath</code>, описанный в <a class="xref" href="datatype-json.html#DATATYPE-JSONPATH" title="8.14.7. Тип jsonpath">Подразделе 8.14.7</a>.</p><p>Типы данных <code class="type">json</code> и <code class="type">jsonb</code> принимают на вход <span class="emphasis"><em>почти</em></span> одинаковые наборы значений, а отличаются они главным образом с точки зрения эффективности. Тип <code class="type">json</code> сохраняет точную копию введённого текста, которую функции обработки должны разбирать заново при каждом выполнении запроса, тогда как данные <code class="type">jsonb</code> сохраняются в разобранном двоичном формате, что несколько замедляет ввод из-за преобразования, но значительно ускоряет обработку, не требуя многократного разбора текста. Кроме того, <code class="type">jsonb</code> поддерживает индексацию, что тоже может быть очень полезно.</p><p>Так как тип <code class="type">json</code> сохраняет точную копию введённого текста, он сохраняет семантически незначащие пробелы между элементами, а также порядок ключей в JSON-объектах. И если JSON-объект внутри содержит повторяющиеся ключи, этот тип сохранит все пары ключ/значение. (Функции обработки будут считать действительной последнюю пару.) Тип <code class="type">jsonb</code>, напротив, не сохраняет пробелы, порядок ключей и значения с дублирующимися ключами. Если во входных данных оказываются дублирующиеся ключи, сохраняется только последнее значение.</p><p>Для большинства приложений предпочтительнее хранить данные JSON в типе <code class="type">jsonb</code> (если нет особых противопоказаний, например важны прежние предположения о порядке ключей объектов).</p><p>В <acronym class="acronym">RFC</acronym> 7159 говорится, что строки JSON должны быть представлены в кодировке UTF-8. Поэтому данные JSON не будут полностью соответствовать спецификации, если кодировка базы данных не UTF-8. При этом нельзя будет вставить в JSON символы, непредставимые в кодировке сервера, и наоборот, допустимыми будут символы, представимые в кодировке сервера, но не в UTF-8.</p><p><acronym class="acronym">RFC</acronym> 7159 разрешает включать в строки JSON спецпоследовательности Unicode в виде <code class="literal">\u<em class="replaceable"><code>XXXX</code></em></code>. В функцию ввода для типа <code class="type">json</code> эти спецпоследовательности допускаются вне зависимости от кодировки базы данных, и проверяется только правильность их синтаксиса (за <code class="literal">\u</code> должны следовать четыре шестнадцатеричных цифры). Однако функция ввода для типа <code class="type">jsonb</code> более строгая: она не допускает спецпоследовательности Unicode для символов, которые не могут быть представлены в кодировке базы. Тип <code class="type">jsonb</code> также не принимает <code class="literal">\u0000</code> (так как это значение не может быть представлено в типе <code class="type">text</code> <span class="productname">PostgreSQL</span>) и требует, чтобы суррогатные пары Unicode использовались для представления символов вне основной многоязыковой плоскости (BMP) правильно. Корректные спецпоследовательности Unicode преобразуются для хранения в один соответствующий символ (это подразумевает сворачивание суррогатных пар в один символ).</p><div class="note"><h3 class="title">Примечание</h3><p>Многие из функций обработки JSON, описанные в <a class="xref" href="functions-json.html" title="9.16. Функции и операторы JSON">Разделе 9.16</a>, преобразуют спецпоследовательности Unicode в обычные символы, поэтому могут выдавать подобные ошибки, даже если им на вход поступает тип <code class="type">json</code>, а не <code class="type">jsonb</code>. То, что функция ввода в тип <code class="type">json</code> не производит этих проверок, можно считать историческим артефактом, хотя это и позволяет просто сохранять (но не обрабатывать) в JSON спецкоды Unicode в базе данных с кодировкой, в которой представленные таким образом символы отсутствуют.</p></div><p>При преобразовании вводимого текста JSON в тип <code class="type">jsonb</code>, примитивные типы, описанные в <acronym class="acronym">RFC</acronym> 7159, по сути отображаются в собственные типы <span class="productname">PostgreSQL</span> как показано в <a class="xref" href="datatype-json.html#JSON-TYPE-MAPPING-TABLE" title="Таблица 8.23. Примитивные типы JSON и соответствующие им типы PostgreSQL">Таблице 8.23</a>. Таким образом, к содержимому типа <code class="type">jsonb</code> предъявляются некоторые дополнительные требования, продиктованные ограничениями представления нижележащего типа данных, которые не распространяются ни на тип <code class="type">json</code>, ни на формат JSON вообще. В частности, тип <code class="type">jsonb</code> не принимает числа, выходящие за диапазон типа данных <span class="productname">PostgreSQL</span> <code class="type">numeric</code>, тогда как с <code class="type">json</code> такого ограничения нет. Такие ограничения, накладываемые реализацией, допускаются согласно <acronym class="acronym">RFC</acronym> 7159. Однако на практике такие проблемы более вероятны в других реализациях, так как обычно примитивный тип JSON <code class="type">number</code> представляется в виде числа с плавающей точкой двойной точности IEEE 754 (что <acronym class="acronym">RFC</acronym> 7159 явно признаёт и допускает). При использовании JSON в качестве формата обмена данными с такими системами следует учитывать риски потери точности чисел, хранившихся в <span class="productname">PostgreSQL</span>.</p><p>И напротив, как показано в таблице, есть некоторые ограничения в формате ввода примитивных типов JSON, не актуальные для соответствующих типов <span class="productname">PostgreSQL</span>.</p><div class="table" id="JSON-TYPE-MAPPING-TABLE"><p class="title"><strong>Таблица 8.23. Примитивные типы JSON и соответствующие им типы <span class="productname">PostgreSQL</span></strong></p><div class="table-contents"><table class="table" summary="Примитивные типы JSON и соответствующие им типы PostgreSQL" border="1"><colgroup><col class="col1" /><col class="col2" /><col class="col3" /></colgroup><thead><tr><th>Примитивный тип JSON</th><th>Тип <span class="productname">PostgreSQL</span></th><th>Замечания</th></tr></thead><tbody><tr><td><code class="type">string</code></td><td><code class="type">text</code></td><td><code class="literal">\u0000</code> не допускается как спецпоследовательность Unicode, представляющая символ, который отсутствует в кодировке базы</td></tr><tr><td><code class="type">number</code></td><td><code class="type">numeric</code></td><td>Значения <code class="literal">NaN</code> и <code class="literal">infinity</code> не допускаются</td></tr><tr><td><code class="type">boolean</code></td><td><code class="type">boolean</code></td><td>Допускаются только варианты <code class="literal">true</code> и <code class="literal">false</code> (в нижнем регистре)</td></tr><tr><td><code class="type">null</code></td><td>(нет)</td><td><code class="literal">NULL</code> в SQL имеет другой смысл</td></tr></tbody></table></div></div><br class="table-break" /><div class="sect2" id="JSON-KEYS-ELEMENTS"><div class="titlepage"><div><div><h3 class="title">8.14.1. Синтаксис вводимых и выводимых значений JSON <a href="#JSON-KEYS-ELEMENTS" class="id_link">#</a></h3></div></div></div><p>Синтаксис ввода/вывода типов данных JSON соответствует стандарту <acronym class="acronym">RFC</acronym> 7159.</p><p>Примеры допустимых выражений с типом <code class="type">json</code> (или <code class="type">jsonb</code>): </p><pre class="programlisting">-- Простое скалярное/примитивное значение
-- Простыми значениями могут быть числа, строки в кавычках, true, false или null
SELECT '5'::json;

-- Массив из нуля и более элементов (элементы могут быть разных типов)
SELECT '[1, 2, "foo", null]'::json;

-- Объект, содержащий пары ключей и значений
-- Заметьте, что ключи объектов — это всегда строки в кавычках
SELECT '{"bar": "baz", "balance": 7.77, "active": false}'::json;

-- Массивы и объекты могут вкладываться произвольным образом
SELECT '{"foo": [true, "bar"], "tags": {"a": 1, "b": null}}'::json;</pre><p>Как было сказано ранее, когда значение JSON вводится и затем выводится без дополнительной обработки, тип <code class="type">json</code> выводит тот же текст, что поступил на вход, а <code class="type">jsonb</code> не сохраняет семантически незначащие детали, такие как пробелы. Например, посмотрите на эти различия: </p><pre class="programlisting">SELECT '{"bar": "baz", "balance": 7.77, "active":false}'::json;
                      json
-------------------------------------------------
 {"bar": "baz", "balance": 7.77, "active":false}
(1 row)

SELECT '{"bar": "baz", "balance": 7.77, "active":false}'::jsonb;
                      jsonb
--------------------------------------------------
 {"bar": "baz", "active": false, "balance": 7.77}
(1 row)</pre><p> Первая семантически незначимая деталь, заслуживающая внимания: с <code class="type">jsonb</code> числа выводятся по правилам нижележащего типа <code class="type">numeric</code>. На практике это означает, что числа, заданные в записи с <code class="literal">E</code>, будут выведены без неё, например: </p><pre class="programlisting">SELECT '{"reading": 1.230e-5}'::json, '{"reading": 1.230e-5}'::jsonb;
         json          |          jsonb
-----------------------+-------------------------
 {"reading": 1.230e-5} | {"reading": 0.00001230}
(1 row)</pre><p> Однако как видно из этого примера, <code class="type">jsonb</code> сохраняет конечные нули дробного числа, хотя они и не имеют семантической значимости, в частности для проверки на равенство.</p><p>Список встроенных функций и операторов, позволяющих создавать и обрабатывать значения JSON, приведён в <a class="xref" href="functions-json.html" title="9.16. Функции и операторы JSON">Разделе 9.16</a>.</p></div><div class="sect2" id="JSON-DOC-DESIGN"><div class="titlepage"><div><div><h3 class="title">8.14.2. Проектирование документов JSON <a href="#JSON-DOC-DESIGN" class="id_link">#</a></h3></div></div></div><p>Представлять данные в JSON можно гораздо более гибко, чем в традиционной реляционной модели данных, что очень привлекательно там, где нет жёстких условий. И оба этих подхода вполне могут сосуществовать и дополнять друг друга в одном приложении. Однако даже для приложений, которым нужна максимальная гибкость, рекомендуется, чтобы документы JSON имели некоторую фиксированную структуру. Эта структура обычно не навязывается жёстко (хотя можно декларативно диктовать некоторые бизнес-правила), но когда она предсказуема, становится гораздо проще писать запросы, которые извлекают полезные данные из набора <span class="quote">«<span class="quote">документов</span>»</span> (информации) в таблице.</p><p>Данные JSON, как и данные любых других типов, хранящиеся в таблицах, находятся под контролем механизма параллельного доступа. Хотя хранить большие документы вполне возможно, не забывайте, что при любом изменении устанавливается блокировка всей строки (на уровне строки). Поэтому для оптимизации блокировок транзакций, изменяющих данные, стоит ограничить размер документов JSON разумными пределами. В идеале каждый документ JSON должен собой представлять атомарный информационный блок, который, согласно бизнес-логике, нельзя разделить на меньшие, индивидуально изменяемые блоки.</p></div><div class="sect2" id="JSON-CONTAINMENT"><div class="titlepage"><div><div><h3 class="title">8.14.3. Проверки на вхождение и существование <code class="type">jsonb</code> <a href="#JSON-CONTAINMENT" class="id_link">#</a></h3></div></div></div><a id="id-1.5.7.22.17.2" class="indexterm"></a><a id="id-1.5.7.22.17.3" class="indexterm"></a><p>Проверка <em class="firstterm">вхождения</em> — важная особенность типа <code class="type">jsonb</code>, не имеющая аналога для типа <code class="type">json</code>. Эта проверка определяет, входит ли один документ <code class="type">jsonb</code> в другой. В следующих примерах возвращается истинное значение (кроме упомянутых исключений):</p><pre class="programlisting">-- Простые скалярные/примитивные значения включают только одно идентичное значение:
SELECT '"foo"'::jsonb @&gt; '"foo"'::jsonb;

-- Массив с правой стороны входит в массив слева:
SELECT '[1, 2, 3]'::jsonb @&gt; '[1, 3]'::jsonb;

-- Порядок элементов в массиве не важен, поэтому это условие тоже выполняется:
SELECT '[1, 2, 3]'::jsonb @&gt; '[3, 1]'::jsonb;

-- А повторяющиеся элементы массива не имеют значения:
SELECT '[1, 2, 3]'::jsonb @&gt; '[1, 2, 2]'::jsonb;

-- Объект с одной парой справа входит в объект слева:
SELECT '{"product": "PostgreSQL", "version": 9.4, "jsonb": true}'::jsonb @&gt; '{"version": 9.4}'::jsonb;

-- Массив справа <span class="emphasis"><strong>не</strong></span> считается входящим в
-- массив слева, хотя в последний и вложен подобный массив:
SELECT '[1, 2, [1, 3]]'::jsonb @&gt; '[1, 3]'::jsonb;  -- выдаёт false

-- Но если добавить уровень вложенности, проверка на вхождение выполняется:
SELECT '[1, 2, [1, 3]]'::jsonb @&gt; '[[1, 3]]'::jsonb;

-- Аналогично, это вхождением не считается:
SELECT '{"foo": {"bar": "baz"}}'::jsonb @&gt; '{"bar": "baz"}'::jsonb;  -- выдаёт false

-- Ключ с пустым объектом на верхнем уровне входит в объект с таким ключом:
SELECT '{"foo": {"bar": "baz"}}'::jsonb @&gt; '{"foo": {}}'::jsonb;</pre><p>Общий принцип этой проверки в том, что входящий объект должен соответствовать объекту, содержащему его, по структуре и данным, возможно, после исключения из содержащего объекта лишних элементов массива или пар ключ/значение. Но помните, что порядок элементов массива для проверки на вхождение не имеет значения, а повторяющиеся элементы массива считаются только один раз.</p><p>В качестве особого исключения для требования идентичности структур, массив может содержать примитивное значение:</p><pre class="programlisting">-- В этот массив входит примитивное строковое значение:
SELECT '["foo", "bar"]'::jsonb @&gt; '"bar"'::jsonb;

-- Это исключение действует только в одну сторону -- здесь вхождения нет:
SELECT '"bar"'::jsonb @&gt; '["bar"]'::jsonb;  -- выдаёт false</pre><p>Для типа <code class="type">jsonb</code> введён также оператор <em class="firstterm">существования</em>, который является вариацией на тему вхождения: он проверяет, является ли строка (заданная в виде значения <code class="type">text</code>) ключом объекта или элементом массива на верхнем уровне значения <code class="type">jsonb</code>. В следующих примерах возвращается истинное значение (кроме упомянутых исключений):</p><pre class="programlisting">-- Строка существует в качестве элемента массива:
SELECT '["foo", "bar", "baz"]'::jsonb ? 'bar';

-- Строка существует в качестве ключа объекта:
SELECT '{"foo": "bar"}'::jsonb ? 'foo';

-- Значения объектов не рассматриваются:
SELECT '{"foo": "bar"}'::jsonb ? 'bar';  -- выдаёт false

-- Как и вхождение, существование определяется на верхнем уровне:
SELECT '{"foo": {"bar": "baz"}}'::jsonb ? 'bar'; -- выдаёт false

-- Строка считается существующей, если она соответствует примитивной строке JSON:
SELECT '"foo"'::jsonb ? 'foo';</pre><p>Объекты JSON для проверок на существование и вхождение со множеством ключей или элементов подходят больше, чем массивы, так как, в отличие от массивов, они внутри оптимизируются для поиска, и поиск элемента не будет линейным.</p><div class="tip"><h3 class="title">Подсказка</h3><p>Так как вхождение в JSON проверяется с учётом вложенности, правильно написанный запрос может заменить явную выборку внутренних объектов. Например, предположим, что у нас есть столбец <code class="structfield">doc</code>, содержащий объекты на верхнем уровне, и большинство этих объектов содержит поля <code class="literal">tags</code> с массивами вложенных объектов. Данный запрос найдёт записи, в которых вложенные объекты содержат ключи <code class="literal">"term":"paris"</code> и <code class="literal">"term":"food"</code>, и при этом пропустит такие ключи, находящиеся вне массива <code class="literal">tags</code>: </p><pre class="programlisting">SELECT doc-&gt;'site_name' FROM websites
  WHERE doc @&gt; '{"tags":[{"term":"paris"}, {"term":"food"}]}';</pre><p> Этого же результата можно добиться, например, так: </p><pre class="programlisting">SELECT doc-&gt;'site_name' FROM websites
  WHERE doc-&gt;'tags' @&gt; '[{"term":"paris"}, {"term":"food"}]';</pre><p> Но данный подход менее гибкий и часто также менее эффективный.</p><p>С другой стороны, оператор существования JSON не учитывает вложенность: он будет искать заданный ключ или элемент массива только на верхнем уровне значения JSON.</p></div><p>Различные операторы вхождения и существования, а также все другие операторы и функции для работы с JSON документированы в <a class="xref" href="functions-json.html" title="9.16. Функции и операторы JSON">Разделе 9.16</a>.</p></div><div class="sect2" id="JSON-INDEXING"><div class="titlepage"><div><div><h3 class="title">8.14.4. Индексация <code class="type">jsonb</code> <a href="#JSON-INDEXING" class="id_link">#</a></h3></div></div></div><a id="id-1.5.7.22.18.2" class="indexterm"></a><p>Для эффективного поиска ключей или пар ключ/значение в большом количестве документов <code class="type">jsonb</code> можно успешно применять индексы GIN. Для этого предоставляются два <span class="quote">«<span class="quote">класса операторов</span>»</span> GIN, предлагающие выбор между производительностью и гибкостью.</p><p>Класс операторов GIN по умолчанию для <code class="type">jsonb</code> поддерживает запросы с операторами существования ключа (<code class="literal">?</code>, <code class="literal">?|</code> и <code class="literal">?&amp;</code>), оператором включения (<code class="literal">@&gt;</code>) и операторами соответствия для <code class="type">jsonpath</code> (<code class="literal">@?</code> и <code class="literal">@@</code>). (Подробнее семантика, реализуемая этими операторами, описана в <a class="xref" href="functions-json.html#FUNCTIONS-JSONB-OP-TABLE" title="Таблица 9.46. Дополнительные операторы jsonb">Таблице 9.46</a>.) Пример создания индекса с этим классом операторов: </p><pre class="programlisting">CREATE INDEX idxgin ON api USING GIN (jdoc);</pre><p> Дополнительный класс операторов GIN <code class="literal">jsonb_path_ops</code> не поддерживает операторы существования ключа, но поддерживает <code class="literal">@&gt;</code>, <code class="literal">@?</code> и <code class="literal">@@</code>. Пример создания индекса с этим классом операторов: </p><pre class="programlisting">CREATE INDEX idxginp ON api USING GIN (jdoc jsonb_path_ops);</pre><p>Рассмотрим пример таблицы, в которой хранятся документы JSON, получаемые от сторонней веб-службы, с документированным определением схемы. Типичный документ:</p><pre class="programlisting">{
    "guid": "9c36adc1-7fb5-4d5b-83b4-90356a46061a",
    "name": "Angela Barton",
    "is_active": true,
    "company": "Magnafone",
    "address": "178 Howard Place, Gulf, Washington, 702",
    "registered": "2009-11-07T08:53:22 +08:00",
    "latitude": 19.793713,
    "longitude": 86.513373,
    "tags": [
        "enim",
        "aliquip",
        "qui"
    ]
}</pre><p> Мы сохраняем эти документы в таблице <code class="structname">api</code>, в столбце <code class="structfield">jdoc</code> типа <code class="type">jsonb</code>. Если по этому столбцу создаётся GIN-индекс, он может применяться в подобных запросах: </p><pre class="programlisting">-- Найти документы, в которых ключ "company" имеет значение "Magnafone"
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc @&gt; '{"company": "Magnafone"}';</pre><p> Однако в следующих запросах он не будет использоваться, потому что, несмотря на то, что оператор <code class="literal">?</code> — индексируемый, он применяется не к индексированному столбцу <code class="structfield">jdoc</code> непосредственно: </p><pre class="programlisting">-- Найти документы, в которых ключ "tags" содержит ключ или элемент массива "qui"
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc -&gt; 'tags' ? 'qui';</pre><p> И всё же, правильно применяя индексы выражений, в этом запросе можно задействовать индекс. Если запрос определённых элементов в ключе <code class="literal">"tags"</code> выполняется часто, вероятно стоит определить такой индекс: </p><pre class="programlisting">CREATE INDEX idxgintags ON api USING GIN ((jdoc -&gt; 'tags'));</pre><p> Теперь предложение <code class="literal">WHERE</code> <code class="literal">jdoc -&gt; 'tags' ? 'qui'</code> будет выполняться как применение индексируемого оператора <code class="literal">?</code> к индексируемому выражению <code class="literal">jdoc -&gt; 'tags'</code>. (Подробнее об индексах выражений можно узнать в <a class="xref" href="indexes-expressional.html" title="11.7. Индексы по выражениям">Разделе 11.7</a>.)</p><p>Ещё один подход к использованию проверок на существование: </p><pre class="programlisting">-- Найти документы, в которых ключ "tags" содержит элемент массива "qui"
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc @&gt; '{"tags": ["qui"]}';</pre><p> Этот запрос может задействовать простой GIN-индекс по столбцу <code class="structfield">jdoc</code>. Но заметьте, что такой индекс будет хранить копии всех ключей и значений в поле <code class="structfield">jdoc</code>, тогда как индекс выражения из предыдущего примера хранит только данные внутри объекта с ключом <code class="literal">tags</code>. Хотя подход с простым индексом гораздо более гибкий (так как он поддерживает запросы по любому ключу), индексы конкретных выражений скорее всего будут меньше и быстрее, чем простые индексы.</p><p>Также индексы GIN поддерживают операторы <code class="literal">@?</code> и <code class="literal">@@</code>, которые сопоставляют <code class="type">jsonpath</code> с данными. Примеры: </p><pre class="programlisting">SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc @? '$.tags[*] ? (@ == "qui")';</pre><p> </p><pre class="programlisting">SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc @@ '$.tags[*] == "qui"';</pre><p> Для этих операторов индекс GIN извлекает из <code class="literal">jsonpath</code> предложения вида <em class="replaceable"><code>цепочка_обращения</code></em> = <em class="replaceable"><code>константа</code></em> и выполняет поиск по ключам и значениям из этих предложений. Цепочка обращения может включать указания обращения <code class="literal">.<em class="replaceable"><code>ключ</code></em></code>, <code class="literal">[*]</code> и <code class="literal">[<em class="replaceable"><code>индекс</code></em>]</code>. Класс операторов <code class="literal">jsonb_ops</code> также поддерживает указания <code class="literal">.*</code> и <code class="literal">.**</code>, которые не поддерживает класс операторов <code class="literal">jsonb_path_ops</code>.</p><p>Класс операторов <code class="literal">jsonb_path_ops</code> поддерживает только запросы с операторами <code class="literal">@&gt;</code>, <code class="literal">@?</code> и <code class="literal">@@</code>, но он значительно производительнее класса по умолчанию <code class="literal">jsonb_ops</code>. Индекс <code class="literal">jsonb_path_ops</code> обычно гораздо меньше индекса <code class="literal">jsonb_ops</code> для тех же данных и более точен при поиске, особенно если запросы обращаются к ключам, часто встречающимся в данных. Таким образом, с ним операции поиска выполняются гораздо эффективнее, чем с классом операторов по умолчанию.</p><p>Техническое различие между GIN-индексами <code class="literal">jsonb_ops</code> и <code class="literal">jsonb_path_ops</code> состоит в том, что для первых создаются независимые элементы индекса для каждого ключа/значения в данных, тогда как для вторых создаются элементы только для значений. <a href="#ftn.id-1.5.7.22.18.9.3" class="footnote"><sup class="footnote" id="id-1.5.7.22.18.9.3">[7]</sup></a> По сути, каждый элемент индекса <code class="literal">jsonb_path_ops</code> представляет собой хеш значения и ключа(ей), приводящего к нему; например, при индексации <code class="literal">{"foo": {"bar": "baz"}}</code> будет создан один элемент индекса с хешем, рассчитанным по всем трём значениям: <code class="literal">foo</code>, <code class="literal">bar</code> и <code class="literal">baz</code>. Таким образом, проверка на вхождение этой структуры будет использовать крайне точный поиск по индексу, но определить, является ли <code class="literal">foo</code> ключом, с помощью такого индекса нельзя. С другой стороны, индекс <code class="literal">jsonb_ops</code> создаст три отдельных элемента индекса, представляющих <code class="literal">foo</code>, <code class="literal">bar</code> и <code class="literal">baz</code> по отдельности; для выполнения проверки на вхождение будут проверены строки таблицы, содержащие все эти три значения. Хотя GIN-индексы позволяют вычислить AND довольно эффективно, такой поиск всё же будет менее точным и более медленным, чем равнозначный поиск с <code class="literal">jsonb_path_ops</code>, особенно если любое одно из этих трёх значений содержится в большом количестве строк.</p><p>Недостаток класса <code class="literal">jsonb_path_ops</code> заключается в том, что он не учитывает в индексе структуры JSON, не содержащие никаких значений <code class="literal">{"a": {}}</code>. Для поиска по документам, содержащих такие структуры, потребуется выполнить полное сканирование индекса, что довольно долго, поэтому <code class="literal">jsonb_path_ops</code> не очень подходит для приложений, часто выполняющих такие запросы.</p><p>Тип <code class="type">jsonb</code> также поддерживает индексы <code class="literal">btree</code> и <code class="literal">hash</code>. Они полезны, только если требуется проверять равенство JSON-документов в целом. Порядок сортировки <code class="literal">btree</code> для типа <code class="type">jsonb</code> редко имеет большое значение, но для полноты он приводится ниже: </p><pre class="synopsis">
<em class="replaceable"><code>Объект</code></em> &gt; <em class="replaceable"><code>Массив</code></em> &gt; <em class="replaceable"><code>Логическое значение</code></em> &gt; <em class="replaceable"><code>Число</code></em> &gt; <em class="replaceable"><code>Строка</code></em> &gt; <em class="replaceable"><code>Null</code></em>

<em class="replaceable"><code>Объект с n парами</code></em> &gt; <em class="replaceable"><code>Объект с n - 1 парами</code></em>

<em class="replaceable"><code>Массив с n элементами</code></em> &gt; <em class="replaceable"><code>Массив с n - 1 элементами</code></em>
</pre><p> Объекты с равным количеством пар сравниваются в таком порядке: </p><pre class="synopsis">
<em class="replaceable"><code>ключ-1</code></em>, <em class="replaceable"><code>значение-1</code></em>, <em class="replaceable"><code>ключ-2</code></em> ...
</pre><p> Заметьте, что ключи объектов сравниваются согласно порядку при хранении; в частности, из-за того, что короткие ключи хранятся перед длинными, результаты могут оказаться несколько не интуитивными: </p><pre class="programlisting">{ "aa": 1, "c": 1} &gt; {"b": 1, "d": 1}</pre><p> Массивы с равным числом элементом упорядочиваются аналогично: </p><pre class="synopsis">
<em class="replaceable"><code>элемент-1</code></em>, <em class="replaceable"><code>элемент-2</code></em> ...
</pre><p> Примитивные значения JSON сравниваются по тем же правилам сравнения, что и нижележащие типы данных <span class="productname">PostgreSQL</span>. Строки сравниваются с учётом порядка сортировки по умолчанию в текущей базе данных.</p></div><div class="sect2" id="JSONB-SUBSCRIPTING"><div class="titlepage"><div><div><h3 class="title">8.14.5. Обращение по индексу к элементам <code class="type">jsonb</code> <a href="#JSONB-SUBSCRIPTING" class="id_link">#</a></h3></div></div></div><p>Тип данных <code class="type">jsonb</code> поддерживает извлечение и изменение элементов в стиле обращения к элементам массива. Указывать на вложенные значения можно, задавая цепочку обращений к элементам, при этом будут действовать правила использования аргумента <code class="literal">path</code> функции <code class="literal">jsonb_set</code>. Если значение <code class="type">jsonb</code> является массивом, числовые индексы начинаются с нуля, а отрицательные целые числа отсчитывают элементы c конца массива к началу. Обращения к срезам массивов не поддерживаются. Результат обращения по индексу всегда имеет тип jsonb.</p><p>Используя операцию обращения по индексу в предложении <code class="literal">SET</code> оператора <code class="command">UPDATE</code>, можно изменять значения <code class="type">jsonb</code>. Путь такого обращения должен быть «проходимым» для всех указанных значений, если они существуют. Например, путь <code class="literal">val['a']['b']['c']</code> можно пройти полностью до <code class="literal">c</code>, если <code class="literal">val</code>, <code class="literal">val['a']</code> и <code class="literal">val['a']['b']</code> — объекты. Если же значение <code class="literal">val['a']</code> или <code class="literal">val['a']['b']</code> не определено, будет создан пустой объект, заполняемый по мере необходимости. Однако, если значение собственно <code class="literal">val</code> или любое из промежуточных значений существует и является не объектом, а, например, строкой, числом или сущностью <code class="literal">jsonb</code> <code class="literal">null</code>, пройти этот путь невозможно, поэтому возникает ошибка и транзакция прерывается.</p><p>Пример синтаксиса обращения по индексу: </p><pre class="programlisting">-- Извлечь значение объекта по ключу
SELECT ('{"a": 1}'::jsonb)['a'];

-- Извлечь значение вложенного объекта по пути ключа
SELECT ('{"a": {"b": {"c": 1}}}'::jsonb)['a']['b']['c'];

-- Извлечь элемент массива по индексу
SELECT ('[1, "2", null]'::jsonb)[1];

-- Изменить значение объекта по ключу. Обратите внимание на апострофы вокруг '1': присваиваемое
-- значение также должно быть типа jsonb
 UPDATE table_name SET jsonb_field['key'] = '1';

-- Это вызовет ошибку, если jsonb_field['a']['b'] в какой-либо записи является не объектом.
-- Например, в {"a": 1} ключу 'a' соответствует числовое значение
-- ключа 'а'.
UPDATE table_name SET jsonb_field['a']['b']['c'] = '1';

-- Отфильтровать записи предложением WHERE с обращением по ключу. Поскольку результат
-- обращения по ключу будет иметь тип jsonb, такой же тип должно иметь сравниваемое с ним значение.
-- Двойные кавычки добавлены, чтобы строка "value" стала допустимой строкой jsonb.
SELECT * FROM table_name WHERE jsonb_field['key'] = '"value"';</pre><p> Присваивание <code class="type">jsonb</code> при обращении по индексу в некоторых особых случаях работает не так, как с функцией <code class="literal">jsonb_set</code>. Когда исходное значение <code class="type">jsonb</code> — <code class="literal">NULL</code>, присваивание при обращении по ключу будет работать, как будто это значение — пустое значение JSON (типа массив или объект, в зависимости от типа ключа): </p><pre class="programlisting">-- Там, где поле jsonb_field было NULL, оно станет {"a": 1}
UPDATE table_name SET jsonb_field['a'] = '1';

-- Там, где поле jsonb_field было NULL, оно станет [1]
UPDATE table_name SET jsonb_field[0] = '1';</pre><p> Если индекс указан для массива, содержащего недостаточно элементов, в него будут добавляться элементы со значением <code class="literal">NULL</code> до тех пор, пока индекс не станет достижимым и пока не станет возможным задать значение. </p><pre class="programlisting">-- Там, где поле jsonb_field было [], оно станет [null, null, 2];
-- там, где поле jsonb_field было [0], оно станет [0, null, 2]
UPDATE table_name SET jsonb_field[2] = '2';</pre><p> Значение <code class="type">jsonb</code> будет принимать присваивания по несуществующим путям, если последний существующий элемент, который нужно пройти, — объект или массив, в зависимости от соответствующего ключа (элемент, на который указывает последний компонент пути, не проходится и может быть любым). Вложенные структуры массивов и объектов будут созданы и для первых дополнятся элементами <code class="literal">null</code> до нужной позиции (заданной в пути), в которую может быть помещено присваиваемое значение. </p><pre class="programlisting">-- Там, где поле jsonb_field было {}, оно станет {"a": [{"b": 1}]}
UPDATE table_name SET jsonb_field['a'][0]['b'] = '1';

-- Там, где поле jsonb_field было [], оно станет [null, {"a": 1}]
UPDATE table_name SET jsonb_field[1]['a'] = '1';</pre></div><div class="sect2" id="DATATYPE-JSON-TRANSFORMS"><div class="titlepage"><div><div><h3 class="title">8.14.6. Трансформации <a href="#DATATYPE-JSON-TRANSFORMS" class="id_link">#</a></h3></div></div></div><p>Для различных процедурных языков представлены дополнительные расширения, реализующие трансформации для типа <code class="type">jsonb</code>.</p><p>Расширения для PL/Perl называются <code class="literal">jsonb_plperl</code> и <code class="literal">jsonb_plperlu</code>. Когда они используются, значения <code class="type">jsonb</code> отображаются в соответствующие структуры Perl: массивы, хеши или скаляры.</p><p>Расширение для PL/Python называется <code class="literal">jsonb_plpython3u</code>. Когда оно используется, значения <code class="type">jsonb</code> отображаются в соответствующие структуры Python: словари, списки или скаляры.</p><p>Из этих расширений <span class="quote">«<span class="quote">доверенным</span>»</span> считается <code class="literal">jsonb_plperl</code>, то есть его могут устанавливать обычные пользователи, имеющие право <code class="literal">CREATE</code> в текущей базе данных. Остальные расширения могут устанавливать только суперпользователи.</p></div><div class="sect2" id="DATATYPE-JSONPATH"><div class="titlepage"><div><div><h3 class="title">8.14.7. Тип jsonpath <a href="#DATATYPE-JSONPATH" class="id_link">#</a></h3></div></div></div><a id="id-1.5.7.22.21.2" class="indexterm"></a><p>Тип <code class="type">jsonpath</code> предназначен для реализации поддержки языка путей SQL/JSON в <span class="productname">PostgreSQL</span>, позволяющего эффективно выполнять запросы к данным JSON. Он обеспечивает двоичное представление разобранного выражения пути SQL/JSON, определяющего, какие элементы должны извлекаться из данных JSON для дальнейшей обработки в функциях SQL/JSON.</p><p>Семантика предикатов и операторов языка путей SQL/JSON в целом соответствует SQL. В то же время, чтобы с данными JSON можно было оперировать естественным образом, в синтаксисе путей SQL/JSON приняты некоторые соглашения JavaScript:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Точка (<code class="literal">.</code>) применяется для доступа к члену объекта.</p></li><li class="listitem"><p>Квадратные скобки (<code class="literal">[]</code>) применяются для обращения к массиву.</p></li><li class="listitem"><p>Элементы массивов в SQL/JSON нумеруются с 0, тогда как обычные массивы SQL — с 1.</p></li></ul></div><p>Числовые константы в выражениях путей SQL/JSON подчиняются правилам JavaScript, которые отличаются от SQL и JSON в некоторых мелких деталях. Например, пути SQL/JSON допускают <code class="literal">.1</code> и <code class="literal">1.</code>, которые недопустимы в JSON. Поддерживаются недесятичные целочисленные константы и разделители-подчёркивания, например, <code class="literal">1_000_000</code>, <code class="literal">0x1EEE_FFFF</code>, <code class="literal">0o273</code>, <code class="literal">0b100101</code>. В путях SQL/JSON (и в JavaScript, но не в самом SQL) не должно быть разделителя-подчёркивания непосредственно после префикса системы счисления.</p><p>Выражение пути SQL/JSON обычно записывается в SQL-запросе в виде символьной константы SQL, и поэтому должно заключаться в апострофы, а любой апостроф, который нужно заключить в это значение, должен дублироваться (см. <a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-STRINGS" title="4.1.2.1. Строковые константы">Подраздел 4.1.2.1</a>). Нередко строковые константы требуется использовать и внутри выражений путей. На такие константы распространяются соглашения JavaScript/ECMAScript: они должны заключаться в двойные кавычки, а для представления символов, которые сложно ввести иначе, используются спецпоследовательности с обратной косой чертой. В частности, символ двойных кавычек внутри строковой константы записывается как <code class="literal">\"</code>, а собственно обратная косая черта как <code class="literal">\\</code>. В число других спецпоследовательностей, воспринимаемых в строках JavaScript, входят: <code class="literal">\b</code>, <code class="literal">\f</code>, <code class="literal">\n</code>, <code class="literal">\r</code>, <code class="literal">\t</code>, <code class="literal">\v</code>, выражающие различные управляющие символы ASCII, <code class="literal">\x<em class="replaceable"><code>NN</code></em></code>, выражающая символ кодом в виде только двух шестнадцатеричных цифр, <code class="literal">\u<em class="replaceable"><code>NNNN</code></em></code>, выражающая символ Unicode кодом в виде четырёх шестнадцатеричных цифр, а также <code class="literal">\u{<em class="replaceable"><code>N...</code></em>}</code>, позволяющая для записи кода символа Unicode использовать от 1 до 6 шестнадцатеричных цифр.</p><p>Выражение пути состоит из последовательности элементов пути, которые могут быть следующими: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Константы примитивных типов JSON: текст Unicode, числа и значения true, false и null.</p></li><li class="listitem"><p>Переменные пути перечислены в <a class="xref" href="datatype-json.html#TYPE-JSONPATH-VARIABLES" title="Таблица 8.24. Переменные jsonpath">Таблице 8.24</a>.</p></li><li class="listitem"><p>Операторы обращения перечислены в <a class="xref" href="datatype-json.html#TYPE-JSONPATH-ACCESSORS" title="Таблица 8.25. Операторы обращения в jsonpath">Таблице 8.25</a>.</p></li><li class="listitem"><p>Операторы и методы <code class="type">jsonpath</code> перечислены в <a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-PATH-OPERATORS" title="9.16.2.2. Операторы и методы SQL/JSON">Подразделе 9.16.2.2</a>.</p></li><li class="listitem"><p>Скобки, применяющиеся для образования выражений фильтра и изменения порядка вычисления пути.</p></li></ul></div><p>Более подробно использование выражений <code class="type">jsonpath</code> с функциями запросов SQL/JSON описано в <a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-PATH" title="9.16.2. Язык путей SQL/JSON">Подразделе 9.16.2</a>.</p><div class="table" id="TYPE-JSONPATH-VARIABLES"><p class="title"><strong>Таблица 8.24. Переменные <code class="type">jsonpath</code></strong></p><div class="table-contents"><table class="table" summary="Переменные jsonpath" border="1"><colgroup><col class="col1" /><col class="col2" /></colgroup><thead><tr><th>Переменная</th><th>Описание</th></tr></thead><tbody><tr><td><code class="literal">$</code></td><td>Переменная, представляющая значение JSON, фигурирующее в запросе (<em class="firstterm">элемент контекста</em>).</td></tr><tr><td><code class="literal">$varname</code></td><td>Именованная переменная. Её значение может быть задано в параметре <em class="parameter"><code>vars</code></em>, который принимают различные функции обработки JSON; подробности в <a class="xref" href="functions-json.html#FUNCTIONS-JSON-PROCESSING-TABLE" title="Таблица 9.49. Функции для обработки JSON">Таблице 9.49</a>.</td></tr><tr><td><code class="literal">@</code></td><td>Переменная, представляющая результат вычисления пути в выражениях фильтров.</td></tr></tbody></table></div></div><br class="table-break" /><div class="table" id="TYPE-JSONPATH-ACCESSORS"><p class="title"><strong>Таблица 8.25. Операторы обращения в <code class="type">jsonpath</code></strong></p><div class="table-contents"><table class="table" summary="Операторы обращения в jsonpath" border="1"><colgroup><col class="col1" /><col class="col2" /></colgroup><thead><tr><th>Оператор обращения</th><th>Описание</th></tr></thead><tbody><tr><td>
       <p>
        <code class="literal">.<em class="replaceable"><code>ключ</code></em></code>
       </p>
       <p>
        <code class="literal">."$<em class="replaceable"><code>имя_переменной</code></em>"</code>
       </p>
      </td><td>
       <p>Оператор обращения к члену объекта, выбираемому по заданному ключу. Если имя ключа совпадает с именем какой-либо переменной, начинающимся с <code class="literal">$</code>, или не соответствует действующим в JavaScript требованиям к идентификаторам, оно должно заключаться в двойные кавычки и таким образом представляться как строковая константа.</p>
      </td></tr><tr><td>
       <p>
        <code class="literal">.*</code>
       </p>
      </td><td>
       <p>Оператор обращения по звёздочке, который возвращает значения всех членов, находящихся на верхнем уровне объекта.</p>
      </td></tr><tr><td>
       <p>
        <code class="literal">.**</code>
       </p>
      </td><td>
       <p>Рекурсивный оператор обращения по звёздочке, который проходит по всем уровням иерархии JSON текущего объекта и возвращает все значения членов, вне зависимости от их уровня вложенности. Это реализованное в <span class="productname">PostgreSQL</span> расширение стандарта SQL/JSON.</p>
      </td></tr><tr><td>
       <p>
        <code class="literal">.**{<em class="replaceable"><code>уровень</code></em>}</code>
       </p>
       <p>
        <code class="literal">.**{<em class="replaceable"><code>начальный_уровень</code></em> to <em class="replaceable"><code>конечный_уровень</code></em>}</code>
       </p>
      </td><td>
       <p>Этот оператор подобен <code class="literal">.**</code>, но выбирает только указанные уровни иерархии JSON. Уровни вложенности задаются целыми числами, при этом нулевой уровень соответствует текущему объекту. Для обращения к самому нижнему уровню вложенности можно использовать ключевое слово <code class="literal">last</code>. Это реализованное в <span class="productname">PostgreSQL</span> расширение стандарта SQL/JSON.</p>
      </td></tr><tr><td>
       <p>
        <code class="literal">[<em class="replaceable"><code>селектор</code></em>, ...]</code>
       </p>
      </td><td>
       <p>Оператор обращения к элементу массива. <code class="literal"><em class="replaceable"><code>Селектор</code></em></code> может задаваться в двух формах: <code class="literal"><em class="replaceable"><code>индекс</code></em></code> или <code class="literal"><em class="replaceable"><code>начальный_индекс</code></em> to <em class="replaceable"><code>конечный_индекс</code></em></code>. Первая форма выбирает единственный элемент по индексу. Вторая форма выбирает срез массива по двум индексам, включающий крайние элементы, соответствущие значениям <em class="replaceable"><code>начальный_индекс</code></em> и <em class="replaceable"><code>конечный_индекс</code></em>.</p>
       <p>Задаваемый <em class="replaceable"><code>индекс</code></em> может быть целочисленным значением или выражением, возвращающим единственное число, которое автоматически приводится к целому. Индекс 0 соответствует первому элементу массива. Также в качестве индекса принимается ключевое слово <code class="literal">last</code>, обозначающее индекс последнего элемента массива, что полезно при обработке массивов неизвестной длины.</p>
      </td></tr><tr><td>
       <p>
        <code class="literal">[*]</code>
       </p>
      </td><td>
       <p>Оператор обращения к элементам массива по звёздочке, возвращающий все элементы массива.</p>
      </td></tr></tbody></table></div></div><br class="table-break" /></div><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.id-1.5.7.22.18.9.3" class="footnote"><p><a href="#id-1.5.7.22.18.9.3" class="para"><sup class="para">[7] </sup></a>Поэтому понятие <span class="quote">«<span class="quote">значение</span>»</span> включает и элементы массивов, хотя в терминологии JSON иногда элементы массивов считаются отличными от значений внутри объектов.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="datatype-xml.html" title="8.13. Тип XML">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="datatype.html" title="Глава 8. Типы данных">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="arrays.html" title="8.15. Массивы">След.</a></td></tr><tr><td width="40%" align="left" valign="top">8.13. Тип <acronym class="acronym">XML</acronym> </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 8.15. Массивы</td></tr></table></div></body></html>