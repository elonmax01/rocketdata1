<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>41.1. Дерево запроса</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="rules.html" title="Глава 41. Система правил" /><link rel="next" href="rules-views.html" title="41.2. Система правил и представления" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">41.1. Дерево запроса</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="rules.html" title="Глава 41. Система правил">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="rules.html" title="Глава 41. Система правил">Наверх</a></td><th width="60%" align="center">Глава 41. Система правил</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="rules-views.html" title="41.2. Система правил и представления">След.</a></td></tr></table><hr /></div><div class="sect1" id="QUERYTREE"><div class="titlepage"><div><div><h2 class="title" style="clear: both">41.1. Дерево запроса <a href="#QUERYTREE" class="id_link">#</a></h2></div></div></div><a id="id-1.8.6.6.2" class="indexterm"></a><p>Чтобы понять, как работает система правил, нужно знать, когда она вызывается, что принимает на вход и какой результат выдаёт.</p><p>Система правил внедрена между анализатором запросов и планировщиком. Она принимает разобранный запрос, одно дерево запроса, и определённые пользователем правила перезаписи, тоже представленные деревьями с некоторой дополнительной информацией, и создаёт некоторое количество деревьев запросов в результате. Таким образом, на входе и выходе этой системы оказывается то, что может сформировать анализатор запросов, и как следствие, всё, с чем работает эта система, представимо в виде операторов <acronym class="acronym">SQL</acronym>.</p><p>Так что же такое дерево запроса? Это внутреннее представление оператора <acronym class="acronym">SQL</acronym>, в котором все образующие его части хранятся отдельно. Эти деревья можно увидеть в журнале сервера, если установить параметры конфигурации <code class="varname">debug_print_parse</code>, <code class="varname">debug_print_rewritten</code> или <code class="varname">debug_print_plan</code>. Действия правил также хранятся в виде деревьев запросов, в системном каталоге <code class="structname">pg_rewrite</code>. Они не форматируются как при выводе в журнал, но содержат точно такую же информацию.</p><p>Для прочтения неформатированного дерева требуется некоторый навык. Но так как представления дерева запросов в виде <acronym class="acronym">SQL</acronym> достаточно, чтобы понять систему правил, в этой главе не будет рассказываться, как их читать.</p><p>Читая <acronym class="acronym">SQL</acronym>-представления деревьев запросов в этой главе, необходимо понимать, на какие части разбивается оператор, когда он преобразуется в структуру дерева запроса. Дерево запроса состоит из следующих частей: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">тип команды</span></dt><dd><p>Это простое значение, говорящее, какая команда (<code class="command">SELECT</code>, <code class="command">INSERT</code>, <code class="command">UPDATE</code> или <code class="command">DELETE</code>) сгенерировала дерево запросов.</p></dd><dt><span class="term">список отношений <a id="id-1.8.6.6.7.2.2.1.1" class="indexterm"></a></span></dt><dd><p>Список отношений представляет собой массив отношений, используемых в запросе. В запросе <code class="command">SELECT</code> он включает отношения, указанные после ключевого слова <code class="literal">FROM</code>.</p><p>Каждый элемент списка отношений представляет таблицу или представление и говорит, с каким именем они упоминаются в других частях запроса. В дереве запросов записываются номера элементов списка отношений, а не их имена, поэтому для него неактуальна проблема дублирования имён, как для оператора <acronym class="acronym">SQL</acronym>. Такая проблема может возникнуть при объединении списков отношений, образованных разными правилами. В этой главе данная ситуация рассматриваться не будет.</p></dd><dt><span class="term">результирующее отношение</span></dt><dd><p>Индекс в списке отношений, указывающий на отношение, которое будет получать результаты запроса.</p><p>В запросах <code class="command">SELECT</code> результирующее отношение отсутствует. (Особый случай <code class="command">SELECT INTO</code> практически равнозначен <code class="command">CREATE TABLE</code> с последующим <code class="literal">INSERT ... SELECT</code> и здесь отдельно не рассматривается.)</p><p>Для команд <code class="command">INSERT</code>, <code class="command">UPDATE</code> и <code class="command">DELETE</code> результирующим отношением будет таблица (или представление!), в которой будут происходить изменения.</p></dd><dt><span class="term">выходной список <a id="id-1.8.6.6.7.2.4.1.1" class="indexterm"></a></span></dt><dd><p>Выходной список — это список выражений, определяющих результат запроса. В случае <code class="command">SELECT</code>, это выражения, которые образуют окончательный набор выходных данных. Они соответствуют выражениям, записанным между ключевыми словами <code class="command">SELECT</code> и <code class="command">FROM</code>. (Указание <code class="literal">*</code> — это просто краткое обозначение имён всех столбцов отношения. Анализатор разворачивает его в список отдельных столбцов, так что система правил никогда не видит его.)</p><p>Командам <code class="command">DELETE</code> не нужен обычный выходной список, так как они не выдают никакие результаты. Вместо этого планировщик добавляет в пустой выходной список специальную запись <acronym class="acronym">CTID</acronym>, чтобы исполнитель мог найти удаляемую строку. (<acronym class="acronym">CTID</acronym> добавляется, когда результирующее отношение — обычная таблица. Если это представление, планировщиком добавляется переменная, содержащая всю строку, как рассказывается в <a class="xref" href="rules-views.html#RULES-VIEWS-UPDATE" title="41.2.4. Изменение представления">Подразделе 41.2.4</a>.)</p><p>Для команд <code class="command">INSERT</code> выходной список описывает новые строки, которые должны попасть в результирующее отношение. Он включает выражения в предложении <code class="literal">VALUES</code> или предложении <code class="command">SELECT</code> в <code class="literal">INSERT ... SELECT</code>. На первом этапе процесс перезаписи добавляет элементы выходного списка для столбцов, которым ничего не присвоила исходная команда, но имеющих значения по умолчанию. Все остальные столбцы (без заданного значения и значения по умолчанию) планировщик заполняет константой NULL.</p><p>Для команд <code class="command">UPDATE</code> выходной список описывает новые строки, которые должны заменить старые. В системе правил он содержит только выражения из части <code class="literal">SET столбец = выражение</code>. Для пропущенных столбцов планировщик вставляет выражения, копирующие значения из старой строки в новую. Так же, как и с командой <code class="command">DELETE</code>, при этом добавляется <acronym class="acronym">CTID</acronym> или переменная со всей строкой, чтобы исполнитель мог найти изменяемую старую строку.</p><p>Каждая запись в выходном списке содержит выражение, которое может быть константой, переменной, указывающей на столбец отношения в таблице отношений, параметром или деревом выражений, образованным из констант, переменных, операторов, вызовов функций и т. д.</p></dd><dt><span class="term">условие фильтра</span></dt><dd><p>Условие фильтра запроса — это выражение, во многом похожее на те, что содержатся в выходном списке. Результат этого выражения — логический, он говорит, должна ли выполняться операция (<code class="command">INSERT</code>, <code class="command">UPDATE</code>, <code class="command">DELETE</code> или <code class="command">SELECT</code>) для данной строки в результате. Оно соответствует предложению <code class="literal">WHERE</code> <acronym class="acronym">SQL</acronym>-оператора.</p></dd><dt><span class="term">дерево соединения</span></dt><dd><p>Дерево соединения запроса показывает структуру предложения <code class="literal">FROM</code>. Для простых запросов вида <code class="literal">SELECT ... FROM a, b, c</code>, дерево соединения — это просто список элементов <code class="literal">FROM</code>, так как они могут соединяться в любом порядке. Но с выражениями <code class="literal">JOIN</code>, особенно с внешними соединениями, приходится соединять отношения именно в заданном порядке. В этом случае дерево соединения отражает структуру выражений <code class="literal">JOIN</code>. Ограничения, связанные с конкретными предложениями <code class="literal">JOIN</code> (из выражений <code class="literal">ON</code> или <code class="literal">USING</code>), тоже сохраняются в виде условных выражений, добавленных к соответствующим узлам дерева соединения. Как оказалось, выражение <code class="literal">WHERE</code> верхнего уровня тоже удобно хранить как условие, добавленное к элементу верхнего уровня дерева соединения. Поэтому в дереве соединения на самом деле представляются оба предложения оператора <code class="command">SELECT</code> — <code class="literal">FROM</code> и <code class="literal">WHERE</code>.</p></dd><dt><span class="term">другие</span></dt><dd><p>Другие части дерева запроса, например, предложение <code class="literal">ORDER BY</code>, в данном контексте не представляют интереса. Система правил выполняет в них некоторые подстановки, применяя правила, но это не имеет непосредственного отношения к основам системы правил.</p></dd></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="rules.html" title="Глава 41. Система правил">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="rules.html" title="Глава 41. Система правил">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="rules-views.html" title="41.2. Система правил и представления">След.</a></td></tr><tr><td width="40%" align="left" valign="top">Глава 41. Система правил </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 41.2. Система правил и представления</td></tr></table></div></body></html>