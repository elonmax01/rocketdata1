<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>49.6. Модули вывода логического декодирования</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="logicaldecoding-catalogs.html" title="49.5. Системные каталоги, связанные с логическим декодированием" /><link rel="next" href="logicaldecoding-writer.html" title="49.7. Запись вывода логического декодирования" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">49.6. Модули вывода логического декодирования</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="logicaldecoding-catalogs.html" title="49.5. Системные каталоги, связанные с логическим декодированием">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="logicaldecoding.html" title="Глава 49. Логическое декодирование">Наверх</a></td><th width="60%" align="center">Глава 49. Логическое декодирование</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="logicaldecoding-writer.html" title="49.7. Запись вывода логического декодирования">След.</a></td></tr></table><hr /></div><div class="sect1" id="LOGICALDECODING-OUTPUT-PLUGIN"><div class="titlepage"><div><div><h2 class="title" style="clear: both">49.6. Модули вывода логического декодирования <a href="#LOGICALDECODING-OUTPUT-PLUGIN" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="logicaldecoding-output-plugin.html#LOGICALDECODING-OUTPUT-INIT">49.6.1. Функция инициализации</a></span></dt><dt><span class="sect2"><a href="logicaldecoding-output-plugin.html#LOGICALDECODING-CAPABILITIES">49.6.2. Возможности</a></span></dt><dt><span class="sect2"><a href="logicaldecoding-output-plugin.html#LOGICALDECODING-OUTPUT-MODE">49.6.3. Режимы вывода</a></span></dt><dt><span class="sect2"><a href="logicaldecoding-output-plugin.html#LOGICALDECODING-OUTPUT-PLUGIN-CALLBACKS">49.6.4. Обработчики в модуле вывода</a></span></dt><dt><span class="sect2"><a href="logicaldecoding-output-plugin.html#LOGICALDECODING-OUTPUT-PLUGIN-OUTPUT">49.6.5. Функции для формирования вывода</a></span></dt></dl></div><p>Пример модуля вывода можно найти в подкаталоге <a class="link" href="test-decoding.html" title="F.45. test_decoding — пример модуля на базе SQL для логического декодирования WAL"><code class="filename">contrib/test_decoding</code></a> в дереве исходного кода PostgreSQL.</p><div class="sect2" id="LOGICALDECODING-OUTPUT-INIT"><div class="titlepage"><div><div><h3 class="title">49.6.1. Функция инициализации <a href="#LOGICALDECODING-OUTPUT-INIT" class="id_link">#</a></h3></div></div></div><a id="id-1.8.14.12.3.2" class="indexterm"></a><p>Модуль вывода загружается в результате динамической загрузки разделяемой библиотеки (при этом в качестве имени библиотеки задаётся имя модуля). Для нахождения библиотеки применяется обычный путь поиска библиотек. В этой библиотеке должна быть функция <code class="function">_PG_output_plugin_init</code>, которая показывает, что библиотека на самом деле представляет собой модуль вывода, и устанавливает требуемые обработчики модуля вывода. Этой функции передаётся структура, в которой должны быть заполнены указатели на функции-обработчики отдельных действий. </p><pre class="programlisting">typedef struct OutputPluginCallbacks
{
    LogicalDecodeStartupCB startup_cb;
    LogicalDecodeBeginCB begin_cb;
    LogicalDecodeChangeCB change_cb;
    LogicalDecodeTruncateCB truncate_cb;
    LogicalDecodeCommitCB commit_cb;
    LogicalDecodeMessageCB message_cb;
    LogicalDecodeFilterByOriginCB filter_by_origin_cb;
    LogicalDecodeShutdownCB shutdown_cb;
    LogicalDecodeFilterPrepareCB filter_prepare_cb;
    LogicalDecodeBeginPrepareCB begin_prepare_cb;
    LogicalDecodePrepareCB prepare_cb;
    LogicalDecodeCommitPreparedCB commit_prepared_cb;
    LogicalDecodeRollbackPreparedCB rollback_prepared_cb;
    LogicalDecodeStreamStartCB stream_start_cb;
    LogicalDecodeStreamStopCB stream_stop_cb;
    LogicalDecodeStreamAbortCB stream_abort_cb;
    LogicalDecodeStreamPrepareCB stream_prepare_cb;
    LogicalDecodeStreamCommitCB stream_commit_cb;
    LogicalDecodeStreamChangeCB stream_change_cb;
    LogicalDecodeStreamMessageCB stream_message_cb;
    LogicalDecodeStreamTruncateCB stream_truncate_cb;
} OutputPluginCallbacks;

typedef void (*LogicalOutputPluginInit) (struct OutputPluginCallbacks *cb);</pre><p> Обработчики <code class="function">begin_cb</code>, <code class="function">change_cb</code> и <code class="function">commit_cb</code> должны устанавливаться обязательно, а <code class="function">startup_cb</code>, <code class="function">truncate_cb</code>, <code class="function">message_cb</code>, <code class="function">filter_by_origin_cb</code> и <code class="function">shutdown_cb</code> могут отсутствовать. Если <code class="function">truncate_cb</code> не установлен, но потребуется декодировать операцию <code class="command">TRUNCATE</code>, она будет проигнорирована.</p><p>Модуль вывода может также определять функции для поддержки потоковой передачи больших транзакций во время их выполнения. Функции <code class="function">stream_start_cb</code>, <code class="function">stream_stop_cb</code>, <code class="function">stream_abort_cb</code>, <code class="function">stream_commit_cb</code> и <code class="function">stream_change_cb</code> являются обязательными, а <code class="function">stream_message_cb</code> и <code class="function">stream_truncate_cb</code> — необязательными. Функция <code class="function">stream_prepare_cb</code> также является обязательной, если модуль вывода поддерживает двухфазную фиксацию.</p><p>Модуль вывода также может определять функции для поддержки двухфазной фиксации, позволяющие декодировать действия в <code class="command">PREPARE TRANSACTION</code>. Обработчики <code class="function">begin_prepare_cb</code>, <code class="function">prepare_cb</code>, <code class="function">commit_prepared_cb</code> и <code class="function">rollback_prepared_cb</code> являются обязательными, а <code class="function">filter_prepare_cb</code> — нет. Обработчик <code class="function">stream_prepare_cb</code> также является обязательным, если модуль вывода поддерживает потоковую передачу больших выполняющихся транзакций.</p></div><div class="sect2" id="LOGICALDECODING-CAPABILITIES"><div class="titlepage"><div><div><h3 class="title">49.6.2. Возможности <a href="#LOGICALDECODING-CAPABILITIES" class="id_link">#</a></h3></div></div></div><p>Для декодирования, форматирования и вывода изменений модули вывода могут использовать практически всю обычную инфраструктуру сервера, включая вызов функций вывода типов. К отношениям разрешается доступ только на чтение, если только эти отношения были созданы программой <code class="command">initdb</code> в схеме <code class="literal">pg_catalog</code>, либо помечены как пользовательские таблицы каталогов командами </p><pre class="programlisting">ALTER TABLE user_catalog_table SET (user_catalog_table = true);
CREATE TABLE another_catalog_table(data text) WITH (user_catalog_table = true);</pre><p> Обратите внимание, что доступ к пользовательским таблицам каталога или обычным системным таблицам каталога в подключаемых модулях вывода должен осуществляться только с использованием функций сканирования <code class="literal">systable_*</code>. При попытке использовать функции сканирования <code class="literal">heap_*</code> произойдёт ошибка. Кроме того, любые действия, которые требуют присваивания идентификатора транзакции, запрещаются. В частности, к этим действиям относятся операции записи в таблицы, изменения DDL и вызов <code class="literal">pg_current_xact_id()</code>.</p></div><div class="sect2" id="LOGICALDECODING-OUTPUT-MODE"><div class="titlepage"><div><div><h3 class="title">49.6.3. Режимы вывода <a href="#LOGICALDECODING-OUTPUT-MODE" class="id_link">#</a></h3></div></div></div><p>Обработчики в модуле вывода могут передавать данные потребителю в практически любых форматах. Для некоторых вариантов использования, например, просмотра изменений через SQL, вывод информации в типах, которые могут содержать произвольные данные (например, <code class="type">bytea</code>), может быть неудобоваримым. Если модуль вывода выводит только текстовые данные в кодировке сервера, он может объявить это, установив в <code class="literal">OutputPluginOptions.output_type</code> значение <code class="literal">OUTPUT_PLUGIN_TEXTUAL_OUTPUT</code> вместо <code class="literal">OUTPUT_PLUGIN_BINARY_OUTPUT</code> в <a class="link" href="logicaldecoding-output-plugin.html#LOGICALDECODING-OUTPUT-PLUGIN-STARTUP" title="49.6.4.1. Обработчик запуска">обработчике запуска</a>. В этом случае все данные должны быть в кодировке сервера, чтобы их можно было передать в значении типа <code class="type">text</code>. Это контролируется в сборках с включёнными проверочными утверждениями.</p></div><div class="sect2" id="LOGICALDECODING-OUTPUT-PLUGIN-CALLBACKS"><div class="titlepage"><div><div><h3 class="title">49.6.4. Обработчики в модуле вывода <a href="#LOGICALDECODING-OUTPUT-PLUGIN-CALLBACKS" class="id_link">#</a></h3></div></div></div><p>Модуль вывода уведомляется о происходящих изменениях через различные обработчики, которые он должен установить.</p><p>Параллельные транзакции декодируются в порядке фиксации, при этом между обратными вызовами <code class="literal">begin</code> и <code class="literal">commit</code> декодируются только изменения, относящиеся к определённой транзакции. Явно или неявно отменённые транзакции никогда не декодируются. Успешные точки сохранения включаются в содержащую их транзакцию в том порядке, в котором они выполнялись в этой транзакции. Транзакция, подготовленная для двухфазной фиксации командой <code class="command">PREPARE TRANSACTION</code>, также будет декодирована, если модуль вывода предоставил требуемые обработчики для декодирования. Возможно, что текущая подготовленная декодируемая транзакция будет прервана параллельно выполненной командой <code class="command">ROLLBACK PREPARED</code>. В этом случае будет прервано и логическое декодирование этой транзакции. Все изменения такой транзакции пропускаются после обнаружения прерывания и вызова обработчика <code class="function">prepare_cb</code>. Таким образом даже при блокирующем прерывании модулю вывода предоставляется достаточно информации, чтобы он мог правильно обработать <code class="command">ROLLBACK PREPARED</code> после декодирования.</p><div class="note"><h3 class="title">Примечание</h3><p>Декодироваться будут только те транзакции, которые уже успешно сброшены на диск. Вследствие этого, <code class="command">COMMIT</code> может не декодироваться в следующем сразу за ним вызове <code class="literal">pg_logical_slot_get_changes()</code>, когда <code class="varname">synchronous_commit</code> имеет значение <code class="literal">off</code>.</p></div><div class="sect3" id="LOGICALDECODING-OUTPUT-PLUGIN-STARTUP"><div class="titlepage"><div><div><h4 class="title">49.6.4.1. Обработчик запуска <a href="#LOGICALDECODING-OUTPUT-PLUGIN-STARTUP" class="id_link">#</a></h4></div></div></div><p>Необязательный обработчик <code class="function">startup_cb</code> вызывается, когда слот репликации создаётся или через него запрашивается передача изменений, независимо от того, в каком количестве изменения готовы к передаче. </p><pre class="programlisting">typedef void (*LogicalDecodeStartupCB) (struct LogicalDecodingContext *ctx,
                                        OutputPluginOptions *options,
                                        bool is_init);</pre><p> Параметр <code class="literal">is_init</code> будет равен true, когда слот репликации создаётся, и false в противном случае. Параметр <em class="parameter"><code>options</code></em> указывает на структуру параметров, которые могут устанавливать модули вывода: </p><pre class="programlisting">typedef struct OutputPluginOptions
{
    OutputPluginOutputType output_type;
    bool        receive_rewrites;
} OutputPluginOptions;</pre><p> В поле <code class="literal">output_type</code> должно быть значение <code class="literal">OUTPUT_PLUGIN_TEXTUAL_OUTPUT</code> или <code class="literal">OUTPUT_PLUGIN_BINARY_OUTPUT</code>. См. также <a class="xref" href="logicaldecoding-output-plugin.html#LOGICALDECODING-OUTPUT-MODE" title="49.6.3. Режимы вывода">Подраздел 49.6.3</a>. Если поле <code class="literal">receive_rewrites</code> равно true, модуль вывода также будет вызываться для изменений, связанных с перезаписью кучи при определённых операциях DDL. Эти изменения представляют интерес для модулей, осуществляющих репликацию DDL, но для их обработки может потребоваться особый подход.</p><p>Обработчик запуска должен проверить параметры, представленные в <code class="literal">ctx-&gt;output_plugin_options</code>. Если модулю вывода требуется поддерживать состояние, он может сохранить его в <code class="literal">ctx-&gt;output_plugin_private</code>.</p></div><div class="sect3" id="LOGICALDECODING-OUTPUT-PLUGIN-SHUTDOWN"><div class="titlepage"><div><div><h4 class="title">49.6.4.2. Обработчик выключения <a href="#LOGICALDECODING-OUTPUT-PLUGIN-SHUTDOWN" class="id_link">#</a></h4></div></div></div><p>Необязательный обработчик <code class="function">shutdown_cb</code> вызывается, когда ранее активный слот репликации перестаёт использоваться, так что ресурсы, занятые модулем вывода, можно освободить. При этом слот не обязательно удаляется, прекращается только потоковая передача через него. </p><pre class="programlisting">typedef void (*LogicalDecodeShutdownCB) (struct LogicalDecodingContext *ctx);</pre></div><div class="sect3" id="LOGICALDECODING-OUTPUT-PLUGIN-BEGIN"><div class="titlepage"><div><div><h4 class="title">49.6.4.3. Обработчик начала транзакции <a href="#LOGICALDECODING-OUTPUT-PLUGIN-BEGIN" class="id_link">#</a></h4></div></div></div><p>Обязательный обработчик <code class="function">begin_cb</code> вызывается, когда декодируется начало зафиксированной транзакции. Прерванные транзакции и их содержимое никогда не декодируется. </p><pre class="programlisting">typedef void (*LogicalDecodeBeginCB) (struct LogicalDecodingContext *ctx,
                                      ReorderBufferTXN *txn);</pre><p> Параметр <em class="parameter"><code>txn</code></em> содержит метаинформацию о транзакции, в частности её идентификатор и время её фиксирования.</p></div><div class="sect3" id="LOGICALDECODING-OUTPUT-PLUGIN-COMMIT"><div class="titlepage"><div><div><h4 class="title">49.6.4.4. Обработчик завершения транзакции <a href="#LOGICALDECODING-OUTPUT-PLUGIN-COMMIT" class="id_link">#</a></h4></div></div></div><p>Обязательный обработчик <code class="function">commit_cb</code> вызывается, когда декодируется фиксирование транзакции. Перед этим обработчиком будет вызываться обработчик <code class="function">change_cb</code> для всех изменённых строк (если строки были изменены). </p><pre class="programlisting">typedef void (*LogicalDecodeCommitCB) (struct LogicalDecodingContext *ctx,
                                       ReorderBufferTXN *txn,
                                       XLogRecPtr commit_lsn);</pre></div><div class="sect3" id="LOGICALDECODING-OUTPUT-PLUGIN-CHANGE"><div class="titlepage"><div><div><h4 class="title">49.6.4.5. Обработчик изменения <a href="#LOGICALDECODING-OUTPUT-PLUGIN-CHANGE" class="id_link">#</a></h4></div></div></div><p>Обязательный обработчик <code class="function">change_cb</code> вызывается для каждого отдельного изменения строки в транзакции, производимого командами <code class="command">INSERT</code>, <code class="command">UPDATE</code> или <code class="command">DELETE</code>. Даже если команда изменила несколько строк сразу, этот обработчик будет вызываться для каждой отдельной строки. Обработчик <code class="function">change_cb</code> может обращаться к системным или пользовательским таблицам каталога, чтобы дополнить выводимую информацию об изменении строки. В случае декодирования подготовленной (но ещё не зафиксированной) транзакции или декодирования незафиксированной транзакции этот обработчик изменений также может выдать ошибку из-за одновременного отката той же самой транзакции. В этом случае логическое декодирование этой прерванной транзакции корректно останавливается. </p><pre class="programlisting">typedef void (*LogicalDecodeChangeCB) (struct LogicalDecodingContext *ctx,
                                       ReorderBufferTXN *txn,
                                       Relation relation,
                                       ReorderBufferChange *change);</pre><p> Параметры <em class="parameter"><code>ctx</code></em> и <em class="parameter"><code>txn</code></em> имеют то же содержимое, что и для обработчиков <code class="function">begin_cb</code> и <code class="function">commit_cb</code>; дополнительный дескриптор отношения <em class="parameter"><code>relation</code></em> указывает на отношение, к которому принадлежит строка, а структура <em class="parameter"><code>change</code></em> описывает передаваемое изменение строки.</p><div class="note"><h3 class="title">Примечание</h3><p>В процессе логического декодирования могут быть обработаны изменения только в таблицах, не являющихся нежурналируемыми (см. описание <a class="xref" href="sql-createtable.html#SQL-CREATETABLE-UNLOGGED"><code class="literal">UNLOGGED</code></a>) или временными (см. описание <a class="xref" href="sql-createtable.html#SQL-CREATETABLE-TEMPORARY"><code class="literal">TEMPORARY</code> или <code class="literal">TEMP</code></a>).</p></div></div><div class="sect3" id="LOGICALDECODING-OUTPUT-PLUGIN-TRUNCATE"><div class="titlepage"><div><div><h4 class="title">49.6.4.6. Обработчик опустошения <a href="#LOGICALDECODING-OUTPUT-PLUGIN-TRUNCATE" class="id_link">#</a></h4></div></div></div><p>Необязательный обработчик <code class="function">truncate_cb</code> вызывается для команды <code class="command">TRUNCATE</code>. </p><pre class="programlisting">typedef void (*LogicalDecodeTruncateCB) (struct LogicalDecodingContext *ctx,
                                         ReorderBufferTXN *txn,
                                         int nrelations,
                                         Relation relations[],
                                         ReorderBufferChange *change);</pre><p> Он получает те же параметры, что и <code class="function">change_cb</code>. Но так как операции <code class="command">TRUNCATE</code> в таблицах, связанных внешними ключами, должны выполняться одновременно, данный обработчик получает на вход не одно отношение, а массив отношений. За подробностями обратитесь к описанию оператора <a class="xref" href="sql-truncate.html" title="TRUNCATE"><span class="refentrytitle">TRUNCATE</span></a>.</p></div><div class="sect3" id="LOGICALDECODING-OUTPUT-PLUGIN-FILTER-ORIGIN"><div class="titlepage"><div><div><h4 class="title">49.6.4.7. Обработчик фильтрации источника <a href="#LOGICALDECODING-OUTPUT-PLUGIN-FILTER-ORIGIN" class="id_link">#</a></h4></div></div></div><p>Необязательный обработчик <code class="function">filter_by_origin_cb</code> вызывается, чтобы отметить, интересуют ли модуль вывода изменения, воспроизводимые из указанного источника (<em class="parameter"><code>origin_id</code></em>). </p><pre class="programlisting">typedef bool (*LogicalDecodeFilterByOriginCB) (struct LogicalDecodingContext *ctx,
                                               RepOriginId origin_id);</pre><p> В параметре <em class="parameter"><code>ctx</code></em> передаётся та же информация, что и для других обработчиков. Чтобы отметить, что изменения, поступающие из переданного узла, не представляют интереса, модуль должен вернуть true, вследствие чего эти изменения будут фильтроваться; в противном случае он должен вернуть false. Другие обработчики для фильтруемых транзакций и изменений вызываться не будут.</p><p>Это полезно при реализации каскадной или разнонаправленной репликации. Фильтрация по источнику в таких конфигурациях позволяет предотвратить передачу взад-вперёд одних и тех же изменений. Хотя информацию об источнике можно также извлечь из транзакций и изменений, фильтрация с помощью этого обработчика гораздо более эффективна.</p></div><div class="sect3" id="LOGICALDECODING-OUTPUT-PLUGIN-MESSAGE"><div class="titlepage"><div><div><h4 class="title">49.6.4.8. Обработчик произвольных сообщений <a href="#LOGICALDECODING-OUTPUT-PLUGIN-MESSAGE" class="id_link">#</a></h4></div></div></div><p>Необязательный обработчик <code class="function">message_cb</code> вызывается при получении сообщения логического декодирования. </p><pre class="programlisting">typedef void (*LogicalDecodeMessageCB) (struct LogicalDecodingContext *ctx,
                                        ReorderBufferTXN *txn,
                                        XLogRecPtr message_lsn,
                                        bool transactional,
                                        const char *prefix,
                                        Size message_size,
                                        const char *message);</pre><p> Параметр <em class="parameter"><code>txn</code></em> содержит метаинформацию о транзакции, включая время её фиксации и её XID. Заметьте, однако, что в нём может передаваться NULL, когда сообщение нетранзакционное и транзакции, в которой было выдано сообщение, ещё не назначен XID. В параметре <em class="parameter"><code>lsn</code></em> отмечается позиция сообщения в WAL. Параметр <em class="parameter"><code>transactional</code></em> показывает, было ли сообщение передано как транзакционное. Подобно обработчику изменений, в случае декодирования подготовленной (но ещё не зафиксированной) транзакции или декодирования незафиксированной транзакции этот обработчик также может выдать ошибку из-за одновременного отката той же самой транзакции. В этом случае логическое декодирование этой прерванной транзакции корректно останавливается. В параметре <em class="parameter"><code>prefix</code></em> передаётся некоторый префикс (завершающийся нулём), по которому текущий модуль может выделять интересующие его сообщения. И наконец, параметр <em class="parameter"><code>message</code></em> содержит само сообщение размером <em class="parameter"><code>message_size</code></em> байт.</p><p>Необходимо дополнительно позаботиться о том, чтобы префикс, определяющий интересующие модуль вывода сообщения, был уникальным. Удачным выбором обычно будет имя расширения или самого модуля вывода.</p></div><div class="sect3" id="LOGICALDECODING-OUTPUT-PLUGIN-FILTER-PREPARE"><div class="titlepage"><div><div><h4 class="title">49.6.4.9. Обработчик фильтра подготовки <a href="#LOGICALDECODING-OUTPUT-PLUGIN-FILTER-PREPARE" class="id_link">#</a></h4></div></div></div><p>Необязательный обработчик <code class="function">filter_prepare_cb</code> вызывается, чтобы определить, следует ли декодировать данные, составляющие текущую фиксируемую двухфазную транзакцию, на этапе подготовки или позже — в виде обычной однофазной транзакции на этапе <code class="command">COMMIT PREPARED</code>. Если декодирование следует пропустить, обработчик должен выдать <code class="literal">true</code>, а иначе — <code class="literal">false</code>. Если обработчик не определён, предполагается <code class="literal">false</code> (т. е. фильтрация отсутствует — все транзакции, использующие двухфазную фиксацию, декодируются также в две фазы). </p><pre class="programlisting">typedef bool (*LogicalDecodeFilterPrepareCB) (struct LogicalDecodingContext *ctx,
                                              TransactionId xid,
                                              const char *gid);</pre><p> Параметр <em class="parameter"><code>ctx</code></em> имеет то же содержимое, что и в других обработчиках. Параметры <em class="parameter"><code>xid</code></em> и <em class="parameter"><code>gid</code></em> предоставляют два разных способа идентификации транзакции. Последующая команда <code class="command">COMMIT PREPARED</code> или <code class="command">ROLLBACK PREPARED</code> передаёт оба идентификатора, предоставляя модулю вывода возможность выбора, какой использовать.</p><p>Обработчик может вызываться несколько раз в течение одной декодируемой транзакции и должен выдавать один и тот же постоянный ответ для данной пары <em class="parameter"><code>xid</code></em> и <em class="parameter"><code>gid</code></em> при каждом вызове.</p></div><div class="sect3" id="LOGICALDECODING-OUTPUT-PLUGIN-BEGIN-PREPARE"><div class="titlepage"><div><div><h4 class="title">49.6.4.10. Обработчик начала подготовленной транзакции <a href="#LOGICALDECODING-OUTPUT-PLUGIN-BEGIN-PREPARE" class="id_link">#</a></h4></div></div></div><p>Обязательный обработчик <code class="function">begin_prepare_cb</code> вызывается при декодировании начала подготовленной транзакции. Переданное в параметре <em class="parameter"><code>txn</code></em> поле <em class="parameter"><code>gid</code></em> позволяет обработчику определить, получал ли этот модуль уже данную команду <code class="command">PREPARE</code>, — если да, он может либо выдать ошибку, либо пропустить оставшиеся изменения транзакции. </p><pre class="programlisting">typedef void (*LogicalDecodeBeginPrepareCB) (struct LogicalDecodingContext *ctx,
                                             ReorderBufferTXN *txn);</pre></div><div class="sect3" id="LOGICALDECODING-OUTPUT-PLUGIN-PREPARE"><div class="titlepage"><div><div><h4 class="title">49.6.4.11. Обработчик подготовки транзакции <a href="#LOGICALDECODING-OUTPUT-PLUGIN-PREPARE" class="id_link">#</a></h4></div></div></div><p>Обязательный обработчик <code class="function">prepare_cb</code> вызывается при декодировании транзакции, подготовленной для двухфазной фиксации. Перед этим обработчиком будет вызываться обработчик <code class="function">change_cb</code> для всех изменённых строк (если строки были изменены). В этом обработчике может использоваться поле <em class="parameter"><code>gid</code></em>, являющееся частью параметра <em class="parameter"><code>txn</code></em>. </p><pre class="programlisting">typedef void (*LogicalDecodePrepareCB) (struct LogicalDecodingContext *ctx,
                                        ReorderBufferTXN *txn,
                                        XLogRecPtr prepare_lsn);</pre></div><div class="sect3" id="LOGICALDECODING-OUTPUT-PLUGIN-COMMIT-PREPARED"><div class="titlepage"><div><div><h4 class="title">49.6.4.12. Обработчик фиксации подготовленной транзакции <a href="#LOGICALDECODING-OUTPUT-PLUGIN-COMMIT-PREPARED" class="id_link">#</a></h4></div></div></div><p>Обязательный обработчик <code class="function">commit_prepared_cb</code> вызывается при декодировании команды <code class="command">COMMIT PREPARED</code> транзакции. В этом обработчике может использоваться поле <em class="parameter"><code>gid</code></em>, являющееся частью параметра <em class="parameter"><code>txn</code></em>. </p><pre class="programlisting">typedef void (*LogicalDecodeCommitPreparedCB) (struct LogicalDecodingContext *ctx,
                                               ReorderBufferTXN *txn,
                                               XLogRecPtr commit_lsn);</pre></div><div class="sect3" id="LOGICALDECODING-OUTPUT-PLUGIN-ROLLBACK-PREPARED"><div class="titlepage"><div><div><h4 class="title">49.6.4.13. Обработчик отмены подготовленной транзакции <a href="#LOGICALDECODING-OUTPUT-PLUGIN-ROLLBACK-PREPARED" class="id_link">#</a></h4></div></div></div><p>Обязательный обработчик <code class="function">rollback_prepared_cb</code> вызывается при декодировании команды <code class="command">ROLLBACK PREPARED</code> транзакции. В этом обработчике может использоваться поле <em class="parameter"><code>gid</code></em>, которое является частью параметра <em class="parameter"><code>txn</code></em>. Проанализировав параметры <em class="parameter"><code>prepare_end_lsn</code></em> и <em class="parameter"><code>prepare_time</code></em>, модуль декодирования может определить, получал ли он <code class="command">PREPARE TRANSACTION</code>, и если да — выполнить отмену транзакции, а в противном случае пропустить эту операцию. Одного поля <em class="parameter"><code>gid</code></em> для этого недостаточно, так как на нижестоящем узле может быть подготовленная транзакция с таким же строковым идентификатором. </p><pre class="programlisting">typedef void (*LogicalDecodeRollbackPreparedCB) (struct LogicalDecodingContext *ctx,
                                                 ReorderBufferTXN *txn,
                                                 XLogRecPtr prepare_end_lsn,
                                                 TimestampTz prepare_time);</pre></div><div class="sect3" id="LOGICALDECODING-OUTPUT-PLUGIN-STREAM-START"><div class="titlepage"><div><div><h4 class="title">49.6.4.14. Обработчик начала потока <a href="#LOGICALDECODING-OUTPUT-PLUGIN-STREAM-START" class="id_link">#</a></h4></div></div></div><p>Обязательный обработчик <code class="function">stream_start_cb</code> вызывается, когда открывается блок передаваемых в потоке изменений выполняющейся транзакции. </p><pre class="programlisting">typedef void (*LogicalDecodeStreamStartCB) (struct LogicalDecodingContext *ctx,
                                            ReorderBufferTXN *txn);</pre></div><div class="sect3" id="LOGICALDECODING-OUTPUT-PLUGIN-STREAM-STOP"><div class="titlepage"><div><div><h4 class="title">49.6.4.15. Обработчик остановки потока <a href="#LOGICALDECODING-OUTPUT-PLUGIN-STREAM-STOP" class="id_link">#</a></h4></div></div></div><p>Обязательный обработчик <code class="function">stream_stop_cb</code> вызывается, когда закрывается блок передаваемых в потоке изменений выполняющейся транзакции. </p><pre class="programlisting">typedef void (*LogicalDecodeStreamStopCB) (struct LogicalDecodingContext *ctx,
                                           ReorderBufferTXN *txn);</pre></div><div class="sect3" id="LOGICALDECODING-OUTPUT-PLUGIN-STREAM-ABORT"><div class="titlepage"><div><div><h4 class="title">49.6.4.16. Обработчик прерывания потока <a href="#LOGICALDECODING-OUTPUT-PLUGIN-STREAM-ABORT" class="id_link">#</a></h4></div></div></div><p>Обязательный обработчик <code class="function">stream_abort_cb</code> вызывается для прерывания передаваемой в потоке транзакции. </p><pre class="programlisting">typedef void (*LogicalDecodeStreamAbortCB) (struct LogicalDecodingContext *ctx,
                                            ReorderBufferTXN *txn,
                                            XLogRecPtr abort_lsn);</pre></div><div class="sect3" id="LOGICALDECODING-OUTPUT-PLUGIN-STREAM-PREPARE"><div class="titlepage"><div><div><h4 class="title">49.6.4.17. Обработчик подготовки потока <a href="#LOGICALDECODING-OUTPUT-PLUGIN-STREAM-PREPARE" class="id_link">#</a></h4></div></div></div><p>Обработчик <code class="function">stream_prepare_cb</code> вызывается для подготовки ранее переданной в потоке транзакции как части двухфазной фиксации. Этот обработчик требуется, когда плагин вывода поддерживает как потоковую передачу больших текущих транзакций, так и двухфазные фиксации. </p><pre class="programlisting">typedef void (*LogicalDecodeStreamPrepareCB) (struct LogicalDecodingContext *ctx,
                                              ReorderBufferTXN *txn,
                                              XLogRecPtr prepare_lsn);</pre></div><div class="sect3" id="LOGICALDECODING-OUTPUT-PLUGIN-STREAM-COMMIT"><div class="titlepage"><div><div><h4 class="title">49.6.4.18. Обработчик фиксации потока <a href="#LOGICALDECODING-OUTPUT-PLUGIN-STREAM-COMMIT" class="id_link">#</a></h4></div></div></div><p>Обязательный обработчик <code class="function">stream_commit_cb</code> вызывается для фиксации ранее переданной в потоке транзакции. </p><pre class="programlisting">typedef void (*LogicalDecodeStreamCommitCB) (struct LogicalDecodingContext *ctx,
                                             ReorderBufferTXN *txn,
                                             XLogRecPtr commit_lsn);</pre></div><div class="sect3" id="LOGICALDECODING-OUTPUT-PLUGIN-STREAM-CHANGE"><div class="titlepage"><div><div><h4 class="title">49.6.4.19. Обработчик изменений в потоке <a href="#LOGICALDECODING-OUTPUT-PLUGIN-STREAM-CHANGE" class="id_link">#</a></h4></div></div></div><p>Обязательный обработчик <code class="function">stream_change_cb</code> вызывается, когда передаётся изменение в блоке изменений (границы которого обозначают вызовы <code class="function">stream_start_cb</code> и <code class="function">stream_stop_cb</code>). Фактические изменения не отображаются, поскольку транзакция может быть прервана позже, а изменения для прерванных транзакций не декодируются. </p><pre class="programlisting">typedef void (*LogicalDecodeStreamChangeCB) (struct LogicalDecodingContext *ctx,
                                             ReorderBufferTXN *txn,
                                             Relation relation,
                                             ReorderBufferChange *change);</pre></div><div class="sect3" id="LOGICALDECODING-OUTPUT-PLUGIN-STREAM-MESSAGE"><div class="titlepage"><div><div><h4 class="title">49.6.4.20. Обработчик сообщения потока <a href="#LOGICALDECODING-OUTPUT-PLUGIN-STREAM-MESSAGE" class="id_link">#</a></h4></div></div></div><p>Необязательный обработчик <code class="function">stream_message_cb</code> вызывается, когда передаётся произвольное сообщение в блоке изменений (границы которого обозначают вызовы <code class="function">stream_start_cb</code> и <code class="function">stream_stop_cb</code>). Содержимое транзакционных сообщений не отображается, поскольку транзакция может быть прервана позже, а изменения для прерванных транзакций не декодируются. </p><pre class="programlisting">typedef void (*LogicalDecodeStreamMessageCB) (struct LogicalDecodingContext *ctx,
                                              ReorderBufferTXN *txn,
                                              XLogRecPtr message_lsn,
                                              bool transactional,
                                              const char *prefix,
                                              Size message_size,
                                              const char *message);</pre></div><div class="sect3" id="LOGICALDECODING-OUTPUT-PLUGIN-STREAM-TRUNCATE"><div class="titlepage"><div><div><h4 class="title">49.6.4.21. Обработчик команды опустошения в потоке <a href="#LOGICALDECODING-OUTPUT-PLUGIN-STREAM-TRUNCATE" class="id_link">#</a></h4></div></div></div><p>Необязательный обработчик <code class="function">truncate_cb</code> вызывается для команды <code class="command">TRUNCATE</code> в блоке изменений (границы которого обозначают вызовы <code class="function">stream_start_cb</code> и <code class="function">stream_stop_cb</code>). </p><pre class="programlisting">typedef void (*LogicalDecodeStreamTruncateCB) (struct LogicalDecodingContext *ctx,
                                               ReorderBufferTXN *txn,
                                               int nrelations,
                                               Relation relations[],
                                               ReorderBufferChange *change);</pre><p> Параметры этого обработчика аналогичны параметрам <code class="function">change_cb</code>. Но так как операции <code class="command">TRUNCATE</code> в таблицах, связанных внешними ключами, должны выполняться одновременно, данный обработчик получает на вход не одно отношение, а массив отношений. За подробностями обратитесь к описанию оператора <a class="xref" href="sql-truncate.html" title="TRUNCATE"><span class="refentrytitle">TRUNCATE</span></a>.</p></div></div><div class="sect2" id="LOGICALDECODING-OUTPUT-PLUGIN-OUTPUT"><div class="titlepage"><div><div><h3 class="title">49.6.5. Функции для формирования вывода <a href="#LOGICALDECODING-OUTPUT-PLUGIN-OUTPUT" class="id_link">#</a></h3></div></div></div><p>Чтобы действительно вывести данные, модули вывода могут записывать их в буфер <code class="literal">StringInfo</code> через <code class="literal">ctx-&gt;out</code>, внутри обработчиков <code class="function">begin_cb</code>, <code class="function">commit_cb</code> или <code class="function">change_cb</code>. Прежде чем записывать данные в этот буфер, необходимо вызвать <code class="function">OutputPluginPrepareWrite(ctx, last_write)</code>, а завершив запись в буфер, нужно вызвать <code class="function">OutputPluginWrite(ctx, last_write)</code>, чтобы собственно произвести запись. Параметр <em class="parameter"><code>last_write</code></em> указывает, была ли эта определённая операция записи последней в данном обработчике.</p><p>Следующий пример показывает, как вывести данные для потребителя модуля вывода: </p><pre class="programlisting">OutputPluginPrepareWrite(ctx, true);
appendStringInfo(ctx-&gt;out, "BEGIN %u", txn-&gt;xid);
OutputPluginWrite(ctx, true);</pre></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="logicaldecoding-catalogs.html" title="49.5. Системные каталоги, связанные с логическим декодированием">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="logicaldecoding.html" title="Глава 49. Логическое декодирование">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="logicaldecoding-writer.html" title="49.7. Запись вывода логического декодирования">След.</a></td></tr><tr><td width="40%" align="left" valign="top">49.5. Системные каталоги, связанные с логическим декодированием </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 49.7. Запись вывода логического декодирования</td></tr></table></div></body></html>