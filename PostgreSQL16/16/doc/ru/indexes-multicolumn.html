<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>11.3. Составные индексы</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="indexes-types.html" title="11.2. Типы индексов" /><link rel="next" href="indexes-ordering.html" title="11.4. Индексы и предложения ORDER BY" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">11.3. Составные индексы</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="indexes-types.html" title="11.2. Типы индексов">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="indexes.html" title="Глава 11. Индексы">Наверх</a></td><th width="60%" align="center">Глава 11. Индексы</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="indexes-ordering.html" title="11.4. Индексы и предложения ORDER BY">След.</a></td></tr></table><hr /></div><div class="sect1" id="INDEXES-MULTICOLUMN"><div class="titlepage"><div><div><h2 class="title" style="clear: both">11.3. Составные индексы <a href="#INDEXES-MULTICOLUMN" class="id_link">#</a></h2></div></div></div><a id="id-1.5.10.6.2" class="indexterm"></a><p>Индексы можно создавать и по нескольким столбцам таблицы. Например, если у вас есть таблица: </p><pre class="programlisting">CREATE TABLE test2 (
  major int,
  minor int,
  name varchar
);</pre><p> (предположим, что вы поместили в неё содержимое каталога <code class="filename">/dev</code>) и вы часто выполняете запросы вида: </p><pre class="programlisting">SELECT name FROM test2 WHERE major = <em class="replaceable"><code>константа</code></em> AND minor = <em class="replaceable"><code>константа</code></em>;</pre><p> тогда имеет смысл определить индекс, покрывающий оба столбца <code class="structfield">major</code> и <code class="structfield">minor</code>. Например: </p><pre class="programlisting">CREATE INDEX test2_mm_idx ON test2 (major, minor);</pre><p>В настоящее время составными могут быть только индексы типов B-дерево, GiST, GIN и BRIN. Возможность построения индекса по нескольким ключевым столбцам не зависит от возможности добавления в индекс неключевых столбцов (<code class="literal">INCLUDE</code>). Число столбцов в индексе ограничивается 32, включая столбцы <code class="literal">INCLUDE</code>. (Этот предел можно изменить при компиляции <span class="productname">PostgreSQL</span>; см. файл <code class="filename">pg_config_manual.h</code>.)</p><p>Составной индекс-B-дерево может применяться в условиях с любым подмножеством столбцов индекса, но наиболее эффективен он при ограничениях по ведущим (левым) столбцам. Точное правило состоит в том, что сканируемая область индекса определяется условиями равенства с ведущими столбцами и условиями неравенства с первым столбцом, не участвующим в условии равенства. Ограничения столбцов правее них также проверяются по индексу, так что обращение к таблице откладывается, но на размер сканируемой области индекса это уже не влияет. Например, если есть индекс по столбцам <code class="literal">(a, b, c)</code> и условие <code class="literal">WHERE a = 5 AND b &gt;= 42 AND c &lt; 77</code>, индекс будет сканироваться от первой записи <code class="literal">a</code> = 5 и <code class="literal">b</code> = 42 до последней с <code class="literal">a</code> = 5. Записи индекса, в которых <code class="literal">c</code> &gt;= 77, не будут учитываться, но тем не менее будут просканированы. Этот индекс в принципе может использоваться в запросах с ограничениями по <code class="literal">b</code> и/или <code class="literal">c</code>, без ограничений столбца <code class="literal">a</code>, но при этом будет просканирован весь индекс, так что в большинстве случаев планировщик предпочтёт использованию индекса полное сканирование таблицы.</p><p>Составной индекс GiST может применяться в условиях с любым подмножеством столбцов индекса. Условия с дополнительными столбцами ограничивают записи, возвращаемые индексом, но в первую очередь сканируемая область индекса определяется ограничением первого столбца. GiST-индекс будет относительно малоэффективен, когда первый его столбец содержит только несколько различающихся значений, даже если дополнительные столбцы дают множество различных значений.</p><p>Составной индекс GIN может применяться в условиях с любым подмножеством столбцов индекса. В отличие от индексов GiST или B-деревьев, эффективность поиска по нему не меняется в зависимости от того, какие из его столбцов используются в условиях запроса.</p><p>Составной индекс BRIN может применяться в условиях запроса с любым подмножеством столбцов индекса. Подобно индексу GIN и в отличие от B-деревьев или GiST, эффективность поиска по нему не меняется в зависимости от того, какие из его столбцов используются в условиях запроса. Единственное, зачем в одной таблице могут потребоваться несколько индексов BRIN вместо одного составного индекса — это затем, чтобы применялись разные параметры хранения <code class="literal">pages_per_range</code>.</p><p>При этом, разумеется, каждый столбец должен использоваться с операторами, соответствующими типу индекса; ограничения с другими операторами рассматриваться не будут.</p><p>Составные индексы следует использовать обдуманно. В большинстве случаев индекс по одному столбцу будет работать достаточно хорошо и сэкономит время и место. Индексы по более чем трём столбцам вряд ли будут полезными, если только таблица не используется крайне однообразно. Описание достоинств различных конфигураций индексов можно найти в <a class="xref" href="indexes-bitmap-scans.html" title="11.5. Объединение нескольких индексов">Разделе 11.5</a> и <a class="xref" href="indexes-index-only-scans.html" title="11.9. Сканирование только индекса и покрывающие индексы">Разделе 11.9</a>.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="indexes-types.html" title="11.2. Типы индексов">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="indexes.html" title="Глава 11. Индексы">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="indexes-ordering.html" title="11.4. Индексы и предложения ORDER BY">След.</a></td></tr><tr><td width="40%" align="left" valign="top">11.2. Типы индексов </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 11.4. Индексы и предложения <code class="literal">ORDER BY</code></td></tr></table></div></body></html>