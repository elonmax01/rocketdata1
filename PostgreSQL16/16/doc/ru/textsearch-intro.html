<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>12.1. Введение</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="textsearch.html" title="Глава 12. Полнотекстовый поиск" /><link rel="next" href="textsearch-tables.html" title="12.2. Таблицы и индексы" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">12.1. Введение</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="textsearch.html" title="Глава 12. Полнотекстовый поиск">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="textsearch.html" title="Глава 12. Полнотекстовый поиск">Наверх</a></td><th width="60%" align="center">Глава 12. Полнотекстовый поиск</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="textsearch-tables.html" title="12.2. Таблицы и индексы">След.</a></td></tr></table><hr /></div><div class="sect1" id="TEXTSEARCH-INTRO"><div class="titlepage"><div><div><h2 class="title" style="clear: both">12.1. Введение <a href="#TEXTSEARCH-INTRO" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="textsearch-intro.html#TEXTSEARCH-DOCUMENT">12.1.1. Что такое документ?</a></span></dt><dt><span class="sect2"><a href="textsearch-intro.html#TEXTSEARCH-MATCHING">12.1.2. Простое соответствие текста</a></span></dt><dt><span class="sect2"><a href="textsearch-intro.html#TEXTSEARCH-INTRO-CONFIGURATIONS">12.1.3. Конфигурации</a></span></dt></dl></div><p>Полнотекстовый поиск (или просто <em class="firstterm">поиск текста</em>) — это возможность находить <em class="firstterm">документы</em> на естественном языке, соответствующие <em class="firstterm">запросу</em>, и, возможно, дополнительно сортировать их по релевантности для этого запроса. Наиболее распространённая задача — найти все документы, содержащие <em class="firstterm">слова запроса</em>, и выдать их отсортированными по степени <em class="firstterm">соответствия</em> запросу. Понятия <code class="varname">запроса</code> и <code class="varname">соответствия</code> довольно расплывчаты и зависят от конкретного приложения. В самом простом случае <code class="varname">запросом</code> считается набор слов, а <code class="varname">соответствие</code> определяется частотой слов в документе.</p><p>Операторы текстового поиска существуют в СУБД уже многие годы. В <span class="productname">PostgreSQL</span> для текстовых типов данных есть операторы <code class="literal">~</code>, <code class="literal">~*</code>, <code class="literal">LIKE</code> и <code class="literal">ILIKE</code>, но им не хватает очень важных вещей, которые требуются сегодня от информационных систем:</p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p>Нет поддержки лингвистического функционала, даже для английского языка. Возможности регулярных выражений ограничены — они не рассчитаны на работу со словоформами, например, <code class="literal">подходят</code> и <code class="literal">подходить</code>. С ними вы можете пропустить документы, которые содержат <code class="literal">подходят</code>, но, вероятно, и они представляют интерес при поиске по ключевому слову <code class="literal">подходить</code>. Конечно, можно попытаться перечислить в регулярном выражении все варианты слова, но это будет очень трудоёмко и чревато ошибками (некоторые слова могут иметь десятки словоформ).</p></li><li class="listitem" style="list-style-type: disc"><p>Они не позволяют упорядочивать результаты поиска (по релевантности), а без этого поиск неэффективен, когда находятся сотни подходящих документов.</p></li><li class="listitem" style="list-style-type: disc"><p>Они обычно выполняются медленно из-за отсутствия индексов, так как при каждом поиске приходится просматривать все документы.</p></li></ul></div><p>Полнотекстовая индексация заключается в <span class="emphasis"><em>предварительной обработке</em></span> документов и сохранении индекса для последующего быстрого поиска. Предварительная обработка включает следующие операции:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: none; "><li class="listitem" style="list-style-type: none"><p><span class="emphasis"><em>Разбор документов на <em class="firstterm">фрагменты</em></em></span>. При этом полезно выделить различные классы фрагментов, например, числа, слова, словосочетания, почтовые адреса и т. д., которые будут обрабатываться по-разному. В принципе классы фрагментов могут зависеть от приложения, но для большинства применений вполне подойдёт предопределённый набор классов. Эту операцию в <span class="productname">PostgreSQL</span> выполняет <em class="firstterm">анализатор</em> (parser). Вы можете использовать как стандартный анализатор, так и создавать свои, узкоспециализированные.</p></li><li class="listitem" style="list-style-type: none"><p><span class="emphasis"><em>Преобразование фрагментов в <em class="firstterm">лексемы</em></em></span>. Лексема — это <em class="firstterm">нормализованный</em> фрагмент, в котором разные словоформы приведены к одной. Например, при нормализации буквы верхнего регистра приводятся к нижнему, а из слов обычно убираются окончания (в частности, <code class="literal">s</code> или <code class="literal">es</code> в английском). Благодаря этому можно находить разные формы одного слова, не вводя вручную все возможные варианты. Кроме того, на данном шаге обычно исключаются <em class="firstterm">стоп-слова</em>, то есть слова, настолько распространённые, что искать их нет смысла. (Другими словами, фрагменты представляют собой просто подстроки текста документа, а лексемы — это слова, имеющие ценность для индексации и поиска.) Для выполнения этого шага в <span class="productname">PostgreSQL</span> используются <em class="firstterm">словари</em>. Набор существующих стандартных словарей при необходимости можно расширять, создавая свои собственные.</p></li><li class="listitem" style="list-style-type: none"><p><span class="emphasis"><em>Хранение документов в форме, подготовленной для поиска</em></span>. Например, каждый документ может быть представлен в виде сортированного массива нормализованных лексем. Помимо лексем часто желательно хранить информацию об их положении для <em class="firstterm">ранжирования по близости</em>, чтобы документ, в котором слова запроса расположены <span class="quote">«<span class="quote">плотнее</span>»</span>, получал более высокий ранг, чем документ с разбросанными словами.</p></li></ul></div><p>Словари позволяют управлять нормализацией фрагментов с большой гибкостью. Создавая словари, можно:</p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p>Определять стоп-слова, которые не будут индексироваться.</p></li><li class="listitem" style="list-style-type: disc"><p>Сопоставлять синонимы с одним словом, используя <span class="application">Ispell</span>.</p></li><li class="listitem" style="list-style-type: disc"><p>Сопоставлять словосочетания с одним словом, используя тезаурус.</p></li><li class="listitem" style="list-style-type: disc"><p>Сопоставлять различные склонения слова с канонической формой, используя словарь <span class="application">Ispell</span>.</p></li><li class="listitem" style="list-style-type: disc"><p>Сопоставлять различные склонения слова с канонической формой, используя стеммер <span class="application">Snowball</span>.</p></li></ul></div><p>Для хранения подготовленных документов в <span class="productname">PostgreSQL</span> предназначен тип данных <code class="type">tsvector</code>, а для представления обработанных запросов — тип <code class="type">tsquery</code> (<a class="xref" href="datatype-textsearch.html" title="8.11. Типы, предназначенные для текстового поиска">Раздел 8.11</a>). С этими типами данных работают целый ряд функций и операторов (<a class="xref" href="functions-textsearch.html" title="9.13. Функции и операторы текстового поиска">Раздел 9.13</a>), и наиболее важный из них — оператор соответствия <code class="literal">@@</code>, с которым мы познакомимся в <a class="xref" href="textsearch-intro.html#TEXTSEARCH-MATCHING" title="12.1.2. Простое соответствие текста">Подразделе 12.1.2</a>. Для ускорения полнотекстового поиска могут применяться индексы (<a class="xref" href="textsearch-indexes.html" title="12.9. Типы индексов, предпочитаемые для текстового поиска">Раздел 12.9</a>).</p><div class="sect2" id="TEXTSEARCH-DOCUMENT"><div class="titlepage"><div><div><h3 class="title">12.1.1. Что такое документ? <a href="#TEXTSEARCH-DOCUMENT" class="id_link">#</a></h3></div></div></div><a id="id-1.5.11.4.10.2" class="indexterm"></a><p><em class="firstterm">Документ</em> — это единица обработки в системе полнотекстового поиска; например, журнальная статья или почтовое сообщение. Система поиска текста должна уметь разбирать документы и сохранять связи лексем (ключевых слов) с содержащим их документом. Впоследствии эти связи могут использоваться для поиска документов с заданными ключевыми словами.</p><p>В контексте поиска в <span class="productname">PostgreSQL</span> документ — это обычно содержимое текстового поля в строке таблицы или, возможно, сочетание (объединение) таких полей, которые могут храниться в разных таблицах или формироваться динамически. Другими словами, документ для индексации может создаваться из нескольких частей и не храниться где-либо как единое целое. Например: </p><pre class="programlisting">SELECT title || ' ' ||  author || ' ' ||  abstract || ' ' || body AS document
FROM messages
WHERE mid = 12;

SELECT m.title || ' ' || m.author || ' ' || m.abstract || ' ' || d.body AS document
FROM messages m, docs d
WHERE m.mid = d.did AND m.mid = 12;</pre><div class="note"><h3 class="title">Примечание</h3><p>На самом деле в этих примерах запросов следует использовать функцию <code class="function">coalesce</code>, чтобы значение <code class="literal">NULL</code> в каком-либо одном атрибуте не привело к тому, что результирующим документом окажется <code class="literal">NULL</code>.</p></div><p>Документы также можно хранить в обычных текстовых файлах в файловой системе. В этом случае база данных может быть просто хранилищем полнотекстового индекса и исполнителем запросов, а найденные документы будут загружаться из файловой системы по некоторым уникальным идентификаторам. Однако для загрузки внешних файлов требуются права суперпользователя или поддержка специальных функций, так что это обычно менее удобно, чем хранить все данные внутри БД <span class="productname">PostgreSQL</span>. Кроме того, когда всё хранится в базе данных, это упрощает доступ к метаданным документов при индексации и выводе результатов.</p><p>Для нужд текстового поиска каждый документ должен быть сведён к специальному формату <code class="type">tsvector</code>. Поиск и ранжирование выполняется исключительно с этим представлением документа — исходный текст потребуется извлечь, только когда документ будет отобран для вывода пользователю. Поэтому мы часто подразумеваем под <code class="type">tsvector</code> документ, тогда как этот тип, конечно, содержит только компактное представление всего документа.</p></div><div class="sect2" id="TEXTSEARCH-MATCHING"><div class="titlepage"><div><div><h3 class="title">12.1.2. Простое соответствие текста <a href="#TEXTSEARCH-MATCHING" class="id_link">#</a></h3></div></div></div><p>Полнотекстовый поиск в <span class="productname">PostgreSQL</span> реализован на базе оператора соответствия <code class="literal">@@</code>, который возвращает <code class="literal">true</code>, если <code class="type">tsvector</code> (документ) соответствует <code class="type">tsquery</code> (запросу). Для этого оператора не важно, какой тип записан первым: </p><pre class="programlisting">SELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector @@
  'cat &amp; rat'::tsquery;
 ?column?
----------
 t

SELECT 'fat &amp; cow'::tsquery @@
  'a fat cat sat on a mat and ate a fat rat'::tsvector;
 ?column?
----------
 f</pre><p>Как можно догадаться из этого примера, <code class="type">tsquery</code> — это не просто текст, как и <code class="type">tsvector</code>. Значение типа <code class="type">tsquery</code> содержит искомые слова, это должны быть уже нормализованные лексемы, возможно объединённые в выражение операторами И, ИЛИ, НЕ и ПРЕДШЕСТВУЕТ. (Подробнее синтаксис описан в <a class="xref" href="datatype-textsearch.html#DATATYPE-TSQUERY" title="8.11.2. tsquery">Подразделе 8.11.2</a>.) Вы можете воспользоваться функциями <code class="function">to_tsquery</code>, <code class="function">plainto_tsquery</code> и <code class="function">phraseto_tsquery</code>, которые могут преобразовать заданный пользователем текст в значение <code class="type">tsquery</code>, прежде всего нормализуя слова в этом тексте. Функция <code class="function">to_tsvector</code> подобным образом может разобрать и нормализовать текстовое содержимое документа. Так что запрос с поиском соответствия на практике выглядит скорее так: </p><pre class="programlisting">SELECT to_tsvector('fat cats ate fat rats') @@ to_tsquery('fat &amp; rat');
 ?column?
----------
 t</pre><p> Заметьте, что соответствие не будет обнаружено, если запрос записан как </p><pre class="programlisting">SELECT 'fat cats ate fat rats'::tsvector @@ to_tsquery('fat &amp; rat');
 ?column?
----------
 f</pre><p> так как слово <code class="literal">rats</code> не будет нормализовано. Элементами <code class="type">tsvector</code> являются лексемы, предположительно уже нормализованные, так что <code class="literal">rats</code> считается не соответствующим <code class="literal">rat</code>.</p><p>Оператор <code class="literal">@@</code> также может принимать типы <code class="type">text</code>, позволяя опустить явные преобразования текстовых строк в типы <code class="type">tsvector</code> и <code class="type">tsquery</code> в простых случаях. Всего есть четыре варианта этого оператора: </p><pre class="programlisting">tsvector @@ tsquery
tsquery  @@ tsvector
text @@ tsquery
text @@ text</pre><p>Первые два мы уже видели раньше. Форма <code class="type">text</code><code class="literal">@@</code><code class="type">tsquery</code> равнозначна выражению <code class="literal">to_tsvector(x) @@ y</code>, а форма <code class="type">text</code><code class="literal">@@</code><code class="type">text</code> — выражению <code class="literal">to_tsvector(x) @@ plainto_tsquery(y)</code>.</p><p>В значении <code class="type">tsquery</code> оператор <code class="literal">&amp;</code> (И) указывает, что оба его операнда должны присутствовать в документе, чтобы он удовлетворял запросу. Подобным образом, оператор <code class="literal">|</code> (ИЛИ) указывает, что в документе должен присутствовать минимум один из его операндов, тогда как оператор <code class="literal">!</code> (НЕ) указывает, что его операнд <span class="emphasis"><em>не</em></span> должен присутствовать, чтобы условие удовлетворялось. Например, запросу <code class="literal">fat &amp; ! rat</code> соответствуют документы, содержащие <code class="literal">fat</code> и не содержащие <code class="literal">rat</code>.</p><p>Фразовый поиск возможен с использованием оператора <code class="literal">&lt;-&gt;</code> (ПРЕДШЕСТВУЕТ) типа <code class="type">tsquery</code>, который находит соответствие, только если его операнды расположены рядом и в заданном порядке. Например: </p><pre class="programlisting">SELECT to_tsvector('fatal error') @@ to_tsquery('fatal &lt;-&gt; error');
 ?column?
----------
 t

SELECT to_tsvector('error is not fatal') @@ to_tsquery('fatal &lt;-&gt; error');
 ?column?
----------
 f</pre><p> Более общая версия оператора ПРЕДШЕСТВУЕТ имеет вид <code class="literal">&lt;<em class="replaceable"><code>N</code></em>&gt;</code>, где <em class="replaceable"><code>N</code></em> — целое число, выражающее разность между позициями найденных лексем. Запись <code class="literal">&lt;1&gt;</code> равнозначна <code class="literal">&lt;-&gt;</code>, тогда как <code class="literal">&lt;2&gt;</code> допускает существование ровно одной лексемы между этими лексемами и т. д. Функция <code class="literal">phraseto_tsquery</code> задействует этот оператор для конструирования <code class="literal">tsquery</code>, который может содержать многословную фразу, включающую в себя стоп-слова. Например: </p><pre class="programlisting">SELECT phraseto_tsquery('cats ate rats');
       phraseto_tsquery
-------------------------------
 'cat' &lt;-&gt; 'ate' &lt;-&gt; 'rat'

SELECT phraseto_tsquery('the cats ate the rats');
       phraseto_tsquery
-------------------------------
 'cat' &lt;-&gt; 'ate' &lt;2&gt; 'rat'</pre><p>Особый случай, который иногда бывает полезен, представляет собой запись <code class="literal">&lt;0&gt;</code>, требующая, чтобы обоим лексемам соответствовало одно слово.</p><p>Сочетанием операторов <code class="type">tsquery</code> можно управлять, применяя скобки. Без скобок операторы имеют следующие приоритеты, в порядке возрастания: <code class="literal">|</code>, <code class="literal">&amp;</code>, <code class="literal">&lt;-&gt;</code> и самый приоритетный — <code class="literal">!</code>.</p><p>Стоит отметить, что операторы И/ИЛИ/НЕ имеют несколько другое значение, когда они применяются в аргументах оператора ПРЕДШЕСТВУЕТ, так как в этом случае имеет значение точная позиция совпадения. Например, обычному <code class="literal">!x</code> соответствуют только документы, не содержащие <code class="literal">x</code> нигде. Но условию <code class="literal">!x &lt;-&gt; y</code> соответствует <code class="literal">y</code>, если оно не следует непосредственно за <code class="literal">x</code>; при вхождении <code class="literal">x</code> в любом другом месте документа он не будет исключаться из рассмотрения. Другой пример: для условия <code class="literal">x &amp; y</code> обычно требуется, чтобы и <code class="literal">x</code>, и <code class="literal">y</code> встречались в каком-то месте документа, но для выполнения условия <code class="literal">(x &amp; y) &lt;-&gt; z</code> требуется, чтобы <code class="literal">x</code> и <code class="literal">y</code> располагались в одном месте, непосредственно перед <code class="literal">z</code>. Таким образом, этот запрос отличается от <code class="literal">x &lt;-&gt; z &amp; y &lt;-&gt; z</code>, которому удовлетворяют документы, содержащие две отдельные последовательности <code class="literal">x z</code> и <code class="literal">y z</code>. (Этот конкретный запрос в таком виде, как он записан, не имеет смысла, так как <code class="literal">x</code> и <code class="literal">y</code> не могут находиться в одном месте; но в более сложных ситуациях, например, с шаблонами поиска по маске, запросы этого вида могут быть полезны.)</p></div><div class="sect2" id="TEXTSEARCH-INTRO-CONFIGURATIONS"><div class="titlepage"><div><div><h3 class="title">12.1.3. Конфигурации <a href="#TEXTSEARCH-INTRO-CONFIGURATIONS" class="id_link">#</a></h3></div></div></div><p>До этого мы рассматривали очень простые примеры поиска текста. Как было упомянуто выше, весь функционал текстового поиска позволяет делать гораздо больше: пропускать определённые слова (стоп-слова), обрабатывать синонимы и выполнять сложный анализ слов, например, выделять фрагменты не только по пробелам. Все эти функции управляются <em class="firstterm">конфигурациями текстового поиска</em>. В <span class="productname">PostgreSQL</span> есть набор предопределённых конфигураций для многих языков, но вы также можете создавать собственные конфигурации. (Все доступные конфигурации можно просмотреть с помощью команды <code class="command">\dF</code> в <span class="application">psql</span>.)</p><p>Подходящая конфигурация для данной среды выбирается во время установки и записывается в параметре <a class="xref" href="runtime-config-client.html#GUC-DEFAULT-TEXT-SEARCH-CONFIG">default_text_search_config</a> в <code class="filename">postgresql.conf</code>. Если вы используете для всего кластера одну конфигурацию текстового поиска, вам будет достаточно этого параметра в <code class="filename">postgresql.conf</code>. Если же требуется использовать в кластере разные конфигурации, но для каждой базы данных одну определённую, её можно задать командой <code class="command">ALTER DATABASE ... SET</code>. В противном случае конфигурацию можно выбрать в рамках сеанса, определив параметр <code class="varname">default_text_search_config</code>.</p><p>У каждой функции текстового поиска, зависящей от конфигурации, есть необязательный аргумент <code class="type">regconfig</code>, в котором можно явно указать конфигурацию для данной функции. Значение <code class="varname">default_text_search_config</code> используется, только когда этот аргумент опущен.</p><p>Для упрощения создания конфигураций текстового поиска они строятся из более простых объектов. В <span class="productname">PostgreSQL</span> есть четыре типа таких объектов:</p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p><em class="firstterm">Анализаторы текстового поиска</em> разделяют документ на фрагменты и классифицируют их (например, как слова или числа).</p></li><li class="listitem" style="list-style-type: disc"><p><em class="firstterm">Словари текстового поиска</em> приводят фрагменты к нормализованной форме и отбрасывают стоп-слова.</p></li><li class="listitem" style="list-style-type: disc"><p><em class="firstterm">Шаблоны текстового поиска</em> предоставляют функции, образующие реализацию словарей. (При создании словаря просто задаётся шаблон и набор параметров для него.)</p></li><li class="listitem" style="list-style-type: disc"><p><em class="firstterm">Конфигурации текстового поиска</em> выбирают анализатор и набор словарей, который будет использоваться для нормализации фрагментов, выданных анализатором.</p></li></ul></div><p>Анализаторы и шаблоны текстового поиска строятся из низкоуровневых функций на языке C; чтобы создать их, нужно программировать на C, а подключить их к базе данных может только суперпользователь. (В подкаталоге <code class="filename">contrib/</code> инсталляции <span class="productname">PostgreSQL</span> можно найти примеры дополнительных анализаторов и шаблонов.) Так как словари и конфигурации представляют собой просто наборы параметров, связывающие анализаторы и шаблоны, их можно создавать, не имея административных прав. Далее в этой главе будут приведены примеры их создания.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="textsearch.html" title="Глава 12. Полнотекстовый поиск">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="textsearch.html" title="Глава 12. Полнотекстовый поиск">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="textsearch-tables.html" title="12.2. Таблицы и индексы">След.</a></td></tr><tr><td width="40%" align="left" valign="top">Глава 12. Полнотекстовый поиск </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 12.2. Таблицы и индексы</td></tr></table></div></body></html>