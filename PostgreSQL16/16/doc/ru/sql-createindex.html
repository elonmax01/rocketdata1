<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CREATE INDEX</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sql-creategroup.html" title="CREATE GROUP" /><link rel="next" href="sql-createlanguage.html" title="CREATE LANGUAGE" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">CREATE INDEX</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-creategroup.html" title="CREATE GROUP">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><th width="60%" align="center">Команды SQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-createlanguage.html" title="CREATE LANGUAGE">След.</a></td></tr></table><hr /></div><div class="refentry" id="SQL-CREATEINDEX"><div class="titlepage"></div><a id="id-1.9.3.69.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">CREATE INDEX</span></h2><p>CREATE INDEX — создать индекс</p></div><div class="refsynopsisdiv"><h2>Синтаксис</h2><pre class="synopsis">CREATE [ UNIQUE ] INDEX [ CONCURRENTLY ] [ [ IF NOT EXISTS ] <em class="replaceable"><code>имя</code></em> ] ON [ ONLY ] <em class="replaceable"><code>имя_таблицы</code></em> [ USING <em class="replaceable"><code>метод</code></em> ]
    ( { <em class="replaceable"><code>имя_столбца</code></em> | ( <em class="replaceable"><code>выражение</code></em> ) } [ COLLATE <em class="replaceable"><code>правило_сортировки</code></em> ] [ <em class="replaceable"><code>класс_операторов</code></em> [ ( <em class="replaceable"><code>параметр_класса_оп</code></em> = <em class="replaceable"><code>значение</code></em> [, ... ] ) ] ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ] [, ...] )
    [ INCLUDE ( <em class="replaceable"><code>имя_столбца</code></em> [, ...] ) ]
    [ NULLS [ NOT ] DISTINCT ]
    [ WITH ( <em class="replaceable"><code>параметр_хранения</code></em> [= <em class="replaceable"><code>значение</code></em>] [, ... ] ) ]
    [ TABLESPACE <em class="replaceable"><code>табл_пространство</code></em> ]
    [ WHERE <em class="replaceable"><code>предикат</code></em> ]</pre></div><div class="refsect1" id="id-1.9.3.69.5"><h2>Описание</h2><p><code class="command">CREATE INDEX</code> создаёт индексы по указанному столбцу(ам) заданного отношения, которым может быть таблица или материализованное представление. Индексы применяются в первую очередь для оптимизации производительности базы данных (хотя при неправильном использовании возможен и противоположный эффект).</p><p>Ключевое поле для индекса задаётся как имя столбца или выражение, заключённое в скобки. Если метод индекса поддерживает составные индексы, допускается указание нескольких полей.</p><p>Поле индекса может быть выражением, вычисляемым из значений одного или нескольких столбцов в строке таблицы. Это может быть полезно для получения быстрого доступа к данным по некоторому преобразованию исходных значений. Например, индекс, построенный по выражению <code class="literal">upper(col)</code>, позволит использовать поиск по индексу в предложении <code class="literal">WHERE upper(col) = 'JIM'</code>.</p><p><span class="productname">PostgreSQL</span> предоставляет следующие методы индексов: B-дерево, хеш, GiST, SP-GiST, GIN и BRIN. Пользователи могут определить и собственные методы индексов, но это довольно сложная задача.</p><p>Если в команде присутствует предложение <code class="literal">WHERE</code>, она создаёт <em class="firstterm">частичный индекс</em>. Такой индекс содержит записи только для части таблицы, обычно более полезной для индексации, чем остальная таблица. Например, если таблица содержит информацию об оплаченных и неоплаченных счетах, при этом последних сравнительно немного, но именно эта часть таблицы наиболее востребована, то увеличить быстродействие можно, создав индекс только по этой части. Ещё одно возможное применение <code class="literal">WHERE</code> — добавив <code class="literal">UNIQUE</code>, обеспечить уникальность в подмножестве таблицы. Подробнее это рассматривается в <a class="xref" href="indexes-partial.html" title="11.8. Частичные индексы">Разделе 11.8</a>.</p><p>Выражение в предложении <code class="literal">WHERE</code> может ссылаться только на столбцы нижележащей таблицы, но не обязательно ограничиваться теми, по которым строится индекс. В настоящее время в <code class="literal">WHERE</code> также нельзя использовать подзапросы и агрегатные выражения. Это же ограничение распространяется и на выражения в полях индексов.</p><p>Все функции и операторы, используемые в определении индекса, должны быть <span class="quote">«<span class="quote">постоянными</span>»</span>, то есть, их результаты должны зависеть только от аргументов, но не от внешних факторов (например, содержимого другой таблицы или текущего времени). Это ограничение обеспечивает определённость поведения индекса. Чтобы использовать в выражении индекса или в предложении <code class="literal">WHERE</code> собственную функцию, не забудьте пометить её при создании как постоянную (IMMUTABLE).</p></div><div class="refsect1" id="id-1.9.3.69.6"><h2>Параметры</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">UNIQUE</code></span></dt><dd><p>Указывает, что система должна контролировать повторяющиеся значения в таблице при создании индекса (если в таблице уже есть данные) и при каждом добавлении данных. Попытки вставить или изменить данные, при которых будет нарушена уникальность индекса, будут завершаться ошибкой.</p><p>Когда уникальные индексы применяются к секционированным таблицам, действуют дополнительные ограничения; см. <a class="xref" href="sql-createtable.html" title="CREATE TABLE"><span class="refentrytitle">CREATE TABLE</span></a>.</p></dd><dt><span class="term"><code class="literal">CONCURRENTLY</code></span></dt><dd><p>С этим указанием <span class="productname">PostgreSQL</span> построит индекс, не устанавливая никаких блокировок, которые бы предотвращали добавление, изменение или удаление записей в таблице, тогда как по умолчанию операция построения индекса блокирует запись (но не чтение) данных в таблице до своего завершения. С созданием индекса в этом режиме связан ряд особенностей, о которых следует знать, — см. <a class="xref" href="sql-createindex.html#SQL-CREATEINDEX-CONCURRENTLY" title="Неблокирующее построение индексов">Неблокирующее построение индексов</a>.</p><p>Для временных таблиц <code class="command">CREATE INDEX</code> всегда выполняется более простым, неблокирующим способом, так как они не могут использоваться никакими другими сеансами.</p></dd><dt><span class="term"><code class="literal">IF NOT EXISTS</code></span></dt><dd><p>Не считать ошибкой, если индекс с таким именем уже существует. В этом случае будет выдано замечание. Заметьте, что нет никакой гарантии, что существующий индекс как-то соотносится с тем, который мог бы быть создан. Имя индекса является обязательным, когда указывается <code class="literal">IF NOT EXISTS</code>.</p></dd><dt><span class="term"><code class="literal">INCLUDE</code></span></dt><dd><p>Необязательное предложение <code class="literal">INCLUDE</code> позволяет указать список столбцов, которые войдут в индекс как <em class="firstterm">неключевые</em> столбцы. Неключевой столбец не может использоваться в условии поиска для сканирования по индексу, и он не учитывается при анализе ограничения уникальности или исключения, устанавливаемого индексом. Однако при сканировании только индекса содержимое неключевых столбцов может быть получено без обращения к целевой таблице, так как оно находится непосредственно в элементе индекса. Таким образом, в результате добавления неключевых столбцов сканирование только индекса может использоваться в тех запросах, где иначе оно было бы неприменимо.</p><p>Добавляя в индекс неключевые столбцы, особенно большого размера, есть смысл проявлять консерватизм. Если кортеж в индексе превышает максимально допустимый размер для данного типа индексов, вставить данные в таблицу не удастся. В неключевых столбцах дублируются данные из основной таблицы, что приводит к раздуванию индекса и может повлечь замедление запросов. Кроме того, если неключевой столбец содержится в индексе B-дерево, в таком индексе не будет работать исключение дубликатов.</p><p>Для столбцов, перечисленных в <code class="literal">INCLUDE</code>, не нужны соответствующие классы операторов; это предложение может содержать столбцы, для типов данных которых не определены классы операторов для заданного метода доступа.</p><p>Выражения в неключевых столбцах не поддерживаются, так как их нельзя будет использовать при сканировании только индекса.</p><p>В настоящее время эту возможность поддерживают методы доступа индексов B-дерево, GiST и SP-GiST. В таких индексах значения столбцов, указанных в предложении <code class="literal">INCLUDE</code>, включаются в кортежи на уровне листьев, которые соответствуют кортежам кучи, но не включаются в элементы верхних уровней, используемые для навигации в дереве.</p></dd><dt><span class="term"><em class="replaceable"><code>имя</code></em></span></dt><dd><p>Имя создаваемого индекса. Указание схемы при этом не допускается; индекс всегда относится к той же схеме, что и родительская таблица. Имя индекса должно отличаться от имени любого другого отношения (таблицы, последовательности, индекса, представления, материализованного представления или сторонней таблицы) в этой схеме. Если имя опущено, <span class="productname">PostgreSQL</span> формирует подходящее имя по имени родительской таблицы и именам индексируемых столбцов.</p></dd><dt><span class="term"><code class="literal">ONLY</code></span></dt><dd><p>Указывает, что индексы не должны рекурсивно создаваться в секциях секционированной таблицы. По умолчанию создание выполняется рекурсивно.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_таблицы</code></em></span></dt><dd><p>Имя индексируемой таблицы (возможно, дополненное схемой).</p></dd><dt><span class="term"><em class="replaceable"><code>метод</code></em></span></dt><dd><p>Имя применяемого метода индекса. Возможные варианты: <code class="literal">btree</code>, <code class="literal">hash</code>, <code class="literal">gist</code>, <code class="literal">spgist</code>, <code class="literal">gin</code>, <code class="literal">brin</code> или установленный пользователем метод, например <a class="link" href="bloom.html" title="F.7. bloom — индексный метод доступа, основанный на фильтрах Блума">bloom</a>. По умолчанию подразумевается метод <code class="literal">btree</code>.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_столбца</code></em></span></dt><dd><p>Имя столбца таблицы.</p></dd><dt><span class="term"><em class="replaceable"><code>выражение</code></em></span></dt><dd><p>Выражение с одним или несколькими столбцами таблицы. Обычно выражение должно записываться в скобках, как показано в синтаксисе команды. Однако скобки можно опустить, если выражение записано в виде вызова функции.</p></dd><dt><span class="term"><em class="replaceable"><code>правило_сортировки</code></em></span></dt><dd><p>Имя правила сортировки, применяемого для индекса. По умолчанию используется правило сортировки, заданное для индексируемого столбца, либо полученное для результата выражения индекса. Индексы с нестандартными правилами сортировки могут быть полезны для запросов, включающих выражения с такими правилами.</p></dd><dt><span class="term"><em class="replaceable"><code>класс_операторов</code></em></span></dt><dd><p>Имя класса операторов. Подробнее об этом ниже.</p></dd><dt><span class="term"><em class="replaceable"><code>параметр_класса_оп</code></em></span></dt><dd><p>Имя параметра класса операторов. Подробнее об этом ниже.</p></dd><dt><span class="term"><code class="literal">ASC</code></span></dt><dd><p>Указывает порядок сортировки по возрастанию (подразумевается по умолчанию).</p></dd><dt><span class="term"><code class="literal">DESC</code></span></dt><dd><p>Указывает порядок сортировки по убыванию.</p></dd><dt><span class="term"><code class="literal">NULLS FIRST</code></span></dt><dd><p>Указывает, что значения NULL после сортировки оказываются перед остальными. Это поведение по умолчанию с порядком сортировки <code class="literal">DESC</code>.</p></dd><dt><span class="term"><code class="literal">NULLS LAST</code></span></dt><dd><p>Указывает, что значения NULL после сортировки оказываются после остальных. Это поведение по умолчанию с порядком сортировки <code class="literal">ASC</code>.</p></dd><dt><span class="term"><code class="literal">NULLS DISTINCT</code><br /></span><span class="term"><code class="literal">NULLS NOT DISTINCT</code></span></dt><dd><p>Определяет, должны ли значения NULL считаться различными (не равными) для уникального индекса. По умолчанию они считаются различными, поэтому уникальный индекс может содержать в столбце несколько значений NULL.</p></dd><dt><span class="term"><em class="replaceable"><code>параметр_хранения</code></em></span></dt><dd><p>Имя специфичного для индекса параметра хранения. За подробностями обратитесь к разделу <a class="xref" href="sql-createindex.html#SQL-CREATEINDEX-STORAGE-PARAMETERS" title="Параметры хранения индекса">Параметры хранения индекса</a> ниже.</p></dd><dt><span class="term"><em class="replaceable"><code>табл_пространство</code></em></span></dt><dd><p>Табличное пространство, в котором будет создан индекс. Если не определено, выбирается <a class="xref" href="runtime-config-client.html#GUC-DEFAULT-TABLESPACE">default_tablespace</a>, либо <a class="xref" href="runtime-config-client.html#GUC-TEMP-TABLESPACES">temp_tablespaces</a>, при создании индекса временной таблицы.</p></dd><dt><span class="term"><em class="replaceable"><code>предикат</code></em></span></dt><dd><p>Выражение ограничения для частичного индекса.</p></dd></dl></div><div class="refsect2" id="SQL-CREATEINDEX-STORAGE-PARAMETERS"><h3>Параметры хранения индекса</h3><p>Необязательное предложение <code class="literal">WITH</code> определяет <em class="firstterm">параметры хранения</em> для индекса. У каждого метода индекса есть свой набор допустимых параметров хранения. Следующий параметр принимают методы B-дерево, хеш, GiST и SP-GiST:</p><div class="variablelist"><dl class="variablelist"><dt id="INDEX-RELOPTION-FILLFACTOR"><span class="term"><code class="literal">fillfactor</code> (<code class="type">integer</code>) <a id="id-1.9.3.69.6.3.3.1.1.3" class="indexterm"></a></span> <a href="#INDEX-RELOPTION-FILLFACTOR" class="id_link">#</a></dt><dd><p>Фактор заполнения для индекса определяет в процентном отношении, насколько плотно метод индекса будет заполнять страницы индекса. Для B-деревьев концевые страницы заполняются до этого процента при начальном построении индекса и позже, при расширении индекса вправо (добавлении новых наибольших значений ключа). Если страницы впоследствии оказываются заполненными полностью, они будут разделены, что приводит к фрагментации структуры индекса на диске. Для B-деревьев по умолчанию используется фактор заполнения 90, но его можно поменять на любое целое число от 10 до 100.</p><p>Для индексов-B-деревьев в таблицах, где ожидается множество добавлений и/или изменений записей, имеет смысл выбрать меньшие значения фактора заполнения в момент выполнения <code class="command">CREATE INDEX</code> (до массовой загрузки данных в таблицы). Значения в диапазоне 50 – 90 могут сгладить <span class="emphasis"><em>всплески</em></span> разделений страниц на начальном этапе жизни индекса-B-дерева (при подобном снижении фактора заполнения может даже уменьшиться абсолютное количество разделений страниц, хотя это во многом зависит от нагрузки). Процедура восходящего удаления индексных кортежей, описанная в <a class="xref" href="btree-implementation.html#BTREE-DELETION" title="67.4.2. Восходящее удаление индексных кортежей">Подразделе 67.4.2</a>, рассчитывает на наличие некоторого <span class="quote">«<span class="quote">дополнительного</span>»</span> места на страницах, где будут сохраняться <span class="quote">«<span class="quote">дополнительные</span>»</span> версии кортежей, и следовательно, может зависеть от фактора заполнения (хотя обычно его влияние второстепенно).</p><p>В других особых случаях может быть полезно увеличить фактор заполнения до 100 перед выполнением <code class="command">CREATE INDEX</code>, чтобы максимально эффективно использовать хранилище. Этот вариант следует рассматривать, только если вы абсолютно уверены, что таблица будет статичной (то есть в ней никогда не будут изменяться или добавляться данные). В противном случае фактор заполнения, равный 100, скорее <span class="emphasis"><em>повредит</em></span> производительности — даже единичные изменения или добавления вызовут резкий скачок активности разделения страниц.</p><p>Другие индексные методы используют фактор заполнения по-своему, но примерно в том же ключе; значение по умолчанию для разных методов разное.</p></dd></dl></div><p>Индексы B-дерево дополнительно принимают этот параметр:</p><div class="variablelist"><dl class="variablelist"><dt id="INDEX-RELOPTION-DEDUPLICATE-ITEMS"><span class="term"><code class="literal">deduplicate_items</code> (<code class="type">boolean</code>) <a id="id-1.9.3.69.6.3.5.1.1.3" class="indexterm"></a></span> <a href="#INDEX-RELOPTION-DEDUPLICATE-ITEMS" class="id_link">#</a></dt><dd><p>Этот параметр управляет механизмом исключения дубликатов, описанным в <a class="xref" href="btree-implementation.html#BTREE-DEDUPLICATION" title="67.4.3. Исключение дубликатов">Подразделе 67.4.3</a>. Он принимает логическое значение <code class="literal">ON</code> или <code class="literal">OFF</code>, соответственно включающее или отключающее это оптимизацию. (Другие возможные написания <code class="literal">ON</code> и <code class="literal">OFF</code> перечислены в <a class="xref" href="config-setting.html" title="20.1. Изменение параметров">Разделе 20.1</a>.) Значение по умолчанию — <code class="literal">ON</code>.</p><div class="note"><h3 class="title">Примечание</h3><p>После выключения параметра <code class="literal">deduplicate_items</code> командой <code class="command">ALTER INDEX</code> при добавлении в будущем новых элементов дубликаты исключаться не будут, но представление существующих кортежей не поменяется на стандартное.</p></div></dd></dl></div><p>Индексы GiST дополнительно принимают этот параметр:</p><div class="variablelist"><dl class="variablelist"><dt id="INDEX-RELOPTION-BUFFERING"><span class="term"><code class="literal">buffering</code> (<code class="type">enum</code>) <a id="id-1.9.3.69.6.3.7.1.1.3" class="indexterm"></a></span> <a href="#INDEX-RELOPTION-BUFFERING" class="id_link">#</a></dt><dd><p>Определяет, будет ли при построении индекса использоваться буферизация, описанная в <a class="xref" href="gist-implementation.html#GIST-BUFFERING-BUILD" title="68.4.1. Способы построения индексов GiST">Подразделе 68.4.1</a>. Со значением <code class="literal">OFF</code> она отключена, с <code class="literal">ON</code> — включена, а с <code class="literal">AUTO</code> — отключена вначале, но может затем включиться на ходу, как только размер индекса достигнет значения <a class="xref" href="runtime-config-query.html#GUC-EFFECTIVE-CACHE-SIZE">effective_cache_size</a>. Значение по умолчанию — <code class="literal">AUTO</code>. Заметьте, что если возможно построить индекс с сортировкой, именно этот метод будет использоваться при любом значении, кроме <code class="literal">buffering=ON</code>.</p></dd></dl></div><p>Индексы GIN принимают другие параметры:</p><div class="variablelist"><dl class="variablelist"><dt id="INDEX-RELOPTION-FASTUPDATE"><span class="term"><code class="literal">fastupdate</code> (<code class="type">boolean</code>) <a id="id-1.9.3.69.6.3.9.1.1.3" class="indexterm"></a></span> <a href="#INDEX-RELOPTION-FASTUPDATE" class="id_link">#</a></dt><dd><p>Этот параметр управляет механизмом быстрого обновления, описанным в <a class="xref" href="gin-implementation.html#GIN-FAST-UPDATE" title="70.4.1. Методика быстрого обновления GIN">Подразделе 70.4.1</a>. Он имеет логическое значение: <code class="literal">ON</code> включает быстрое обновление, <code class="literal">OFF</code> отключает его. Значение по умолчанию — <code class="literal">ON</code>.</p><div class="note"><h3 class="title">Примечание</h3><p>Выключение <code class="literal">fastupdate</code> в <code class="command">ALTER INDEX</code> предотвращает помещение добавляемых в дальнейшем строк в список записей, ожидающих индексации, но записи, добавленные в этот список ранее, в нём остаются. Чтобы очистить очередь операций, надо затем выполнить <code class="command">VACUUM</code> для этой таблицы или вызвать функцию <code class="function">gin_clean_pending_list</code>.</p></div></dd></dl></div><div class="variablelist"><dl class="variablelist"><dt id="INDEX-RELOPTION-GIN-PENDING-LIST-LIMIT"><span class="term"><code class="literal">gin_pending_list_limit</code> (<code class="type">integer</code>) <a id="id-1.9.3.69.6.3.10.1.1.3" class="indexterm"></a></span> <a href="#INDEX-RELOPTION-GIN-PENDING-LIST-LIMIT" class="id_link">#</a></dt><dd><p>Пользовательский параметр <a class="xref" href="runtime-config-client.html#GUC-GIN-PENDING-LIST-LIMIT">gin_pending_list_limit</a>. Его значение задаётся в килобайтах.</p></dd></dl></div><p>Индексы <acronym class="acronym">BRIN</acronym> принимают другие параметры:</p><div class="variablelist"><dl class="variablelist"><dt id="INDEX-RELOPTION-PAGES-PER-RANGE"><span class="term"><code class="literal">pages_per_range</code> (<code class="type">integer</code>) <a id="id-1.9.3.69.6.3.12.1.1.3" class="indexterm"></a></span> <a href="#INDEX-RELOPTION-PAGES-PER-RANGE" class="id_link">#</a></dt><dd><p>Определяет, сколько блоков таблицы образуют зону блоков для каждой записи в индексе <acronym class="acronym">BRIN</acronym> (за подробностями обратитесь к <a class="xref" href="brin-intro.html" title="71.1. Введение">Разделу 71.1</a>). Значение по умолчанию — <code class="literal">128</code>.</p></dd><dt id="INDEX-RELOPTION-AUTOSUMMARIZE"><span class="term"><code class="literal">autosummarize</code> (<code class="type">boolean</code>) <a id="id-1.9.3.69.6.3.12.2.1.3" class="indexterm"></a></span> <a href="#INDEX-RELOPTION-AUTOSUMMARIZE" class="id_link">#</a></dt><dd><p>Определяет, будет ли поставлен в очередь расчёт сводного значения для предыдущей зоны страниц, когда происходит добавление в следующую. За подробностями обратитесь к <a class="xref" href="brin-intro.html#BRIN-OPERATION" title="71.1.1. Обслуживание индекса">Подразделу 71.1.1</a>. По умолчанию <code class="literal">off</code>.</p></dd></dl></div></div><div class="refsect2" id="SQL-CREATEINDEX-CONCURRENTLY"><h3>Неблокирующее построение индексов</h3><a id="id-1.9.3.69.6.4.2" class="indexterm"></a><p>Создание индекса может мешать обычной работе с базой данных. Обычно <span class="productname">PostgreSQL</span> блокирует запись в индексируемую таблицу и выполняет всю операцию построения индекса за одно сканирование таблицы. Другие транзакции могут продолжать читать таблицу, но при попытке вставить, изменить или удалить строки в таблице они будут заблокированы до завершения построения индекса. Это может оказать нежелательное влияние на работу производственной базы данных. Индексация очень больших таблиц может занимать много часов, и даже для маленьких таблиц построение индекса может заблокировать записывающие процессы на время, неприемлемое для производственной системы.</p><p><span class="productname">PostgreSQL</span> поддерживает построение индексов без блокировки записи. Этот метод выбирается указанием <code class="literal">CONCURRENTLY</code> команды <code class="command">CREATE INDEX</code>. Когда он используется, <span class="productname">PostgreSQL</span> должен выполнить два сканирования таблицы, а кроме того, должен дождаться завершения всех существующих транзакций, которые потенциально могут модифицировать и использовать этот индекс. Таким образом, эта процедура требует проделать в сумме больше действий и выполняется значительно дольше, чем обычное построение индекса. Однако благодаря тому, что этот метод позволяет продолжать обычную работу с базой во время построения индекса, он оказывается полезным в производственной среде. Хотя разумеется, дополнительная нагрузка на процессор и подсистему ввода/вывода, создаваемая при построении индекса, может привести к замедлению других операций.</p><p>При неблокирующем построении индекса он как <span class="quote">«<span class="quote">нерабочий</span>»</span> добавляется в системный каталог в одной транзакции, а затем в двух других транзакциях выполняются ещё два сканирования таблицы. Перед каждым сканированием таблицы процедура построения индекса должна ждать завершения текущих транзакций, модифицировавших эту таблицу. После второго сканирования также необходимо дожидаться завершения всех транзакций, получивших снимок (см. <a class="xref" href="mvcc.html" title="Глава 13. Управление конкурентным доступом">Главу 13</a>) перед вторым сканированием, включая транзакции, задействованные на любом этапе неблокирующего построения индексов для других таблиц (это касается частичных индексов и индексов, построенных не просто по столбцам). Наконец индекс может быть помечен как <span class="quote">«<span class="quote">рабочий</span>»</span> и готовый к использованию, после чего команда <code class="command">CREATE INDEX</code> завершается. Однако даже тогда индекс может быть не готов немедленно к применению в запросах: в худшем случае он не будет использоваться, пока существуют транзакции, начатые до начала построения индекса.</p><p>Если при сканировании таблицы возникает проблема, например взаимоблокировка или нарушение уникальности в уникальном индексе, команда <code class="command">CREATE INDEX</code> завершится ошибкой, но оставит после себя <span class="quote">«<span class="quote">нерабочий</span>»</span> индекс. Этот индекс будет игнорироваться при чтении данных, так как он может быть неполным; однако с ним могут быть связаны дополнительные операции при изменениях. В <span class="application">psql</span> встроенная команда <code class="command">\d</code> помечает такой индекс как <code class="literal">INVALID</code>: </p><pre class="programlisting">postgres=# \d tab
       Table "public.tab"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 col    | integer |           |          |
Indexes:
    "idx" btree (col) INVALID</pre><p> Рекомендуемый в таких случаях способ исправления ситуации — удалить индекс и затем попытаться снова выполнить <code class="command">CREATE INDEX CONCURRENTLY</code>. (Кроме того, можно перестроить его с помощью команды <code class="command">REINDEX INDEX CONCURRENTLY</code>.)</p><p>Ещё одна сложность, с которой можно столкнуться при неблокирующем построении уникального индекса, заключается в том, что ограничение уникальности уже влияет на другие транзакции, когда второе сканирование таблицы только начинается. Это значит, что нарушения ограничения могут проявляться в других запросах до того, как индекс становится доступным для использования и даже тогда, когда создать индекс в итоге не удаётся. Кроме того, если при втором сканировании происходит ошибка, <span class="quote">«<span class="quote">нерабочий</span>»</span> индекс оставляет в силе своё ограничение уникальности и дальше.</p><p>Метод неблокирующего построения поддерживает также индексы выражений и частичные индексы. Ошибки, произошедшие при вычислении этих выражений, могут привести к такому же поведению, как в вышеописанных случаях с нарушением ограничений уникальности.</p><p>Обычное построение индекса допускает одновременное построение других индексов для таблицы обычным методом, но неблокирующее построение для конкретной таблицы в один момент времени допускается только одно. Однако в любом случае никакие другие изменения схемы таблицы в это время не разрешаются. Другое отличие состоит в том, что в блоке транзакции может быть выполнена обычная команда <code class="command">CREATE INDEX</code>, но не <code class="command">CREATE INDEX CONCURRENTLY</code>.</p><p>Метод неблокирующего построения для индексов секционированных таблиц в настоящее время не поддерживается. Однако вы можете сократить время, на которое будет заблокирована секционированная таблица, построив в неблокирующем режиме индекс для каждой секции в отдельности и затем создав секционированный индекс в обычном режиме. В этом случае построение секционированного индекса будет заключаться только в изменении метаданных.</p></div></div><div class="refsect1" id="id-1.9.3.69.7"><h2>Замечания</h2><p>Информацию о том, когда могут применяться, и когда не применяются индексы, и в каких конкретных ситуациях они могут быть полезны, можно найти в <a class="xref" href="indexes.html" title="Глава 11. Индексы">Главе 11</a>.</p><p>В настоящее время индексы с несколькими ключевыми столбцами поддерживаются только методами B-дерево, GiST, GIN и BRIN. Возможность построения индекса по нескольким ключевым столбцам не зависит от поддержки включения в индекс неключевых столбцов (<code class="literal">INCLUDE</code>). Индексы могут содержать до 32 столбцов, в том числе неключевых. (Этот предел можно изменить, пересобрав <span class="productname">PostgreSQL</span>.) Уникальные индексы поддерживает только метод B-дерево.</p><p>Для каждого столбца индекса можно задать <em class="firstterm">класс операторов</em> и дополнительные параметры класса. Данный класс определяет, какие операторы будут использоваться индексом для этого столбца. Например, индекс-B-дерево по четырёхбайтовым целым будет использовать класс <code class="literal">int4_ops</code>; этот класс операторов включает функции сравнения для таких значений. На практике обычно достаточно использовать класс операторов по умолчанию для типа данных столбца. Существование классов операторов объясняется в первую очередь тем, что для некоторых типов данных можно предложить более одного осмысленного порядка сортировки. Например, может возникнуть желание отсортировать комплексные числа как по абсолютному значению, так и по вещественной части. Это можно сделать, определив два класса операторов для типа данных и выбрав подходящий класс при создании индекса. За дополнительными сведениями о классах операторов обратитесь к <a class="xref" href="indexes-opclass.html" title="11.10. Семейства и классы операторов">Разделу 11.10</a> и <a class="xref" href="xindex.html" title="38.16. Интерфейсы расширений для индексов">Разделу 38.16</a>.</p><p>Когда команда <code class="literal">CREATE INDEX</code> вызывается для секционированной таблицы, по умолчанию её действие распространятся рекурсивно на все секции, с тем чтобы в них оказались соответствующие индексы. Сначала каждая секция проверяется на наличие равнозначного индекса, и, если таковой находится, он присоединяется как индекс секции к создаваемому, который таким образом становится родительским индексом. Если нужного индекса не оказывается, новый индекс автоматически создаётся и присоединяется к основному; имя индекса для каждой секции выбирается так же, как и при выполнении этой команды без имени индекса. С указанием <code class="literal">ONLY</code> рекурсия не производится и индекс помечается как нерабочий. (Команда <code class="command">ALTER INDEX ... ATTACH PARTITION</code> пометит его как рабочий, когда он будет представлен во всех секциях). Однако заметьте, что в любой секции, создаваемой в будущем командой <code class="command">CREATE TABLE ... PARTITION OF</code>, соответствующий индекс появится автоматически, вне зависимости от данного указания.</p><p>Для методов индекса, поддерживающих сканирование по порядку (в настоящее время это поддерживает только B-дерево), можно изменить порядок сортировки индекса, добавив необязательные предложения <code class="literal">ASC</code>, <code class="literal">DESC</code>, <code class="literal">NULLS FIRST</code> или <code class="literal">NULLS LAST</code>. Так как упорядоченный индекс можно сканировать вперёд или назад, обычно не имеет смысла создавать индекс по убыванию (<code class="literal">DESC</code>) для одного столбца — этот порядок сортировки можно получить и с обычным индексом. Эти параметры имеют смысл при создании составных индексов так, что они будут соответствовать порядку сортировки, указанному в запросе со смешанным порядком, например <code class="literal">SELECT ... ORDER BY x ASC, y DESC</code>. Параметры <code class="literal">NULLS</code> полезны, когда требуется реализовать поведение <span class="quote">«<span class="quote">NULL внизу</span>»</span>, изменив стандартное <span class="quote">«<span class="quote">NULL вверху</span>»</span>, в запросах, зависящих от индексов, чтобы избежать дополнительной сортировки.</p><p>Система регулярно собирает статистику по всем столбцам таблицы. Новые индексы, построенные без применения выражений, могут эффективно использовать эту статистику сразу. Однако для создаваемых индексов по выражениям требуется выполнить <a class="link" href="sql-analyze.html" title="ANALYZE"><code class="command">ANALYZE</code></a> или подождать, пока <a class="link" href="routine-vacuuming.html#AUTOVACUUM" title="25.1.6. Демон автоочистки">фоновый процесс автоочистки</a> не проанализирует таблицу и не посчитает статистику для этих индексов.</p><p>Для большинства методов индексов скорость создания индекса зависит от значения <a class="xref" href="runtime-config-resource.html#GUC-MAINTENANCE-WORK-MEM">maintenance_work_mem</a>. Чем больше это значение, тем меньше времени требуется для создания индекса (если только заданное значение не превышает объём действительно доступной памяти, что влечёт за собой использование подкачки).</p><p><span class="productname">PostgreSQL</span> может строить индексы, задействуя несколько процессоров для ускорения обработки строк таблицы. Это называется <em class="firstterm">параллельным построением индексов</em>. Для методов индексов, поддерживающих построение в параллельном режиме (в настоящее время это только B-дерево), параметр <code class="varname">maintenance_work_mem</code> задаёт максимальный объём памяти, который может быть выделен для одной операции построения индекса в целом, независимо от того, сколько рабочих процессов будет запущено. Целесообразность использования параллельных процессов и их оптимальное количество обычно автоматически определяется моделью стоимости.</p><p>Параллельное построение индексов может выиграть от увеличения <code class="varname">maintenance_work_mem</code> там, где для аналогичного последовательного построения индекса выигрыша не будет или он будет минимальным. Заметьте, что значение <code class="varname">maintenance_work_mem</code> может влиять на число запрашиваемых рабочих процессов, так как параллельным исполнителям должно быть выделено не менее <code class="literal">32MB</code> из общего бюджета <code class="varname">maintenance_work_mem</code>. Кроме того, <code class="literal">32MB</code> должно остаться для ведущего процесса. Увеличение <a class="xref" href="runtime-config-resource.html#GUC-MAX-PARALLEL-MAINTENANCE-WORKERS">max_parallel_maintenance_workers</a> позволит создать больше исполнителей, что приведёт к уменьшению времени создания индекса, если только создание индекса уже не упирается в скорость ввода/вывода. Разумеется, для этого должно быть достаточно процессорных ресурсов, которые иначе бы простаивали.</p><p>Если в <a class="link" href="sql-altertable.html" title="ALTER TABLE"><code class="command">ALTER TABLE</code></a> задаётся значение <code class="literal">parallel_workers</code>, именно оно определяет, сколько параллельных исполнителей будет запрашивать команда <code class="command">CREATE INDEX</code> для данной таблицы. При этом полностью игнорируется модель стоимости и <code class="varname">maintenance_work_mem</code> не влияет на определение количества параллельных исполнителей. Если параметру <code class="literal">parallel_workers</code> в <code class="command">ALTER TABLE</code> присваивается 0, параллельное построение индексов для этой таблицы полностью отключается.</p><div class="tip"><h3 class="title">Подсказка</h3><p>После изменения параметра <code class="literal">parallel_workers</code> в ходе оптимизации построения индексов имеет смысл сбросить его. Это предотвратит нежелательные изменения планов запросов, так как <code class="literal">parallel_workers</code> влияет на <span class="emphasis"><em>все</em></span> параллельные сканирования таблицы.</p></div><p>Хотя <code class="command">CREATE INDEX</code> с указанием <code class="literal">CONCURRENTLY</code> поддерживает параллельное построение без особых ограничений, фактически в параллельном режиме выполняется только первое сканирование таблицы.</p><p>Для удаления индекса применяется <a class="link" href="sql-dropindex.html" title="DROP INDEX"><code class="command">DROP INDEX</code></a>.</p><p>Как и любая длительная транзакция, операция <code class="command">CREATE INDEX</code> с таблицей может повлиять на возможность удаления кортежей параллельной операцией <code class="command">VACUUM</code> с какой-либо другой таблицей.</p><p>В предыдущих выпусках <span class="productname">PostgreSQL</span> также поддерживался метод индекса R-дерево. Сейчас он отсутствует, так как он не даёт значительных преимуществ по сравнению с GiST. Указание <code class="literal">USING rtree</code> команда <code class="command">CREATE INDEX</code> будет интерпретировать как <code class="literal">USING gist</code>, для упрощения перевода старых баз на GiST.</p><p>Каждый процесс, выполняющий операцию <code class="command">CREATE INDEX</code>, будет выдавать информацию о ходе её выполнения, отображаемую в представлении <code class="structname">pg_stat_progress_create_index</code>. За подробностями обратитесь к <a class="xref" href="progress-reporting.html#CREATE-INDEX-PROGRESS-REPORTING" title="28.4.4. Отслеживание выполнения CREATE INDEX">Подразделу 28.4.4</a>.</p></div><div class="refsect1" id="id-1.9.3.69.8"><h2>Примеры</h2><p>Создание уникального индекса-B-дерева по столбцу <code class="literal">title</code> в таблице <code class="literal">films</code>: </p><pre class="programlisting">CREATE UNIQUE INDEX title_idx ON films (title);</pre><p>Создание уникального индекса-B-дерева по столбцу <code class="literal">title</code> с неключевыми столбцами <code class="literal">director</code> и <code class="literal">rating</code> в таблице <code class="literal">films</code>: </p><pre class="programlisting">CREATE UNIQUE INDEX title_idx ON films (title) INCLUDE (director, rating);</pre><p>Создание индекса B-дерево без исключения дубликатов: </p><pre class="programlisting">CREATE INDEX title_idx ON films (title) WITH (deduplicate_items = off);</pre><p>Создание индекса по выражению <code class="literal">lower(title)</code>, позволяющего эффективно выполнять регистронезависимый поиск: </p><pre class="programlisting">CREATE INDEX ON films ((lower(title)));</pre><p> (В этом примере мы решили опустить имя индекса, чтобы имя выбрала система, например <code class="literal">films_lower_idx</code>.)</p><p>Создание индекса с нестандартным правилом сортировки: </p><pre class="programlisting">CREATE INDEX title_idx_german ON films (title COLLATE "de_DE");</pre><p>Создание индекса с нестандартным порядком значений NULL: </p><pre class="programlisting">CREATE INDEX title_idx_nulls_low ON films (title NULLS FIRST);</pre><p>Создание индекса с нестандартным фактором заполнения: </p><pre class="programlisting">CREATE UNIQUE INDEX title_idx ON films (title) WITH (fillfactor = 70);</pre><p>Создание индекса <acronym class="acronym">GIN</acronym> с отключённым механизмом быстрого обновления: </p><pre class="programlisting">CREATE INDEX gin_idx ON documents_table USING GIN (locations) WITH (fastupdate = off);</pre><p>Создание индекса по столбцу <code class="literal">code</code> в таблице <code class="literal">films</code> и размещение его в табличном пространстве <code class="literal">indexspace</code>: </p><pre class="programlisting">CREATE INDEX code_idx ON films (code) TABLESPACE indexspace;</pre><p>Создание индекса GiST по координатам точек, позволяющего эффективно использовать операторы box с результатом функции преобразования: </p><pre class="programlisting">CREATE INDEX pointloc
    ON points USING gist (box(location,location));
SELECT * FROM points
    WHERE box(location,location) &amp;&amp; '(0,0),(1,1)'::box;</pre><p>Создание индекса без блокировки записи в таблицу: </p><pre class="programlisting">CREATE INDEX CONCURRENTLY sales_quantity_index ON sales_table (quantity);</pre></div><div class="refsect1" id="id-1.9.3.69.9"><h2>Совместимость</h2><p><code class="command">CREATE INDEX</code> является языковым расширением <span class="productname">PostgreSQL</span>. Средства обеспечения индексов в стандарте SQL не описаны.</p></div><div class="refsect1" id="id-1.9.3.69.10"><h2>См. также</h2><span class="simplelist"><a class="xref" href="sql-alterindex.html" title="ALTER INDEX"><span class="refentrytitle">ALTER INDEX</span></a>, <a class="xref" href="sql-dropindex.html" title="DROP INDEX"><span class="refentrytitle">DROP INDEX</span></a>, <a class="xref" href="sql-reindex.html" title="REINDEX"><span class="refentrytitle">REINDEX</span></a>, <a class="xref" href="progress-reporting.html#CREATE-INDEX-PROGRESS-REPORTING" title="28.4.4. Отслеживание выполнения CREATE INDEX">Подраздел 28.4.4</a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-creategroup.html" title="CREATE GROUP">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-createlanguage.html" title="CREATE LANGUAGE">След.</a></td></tr><tr><td width="40%" align="left" valign="top">CREATE GROUP </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> CREATE LANGUAGE</td></tr></table></div></body></html>