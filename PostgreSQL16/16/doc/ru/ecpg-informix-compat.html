<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>36.15. Режим совместимости с Informix</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="ecpg-sql-whenever.html" title="WHENEVER" /><link rel="next" href="ecpg-oracle-compat.html" title="36.16. Режим совместимости с Oracle" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">36.15. Режим совместимости с <span class="productname">Informix</span></th></tr><tr><td width="10%" align="left"><a accesskey="p" href="ecpg-sql-whenever.html" title="WHENEVER">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="ecpg.html" title="Глава 36. ECPG — Встраиваемый SQL в C">Наверх</a></td><th width="60%" align="center">Глава 36. <span class="application">ECPG</span> — Встраиваемый <acronym class="acronym">SQL</acronym> в C</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="ecpg-oracle-compat.html" title="36.16. Режим совместимости с Oracle">След.</a></td></tr></table><hr /></div><div class="sect1" id="ECPG-INFORMIX-COMPAT"><div class="titlepage"><div><div><h2 class="title" style="clear: both">36.15. Режим совместимости с <span class="productname">Informix</span> <a href="#ECPG-INFORMIX-COMPAT" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="ecpg-informix-compat.html#ECPG-INFORMIX-TYPES">36.15.1. Дополнительные типы</a></span></dt><dt><span class="sect2"><a href="ecpg-informix-compat.html#ECPG-INFORMIX-STATEMENTS">36.15.2. Дополнительные/недостающие операторы встраиваемого SQL</a></span></dt><dt><span class="sect2"><a href="ecpg-informix-compat.html#ECPG-INFORMIX-SQLDA">36.15.3. Области дескрипторов SQLDA, совместимые с Informix</a></span></dt><dt><span class="sect2"><a href="ecpg-informix-compat.html#ECPG-INFORMIX-FUNCTIONS">36.15.4. Дополнительные функции</a></span></dt><dt><span class="sect2"><a href="ecpg-informix-compat.html#ECPG-INFORMIX-CONSTANTS">36.15.5. Дополнительные константы</a></span></dt></dl></div><p>Препроцессор <code class="command">ecpg</code> может работать в так называемом <em class="firstterm">режиме совместимости с Informix</em>. Если этот режим включён, <code class="command">ecpg</code> старается работать как предкомпилятор <span class="productname">Informix</span> для кода <span class="productname">Informix</span> E/SQL. Вообще говоря, это позволяет записывать встраиваемые команды SQL, используя знак доллара вместо слов <code class="literal">EXEC SQL</code>: </p><pre class="programlisting">$int j = 3;
$CONNECT TO :dbname;
$CREATE TABLE test(i INT PRIMARY KEY, j INT);
$INSERT INTO test(i, j) VALUES (7, :j);
$COMMIT;</pre><div class="note"><h3 class="title">Примечание</h3><p>Между <code class="literal">$</code> и последующей директивой препроцессора (в частности, <code class="literal">include</code>, <code class="literal">define</code>, <code class="literal">ifdef</code> и т. п.) не должно быть пробельных символов. В противном случае препроцессор воспримет следующее слово как имя переменной среды.</p></div><p>Поддерживаются два режима совместимости: <code class="literal">INFORMIX</code> и <code class="literal">INFORMIX_SE</code></p><p>При компоновке программ, использующих этот режим совместимости, обязательно подключите библиотеку <code class="literal">libcompat</code>, поставляемую с ECPG.</p><p>Помимо ранее упомянутого синтаксического сахара, режим совместимости с <span class="productname">Informix</span> приносит из E/SQL в ECPG набор функций для ввода, вывода и преобразования данных, а также встраиваемые операторы SQL.</p><p>Режим совместимости с <span class="productname">Informix</span> тесно связан с библиотекой pgtypeslib из ECPG. Библиотека pgtypeslib сопоставляет типы данных SQL с типами данных в ведущей программе на C, а большинство дополнительных функций режима совместимости с <span class="productname">Informix</span> позволяют работать с этими типами C. Заметьте, однако, что степень совместимости ограничена. ECPG не пытается копировать поведение <span class="productname">Informix</span>; вы можете выполнять примерно те же операции и пользоваться функции с теми же именами и с тем же поведением, но если вы используете <span class="productname">Informix</span>, просто заменить одно средство другим на данный момент нельзя. Более того, есть различия и в типах данных. В частности, типы даты и интервала в <span class="productname">PostgreSQL</span> не воспринимают диапазоны, как например, <code class="literal">YEAR TO MINUTE</code>, так что и в ECPG это не будет поддерживаться.</p><div class="sect2" id="ECPG-INFORMIX-TYPES"><div class="titlepage"><div><div><h3 class="title">36.15.1. Дополнительные типы <a href="#ECPG-INFORMIX-TYPES" class="id_link">#</a></h3></div></div></div><p>Теперь в режиме Informix без указания <code class="literal">typedef</code> поддерживается специальный псевдотип Informix "string" для хранения символьной строки, обрезаемой справа. На самом деле, в режиме Informix ECPG откажется обрабатывать исходные файлы, содержащие определение типа <code class="literal">typedef некоторый_тип string;</code> </p><pre class="programlisting">EXEC SQL BEGIN DECLARE SECTION;
string userid; /* эта переменная будет содержать обрезанные данные */
EXEC SQL END DECLARE SECTION;

EXEC SQL FETCH MYCUR INTO :userid;</pre></div><div class="sect2" id="ECPG-INFORMIX-STATEMENTS"><div class="titlepage"><div><div><h3 class="title">36.15.2. Дополнительные/недостающие операторы встраиваемого SQL <a href="#ECPG-INFORMIX-STATEMENTS" class="id_link">#</a></h3></div></div></div><p>
    </p><div class="variablelist"><dl class="variablelist"><dt id="ECPG-INFORMIX-STATEMENTS-CLOSE-DATABASE"><span class="term"><code class="literal">CLOSE DATABASE</code></span> <a href="#ECPG-INFORMIX-STATEMENTS-CLOSE-DATABASE" class="id_link">#</a></dt><dd><p>Этот оператор закрывает текущее подключение. Фактически это синоним команды <code class="literal">DISCONNECT CURRENT</code> в ECPG: </p><pre class="programlisting">$CLOSE DATABASE;                /* закрыть текущее подключение */
EXEC SQL CLOSE DATABASE;</pre></dd><dt id="ECPG-INFORMIX-STATEMENTS-FREE-CURSOR-NAME"><span class="term"><code class="literal">FREE имя_курсора</code></span> <a href="#ECPG-INFORMIX-STATEMENTS-FREE-CURSOR-NAME" class="id_link">#</a></dt><dd><p>Из-за различий в подходах ECPG и ESQL/C Informix (а именно другого разделения на чисто грамматические преобразования и вызовы нижележащей библиотеки времени выполнения) в ECPG нет оператора <code class="literal">FREE имя_курсора</code>. Это связано с тем, что в ECPG команда <code class="literal">DECLARE CURSOR</code> не сводится к вызову функции в библиотеке времени выполнения, которая бы принимала имя курсора. Это значит, что курсоры SQL в библиотеке ECPG не требуют обслуживания, оно требуется только на уровне сервера PostgreSQL.</p></dd><dt id="ECPG-INFORMIX-STATEMENTS-FREE-STATEMENT-NAME"><span class="term"><code class="literal">FREE имя_оператора</code></span> <a href="#ECPG-INFORMIX-STATEMENTS-FREE-STATEMENT-NAME" class="id_link">#</a></dt><dd><p>Команда <code class="literal">FREE имя_оператора</code> является синонимом команды <code class="literal">DEALLOCATE PREPARE имя_оператора</code>.</p></dd></dl></div><p>
   </p></div><div class="sect2" id="ECPG-INFORMIX-SQLDA"><div class="titlepage"><div><div><h3 class="title">36.15.3. Области дескрипторов SQLDA, совместимые с Informix <a href="#ECPG-INFORMIX-SQLDA" class="id_link">#</a></h3></div></div></div><p>Режим совместимости с Informix поддерживает структуру, отличную от описанной в <a class="xref" href="ecpg-descriptors.html#ECPG-SQLDA-DESCRIPTORS" title="36.7.2. Области дескрипторов SQLDA">Подразделе 36.7.2</a>. См. ниже: </p><pre class="programlisting">struct sqlvar_compat
{
    short   sqltype;
    int     sqllen;
    char   *sqldata;
    short  *sqlind;
    char   *sqlname;
    char   *sqlformat;
    short   sqlitype;
    short   sqlilen;
    char   *sqlidata;
    int     sqlxid;
    char   *sqltypename;
    short   sqltypelen;
    short   sqlownerlen;
    short   sqlsourcetype;
    char   *sqlownername;
    int     sqlsourceid;
    char   *sqlilongdata;
    int     sqlflags;
    void   *sqlreserved;
};

struct sqlda_compat
{
    short  sqld;
    struct sqlvar_compat *sqlvar;
    char   desc_name[19];
    short  desc_occ;
    struct sqlda_compat *desc_next;
    void  *reserved;
};

typedef struct sqlvar_compat    sqlvar_t;
typedef struct sqlda_compat     sqlda_t;</pre><p>Глобальные свойства: </p><div class="variablelist"><dl class="variablelist"><dt id="ECPG-INFORMIX-SQLDA-SQLD"><span class="term"><code class="literal">sqld</code></span> <a href="#ECPG-INFORMIX-SQLDA-SQLD" class="id_link">#</a></dt><dd><p>Число полей в дескрипторе <code class="literal">SQLDA</code>.</p></dd><dt id="ECPG-INFORMIX-SQLDA-SQLVAR"><span class="term"><code class="literal">sqlvar</code></span> <a href="#ECPG-INFORMIX-SQLDA-SQLVAR" class="id_link">#</a></dt><dd><p>Указатель на свойства по полям.</p></dd><dt id="ECPG-INFORMIX-SQLDA-DESC-NAME"><span class="term"><code class="literal">desc_name</code></span> <a href="#ECPG-INFORMIX-SQLDA-DESC-NAME" class="id_link">#</a></dt><dd><p>Не используется, заполняется нулями.</p></dd><dt id="ECPG-INFORMIX-SQLDA-DESC-OCC"><span class="term"><code class="literal">desc_occ</code></span> <a href="#ECPG-INFORMIX-SQLDA-DESC-OCC" class="id_link">#</a></dt><dd><p>Размер структуры в памяти.</p></dd><dt id="ECPG-INFORMIX-SQLDA-DESC-NEXT"><span class="term"><code class="literal">desc_next</code></span> <a href="#ECPG-INFORMIX-SQLDA-DESC-NEXT" class="id_link">#</a></dt><dd><p>Указатель на следующую структуру SQLDA, если набор результатов содержит больше одной записи.</p></dd><dt id="ECPG-INFORMIX-SQLDA-RESERVED"><span class="term"><code class="literal">reserved</code></span> <a href="#ECPG-INFORMIX-SQLDA-RESERVED" class="id_link">#</a></dt><dd><p>Неиспользуемый указатель, содержит NULL. Сохраняется для совместимости с Informix.</p></dd></dl></div><p> Свойства, относящиеся к полям, описаны ниже, они хранятся в массиве <code class="literal">sqlvar</code>: </p><div class="variablelist"><dl class="variablelist"><dt id="ECPG-INFORMIX-SQLDA-SQLTYPE"><span class="term"><code class="literal">sqltype</code></span> <a href="#ECPG-INFORMIX-SQLDA-SQLTYPE" class="id_link">#</a></dt><dd><p>Тип поля. Соответствующие константы представлены в <code class="literal">sqltypes.h</code></p></dd><dt id="ECPG-INFORMIX-SQLDA-SQLLEN"><span class="term"><code class="literal">sqllen</code></span> <a href="#ECPG-INFORMIX-SQLDA-SQLLEN" class="id_link">#</a></dt><dd><p>Длина данных поля.</p></dd><dt id="ECPG-INFORMIX-SQLDA-SQLDATA"><span class="term"><code class="literal">sqldata</code></span> <a href="#ECPG-INFORMIX-SQLDA-SQLDATA" class="id_link">#</a></dt><dd><p>Указатель на данные поля. Этот указатель имеет тип <code class="literal">char *</code>, но он указывает на данные в двоичном формате. Например: </p><pre class="programlisting">int intval;

switch (sqldata-&gt;sqlvar[i].sqltype)
{
    case SQLINTEGER:
        intval = *(int *)sqldata-&gt;sqlvar[i].sqldata;
        break;
  ...
}</pre></dd><dt id="ECPG-INFORMIX-SQLDA-SQLIND"><span class="term"><code class="literal">sqlind</code></span> <a href="#ECPG-INFORMIX-SQLDA-SQLIND" class="id_link">#</a></dt><dd><p>Указатель на индикатор NULL. Если возвращается командами DESCRIBE или FETCH, это всегда действительный указатель. Если передаётся на вход команде <code class="literal">EXECUTE ... USING sqlda;</code>, NULL вместо указателя означает, что значение этого поля отлично от NULL. Чтобы обозначить NULL в поле, необходимо корректно установить этот указатель и <code class="literal">sqlitype</code>. Например: </p><pre class="programlisting">if (*(int2 *)sqldata-&gt;sqlvar[i].sqlind != 0)
    printf("value is NULL\n");</pre></dd><dt id="ECPG-INFORMIX-SQLDA-SQLNAME"><span class="term"><code class="literal">sqlname</code></span> <a href="#ECPG-INFORMIX-SQLDA-SQLNAME" class="id_link">#</a></dt><dd><p>Имя поля, в виде строки с завершающим 0.</p></dd><dt id="ECPG-INFORMIX-SQLDA-SQLFORMAT"><span class="term"><code class="literal">sqlformat</code></span> <a href="#ECPG-INFORMIX-SQLDA-SQLFORMAT" class="id_link">#</a></dt><dd><p>Зарезервировано в Informix, значение <a class="xref" href="libpq-exec.html#LIBPQ-PQFFORMAT"><code class="function">PQfformat</code></a> для данного поля.</p></dd><dt id="ECPG-INFORMIX-SQLDA-SQLITYPE"><span class="term"><code class="literal">sqlitype</code></span> <a href="#ECPG-INFORMIX-SQLDA-SQLITYPE" class="id_link">#</a></dt><dd><p>Тип данных индикатора NULL. При получении данных с сервера это всегда SQLSMINT. Когда <code class="literal">SQLDA</code> используется в параметризованном запросе, данные индикатора обрабатываются в соответствии с указанным здесь типом.</p></dd><dt id="ECPG-INFORMIX-SQLDA-SQLILEN"><span class="term"><code class="literal">sqlilen</code></span> <a href="#ECPG-INFORMIX-SQLDA-SQLILEN" class="id_link">#</a></dt><dd><p>Длина данных индикатора NULL.</p></dd><dt id="ECPG-INFORMIX-SQLDA-SQLXID"><span class="term"><code class="literal">sqlxid</code></span> <a href="#ECPG-INFORMIX-SQLDA-SQLXID" class="id_link">#</a></dt><dd><p>Расширенный тип поля, результат функции <a class="xref" href="libpq-exec.html#LIBPQ-PQFTYPE"><code class="function">PQftype</code></a>.</p></dd><dt id="ECPG-INFORMIX-SQLDA-SQLTYPENAME"><span class="term"><code class="literal">sqltypename</code><br /></span><span class="term"><code class="literal">sqltypelen</code><br /></span><span class="term"><code class="literal">sqlownerlen</code><br /></span><span class="term"><code class="literal">sqlsourcetype</code><br /></span><span class="term"><code class="literal">sqlownername</code><br /></span><span class="term"><code class="literal">sqlsourceid</code><br /></span><span class="term"><code class="literal">sqlflags</code><br /></span><span class="term"><code class="literal">sqlreserved</code></span> <a href="#ECPG-INFORMIX-SQLDA-SQLTYPENAME" class="id_link">#</a></dt><dd><p>Не используются.</p></dd><dt id="ECPG-INFORMIX-SQLDA-SQLILONGDATA"><span class="term"><code class="literal">sqlilongdata</code></span> <a href="#ECPG-INFORMIX-SQLDA-SQLILONGDATA" class="id_link">#</a></dt><dd><p>Совпадает с <code class="literal">sqldata</code>, если <code class="literal">sqllen</code> превышает 32 Кбайта.</p></dd></dl></div><p> Например: </p><pre class="programlisting">EXEC SQL INCLUDE sqlda.h;

    sqlda_t        *sqlda; /* Это объявление не обязательно должно быть внутри DECLARE SECTION */

    EXEC SQL BEGIN DECLARE SECTION;
    char *prep_stmt = "select * from table1";
    int i;
    EXEC SQL END DECLARE SECTION;

    ...

    EXEC SQL PREPARE mystmt FROM :prep_stmt;

    EXEC SQL DESCRIBE mystmt INTO sqlda;

    printf("# of fields: %d\n", sqlda-&gt;sqld);
    for (i = 0; i &lt; sqlda-&gt;sqld; i++)
      printf("field %d: \"%s\"\n", sqlda-&gt;sqlvar[i]-&gt;sqlname);

    EXEC SQL DECLARE mycursor CURSOR FOR mystmt;
    EXEC SQL OPEN mycursor;
    EXEC SQL WHENEVER NOT FOUND GOTO out;

    while (1)
    {
      EXEC SQL FETCH mycursor USING sqlda;
    }

    EXEC SQL CLOSE mycursor;

    free(sqlda); /* Освобождать нужно только основную структуру,
                  * sqlda и sqlda-&gt;sqlvar находятся в одной выделенной области. */</pre><p> Дополнительную информацию можно найти в заголовочном файле <code class="literal">sqlda.h</code> и в регрессионном тесте <code class="literal">src/interfaces/ecpg/test/compat_informix/sqlda.pgc</code>.</p></div><div class="sect2" id="ECPG-INFORMIX-FUNCTIONS"><div class="titlepage"><div><div><h3 class="title">36.15.4. Дополнительные функции <a href="#ECPG-INFORMIX-FUNCTIONS" class="id_link">#</a></h3></div></div></div><p>
    </p><div class="variablelist"><dl class="variablelist"><dt id="ECPG-INFORMIX-FUNCTIONS-DECADD"><span class="term"><code class="function">decadd</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-DECADD" class="id_link">#</a></dt><dd><p>Складывает два значения типа decimal. </p><pre class="synopsis">
int decadd(decimal *arg1, decimal *arg2, decimal *sum);
</pre><p> Эта функция получает указатель на первый операнд типа decimal (<code class="literal">arg1</code>), указатель на второй операнд типа decimal (<code class="literal">arg2</code>) и указатель на переменную типа decimal, в которую будет записана сумма (<code class="literal">sum</code>). В случае успеха эта функция возвращает 0. <code class="symbol">ECPG_INFORMIX_NUM_OVERFLOW</code> возвращается в случае переполнения, а <code class="symbol">ECPG_INFORMIX_NUM_UNDERFLOW</code> в случае антипереполнения. При любых других ошибках возвращается -1, а в <code class="varname">errno</code> устанавливается код <code class="varname">errno</code> из pgtypeslib.</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-DECCMP"><span class="term"><code class="function">deccmp</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-DECCMP" class="id_link">#</a></dt><dd><p>Сравнивает два значения типа decimal. </p><pre class="synopsis">
int deccmp(decimal *arg1, decimal *arg2);
</pre><p> Эта функция получает указатель на первое значение типа decimal (<code class="literal">arg1</code>), указатель на второе значение типа decimal (<code class="literal">arg2</code>) и возвращает целое, отражающее результат сравнения этих чисел. </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>1, если значение, на которое указывает <code class="literal">arg1</code>, больше значения, на которое указывает <code class="literal">var2</code></p></li><li class="listitem"><p>-1, если значение, на которое указывает <code class="literal">arg1</code>, меньше значения, на которое указывает <code class="literal">arg2</code></p></li><li class="listitem"><p>0, если значение, на которое указывает <code class="literal">arg1</code>, равно значению, на которое указывает <code class="literal">arg2</code></p></li></ul></div></dd><dt id="ECPG-INFORMIX-FUNCTIONS-DECCOPY"><span class="term"><code class="function">deccopy</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-DECCOPY" class="id_link">#</a></dt><dd><p>Копирует значение типа decimal. </p><pre class="synopsis">
void deccopy(decimal *src, decimal *target);
</pre><p> Функция принимает в первом аргументе (<code class="literal">src</code>) указатель на значение decimal, которое должно быть скопировано, а во втором аргументе (<code class="literal">target</code>) принимает указатель на структуру типа decimal для скопированного значения.</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-DECCVASC"><span class="term"><code class="function">deccvasc</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-DECCVASC" class="id_link">#</a></dt><dd><p>Преобразует значение из представления ASCII в тип decimal. </p><pre class="synopsis">
int deccvasc(char *cp, int len, decimal *np);
</pre><p> Эта функция получает указатель на строку, содержащую строковое представление числа, которое нужно преобразовать, (<code class="literal">cp</code>), а также его длину <code class="literal">len</code>. В <code class="literal">np</code> передаётся указатель на переменную типа decimal, в которую будет помещён результат преобразования.</p><p>Допустимыми являются, например следующие форматы: <code class="literal">-2</code>, <code class="literal">.794</code>, <code class="literal">+3.44</code>, <code class="literal">592.49E07</code> или <code class="literal">-32.84e-4</code>.</p><p>В случае успеха эта функция возвращает 0. При переполнении или антипереполнении возвращается <code class="literal">ECPG_INFORMIX_NUM_OVERFLOW</code> или <code class="literal">ECPG_INFORMIX_NUM_UNDERFLOW</code>, соответственно. Если разобрать ASCII-представление не удаётся, возвращается <code class="literal">ECPG_INFORMIX_BAD_NUMERIC</code> или <code class="literal">ECPG_INFORMIX_BAD_EXPONENT</code>, если не удаётся разобрать компонент экспоненты.</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-DECCVDBL"><span class="term"><code class="function">deccvdbl</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-DECCVDBL" class="id_link">#</a></dt><dd><p>Преобразует значение double в значение типа decimal. </p><pre class="synopsis">
int deccvdbl(double dbl, decimal *np);
</pre><p> Данная функция принимает в первом аргументе (<code class="literal">dbl</code>) переменную типа double, которая должна быть преобразована. Во втором аргументе (<code class="literal">np</code>) она принимает указатель на переменную decimal, в которую будет помещён результат операции.</p><p>Эта функция возвращает 0 в случае успеха, либо отрицательное значение, если выполнить преобразование не удалось.</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-DECCVINT"><span class="term"><code class="function">deccvint</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-DECCVINT" class="id_link">#</a></dt><dd><p>Преобразует значение int в значение типа decimal. </p><pre class="synopsis">
int deccvint(int in, decimal *np);
</pre><p> Данная функция принимает в первом аргументе (<code class="literal">in</code>) переменную типа int, которая должна быть преобразована. Во втором аргументе (<code class="literal">np</code>) она принимает указатель на переменную decimal, в которую будет помещён результат операции.</p><p>Эта функция возвращает 0 в случае успеха, либо отрицательное значение, если выполнить преобразование не удалось.</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-DECCVLONG"><span class="term"><code class="function">deccvlong</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-DECCVLONG" class="id_link">#</a></dt><dd><p>Преобразует значение long в значение типа decimal. </p><pre class="synopsis">
int deccvlong(long lng, decimal *np);
</pre><p> Данная функция принимает в первом аргументе (<code class="literal">lng</code>) переменную типа long, которая должна быть преобразована. Во втором аргументе (<code class="literal">np</code>) она принимает указатель на переменную decimal, в которую будет помещён результат операции.</p><p>Эта функция возвращает 0 в случае успеха, либо отрицательное значение, если выполнить преобразование не удалось.</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-DECDIV"><span class="term"><code class="function">decdiv</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-DECDIV" class="id_link">#</a></dt><dd><p>Делит одну переменную типа decimal на другую. </p><pre class="synopsis">
int decdiv(decimal *n1, decimal *n2, decimal *result);
</pre><p> Эта функция получает указатели на переменные (<code class="literal">n1</code> и <code class="literal">n2</code>) и вычисляет частное <code class="literal">n1</code>/<code class="literal">n2</code>. В <code class="literal">result</code> передаётся указатель на переменную, в которую будет помещён результат операции.</p><p>В случае успеха возвращается 0, а при ошибке — отрицательное значение. В случае переполнения или антипереполнения данная функция возвращает <code class="literal">ECPG_INFORMIX_NUM_OVERFLOW</code> или <code class="literal">ECPG_INFORMIX_NUM_UNDERFLOW</code>, соответственно. При попытке деления на ноль возвращается <code class="literal">ECPG_INFORMIX_DIVIDE_ZERO</code>.</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-DECMUL"><span class="term"><code class="function">decmul</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-DECMUL" class="id_link">#</a></dt><dd><p>Перемножает два значения типа decimal. </p><pre class="synopsis">
int decmul(decimal *n1, decimal *n2, decimal *result);
</pre><p> Эта функция получает указатели на переменные (<code class="literal">n1</code> и <code class="literal">n2</code>) и вычисляет произведение <code class="literal">n1</code>*<code class="literal">n2</code>. В <code class="literal">result</code> передаётся указатель на переменную, в которую будет помещён результат операции.</p><p>В случае успеха возвращается 0, а при ошибке — отрицательное значение. В случае переполнения или антипереполнения данная функция возвращает <code class="literal">ECPG_INFORMIX_NUM_OVERFLOW</code> или <code class="literal">ECPG_INFORMIX_NUM_UNDERFLOW</code>, соответственно.</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-DECSUB"><span class="term"><code class="function">decsub</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-DECSUB" class="id_link">#</a></dt><dd><p>Вычитает одно значение типа decimal из другого. </p><pre class="synopsis">
int decsub(decimal *n1, decimal *n2, decimal *result);
</pre><p> Эта функция получает указатели на переменные (<code class="literal">n1</code> и <code class="literal">n2</code>) и вычисляет разность <code class="literal">n1</code>-<code class="literal">n2</code>. В <code class="literal">result</code> передаётся указатель на переменную, в которую будет помещён результат операции.</p><p>В случае успеха возвращается 0, а при ошибке — отрицательное значение. В случае переполнения или антипереполнения данная функция возвращает <code class="literal">ECPG_INFORMIX_NUM_OVERFLOW</code> или <code class="literal">ECPG_INFORMIX_NUM_UNDERFLOW</code>, соответственно.</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-DECTOASC"><span class="term"><code class="function">dectoasc</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-DECTOASC" class="id_link">#</a></dt><dd><p>Преобразует переменную типа decimal в представление ASCII (в строку C char*). </p><pre class="synopsis">
int dectoasc(decimal *np, char *cp, int len, int right)
</pre><p> Эта функция получает указатель на переменную типа decimal (<code class="literal">np</code>), которая будет преобразована в текстовое представление. Аргумент <code class="literal">cp</code> указывает на буфер, в который будет помещён результат операции. Аргумент <code class="literal">right</code> определяет, сколько должно выводиться цифр правее десятичной точки. Результат будет округлён до этого числа десятичных цифр. Значение <code class="literal">right</code>, равное -1, указывает, что выводиться должны все имеющиеся десятичные цифры. Если длина выходного буфера, которую задаёт <code class="literal">len</code>, недостаточна для помещения в него текстового представления, включая завершающий нулевой байт, в буфере сохраняется один знак <code class="literal">*</code> и возвращается -1.</p><p>Эта функция возвращает -1, если буфер <code class="literal">cp</code> слишком мал, либо <code class="literal">ECPG_INFORMIX_OUT_OF_MEMORY</code> при нехватке памяти.</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-DECTODBL"><span class="term"><code class="function">dectodbl</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-DECTODBL" class="id_link">#</a></dt><dd><p>Преобразует переменную типа decimal в тип double. </p><pre class="synopsis">
int dectodbl(decimal *np, double *dblp);
</pre><p> Эта функция получает указатель (<code class="literal">np</code>) на значение decimal, которое нужно преобразовать, и указатель (<code class="literal">dblp</code>) на переменную double, в которую будет помещён результат операции.</p><p>В случае успеха возвращается 0, или отрицательное значение, если выполнить преобразование не удалось.</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-DECTOINT"><span class="term"><code class="function">dectoint</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-DECTOINT" class="id_link">#</a></dt><dd><p>Преобразует переменную типа decimal в тип integer. </p><pre class="synopsis">
int dectoint(decimal *np, int *ip);
</pre><p> Эта функция получает указатель (<code class="literal">np</code>) на значение decimal, которое нужно преобразовать, и указатель (<code class="literal">ip</code>) на целочисленную переменную, в которую будет помещён результат операции.</p><p>В случае успеха возвращается 0, или отрицательное значение, если выполнить преобразование не удалось. В случае переполнения возвращается <code class="literal">ECPG_INFORMIX_NUM_OVERFLOW</code>.</p><p>Заметьте, что реализация ECPG отличается от реализации <span class="productname">Informix</span>. В <span class="productname">Informix</span> целое ограничивается диапазоном -32767 .. 32767, тогда как в ECPG ограничение зависит от архитектуры (<code class="literal">INT_MIN .. INT_MAX</code>).</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-DECTOLONG"><span class="term"><code class="function">dectolong</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-DECTOLONG" class="id_link">#</a></dt><dd><p>Преобразует переменную типа decimal в тип long. </p><pre class="synopsis">
int dectolong(decimal *np, long *lngp);
</pre><p> Эта функция получает указатель (<code class="literal">np</code>) на значение decimal, которое нужно преобразовать, и указатель (<code class="literal">lngp</code>) на переменную типа long, в которую будет помещён результат операции.</p><p>В случае успеха возвращается 0, или отрицательное значение, если выполнить преобразование не удалось. В случае переполнения возвращается <code class="literal">ECPG_INFORMIX_NUM_OVERFLOW</code>.</p><p>Заметьте, что реализация ECPG отличается от реализации <span class="productname">Informix</span>. В <span class="productname">Informix</span> длинное целое ограничено диапазоном -2 147 483 647 .. 2 147 483 647, тогда как в ECPG ограничение зависит от архитектуры (<code class="literal">-LONG_MAX .. LONG_MAX</code>).</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-RDATESTR"><span class="term"><code class="function">rdatestr</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-RDATESTR" class="id_link">#</a></dt><dd><p>Преобразует дату в строку C char*. </p><pre class="synopsis">
int rdatestr(date d, char *str);
</pre><p> Эта функция принимает два аргумента. В первом (<code class="literal">d</code>) передаётся дата, которую нужно преобразовать, а во втором указатель на целевую строку. Результат всегда выводится в формате <code class="literal">yyyy-mm-dd</code>, так что для этой строки нужно выделить минимум 11 байт (включая завершающий нулевой байт).</p><p>Эта функция возвращает 0 в случае успеха, а в случае ошибки — отрицательное значение.</p><p>Заметьте, что реализация ECPG отличается от реализации <span class="productname">Informix</span>. В <span class="productname">Informix</span> формат вывода можно изменить переменными окружения, а в ECPG он фиксирован.</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-RSTRDATE"><span class="term"><code class="function">rstrdate</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-RSTRDATE" class="id_link">#</a></dt><dd><p>Разбирает текстовое представление даты. </p><pre class="synopsis">
int rstrdate(char *str, date *d);
</pre><p> Эта функция получает текстовое представление (<code class="literal">str</code>) даты, которую нужно преобразовать, и указатель на переменную типа date (<code class="literal">d</code>). Для данной функции нельзя задать маску формата. Она использует стандартную маску формата <span class="productname">Informix</span>, а именно: <code class="literal">mm/dd/yyyy</code>. Внутри эта функция вызывает <code class="function">rdefmtdate</code>. Таким образом, <code class="function">rstrdate</code> не будет быстрее, и если у вас есть выбор, используйте функцию <code class="function">rdefmtdate</code>, которая позволяет явно задать маску формата.</p><p>Эта функция возвращает те же значения, что и <code class="function">rdefmtdate</code>.</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-RTODAY"><span class="term"><code class="function">rtoday</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-RTODAY" class="id_link">#</a></dt><dd><p>Выдаёт текущую дату. </p><pre class="synopsis">
void rtoday(date *d);
</pre><p> Эта функция получает указатель на переменную (<code class="literal">d</code>) типа date, в которую будет записана текущая дата.</p><p>Внутри эта функция вызывает <a class="xref" href="ecpg-pgtypes.html#PGTYPESDATETODAY"><code class="function">PGTYPESdate_today</code></a>.</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-RJULMDY"><span class="term"><code class="function">rjulmdy</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-RJULMDY" class="id_link">#</a></dt><dd><p>Извлекает значения дня, месяца и года из переменной типа date. </p><pre class="synopsis">
int rjulmdy(date d, short mdy[3]);
</pre><p> Эта функция получает дату <code class="literal">d</code> и указатель на 3 коротких целочисленных значения <code class="literal">mdy</code>. Имя переменной указывает на порядок значений: в <code class="literal">mdy[0]</code> записывается номер месяца, в <code class="literal">mdy[1]</code> — номер дня, а в <code class="literal">mdy[2]</code> — год.</p><p>В текущем состоянии эта функция всегда возвращает 0.</p><p>Внутри эта функция вызывает <a class="xref" href="ecpg-pgtypes.html#PGTYPESDATEJULMDY"><code class="function">PGTYPESdate_julmdy</code></a>.</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-RDEFMTDATE"><span class="term"><code class="function">rdefmtdate</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-RDEFMTDATE" class="id_link">#</a></dt><dd><p>Преобразует символьную строку в значение типа date по маске формата. </p><pre class="synopsis">
int rdefmtdate(date *d, char *fmt, char *str);
</pre><p> Эта функция принимает указатель на переменную типа date (<code class="literal">d</code>), в которую будет помещён результат операции, маску формата для разбора даты (<code class="literal">fmt</code>) и строку C char*, содержащую текстовое представление даты (<code class="literal">str</code>). Ожидается, что текстовое представление будет соответствовать маске формата. Однако это соответствие не обязательно должно быть точным. Данная функция анализирует только порядок элементов и ищет в нём подстроки <code class="literal">yy</code> или <code class="literal">yyyy</code>, обозначающие позицию года, подстроку <code class="literal">mm</code>, обозначающую позицию месяца, и <code class="literal">dd</code>, обозначающую позицию дня.</p><p>Эта функция возвращает следующие значения: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>0 — Функция выполнена успешно.</p></li><li class="listitem"><p><code class="literal">ECPG_INFORMIX_ENOSHORTDATE</code> — Дата не содержит разделителей между днём, месяцем и годом. С таким форматом входная строка должна быть длиной ровно 6 или 8 байт, но это не так.</p></li><li class="listitem"><p><code class="literal">ECPG_INFORMIX_ENOTDMY</code> — Строка формата не определяет корректно последовательный порядок года, месяца и дня.</p></li><li class="listitem"><p><code class="literal">ECPG_INFORMIX_BAD_DAY</code> — Во входной строке отсутствует корректное указание дня.</p></li><li class="listitem"><p><code class="literal">ECPG_INFORMIX_BAD_MONTH</code> — Во входной строке отсутствует корректное указание месяца.</p></li><li class="listitem"><p><code class="literal">ECPG_INFORMIX_BAD_YEAR</code> — Во входной строке отсутствует корректное указание года.</p></li></ul></div><p>В реализации этой функции вызывается <a class="xref" href="ecpg-pgtypes.html#PGTYPESDATEDEFMTASC"><code class="function">PGTYPESdate_defmt_asc</code></a>. Примеры вводимых строк приведены в таблице в её описании.</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-RFMTDATE"><span class="term"><code class="function">rfmtdate</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-RFMTDATE" class="id_link">#</a></dt><dd><p>Преобразует переменную типа date в текстовое представление по маске формата. </p><pre class="synopsis">
int rfmtdate(date d, char *fmt, char *str);
</pre><p> Эта функция принимает дату для преобразования (<code class="literal">d</code>), маску формата (<code class="literal">fmt</code>) и строку, в которую будет помещено текстовое представление даты (<code class="literal">str</code>).</p><p>В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.</p><p>Внутри эта функция вызывает <a class="xref" href="ecpg-pgtypes.html#PGTYPESDATEFMTASC"><code class="function">PGTYPESdate_fmt_asc</code></a>, примеры форматов можно найти в её описании.</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-RMDYJUL"><span class="term"><code class="function">rmdyjul</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-RMDYJUL" class="id_link">#</a></dt><dd><p>Образует значение даты из массива 3 коротких целых, задающих день, месяц и год даты. </p><pre class="synopsis">
int rmdyjul(short mdy[3], date *d);
</pre><p> Эта функция получает в первом аргументе массив из 3 коротких целых (<code class="literal">mdy</code>), а во втором указатель на переменную типа date, в которую будет помещён результат операции.</p><p>В настоящее время эта функция всегда возвращает 0.</p><p>В реализации этой функции вызывается <a class="xref" href="ecpg-pgtypes.html#PGTYPESDATEMDYJUL"><code class="function">PGTYPESdate_mdyjul</code></a>.</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-RDAYOFWEEK"><span class="term"><code class="function">rdayofweek</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-RDAYOFWEEK" class="id_link">#</a></dt><dd><p>Возвращает число, представляющее день недели для заданной даты. </p><pre class="synopsis">
int rdayofweek(date d);
</pre><p> Эта функция принимает в единственном аргументе переменную <code class="literal">d</code> типа date и возвращает целое число, выражающее день недели для этой даты. </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>0 — Воскресенье</p></li><li class="listitem"><p>1 — Понедельник</p></li><li class="listitem"><p>2 — Вторник</p></li><li class="listitem"><p>3 — Среда</p></li><li class="listitem"><p>4 — Четверг</p></li><li class="listitem"><p>5 — Пятница</p></li><li class="listitem"><p>6 — Суббота</p></li></ul></div><p>В реализации этой функции вызывается <a class="xref" href="ecpg-pgtypes.html#PGTYPESDATEDAYOFWEEK"><code class="function">PGTYPESdate_dayofweek</code></a>.</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-DTCURRENT"><span class="term"><code class="function">dtcurrent</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-DTCURRENT" class="id_link">#</a></dt><dd><p>Получает текущее время. </p><pre class="synopsis">
void dtcurrent(timestamp *ts);
</pre><p> Эта функция получает текущее время и сохраняет его в переменной типа timestamp, на которую указывает <code class="literal">ts</code>.</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-DTCVASC"><span class="term"><code class="function">dtcvasc</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-DTCVASC" class="id_link">#</a></dt><dd><p>Разбирает время из текстового представления в переменную типа timestamp. </p><pre class="synopsis">
int dtcvasc(char *str, timestamp *ts);
</pre><p> Эта функция получает строку (<code class="literal">str</code>), которую нужно разобрать, и указатель на переменную типа timestamp, в которую будет помещён результат операции (<code class="literal">ts</code>).</p><p>Эта функция возвращает 0 в случае успеха, а в случае ошибки — отрицательное значение.</p><p>Внутри эта функция вызывает <a class="xref" href="ecpg-pgtypes.html#PGTYPESTIMESTAMPFROMASC"><code class="function">PGTYPEStimestamp_from_asc</code></a>. Примеры вводимых строк приведены в таблице в её описании.</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-DTCVFMTASC"><span class="term"><code class="function">dtcvfmtasc</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-DTCVFMTASC" class="id_link">#</a></dt><dd><p>Разбирает время из текстового представления в переменную типа timestamp по маске формата. </p><pre class="synopsis">
dtcvfmtasc(char *inbuf, char *fmtstr, timestamp *dtvalue)
</pre><p> Эта функция получает строку (<code class="literal">inbuf</code>), которую нужно разобрать, маску формата (<code class="literal">fmtstr</code>) и указатель на переменную timestamp, в которой будет содержаться результат операции (<code class="literal">dtvalue</code>).</p><p>В реализации этой функции используется <a class="xref" href="ecpg-pgtypes.html#PGTYPESTIMESTAMPDEFMTASC"><code class="function">PGTYPEStimestamp_defmt_asc</code></a>. Список допустимых кодов формата приведён в её описании.</p><p>Эта функция возвращает 0 в случае успеха, а в случае ошибки — отрицательное значение.</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-DTSUB"><span class="term"><code class="function">dtsub</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-DTSUB" class="id_link">#</a></dt><dd><p>Вычитает одно значение времени из другого и возвращает переменную типа interval. </p><pre class="synopsis">
int dtsub(timestamp *ts1, timestamp *ts2, interval *iv);
</pre><p> Эта функция вычитает значение timestamp, на которое указывает <code class="literal">ts2</code>, из значения timestamp, на которое указывает <code class="literal">ts1</code>, и сохраняет результат в переменной типа interval, на которую указывает <code class="literal">iv</code>.</p><p>В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-DTTOASC"><span class="term"><code class="function">dttoasc</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-DTTOASC" class="id_link">#</a></dt><dd><p>Преобразует переменную типа timestamp в строку C char*. </p><pre class="synopsis">
int dttoasc(timestamp *ts, char *output);
</pre><p> Эта функция получает указатель (<code class="literal">ts</code>) на переменную типа timestamp, которую нужно преобразовать, и строку (<code class="literal">output</code>) для сохранения результата операции. Она преобразует <code class="literal">ts</code> в текстовое представление согласно стандарту SQL, то есть по маске <code class="literal">YYYY-MM-DD HH:MM:SS</code>.</p><p>В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-DTTOFMTASC"><span class="term"><code class="function">dttofmtasc</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-DTTOFMTASC" class="id_link">#</a></dt><dd><p>Преобразует переменную типа timestamp в строку C char* по маске формата. </p><pre class="synopsis">
int dttofmtasc(timestamp *ts, char *output, int str_len, char *fmtstr);
</pre><p> Эта функция получает в первом аргументе (<code class="literal">ts</code>) указатель на переменную типа timestamp, а в последующих указатель на буфер вывода (<code class="literal">output</code>), максимальную длину строки, которую может принять буфер (<code class="literal">str_len</code>), и маску формата, с которой будет выполняться преобразование (<code class="literal">fmtstr</code>).</p><p>В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.</p><p>Внутри эта функция использует <a class="xref" href="ecpg-pgtypes.html#PGTYPESTIMESTAMPFMTASC"><code class="function">PGTYPEStimestamp_fmt_asc</code></a>. Примеры допустимых масок формата можно найти в её описании.</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-INTOASC"><span class="term"><code class="function">intoasc</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-INTOASC" class="id_link">#</a></dt><dd><p>Преобразует переменную типа interval в строку C char*. </p><pre class="synopsis">
int intoasc(interval *i, char *str);
</pre><p> Эта функция получает указатель (<code class="literal">i</code>) на переменную типа interval, которую нужно преобразовать, и строку (<code class="literal">str</code>) для сохранения результата операции. Она преобразует <code class="literal">i</code> в текстовое представление согласно стандарту SQL, то есть по маске <code class="literal">YYYY-MM-DD HH:MM:SS</code>.</p><p>В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-RFMTLONG"><span class="term"><code class="function">rfmtlong</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-RFMTLONG" class="id_link">#</a></dt><dd><p>Преобразует длинное целое в текстовое представление по маске формата. </p><pre class="synopsis">
int rfmtlong(long lng_val, char *fmt, char *outbuf);
</pre><p> Эта функция принимает значение типа long (<code class="literal">lng_val</code>), маску формата (<code class="literal">fmt</code>) и указатель на выходной буфер (<code class="literal">outbuf</code>). Она преобразует длинное целое в его текстовое представление согласно заданной маске формата.</p><p>Маску формата можно составить из следующих символов, определяющих формат: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">*</code> (звёздочка) — если в данной позиции будет пусто, заполнить её звёздочкой.</p></li><li class="listitem"><p><code class="literal">&amp;</code> (амперсанд) — если в данной позиции будет пусто, заполнить её нулём.</p></li><li class="listitem"><p><code class="literal">#</code> — заменить ведущие нули пробелами.</p></li><li class="listitem"><p><code class="literal">&lt;</code> — выровнять число в строке по левой стороне.</p></li><li class="listitem"><p><code class="literal">,</code> (запятая) — сгруппировать числа, содержащие четыре и более цифр, в группы по три цифры через запятую.</p></li><li class="listitem"><p><code class="literal">.</code> (точка) — этот символ отделяет целую часть числа от дробной.</p></li><li class="listitem"><p><code class="literal">-</code> (минус) — с отрицательным числом должен выводиться знак минус.</p></li><li class="listitem"><p><code class="literal">+</code> (плюс) — с положительным числом должен выводиться знак плюс.</p></li><li class="listitem"><p><code class="literal">(</code> — это символ заменяет знак минус перед отрицательным числом. Сам знак минус выводиться не будет.</p></li><li class="listitem"><p><code class="literal">)</code> — этот символ заменяет минус и выводится после отрицательного числа.</p></li><li class="listitem"><p><code class="literal">$</code> — символ денежной суммы.</p></li></ul></div></dd><dt id="ECPG-INFORMIX-FUNCTIONS-RUPSHIFT"><span class="term"><code class="function">rupshift</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-RUPSHIFT" class="id_link">#</a></dt><dd><p>Приводит строку к верхнему регистру. </p><pre class="synopsis">
void rupshift(char *str);
</pre><p> Эта функция получает указатель на строку и приводит в ней каждый символ в нижнем регистре к верхнему регистру.</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-BYLENG"><span class="term"><code class="function">byleng</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-BYLENG" class="id_link">#</a></dt><dd><p>Возвращает число символов в строке, не считая завершающих пробелов. </p><pre class="synopsis">
int byleng(char *str, int len);
</pre><p> Эта функция принимает в первом аргументе (<code class="literal">str</code>) строку фиксированной длины, а во втором (<code class="literal">len</code>) её длину. Она возвращает число значимых символов, то есть длину строки без завершающих пробелов.</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-LDCHAR"><span class="term"><code class="function">ldchar</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-LDCHAR" class="id_link">#</a></dt><dd><p>Копирует строку фиксированной длины в строку с завершающим нулём. </p><pre class="synopsis">
void ldchar(char *src, int len, char *dest);
</pre><p> Эта функция принимает строку фиксированной длины (<code class="literal">src</code>), которую нужно скопировать, её длину (<code class="literal">len</code>) и указатель на целевой буфер в памяти (<code class="literal">dest</code>). Учтите, что для буфера, на который указывает <code class="literal">dest</code>, необходимо выделить как минимум <code class="literal">len+1</code> байт. Данная функция копирует в новую область не больше <code class="literal">len</code> байт (меньше, если в исходной строке есть завершающие пробелы) и добавляет завершающий 0.</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-RGETMSG"><span class="term"><code class="function">rgetmsg</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-RGETMSG" class="id_link">#</a></dt><dd><pre class="synopsis">
int rgetmsg(int msgnum, char *s, int maxsize);
</pre><p> Эта функция определена, но не реализована на данный момент!</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-RTYPALIGN"><span class="term"><code class="function">rtypalign</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-RTYPALIGN" class="id_link">#</a></dt><dd><pre class="synopsis">
int rtypalign(int offset, int type);
</pre><p> Эта функция определена, но не реализована на данный момент!</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-RTYPMSIZE"><span class="term"><code class="function">rtypmsize</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-RTYPMSIZE" class="id_link">#</a></dt><dd><pre class="synopsis">
int rtypmsize(int type, int len);
</pre><p> Эта функция определена, но не реализована на данный момент!</p></dd><dt id="ECPG-INFORMIX-FUNCTIONS-RTYPWIDTH"><span class="term"><code class="function">rtypwidth</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-RTYPWIDTH" class="id_link">#</a></dt><dd><pre class="synopsis">
int rtypwidth(int sqltype, int sqllen);
</pre><p> Эта функция определена, но не реализована на данный момент!</p></dd><dt id="RSETNULL"><span class="term"><code class="function">rsetnull</code></span> <a href="#RSETNULL" class="id_link">#</a></dt><dd><p>Присваивает переменной NULL. </p><pre class="synopsis">
int rsetnull(int t, char *ptr);
</pre><p> Эта функция получает целое, определяющее тип переменной, и указатель на саму переменную, приведённый к указателю C char*.</p><p>Определены следующие типы: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">CCHARTYPE</code> — для переменной типа <code class="type">char</code> или <code class="type">char*</code></p></li><li class="listitem"><p><code class="literal">CSHORTTYPE</code> — для переменной типа <code class="type">short int</code></p></li><li class="listitem"><p><code class="literal">CINTTYPE</code> — для переменной типа <code class="type">int</code></p></li><li class="listitem"><p><code class="literal">CBOOLTYPE</code> — для переменной типа <code class="type">boolean</code></p></li><li class="listitem"><p><code class="literal">CFLOATTYPE</code> — для переменной типа <code class="type">float</code></p></li><li class="listitem"><p><code class="literal">CLONGTYPE</code> — для переменной типа <code class="type">long</code></p></li><li class="listitem"><p><code class="literal">CDOUBLETYPE</code> — для переменной типа <code class="type">double</code></p></li><li class="listitem"><p><code class="literal">CDECIMALTYPE</code> — для переменной типа <code class="type">decimal</code></p></li><li class="listitem"><p><code class="literal">CDATETYPE</code> — для переменной типа <code class="type">date</code></p></li><li class="listitem"><p><code class="literal">CDTIMETYPE</code> — для переменной типа <code class="type">timestamp</code></p></li></ul></div><p>Примеры вызова этой функции: </p><pre class="programlisting">
$char c[] = "abc       ";
$short s = 17;
$int i = -74874;

rsetnull(CCHARTYPE, (char *) c);
rsetnull(CSHORTTYPE, (char *) &amp;s);
rsetnull(CINTTYPE, (char *) &amp;i);

</pre></dd><dt id="ECPG-INFORMIX-FUNCTIONS-RISNULL"><span class="term"><code class="function">risnull</code></span> <a href="#ECPG-INFORMIX-FUNCTIONS-RISNULL" class="id_link">#</a></dt><dd><p>Проверяет содержимое переменной на NULL. </p><pre class="synopsis">
int risnull(int t, char *ptr);
</pre><p> Эта функция получает тип проверяемой переменной (<code class="literal">t</code>), а также указатель на неё (<code class="literal">ptr</code>). Заметьте, что этот указатель нужно привести к char*. Список возможных типов переменных приведён в описании функции <a class="xref" href="ecpg-informix-compat.html#RSETNULL"><code class="function">rsetnull</code></a>.</p><p>Примеры использования этой функции: </p><pre class="programlisting">
$char c[] = "abc       ";
$short s = 17;
$int i = -74874;

risnull(CCHARTYPE, (char *) c);
risnull(CSHORTTYPE, (char *) &amp;s);
risnull(CINTTYPE, (char *) &amp;i);

</pre></dd></dl></div><p>
   </p></div><div class="sect2" id="ECPG-INFORMIX-CONSTANTS"><div class="titlepage"><div><div><h3 class="title">36.15.5. Дополнительные константы <a href="#ECPG-INFORMIX-CONSTANTS" class="id_link">#</a></h3></div></div></div><p>Заметьте, что все эти константы относятся к ошибкам и все они представлены отрицательными значениями. Из описаний различных констант вы также можете узнать, какими именно числами они представлены в текущей реализации. Однако полагаться на эти числа не следует. Тем не менее вы можете рассчитывать на то, что все эти значения будут отрицательными. </p><div class="variablelist"><dl class="variablelist"><dt id="ECPG-INFORMIX-CONSTANTS-ECPG-INFORMIX-NUM-OVERFLOW"><span class="term"><code class="literal">ECPG_INFORMIX_NUM_OVERFLOW</code></span> <a href="#ECPG-INFORMIX-CONSTANTS-ECPG-INFORMIX-NUM-OVERFLOW" class="id_link">#</a></dt><dd><p>Функции возвращают это значение, если при вычислении происходит переполнение. Внутри оно представляется числом -1200 (определение <span class="productname">Informix</span>).</p></dd><dt id="ECPG-INFORMIX-CONSTANTS-ECPG-INFORMIX-NUM-UNDERFLOW"><span class="term"><code class="literal">ECPG_INFORMIX_NUM_UNDERFLOW</code></span> <a href="#ECPG-INFORMIX-CONSTANTS-ECPG-INFORMIX-NUM-UNDERFLOW" class="id_link">#</a></dt><dd><p>Функции возвращают это значение, если при вычислении происходит антипереполнение. Внутри оно представляется числом -1201 (определение <span class="productname">Informix</span>).</p></dd><dt id="ECPG-INFORMIX-CONSTANTS-ECPG-INFORMIX-DIVIDE-ZERO"><span class="term"><code class="literal">ECPG_INFORMIX_DIVIDE_ZERO</code></span> <a href="#ECPG-INFORMIX-CONSTANTS-ECPG-INFORMIX-DIVIDE-ZERO" class="id_link">#</a></dt><dd><p>Функции возвращают это значение при попытке деления на ноль. Внутри оно представляется числом -1202 (определение <span class="productname">Informix</span>).</p></dd><dt id="ECPG-INFORMIX-CONSTANTS-ECPG-INFORMIX-BAD-YEAR"><span class="term"><code class="literal">ECPG_INFORMIX_BAD_YEAR</code></span> <a href="#ECPG-INFORMIX-CONSTANTS-ECPG-INFORMIX-BAD-YEAR" class="id_link">#</a></dt><dd><p>Функции возвращают это значение, если при разборе даты встретилось некорректное указание года. Внутри оно представляется числом -1204 (определение <span class="productname">Informix</span>).</p></dd><dt id="ECPG-INFORMIX-CONSTANTS-ECPG-INFORMIX-BAD-MONTH"><span class="term"><code class="literal">ECPG_INFORMIX_BAD_MONTH</code></span> <a href="#ECPG-INFORMIX-CONSTANTS-ECPG-INFORMIX-BAD-MONTH" class="id_link">#</a></dt><dd><p>Функции возвращают это значение, если при разборе даты встретилось некорректное указание месяца. Внутри оно представляется числом -1205 (определение <span class="productname">Informix</span>).</p></dd><dt id="ECPG-INFORMIX-CONSTANTS-ECPG-INFORMIX-BAD-DAY"><span class="term"><code class="literal">ECPG_INFORMIX_BAD_DAY</code></span> <a href="#ECPG-INFORMIX-CONSTANTS-ECPG-INFORMIX-BAD-DAY" class="id_link">#</a></dt><dd><p>Функции возвращают это значение, если при разборе даты встретилось некорректное указание дня. Внутри оно представляется числом -1206 (определение <span class="productname">Informix</span>).</p></dd><dt id="ECPG-INFORMIX-CONSTANTS-ECPG-INFORMIX-ENOSHORTDATE"><span class="term"><code class="literal">ECPG_INFORMIX_ENOSHORTDATE</code></span> <a href="#ECPG-INFORMIX-CONSTANTS-ECPG-INFORMIX-ENOSHORTDATE" class="id_link">#</a></dt><dd><p>Функции возвращают это значение, если процедуре разбора даты требуется короткая запись даты, но строка даты имеет неподходящую длину. Внутри оно представляется числом -1209 (определение <span class="productname">Informix</span>).</p></dd><dt id="ECPG-INFORMIX-CONSTANTS-ECPG-INFORMIX-DATE-CONVERT"><span class="term"><code class="literal">ECPG_INFORMIX_DATE_CONVERT</code></span> <a href="#ECPG-INFORMIX-CONSTANTS-ECPG-INFORMIX-DATE-CONVERT" class="id_link">#</a></dt><dd><p>Функции возвращают это значение, если при форматировании даты происходит ошибка. Внутри оно представляется числом -1210 (определение <span class="productname">Informix</span>).</p></dd><dt id="ECPG-INFORMIX-CONSTANTS-ECPG-INFORMIX-OUT-OF-MEMORY"><span class="term"><code class="literal">ECPG_INFORMIX_OUT_OF_MEMORY</code></span> <a href="#ECPG-INFORMIX-CONSTANTS-ECPG-INFORMIX-OUT-OF-MEMORY" class="id_link">#</a></dt><dd><p>Функции возвращают это значение, если им не хватает памяти для выполнения операций. Внутри оно представляется числом -1211 (определение <span class="productname">Informix</span>).</p></dd><dt id="ECPG-INFORMIX-CONSTANTS-ECPG-INFORMIX-ENOTDMY"><span class="term"><code class="literal">ECPG_INFORMIX_ENOTDMY</code></span> <a href="#ECPG-INFORMIX-CONSTANTS-ECPG-INFORMIX-ENOTDMY" class="id_link">#</a></dt><dd><p>Функции возвращают это значение, если процедура разбора должна была получить маску формата (например, <code class="literal">mmddyy</code>), но не все поля были записаны правильно. Внутри оно представляется числом -1212 (определение <span class="productname">Informix</span>).</p></dd><dt id="ECPG-INFORMIX-CONSTANTS-ECPG-INFORMIX-BAD-NUMERIC"><span class="term"><code class="literal">ECPG_INFORMIX_BAD_NUMERIC</code></span> <a href="#ECPG-INFORMIX-CONSTANTS-ECPG-INFORMIX-BAD-NUMERIC" class="id_link">#</a></dt><dd><p>Функции возвращают это значение, если процедура разбора не может получить числовое значение из текстового представления, потому что оно некорректно, либо если процедура вычисления не может произвести операцию с числовыми переменными из-за недопустимого значения минимум одной из этих переменных. Внутри оно представляется числом -1213 (определение <span class="productname">Informix</span>).</p></dd><dt id="ECPG-INFORMIX-CONSTANTS-ECPG-INFORMIX-BAD-EXPONENT"><span class="term"><code class="literal">ECPG_INFORMIX_BAD_EXPONENT</code></span> <a href="#ECPG-INFORMIX-CONSTANTS-ECPG-INFORMIX-BAD-EXPONENT" class="id_link">#</a></dt><dd><p>Функции возвращают это значение, если процедура разбора не может воспринять экспоненту в числе. Внутри оно представляется числом -1216 (определение <span class="productname">Informix</span>).</p></dd><dt id="ECPG-INFORMIX-CONSTANTS-ECPG-INFORMIX-BAD-DATE"><span class="term"><code class="literal">ECPG_INFORMIX_BAD_DATE</code></span> <a href="#ECPG-INFORMIX-CONSTANTS-ECPG-INFORMIX-BAD-DATE" class="id_link">#</a></dt><dd><p>Функции возвращают это значение, если процедура разбора не может разобрать дату. Внутри оно представляется числом -1218 (определение <span class="productname">Informix</span>).</p></dd><dt id="ECPG-INFORMIX-CONSTANTS-ECPG-INFORMIX-EXTRA-CHARS"><span class="term"><code class="literal">ECPG_INFORMIX_EXTRA_CHARS</code></span> <a href="#ECPG-INFORMIX-CONSTANTS-ECPG-INFORMIX-EXTRA-CHARS" class="id_link">#</a></dt><dd><p>Функции возвращают это значение, если процедуре разбора передаются посторонние символы, которая она не может разобрать. Внутри оно представляется числом -1264 (определение <span class="productname">Informix</span>).</p></dd></dl></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ecpg-sql-whenever.html" title="WHENEVER">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="ecpg.html" title="Глава 36. ECPG — Встраиваемый SQL в C">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="ecpg-oracle-compat.html" title="36.16. Режим совместимости с Oracle">След.</a></td></tr><tr><td width="40%" align="left" valign="top">WHENEVER </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 36.16. Режим совместимости с <span class="productname">Oracle</span></td></tr></table></div></body></html>