<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>46.6. Обращение к базе данных</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="plpython-trigger.html" title="46.5. Триггерные функции" /><link rel="next" href="plpython-subtransaction.html" title="46.7. Явные подтранзакции" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">46.6. Обращение к базе данных</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="plpython-trigger.html" title="46.5. Триггерные функции">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="plpython.html" title="Глава 46. PL/Python — процедурный язык Python">Наверх</a></td><th width="60%" align="center">Глава 46. PL/Python — процедурный язык Python</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="plpython-subtransaction.html" title="46.7. Явные подтранзакции">След.</a></td></tr></table><hr /></div><div class="sect1" id="PLPYTHON-DATABASE"><div class="titlepage"><div><div><h2 class="title" style="clear: both">46.6. Обращение к базе данных <a href="#PLPYTHON-DATABASE" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="plpython-database.html#PLPYTHON-DATABASE-ACCESS-FUNCS">46.6.1. Функции обращения к базе данных</a></span></dt><dt><span class="sect2"><a href="plpython-database.html#PLPYTHON-TRAPPING">46.6.2. Обработка ошибок</a></span></dt></dl></div><p>Исполнитель языка PL/Python автоматически импортирует модуль Python с именем <code class="literal">plpy</code>. Вы в своём коде можете использовать функции и константы, объявленные в этом модуле, обращаясь к ним по именам вида <code class="literal">plpy.<em class="replaceable"><code>имя</code></em></code>.</p><div class="sect2" id="PLPYTHON-DATABASE-ACCESS-FUNCS"><div class="titlepage"><div><div><h3 class="title">46.6.1. Функции обращения к базе данных <a href="#PLPYTHON-DATABASE-ACCESS-FUNCS" class="id_link">#</a></h3></div></div></div><p>Модуль <code class="literal">plpy</code> содержит различные функции для выполнения команд в базе данных:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">plpy.<code class="function">execute</code>(<em class="replaceable"><code>запрос</code></em> [, <em class="replaceable"><code>предел</code></em>])</code></span></dt><dd><p>При вызове <code class="function">plpy.execute</code> со строкой запроса и необязательным аргументом, ограничивающим число строк, выполняется заданный запрос, а то, что он выдаёт, возвращается в виде объекта результата.</p><p>Если <em class="replaceable"><code>предел</code></em> задан и больше нуля, то <code class="function">plpy.execute</code> получает число строк, не превышающее <em class="replaceable"><code>предел</code></em>, как если бы запрос включал предложение <code class="literal">LIMIT</code>. Без указания <em class="replaceable"><code>предела</code></em> или когда он равен нулю ограничение на количество строк снимается.</p><p>Объект результата имитирует список или словарь. Получить из него данные можно по номеру строки и имени столбца. Например, команда: </p><pre class="programlisting">rv = plpy.execute("SELECT * FROM my_table", 5)</pre><p> вернёт не более 5 строк из отношения <code class="literal">my_table</code>. Если в <code class="literal">my_table</code> есть столбец <code class="literal">my_column</code>, к нему можно обратиться так: </p><pre class="programlisting">foo = rv[i]["my_column"]</pre><p> Число возвращённых в этом объекте строк можно получить, воспользовавшись встроенной функцией <code class="function">len</code>.</p><p>Для объекта результата определены следующие дополнительные методы: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal"><code class="function">nrows</code>()</code></span></dt><dd><p>Возвращает число строк, обработанных командой. Заметьте, что это число не обязательно будет равно числу возвращённых строк. Например, команда <code class="command">UPDATE</code> устанавливает это значение, но не возвращает строк (без указания <code class="literal">RETURNING</code>).</p></dd><dt><span class="term"><code class="literal"><code class="function">status</code>()</code></span></dt><dd><p>Значение состояния, возвращённое <code class="function">SPI_execute()</code>.</p></dd><dt><span class="term"><code class="literal"><code class="function">colnames</code>()</code><br /></span><span class="term"><code class="literal"><code class="function">coltypes</code>()</code><br /></span><span class="term"><code class="literal"><code class="function">coltypmods</code>()</code></span></dt><dd><p>Возвращают список имён столбцов, список OID типов столбцов и список модификаторов типа этих столбцов, соответственно.</p><p>Эти методы вызывают исключение, когда им передаётся объект, полученный от команды, не возвращающей результирующий набор, например, <code class="command">UPDATE</code> без <code class="literal">RETURNING</code>, либо <code class="command">DROP TABLE</code>. Но эти методы вполне можно использовать с результатом, содержащим ноль строк.</p></dd><dt><span class="term"><code class="literal"><code class="function">__str__</code>()</code></span></dt><dd><p>Стандартный метод <code class="literal">__str__</code> определён так, чтобы можно было, например, вывести отладочное сообщение с результатами запроса, вызвав <code class="literal">plpy.debug(rv)</code>.</p></dd></dl></div><p>Объект результата может быть изменён.</p><p>Заметьте, что при вызове <code class="literal">plpy.execute</code> весь набор результатов будет прочитан в память. Эту функцию следует использовать, только если вы знаете, что набор будет относительно небольшим. Если вы хотите исключить риск переполнения памяти при выборке результатов большого объёма, используйте <code class="literal">plpy.cursor</code> вместо <code class="literal">plpy.execute</code>.</p></dd><dt><span class="term"><code class="literal">plpy.<code class="function">prepare</code>(<em class="replaceable"><code>запрос</code></em> [, <em class="replaceable"><code>типы_аргументов</code></em>])</code><br /></span><span class="term"><code class="literal">plpy.<code class="function">execute</code>(<em class="replaceable"><code>план</code></em> [, <em class="replaceable"><code>аргументы</code></em> [, <em class="replaceable"><code>предел</code></em>]])</code></span></dt><dd><p><a id="id-1.8.11.14.3.3.2.3.1.1" class="indexterm"></a> Функция <code class="function">plpy.prepare</code> подготавливает план выполнения для запроса. Она вызывается со строкой запроса и списком типов параметров (если в запросе есть параметры). Например: </p><pre class="programlisting">plan = plpy.prepare("SELECT last_name FROM my_users WHERE first_name = $1", ["text"])</pre><p> Здесь <code class="literal">text</code> представляет переменную, передаваемую в качестве параметра <code class="literal">$1</code>. Второй аргумент необязателен, если запросу не нужно передавать никакие параметры.</p><p>Чтобы запустить подготовленный оператор на выполнение, используйте вариацию функции <code class="function">plpy.execute</code>: </p><pre class="programlisting">rv = plpy.execute(plan, ["name"], 5)</pre><p> Передайте план в первом аргументе (вместо строки запроса), а список значений, которые будут подставлены в запрос, — во втором. Второй аргумент можно опустить, если запрос не принимает никакие параметры. Третий аргумент, как и раньше, задаёт необязательное ограничение максимального числа строк.</p><p>Вы также можете вызвать метод <code class="function">execute</code> объекта плана: </p><pre class="programlisting">rv = plan.execute(["name"], 5)</pre><p>Параметры запросов и поля строк результата преобразуются между типами данных PostgreSQL и Python как описано в <a class="xref" href="plpython-data.html" title="46.2. Значения данных">Разделе 46.2</a>.</p><p>Когда вы подготавливаете план, используя модуль PL/Python, он сохраняется автоматически. Что это означает, вы можете узнать в документации SPI (<a class="xref" href="spi.html" title="Глава 47. Интерфейс программирования сервера">Глава 47</a>). Чтобы эффективно использовать это в нескольких вызовах функции, может потребоваться применить словарь постоянного хранения <code class="literal">SD</code> или <code class="literal">GD</code> (см. <a class="xref" href="plpython-sharing.html" title="46.3. Совместное использование данных">Раздел 46.3</a>). Например: </p><pre class="programlisting">CREATE FUNCTION usesavedplan() RETURNS trigger AS $$
    if "plan" in SD:
        plan = SD["plan"]
    else:
        plan = plpy.prepare("SELECT 1")
        SD["plan"] = plan
    # остальной код функции
$$ LANGUAGE plpython3u;</pre></dd><dt><span class="term"><code class="literal">plpy.<code class="function">cursor</code>(<em class="replaceable"><code>запрос</code></em>)</code><br /></span><span class="term"><code class="literal">plpy.<code class="function">cursor</code>(<em class="replaceable"><code>план</code></em> [, <em class="replaceable"><code>аргументы</code></em>])</code></span></dt><dd><p>Функция <code class="literal">plpy.cursor</code> принимает те же аргументы, что и <code class="literal">plpy.execute</code> (кроме ограничения строк) и возвращает объект курсора, который позволяет обрабатывать объёмные наборы результатов небольшими порциями. Как и <code class="literal">plpy.execute</code>, этой функции можно передать строку запроса или объект плана со списком аргументов, а можно вызывать функцию <code class="function">cursor</code> как метод объекта плана.</p><p>Объект курсора реализует метод <code class="literal">fetch</code>, который принимает целочисленный параметр и возвращает объект результата. При каждом следующем вызове <code class="literal">fetch</code> возвращаемый объект будет содержать следующий набор строк, в количестве, не превышающем значение параметра. Когда строки закончатся, <code class="literal">fetch</code> начнёт возвращать пустой объект результата. Объекты курсора также предоставляют <a class="ulink" href="https://docs.python.org/library/stdtypes.html#iterator-types" target="_top">интерфейс итератора</a>, выдающий по строке за один раз, пока не будут выданы все строки. Данные, выбираемые таким образом, возвращаются не как объекты результата, а как словари (одной строке результата соответствует один словарь).</p><p>Следующий пример демонстрирует обработку содержимого большой таблицы двумя способами: </p><pre class="programlisting">CREATE FUNCTION count_odd_iterator() RETURNS integer AS $$
odd = 0
for row in plpy.cursor("select num from largetable"):
    if row['num'] % 2:
         odd += 1
return odd
$$ LANGUAGE plpython3u;

CREATE FUNCTION count_odd_fetch(batch_size integer) RETURNS integer AS $$
odd = 0
cursor = plpy.cursor("select num from largetable")
while True:
    rows = cursor.fetch(batch_size)
    if not rows:
        break
    for row in rows:
        if row['num'] % 2:
            odd += 1
return odd
$$ LANGUAGE plpython3u;

CREATE FUNCTION count_odd_prepared() RETURNS integer AS $$
odd = 0
plan = plpy.prepare("select num from largetable where num % $1 &lt;&gt; 0", ["integer"])
rows = list(plpy.cursor(plan, [2]))  # или: = list(plan.cursor([2]))

return len(rows)
$$ LANGUAGE plpython3u;</pre><p>Курсоры ликвидируются автоматически. Но если вы хотите явно освободить все ресурсы, занятые курсором, вызовите метод <code class="literal">close</code>. Продолжать получать данные через курсор, который был закрыт, нельзя.</p><div class="tip"><h3 class="title">Подсказка</h3><p>Не путайте объекты, создаваемые функцией <code class="literal">plpy.cursor</code>, с курсорами DB-API, определёнными в <a class="ulink" href="https://www.python.org/dev/peps/pep-0249/" target="_top">спецификации API для работы с базами данных в Python</a>. Они не имеют ничего общего, кроме имени.</p></div></dd></dl></div></div><div class="sect2" id="PLPYTHON-TRAPPING"><div class="titlepage"><div><div><h3 class="title">46.6.2. Обработка ошибок <a href="#PLPYTHON-TRAPPING" class="id_link">#</a></h3></div></div></div><p>Функции, обращающиеся к базе данных, могут сталкиваться с ошибками, в результате которых они будут прерываться и вызывать исключение. Обе функции <code class="function">plpy.execute</code> и <code class="function">plpy.prepare</code> могут вызывать экземпляр подкласса исключения <code class="literal">plpy.SPIError</code>, которое по умолчание прекращает выполнение функции. Эту ошибку можно обработать, как и любое другое исключение в Python, применив конструкцию <code class="literal">try/except</code>. Например: </p><pre class="programlisting">CREATE FUNCTION try_adding_joe() RETURNS text AS $$
    try:
        plpy.execute("INSERT INTO users(username) VALUES ('joe')")
    except plpy.SPIError:
        return "something went wrong"
    else:
        return "Joe added"
$$ LANGUAGE plpython3u;</pre><p>Фактический класс вызываемого исключения соответствует определённому условию возникновения ошибки. Список всех возможных условий приведён в <a class="xref" href="errcodes-appendix.html#ERRCODES-TABLE" title="Таблица A.1. Коды ошибок PostgreSQL">Таблице A.1</a>. В модуле <code class="literal">plpy.spiexceptions</code> определяются классы исключений для каждого условия <span class="productname">PostgreSQL</span>, с именами, производными от имён условий. Например, имя <code class="literal">division_by_zero</code> становится именем <code class="literal">DivisionByZero</code>, <code class="literal">unique_violation</code> — именем <code class="literal">UniqueViolation</code>, <code class="literal">fdw_error</code> — именем <code class="literal">FdwError</code> и т. д. Все эти классы исключений наследуются от <code class="literal">SPIError</code>. Такое разделение на классы упрощает обработку определённых ошибок, например: </p><pre class="programlisting">CREATE FUNCTION insert_fraction(numerator int, denominator int) RETURNS text AS $$
from plpy import spiexceptions
try:
    plan = plpy.prepare("INSERT INTO fractions (frac) VALUES ($1 / $2)", ["int", "int"])
    plpy.execute(plan, [numerator, denominator])
except spiexceptions.DivisionByZero:
    return "denominator cannot equal zero"
except spiexceptions.UniqueViolation:
    return "already have that fraction"
except plpy.SPIError as e:
    return "other error, SQLSTATE %s" % e.sqlstate
else:
    return "fraction inserted"
$$ LANGUAGE plpython3u;</pre><p> Заметьте, что так как все исключения из модуля <code class="literal">plpy.spiexceptions</code> наследуются от исключения <code class="literal">SPIError</code>, команда <code class="literal">except</code>, обрабатывающая это исключение, будет перехватывать все ошибки при обращении к базе данных.</p><p>В качестве другого варианта обработки различных условий ошибок, вы можете перехватывать исключение <code class="literal">SPIError</code> и определять конкретное условие ошибки внутри блока <code class="literal">except</code> по значению атрибута <code class="literal">sqlstate</code> объекта исключения. Этот атрибут содержит строку с кодом ошибки <span class="quote">«<span class="quote">SQLSTATE</span>»</span>. Конечный результат при таком подходе примерно тот же.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="plpython-trigger.html" title="46.5. Триггерные функции">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="plpython.html" title="Глава 46. PL/Python — процедурный язык Python">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="plpython-subtransaction.html" title="46.7. Явные подтранзакции">След.</a></td></tr><tr><td width="40%" align="left" valign="top">46.5. Триггерные функции </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 46.7. Явные подтранзакции</td></tr></table></div></body></html>