<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>56.4. Различные соглашения по оформлению кода</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="error-style-guide.html" title="56.3. Руководство по стилю сообщений об ошибках" /><link rel="next" href="nls.html" title="Глава 57. Языковая поддержка" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">56.4. Различные соглашения по оформлению кода</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="error-style-guide.html" title="56.3. Руководство по стилю сообщений об ошибках">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="source.html" title="Глава 56. Соглашения по оформлению кода PostgreSQL">Наверх</a></td><th width="60%" align="center">Глава 56. Соглашения по оформлению кода PostgreSQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="nls.html" title="Глава 57. Языковая поддержка">След.</a></td></tr></table><hr /></div><div class="sect1" id="SOURCE-CONVENTIONS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">56.4. Различные соглашения по оформлению кода <a href="#SOURCE-CONVENTIONS" class="id_link">#</a></h2></div></div></div><div class="simplesect" id="SOURCE-CONVENTIONS-C-STANDARD"><div class="titlepage"><div><div><h3 class="title">56.4.1. Стандарт C <a href="#SOURCE-CONVENTIONS-C-STANDARD" class="id_link">#</a></h3></div></div></div><p>Код в <span class="productname">PostgreSQL</span> должен использовать только те возможности языка, что описаны в стандарте C99. Это означает, что код postgres должен успешно компилироваться компилятором, поддерживающим C99, возможно, за исключением нескольких платформозависимых мест.</p><p>Некоторые возможности, вошедшие в стандарт C99, в настоящее время использовать в коде ядра <span class="productname">PostgreSQL</span> нельзя. В данный момент это массивы переменного размера, перемежающиеся с кодом объявления, комментарии <code class="literal">//</code> и универсальные символьные имена. Данный запрет объясняется соображениями переносимости и исторически сложившейся практикой.</p><p>Возможности более поздних ревизий стандарта C или специфические особенности компилятора могут использоваться, только если предусмотрен и вариант компиляции без них.</p><p>Например, в настоящее время используются конструкции <code class="literal">_Static_assert()</code> и <code class="literal">__builtin_constant_p</code>, хотя они относятся к более новым ревизиям стандарта C и расширению <span class="productname">GCC</span>, соответственно. Но если они недоступны, мы переходим к совместимой с C99 замене, которая выполняет те же проверки, но выдаёт довольно непонятные сообщения, и не используем <code class="literal">__builtin_constant_p</code>.</p></div><div class="simplesect" id="SOURCE-CONVENTIONS-MACROS-INLINE"><div class="titlepage"><div><div><h3 class="title">56.4.2. Внедрённые функции и макросы, подобные функциям <a href="#SOURCE-CONVENTIONS-MACROS-INLINE" class="id_link">#</a></h3></div></div></div><p>Допускается использование и макросов с аргументами, и функций <code class="literal">static inline</code>. Последний вариант предпочтительнее, если возникает риск множественного вычисления выражений в макросе, как например в случае с </p><pre class="programlisting">#define Max(x, y)       ((x) &gt; (y) ? (x) : (y))</pre><p> или когда макрос может быть слишком объёмным. В других случаях использовать макросы — единственный, или как минимум более простой вариант. Например, может быть полезна возможность передавать макросу выражения различных типов.</p><p>Когда определение внедрённой функции обращается к символам (переменным, функциям), доступным только в серверном коде, такая функция не должна быть видна при включении в клиентский код. </p><pre class="programlisting">#ifndef FRONTEND
static inline MemoryContext
MemoryContextSwitchTo(MemoryContext context)
{
    MemoryContext old = CurrentMemoryContext;

    CurrentMemoryContext = context;
    return old;
}
#endif   /* FRONTEND */</pre><p> В этом примере вызывается функция <code class="literal">CurrentMemoryContext</code>, существующая только на стороне сервера, и поэтому функция скрыта директивой <code class="literal">#ifndef FRONTEND</code>. Это правило введено, потому что некоторые компиляторы генерируют указатели на символы, фигурирующие во внедрённых функциях, даже когда эти функции не используются.</p></div><div class="simplesect" id="SOURCE-CONVENTIONS-SIGNAL-HANDLERS"><div class="titlepage"><div><div><h3 class="title">56.4.3. Написание обработчиков сигналов <a href="#SOURCE-CONVENTIONS-SIGNAL-HANDLERS" class="id_link">#</a></h3></div></div></div><p>Чтобы код мог выполняться внутри обработчика сигналов, его нужно написать очень аккуратно. Фундаментальная сложность состоит в том, что обработчик сигнала может прервать код в любой момент, если он не отключён. Если код внутри обработчика сигнала использует то же состояние, что и внешний основной код, это может привести к хаосу. В качестве примера представьте, что произойдёт, если обработчик сигнала попытается получить ту же блокировку, которой уже владеет прерванный код.</p><p>Если не предпринимать специальных мер, код в обработчиках сигналов может вызывать только безопасные с точки зрения асинхронных сигналов функции (как это определяется в POSIX) и обращаться к переменным типа <code class="literal">volatile sig_atomic_t</code>. Также безопасными для обработчиков сигналов считаются несколько функций в <code class="command">postgres</code>, в том числе, что важно, <code class="function">SetLatch()</code>.</p><p>В большинстве случаев обработчики событий должны только сообщить о поступлении сигнала и пробудить код снаружи обработчика, используя защёлку. Например, обработчик может быть таким: </p><pre class="programlisting">static void
handle_sighup(SIGNAL_ARGS)
{
    int         save_errno = errno;

    got_SIGHUP = true;
    SetLatch(MyLatch);

    errno = save_errno;
}</pre><p> Переменная <code class="varname">errno</code> сохраняется и восстанавливается, так как её может изменить <code class="function">SetLatch()</code>. Если этого не сделать, прерванный код, считывая <code class="varname">errno</code>, мог бы получить некорректное значение.</p></div><div class="simplesect" id="SOURCE-CONVENTIONS-FUNCTION-POINTERS"><div class="titlepage"><div><div><h3 class="title">56.4.4. Вызов функций по указателям <a href="#SOURCE-CONVENTIONS-FUNCTION-POINTERS" class="id_link">#</a></h3></div></div></div><p>Вызов функции по указателю может записываться по-разному. Ясности ради, когда указатель на функцию — простая переменная, предпочтительным вариантом считается запись с явным разыменованием указателя, например: </p><pre class="programlisting">(*emit_log_hook) (edata);</pre><p> (хотя будет работать и просто <code class="literal">emit_log_hook(edata)</code>). Когда указатель на функции является частью структуры, дополнительные знаки пунктуации можно и обычно даже нужно опускать, например: </p><pre class="programlisting">paramInfo-&gt;paramFetch(paramInfo, paramId);</pre></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="error-style-guide.html" title="56.3. Руководство по стилю сообщений об ошибках">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="source.html" title="Глава 56. Соглашения по оформлению кода PostgreSQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="nls.html" title="Глава 57. Языковая поддержка">След.</a></td></tr><tr><td width="40%" align="left" valign="top">56.3. Руководство по стилю сообщений об ошибках </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> Глава 57. Языковая поддержка</td></tr></table></div></body></html>