<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>28.5. Динамическая трассировка</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="progress-reporting.html" title="28.4. Отслеживание выполнения" /><link rel="next" href="diskusage.html" title="Глава 29. Мониторинг использования диска" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">28.5. Динамическая трассировка</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="progress-reporting.html" title="28.4. Отслеживание выполнения">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="monitoring.html" title="Глава 28. Мониторинг работы СУБД">Наверх</a></td><th width="60%" align="center">Глава 28. Мониторинг работы СУБД</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="diskusage.html" title="Глава 29. Мониторинг использования диска">След.</a></td></tr></table><hr /></div><div class="sect1" id="DYNAMIC-TRACE"><div class="titlepage"><div><div><h2 class="title" style="clear: both">28.5. Динамическая трассировка <a href="#DYNAMIC-TRACE" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="dynamic-trace.html#COMPILING-FOR-TRACE">28.5.1. Компиляция для включения динамической трассировки</a></span></dt><dt><span class="sect2"><a href="dynamic-trace.html#TRACE-POINTS">28.5.2. Встроенные точки трассировки</a></span></dt><dt><span class="sect2"><a href="dynamic-trace.html#USING-TRACE-POINTS">28.5.3. Использование точек трассировки</a></span></dt><dt><span class="sect2"><a href="dynamic-trace.html#DEFINING-TRACE-POINTS">28.5.4. Задание новых точек трассировки</a></span></dt></dl></div><a id="id-1.6.15.10.2" class="indexterm"></a><p><span class="productname">PostgreSQL</span> позволяет выполнять динамическую трассировку сервера базы данных. Имеющиеся возможности позволяют вызывать внешнюю утилиту в определённых точках кода и таким образом отслеживать его выполнение.</p><p>Несколько подобных точек сбора метрик, или точек трассировки, уже встроено в исходный код. Предполагается, что эти точки будут использоваться разработчиками и администраторами базы данных. По умолчанию точки трассировки не входят в сборку <span class="productname">PostgreSQL</span>; пользователь должен явно указать конфигурационному скрипту необходимость включения этих макросов.</p><p>В настоящее время поддерживается только утилита <a class="ulink" href="https://en.wikipedia.org/wiki/DTrace" target="_top">DTrace</a>, которая доступна для Solaris, macOS, FreeBSD, NetBSD и Oracle Linux. Проект <a class="ulink" href="http://sourceware.org/systemtap/" target="_top">SystemTap</a> для Linux представляет собой эквивалент DTrace и также может быть использован. Теоретически возможна поддержка и других утилит динамической трассировки, для этого необходимо изменить определения для макроса в <code class="filename">src/include/utils/probes.h</code>.</p><div class="sect2" id="COMPILING-FOR-TRACE"><div class="titlepage"><div><div><h3 class="title">28.5.1. Компиляция для включения динамической трассировки <a href="#COMPILING-FOR-TRACE" class="id_link">#</a></h3></div></div></div><p>По умолчанию точки трассировки недоступны, поэтому в конфигурационном скрипте <span class="productname">PostgreSQL</span> требуется явно указать необходимость их подключения. Для поддержки утилиты DTrace укажите <code class="option">--enable-dtrace</code> в конфигурационном файле. Более подробно смотрите <a class="xref" href="install-make.html#CONFIGURE-OPTIONS-DEVEL" title="17.3.3.6. Параметры для разработчиков">Подраздел 17.3.3.6</a>.</p></div><div class="sect2" id="TRACE-POINTS"><div class="titlepage"><div><div><h3 class="title">28.5.2. Встроенные точки трассировки <a href="#TRACE-POINTS" class="id_link">#</a></h3></div></div></div><p>В исходный код входит несколько стандартных точек трассировки, которые представлены в <a class="xref" href="dynamic-trace.html#DTRACE-PROBE-POINT-TABLE" title="Таблица 28.48. Встроенные точки трассировки DTrace">Таблице 28.48</a>; в <a class="xref" href="dynamic-trace.html#TYPEDEFS-TABLE" title="Таблица 28.49. Предопределённые типы, используемые в параметрах точек трассировки">Таблице 28.49</a> показаны типы данных, которые используются для этих точек. Конечно, для более детального отслеживания работы <span class="productname">PostgreSQL</span> можно добавлять и другие точки трассировки.</p><div class="table" id="DTRACE-PROBE-POINT-TABLE"><p class="title"><strong>Таблица 28.48. Встроенные точки трассировки DTrace</strong></p><div class="table-contents"><table class="table" summary="Встроенные точки трассировки DTrace" border="1"><colgroup><col class="col1" /><col class="col2" /><col class="col3" /></colgroup><thead><tr><th>Name</th><th>Параметры</th><th>Описание</th></tr></thead><tbody><tr><td><code class="literal">transaction-start</code></td><td><code class="literal">(LocalTransactionId)</code></td><td>Срабатывает в начале новой транзакции. arg0 задаёт идентификатор транзакции.</td></tr><tr><td><code class="literal">transaction-commit</code></td><td><code class="literal">(LocalTransactionId)</code></td><td>Срабатывает при успешном завершении транзакции. arg0 задаёт идентификатор транзакции.</td></tr><tr><td><code class="literal">transaction-abort</code></td><td><code class="literal">(LocalTransactionId)</code></td><td>Срабатывает, когда транзакция завершается с ошибкой. arg0 задаёт идентификатор транзакции.</td></tr><tr><td><code class="literal">query-start</code></td><td><code class="literal">(const char *)</code></td><td>Срабатывает, когда начинается обработка запроса. arg0 задаёт текст запроса.</td></tr><tr><td><code class="literal">query-done</code></td><td><code class="literal">(const char *)</code></td><td>Срабатывает по завершении обработки запроса. arg0 задаёт текст запроса.</td></tr><tr><td><code class="literal">query-parse-start</code></td><td><code class="literal">(const char *)</code></td><td>Срабатывает, когда начинается разбор запроса. arg0 задаёт текст запроса.</td></tr><tr><td><code class="literal">query-parse-done</code></td><td><code class="literal">(const char *)</code></td><td>Срабатывает по завершении разбора (parsing) запроса. arg0 задаёт текст запроса.</td></tr><tr><td><code class="literal">query-rewrite-start</code></td><td><code class="literal">(const char *)</code></td><td>Срабатывает, когда начинается модификация запроса. arg0 задаёт текст запроса.</td></tr><tr><td><code class="literal">query-rewrite-done</code></td><td><code class="literal">(const char *)</code></td><td>Срабатывает по завершении модификации запроса. arg0 задаёт текст запроса.</td></tr><tr><td><code class="literal">query-plan-start</code></td><td><code class="literal">()</code></td><td>Срабатывает, когда начинает работать планировщик выполнения запроса.</td></tr><tr><td><code class="literal">query-plan-done</code></td><td><code class="literal">()</code></td><td>Срабатывает по завершении работы планировщика запроса.</td></tr><tr><td><code class="literal">query-execute-start</code></td><td><code class="literal">()</code></td><td>Срабатывает, когда начинается выполнение запроса.</td></tr><tr><td><code class="literal">query-execute-done</code></td><td><code class="literal">()</code></td><td>Срабатывает по завершении выполнения запроса.</td></tr><tr><td><code class="literal">statement-status</code></td><td><code class="literal">(const char *)</code></td><td>Срабатывает каждый раз, когда серверный процесс обновляет свой статус в <code class="structname">pg_stat_activity</code>.<code class="structfield">status</code>. arg0 задаёт новую строку состояния.</td></tr><tr><td><code class="literal">checkpoint-start</code></td><td><code class="literal">(int)</code></td><td>Срабатывает в начале контрольной точки. arg0 содержит битовые флаги, с помощью которых задаются разные типы контрольных точек, такие как shutdown, immediate или force.</td></tr><tr><td><code class="literal">checkpoint-done</code></td><td><code class="literal">(int, int, int, int, int)</code></td><td>Срабатывает по завершении контрольной точки. (Перечисленные далее точки трассировки срабатывают последовательно при обработке контрольной точки.) arg0 задаёт число записанных буферов. arg1 — общее число буферов. arg2, arg3 и arg4 задают число файлов WAL, которые были добавлены, удалены или переработаны, соответственно.</td></tr><tr><td><code class="literal">clog-checkpoint-start</code></td><td><code class="literal">(bool)</code></td><td>Срабатывает, когда начинается запись контрольной точки в CLOG. arg0 = true для обычных контрольных точек и false для контрольных точек типа shutdown.</td></tr><tr><td><code class="literal">clog-checkpoint-done</code></td><td><code class="literal">(bool)</code></td><td>Срабатывает по завершении записи контрольной точки в CLOG. Значение arg0 задаётся аналогично значению для <code class="literal">clog-checkpoint-start</code>.</td></tr><tr><td><code class="literal">subtrans-checkpoint-start</code></td><td><code class="literal">(bool)</code></td><td>Срабатывает, когда начинается запись контрольной точки в SUBTRANS. arg0 = true для обычных контрольных точек и false для контрольных точек типа shutdown.</td></tr><tr><td><code class="literal">subtrans-checkpoint-done</code></td><td><code class="literal">(bool)</code></td><td>Срабатывает по завершении записи контрольной точки в SUBTRANS. Значение arg0 задаётся аналогично значению для <code class="literal">subtrans-checkpoint-start</code>.</td></tr><tr><td><code class="literal">multixact-checkpoint-start</code></td><td><code class="literal">(bool)</code></td><td>Срабатывает, когда начинается запись контрольной точки в MultiXact. arg0 = true для обычных контрольных точек и false для контрольных точек типа shutdown.</td></tr><tr><td><code class="literal">multixact-checkpoint-done</code></td><td><code class="literal">(bool)</code></td><td>Срабатывает по завершении записи контрольной точки в MultiXact. Значение arg0 задаётся аналогично значению для <code class="literal">multixact-checkpoint-start</code>.</td></tr><tr><td><code class="literal">buffer-checkpoint-start</code></td><td><code class="literal">(int)</code></td><td>Срабатывает, когда начинается запись буферов контрольной точки. arg0 содержит битовые флаги, с помощью которых задаются разные типы контрольных точек, такие как shutdown, immediate или force.</td></tr><tr><td><code class="literal">buffer-sync-start</code></td><td><code class="literal">(int, int)</code></td><td>Срабатывает во время контрольной точки, когда начинается запись грязных буферов (после нахождения буферов, которые должны быть записаны). arg0 задаёт общее число буферов. arg1 задаёт число буферов, которые в настоящий момент являются грязными и должны быть записаны.</td></tr><tr><td><code class="literal">buffer-sync-written</code></td><td><code class="literal">(int)</code></td><td>Срабатывает после записи каждого буфера при выполнении контрольной точки. arg0 задаёт идентификатор буфера.</td></tr><tr><td><code class="literal">buffer-sync-done</code></td><td><code class="literal">(int, int, int)</code></td><td>Срабатывает после записи всех грязных буферов. arg0 задаёт общее число буферов. arg1 задаёт число буферов, которые фактически были записаны процессом выполнения контрольной точки. arg2 задаёт число буферов, которое должно было быть записано (arg1 из <code class="literal">buffer-sync-start</code>); разные значения говорят о том, что во время выполнения этой контрольной точки буферы сбрасывались другими процессами.</td></tr><tr><td><code class="literal">buffer-checkpoint-sync-start</code></td><td><code class="literal">()</code></td><td>Срабатывает после записи грязных буферов в ядро и до начала формирования запросов fsync.</td></tr><tr><td><code class="literal">buffer-checkpoint-done</code></td><td><code class="literal">()</code></td><td>Срабатывает по завершении синхронизации буферов с диском.</td></tr><tr><td><code class="literal">twophase-checkpoint-start</code></td><td><code class="literal">()</code></td><td>Срабатывает, когда начинается двухфазный этап выполнения контрольной точки.</td></tr><tr><td><code class="literal">twophase-checkpoint-done</code></td><td><code class="literal">()</code></td><td>Срабатывает по завершении двухфазного этапа выполнения контрольной точки.</td></tr><tr><td><code class="literal">buffer-extend-start</code></td><td><code class="literal">(ForkNumber, BlockNumber, Oid, Oid, Oid, int, unsigned int)</code></td><td>Срабатывает при запуске расширения отношения. arg0 содержит расширяемый слой. arg1, arg2 и arg3 содержат идентификаторы (OID) табличного пространства, базы данных и отношения, идентифицирующие отношение. arg4 для локального буфера задаёт идентификатор серверного процесса, создавшего временное отношение, или <code class="symbol">InvalidBackendId</code> (-1) для разделяемого буфера. arg5 — это количество блоков, на которое расширяется вызывающее отношение.</td></tr><tr><td><code class="literal">buffer-extend-done</code></td><td><code class="literal">(ForkNumber, BlockNumber, Oid, Oid, Oid, int, unsigned int, BlockNumber)</code></td><td>Срабатывает по завершении расширения отношения. arg0 содержит расширяемый слой. arg1, arg2 и arg3 содержат идентификаторы (OID) табличного пространства, базы данных и отношения, идентифицирующие отношение. arg4 для локального буфера задаёт идентификатор серверного процесса, создавшего временное отношение, или <code class="symbol">InvalidBackendId</code> (-1) для разделяемого буфера. arg5 — это количество блоков, на которое было расширено вызывающее отношение, оно может быть меньше, чем количество в <code class="literal">buffer-extend-start</code>, из-за ограничений ресурса. arg6 содержит BlockNumber первого нового блока.</td></tr><tr><td><code class="literal">buffer-read-start</code></td><td><code class="literal">(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</code></td><td>Срабатывает, когда начинается чтение буфера. arg0 и arg1 содержат номер слоя и номер блока этой страницы. arg2, arg3 и arg4 содержат идентификаторы (OID) табличного пространства, базы данных и отношения, которые однозначно идентифицируют отношение. arg5 для локального буфера задаёт идентификатор серверного процесса, создавшего временное отношение, или <code class="symbol">InvalidBackendId</code> (-1) для разделяемого буфера.</td></tr><tr><td><code class="literal">buffer-read-done</code></td><td><code class="literal">(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool)</code></td><td>Срабатывает по завершении чтения блока. arg0 и arg1 содержат номер слоя и номер блока страницы. arg2, arg3 и arg4 содержат идентификаторы (OID) табличного пространства, базы данных и отношения, которые однозначно идентифицируют отношение. arg5 для локального буфера задаёт идентификатор серверного процесса, создавшего временное отношение, или <code class="symbol">InvalidBackendId</code> (-1) — для разделяемого буфера. arg6 имеет значение true, если буфер был найден в пуле, и false, если не был.</td></tr><tr><td><code class="literal">buffer-flush-start</code></td><td><code class="literal">(ForkNumber, BlockNumber, Oid, Oid, Oid)</code></td><td>Срабатывает перед формированием любого запроса на запись в разделяемый буфер. arg0 и arg1 содержат номер слоя и номер блока этой страницы. arg2, arg3 и arg4 содержат идентификаторы (OID) табличного пространства, базы данных и отношения, которые однозначно идентифицируют отношение.</td></tr><tr><td><code class="literal">buffer-flush-done</code></td><td><code class="literal">(ForkNumber, BlockNumber, Oid, Oid, Oid)</code></td><td>Срабатывает по завершении запроса на запись. (Учтите, что это отражает только момент передачи данных в ядро; обычно на диск они ещё не записаны.) Аргументы аналогичны <code class="literal">buffer-flush-start</code>.</td></tr><tr><td><code class="literal">wal-buffer-write-dirty-start</code></td><td><code class="literal">()</code></td><td>Срабатывает, когда серверный процесс начинает запись грязного WAL буфера из-за того, что свободные WAL буферы закончились. (Частое повторение такой ситуации означает, что значение <a class="xref" href="runtime-config-wal.html#GUC-WAL-BUFFERS">wal_buffers</a> слишком мало.)</td></tr><tr><td><code class="literal">wal-buffer-write-dirty-done</code></td><td><code class="literal">()</code></td><td>Срабатывает по завершении записи грязного WAL буфера.</td></tr><tr><td><code class="literal">wal-insert</code></td><td><code class="literal">(unsigned char, unsigned char)</code></td><td>Срабатывает при добавлении записи в WAL. arg0 задаёт идентификатор менеджера ресурсов (rmid) для этой записи. arg1 задаёт информационные флаги.</td></tr><tr><td><code class="literal">wal-switch</code></td><td><code class="literal">()</code></td><td>Срабатывает при запросе на переключение сегмента WAL.</td></tr><tr><td><code class="literal">smgr-md-read-start</code></td><td><code class="literal">(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</code></td><td>Срабатывает, когда начинается чтение блока из отношения. arg0 и arg1 содержат номер слоя и номер блока этой страницы. arg2, arg3 и arg4 содержат идентификаторы (OID) табличного пространства, базы данных и отношения, которые однозначно идентифицируют отношение. arg5 для локального буфера задаёт идентификатор серверного процесса, создавшего временное отношение, или <code class="symbol">InvalidBackendId</code> (-1) для разделяемого буфера.</td></tr><tr><td><code class="literal">smgr-md-read-done</code></td><td><code class="literal">(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</code></td><td>Срабатывает по завершении чтения блока. arg0 и arg1 содержат номер слоя и номер блока страницы. arg2, arg3 и arg4 содержат идентификаторы (OID) табличного пространства, базы данных и отношения, которые однозначно идентифицируют отношение. arg5 для локального буфера задаёт идентификатор серверного процесса, создавшего временное отношение, или <code class="symbol">InvalidBackendId</code> (-1) — для разделяемого буфера. arg6 задаёт количество фактически прочитанных байтов, тогда как arg7 задаёт количество запрошенных байтов (различия говорят о наличии проблемы).</td></tr><tr><td><code class="literal">smgr-md-write-start</code></td><td><code class="literal">(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</code></td><td>Срабатывает, когда начинается запись блока в отношение. arg0 и arg1 содержат номер слоя и номер блока этой страницы. arg2, arg3 и arg4 содержат идентификаторы (OID) табличного пространства, базы данных и отношения, которые однозначно идентифицируют отношение. arg5 для локального буфера задаёт идентификатор серверного процесса, создавшего временное отношение, или <code class="symbol">InvalidBackendId</code> (-1) — для разделяемого буфера.</td></tr><tr><td><code class="literal">smgr-md-write-done</code></td><td><code class="literal">(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</code></td><td>Срабатывает по завершении записи блока. arg0 и arg1 содержат номер слоя и номер блока этой страницы. arg2, arg3 и arg4 содержат идентификаторы (OID) табличного пространства, базы данных и отношения, которые однозначно идентифицируют отношение. arg5 для локального буфера задаёт идентификатор серверного процесса, создавшего временное отношение, или <code class="symbol">InvalidBackendId</code> (-1) — для разделяемого буфера. arg6 задаёт количество фактически записанных байтов, тогда как arg7 задаёт количество запрошенных байтов (различия говорят о наличии проблемы).</td></tr><tr><td><code class="literal">sort-start</code></td><td><code class="literal">(int, bool, int, int, bool, int)</code></td><td>Срабатывает, когда начинается операция сортировки. arg0 задаёт сортировку таблицы, индекса или элемента данных. arg1 = true, если данные ожидаются уникальными. arg2 задаёт число ключевых столбцов. arg3 задаёт объём доступной рабочей памяти в килобайтах. arg4 = true, если требуется произвольный доступ к результату сортировки. В arg5 значение <code class="literal">0</code> указывает на последовательный процесс, <code class="literal">1</code> — на параллельный, а <code class="literal">2</code> показывает, что это ведущий процесс в параллельной сортировке.</td></tr><tr><td><code class="literal">sort-done</code></td><td><code class="literal">(bool, long)</code></td><td>Срабатывает по завершении сортировки. arg0 = true для внешней сортировки, false — для внутренней сортировки. arg1 задаёт число дисковых блоков, использованных для внешней сортировки, или объём памяти, использованной для внутренней сортировки, в килобайтах.</td></tr><tr><td><code class="literal">lwlock-acquire</code></td><td><code class="literal">(char *, LWLockMode)</code></td><td>Срабатывает, когда выдаётся блокировка LWLock. В arg0 передаётся транш блокировки, в arg1 запрошенный режим блокировки (исключительная или разделяемая).</td></tr><tr><td><code class="literal">lwlock-release</code></td><td><code class="literal">(char *)</code></td><td>Срабатывает, когда блокировка LWLock освобождается (но учтите, что никакие ждущие процессы ещё не пробуждены). В arg0 передаётся транш блокировки.</td></tr><tr><td><code class="literal">lwlock-wait-start</code></td><td><code class="literal">(char *, LWLockMode)</code></td><td>Срабатывает, когда блокировка LWLock не доступна моментально, и серверный процесс начал ожидать её доступности. В arg0 передаётся транш блокировки, в arg1 запрошенный режим блокировки (исключительная или разделяемая).</td></tr><tr><td><code class="literal">lwlock-wait-done</code></td><td><code class="literal">(char *, LWLockMode)</code></td><td>Срабатывает, когда серверный процесс прекращает ожидание блокировки LWLock (но саму блокировку он ещё не получил). В arg0 передаётся транш блокировки, в arg1 запрошенный режим блокировки (исключительная или разделяемая).</td></tr><tr><td><code class="literal">lwlock-condacquire</code></td><td><code class="literal">(char *, LWLockMode)</code></td><td>Срабатывает, когда блокировка LWLock была успешно получена процессом, запросившим её в режиме без ожидания. В arg0 передаётся транш блокировки, в arg1 запрошенный режим блокировки (исключительная или разделяемая).</td></tr><tr><td><code class="literal">lwlock-condacquire-fail</code></td><td><code class="literal">(char *, LWLockMode)</code></td><td>Срабатывает, когда блокировка LWLock не была успешно получена процессом, запросившим её в режиме без ожидания. В arg0 передаётся транш блокировки, в arg1 запрошенный режим блокировки (исключительная или разделяемая).</td></tr><tr><td><code class="literal">lock-wait-start</code></td><td><code class="literal">(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</code></td><td>Срабатывает, когда запрос на тяжёлую блокировку (блокировку lmgr) переходит в состояние ожидания, поскольку блокировка недоступна. Аргументы с arg0 до arg3 задают атрибуты, идентифицирующие объект, на который накладывается блокировка. arg4 задаёт тип объекта, на который накладывается блокировка. arg5 задаёт тип запрошенной блокировки.</td></tr><tr><td><code class="literal">lock-wait-done</code></td><td><code class="literal">(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</code></td><td>Срабатывает, когда запрос на тяжёлую блокировку (блокировку lmgr) выходит из состояния ожидания (т. е. получает блокировку). Аргументы аналогичны <code class="literal">lock-wait-start</code>.</td></tr><tr><td><code class="literal">deadlock-found</code></td><td><code class="literal">()</code></td><td>Срабатывает, когда детектор взаимных блокировок обнаруживает такую взаимную блокировку</td></tr></tbody></table></div></div><br class="table-break" /><div class="table" id="TYPEDEFS-TABLE"><p class="title"><strong>Таблица 28.49. Предопределённые типы, используемые в параметрах точек трассировки</strong></p><div class="table-contents"><table class="table" summary="Предопределённые типы, используемые в параметрах точек трассировки" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Тип</th><th>Определение</th></tr></thead><tbody><tr><td><code class="type">LocalTransactionId</code></td><td><code class="type">unsigned int</code></td></tr><tr><td><code class="type">LWLockMode</code></td><td><code class="type">int</code></td></tr><tr><td><code class="type">LOCKMODE</code></td><td><code class="type">int</code></td></tr><tr><td><code class="type">BlockNumber</code></td><td><code class="type">unsigned int</code></td></tr><tr><td><code class="type">Oid</code></td><td><code class="type">unsigned int</code></td></tr><tr><td><code class="type">ForkNumber</code></td><td><code class="type">int</code></td></tr><tr><td><code class="type">bool</code></td><td><code class="type">unsigned char</code></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect2" id="USING-TRACE-POINTS"><div class="titlepage"><div><div><h3 class="title">28.5.3. Использование точек трассировки <a href="#USING-TRACE-POINTS" class="id_link">#</a></h3></div></div></div><p>В приведённом ниже примере показан скрипт DTrace для анализа числа транзакций в системе, который можно использовать в качестве альтернативы созданию снимка данных <code class="structname">pg_stat_database</code> до и после выполнения теста производительности: </p><pre class="programlisting">#!/usr/sbin/dtrace -qs

postgresql$1:::transaction-start
{
      @start["Start"] = count();
      self-&gt;ts  = timestamp;
}

postgresql$1:::transaction-abort
{
      @abort["Abort"] = count();
}

postgresql$1:::transaction-commit
/self-&gt;ts/
{
      @commit["Commit"] = count();
      @time["Total time (ns)"] = sum(timestamp - self-&gt;ts);
      self-&gt;ts=0;
}</pre><p> При выполнении этот D-скрипт возвращает результат вида: </p><pre class="screen">
# ./txn_count.d `pgrep -n postgres` or ./txn_count.d &lt;PID&gt;
^C

Start                                          71
Commit                                         70
Total time (ns)                        2312105013
</pre><div class="note"><h3 class="title">Примечание</h3><p>SystemTap использует отличную от DTrace нотацию для скриптов трассировки, хотя лежащие в их основе точки трассировки совместимы. Стоит отметить, что на момент написания этой главы в скриптах SystemTap имена точек трассировки должны обрамляться двойными подчёркиваниями, а не дефисами. Ожидается, что эта проблема будет решена в следующих версиях SystemTap.</p></div><p>Необходимо помнить, что скрипты DTrace должны быть аккуратно написаны и отлажены, в противном случае собранная трассировочная информация может оказаться бессмысленной. В большинстве случаев причиной обнаруженных проблем является инструментарий, а не сама система. Отправляя на рассмотрение данные, полученные с использованием динамической трассировки, обязательно прилагайте скрипт, с помощью которого они были получены, для того чтобы его также проверить и обсудить.</p></div><div class="sect2" id="DEFINING-TRACE-POINTS"><div class="titlepage"><div><div><h3 class="title">28.5.4. Задание новых точек трассировки <a href="#DEFINING-TRACE-POINTS" class="id_link">#</a></h3></div></div></div><p>Новые точки трассировки разработчик может определить в любом участке кода, однако это потребует перекомпиляции. Ниже приведены шаги, необходимые для добавления новых точек трассировки:</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>Определить имена точек трассировки и данные, которые будут доступны в этих точках</p></li><li class="step"><p>Добавить описание точек трассировки в <code class="filename">src/backend/utils/probes.d</code></p></li><li class="step"><p>Включить <code class="filename">pg_trace.h</code>, если его ещё не использовали в модуле (модулях), содержащих точки трассировки, и вставить <code class="literal">TRACE_POSTGRESQL</code> отладочные макросы в нужные места исходного кода</p></li><li class="step"><p>Перекомпилировать и убедиться в доступности новых точек трассировки</p></li></ol></div><p><strong>Пример: </strong>Вот пример того, как можно добавить точку для трассировки всех новых транзакций по их идентификатору.</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>Устанавливаем, что проба будет называться <code class="literal">transaction-start</code> и принимать параметр типа <code class="type">LocalTransactionId</code></p></li><li class="step"><p>Добавляем определение пробы в <code class="filename">src/backend/utils/probes.d</code>: </p><pre class="programlisting">probe transaction__start(LocalTransactionId);</pre><p> Обратите внимание на использование двойного подчёркивания в имени пробы. В скрипте DTrace, использующем эту точку, двойное подчёркивание нужно будет заменить дефисом, поэтому в документации для пользователей имя этой пробы — <code class="literal">transaction-start</code>.</p></li><li class="step"><p>Во время компиляции <code class="literal">transaction__start</code> преобразуется в макрос <code class="literal">TRACE_POSTGRESQL_TRANSACTION_START</code> (обратите внимание, что здесь используется одинарное подчёркивание), который доступен в результате включения <code class="filename">pg_trace.h</code>. Добавим вызов макроса в требуемую точку исходного кода. В данном случае это будет выглядеть приблизительно так: </p><pre class="programlisting">TRACE_POSTGRESQL_TRANSACTION_START(vxid.localTransactionId);</pre></li><li class="step"><p>После перекомпиляции и запуска нового бинарного файла используйте следующую команду DTrace, чтобы проверить доступность только что добавленной пробы. Должен получиться результат, подобный этому: </p><pre class="screen">
# dtrace -ln transaction-start
   ID    PROVIDER          MODULE           FUNCTION NAME
18705 postgresql49878     postgres     StartTransactionCommand transaction-start
18755 postgresql49877     postgres     StartTransactionCommand transaction-start
18805 postgresql49876     postgres     StartTransactionCommand transaction-start
18855 postgresql49875     postgres     StartTransactionCommand transaction-start
18986 postgresql49873     postgres     StartTransactionCommand transaction-start
</pre></li></ol></div><p>При добавлении макросов трассировки в код, написанный на языке C, необходимо позаботиться о следующем: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Нужно убедиться, что типы данных, определённые в параметрах пробы, совпадают с типами данных переменных, которые используются в макросе. В противном случае компиляция завершится с ошибками.</p></li><li class="listitem"><p>В большинстве платформ в случае, если <span class="productname">PostgreSQL</span> собран с указанием <code class="option">--enable-dtrace</code>, то аргументы макроса трассировки вычисляются каждый раз, когда макрос получает управление, <span class="emphasis"><em>даже если трассировка не выполняется</em></span>. Об этом не стоит беспокоиться, если вы просто возвращаете значения небольшого числа локальных переменных. Однако избегайте использования ресурсоёмких вызовов функций в аргументах. Если это необходимо, то постарайтесь защитить макрос проверкой, которая будет определять, действительно ли включена трассировка: </p><pre class="programlisting">if (TRACE_POSTGRESQL_TRANSACTION_START_ENABLED())
    TRACE_POSTGRESQL_TRANSACTION_START(some_function(...));</pre><p> Каждый макрос трассировки имеет соответствующий макрос <code class="literal">ENABLED</code>.</p></li></ul></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="progress-reporting.html" title="28.4. Отслеживание выполнения">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="monitoring.html" title="Глава 28. Мониторинг работы СУБД">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="diskusage.html" title="Глава 29. Мониторинг использования диска">След.</a></td></tr><tr><td width="40%" align="left" valign="top">28.4. Отслеживание выполнения </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> Глава 29. Мониторинг использования диска</td></tr></table></div></body></html>