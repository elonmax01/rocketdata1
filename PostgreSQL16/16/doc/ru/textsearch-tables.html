<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>12.2. Таблицы и индексы</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="textsearch-intro.html" title="12.1. Введение" /><link rel="next" href="textsearch-controls.html" title="12.3. Управление текстовым поиском" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">12.2. Таблицы и индексы</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="textsearch-intro.html" title="12.1. Введение">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="textsearch.html" title="Глава 12. Полнотекстовый поиск">Наверх</a></td><th width="60%" align="center">Глава 12. Полнотекстовый поиск</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="textsearch-controls.html" title="12.3. Управление текстовым поиском">След.</a></td></tr></table><hr /></div><div class="sect1" id="TEXTSEARCH-TABLES"><div class="titlepage"><div><div><h2 class="title" style="clear: both">12.2. Таблицы и индексы <a href="#TEXTSEARCH-TABLES" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="textsearch-tables.html#TEXTSEARCH-TABLES-SEARCH">12.2.1. Поиск в таблице</a></span></dt><dt><span class="sect2"><a href="textsearch-tables.html#TEXTSEARCH-TABLES-INDEX">12.2.2. Создание индексов</a></span></dt></dl></div><p>В предыдущем разделе приводились примеры, которые показывали, как можно выполнить сопоставление с простыми текстовыми константами. В этом разделе показывается, как находить текст в таблице, возможно с применением индексов.</p><div class="sect2" id="TEXTSEARCH-TABLES-SEARCH"><div class="titlepage"><div><div><h3 class="title">12.2.1. Поиск в таблице <a href="#TEXTSEARCH-TABLES-SEARCH" class="id_link">#</a></h3></div></div></div><p>Полнотекстовый поиск можно выполнить, не применяя индекс. Следующий простой запрос выводит заголовок (<code class="structname">title</code>) каждой строки, содержащей слово <code class="literal">friend</code> в поле <code class="structfield">body</code>: </p><pre class="programlisting">SELECT title
FROM pgweb
WHERE to_tsvector('english', body) @@ to_tsquery('english', 'friend');</pre><p> При этом также будут найдены связанные слова, такие как <code class="literal">friends</code> и <code class="literal">friendly</code>, так как все они сводятся к одной нормализованной лексеме.</p><p>В показанном выше примере для разбора и нормализации строки явно выбирается конфигурация <code class="literal">english</code>. Хотя параметры, задающие конфигурацию, можно опустить: </p><pre class="programlisting">SELECT title
FROM pgweb
WHERE to_tsvector(body) @@ to_tsquery('friend');</pre><p> Такой запрос будет использовать конфигурацию, заданную в параметре <a class="xref" href="runtime-config-client.html#GUC-DEFAULT-TEXT-SEARCH-CONFIG">default_text_search_config</a>.</p><p>В следующем более сложном примере выбираются десять документов, изменённых последними, со словами <code class="literal">create</code> и <code class="literal">table</code> в полях <code class="structname">title</code> или <code class="structname">body</code>: </p><pre class="programlisting">SELECT title
FROM pgweb
WHERE to_tsvector(title || ' ' || body) @@ to_tsquery('create &amp; table')
ORDER BY last_mod_date DESC
LIMIT 10;</pre><p> Чтобы найти строки, содержащие <code class="literal">NULL</code> в одном из полей, нужно воспользоваться функцией <code class="function">coalesce</code>, но здесь мы опустили её вызовы для краткости.</p><p>Хотя такие запросы будут работать и без индекса, для большинства приложений скорость будет неприемлемой; этот подход рекомендуется только для нерегулярного поиска и динамического содержимого. Для практического применения полнотекстового поиска обычно создаются индексы.</p></div><div class="sect2" id="TEXTSEARCH-TABLES-INDEX"><div class="titlepage"><div><div><h3 class="title">12.2.2. Создание индексов <a href="#TEXTSEARCH-TABLES-INDEX" class="id_link">#</a></h3></div></div></div><p>Для ускорения текстового поиска мы можем создать индекс <acronym class="acronym">GIN</acronym> (см. <a class="xref" href="textsearch-indexes.html" title="12.9. Типы индексов, предпочитаемые для текстового поиска">Раздел 12.9</a>): </p><pre class="programlisting">CREATE INDEX pgweb_idx ON pgweb USING GIN (to_tsvector('english', body));</pre><p> Заметьте, что здесь используется функция <code class="function">to_tsvector</code> с двумя аргументами. В выражениях, определяющих индексы, можно использовать только функции, в которых явно задаётся имя конфигурации текстового поиска (см. <a class="xref" href="indexes-expressional.html" title="11.7. Индексы по выражениям">Раздел 11.7</a>). Это объясняется тем, что содержимое индекса не должно зависеть от значения параметра <a class="xref" href="runtime-config-client.html#GUC-DEFAULT-TEXT-SEARCH-CONFIG">default_text_search_config</a>. В противном случае содержимое индекса может быть неактуальным, если разные его элементы <code class="type">tsvector</code> будут создаваться с разными конфигурациями текстового поиска и нельзя будет понять, какую именно использовать. Выгрузить и восстановить такой индекс будет невозможно.</p><p>Так как при создании индекса использовалась версия <code class="function">to_tsvector</code> с двумя аргументами, этот индекс будет использоваться только в запросах, где <code class="function">to_tsvector</code> вызывается с двумя аргументами и во втором передаётся имя той же конфигурации. То есть, <code class="literal">WHERE to_tsvector('english', body) @@ 'a &amp; b'</code> сможет использовать этот индекс, а <code class="literal">WHERE to_tsvector(body) @@ 'a &amp; b'</code> — нет. Это гарантирует, что индекс будет использоваться только с той конфигурацией, с которой создавались его элементы.</p><p>Индекс можно создать более сложным образом, определив для него имя конфигурации в другом столбце таблицы, например: </p><pre class="programlisting">CREATE INDEX pgweb_idx ON pgweb USING GIN (to_tsvector(config_name, body));</pre><p> где <code class="literal">config_name</code> — имя столбца в таблице <code class="literal">pgweb</code>. Так можно сохранить имя конфигурации, связанной с элементом индекса, и, таким образом, иметь в одном индексе элементы с разными конфигурациями. Это может быть полезно, например, когда в коллекции документов хранятся документы на разных языках. И в этом случае в запросах должен использоваться тот же индекс (с таким же образом задаваемой конфигурацией), например, так: <code class="literal">WHERE to_tsvector(config_name, body) @@ 'a &amp; b'</code>.</p><p>Индексы могут создаваться даже по объединению столбцов: </p><pre class="programlisting">CREATE INDEX pgweb_idx ON pgweb USING GIN (to_tsvector('english', title || ' ' || body));</pre><p>Ещё один вариант — создать отдельный столбец <code class="type">tsvector</code>, в котором сохранить результат <code class="function">to_tsvector</code>. Чтобы этот столбец автоматически синхронизировался с исходными данными, он создаётся как сохранённый генерируемый столбец. Следующий пример показывает, как можно подготовить для индексации объединённое содержимое столбцов <code class="literal">title</code> и <code class="literal">body</code>, применив функцию <code class="function">coalesce</code> для получения желаемого результата, даже когда один из столбцов <code class="literal">NULL</code>: </p><pre class="programlisting">ALTER TABLE pgweb
    ADD COLUMN textsearchable_index_col tsvector
               GENERATED ALWAYS AS (to_tsvector('english', coalesce(title, '') || ' ' || coalesce(body, ''))) STORED;</pre><p> Затем мы создаём индекс <acronym class="acronym">GIN</acronym> для ускорения поиска: </p><pre class="programlisting">CREATE INDEX textsearch_idx ON pgweb USING GIN (textsearchable_index_col);</pre><p> Теперь мы можем быстро выполнять полнотекстовый поиск: </p><pre class="programlisting">SELECT title
FROM pgweb
WHERE textsearchable_index_col @@ to_tsquery('create &amp; table')
ORDER BY last_mod_date DESC
LIMIT 10;</pre><p>Хранение вычисленного выражения индекса в отдельном столбце даёт ряд преимуществ. Во-первых, для использования индекса в запросах не нужно явно указывать имя конфигурации текстового поиска. Как показано в вышеприведённом примере, в этом случае запрос может зависеть от <code class="varname">default_text_search_config</code>. Во-вторых, поиск выполняется быстрее, так как для проверки соответствия данных индексу не нужно повторно выполнять <code class="function">to_tsvector</code>. (Это актуально больше для индексов GiST, чем для GIN; см. <a class="xref" href="textsearch-indexes.html" title="12.9. Типы индексов, предпочитаемые для текстового поиска">Раздел 12.9</a>.) С другой стороны, схему с индексом по выражению проще реализовать и она позволяет сэкономить место на диске, так как представление <code class="type">tsvector</code> не хранится явно.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="textsearch-intro.html" title="12.1. Введение">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="textsearch.html" title="Глава 12. Полнотекстовый поиск">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="textsearch-controls.html" title="12.3. Управление текстовым поиском">След.</a></td></tr><tr><td width="40%" align="left" valign="top">12.1. Введение </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 12.3. Управление текстовым поиском</td></tr></table></div></body></html>