<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>34.3. Функции для исполнения команд</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="libpq-status.html" title="34.2. Функции, описывающие текущее состояние подключения" /><link rel="next" href="libpq-async.html" title="34.4. Асинхронная обработка команд" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">34.3. Функции для исполнения команд</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="libpq-status.html" title="34.2. Функции, описывающие текущее состояние подключения">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="libpq.html" title="Глава 34. libpq — библиотека для языка C">Наверх</a></td><th width="60%" align="center">Глава 34. <span class="application">libpq</span> — библиотека для языка C</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="libpq-async.html" title="34.4. Асинхронная обработка команд">След.</a></td></tr></table><hr /></div><div class="sect1" id="LIBPQ-EXEC"><div class="titlepage"><div><div><h2 class="title" style="clear: both">34.3. Функции для исполнения команд <a href="#LIBPQ-EXEC" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="libpq-exec.html#LIBPQ-EXEC-MAIN">34.3.1. Главные функции</a></span></dt><dt><span class="sect2"><a href="libpq-exec.html#LIBPQ-EXEC-SELECT-INFO">34.3.2. Извлечение информации, связанной с результатом запроса</a></span></dt><dt><span class="sect2"><a href="libpq-exec.html#LIBPQ-EXEC-NONSELECT">34.3.3. Получение другой информации о результате</a></span></dt><dt><span class="sect2"><a href="libpq-exec.html#LIBPQ-EXEC-ESCAPE-STRING">34.3.4. Экранирование строковых значений для включения в SQL-команды</a></span></dt></dl></div><p>После того как соединение с сервером было успешно установлено, функции, описанные в этом разделе, используются для выполнения SQL-запросов и команд.</p><div class="sect2" id="LIBPQ-EXEC-MAIN"><div class="titlepage"><div><div><h3 class="title">34.3.1. Главные функции <a href="#LIBPQ-EXEC-MAIN" class="id_link">#</a></h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQEXEC"><span class="term"><code class="function">PQexec</code><a id="id-1.7.3.10.3.2.1.1.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQEXEC" class="id_link">#</a></dt><dd><p>Передаёт команду серверу и ожидает результата. </p><pre class="synopsis">
PGresult *PQexec(PGconn *conn, const char *command);
</pre><p>Возвращает указатель на <code class="structname">PGresult</code> или, возможно, пустой указатель (null). Как правило, возвращается непустой указатель, исключением являются ситуации нехватки памяти или серьёзные ошибки, такие, как невозможность отправки команды серверу. Для проверки возвращаемого значения на наличие ошибок следует вызвать функцию <a class="xref" href="libpq-exec.html#LIBPQ-PQRESULTSTATUS"><code class="function">PQresultStatus</code></a> (в случае нулевого указателя она возвратит <code class="symbol">PGRES_FATAL_ERROR</code>). Для получения дополнительной информации о таких ошибках используйте функцию <a class="xref" href="libpq-status.html#LIBPQ-PQERRORMESSAGE"><code class="function">PQerrorMessage</code></a>.</p></dd></dl></div><p> Строка команды может включать в себя более одной SQL-команды (которые разделяются точкой с запятой). Несколько запросов, отправленных с помощью одного вызова <a class="xref" href="libpq-exec.html#LIBPQ-PQEXEC"><code class="function">PQexec</code></a>, обрабатываются в рамках одной транзакции, если только команды <code class="command">BEGIN</code>/<code class="command">COMMIT</code> не включены явно в строку запроса, чтобы разделить его на несколько транзакций. (Подробнее о том, как сервер обрабатывает строки, включающие несколько команд, рассказывается в <a class="xref" href="protocol-flow.html#PROTOCOL-FLOW-MULTI-STATEMENT" title="55.2.2.1. Несколько операторов в простом протоколе запросов">Подразделе 55.2.2.1</a>.) Однако обратите внимание, что возвращаемая структура <code class="structname">PGresult</code> описывает только результат последней из выполненных команд, содержащихся в строке запроса. Если одна из команд завершается сбоем, то обработка строки запроса на этом останавливается, и возвращённая структура <code class="structname">PGresult</code> описывает состояние ошибки.</p><p>
    </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQEXECPARAMS"><span class="term"><code class="function">PQexecParams</code><a id="id-1.7.3.10.3.3.1.1.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQEXECPARAMS" class="id_link">#</a></dt><dd><p>Отправляет команду серверу и ожидает результата. Имеет возможность передать параметры отдельно от текста SQL-команды. </p><pre class="synopsis">
PGresult *PQexecParams(PGconn *conn,
                       const char *command,
                       int nParams,
                       const Oid *paramTypes,
                       const char * const *paramValues,
                       const int *paramLengths,
                       const int *paramFormats,
                       int resultFormat);
</pre><p><a class="xref" href="libpq-exec.html#LIBPQ-PQEXECPARAMS"><code class="function">PQexecParams</code></a> подобна <a class="xref" href="libpq-exec.html#LIBPQ-PQEXEC"><code class="function">PQexec</code></a>, но предлагает дополнительную функциональность: значения параметров могут быть указаны отдельно от самой строки-команды, а результаты запроса могут быть затребованы либо в текстовом, либо в двоичном формате.</p><p>Параметры функции следующие: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>conn</code></em></span></dt><dd><p>Объект, описывающий подключение, через которое пересылается команда.</p></dd><dt><span class="term"><em class="parameter"><code>command</code></em></span></dt><dd><p>Строка SQL-команды, которая должна быть выполнена. Если используются параметры, то в строке команды на них ссылаются, как <code class="literal">$1</code>, <code class="literal">$2</code> и т. д.</p></dd><dt><span class="term"><em class="parameter"><code>nParams</code></em></span></dt><dd><p>Число предоставляемых параметров. Оно равно длине массивов <em class="parameter"><code>paramTypes[]</code></em>, <em class="parameter"><code>paramValues[]</code></em>, <em class="parameter"><code>paramLengths[]</code></em> и <em class="parameter"><code>paramFormats[]</code></em>. (Указатели на массивы могут быть равны <code class="symbol">NULL</code>, когда <em class="parameter"><code>nParams</code></em> равно нулю.)</p></dd><dt><span class="term"><em class="parameter"><code>paramTypes[]</code></em></span></dt><dd><p>Предписывает, посредством OID, типы данных, которые должны быть назначены параметрам. Если значение <em class="parameter"><code>paramTypes</code></em> равно <code class="symbol">NULL</code> или какой-либо отдельный элемент в массиве равен нулю, тогда сервер самостоятельно определит тип данных для параметра точно таким же образом, как он сделал бы для литеральной строки, тип которой не указан.</p></dd><dt><span class="term"><em class="parameter"><code>paramValues[]</code></em></span></dt><dd><p>Указывает фактические значения параметров. Нулевой указатель в этом массиве означает, что соответствующий параметр равен null; в противном случае указатель указывает на текстовую строку, завершающуюся нулевым символом (для текстового формата), или на двоичные данные в формате, которого ожидает сервер (для двоичного формата).</p></dd><dt><span class="term"><em class="parameter"><code>paramLengths[]</code></em></span></dt><dd><p>Указывает фактические длины данных для параметров, представленных в двоичном формате. Он игнорируется для параметров, имеющих значение null, и для параметров, представленных в текстовом формате. Указатель на массив может быть нулевым, когда нет двоичных параметров.</p></dd><dt><span class="term"><em class="parameter"><code>paramFormats[]</code></em></span></dt><dd><p>Указывает, являются ли параметры текстовыми (поместите нуль в элемент массива, соответствующий такому параметру) или двоичными (поместите единицу в элемент массива, соответствующий такому параметру). Если указатель на массив является нулевым, тогда все параметры считаются текстовыми строками.</p><p>Значения, переданные в двоичном формате, требуют знания внутреннего представления, которого ожидает сервер. Например, целые числа должны передаваться с использованием сетевого порядка байтов. Передача значений типа <code class="type">numeric</code> требует знания формата, в котором их хранит сервер; это реализовано в <code class="filename">src/backend/utils/adt/numeric.c::numeric_send()</code> и <code class="filename">src/backend/utils/adt/numeric.c::numeric_recv()</code>.</p></dd><dt><span class="term"><em class="parameter"><code>resultFormat</code></em></span></dt><dd><p>Требует указать ноль, чтобы получить результаты в текстовом формате, или единицу, чтобы получить результаты в двоичном формате. (В настоящее время нет возможности получить различные столбцы результата в разных форматах, хотя это и возможно на уровне протокола, лежащего в основе подключений.)</p></dd></dl></div></dd></dl></div><p>
   </p><p>Главным преимуществом <a class="xref" href="libpq-exec.html#LIBPQ-PQEXECPARAMS"><code class="function">PQexecParams</code></a> перед <a class="xref" href="libpq-exec.html#LIBPQ-PQEXEC"><code class="function">PQexec</code></a> является возможность отделить значения параметров от строки запроса. Это позволяет обойтись без кавычек и экранирующих символов, манипулирование которыми бывает трудоёмким и часто приводит к ошибкам.</p><p>В отличие от <a class="xref" href="libpq-exec.html#LIBPQ-PQEXEC"><code class="function">PQexec</code></a>, <a class="xref" href="libpq-exec.html#LIBPQ-PQEXECPARAMS"><code class="function">PQexecParams</code></a> позволяет включать не более одной SQL-команды в строку запроса. (В ней могут содержаться точки с запятой, однако может присутствовать не более одной непустой команды.) Это ограничение накладывается базовым протоколом, но оно приносит и некоторую пользу в качестве дополнительной защиты от атак методом SQL-инъекций.</p><div class="tip"><h3 class="title">Подсказка</h3><p>Указание типов параметров с помощью OID является трудоёмким, особенно если вы предпочитаете не указывать явно значений OID в вашей программе. Однако вы можете избежать этого даже в случаях, когда сервер самостоятельно не может определить тип параметра или выбирает не тот тип, который вы хотите. В строке SQL-команды добавьте явное приведение типа для этого параметра, чтобы показать, какой тип данных вы будете отправлять. Например: </p><pre class="programlisting">SELECT * FROM mytable WHERE x = $1::bigint;</pre><p> Это приведёт к тому, что параметр <code class="literal">$1</code> будет считаться имеющим тип <code class="type">bigint</code>, в то время как по умолчанию ему был бы назначен тот же самый тип, что и <code class="literal">x</code>. Такое явное принятие решения о типе параметра либо с помощью описанного метода, либо путём задания числового OID строго рекомендуется, когда значения параметров отправляются в двоичном формате, поскольку двоичный формат имеет меньшую избыточность, чем текстовый, и поэтому гораздо менее вероятно, что сервер обнаружит ошибку несоответствия типов, допущенную вами.</p></div><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQPREPARE"><span class="term"><code class="function">PQprepare</code><a id="id-1.7.3.10.3.7.1.1.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQPREPARE" class="id_link">#</a></dt><dd><p>Отправляет запрос, чтобы создать подготовленный оператор с конкретными параметрами, и ожидает завершения. </p><pre class="synopsis">
PGresult *PQprepare(PGconn *conn,
                    const char *stmtName,
                    const char *query,
                    int nParams,
                    const Oid *paramTypes);
</pre><p><a class="xref" href="libpq-exec.html#LIBPQ-PQPREPARE"><code class="function">PQprepare</code></a> создаёт подготовленный оператор для последующего исполнения с помощью <a class="xref" href="libpq-exec.html#LIBPQ-PQEXECPREPARED"><code class="function">PQexecPrepared</code></a>. Благодаря этому, команды, которые будут выполняться многократно, не потребуется разбирать и планировать каждый раз; за подробностями обратитесь к <a class="xref" href="sql-prepare.html" title="PREPARE"><span class="refentrytitle">PREPARE</span></a>.</p><p>Функция создаёт подготовленный оператор с именем <em class="parameter"><code>stmtName</code></em> из строки <em class="parameter"><code>query</code></em>, которая должна содержать единственную SQL-команду. <em class="parameter"><code>stmtName</code></em> может быть пустой строкой <code class="literal">""</code>, тогда будет создан неименованный оператор (в таком случае любой уже существующий неименованный оператор будет автоматически заменён), в противном случае, если имя оператора уже определено в текущем сеансе работы, будет ошибка. Если используются параметры, то в запросе к ним обращаются таким образом: <code class="literal">$1</code>, <code class="literal">$2</code> и т. д. <em class="parameter"><code>nParams</code></em> представляет число параметров, типы данных для которых указаны в массиве <em class="parameter"><code>paramTypes[]</code></em>. (Указатель на массив может быть равен <code class="symbol">NULL</code>, когда значение <em class="parameter"><code>nParams</code></em> равно нулю.) <em class="parameter"><code>paramTypes[]</code></em> указывает, посредством OID, типы данных, которые будут назначены параметрам. Если <em class="parameter"><code>paramTypes</code></em> равен <code class="symbol">NULL</code> или какой-либо элемент в этом массиве равен нулю, то сервер назначает тип данных соответствующему параметру точно таким же способом, как он сделал бы для литеральной строки, не имеющей типа. Также в запросе можно использовать параметры с номерами, большими, чем <em class="parameter"><code>nParams</code></em>; типы данных для них сервер также сможет подобрать. (См. описание <a class="xref" href="libpq-exec.html#LIBPQ-PQDESCRIBEPREPARED"><code class="function">PQdescribePrepared</code></a>, где сказано, как можно определить, какие типы данных были подобраны).</p><p>Как и при вызове <a class="xref" href="libpq-exec.html#LIBPQ-PQEXEC"><code class="function">PQexec</code></a>, результатом является объект <code class="structname">PGresult</code>, содержимое которого показывает успех или сбой на стороне сервера. Нулевой указатель означает нехватку памяти или невозможность вообще отправить команду. Для получения дополнительной информации о таких ошибках используйте <a class="xref" href="libpq-status.html#LIBPQ-PQERRORMESSAGE"><code class="function">PQerrorMessage</code></a>.</p></dd></dl></div><p> Подготовленные операторы для использования с <a class="xref" href="libpq-exec.html#LIBPQ-PQEXECPREPARED"><code class="function">PQexecPrepared</code></a> можно также создать путём исполнения SQL-команд <a class="xref" href="sql-prepare.html" title="PREPARE"><span class="refentrytitle">PREPARE</span></a>. Также, хотя никакой функции <span class="application">libpq</span> для удаления подготовленного оператора не предусмотрено, для этой цели можно воспользоваться SQL-командой <a class="xref" href="sql-deallocate.html" title="DEALLOCATE"><span class="refentrytitle">DEALLOCATE</span></a>.</p><p>
    </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQEXECPREPARED"><span class="term"><code class="function">PQexecPrepared</code><a id="id-1.7.3.10.3.8.1.1.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQEXECPREPARED" class="id_link">#</a></dt><dd><p>Отправляет запрос на исполнение подготовленного оператора с данными параметрами и ожидает результата. </p><pre class="synopsis">
PGresult *PQexecPrepared(PGconn *conn,
                         const char *stmtName,
                         int nParams,
                         const char * const *paramValues,
                         const int *paramLengths,
                         const int *paramFormats,
                         int resultFormat);
</pre><p><a class="xref" href="libpq-exec.html#LIBPQ-PQEXECPREPARED"><code class="function">PQexecPrepared</code></a> подобна <a class="xref" href="libpq-exec.html#LIBPQ-PQEXECPARAMS"><code class="function">PQexecParams</code></a>, но команда, подлежащая исполнению, указывается путём передачи имени предварительно подготовленного оператора вместо передачи строки запроса. Эта возможность позволяет командам, которые вызываются многократно, подвергаться разбору и планированию только один раз, а не при каждом их исполнении. Оператор должен быть подготовлен предварительно в рамках текущего сеанса работы.</p><p>Параметры идентичны <a class="xref" href="libpq-exec.html#LIBPQ-PQEXECPARAMS"><code class="function">PQexecParams</code></a>, за исключением того, что вместо строки запроса передаётся имя подготовленного оператора и отсутствует параметр <em class="parameter"><code>paramTypes[]</code></em> (он не нужен, поскольку типы данных для параметров подготовленного оператора были определены при его создании).</p></dd><dt id="LIBPQ-PQDESCRIBEPREPARED"><span class="term"><code class="function">PQdescribePrepared</code><a id="id-1.7.3.10.3.8.1.2.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQDESCRIBEPREPARED" class="id_link">#</a></dt><dd><p>Передаёт запрос на получение информации об указанном подготовленном операторе и ожидает завершения. </p><pre class="synopsis">
PGresult *PQdescribePrepared(PGconn *conn, const char *stmtName);
</pre><p><a class="xref" href="libpq-exec.html#LIBPQ-PQDESCRIBEPREPARED"><code class="function">PQdescribePrepared</code></a> позволяет приложению получить информацию о предварительно подготовленном операторе.</p><p>Для ссылки на неименованный оператор значение <em class="parameter"><code>stmtName</code></em> может быть пустой строкой <code class="literal">""</code> или <code class="symbol">NULL</code>, в противном случае оно должно быть именем существующего подготовленного оператора. В случае успешного выполнения возвращается <code class="structname">PGresult</code> со статусом <code class="literal">PGRES_COMMAND_OK</code>. Функции <a class="xref" href="libpq-exec.html#LIBPQ-PQNPARAMS"><code class="function">PQnparams</code></a> и <a class="xref" href="libpq-exec.html#LIBPQ-PQPARAMTYPE"><code class="function">PQparamtype</code></a> позволяют извлечь из <code class="structname">PGresult</code> информацию о параметрах подготовленного оператора, а функции <a class="xref" href="libpq-exec.html#LIBPQ-PQNFIELDS"><code class="function">PQnfields</code></a>, <a class="xref" href="libpq-exec.html#LIBPQ-PQFNAME"><code class="function">PQfname</code></a>, <a class="xref" href="libpq-exec.html#LIBPQ-PQFTYPE"><code class="function">PQftype</code></a> и т. п. предоставляют информацию о результирующих столбцах данного оператора (если они есть).</p></dd><dt id="LIBPQ-PQDESCRIBEPORTAL"><span class="term"><code class="function">PQdescribePortal</code><a id="id-1.7.3.10.3.8.1.3.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQDESCRIBEPORTAL" class="id_link">#</a></dt><dd><p>Передаёт запрос на получение информации об указанном портале и ожидает завершения. </p><pre class="synopsis">
PGresult *PQdescribePortal(PGconn *conn, const char *portalName);
</pre><p><a class="xref" href="libpq-exec.html#LIBPQ-PQDESCRIBEPORTAL"><code class="function">PQdescribePortal</code></a> позволяет приложению получить информацию о предварительно созданном портале. (<span class="application">libpq</span> не предоставляет прямого доступа к порталам, но вы можете использовать эту функцию для ознакомления со свойствами курсора, созданного с помощью SQL-команды <code class="command">DECLARE CURSOR</code>.)</p><p>Для ссылки на неименованный портал значение <em class="parameter"><code>portalName</code></em> может быть пустой строкой <code class="literal">""</code> или <code class="symbol">NULL</code>, в противном случае оно должно быть именем существующего портала. В случае успешного завершения возвращается <code class="structname">PGresult</code> со статусом <code class="literal">PGRES_COMMAND_OK</code>. С помощью функций <a class="xref" href="libpq-exec.html#LIBPQ-PQNFIELDS"><code class="function">PQnfields</code></a>, <a class="xref" href="libpq-exec.html#LIBPQ-PQFNAME"><code class="function">PQfname</code></a>, <a class="xref" href="libpq-exec.html#LIBPQ-PQFTYPE"><code class="function">PQftype</code></a> и т. д. можно извлечь из <code class="structname">PGresult</code> информацию о результирующих столбцах данного портала (если они есть).</p></dd></dl></div><p>
   </p><p>Структура <code class="structname">PGresult</code><a id="id-1.7.3.10.3.9.2" class="indexterm"></a> содержит результат, возвращённый сервером. Разработчики приложений <span class="application">libpq</span> должны тщательно поддерживать абстракцию <code class="structname">PGresult</code>. Для получения доступа к содержимому <code class="structname">PGresult</code> используйте функции доступа, описанные ниже. Избегайте непосредственного обращения к полям структуры <code class="structname">PGresult</code>, поскольку они могут измениться в будущем. </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQRESULTSTATUS"><span class="term"><code class="function">PQresultStatus</code><a id="id-1.7.3.10.3.9.7.1.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQRESULTSTATUS" class="id_link">#</a></dt><dd><p>Возвращает статус результата выполнения команды. </p><pre class="synopsis">
ExecStatusType PQresultStatus(const PGresult *res);
</pre><p><a class="xref" href="libpq-exec.html#LIBPQ-PQRESULTSTATUS"><code class="function">PQresultStatus</code></a> может возвращать одно из следующих значений: </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PGRES-EMPTY-QUERY"><span class="term"><code class="literal">PGRES_EMPTY_QUERY</code></span> <a href="#LIBPQ-PGRES-EMPTY-QUERY" class="id_link">#</a></dt><dd><p>Строка, отправленная серверу, была пустой.</p></dd><dt id="LIBPQ-PGRES-COMMAND-OK"><span class="term"><code class="literal">PGRES_COMMAND_OK</code></span> <a href="#LIBPQ-PGRES-COMMAND-OK" class="id_link">#</a></dt><dd><p>Успешное завершение команды, не возвращающей никаких данных.</p></dd><dt id="LIBPQ-PGRES-TUPLES-OK"><span class="term"><code class="literal">PGRES_TUPLES_OK</code></span> <a href="#LIBPQ-PGRES-TUPLES-OK" class="id_link">#</a></dt><dd><p>Успешное завершение команды, возвращающей данные (такой, как <code class="command">SELECT</code> или <code class="command">SHOW</code>).</p></dd><dt id="LIBPQ-PGRES-COPY-OUT"><span class="term"><code class="literal">PGRES_COPY_OUT</code></span> <a href="#LIBPQ-PGRES-COPY-OUT" class="id_link">#</a></dt><dd><p>Начат перенос данных Copy Out (с сервера).</p></dd><dt id="LIBPQ-PGRES-COPY-IN"><span class="term"><code class="literal">PGRES_COPY_IN</code></span> <a href="#LIBPQ-PGRES-COPY-IN" class="id_link">#</a></dt><dd><p>Начат перенос данных Copy In (на сервер).</p></dd><dt id="LIBPQ-PGRES-BAD-RESPONSE"><span class="term"><code class="literal">PGRES_BAD_RESPONSE</code></span> <a href="#LIBPQ-PGRES-BAD-RESPONSE" class="id_link">#</a></dt><dd><p>Ответ сервера не был распознан.</p></dd><dt id="LIBPQ-PGRES-NONFATAL-ERROR"><span class="term"><code class="literal">PGRES_NONFATAL_ERROR</code></span> <a href="#LIBPQ-PGRES-NONFATAL-ERROR" class="id_link">#</a></dt><dd><p>Произошла некритическая ошибка (уведомление или предупреждение).</p></dd><dt id="LIBPQ-PGRES-FATAL-ERROR"><span class="term"><code class="literal">PGRES_FATAL_ERROR</code></span> <a href="#LIBPQ-PGRES-FATAL-ERROR" class="id_link">#</a></dt><dd><p>Произошла критическая ошибка.</p></dd><dt id="LIBPQ-PGRES-COPY-BOTH"><span class="term"><code class="literal">PGRES_COPY_BOTH</code></span> <a href="#LIBPQ-PGRES-COPY-BOTH" class="id_link">#</a></dt><dd><p>Начат перенос данных Copy In/Out (на сервер и с сервера). Эта функция в настоящее время используется только для потоковой репликации, поэтому такой статус не должен иметь место в обычных приложениях.</p></dd><dt id="LIBPQ-PGRES-SINGLE-TUPLE"><span class="term"><code class="literal">PGRES_SINGLE_TUPLE</code></span> <a href="#LIBPQ-PGRES-SINGLE-TUPLE" class="id_link">#</a></dt><dd><p>Структура <code class="structname">PGresult</code> содержит только одну результирующую строку, возвращённую текущей командой. Этот статус имеет место только тогда, когда для данного запроса был выбран режим построчного вывода (см. <a class="xref" href="libpq-single-row-mode.html" title="34.6. Построчное извлечение результатов запроса">Раздел 34.6</a>).</p></dd><dt id="LIBPQ-PGRES-PIPELINE-SYNC"><span class="term"><code class="literal">PGRES_PIPELINE_SYNC</code></span> <a href="#LIBPQ-PGRES-PIPELINE-SYNC" class="id_link">#</a></dt><dd><p><code class="structname">PGresult</code> представляет точку синхронизации в конвейерном режиме, запрошенную <a class="xref" href="libpq-pipeline-mode.html#LIBPQ-PQPIPELINESYNC"><code class="function">PQpipelineSync</code></a>. Этот статус возможен, только если выбран конвейерный режим.</p></dd><dt id="LIBPQ-PGRES-PIPELINE-ABORTED"><span class="term"><code class="literal">PGRES_PIPELINE_ABORTED</code></span> <a href="#LIBPQ-PGRES-PIPELINE-ABORTED" class="id_link">#</a></dt><dd><p>Структура <code class="structname">PGresult</code> представляет конвейер, получивший ошибку от сервера. Функция <code class="function">PQgetResult</code> должна вызываться неоднократно, и каждый раз она будет возвращать этот код состояния до конца текущего конвейера, после чего она вернёт <code class="literal">PGRES_PIPELINE_SYNC</code> и сможет возобновиться нормальная обработка.</p></dd></dl></div><p> Если статус результата <code class="literal">PGRES_TUPLES_OK</code> или <code class="literal">PGRES_SINGLE_TUPLE</code>, тогда для извлечения строк, возвращённых запросом, можно использовать функции, описанные ниже. Обратите внимание, что команда <code class="command">SELECT</code>, даже когда она не извлекает ни одной строки, всё же показывает <code class="literal">PGRES_TUPLES_OK</code>. <code class="literal">PGRES_COMMAND_OK</code> предназначен для команд, которые никогда не возвращают строки (<code class="command">INSERT</code> или <code class="command">UPDATE</code> без использования предложения <code class="literal">RETURNING</code> и др.). Ответ <code class="literal">PGRES_EMPTY_QUERY</code> может указывать на наличие ошибки в клиентском программном обеспечении.</p><p>Результат со статусом <code class="symbol">PGRES_NONFATAL_ERROR</code> никогда не будет возвращён напрямую функцией <a class="xref" href="libpq-exec.html#LIBPQ-PQEXEC"><code class="function">PQexec</code></a> или другими функциями исполнения запросов; вместо этого результаты такого вида передаются обработчику уведомлений (см. <a class="xref" href="libpq-notice-processing.html" title="34.13. Обработка замечаний">Раздел 34.13</a>).</p></dd><dt id="LIBPQ-PQRESSTATUS"><span class="term"><code class="function">PQresStatus</code><a id="id-1.7.3.10.3.9.7.2.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQRESSTATUS" class="id_link">#</a></dt><dd><p>Преобразует значение перечислимого типа, возвращённое функцией <a class="xref" href="libpq-exec.html#LIBPQ-PQRESULTSTATUS"><code class="function">PQresultStatus</code></a>, в строковую константу, описывающую код статуса. Вызывающая функция не должна освобождать память, на которую указывает возвращаемый указатель. </p><pre class="synopsis">
char *PQresStatus(ExecStatusType status);
</pre></dd><dt id="LIBPQ-PQRESULTERRORMESSAGE"><span class="term"><code class="function">PQresultErrorMessage</code><a id="id-1.7.3.10.3.9.7.3.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQRESULTERRORMESSAGE" class="id_link">#</a></dt><dd><p>Возвращает сообщение об ошибке, связанное с командой, или пустую строку, если ошибки не произошло. </p><pre class="synopsis">
char *PQresultErrorMessage(const PGresult *res);
</pre><p> Если произошла ошибка, то возвращённая строка будет включать завершающий символ новой строки. Вызывающая функция не должна напрямую освобождать память, на которую указывает возвращаемый указатель. Она будет освобождена, когда соответствующий указатель <code class="structname">PGresult</code> будет передан функции <a class="xref" href="libpq-exec.html#LIBPQ-PQCLEAR"><code class="function">PQclear</code></a>.</p><p>Если непосредственно после вызова <a class="xref" href="libpq-exec.html#LIBPQ-PQEXEC"><code class="function">PQexec</code></a> или <a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a> вызвать функцию <a class="xref" href="libpq-status.html#LIBPQ-PQERRORMESSAGE"><code class="function">PQerrorMessage</code></a> (для данного подключения), то она возвратит ту же самую строку, что и <a class="xref" href="libpq-exec.html#LIBPQ-PQRESULTERRORMESSAGE"><code class="function">PQresultErrorMessage</code></a> (для данного результата). Однако <code class="structname">PGresult</code> сохранит своё сообщение об ошибке до тех пор, пока не будет уничтожен, в то время как сообщение об ошибке, связанное с данным подключением, будет изменяться при выполнении последующих операций. Воспользуйтесь функцией <a class="xref" href="libpq-exec.html#LIBPQ-PQRESULTERRORMESSAGE"><code class="function">PQresultErrorMessage</code></a>, когда вы хотите узнать статус, связанный с конкретной структурой <code class="structname">PGresult</code>; используйте функцию <a class="xref" href="libpq-status.html#LIBPQ-PQERRORMESSAGE"><code class="function">PQerrorMessage</code></a>, когда вы хотите узнать статус выполнения самой последней операции на данном соединении.</p></dd><dt id="LIBPQ-PQRESULTVERBOSEERRORMESSAGE"><span class="term"><code class="function">PQresultVerboseErrorMessage</code><a id="id-1.7.3.10.3.9.7.4.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQRESULTVERBOSEERRORMESSAGE" class="id_link">#</a></dt><dd><p>Возвращает переформатированную версию сообщения об ошибке, связанного с объектом <code class="structname">PGresult</code>. </p><pre class="synopsis">
char *PQresultVerboseErrorMessage(const PGresult *res,
                                  PGVerbosity verbosity,
                                  PGContextVisibility show_context);
</pre><p> В некоторых ситуациях клиент может захотеть получить более подробную версию ранее выданного сообщения об ошибке. Эту потребность удовлетворяет функция <a class="xref" href="libpq-exec.html#LIBPQ-PQRESULTVERBOSEERRORMESSAGE"><code class="function">PQresultVerboseErrorMessage</code></a>, формируя сообщение, которое было бы выдано функцией <a class="xref" href="libpq-exec.html#LIBPQ-PQRESULTERRORMESSAGE"><code class="function">PQresultErrorMessage</code></a>, если бы заданный уровень детализации был текущим для соединения в момент заполнения <code class="structname">PGresult</code>. Если же в <code class="structname">PGresult</code> не содержится ошибка, вместо этого выдаётся сообщение <span class="quote">«<span class="quote">PGresult is not an error result</span>»</span> (PGresult — не результат с ошибкой). Возвращаемое этой функцией сообщение завершается переводом строки.</p><p>В отличие от многих других функций, извлекающих данные из <code class="structname">PGresult</code>, результат этой функции — новая размещённая в памяти строка. Когда эта строка будет не нужна, вызывающий код должен освободить её место, вызвав <code class="function">PQfreemem()</code>.</p><p>При нехватке памяти может быть возвращёно NULL.</p></dd><dt id="LIBPQ-PQRESULTERRORFIELD"><span class="term"><code class="function">PQresultErrorField</code><a id="id-1.7.3.10.3.9.7.5.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQRESULTERRORFIELD" class="id_link">#</a></dt><dd><p>Возвращает индивидуальное поле из отчёта об ошибке. </p><pre class="synopsis">
char *PQresultErrorField(const PGresult *res, int fieldcode);
</pre><p> <em class="parameter"><code>fieldcode</code></em> это идентификатор поля ошибки; см. символические константы, перечисленные ниже. Если <code class="structname">PGresult</code> не содержит ошибки или предупреждения или не включает указанное поле, то возвращается <code class="symbol">NULL</code>. Значения полей обычно не включают завершающий символ новой строки. Вызывающая функция не должна напрямую освобождать память, на которую указывает возвращаемый указатель. Она будет освобождена, когда соответствующий указатель <code class="structname">PGresult</code> будет передан функции <a class="xref" href="libpq-exec.html#LIBPQ-PQCLEAR"><code class="function">PQclear</code></a>.</p><p>Доступны следующие коды полей: </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PG-DIAG-SEVERITY"><span class="term"><code class="symbol">PG_DIAG_SEVERITY</code></span> <a href="#LIBPQ-PG-DIAG-SEVERITY" class="id_link">#</a></dt><dd><p>Серьёзность; поле может содержать <code class="literal">ERROR</code>, <code class="literal">FATAL</code> или <code class="literal">PANIC</code> (в сообщении об ошибке) либо <code class="literal">WARNING</code>, <code class="literal">NOTICE</code>, <code class="literal">DEBUG</code>, <code class="literal">INFO</code> или <code class="literal">LOG</code> (в сообщении-уведомлении) либо локализованный перевод одного из этих значений. Присутствует всегда.</p></dd><dt id="LIBPQ-PG-DIAG-SEVERITY-NONLOCALIZED"><span class="term"><code class="symbol">PG_DIAG_SEVERITY_NONLOCALIZED</code></span> <a href="#LIBPQ-PG-DIAG-SEVERITY-NONLOCALIZED" class="id_link">#</a></dt><dd><p>Серьёзность; поле может содержать <code class="literal">ERROR</code>, <code class="literal">FATAL</code> или <code class="literal">PANIC</code> (в сообщении об ошибке) либо <code class="literal">WARNING</code>, <code class="literal">NOTICE</code>, <code class="literal">DEBUG</code>, <code class="literal">INFO</code> или <code class="literal">LOG</code> (в сообщении-уведомлении). Это поле подобно <code class="symbol">PG_DIAG_SEVERITY</code>, но его содержимое никогда не переводится. Присутствует только в отчётах, выдаваемых <span class="productname">PostgreSQL</span> версии 9.6 и новее.</p></dd><dt id="LIBPQ-PG-DIAG-SQLSTATE"><span class="term"><code class="symbol">PG_DIAG_SQLSTATE</code><a id="id-1.7.3.10.3.9.7.5.2.2.1.3.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PG-DIAG-SQLSTATE" class="id_link">#</a></dt><dd><p>Код ошибки в соответствии с соглашением о кодах SQLSTATE. Код SQLSTATE идентифицирует тип случившейся ошибки; он может использоваться клиентскими приложениями, чтобы выполнять конкретные операции (такие, как обработка ошибок) в ответ на конкретную ошибку базы данных. Список возможных кодов SQLSTATE приведён в <a class="xref" href="errcodes-appendix.html" title="Приложение A. Коды ошибок PostgreSQL">Приложении A</a>. Это поле не подлежит локализации. Оно всегда присутствует.</p></dd><dt id="LIBPQ-PG-DIAG-MESSAGE-PRIMARY"><span class="term"><code class="symbol">PG_DIAG_MESSAGE_PRIMARY</code></span> <a href="#LIBPQ-PG-DIAG-MESSAGE-PRIMARY" class="id_link">#</a></dt><dd><p>Главное сообщение об ошибке, предназначенное для прочтения пользователем. Как правило составляет всего одну строку. Это поле всегда присутствует.</p></dd><dt id="LIBPQ-PG-DIAG-MESSAGE-DETAIL"><span class="term"><code class="symbol">PG_DIAG_MESSAGE_DETAIL</code></span> <a href="#LIBPQ-PG-DIAG-MESSAGE-DETAIL" class="id_link">#</a></dt><dd><p>Необязательное дополнительное сообщение об ошибке, передающее более детальную информацию о проблеме. Может занимать несколько строк.</p></dd><dt id="LIBPQ-PG-DIAG-MESSAGE-HINT"><span class="term"><code class="symbol">PG_DIAG_MESSAGE_HINT</code></span> <a href="#LIBPQ-PG-DIAG-MESSAGE-HINT" class="id_link">#</a></dt><dd><p>Подсказка: необязательное предположение о том, что можно сделать в данной проблемной ситуации. Оно должно отличаться от детальной информации в том смысле, что оно предлагает совет (возможно, и неподходящий), а не просто факты. Может занимать несколько строк.</p></dd><dt id="LIBPQ-PG-DIAG-STATEMENT-POSITION"><span class="term"><code class="symbol">PG_DIAG_STATEMENT_POSITION</code></span> <a href="#LIBPQ-PG-DIAG-STATEMENT-POSITION" class="id_link">#</a></dt><dd><p>Строка, содержащая десятичное целое число, указывающее позицию расположения ошибки в качестве индекса в оригинальной строке оператора. Первый символ имеет позицию 1, при этом позиции измеряются в символах а не в байтах.</p></dd><dt id="LIBPQ-PG-DIAG-INTERNAL-POSITION"><span class="term"><code class="symbol">PG_DIAG_INTERNAL_POSITION</code></span> <a href="#LIBPQ-PG-DIAG-INTERNAL-POSITION" class="id_link">#</a></dt><dd><p>Это поле определяется точно так же, как и поле <code class="symbol">PG_DIAG_STATEMENT_POSITION</code>, но оно используется, когда позиция местонахождения ошибки относится к команде, сгенерированной внутренними модулями, а не к команде, представленной клиентом. Когда появляется это поле, то всегда появляется и поле <code class="symbol">PG_DIAG_INTERNAL_QUERY</code>.</p></dd><dt id="LIBPQ-PG-DIAG-INTERNAL-QUERY"><span class="term"><code class="symbol">PG_DIAG_INTERNAL_QUERY</code></span> <a href="#LIBPQ-PG-DIAG-INTERNAL-QUERY" class="id_link">#</a></dt><dd><p>Текст команды, сгенерированной внутренними модулями, завершившейся сбоем. Это мог бы быть, например, SQL-запрос, выданный функцией на языке PL/pgSQL.</p></dd><dt id="LIBPQ-PG-DIAG-CONTEXT"><span class="term"><code class="symbol">PG_DIAG_CONTEXT</code></span> <a href="#LIBPQ-PG-DIAG-CONTEXT" class="id_link">#</a></dt><dd><p>Характеристика контекста, в котором произошла ошибка. В настоящее время она включает вывод стека вызовов активных функций процедурного языка и запросов, сгенерированных внутренними модулями. Стек выводится по одному элементу в строке, при этом первым идет самый последний из элементов (самый недавний вызов).</p></dd><dt id="LIBPQ-PG-DIAG-SCHEMA-NAME"><span class="term"><code class="symbol">PG_DIAG_SCHEMA_NAME</code></span> <a href="#LIBPQ-PG-DIAG-SCHEMA-NAME" class="id_link">#</a></dt><dd><p>Если ошибка была связана с конкретным объектом базы данных, то в это поле будет записано имя схемы, содержащей данный объект.</p></dd><dt id="LIBPQ-PG-DIAG-TABLE-NAME"><span class="term"><code class="symbol">PG_DIAG_TABLE_NAME</code></span> <a href="#LIBPQ-PG-DIAG-TABLE-NAME" class="id_link">#</a></dt><dd><p>Если ошибка была связана с конкретной таблицей, то в это поле будет записано имя таблицы. (Для получения имени схемы для данной таблицы обратитесь к полю, содержащему имя схемы.)</p></dd><dt id="LIBPQ-PG-DIAG-COLUMN-NAME"><span class="term"><code class="symbol">PG_DIAG_COLUMN_NAME</code></span> <a href="#LIBPQ-PG-DIAG-COLUMN-NAME" class="id_link">#</a></dt><dd><p>Если ошибка была связана с конкретным столбцом таблицы, то в это поле будет записано имя столбца. (Чтобы идентифицировать таблицу, обратитесь к полям, содержащим имена схемы и таблицы.)</p></dd><dt id="LIBPQ-PG-DIAG-DATATYPE-NAME"><span class="term"><code class="symbol">PG_DIAG_DATATYPE_NAME</code></span> <a href="#LIBPQ-PG-DIAG-DATATYPE-NAME" class="id_link">#</a></dt><dd><p>Если ошибка была связана с конкретным типом данных, то в это поле будет записано имя типа данных. (Чтобы получить имя схемы, которой принадлежит этот тип данных, обратитесь к полю, содержащему имя схемы.)</p></dd><dt id="LIBPQ-PG-DIAG-CONSTRAINT-NAME"><span class="term"><code class="symbol">PG_DIAG_CONSTRAINT_NAME</code></span> <a href="#LIBPQ-PG-DIAG-CONSTRAINT-NAME" class="id_link">#</a></dt><dd><p>Если ошибка была связана с конкретным ограничением, то в это поле будет записано имя ограничения. Чтобы получить имя таблицы или домена, связанных с этим ограничением, обратитесь к полям, перечисленным выше. (С этой целью индексы рассматриваются как ограничения, даже если они и не были созданы с помощью синтаксиса для создания ограничений.)</p></dd><dt id="LIBPQ-PG-DIAG-SOURCE-FILE"><span class="term"><code class="symbol">PG_DIAG_SOURCE_FILE</code></span> <a href="#LIBPQ-PG-DIAG-SOURCE-FILE" class="id_link">#</a></dt><dd><p>Имя файла, содержащего позицию в исходном коде, для которой было выдано сообщение об ошибка.</p></dd><dt id="LIBPQ-PG-DIAG-SOURCE-LINE"><span class="term"><code class="symbol">PG_DIAG_SOURCE_LINE</code></span> <a href="#LIBPQ-PG-DIAG-SOURCE-LINE" class="id_link">#</a></dt><dd><p>Номер строки той позиции в исходном коде, для которой было выдано сообщение об ошибке.</p></dd><dt id="LIBPQ-PG-DIAG-SOURCE-FUNCTION"><span class="term"><code class="symbol">PG_DIAG_SOURCE_FUNCTION</code></span> <a href="#LIBPQ-PG-DIAG-SOURCE-FUNCTION" class="id_link">#</a></dt><dd><p>Имя функции в исходном коде, сообщающей об ошибке.</p></dd></dl></div><div class="note"><h3 class="title">Примечание</h3><p>Поля для имени схемы, имени таблицы, имени столбца, имени типа данных и имени ограничения предоставляются лишь для ограниченного числа типов ошибок; см. <a class="xref" href="errcodes-appendix.html" title="Приложение A. Коды ошибок PostgreSQL">Приложение A</a>. Не рассчитывайте на то, что присутствие любого из этих полей гарантирует и присутствие какого-то другого поля. Базовые источники ошибок придерживаются взаимосвязей, описанных выше, но функции, определённые пользователем, могут использовать эти поля другими способами. Аналогично, не рассчитывайте на то, что эти поля обозначают объекты, существующие в текущей базе данных в настоящий момент.</p></div><p>Клиент отвечает за форматирование отображаемой информации в соответствии с его нуждами; в частности, он должен разбивать длинные строки, как требуется. Символы новой строки, встречающиеся в полях сообщения об ошибке, должны обрабатываться, как разрывы абзацев, а не строк.</p><p>Ошибки, сгенерированные внутренними модулями <span class="application">libpq</span>, будут иметь поля серьёзности ошибки и основного сообщения, но, как правило, никаких других полей.</p><p>Заметьте, что поля ошибки доступны только из объектов <code class="structname">PGresult</code>, а не из объектов <code class="structname">PGconn</code>. Не существует функции <code class="function">PQerrorField</code>.</p></dd><dt id="LIBPQ-PQCLEAR"><span class="term"><code class="function">PQclear</code><a id="id-1.7.3.10.3.9.7.6.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQCLEAR" class="id_link">#</a></dt><dd><p>Освобождает область памяти, связанную с <code class="structname">PGresult</code>. Результат выполнения каждой команды должен быть освобождён с помощью <a class="xref" href="libpq-exec.html#LIBPQ-PQCLEAR"><code class="function">PQclear</code></a>, когда он больше не нужен. </p><pre class="synopsis">
void PQclear(PGresult *res);
</pre><p> Если аргумент является указателем <code class="symbol">NULL</code>, операция не выполняется.</p><p>Вы можете сохранять объект <code class="structname">PGresult</code>, пока он вам нужен; он не исчезает ни когда вы выдаёте новую команду, ни даже если вы закрываете соединение. Чтобы от него избавиться, вы должны вызвать <a class="xref" href="libpq-exec.html#LIBPQ-PQCLEAR"><code class="function">PQclear</code></a>. Если этого не делать, в вашем приложении будут иметь место утечки памяти.</p></dd></dl></div></div><div class="sect2" id="LIBPQ-EXEC-SELECT-INFO"><div class="titlepage"><div><div><h3 class="title">34.3.2. Извлечение информации, связанной с результатом запроса <a href="#LIBPQ-EXEC-SELECT-INFO" class="id_link">#</a></h3></div></div></div><p>Эти функции служат для извлечения информации из объекта <code class="structname">PGresult</code>, который представляет результат успешного запроса (то есть такого, который имеет статус <code class="literal">PGRES_TUPLES_OK</code> или <code class="literal">PGRES_SINGLE_TUPLE</code>). Их также можно использовать для извлечения информации об успешной операции DESCRIBE: результат этой операции содержит всю ту же самую информацию о столбцах, которая была бы получена при реальном исполнении запроса, но не содержит ни одной строки. Для объектов, имеющих другие значения статуса, эти функции будут действовать таким образом, как будто результат не содержит ни одной строки и ни одного столбца.</p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQNTUPLES"><span class="term"><code class="function">PQntuples</code><a id="id-1.7.3.10.4.3.1.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQNTUPLES" class="id_link">#</a></dt><dd><p>Возвращает число строк (кортежей) в полученной выборке. (Заметьте, что объекты <code class="structname">PGresult</code> не могут содержать более чем <code class="literal">INT_MAX</code> строк, так что для результата достаточно типа <code class="type">int</code>.) </p><pre class="synopsis">
int PQntuples(const PGresult *res);
</pre></dd><dt id="LIBPQ-PQNFIELDS"><span class="term"><code class="function">PQnfields</code><a id="id-1.7.3.10.4.3.2.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQNFIELDS" class="id_link">#</a></dt><dd><p>Возвращает число столбцов (полей) в каждой строке полученной выборки. </p><pre class="synopsis">
int PQnfields(const PGresult *res);
</pre></dd><dt id="LIBPQ-PQFNAME"><span class="term"><code class="function">PQfname</code><a id="id-1.7.3.10.4.3.3.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQFNAME" class="id_link">#</a></dt><dd><p>Возвращает имя столбца, соответствующего данному номеру столбца. Номера столбцов начинаются с 0. Вызывающая функция не должна напрямую освобождать память, на которую указывает возвращаемый указатель. Она будет освобождена, когда соответствующий указатель на <code class="structname">PGresult</code> будет передан функции <a class="xref" href="libpq-exec.html#LIBPQ-PQCLEAR"><code class="function">PQclear</code></a>. </p><pre class="synopsis">
char *PQfname(const PGresult *res,
              int column_number);
</pre><p>Если номер столбца выходит за пределы допустимого диапазона, то возвращается <code class="symbol">NULL</code>.</p></dd><dt id="LIBPQ-PQFNUMBER"><span class="term"><code class="function">PQfnumber</code><a id="id-1.7.3.10.4.3.4.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQFNUMBER" class="id_link">#</a></dt><dd><p>Возвращает номер столбца, соответствующий данному имени столбца. </p><pre class="synopsis">
int PQfnumber(const PGresult *res,
              const char *column_name);
</pre><p>Если данное имя не совпадает с именем ни одного из столбцов, то возвращается -1.</p><p>Данное имя интерпретируется, как идентификатор в SQL-команде. Это означает, что оно переводится в нижний регистр, если только оно не заключено в двойные кавычки. Например, для выборки, сгенерированной с помощью такой SQL-команды: </p><pre class="programlisting">SELECT 1 AS FOO, 2 AS "BAR";</pre><p> мы получили бы следующие результаты: </p><pre class="programlisting">PQfname(res, 0)              <em class="lineannotation"><span class="lineannotation">foo</span></em>
PQfname(res, 1)              <em class="lineannotation"><span class="lineannotation">BAR</span></em>
PQfnumber(res, "FOO")        <em class="lineannotation"><span class="lineannotation">0</span></em>
PQfnumber(res, "foo")        <em class="lineannotation"><span class="lineannotation">0</span></em>
PQfnumber(res, "BAR")        <em class="lineannotation"><span class="lineannotation">-1</span></em>
PQfnumber(res, "\"BAR\"")    <em class="lineannotation"><span class="lineannotation">1</span></em></pre></dd><dt id="LIBPQ-PQFTABLE"><span class="term"><code class="function">PQftable</code><a id="id-1.7.3.10.4.3.5.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQFTABLE" class="id_link">#</a></dt><dd><p>Возвращает OID таблицы, из которой был получен данный столбец. Номера столбцов начинаются с 0. </p><pre class="synopsis">
Oid PQftable(const PGresult *res,
             int column_number);
</pre><p>В следующих случаях возвращается <code class="literal">InvalidOid</code>: если номер столбца выходит за пределы допустимого диапазона; если указанный столбец не является простой ссылкой на столбец таблицы. Вы можете сделать запрос к системной таблице <code class="literal">pg_class</code>, чтобы точно определить, к какой таблице было произведено обращение.</p><p>Тип данных <code class="type">Oid</code> и константа <code class="literal">InvalidOid</code> будут определены, когда вы включите заголовочный файл для <span class="application">libpq</span>. Они будут принадлежать к одному из целочисленных типов.</p></dd><dt id="LIBPQ-PQFTABLECOL"><span class="term"><code class="function">PQftablecol</code><a id="id-1.7.3.10.4.3.6.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQFTABLECOL" class="id_link">#</a></dt><dd><p>Возвращает номер столбца (в пределах его таблицы) для указанного столбца в полученной выборке. Номера столбцов в полученной выборке начинаются с 0, но столбцы в таблице имеют ненулевые номера. </p><pre class="synopsis">
int PQftablecol(const PGresult *res,
                int column_number);
</pre><p>В следующих случаях возвращается ноль: если номер столбца выходит за пределы допустимого диапазона; если указанный столбец не является простой ссылкой на столбец таблицы.</p></dd><dt id="LIBPQ-PQFFORMAT"><span class="term"><code class="function">PQfformat</code><a id="id-1.7.3.10.4.3.7.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQFFORMAT" class="id_link">#</a></dt><dd><p>Возвращает код формата, показывающий формат данного столбца. Номера столбцов начинаются с 0. </p><pre class="synopsis">
int PQfformat(const PGresult *res,
              int column_number);
</pre><p>Значение кода формата, равное нулю, указывает на текстовое представление данных, в то время, как значение, равное единице, означает двоичное представление. (Другие значения кодов зарезервированы для определения в будущем.)</p></dd><dt id="LIBPQ-PQFTYPE"><span class="term"><code class="function">PQftype</code><a id="id-1.7.3.10.4.3.8.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQFTYPE" class="id_link">#</a></dt><dd><p>Возвращает тип данных, соответствующий данному номеру столбца. Возвращаемое целое значение является внутренним номером OID для этого типа. Номера столбцов начинаются с 0. </p><pre class="synopsis">
Oid PQftype(const PGresult *res,
            int column_number);
</pre><p>Вы можете сделать запрос к системной таблице <code class="literal">pg_type</code>, чтобы получить имена и свойства различных типов данных. Значения <acronym class="acronym">OID</acronym> для встроенных типов данных определены в файле <code class="filename">catalog/pg_type_d.h</code> в каталоге <code class="filename">include</code> установленного сервера <span class="productname">PostgreSQL</span>.</p></dd><dt id="LIBPQ-PQFMOD"><span class="term"><code class="function">PQfmod</code><a id="id-1.7.3.10.4.3.9.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQFMOD" class="id_link">#</a></dt><dd><p>Возвращает модификатор типа для столбца, соответствующего данному номеру. Номера столбцов начинаются с 0. </p><pre class="synopsis">
int PQfmod(const PGresult *res,
           int column_number);
</pre><p>Интерпретация значений модификатора зависит от типа; они обычно показывают точность или предельные размеры. Значение -1 используется, чтобы показать <span class="quote">«<span class="quote">нет доступной информации</span>»</span>. Большинство типов данных не используют модификаторов, в таком случае значение всегда будет -1.</p></dd><dt id="LIBPQ-PQFSIZE"><span class="term"><code class="function">PQfsize</code><a id="id-1.7.3.10.4.3.10.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQFSIZE" class="id_link">#</a></dt><dd><p>Возвращает размер в байтах для столбца, соответствующего данному номеру. Номера столбцов начинаются с 0. </p><pre class="synopsis">
int PQfsize(const PGresult *res,
            int column_number);
</pre><p><a class="xref" href="libpq-exec.html#LIBPQ-PQFSIZE"><code class="function">PQfsize</code></a> возвращает размер пространства, выделенного для этого столбца в строке базы данных, другими словами, это размер внутреннего представления этого типа данных на сервере. (Следовательно, эта информация не является по-настоящему полезной для клиентов.) Отрицательное значение говорит о том, что тип данных имеет переменную длину.</p></dd><dt id="LIBPQ-PQBINARYTUPLES"><span class="term"><code class="function">PQbinaryTuples</code><a id="id-1.7.3.10.4.3.11.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQBINARYTUPLES" class="id_link">#</a></dt><dd><p>Возвращает 1, если <code class="structname">PGresult</code> содержит двоичные данные, или 0, если данные текстовые. </p><pre class="synopsis">
int PQbinaryTuples(const PGresult *res);
</pre><p>Эта функция не рекомендуется к использованию (за исключением применения в связи с командой <code class="command">COPY</code>), поскольку один и тот же <code class="structname">PGresult</code> может содержать в некоторых столбцах текстовые данные, а в остальных — двоичные. Предпочтительнее использовать <a class="xref" href="libpq-exec.html#LIBPQ-PQFFORMAT"><code class="function">PQfformat</code></a>. <a class="xref" href="libpq-exec.html#LIBPQ-PQBINARYTUPLES"><code class="function">PQbinaryTuples</code></a> возвращает 1, только если все столбцы в выборке являются двоичными (код формата 1).</p></dd><dt id="LIBPQ-PQGETVALUE"><span class="term"><code class="function">PQgetvalue</code><a id="id-1.7.3.10.4.3.12.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQGETVALUE" class="id_link">#</a></dt><dd><p>Возвращает значение одного поля из одной строки, содержащейся в <code class="structname">PGresult</code>. Номера строк и столбцов начинаются с 0. Вызывающая функция не должна напрямую освобождать память, на которую указывает возвращаемый указатель. Она будет освобождена, когда соответствующий указатель на <code class="structname">PGresult</code> будет передан функции <a class="xref" href="libpq-exec.html#LIBPQ-PQCLEAR"><code class="function">PQclear</code></a>. </p><pre class="synopsis">
char *PQgetvalue(const PGresult *res,
                 int row_number,
                 int column_number);
</pre><p>Для данных в текстовом формате значение, возвращаемое функцией <a class="xref" href="libpq-exec.html#LIBPQ-PQGETVALUE"><code class="function">PQgetvalue</code></a>, является значением поля, представленным в виде символьной строки с завершающим нулевым символом. Для данных в двоичном формате используется двоичное представление значения. Оно определяется функциями <code class="function">typsend</code> и <code class="function">typreceive</code> для конкретного типа данных. (В этом случае к значению также добавляется нулевой байт, но обычно это не приносит пользы, поскольку вероятно, что значение уже содержит нулевые байты.)</p><p>Пустая строка возвращается в том случае, когда поле содержит null. Чтобы отличить значения null от пустых строковых значений, воспользуйтесь функцией <a class="xref" href="libpq-exec.html#LIBPQ-PQGETISNULL"><code class="function">PQgetisnull</code></a>.</p><p>Указатель, возвращаемый функцией <a class="xref" href="libpq-exec.html#LIBPQ-PQGETVALUE"><code class="function">PQgetvalue</code></a>, указывает на область памяти внутри структуры <code class="structname">PGresult</code>. Модифицировать данные, на которые указывает этот указатель, не следует. Вместо этого нужно явно скопировать данные в другую область памяти, если предполагается использовать их за рамками жизненного цикла структуры <code class="structname">PGresult</code>.</p></dd><dt id="LIBPQ-PQGETISNULL"><span class="term"><code class="function">PQgetisnull</code><a id="id-1.7.3.10.4.3.13.1.2" class="indexterm"></a><a id="id-1.7.3.10.4.3.13.1.3" class="indexterm"></a></span> <a href="#LIBPQ-PQGETISNULL" class="id_link">#</a></dt><dd><p>Проверяет поле на предмет отсутствия значения (null). Номера строк и столбцов начинаются с 0. </p><pre class="synopsis">
int PQgetisnull(const PGresult *res,
                int row_number,
                int column_number);
</pre><p>Эта функция возвращает 1, если значение в поле отсутствует (null), и 0, если поле содержит отличное от null значение. (Заметьте, что если поле содержит null, функция <a class="xref" href="libpq-exec.html#LIBPQ-PQGETVALUE"><code class="function">PQgetvalue</code></a> возвращает пустую строку, а не нулевой указатель.)</p></dd><dt id="LIBPQ-PQGETLENGTH"><span class="term"><code class="function">PQgetlength</code><a id="id-1.7.3.10.4.3.14.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQGETLENGTH" class="id_link">#</a></dt><dd><p>Возвращает фактическую длину значения поля в байтах. Номера строк и столбцов начинаются с 0. </p><pre class="synopsis">
int PQgetlength(const PGresult *res,
                int row_number,
                int column_number);
</pre><p>Это фактическая длина данных для конкретного значения данных, то есть размер объекта, на который указывает <a class="xref" href="libpq-exec.html#LIBPQ-PQGETVALUE"><code class="function">PQgetvalue</code></a>. Для текстового формата данных это то же самое, что <code class="function">strlen()</code>. Для двоичного же формата это существенная информация. Учтите, что при расчёте фактического объёма данных <span class="emphasis"><em>не</em></span> следует полагаться на <a class="xref" href="libpq-exec.html#LIBPQ-PQFSIZE"><code class="function">PQfsize</code></a>.</p></dd><dt id="LIBPQ-PQNPARAMS"><span class="term"><code class="function">PQnparams</code><a id="id-1.7.3.10.4.3.15.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQNPARAMS" class="id_link">#</a></dt><dd><p>Возвращает число параметров подготовленного оператора. </p><pre class="synopsis">
int PQnparams(const PGresult *res);
</pre><p>Эта функция полезна только при исследовании результата работы функции <a class="xref" href="libpq-exec.html#LIBPQ-PQDESCRIBEPREPARED"><code class="function">PQdescribePrepared</code></a>. Для других типов результатов она возвратит ноль.</p></dd><dt id="LIBPQ-PQPARAMTYPE"><span class="term"><code class="function">PQparamtype</code><a id="id-1.7.3.10.4.3.16.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQPARAMTYPE" class="id_link">#</a></dt><dd><p>Возвращает тип данных для указанного параметра оператора. Номера параметров начинаются с 0. </p><pre class="synopsis">
Oid PQparamtype(const PGresult *res, int param_number);
</pre><p>Эта функция полезна только при исследовании результата работы функции <a class="xref" href="libpq-exec.html#LIBPQ-PQDESCRIBEPREPARED"><code class="function">PQdescribePrepared</code></a>. Для других типов результатов она возвратит ноль.</p></dd><dt id="LIBPQ-PQPRINT"><span class="term"><code class="function">PQprint</code><a id="id-1.7.3.10.4.3.17.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQPRINT" class="id_link">#</a></dt><dd><p>Выводит все строки и, по выбору, имена столбцов в указанный поток вывода. </p><pre class="synopsis">
void PQprint(FILE *fout,      /* поток вывода */
             const PGresult *res,
             const PQprintOpt *po);
typedef struct
{
    pqbool  header;      /* печатать заголовки полей и счётчик строк */
    pqbool  align;       /* выравнивать поля */
    pqbool  standard;    /* старый формат */
    pqbool  html3;       /* выводить HTML-таблицы */
    pqbool  expanded;    /* расширять таблицы */
    pqbool  pager;       /* использовать программу для постраничного просмотра, если нужно */
    char    *fieldSep;   /* разделитель полей */
    char    *tableOpt;   /* атрибуты для HTML-таблицы */
    char    *caption;    /* заголовок HTML-таблицы */
    char    **fieldName; /* массив заменителей для имён полей, завершающийся нулевым символом */
} PQprintOpt;
</pre><p>Эту функцию прежде использовала утилита <span class="application">psql</span> для вывода результатов запроса, но больше она её не использует. Обратите внимание, предполагается, что все данные представлены в текстовом формате.</p></dd></dl></div></div><div class="sect2" id="LIBPQ-EXEC-NONSELECT"><div class="titlepage"><div><div><h3 class="title">34.3.3. Получение другой информации о результате <a href="#LIBPQ-EXEC-NONSELECT" class="id_link">#</a></h3></div></div></div><p>Эти функции используются для получения остальной информации из объектов <code class="structname">PGresult</code>.</p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQCMDSTATUS"><span class="term"><code class="function">PQcmdStatus</code><a id="id-1.7.3.10.5.3.1.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQCMDSTATUS" class="id_link">#</a></dt><dd><p>Возвращает дескриптор статуса для SQL-команды, которая сгенерировала <code class="structname">PGresult</code>. </p><pre class="synopsis">
char *PQcmdStatus(PGresult *res);
</pre><p>Как правило, это просто имя команды, но могут быть включены и дополнительные сведения, такие, как число обработанных строк. Вызывающая функция не должна напрямую освобождать память, на которую указывает возвращаемый указатель. Она будет освобождена, когда соответствующий указатель на <code class="structname">PGresult</code> будет передан функции <a class="xref" href="libpq-exec.html#LIBPQ-PQCLEAR"><code class="function">PQclear</code></a>.</p></dd><dt id="LIBPQ-PQCMDTUPLES"><span class="term"><code class="function">PQcmdTuples</code><a id="id-1.7.3.10.5.3.2.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQCMDTUPLES" class="id_link">#</a></dt><dd><p>Возвращает число строк, которые затронула SQL-команда. </p><pre class="synopsis">
char *PQcmdTuples(PGresult *res);
</pre><p>Эта функция возвращает строковое значение, содержащее число строк, которые затронул <acronym class="acronym">SQL</acronym>-оператор, сгенерировавший данный <code class="structname">PGresult</code>. Эту функцию можно использовать только сразу после выполнения команд <code class="command">SELECT</code>, <code class="command">CREATE TABLE AS</code>, <code class="command">INSERT</code>, <code class="command">UPDATE</code>, <code class="command">DELETE</code>, <code class="command">MERGE</code>, <code class="command">MOVE</code>, <code class="command">FETCH</code> или <code class="command">COPY</code>, а также после оператора <code class="command">EXECUTE</code>, выполнившего подготовленный запрос, содержащий команды <code class="command">INSERT</code>, <code class="command">UPDATE</code>, <code class="command">DELETE</code> или <code class="command">MERGE</code>. Если команда, которая сгенерировала <code class="structname">PGresult</code>, была какой-то иной, то <a class="xref" href="libpq-exec.html#LIBPQ-PQCMDTUPLES"><code class="function">PQcmdTuples</code></a> возвращает пустую строку. Вызывающая функция не должна напрямую освобождать память, на которую указывает возвращаемый указатель. Она будет освобождена, когда соответствующий указатель на <code class="structname">PGresult</code> будет передан функции <a class="xref" href="libpq-exec.html#LIBPQ-PQCLEAR"><code class="function">PQclear</code></a>.</p></dd><dt id="LIBPQ-PQOIDVALUE"><span class="term"><code class="function">PQoidValue</code><a id="id-1.7.3.10.5.3.3.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQOIDVALUE" class="id_link">#</a></dt><dd><p>Возвращает OID<a id="id-1.7.3.10.5.3.3.2.1.1" class="indexterm"></a> вставленной строки, если <acronym class="acronym">SQL</acronym>-команда была командой <code class="command">INSERT</code>, которая вставила ровно одну строку в таблицу, имеющую идентификаторы OID, или командой <code class="command">EXECUTE</code>, которая выполнила подготовленный запрос, содержащий соответствующий оператор <code class="command">INSERT</code>. В противном случае эта функция возвращает <code class="literal">InvalidOid</code>. Эта функция также возвратит <code class="literal">InvalidOid</code>, если таблица, затронутая командой <code class="command">INSERT</code>, не содержит идентификаторов OID. </p><pre class="synopsis">
Oid PQoidValue(const PGresult *res);
</pre></dd><dt id="LIBPQ-PQOIDSTATUS"><span class="term"><code class="function">PQoidStatus</code><a id="id-1.7.3.10.5.3.4.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQOIDSTATUS" class="id_link">#</a></dt><dd><p>Эта функция считается не рекомендуемой к использованию (в качестве замены служит <a class="xref" href="libpq-exec.html#LIBPQ-PQOIDVALUE"><code class="function">PQoidValue</code></a>), а также она не является потокобезопасной. Она возвращает строковое значение, содержащее OID вставленной строки, в то время как <a class="xref" href="libpq-exec.html#LIBPQ-PQOIDVALUE"><code class="function">PQoidValue</code></a> возвращает значение OID. </p><pre class="synopsis">
char *PQoidStatus(const PGresult *res);
</pre></dd></dl></div></div><div class="sect2" id="LIBPQ-EXEC-ESCAPE-STRING"><div class="titlepage"><div><div><h3 class="title">34.3.4. Экранирование строковых значений для включения в SQL-команды <a href="#LIBPQ-EXEC-ESCAPE-STRING" class="id_link">#</a></h3></div></div></div><a id="id-1.7.3.10.6.2" class="indexterm"></a><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQESCAPELITERAL"><span class="term"><code class="function">PQescapeLiteral</code><a id="id-1.7.3.10.6.3.1.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQESCAPELITERAL" class="id_link">#</a></dt><dd><p>
</p><pre class="synopsis">char *PQescapeLiteral(PGconn *conn, const char *str, size_t length);</pre><p>
     </p><p><a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPELITERAL"><code class="function">PQescapeLiteral</code></a> экранирует строковое значение для использования внутри SQL-команды. Это полезно при вставке в SQL-команды значений данных в виде строковых констант. Определённые символы (например, кавычки и обратная косая черта) должны экранироваться, чтобы предотвратить их специальную интерпретацию синтаксическим анализатором языка SQL. Эту операцию выполняет <a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPELITERAL"><code class="function">PQescapeLiteral</code></a>.</p><p><a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPELITERAL"><code class="function">PQescapeLiteral</code></a> возвращает экранированную версию параметра <em class="parameter"><code>str</code></em>, размещённую в области памяти, распределённой с помощью функции <code class="function">malloc()</code>. Эту память нужно освобождать с помощью функции <code class="function">PQfreemem()</code>, когда возвращённое значение больше не требуется. Завершающий нулевой байт не нужен и не должен учитываться в параметре <em class="parameter"><code>length</code></em>. (Если завершающий нулевой байт был найден до того, как были обработаны <em class="parameter"><code>length</code></em> байт, то <a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPELITERAL"><code class="function">PQescapeLiteral</code></a> останавливает работу на нулевом байте; таким образом, поведение функции напоминает <code class="function">strncpy</code>.) В возвращённой строке все специальные символы заменены таким образом, что синтаксический анализатор строковых литералов <span class="productname">PostgreSQL</span> может обработать их должным образом. В строку также добавляется завершающий нулевой байт. Одинарные кавычки, которые должны окружать строковые литералы <span class="productname">PostgreSQL</span>, включаются в результирующую строку.</p><p>В случае ошибки <a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPELITERAL"><code class="function">PQescapeLiteral</code></a> возвращает <code class="symbol">NULL</code>, и в объект <em class="parameter"><code>conn</code></em> помещается соответствующее сообщение.</p><div class="tip"><h3 class="title">Подсказка</h3><p>Особенно важно выполнять надлежащее экранирование при обработке строк, полученных из ненадёжных источников. В противном случае ваша безопасность подвергается риску из-за уязвимости в отношении атак с использованием <span class="quote">«<span class="quote">SQL-инъекций</span>»</span>, с помощью которых нежелательные SQL-команды направляются в вашу базу данных.</p></div><p>Обратите внимание, что нет необходимости (и это будет даже некорректно) экранировать значения данных, передаваемых в виде отдельных параметров в функцию <a class="xref" href="libpq-exec.html#LIBPQ-PQEXECPARAMS"><code class="function">PQexecParams</code></a> или родственные ей функции.</p></dd><dt id="LIBPQ-PQESCAPEIDENTIFIER"><span class="term"><code class="function">PQescapeIdentifier</code><a id="id-1.7.3.10.6.3.2.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQESCAPEIDENTIFIER" class="id_link">#</a></dt><dd><p>
</p><pre class="synopsis">char *PQescapeIdentifier(PGconn *conn, const char *str, size_t length);</pre><p>
     </p><p><a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPEIDENTIFIER"><code class="function">PQescapeIdentifier</code></a> экранирует строку, предназначенную для использования в качестве идентификатора SQL, например имени таблицы, столбца или функции. Это полезно, когда идентификатор, выбранный пользователем, может содержать специальные символы, которые в противном случае не интерпретировались бы синтаксическим анализатором SQL, как часть идентификатора, или когда идентификатор может содержать символы верхнего регистра и этот регистр требуется сохранить.</p><p><a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPEIDENTIFIER"><code class="function">PQescapeIdentifier</code></a> возвращает версию параметра <em class="parameter"><code>str</code></em>, экранированную как SQL-идентификатор, и размещённую в области памяти, распределённой с помощью функции <code class="function">malloc()</code>. Эту память нужно освобождать с помощью функции <code class="function">PQfreemem()</code>, когда возвращённое значение больше не требуется. Завершающий нулевой байт не нужен и не должен учитываться в параметре <em class="parameter"><code>length</code></em>. (Если завершающий нулевой байт был найден до того, как были обработаны <em class="parameter"><code>length</code></em> байт, то <a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPEIDENTIFIER"><code class="function">PQescapeIdentifier</code></a> останавливается на нулевом байте; таким образом, поведение функции напоминает <code class="function">strncpy</code>.) В возвращённой строке все специальные символы заменены таким образом, что она будет надлежащим образом обработана, как SQL-идентификатор. Завершающий нулевой байт также будет добавлен. Возвращённая строка также будет заключена в двойные кавычки.</p><p>В случае ошибки <a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPEIDENTIFIER"><code class="function">PQescapeIdentifier</code></a> возвращает <code class="symbol">NULL</code>, и в объект <em class="parameter"><code>conn</code></em> помещается соответствующее сообщение.</p><div class="tip"><h3 class="title">Подсказка</h3><p>Как и в случае со строковыми литералами, для того чтобы предотвратить атаки с помощью SQL-инъекций, SQL-идентификаторы должны экранироваться, когда они получены из ненадёжного источника.</p></div></dd><dt id="LIBPQ-PQESCAPESTRINGCONN"><span class="term"><code class="function">PQescapeStringConn</code><a id="id-1.7.3.10.6.3.3.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQESCAPESTRINGCONN" class="id_link">#</a></dt><dd><p>
</p><pre class="synopsis">size_t PQescapeStringConn(PGconn *conn,
                          char *to, const char *from, size_t length,
                          int *error);</pre><p>
     </p><p><a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPESTRINGCONN"><code class="function">PQescapeStringConn</code></a> экранирует строковые литералы наподобие <a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPELITERAL"><code class="function">PQescapeLiteral</code></a>. Но, в отличие от <a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPELITERAL"><code class="function">PQescapeLiteral</code></a>, за предоставление буфера надлежащего размера отвечает вызывающая функция. Более того, <a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPESTRINGCONN"><code class="function">PQescapeStringConn</code></a> не добавляет одинарные кавычки, которые должны окружать строковые литералы <span class="productname">PostgreSQL</span>; они должны быть включены в SQL-команду, в которую вставляется результирующая строка. Параметр <em class="parameter"><code>from</code></em> указывает на первый символ строки, которая должна экранироваться, а параметр <em class="parameter"><code>length</code></em> задаёт число байт в этой строке. Завершающий нулевой байт не требуется и не должен учитываться в параметре <em class="parameter"><code>length</code></em>. (Если завершающий нулевой байт был найден до того, как были обработаны <em class="parameter"><code>length</code></em> байт, то <a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPESTRINGCONN"><code class="function">PQescapeStringConn</code></a> останавливается на нулевом байте; таким образом, поведение функции напоминает <code class="function">strncpy</code>.) Параметр <em class="parameter"><code>to</code></em> должен указывать на буфер, который сможет вместить как минимум на один байт больше, чем предписывает удвоенное значение параметра <em class="parameter"><code>length</code></em>, в противном случае поведение функции не определено. Поведение будет также не определено, если строки <em class="parameter"><code>to</code></em> и <em class="parameter"><code>from</code></em> перекрываются.</p><p>Если параметр <em class="parameter"><code>error</code></em> не равен <code class="symbol">NULL</code>, тогда значение <code class="literal">*error</code> устанавливается равным нулю в случае успешной работы и не равным нулю в случае ошибки. В настоящее время единственным возможным условием возникновения ошибки является неверная мультибайтовая кодировка в исходной строке. Выходная строка формируется даже при наличии ошибки, но можно ожидать, что сервер отвергнет её как неверно сформированную. В случае ошибки в объект <em class="parameter"><code>conn</code></em> записывается соответствующее сообщение независимо от того, равно ли <code class="symbol">NULL</code> значение параметра <em class="parameter"><code>error</code></em>.</p><p><a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPESTRINGCONN"><code class="function">PQescapeStringConn</code></a> возвращает число байт, записанных по адресу <em class="parameter"><code>to</code></em>, не включая завершающий нулевой байт.</p></dd><dt id="LIBPQ-PQESCAPESTRING"><span class="term"><code class="function">PQescapeString</code><a id="id-1.7.3.10.6.3.4.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQESCAPESTRING" class="id_link">#</a></dt><dd><p><a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPESTRING"><code class="function">PQescapeString</code></a> является более старой, не рекомендованной к использованию версией функции <a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPESTRINGCONN"><code class="function">PQescapeStringConn</code></a>. </p><pre class="synopsis">
size_t PQescapeString (char *to, const char *from, size_t length);
</pre><p>Единственное отличие от <a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPESTRINGCONN"><code class="function">PQescapeStringConn</code></a> состоит в том, что у функции <a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPESTRING"><code class="function">PQescapeString</code></a> нет параметров <code class="structname">PGconn</code> и <em class="parameter"><code>error</code></em>. Поэтому она не может скорректировать своё поведение в зависимости от свойств подключения (таких, как кодировка символов) и, следовательно, <span class="emphasis"><em>она может выдавать неверные результаты</em></span>. Также она не имеет возможности сообщить об ошибках.</p><p><a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPESTRING"><code class="function">PQescapeString</code></a> может безопасно использоваться в клиентских программах, которые работают лишь с одним подключением к <span class="productname">PostgreSQL</span> за один раз (в этом случае функция может найти то, что ей нужно знать, <span class="quote">«<span class="quote">за кулисами</span>»</span>). В других контекстах её использование несёт угрозу безопасности и его следует избегать в пользу применения функции <a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPESTRINGCONN"><code class="function">PQescapeStringConn</code></a>.</p></dd><dt id="LIBPQ-PQESCAPEBYTEACONN"><span class="term"><code class="function">PQescapeByteaConn</code><a id="id-1.7.3.10.6.3.5.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQESCAPEBYTEACONN" class="id_link">#</a></dt><dd><p>Экранирует двоичные данные для их использования внутри SQL-команды с типом данных <code class="type">bytea</code>. Как и в случае с  <a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPESTRINGCONN"><code class="function">PQescapeStringConn</code></a>, эта функция применяется только тогда, когда данные вставляются непосредственно в строку SQL-команды. </p><pre class="synopsis">
unsigned char *PQescapeByteaConn(PGconn *conn,
                                 const unsigned char *from,
                                 size_t from_length,
                                 size_t *to_length);
</pre><p>Байты, имеющие определённые значения, должны экранироваться, когда они используются внутри литерала, имеющего тип <code class="type">bytea</code>, в <acronym class="acronym">SQL</acronym>-операторе. <a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPEBYTEACONN"><code class="function">PQescapeByteaConn</code></a> экранирует байты, используя либо hex-кодирование, либо экранирование с помощью обратной косой черты. См. <a class="xref" href="datatype-binary.html" title="8.4. Двоичные типы данных">Раздел 8.4</a> для получения дополнительной информации.</p><p>Параметр <em class="parameter"><code>from</code></em> указывает на первый байт строки, которая должна экранироваться, а параметр <em class="parameter"><code>from_length</code></em> задаёт число байт в этой двоичной строке. (Завершающий нулевой байт не нужен и не учитывается.) Параметр <em class="parameter"><code>to_length</code></em> указывает на переменную, которая будет содержать длину результирующей экранированной строки. Эта длина включает завершающий нулевой байт результирующей строки.</p><p><a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPEBYTEACONN"><code class="function">PQescapeByteaConn</code></a> возвращает экранированную версию двоичной строки, на которую указывает параметр <em class="parameter"><code>from</code></em>, и размещает её в памяти, распределённой с помощью <code class="function">malloc()</code>. Эта память должна быть освобождена с помощью функции <code class="function">PQfreemem()</code>, когда результирующая строка больше не нужна. В возвращаемой строке все специальные символы заменены так, чтобы синтаксический анализатор литеральных строк <span class="productname">PostgreSQL</span> и функция ввода для типа <code class="type">bytea</code> могли обработать их надлежащим образом. Завершающий нулевой байт также добавляется. Одинарные кавычки, которые должны окружать строковые литералы <span class="productname">PostgreSQL</span>, не являются частью результирующей строки.</p><p>В случае ошибки возвращается нулевой указатель, и соответствующее сообщение об ошибке записывается в объект <em class="parameter"><code>conn</code></em>. В настоящее время единственной возможной ошибкой может быть нехватка памяти для результирующей строки.</p></dd><dt id="LIBPQ-PQESCAPEBYTEA"><span class="term"><code class="function">PQescapeBytea</code><a id="id-1.7.3.10.6.3.6.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQESCAPEBYTEA" class="id_link">#</a></dt><dd><p><a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPEBYTEA"><code class="function">PQescapeBytea</code></a> является устаревшей и не рекомендуемой к использованию версией функции <a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPEBYTEACONN"><code class="function">PQescapeByteaConn</code></a>. </p><pre class="synopsis">
unsigned char *PQescapeBytea(const unsigned char *from,
                             size_t from_length,
                             size_t *to_length);
</pre><p>Единственное отличие от <a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPEBYTEACONN"><code class="function">PQescapeByteaConn</code></a> состоит в том, что у функции <a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPEBYTEA"><code class="function">PQescapeBytea</code></a> нет параметра <code class="structname">PGconn</code>. Поэтому <a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPEBYTEA"><code class="function">PQescapeBytea</code></a> может безопасно использоваться в клиентских программах, которые работают лишь с одним подключением к <span class="productname">PostgreSQL</span> в один момент времени (в этом случае функция может узнать то, что ей нужно, <span class="quote">«<span class="quote">за кулисами</span>»</span>). Она <span class="emphasis"><em>может выдавать неверные результаты</em></span> при использовании в программах, которые устанавливает несколько подключений к базам данных (в таких случаях используйте <a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPEBYTEACONN"><code class="function">PQescapeByteaConn</code></a>).</p></dd><dt id="LIBPQ-PQUNESCAPEBYTEA"><span class="term"><code class="function">PQunescapeBytea</code><a id="id-1.7.3.10.6.3.7.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQUNESCAPEBYTEA" class="id_link">#</a></dt><dd><p>Преобразует строковое представление двоичных данных в двоичные данные — является обратной функцией к функции <a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPEBYTEA"><code class="function">PQescapeBytea</code></a>. Она нужна, когда данные типа <code class="type">bytea</code> извлекаются в текстовом формате, но не когда они извлекаются в двоичном формате. </p><pre class="synopsis">
unsigned char *PQunescapeBytea(const unsigned char *from, size_t *to_length);
</pre><p>Параметр <em class="parameter"><code>from</code></em> указывает на строку, такую, какую могла бы возвратить функция <a class="xref" href="libpq-exec.html#LIBPQ-PQGETVALUE"><code class="function">PQgetvalue</code></a>, применённая к столбцу типа <code class="type">bytea</code>. <a class="xref" href="libpq-exec.html#LIBPQ-PQUNESCAPEBYTEA"><code class="function">PQunescapeBytea</code></a> преобразует это строковое представление в его двоичное представление. Она возвращает указатель на буфер, выделенный функцией <code class="function">malloc()</code>, или <code class="symbol">NULL</code> в случае ошибки и помещает размер буфера по адресу <em class="parameter"><code>to_length</code></em>. Когда результат не будет нужен, необходимо освободить его память, вызвав <a class="xref" href="libpq-misc.html#LIBPQ-PQFREEMEM"><code class="function">PQfreemem</code></a>.</p><p>Это преобразование не является точной инверсией для <a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPEBYTEA"><code class="function">PQescapeBytea</code></a>, поскольку ожидается, что строка, полученная от <a class="xref" href="libpq-exec.html#LIBPQ-PQGETVALUE"><code class="function">PQgetvalue</code></a>, не будет <span class="quote">«<span class="quote">экранированной</span>»</span>. В частности, это означает, что учитывать режим спецпоследовательностей не нужно, и поэтому в параметре <code class="structname">PGconn</code> нет необходимости.</p></dd></dl></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="libpq-status.html" title="34.2. Функции, описывающие текущее состояние подключения">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="libpq.html" title="Глава 34. libpq — библиотека для языка C">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="libpq-async.html" title="34.4. Асинхронная обработка команд">След.</a></td></tr><tr><td width="40%" align="left" valign="top">34.2. Функции, описывающие текущее состояние подключения </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 34.4. Асинхронная обработка команд</td></tr></table></div></body></html>