<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>43.11. PL/pgSQL изнутри</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="plpgsql-trigger.html" title="43.10. Триггерные функции" /><link rel="next" href="plpgsql-development-tips.html" title="43.12. Советы по разработке на PL/pgSQL" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">43.11. <span class="application">PL/pgSQL</span> изнутри</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="plpgsql-trigger.html" title="43.10. Триггерные функции">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="plpgsql.html" title="Глава 43. PL/pgSQL — процедурный язык SQL">Наверх</a></td><th width="60%" align="center">Глава 43. <span class="application">PL/pgSQL</span> — процедурный язык <acronym class="acronym">SQL</acronym></th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="plpgsql-development-tips.html" title="43.12. Советы по разработке на PL/pgSQL">След.</a></td></tr></table><hr /></div><div class="sect1" id="PLPGSQL-IMPLEMENTATION"><div class="titlepage"><div><div><h2 class="title" style="clear: both">43.11. <span class="application">PL/pgSQL</span> изнутри <a href="#PLPGSQL-IMPLEMENTATION" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="plpgsql-implementation.html#PLPGSQL-VAR-SUBST">43.11.1. Подстановка переменных</a></span></dt><dt><span class="sect2"><a href="plpgsql-implementation.html#PLPGSQL-PLAN-CACHING">43.11.2. Кеширование плана</a></span></dt></dl></div><p>В этом разделе обсуждаются некоторые детали реализации, которые пользователям <span class="application">PL/pgSQL</span> важно знать.</p><div class="sect2" id="PLPGSQL-VAR-SUBST"><div class="titlepage"><div><div><h3 class="title">43.11.1. Подстановка переменных <a href="#PLPGSQL-VAR-SUBST" class="id_link">#</a></h3></div></div></div><p>SQL-операторы и выражения внутри функции на <span class="application">PL/pgSQL</span> могут ссылаться на переменные и параметры этой функции. За кулисами <span class="application">PL/pgSQL</span> заменяет параметры запросов для таких ссылок. Параметры будут заменены только в местах, где они синтаксически допустимы. Как крайний случай, рассмотрим следующий пример плохого стиля программирования: </p><pre class="programlisting">INSERT INTO foo (foo) VALUES (foo(foo));</pre><p> Первый раз <code class="literal">foo</code> появляется на том месте, где синтаксически должно быть имя таблицы, поэтому замены не будет, даже если функция имеет переменную <code class="literal">foo</code>. Второй раз <code class="literal">foo</code> встречается там, где должно быть имя столбца таблицы, поэтому замены не будет и здесь. Третий раз — на месте, где должно быть имя функции, поэтому замены не будет. Только последнее вхождение <code class="literal">foo</code> является кандидатом на то, чтобы быть ссылкой на переменную функции <span class="application">PL/pgSQL</span>.</p><p>Объяснить принцип действия можно ещё и так: при подстановке переменных в SQL-команду могут вставляться только значения данных; при этом нельзя динамически менять объекты базы данных, на которые ссылается команда. (Для этого нужно сконструировать строку команды динамически, как описано в <a class="xref" href="plpgsql-statements.html#PLPGSQL-STATEMENTS-EXECUTING-DYN" title="43.5.4. Выполнение динамически формируемых команд">Подразделе 43.5.4</a>.)</p><p>Если имена переменных синтаксически не отличаются от названий столбцов таблицы, то возможна двусмысленность и в ссылках на таблицы. Является ли данное имя ссылкой на столбец таблицы или ссылкой на переменную? Изменим предыдущий пример: </p><pre class="programlisting">INSERT INTO dest (col) SELECT foo + bar FROM src;</pre><p> Здесь <code class="literal">dest</code> и <code class="literal">src</code> должны быть именами таблиц, <code class="literal">col</code> должен быть столбцом <code class="literal">dest</code>. Однако <code class="literal">foo</code> и <code class="literal">bar</code> могут быть как переменными функции, так и столбцами <code class="literal">src</code>.</p><p>По умолчанию, <span class="application">PL/pgSQL</span> выдаст ошибку, если имя в операторе SQL может относиться как к переменной, так и к столбцу таблицы. Ситуацию можно исправить переименованием переменной, переименованием столбца, точной квалификацией неоднозначной ссылки или указанием <span class="application">PL/pgSQL</span> машине, какую интерпретацию предпочесть.</p><p>Самое простое решение — переименовать переменную или столбец. Общее правило кодирования предполагает использование различных соглашений о наименовании для переменных <span class="application">PL/pgSQL</span> и столбцов таблиц. Например, если имена переменных всегда имеют вид <code class="literal">v_<em class="replaceable"><code>имя</code></em></code>, а имена столбцов никогда не начинаются на <code class="literal">v_</code>, то конфликты исключены.</p><p>В качестве альтернативы можно дополнить имена неоднозначных ссылок, чтобы сделать их точными. В приведённом выше примере <code class="literal">src.foo</code> однозначно бы определялась, как ссылка на столбец таблицы. Чтобы сделать однозначной ссылку на переменную, переменная должна быть объявлена в блоке с меткой, и далее нужно использовать эту метку (см. <a class="xref" href="plpgsql-structure.html" title="43.2. Структура PL/pgSQL">Раздел 43.2</a>). Например: </p><pre class="programlisting">&lt;&lt;block&gt;&gt;
DECLARE
    foo int;
BEGIN
    foo := ...;
    INSERT INTO dest (col) SELECT block.foo + bar FROM src;</pre><p> Здесь <code class="literal">block.foo</code> ссылается на переменную, даже если в таблице <code class="literal">src</code> есть столбец <code class="literal">foo</code>. Параметры функции, а также специальные переменные, такие как <code class="literal">FOUND</code>, могут быть дополнены именем функции, потому что они неявно объявлены во внешнем блоке, метка которого совпадает с именем функции.</p><p>Иногда может быть не очень практичным исправлять таким способом все неоднозначные ссылки в большом куске <span class="application">PL/pgSQL</span> кода. В таких случаях можно указать, чтобы <span class="application">PL/pgSQL</span> разрешал неоднозначные ссылки в пользу переменных (это совместимо с <span class="application">PL/pgSQL</span> до версии <span class="productname">PostgreSQL</span> 9.0), или в пользу столбцов таблицы (совместимо с некоторыми другими системами, такими как <span class="productname">Oracle</span>).</p><a id="id-1.8.8.13.3.9" class="indexterm"></a><p>На уровне всей системы поведение <span class="application">PL/pgSQL</span> регулируется установкой конфигурационного параметра <code class="literal">plpgsql.variable_conflict</code>, имеющего значения: <code class="literal">error</code>, <code class="literal">use_variable</code> или <code class="literal">use_column</code> (<code class="literal">error</code> устанавливается по умолчанию при установке системы). Изменение этого параметра влияет на все последующие компиляции операторов в функциях на <span class="application">PL/pgSQL</span>, но не на операторы уже скомпилированные в текущем сеансе. Так как изменение этого параметра может привести к неожиданным изменениям в поведении функций на <span class="application">PL/pgSQL</span>, он может быть изменён только суперпользователем.</p><p>Поведение <span class="application">PL/pgSQL</span> можно изменять для каждой отдельной функции, если добавить в начало функции одну из этих специальных команд: </p><pre class="programlisting">#variable_conflict error
#variable_conflict use_variable
#variable_conflict use_column</pre><p> Эти команды влияют только на функцию, в которой они записаны и перекрывают действие <code class="literal">plpgsql.variable_conflict</code>. Пример: </p><pre class="programlisting">CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    #variable_conflict use_variable
    DECLARE
        curtime timestamp := now();
    BEGIN
        UPDATE users SET last_modified = curtime, comment = comment
          WHERE users.id = id;
    END;
$$ LANGUAGE plpgsql;</pre><p> В команде <code class="literal">UPDATE</code>, <code class="literal">curtime</code>, <code class="literal">comment</code> и <code class="literal">id</code> будут ссылаться на переменные и параметры функции вне зависимости от того, есть ли столбцы с такими именами в таблице <code class="literal">users</code>. Обратите внимание, что нужно дополнить именем таблицы ссылку на <code class="literal">users.id</code> в предложении <code class="literal">WHERE</code>, чтобы она ссылалась на столбец таблицы. При этом необязательно дополнять ссылку на <code class="literal">comment</code> в левой части списка <code class="literal">UPDATE</code>, так как синтаксически в этом месте должно быть имя столбца таблицы <code class="literal">users</code>. Эту функцию можно было бы записать и без зависимости от значения <code class="literal">variable_conflict</code>: </p><pre class="programlisting">CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    &lt;&lt;fn&gt;&gt;
    DECLARE
        curtime timestamp := now();
    BEGIN
        UPDATE users SET last_modified = fn.curtime, comment = stamp_user.comment
          WHERE users.id = stamp_user.id;
    END;
$$ LANGUAGE plpgsql;</pre><p>Замена переменных не происходит в строке, исполняемой командой <code class="command">EXECUTE</code> или её вариантом. Если нужно вставлять изменяющиеся значения в такую команду, то это делается либо при построении самой командной строки или с использованием <code class="literal">USING</code>, как показано в <a class="xref" href="plpgsql-statements.html#PLPGSQL-STATEMENTS-EXECUTING-DYN" title="43.5.4. Выполнение динамически формируемых команд">Подразделе 43.5.4</a>.</p><p>Замена переменных в настоящее время работает только в командах <code class="command">SELECT</code>, <code class="command">INSERT</code>, <code class="command">UPDATE</code>, <code class="command">DELETE</code> и командах, содержащих одну из вышеперечисленных (например, <code class="command">EXPLAIN</code> и <code class="command">CREATE TABLE ... AS SELECT</code>), потому что основной исполнитель SQL допускает использование параметров запроса только в этих командах. Чтобы использовать изменяемые имена или значения в других типах операторов (обычно называемые служебными), необходимо составить текст команды в виде строки и выполнить её в <code class="command">EXECUTE</code>.</p></div><div class="sect2" id="PLPGSQL-PLAN-CACHING"><div class="titlepage"><div><div><h3 class="title">43.11.2. Кеширование плана <a href="#PLPGSQL-PLAN-CACHING" class="id_link">#</a></h3></div></div></div><p>Интерпретатор <span class="application">PL/pgSQL</span> анализирует исходный текст функции и строит внутреннее бинарное дерево инструкций при первом вызове функции (для каждого сеанса). В дерево инструкций полностью переводится вся структура операторов <span class="application">PL/pgSQL</span>, но для выражений и команд <acronym class="acronym">SQL</acronym>, используемых в функции, это происходит не сразу.</p><p><a id="id-1.8.8.13.4.3.1" class="indexterm"></a> При первом выполнении в функции каждого выражения или команды <acronym class="acronym">SQL</acronym> интерпретатор <span class="application">PL/pgSQL</span> разбирает и анализирует команду для создания подготовленного к выполнению оператора с помощью функции <code class="function">SPI_prepare</code> менеджера интерфейса программирования сервера. Последующие обращения к этому выражению или команде повторно используют подготовленный к выполнению оператор. Таким образом, <acronym class="acronym">SQL</acronym>-команды, находящиеся в редко посещаемой ветке кода условного оператора, не несут накладных расходов на разбор команд, если они так и не будут выполнены в текущем сеансе. Здесь есть недостаток, заключающийся в том, что ошибки в определённом выражении или команде не могут быть обнаружены, пока выполнение не дойдёт до этой части функции. (Тривиальные синтаксические ошибки обнаружатся в ходе первоначального разбора, но ничего более серьёзного не будет обнаружено до исполнения.)</p><p>Кроме того, <span class="application">PL/pgSQL</span> (точнее, менеджер интерфейса программирования сервера) будет пытаться кешировать план выполнения для любого подготовленного к исполнению оператора. При каждом вызове оператора, если не используется план из кеша, генерируется новый план выполнения, и текущие значения параметров (то есть значения переменных <span class="application">PL/pgSQL</span>) могут быть использованы для оптимизации нового плана. Если оператор не имеет параметров или выполняется много раз, менеджер интерфейса программирования сервера рассмотрит вопрос о создании и кешировании (для повторного использования) общего плана, не зависящего от значений параметров. Как правило, это происходит в тех случаях, когда план выполнения не очень чувствителен к имеющимся ссылкам на значения переменных <span class="application">PL/pgSQL</span>. В противном случае выгоднее каждый раз формировать новый план. Более подробно поведение подготовленных операторов рассматривается в <a class="xref" href="sql-prepare.html" title="PREPARE"><span class="refentrytitle">PREPARE</span></a>.</p><p>Чтобы <span class="application">PL/pgSQL</span> мог сохранять подготовленные операторы и планы выполнения, команды SQL в коде <span class="application">PL/pgSQL</span>, должны использовать одни и те же таблицы и столбцы при каждом исполнении. А это значит, что в SQL-командах нельзя использовать названия таблиц и столбцов в качестве параметров. Чтобы обойти это ограничение, нужно сконструировать динамическую команду для оператора <span class="application">PL/pgSQL</span> <code class="command">EXECUTE</code> — ценой будет разбор и построение нового плана выполнения при каждом вызове.</p><p>Изменчивая природа переменных типа <code class="type">record</code> представляет ещё одну проблему в этой связи. Когда поля переменной типа <code class="type">record</code> используются в выражениях или операторах, типы данных полей не должны меняться от одного вызова функции к другому, так как при анализе каждого выражения будет использоваться тот тип данных, который присутствовал при первом вызове. При необходимости можно использовать <code class="command">EXECUTE</code> для решения этой проблемы.</p><p>Если функция используется в качестве триггера более чем для одной таблицы, <span class="application">PL/pgSQL</span> независимо подготавливает и кеширует операторы для каждой такой таблицы. То есть создаётся кеш для каждой комбинации триггерная функция + таблица, а не только для каждой функции. Это устраняет некоторые проблемы, связанные с различными типами данных. Например, триггерная функция сможет успешно работать со столбцом <code class="literal">key</code>, даже если в разных таблицах этот столбец имеет разные типы данных.</p><p>Таким же образом, функции с полиморфными типами аргументов имеют отдельный кеш для каждой комбинации фактических типов аргументов, так что различия типов данных не вызывают неожиданных сбоев.</p><p>Кеширование операторов иногда приводит к неожиданным эффектам при интерпретации чувствительных ко времени значений. Например, есть разница между тем, что делают эти две функции: </p><pre class="programlisting">CREATE FUNCTION logfunc1(logtxt text) RETURNS void AS $$
    BEGIN
        INSERT INTO logtable VALUES (logtxt, 'now');
    END;
$$ LANGUAGE plpgsql;</pre><p> и </p><pre class="programlisting">CREATE FUNCTION logfunc2(logtxt text) RETURNS void AS $$
    DECLARE
        curtime timestamp;
    BEGIN
        curtime := 'now';
        INSERT INTO logtable VALUES (logtxt, curtime);
    END;
$$ LANGUAGE plpgsql;</pre><p>В случае <code class="function">logfunc1</code>, при анализе <code class="command">INSERT</code>, основной анализатор <span class="productname">PostgreSQL</span> знает, что строку <code class="literal">'now'</code> следует толковать как <code class="type">timestamp</code>, потому что целевой столбец таблицы <code class="classname">logtable</code> имеет такой тип данных. Таким образом, <code class="literal">'now'</code> будет преобразовано в константу <code class="type">timestamp</code> при анализе <code class="command">INSERT</code>, а затем эта константа будет использоваться в последующих вызовах <code class="function">logfunc1</code> в течение всего сеанса. Разумеется, это не то, что хотел программист. Лучше было бы использовать функцию <code class="literal">now()</code> или <code class="literal">current_timestamp</code>.</p><p>В случае <code class="function">logfunc2</code>, основной анализатор <span class="productname">PostgreSQL</span> не знает, какого типа будет <code class="literal">'now'</code> и поэтому возвращает значение типа <code class="type">text</code>, содержащее строку <code class="literal">now</code>. При последующем присваивании локальной переменной <code class="varname">curtime</code> интерпретатор <span class="application">PL/pgSQL</span> приводит эту строку к типу <code class="type">timestamp</code>, вызывая функции <code class="function">textout</code> и <code class="function">timestamp_in</code>. Таким образом, метка времени будет обновляться при каждом выполнении, как и ожидается программистом. И хотя всё работает как ожидалось, это ужасно неэффективно, поэтому использование функции <code class="literal">now()</code> по-прежнему значительно лучше.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="plpgsql-trigger.html" title="43.10. Триггерные функции">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="plpgsql.html" title="Глава 43. PL/pgSQL — процедурный язык SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="plpgsql-development-tips.html" title="43.12. Советы по разработке на PL/pgSQL">След.</a></td></tr><tr><td width="40%" align="left" valign="top">43.10. Триггерные функции </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 43.12. Советы по разработке на <span class="application">PL/pgSQL</span></td></tr></table></div></body></html>