<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>14.4. Наполнение базы данных</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="explicit-joins.html" title="14.3. Управление планировщиком с помощью явных предложений JOIN" /><link rel="next" href="non-durability.html" title="14.5. Оптимизация, угрожающая стабильности" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">14.4. Наполнение базы данных</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="explicit-joins.html" title="14.3. Управление планировщиком с помощью явных предложений JOIN">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="performance-tips.html" title="Глава 14. Оптимизация производительности">Наверх</a></td><th width="60%" align="center">Глава 14. Оптимизация производительности</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="non-durability.html" title="14.5. Оптимизация, угрожающая стабильности">След.</a></td></tr></table><hr /></div><div class="sect1" id="POPULATE"><div class="titlepage"><div><div><h2 class="title" style="clear: both">14.4. Наполнение базы данных <a href="#POPULATE" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="populate.html#DISABLE-AUTOCOMMIT">14.4.1. Отключите автофиксацию транзакций</a></span></dt><dt><span class="sect2"><a href="populate.html#POPULATE-COPY-FROM">14.4.2. Используйте <code class="command">COPY</code></a></span></dt><dt><span class="sect2"><a href="populate.html#POPULATE-RM-INDEXES">14.4.3. Удалите индексы</a></span></dt><dt><span class="sect2"><a href="populate.html#POPULATE-RM-FKEYS">14.4.4. Удалите ограничения внешних ключей</a></span></dt><dt><span class="sect2"><a href="populate.html#POPULATE-WORK-MEM">14.4.5. Увеличьте <code class="varname">maintenance_work_mem</code></a></span></dt><dt><span class="sect2"><a href="populate.html#POPULATE-MAX-WAL-SIZE">14.4.6. Увеличьте <code class="varname">max_wal_size</code></a></span></dt><dt><span class="sect2"><a href="populate.html#POPULATE-PITR">14.4.7. Отключите архивацию WAL и потоковую репликацию</a></span></dt><dt><span class="sect2"><a href="populate.html#POPULATE-ANALYZE">14.4.8. Выполните в конце <code class="command">ANALYZE</code></a></span></dt><dt><span class="sect2"><a href="populate.html#POPULATE-PG-DUMP">14.4.9. Несколько замечаний относительно <span class="application">pg_dump</span></a></span></dt></dl></div><p>Довольно часто в начале или в процессе использования базы данных возникает необходимость загрузить в неё большой объём данных. В этом разделе приведены рекомендации, которые помогут сделать это максимально эффективно.</p><div class="sect2" id="DISABLE-AUTOCOMMIT"><div class="titlepage"><div><div><h3 class="title">14.4.1. Отключите автофиксацию транзакций <a href="#DISABLE-AUTOCOMMIT" class="id_link">#</a></h3></div></div></div><a id="id-1.5.13.7.3.2" class="indexterm"></a><p>Выполняя серию команд <code class="command">INSERT</code>, выключите автофиксацию транзакций и зафиксируйте транзакцию только один раз в самом конце. (В обычном SQL это означает, что нужно выполнить <code class="command">BEGIN</code> до, и <code class="command">COMMIT</code> после этой серии. Некоторые клиентские библиотеки могут делать это автоматически, в таких случаях нужно убедиться, что это так.) Если вы будете фиксировать каждое добавление по отдельности, <span class="productname">PostgreSQL</span> придётся проделать много действий для каждой добавляемой строки. Выполнять все операции в одной транзакции хорошо ещё и потому, что в случае ошибки добавления одной из строк произойдёт откат к исходному состоянию и вы не окажетесь в сложной ситуации с частично загруженными данными.</p></div><div class="sect2" id="POPULATE-COPY-FROM"><div class="titlepage"><div><div><h3 class="title">14.4.2. Используйте <code class="command">COPY</code> <a href="#POPULATE-COPY-FROM" class="id_link">#</a></h3></div></div></div><p>Используйте <a class="link" href="sql-copy.html" title="COPY"><code class="command">COPY</code></a>, чтобы загрузить все строки одной командой вместо серии <code class="command">INSERT</code>. Команда <code class="command">COPY</code> оптимизирована для загрузки большого количества строк; хотя она не так гибка, как <code class="command">INSERT</code>, но при загрузке больших объёмов данных она влечёт гораздо меньше накладных расходов. Так как <code class="command">COPY</code> — это одна команда, применяя её, нет необходимости отключать автофиксацию транзакций.</p><p>В случаях, когда <code class="command">COPY</code> не подходит, может быть полезно создать подготовленный оператор <code class="command">INSERT</code> с помощью <a class="link" href="sql-prepare.html" title="PREPARE"><code class="command">PREPARE</code></a>, а затем выполнять <code class="command">EXECUTE</code> столько раз, сколько потребуется. Это позволит избежать накладных расходов, связанных с разбором и анализом каждой команды <code class="command">INSERT</code>. В разных интерфейсах это может выглядеть по-разному; за подробностями обратитесь к описанию <span class="quote">«<span class="quote">подготовленных операторов</span>»</span> в документации конкретного интерфейса.</p><p>Заметьте, что с помощью <code class="command">COPY</code> большое количество строк практически всегда загружается быстрее, чем с помощью <code class="command">INSERT</code>, даже если используется <code class="command">PREPARE</code> и серия операций добавления заключена в одну транзакцию.</p><p><code class="command">COPY</code> работает быстрее всего, если она выполняется в одной транзакции с командами <code class="command">CREATE TABLE</code> или <code class="command">TRUNCATE</code>. В таких случаях записывать WAL не нужно, так как в случае ошибки файлы, содержащие загружаемые данные, будут всё равно удалены. Однако это замечание справедливо, только когда параметр <a class="xref" href="runtime-config-wal.html#GUC-WAL-LEVEL">wal_level</a> равен <code class="literal">minimal</code>, так как в противном случае все команды должны записывать свои изменения в WAL.</p></div><div class="sect2" id="POPULATE-RM-INDEXES"><div class="titlepage"><div><div><h3 class="title">14.4.3. Удалите индексы <a href="#POPULATE-RM-INDEXES" class="id_link">#</a></h3></div></div></div><p>Если вы загружаете данные в только что созданную таблицу, быстрее всего будет загрузить данные с помощью <code class="command">COPY</code>, а затем создать все необходимые для неё индексы. На создание индекса для уже существующих данных уйдёт меньше времени, чем на последовательное его обновление при добавлении каждой строки.</p><p>Если вы добавляете данные в существующую таблицу, может иметь смысл удалить индексы, загрузить таблицу, а затем пересоздать индексы. Конечно, при этом надо учитывать, что временное отсутствие индексов может отрицательно повлиять на скорость работы других пользователей. Кроме того, следует дважды подумать, прежде чем удалять уникальные индексы, так как без них соответствующие проверки ключей не будут выполняться.</p></div><div class="sect2" id="POPULATE-RM-FKEYS"><div class="titlepage"><div><div><h3 class="title">14.4.4. Удалите ограничения внешних ключей <a href="#POPULATE-RM-FKEYS" class="id_link">#</a></h3></div></div></div><p>Как и с индексами, проверки, связанные с ограничениями внешних ключей, выгоднее выполнять <span class="quote">«<span class="quote">массово</span>»</span>, а не для каждой строки в отдельности. Поэтому может быть полезно удалить ограничения внешних ключей, загрузить данные, а затем восстановить прежние ограничения. И в этом случае тоже приходится выбирать между скоростью загрузки данных и риском допустить ошибки в отсутствие ограничений.</p><p>Более того, когда вы загружаете данные в таблицу с существующими ограничениями внешнего ключа, для каждой новой строки добавляется запись в очередь событий триггера (так как именно срабатывающий триггер проверяет такие ограничения для строки). При загрузке многих миллионов строк очередь событий триггера может занять всю доступную память, что приведёт к недопустимой нагрузке на файл подкачки или даже к сбою команды. Таким образом, загружая большие объёмы данных, может быть не просто желательно, а <span class="emphasis"><em>необходимо</em></span> удалять, а затем восстанавливать внешние ключи. Если же временное отключение этого ограничения неприемлемо, единственно возможным решением может быть разделение всей операции загрузки на меньшие транзакции.</p></div><div class="sect2" id="POPULATE-WORK-MEM"><div class="titlepage"><div><div><h3 class="title">14.4.5. Увеличьте <code class="varname">maintenance_work_mem</code> <a href="#POPULATE-WORK-MEM" class="id_link">#</a></h3></div></div></div><p>Ускорить загрузку больших объёмов данных можно, увеличив параметр конфигурации <a class="xref" href="runtime-config-resource.html#GUC-MAINTENANCE-WORK-MEM">maintenance_work_mem</a> на время загрузки. Это приведёт к увеличению быстродействия <code class="command">CREATE INDEX</code> и <code class="command">ALTER TABLE ADD FOREIGN KEY</code>. На скорость самой команды <code class="command">COPY</code> это не повлияет, так что этот совет будет полезен, только если вы применяете какой-либо из двух вышеописанных приёмов.</p></div><div class="sect2" id="POPULATE-MAX-WAL-SIZE"><div class="titlepage"><div><div><h3 class="title">14.4.6. Увеличьте <code class="varname">max_wal_size</code> <a href="#POPULATE-MAX-WAL-SIZE" class="id_link">#</a></h3></div></div></div><p>Также массовую загрузку данных можно ускорить, изменив на время загрузки параметр конфигурации <a class="xref" href="runtime-config-wal.html#GUC-MAX-WAL-SIZE">max_wal_size</a>. Загружая большие объёмы данных, <span class="productname">PostgreSQL</span> вынужден увеличивать частоту контрольных точек по сравнению с обычной (которая задаётся параметром <code class="varname">checkpoint_timeout</code>), а значит и чаще сбрасывать «грязные» страницы на диск. Временно увеличив <code class="varname">max_wal_size</code>, можно уменьшить частоту контрольных точек и связанных с ними операций ввода-вывода.</p></div><div class="sect2" id="POPULATE-PITR"><div class="titlepage"><div><div><h3 class="title">14.4.7. Отключите архивацию WAL и потоковую репликацию <a href="#POPULATE-PITR" class="id_link">#</a></h3></div></div></div><p>Для загрузки больших объёмов данных в среде, где используется архивация WAL или потоковая репликация, быстрее будет сделать копию базы данных после загрузки данных, чем обрабатывать множество операций изменений в WAL. Чтобы отключить передачу изменений через WAL в процессе загрузки, отключите архивацию и потоковую репликацию, назначьте параметру <a class="xref" href="runtime-config-wal.html#GUC-WAL-LEVEL">wal_level</a> значение <code class="literal">minimal</code>, <a class="xref" href="runtime-config-wal.html#GUC-ARCHIVE-MODE">archive_mode</a> — <code class="literal">off</code>, а <a class="xref" href="runtime-config-replication.html#GUC-MAX-WAL-SENDERS">max_wal_senders</a> — 0. Но имейте в виду, что изменённые параметры вступят в силу только после перезапуска сервера, а все ранее созданные резервные копии не будут пригодны для резервного сервера и восстановления архива, что может привести к потере данных.</p><p>Это не только поможет сэкономить время архивации и передачи WAL, но и непосредственно ускорит некоторые команды, потому что они не записывают в WAL ничего, если в <code class="varname">wal_level</code> установлен уровень <code class="literal">minimal</code> и текущая подтранзакция (или транзакция верхнего уровня) создала и опустошила таблицу или индекс, куда затем вносятся изменения. (Они могут гарантировать безопасность данных при сбое, не записывая их в WAL, а только выполнив <code class="function">fsync</code> в конце, что будет гораздо дешевле.)</p></div><div class="sect2" id="POPULATE-ANALYZE"><div class="titlepage"><div><div><h3 class="title">14.4.8. Выполните в конце <code class="command">ANALYZE</code> <a href="#POPULATE-ANALYZE" class="id_link">#</a></h3></div></div></div><p>Всякий раз, когда распределение данных в таблице значительно меняется, настоятельно рекомендуется выполнять <a class="link" href="sql-analyze.html" title="ANALYZE"><code class="command">ANALYZE</code></a>. Эта рекомендация касается и загрузки в таблицу большого объёма данных. Выполнив <code class="command">ANALYZE</code> (или <code class="command">VACUUM ANALYZE</code>), вы тем самым обновите статистику по данной таблице для планировщика. Когда планировщик не имеет статистики или она не соответствует действительности, он не сможет правильно планировать запросы, что приведёт к снижению быстродействия при работе с соответствующими таблицами. Заметьте, что если включён демон автоочистки, он может запускать <code class="command">ANALYZE</code> автоматически; подробнее об этом можно узнать в <a class="xref" href="routine-vacuuming.html#VACUUM-FOR-STATISTICS" title="25.1.3. Обновление статистики планировщика">Подразделе 25.1.3</a> и <a class="xref" href="routine-vacuuming.html#AUTOVACUUM" title="25.1.6. Демон автоочистки">Подразделе 25.1.6</a>.</p></div><div class="sect2" id="POPULATE-PG-DUMP"><div class="titlepage"><div><div><h3 class="title">14.4.9. Несколько замечаний относительно <span class="application">pg_dump</span> <a href="#POPULATE-PG-DUMP" class="id_link">#</a></h3></div></div></div><p>В скриптах загрузки данных, которые генерирует <span class="application">pg_dump</span>, автоматически учитываются некоторые, но не все из этих рекомендаций. Чтобы загрузить данные, которые выгрузил <span class="application">pg_dump</span>, максимально быстро, вам нужно будет выполнить некоторые дополнительные действия вручную. (Заметьте, что эти замечания относятся только к <span class="emphasis"><em>восстановлению</em></span> данных, но не к <span class="emphasis"><em>выгрузке</em></span> их. Следующие рекомендации применимы вне зависимости от того, загружается ли архивный файл <span class="application">pg_dump</span> в <span class="application">psql</span> или в <span class="application">pg_restore</span>.)</p><p>По умолчанию <span class="application">pg_dump</span> использует команду <code class="command">COPY</code> и когда она выгружает полностью схему и данные, в сгенерированном скрипте она сначала предусмотрительно загружает данные, а потом создаёт индексы и внешние ключи. Так что в этом случае часть рекомендаций выполняется автоматически. Вам остаётся учесть только следующие: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Установите подходящие (то есть превышающие обычные) значения для <code class="varname">maintenance_work_mem</code> и <code class="varname">max_wal_size</code>.</p></li><li class="listitem"><p>Если вы используете архивацию WAL или потоковую репликацию, по возможности отключите их на время восстановления. Для этого перед загрузкой данных, присвойте параметру <code class="varname">archive_mode</code> значение <code class="literal">off</code>, <code class="varname">wal_level</code> — <code class="literal">minimal</code>, а <code class="varname">max_wal_senders</code> — 0. Закончив восстановление, верните их обычные значения и сделайте свежую базовую резервную копию.</p></li><li class="listitem"><p>Поэкспериментируйте с режимами параллельного копирования и восстановления команд <span class="application">pg_dump</span> и <span class="application">pg_restore</span>, и подберите оптимальное число параллельных заданий. Параллельное копирование и восстановление данных, управляемое параметром <code class="option">-j</code>, должно дать значительный выигрыш в скорости по сравнению с последовательным режимом.</p></li><li class="listitem"><p>Если это возможно в вашей ситуации, восстановите все данные в рамках одной транзакции. Для этого передайте параметр <code class="option">-1</code> или <code class="option">--single-transaction</code> команде <span class="application">psql</span> или <span class="application">pg_restore</span>. Но учтите, что в этом режиме даже незначительная ошибка приведёт к откату всех изменений и часы восстановления будут потрачены зря. В зависимости от того, насколько взаимосвязаны данные, предпочтительнее может быть вычистить их вручную. Команды <code class="command">COPY</code> будут работать максимально быстро, когда они выполняются в одной транзакции и архивация WAL выключена.</p></li><li class="listitem"><p>Если на сервере баз данных установлено несколько процессоров, полезным может оказаться параметр <code class="option">--jobs</code> команды <span class="application">pg_restore</span>. С его помощью можно выполнить загрузку данных и создание индексов параллельно.</p></li><li class="listitem"><p>После загрузки данных запустите <code class="command">ANALYZE</code>.</p></li></ul></div><p>При выгрузке данных без схемы тоже используется команда <code class="command">COPY</code>, но индексы, как обычно и внешние ключи, при этом не удаляются и не пересоздаются. <a href="#ftn.id-1.5.13.7.11.4.2" class="footnote"><sup class="footnote" id="id-1.5.13.7.11.4.2">[14]</sup></a> Поэтому, загружая только данные, вы сами должны решить, нужно ли для ускорения загрузки удалять и пересоздавать индексы и внешние ключи. При этом будет так же полезно увеличить параметр <code class="varname">max_wal_size</code>, но не <code class="varname">maintenance_work_mem</code>; его стоит менять, только если вы впоследствии пересоздаёте индексы и внешние ключи вручную. И не забудьте выполнить <code class="command">ANALYZE</code> после; подробнее об этом можно узнать в <a class="xref" href="routine-vacuuming.html#VACUUM-FOR-STATISTICS" title="25.1.3. Обновление статистики планировщика">Подразделе 25.1.3</a> и <a class="xref" href="routine-vacuuming.html#AUTOVACUUM" title="25.1.6. Демон автоочистки">Подразделе 25.1.6</a>.</p></div><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.id-1.5.13.7.11.4.2" class="footnote"><p><a href="#id-1.5.13.7.11.4.2" class="para"><sup class="para">[14] </sup></a>Вы можете отключить внешние ключи, используя параметр <code class="option">--disable-triggers</code> — но при этом нужно понимать, что тем самым вы не просто отложите, а полностью выключите соответствующие проверки, что позволит вставить недопустимые данные.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="explicit-joins.html" title="14.3. Управление планировщиком с помощью явных предложений JOIN">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="performance-tips.html" title="Глава 14. Оптимизация производительности">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="non-durability.html" title="14.5. Оптимизация, угрожающая стабильности">След.</a></td></tr><tr><td width="40%" align="left" valign="top">14.3. Управление планировщиком с помощью явных предложений <code class="literal">JOIN</code> </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 14.5. Оптимизация, угрожающая стабильности</td></tr></table></div></body></html>