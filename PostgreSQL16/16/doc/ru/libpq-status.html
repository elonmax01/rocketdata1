<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>34.2. Функции, описывающие текущее состояние подключения</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="libpq-connect.html" title="34.1. Функции управления подключением к базе данных" /><link rel="next" href="libpq-exec.html" title="34.3. Функции для исполнения команд" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">34.2. Функции, описывающие текущее состояние подключения</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="libpq-connect.html" title="34.1. Функции управления подключением к базе данных">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="libpq.html" title="Глава 34. libpq — библиотека для языка C">Наверх</a></td><th width="60%" align="center">Глава 34. <span class="application">libpq</span> — библиотека для языка C</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="libpq-exec.html" title="34.3. Функции для исполнения команд">След.</a></td></tr></table><hr /></div><div class="sect1" id="LIBPQ-STATUS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">34.2. Функции, описывающие текущее состояние подключения <a href="#LIBPQ-STATUS" class="id_link">#</a></h2></div></div></div><p>Эти функции могут использоваться для опроса состояния объекта, описывающего существующее подключение к базе данных.</p><div class="tip"><h3 class="title">Подсказка</h3><p><a id="id-1.7.3.9.3.1.1" class="indexterm"></a> <a id="id-1.7.3.9.3.1.2" class="indexterm"></a> Разработчики приложений на основе <span class="application">libpq</span> должны тщательно поддерживать абстракцию <code class="structname">PGconn</code>. Следует использовать функции доступа, описанные ниже, для получения содержимого <code class="structname">PGconn</code>. Обращение напрямую к внутренним полям <code class="structname">PGconn</code>, используя сведения из <code class="filename">libpq-int.h</code>, не рекомендуется, поскольку они могут измениться в будущем.</p></div><p>Следующие функции возвращают значения параметров, которые были установлены в момент подключения. Эти значения не изменяются во время жизни соединения. Если используется строка соединения с несколькими узлами, значения <a class="xref" href="libpq-status.html#LIBPQ-PQHOST"><code class="function">PQhost</code></a>, <a class="xref" href="libpq-status.html#LIBPQ-PQPORT"><code class="function">PQport</code></a> и <a class="xref" href="libpq-status.html#LIBPQ-PQPASS"><code class="function">PQpass</code></a> могут меняться, если с тем же объектом <code class="structname">PGconn</code> устанавливается новое соединение. Другие значения не меняются на протяжении жизни объекта <code class="structname">PGconn</code>. </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQDB"><span class="term"><code class="function">PQdb</code><a id="id-1.7.3.9.4.6.1.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQDB" class="id_link">#</a></dt><dd><p>Возвращает имя базы данных, с которой установлено соединение. </p><pre class="synopsis">
char *PQdb(const PGconn *conn);
</pre></dd><dt id="LIBPQ-PQUSER"><span class="term"><code class="function">PQuser</code><a id="id-1.7.3.9.4.6.2.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQUSER" class="id_link">#</a></dt><dd><p>Возвращает имя пользователя, который установил соединение.</p><pre class="synopsis">
char *PQuser(const PGconn *conn);
</pre></dd><dt id="LIBPQ-PQPASS"><span class="term"><code class="function">PQpass</code><a id="id-1.7.3.9.4.6.3.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQPASS" class="id_link">#</a></dt><dd><p>Возвращает пароль, использованный для подключения.</p><pre class="synopsis">
char *PQpass(const PGconn *conn);
</pre><p><a class="xref" href="libpq-status.html#LIBPQ-PQPASS"><code class="function">PQpass</code></a> возвратит либо пароль, указанный в параметрах подключения, либо пароль, полученный из <a class="link" href="libpq-pgpass.html" title="34.16. Файл паролей">файла паролей</a> (в случае отсутствия первого). Во втором случае, если в параметрах подключения было указано несколько узлов, полагаться на результат <a class="xref" href="libpq-status.html#LIBPQ-PQPASS"><code class="function">PQpass</code></a> нельзя, пока соединение не будет установлено. Состояние подключения позволяет проверить функция <code class="function">PQstatus</code>.</p></dd><dt id="LIBPQ-PQHOST"><span class="term"><code class="function">PQhost</code><a id="id-1.7.3.9.4.6.4.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQHOST" class="id_link">#</a></dt><dd><p>Возвращает имя сервера для активного соединения. Это может быть имя узла, IP-адрес или путь к каталогу, если подключение установлено через сокет Unix. (Признаком подключения к сокету будет абсолютный путь, который начинается с <code class="literal">/</code>.) </p><pre class="synopsis">
char *PQhost(const PGconn *conn);
</pre><p>Если в параметрах подключения был задан и <code class="literal">host</code>, и <code class="literal">hostaddr</code>, функция <a class="xref" href="libpq-status.html#LIBPQ-PQHOST"><code class="function">PQhost</code></a> выдаст содержимое <code class="literal">host</code>. Если был задан только <code class="literal">hostaddr</code>, возвращается это значение. Если в параметрах подключения было задано несколько узлов, <a class="xref" href="libpq-status.html#LIBPQ-PQHOST"><code class="function">PQhost</code></a> возвращает адрес узла, с которым фактически установлено соединение.</p><p><a class="xref" href="libpq-status.html#LIBPQ-PQHOST"><code class="function">PQhost</code></a> возвращает <code class="symbol">NULL</code>, если аргумент <em class="parameter"><code>conn</code></em> равен <code class="symbol">NULL</code>. Иначе в случае ошибки при получении информации об узле (это возможно, если соединение не установлено до конца или произошла ошибка) она возвращает пустую строку.</p><p>Если в параметрах подключения указаны несколько узлов, на результат <a class="xref" href="libpq-status.html#LIBPQ-PQHOST"><code class="function">PQhost</code></a> нельзя полагаться, пока соединение не будет установлено. Проверить состояние соединения позволяет функция <a class="xref" href="libpq-status.html#LIBPQ-PQSTATUS"><code class="function">PQstatus</code></a>.</p></dd><dt id="LIBPQ-PQHOSTADDR"><span class="term"><code class="function">PQhostaddr</code><a id="id-1.7.3.9.4.6.5.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQHOSTADDR" class="id_link">#</a></dt><dd><p>Возвращает IP-адрес сервера для активного соединения. Это может быть адрес, в который разрешилось имя узла, или IP-адрес, переданный в параметре <code class="literal">hostaddr</code>. </p><pre class="synopsis">
char *PQhostaddr(const PGconn *conn);
</pre><p><a class="xref" href="libpq-status.html#LIBPQ-PQHOSTADDR"><code class="function">PQhostaddr</code></a> возвращает <code class="symbol">NULL</code>, если аргумент <em class="parameter"><code>conn</code></em> равен <code class="symbol">NULL</code>. Иначе в случае ошибки при получении информации об узле (это возможно, если соединение не установлено до конца или произошла ошибка) она возвращает пустую строку.</p></dd><dt id="LIBPQ-PQPORT"><span class="term"><code class="function">PQport</code><a id="id-1.7.3.9.4.6.6.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQPORT" class="id_link">#</a></dt><dd><p>Возвращает номер порта активного соединения.</p><pre class="synopsis">
char *PQport(const PGconn *conn);
</pre><p>Если в параметрах подключения было задано несколько портов, <a class="xref" href="libpq-status.html#LIBPQ-PQPORT"><code class="function">PQport</code></a> возвращает порт, с которым фактически установлено соединение.</p><p><a class="xref" href="libpq-status.html#LIBPQ-PQPORT"><code class="function">PQport</code></a> возвращает <code class="symbol">NULL</code>, если аргумент <em class="parameter"><code>conn</code></em> равен <code class="symbol">NULL</code>. Иначе в случае ошибки при получении информации о порте (это возможно, если соединение не установлено до конца или произошла ошибка) она возвращает пустую строку.</p><p>Если в параметрах подключения указаны несколько портов, на результат <a class="xref" href="libpq-status.html#LIBPQ-PQPORT"><code class="function">PQport</code></a> нельзя полагаться, пока соединение не будет установлено. Проверить состояние соединения позволяет функция <a class="xref" href="libpq-status.html#LIBPQ-PQSTATUS"><code class="function">PQstatus</code></a>.</p></dd><dt id="LIBPQ-PQTTY"><span class="term"><code class="function">PQtty</code><a id="id-1.7.3.9.4.6.7.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQTTY" class="id_link">#</a></dt><dd><p>Эта функция теперь ничего не делает, но необходима для обратной совместимости. Функция всегда возвращает пустую строку или <code class="symbol">NULL</code>, если аргумент <em class="parameter"><code>conn</code></em> имеет значение <code class="symbol">NULL</code>. </p><pre class="synopsis">
char *PQtty(const PGconn *conn);
</pre></dd><dt id="LIBPQ-PQOPTIONS"><span class="term"><code class="function">PQoptions</code><a id="id-1.7.3.9.4.6.8.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQOPTIONS" class="id_link">#</a></dt><dd><p>Возвращает параметры командной строки, переданные в запросе на подключение.</p><pre class="synopsis">
char *PQoptions(const PGconn *conn);
</pre></dd></dl></div><p>Следующие функции возвращают данные статуса, который может измениться в процессе выполнения операций на объекте <code class="structname">PGconn</code>. </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQSTATUS"><span class="term"><code class="function">PQstatus</code><a id="id-1.7.3.9.5.2.1.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQSTATUS" class="id_link">#</a></dt><dd><p>Возвращает состояние подключения.</p><pre class="synopsis">
ConnStatusType PQstatus(const PGconn *conn);
</pre><p>Статус может принимать одно из ряда значений. Однако только два из них видны извне процедуры асинхронного подключения: <code class="literal">CONNECTION_OK</code> и <code class="literal">CONNECTION_BAD</code>. Успешное подключение к базе данных имеет статус <code class="literal">CONNECTION_OK</code>. О неудачной попытке подключения сигнализирует статус <code class="literal">CONNECTION_BAD</code>. Обычно статус OK остаётся таковым до вызова <a class="xref" href="libpq-connect.html#LIBPQ-PQFINISH"><code class="function">PQfinish</code></a>, но в случае ошибки соединения статус может смениться на <code class="literal">CONNECTION_BAD</code> преждевременно. В таком случае приложение может попытаться восстановить подключение, вызвав <a class="xref" href="libpq-connect.html#LIBPQ-PQRESET"><code class="function">PQreset</code></a>.</p><p>О других кодах состояния, которые могут выдать эти функции, можно узнать в описании <a class="xref" href="libpq-connect.html#LIBPQ-PQCONNECTSTARTPARAMS"><code class="function">PQconnectStartParams</code></a>, <code class="function">PQconnectStart</code> и <code class="function">PQconnectPoll</code>.</p></dd><dt id="LIBPQ-PQTRANSACTIONSTATUS"><span class="term"><code class="function">PQtransactionStatus</code><a id="id-1.7.3.9.5.2.2.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQTRANSACTIONSTATUS" class="id_link">#</a></dt><dd><p>Возвращает текущий статус сервера, отражающий процесс выполнения транзакций. </p><pre class="synopsis">
PGTransactionStatusType PQtransactionStatus(const PGconn *conn);
</pre><p> Статус может быть одним из <code class="literal">PQTRANS_IDLE</code> (в настоящее время не занят обработкой транзакции), <code class="literal">PQTRANS_ACTIVE</code> (команда в процессе обработки), <code class="literal">PQTRANS_INTRANS</code> (не выполняет работу, но находится в рамках действительной транзакции) или <code class="literal">PQTRANS_INERROR</code> (не выполняет работу, но находится в рамках транзакции, завершившейся сбоем). Статус принимает значение <code class="literal">PQTRANS_UNKNOWN</code>, если соединение не работает. Статус принимает значение <code class="literal">PQTRANS_ACTIVE</code> только тогда, когда запрос был отправлен серверу, но ещё не завершён.</p></dd><dt id="LIBPQ-PQPARAMETERSTATUS"><span class="term"><code class="function">PQparameterStatus</code><a id="id-1.7.3.9.5.2.3.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQPARAMETERSTATUS" class="id_link">#</a></dt><dd><p>Отыскивает текущее значение параметра сервера. </p><pre class="synopsis">
const char *PQparameterStatus(const PGconn *conn, const char *paramName);
</pre><p> Значения определённых параметров сервер сообщает автоматически в начале процедуры подключения или тогда, когда их значения изменяются. <a class="xref" href="libpq-status.html#LIBPQ-PQPARAMETERSTATUS"><code class="function">PQparameterStatus</code></a> можно использовать, чтобы запросить эти значения. Функция возвращает текущее значение параметра, если оно известно, или <code class="symbol">NULL</code>, если параметр неизвестен.</p><p>Параметры, об изменении которых сообщается в текущей версии: </p><table border="0" summary="Simple list" class="simplelist"><tr><td><code class="varname">application_name</code></td><td><code class="varname">is_superuser</code></td></tr><tr><td><code class="varname">client_encoding</code></td><td><code class="varname">scram_iterations</code></td></tr><tr><td><code class="varname">DateStyle</code></td><td><code class="varname">server_encoding</code></td></tr><tr><td><code class="varname">default_transaction_read_only</code></td><td><code class="varname">server_version</code></td></tr><tr><td><code class="varname">in_hot_standby</code></td><td><code class="varname">session_authorization</code></td></tr><tr><td><code class="varname">integer_datetimes</code></td><td><code class="varname">standard_conforming_strings</code></td></tr><tr><td><code class="varname">IntervalStyle</code></td><td><code class="varname">TimeZone</code></td></tr></table><p> (<code class="varname">server_encoding</code>, <code class="varname">TimeZone</code> и <code class="varname">integer_datetimes</code> не отслеживались до версии 8.0; <code class="varname">standard_conforming_strings</code> не отслеживался до 8.1; <code class="varname">IntervalStyle</code> — до версии 8.4; <code class="varname">application_name</code> — до версии 9.0; <code class="varname">default_transaction_read_only</code> и <code class="varname">in_hot_standby</code> — до версии 14; <code class="varname">scram_iterations</code> — до версии 16.) Обратите внимание, что <code class="varname">server_version</code>, <code class="varname">server_encoding</code> и <code class="varname">integer_datetimes</code> не могут меняться после запуска сервера.</p><p>Если для <code class="varname">standard_conforming_strings</code> не передано никакого значения, то приложения могут принять его равным <code class="literal">off</code>. Это означает, что символы обратной косой черты в строковых литералах интерпретируются в качестве спецсимволов. Также, наличие этого параметра может рассматриваться как указание на то, что синтаксис escape-строк (<code class="literal">E'...'</code>) является приемлемым.</p><p>Хотя возвращаемый указатель объявлен со спецификатором <code class="literal">const</code>, фактически он указывает на изменяемое хранилище, связанное со структурой <code class="literal">PGconn</code>. Не стоит рассчитывать на то, что указатель останется действительным при последующих запросах.</p></dd><dt id="LIBPQ-PQPROTOCOLVERSION"><span class="term"><code class="function">PQprotocolVersion</code><a id="id-1.7.3.9.5.2.4.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQPROTOCOLVERSION" class="id_link">#</a></dt><dd><p>Запрашивает протокол, используемый между клиентом и сервером. </p><pre class="synopsis">
int PQprotocolVersion(const PGconn *conn);
</pre><p> Приложения могут использовать эту функцию, чтобы определить, поддерживаются ли опредёленные функциональные возможности. В настоящее время возможными значениями являются 3 (протокол версии 3.0) или ноль (проблемы в подключении). Версия протокола не будет изменяться после завершения процедуры подключения, но теоретически она могла бы измениться в процессе переподключения. Версия протокола 3.0 обычно используется при взаимодействии с серверами <span class="productname">PostgreSQL</span> версии 7.4 или более поздними.</p></dd><dt id="LIBPQ-PQSERVERVERSION"><span class="term"><code class="function">PQserverVersion</code><a id="id-1.7.3.9.5.2.5.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQSERVERVERSION" class="id_link">#</a></dt><dd><p>Возвращает целочисленное представление версии сервера. </p><pre class="synopsis">
int PQserverVersion(const PGconn *conn);
</pre><p>Приложения могут использовать эту функцию, чтобы определить версию сервера баз данных, к которому они подключены. Возвращаемое ей число получается в результате умножения номера основной версии на 10000 и добавления номера дополнительной версии. Например, для версии 10.1 будет выдано число 100001, а для версии 11.0 — 110000. Если соединение не работает, то возвращается ноль.</p><p>До версии 10 в <span class="productname">PostgreSQL</span> номера версий образовывались из трёх чисел, первые два из которых представляли основную версию. Для таких версий <a class="xref" href="libpq-status.html#LIBPQ-PQSERVERVERSION"><code class="function">PQserverVersion</code></a> отводит на каждое число по две цифры; например, для версии 9.1.5 будет выдано 90105, а для версии 9.2.0 — 90200.</p><p>Таким образом, чтобы получить логический номер основной версии для определения доступности функционала, приложения должны разделить результат <a class="xref" href="libpq-status.html#LIBPQ-PQSERVERVERSION"><code class="function">PQserverVersion</code></a> на 100, а не на 10000. Во всех сериях номера дополнительных (корректирующих) выпусков различаются только в двух последних цифрах.</p></dd><dt id="LIBPQ-PQERRORMESSAGE"><span class="term"><code class="function">PQerrorMessage</code><a id="id-1.7.3.9.5.2.6.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQERRORMESSAGE" class="id_link">#</a></dt><dd><p><a id="id-1.7.3.9.5.2.6.2.1.1" class="indexterm"></a> Возвращает сообщение об ошибке, наиболее недавно сгенерированное операцией, выполненной в рамках текущего подключения. </p><pre class="synopsis">
char *PQerrorMessage(const PGconn *conn);
</pre><p>Почти все функции библиотеки <span class="application">libpq</span> в случае сбоя сформируют сообщение для <a class="xref" href="libpq-status.html#LIBPQ-PQERRORMESSAGE"><code class="function">PQerrorMessage</code></a>. Обратите внимание, что по соглашениям, принятым в <span class="application">libpq</span>, непустой результат функции <a class="xref" href="libpq-status.html#LIBPQ-PQERRORMESSAGE"><code class="function">PQerrorMessage</code></a> может состоять из нескольких строк и будет включать завершающий символ новой строки. Вызывающая функция не должна освобождать память, на которую указывает возвращаемое значение, напрямую. Она будет освобождена, когда связанный с ней дескриптор <code class="structname">PGconn</code> будет передан функции <a class="xref" href="libpq-connect.html#LIBPQ-PQFINISH"><code class="function">PQfinish</code></a>. Не стоит ожидать, что результирующая строка останется той же самой при выполнении нескольких операций со структурой <code class="literal">PGconn</code>.</p></dd><dt id="LIBPQ-PQSOCKET"><span class="term"><code class="function">PQsocket</code><a id="id-1.7.3.9.5.2.7.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQSOCKET" class="id_link">#</a></dt><dd><p>Получает номер файлового дескриптора для сокета соединения с сервером. Действительный дескриптор будет больше или равен 0; значение -1 показывает, что в данный момент не открыто ни одного соединения с сервером. (Значение не изменится во время обычной работы, но может измениться во время установки или переустановки подключения.) </p><pre class="synopsis">
int PQsocket(const PGconn *conn);
</pre></dd><dt id="LIBPQ-PQBACKENDPID"><span class="term"><code class="function">PQbackendPID</code><a id="id-1.7.3.9.5.2.8.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQBACKENDPID" class="id_link">#</a></dt><dd><p>Возвращает <acronym class="acronym">ID</acronym> (PID)<a id="id-1.7.3.9.5.2.8.2.1.2" class="indexterm"></a> серверного процесса, обрабатывающего это подключение. </p><pre class="synopsis">
int PQbackendPID(const PGconn *conn);
</pre><p><acronym class="acronym">PID</acronym> серверного процесса полезен для отладочных целей и для сопоставления с сообщениями команды <code class="command">NOTIFY</code> (которые включают <acronym class="acronym">PID</acronym> уведомляющего серверного процесса). Примите к сведению, что <acronym class="acronym">PID</acronym> принадлежит процессу, выполняющемуся на узле сервера баз данных, а не на локальном узле.</p></dd><dt id="LIBPQ-PQCONNECTIONNEEDSPASSWORD"><span class="term"><code class="function">PQconnectionNeedsPassword</code><a id="id-1.7.3.9.5.2.9.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQCONNECTIONNEEDSPASSWORD" class="id_link">#</a></dt><dd><p>Возвращает true (1), если метод аутентификации соединения требовал пароля, однако он не был предоставлен. Возвращает false (0), если пароль не требовался. </p><pre class="synopsis">
int PQconnectionNeedsPassword(const PGconn *conn);
</pre><p>Эту функцию можно применить после неудачной попытки подключения, чтобы решить, нужно ли предлагать пользователю ввести пароль.</p></dd><dt id="LIBPQ-PQCONNECTIONUSEDPASSWORD"><span class="term"><code class="function">PQconnectionUsedPassword</code><a id="id-1.7.3.9.5.2.10.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQCONNECTIONUSEDPASSWORD" class="id_link">#</a></dt><dd><p>Возвращает true (1), если метод аутентификации соединения использовал пароль. Возвращает false (0) в противном случае. </p><pre class="synopsis">
int PQconnectionUsedPassword(const PGconn *conn);
</pre><p>Эту функцию можно применить как после неудачной, так и после успешной попытки подключения, чтобы определить, требовал ли сервер предоставления пароля.</p></dd><dt id="LIBPQ-PQCONNECTIONUSEDGSSAPI"><span class="term"><code class="function">PQconnectionUsedGSSAPI</code><a id="id-1.7.3.9.5.2.11.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQCONNECTIONUSEDGSSAPI" class="id_link">#</a></dt><dd><p>Возвращает true (1), если метод аутентификации соединения использовал GSSAPI. Возвращает false (0) в противном случае. </p><pre class="synopsis">
int PQconnectionUsedGSSAPI(const PGconn *conn);
</pre><p>Эту функцию можно применить, чтобы определить, использовалась ли для подключения аутентификация GSSAPI.</p></dd></dl></div><p>Следующие функции возвращают информацию, относящуюся к SSL. Эта информация обычно не меняется после того, как подключение установлено. </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQSSLINUSE"><span class="term"><code class="function">PQsslInUse</code><a id="id-1.7.3.9.6.1.1.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQSSLINUSE" class="id_link">#</a></dt><dd><p>Возвращает true (1), если для текущего подключения используется SSL, и false (0) в противном случае. </p><pre class="synopsis">
int PQsslInUse(const PGconn *conn);
</pre></dd><dt id="LIBPQ-PQSSLATTRIBUTE"><span class="term"><code class="function">PQsslAttribute</code><a id="id-1.7.3.9.6.1.2.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQSSLATTRIBUTE" class="id_link">#</a></dt><dd><p>Возвращает связанную с SSL информацию о соединении. </p><pre class="synopsis">
const char *PQsslAttribute(const PGconn *conn, const char *attribute_name);
</pre><p>Список доступных атрибутов зависит от используемой библиотеки SSL и типа подключения. Если подключение не использует SSL или указанное имя атрибута неизвестно используемой библиотеке, возвращается NULL.</p><p>Обычно доступны следующие атрибуты: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">library</code></span></dt><dd><p>Имя используемой реализации SSL. (В настоящее время поддерживается только <code class="literal">"OpenSSL"</code>)</p></dd><dt><span class="term"><code class="literal">protocol</code></span></dt><dd><p>Применяемая версия SSL/TLS. Наиболее распространены варианты <code class="literal">"TLSv1"</code>, <code class="literal">"TLSv1.1"</code> и <code class="literal">"TLSv1.2"</code>, но реализация может возвращать и другие строки, если применяется какой-то другой протокол.</p></dd><dt><span class="term"><code class="literal">key_bits</code></span></dt><dd><p>Число бит в ключе, используемом алгоритмом шифрования.</p></dd><dt><span class="term"><code class="literal">cipher</code></span></dt><dd><p>Краткое имя применяемого комплекта шифров, например: <code class="literal">"DHE-RSA-DES-CBC3-SHA"</code>. Эти имена могут быть разными в разных реализациях SSL.</p></dd><dt><span class="term"><code class="literal">compression</code></span></dt><dd><p>Возвращает <code class="literal">on</code>, если используется сжатие SSL, или <code class="literal">off</code> в противном случае.</p></dd></dl></div><p>В качестве исключения можно запросить атрибут <code class="literal">library</code> без подключения, передав NULL в качестве аргумента <code class="literal">conn</code>. В результате будет выдано имя используемой по умолчанию библиотеки SSL, либо NULL, если библиотека <span class="application">libpq</span> была скомпилирована без поддержки SSL. (В версиях <span class="productname">PostgreSQL</span> ниже 15, когда в <code class="literal">conn</code> передавался NULL, результатом всегда был NULL. Отличить новую реализацию от старой в клиентских программах можно, проверив макрос <code class="literal">LIBPQ_HAS_SSL_LIBRARY_DETECTION</code>.)</p></dd><dt id="LIBPQ-PQSSLATTRIBUTENAMES"><span class="term"><code class="function">PQsslAttributeNames</code><a id="id-1.7.3.9.6.1.3.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQSSLATTRIBUTENAMES" class="id_link">#</a></dt><dd><p>Возвращает массив имён доступных атрибутов SSL, которые могут использоваться в <code class="function">PQsslAttribute()</code>. Завершается массив указателем NULL. </p><pre class="synopsis">
const char * const * PQsslAttributeNames(const PGconn *conn);
</pre><p>Если <code class="literal">conn</code> равен NULL, возвращаются атрибуты, доступные для библиотеки SSL по умолчанию, или пустой список, если библиотека <span class="application">libpq</span> была скомпилирована без поддержки SSL. При значении <code class="literal">conn</code>, отличном от NULL, возвращаются атрибуты, доступные для библиотеки SSL, используемой для соединения, или пустой список, если соединение не зашифровано.</p></dd><dt id="LIBPQ-PQSSLSTRUCT"><span class="term"><code class="function">PQsslStruct</code><a id="id-1.7.3.9.6.1.4.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQSSLSTRUCT" class="id_link">#</a></dt><dd><p>Возвращает указатель на специфичный для реализации SSL объект, описывающий подключение. Если соединение не зашифровано или реализация SSL, используемая для подключения, не поддерживает запрошенный тип объекта, возвращается NULL. </p><pre class="synopsis">
void *PQsslStruct(const PGconn *conn, const char *struct_name);
</pre><p>Какие структуры можно получить, зависит от используемой реализации SSL. <span class="productname">OpenSSL</span> предоставляет одну структуру с именем <code class="literal">OpenSSL</code> и возвращает указатель на объект <code class="literal">SSL</code> struct, описанный в <span class="productname">OpenSSL</span>. Для написания вызова этой функции можно воспользоваться кодом в следующих строках: </p><pre class="programlisting">
#include &lt;libpq-fe.h&gt;
#include &lt;openssl/ssl.h&gt;

...

    SSL *ssl;

    dbconn = PQconnectdb(...);
    ...

    ssl = PQsslStruct(dbconn, "OpenSSL");
    if (ssl)
    {
        /* use OpenSSL functions to access ssl */
    }
</pre><p>Эта структура может использоваться, чтобы сличить уровни шифрования, проверить сертификаты сервера и т. д. За информацией об этой структуре обратитесь к документации по <span class="productname">OpenSSL</span>.</p></dd><dt id="LIBPQ-PQGETSSL"><span class="term"><code class="function">PQgetssl</code><a id="id-1.7.3.9.6.1.5.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQGETSSL" class="id_link">#</a></dt><dd><p><a id="id-1.7.3.9.6.1.5.2.1.1" class="indexterm"></a> Возвращает структуру SSL, использовавшуюся в соединении, или NULL, если SSL не используется. </p><pre class="synopsis">
void *PQgetssl(const PGconn *conn);
</pre><p>Эта функция равнозначна <code class="literal">PQsslStruct(conn, "OpenSSL")</code>. Её не следует применять в новых приложениях, так как возвращаемая структура специфична для <span class="productname">OpenSSL</span> и её нельзя будет получить с другой реализацией <acronym class="acronym">SSL</acronym>. Чтобы проверить, использует ли подключение SSL, лучше вызвать <a class="xref" href="libpq-status.html#LIBPQ-PQSSLINUSE"><code class="function">PQsslInUse</code></a>, а чтобы получить свойства подключения — <a class="xref" href="libpq-status.html#LIBPQ-PQSSLATTRIBUTE"><code class="function">PQsslAttribute</code></a>.</p></dd></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="libpq-connect.html" title="34.1. Функции управления подключением к базе данных">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="libpq.html" title="Глава 34. libpq — библиотека для языка C">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="libpq-exec.html" title="34.3. Функции для исполнения команд">След.</a></td></tr><tr><td width="40%" align="left" valign="top">34.1. Функции управления подключением к базе данных </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 34.3. Функции для исполнения команд</td></tr></table></div></body></html>