<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>20.7. Планирование запросов</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="runtime-config-replication.html" title="20.6. Репликация" /><link rel="next" href="runtime-config-logging.html" title="20.8. Регистрация ошибок и протоколирование работы сервера" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">20.7. Планирование запросов</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="runtime-config-replication.html" title="20.6. Репликация">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="runtime-config.html" title="Глава 20. Настройка сервера">Наверх</a></td><th width="60%" align="center">Глава 20. Настройка сервера</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="runtime-config-logging.html" title="20.8. Регистрация ошибок и протоколирование работы сервера">След.</a></td></tr></table><hr /></div><div class="sect1" id="RUNTIME-CONFIG-QUERY"><div class="titlepage"><div><div><h2 class="title" style="clear: both">20.7. Планирование запросов <a href="#RUNTIME-CONFIG-QUERY" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="runtime-config-query.html#RUNTIME-CONFIG-QUERY-ENABLE">20.7.1. Конфигурация методов планировщика</a></span></dt><dt><span class="sect2"><a href="runtime-config-query.html#RUNTIME-CONFIG-QUERY-CONSTANTS">20.7.2. Константы стоимости для планировщика</a></span></dt><dt><span class="sect2"><a href="runtime-config-query.html#RUNTIME-CONFIG-QUERY-GEQO">20.7.3. Генетический оптимизатор запросов</a></span></dt><dt><span class="sect2"><a href="runtime-config-query.html#RUNTIME-CONFIG-QUERY-OTHER">20.7.4. Другие параметры планировщика</a></span></dt></dl></div><div class="sect2" id="RUNTIME-CONFIG-QUERY-ENABLE"><div class="titlepage"><div><div><h3 class="title">20.7.1. Конфигурация методов планировщика <a href="#RUNTIME-CONFIG-QUERY-ENABLE" class="id_link">#</a></h3></div></div></div><p>Эти параметры конфигурации дают возможность грубо влиять на планы, выбираемые оптимизатором запросов. Если автоматически выбранный оптимизатором план конкретного запроса оказался неоптимальным, в качестве <span class="emphasis"><em>временного</em></span> решения можно воспользоваться одним из этих параметров и вынудить планировщик выбрать другой план. Улучшить качество планов, выбираемых планировщиком, можно и более подходящими способами, в частности, скорректировать константы стоимости (см. <a class="xref" href="runtime-config-query.html#RUNTIME-CONFIG-QUERY-CONSTANTS" title="20.7.2. Константы стоимости для планировщика">Подраздел 20.7.2</a>), выполнить <a class="link" href="sql-analyze.html" title="ANALYZE"><code class="command">ANALYZE</code></a> вручную, увеличить значение параметра конфигурации <a class="xref" href="runtime-config-query.html#GUC-DEFAULT-STATISTICS-TARGET">default_statistics_target</a> и увеличить объём статистики, собираемой для отдельных столбцов, воспользовавшись командой <code class="command">ALTER TABLE SET STATISTICS</code>.</p><div class="variablelist"><dl class="variablelist"><dt id="GUC-ENABLE-ASYNC-APPEND"><span class="term"><code class="varname">enable_async_append</code> (<code class="type">boolean</code>) <a id="id-1.6.7.10.2.3.1.1.3" class="indexterm"></a></span> <a href="#GUC-ENABLE-ASYNC-APPEND" class="id_link">#</a></dt><dd><p>Включает или отключает использование планировщиком планов с асинхронным добавлением данных. По умолчанию имеет значение <code class="literal">on</code> (вкл.).</p></dd><dt id="GUC-ENABLE-BITMAPSCAN"><span class="term"><code class="varname">enable_bitmapscan</code> (<code class="type">boolean</code>) <a id="id-1.6.7.10.2.3.2.1.3" class="indexterm"></a> <a id="id-1.6.7.10.2.3.2.1.4" class="indexterm"></a></span> <a href="#GUC-ENABLE-BITMAPSCAN" class="id_link">#</a></dt><dd><p>Включает или отключает использование планов сканирования по битовой карте. По умолчанию имеет значение <code class="literal">on</code> (вкл.).</p></dd><dt id="GUC-ENABLE-GATHERMERGE"><span class="term"><code class="varname">enable_gathermerge</code> (<code class="type">boolean</code>) <a id="id-1.6.7.10.2.3.3.1.3" class="indexterm"></a></span> <a href="#GUC-ENABLE-GATHERMERGE" class="id_link">#</a></dt><dd><p>Включает или отключает использование планов соединения посредством сбора. По умолчанию имеет значение <code class="literal">on</code> (вкл.).</p></dd><dt id="GUC-ENABLE-HASHAGG"><span class="term"><code class="varname">enable_hashagg</code> (<code class="type">boolean</code>) <a id="id-1.6.7.10.2.3.4.1.3" class="indexterm"></a></span> <a href="#GUC-ENABLE-HASHAGG" class="id_link">#</a></dt><dd><p>Включает или отключает использование планов агрегирования по хешу. По умолчанию имеет значение <code class="literal">on</code> (вкл.).</p></dd><dt id="GUC-ENABLE-HASHJOIN"><span class="term"><code class="varname">enable_hashjoin</code> (<code class="type">boolean</code>) <a id="id-1.6.7.10.2.3.5.1.3" class="indexterm"></a></span> <a href="#GUC-ENABLE-HASHJOIN" class="id_link">#</a></dt><dd><p>Включает или отключает использование планов соединения по хешу. По умолчанию имеет значение <code class="literal">on</code> (вкл.).</p></dd><dt id="GUC-ENABLE-INCREMENTAL-SORT"><span class="term"><code class="varname">enable_incremental_sort</code> (<code class="type">boolean</code>) <a id="id-1.6.7.10.2.3.6.1.3" class="indexterm"></a></span> <a href="#GUC-ENABLE-INCREMENTAL-SORT" class="id_link">#</a></dt><dd><p>Включает или отключает использование планировщиком инкрементальной сортировки. По умолчанию имеет значение <code class="literal">on</code> (вкл.).</p></dd><dt id="GUC-ENABLE-INDEXSCAN"><span class="term"><code class="varname">enable_indexscan</code> (<code class="type">boolean</code>) <a id="id-1.6.7.10.2.3.7.1.3" class="indexterm"></a> <a id="id-1.6.7.10.2.3.7.1.4" class="indexterm"></a></span> <a href="#GUC-ENABLE-INDEXSCAN" class="id_link">#</a></dt><dd><p>Включает или отключает использование планов сканирования по индексу. По умолчанию имеет значение <code class="literal">on</code> (вкл.).</p></dd><dt id="GUC-ENABLE-INDEXONLYSCAN"><span class="term"><code class="varname">enable_indexonlyscan</code> (<code class="type">boolean</code>) <a id="id-1.6.7.10.2.3.8.1.3" class="indexterm"></a></span> <a href="#GUC-ENABLE-INDEXONLYSCAN" class="id_link">#</a></dt><dd><p>Включает или отключает использование планов сканирования только индекса (см. <a class="xref" href="indexes-index-only-scans.html" title="11.9. Сканирование только индекса и покрывающие индексы">Раздел 11.9</a>). По умолчанию имеет значение <code class="literal">on</code> (вкл.).</p></dd><dt id="GUC-ENABLE-MATERIAL"><span class="term"><code class="varname">enable_material</code> (<code class="type">boolean</code>) <a id="id-1.6.7.10.2.3.9.1.3" class="indexterm"></a></span> <a href="#GUC-ENABLE-MATERIAL" class="id_link">#</a></dt><dd><p>Включает или отключает использование материализации при планировании запросов. Полностью исключить материализацию невозможно, но при выключении этого параметра планировщик не будет вставлять узлы материализации, за исключением случаев, где они требуются для правильности. По умолчанию этот параметр имеет значение <code class="literal">on</code> (вкл.).</p></dd><dt id="GUC-ENABLE-MEMOIZE"><span class="term"><code class="varname">enable_memoize</code> (<code class="type">boolean</code>) <a id="id-1.6.7.10.2.3.10.1.3" class="indexterm"></a></span> <a href="#GUC-ENABLE-MEMOIZE" class="id_link">#</a></dt><dd><p>Включает или отключает использование планировщиком планов с мемоизацией для кеширования результатов параметризованного сканирования внутри соединений вложенным циклом. Этот тип плана позволяет пропускать сканирование нижележащих планов, когда результаты, соответствующие текущим параметрам, уже находятся в кеше. Менее востребованные результаты могут быть удалены из кеша, когда требуется больше места для новых записей. По умолчанию имеет значение <code class="literal">on</code> (вкл.).</p></dd><dt id="GUC-ENABLE-MERGEJOIN"><span class="term"><code class="varname">enable_mergejoin</code> (<code class="type">boolean</code>) <a id="id-1.6.7.10.2.3.11.1.3" class="indexterm"></a></span> <a href="#GUC-ENABLE-MERGEJOIN" class="id_link">#</a></dt><dd><p>Включает или отключает использование планов соединения слиянием. По умолчанию имеет значение <code class="literal">on</code> (вкл.).</p></dd><dt id="GUC-ENABLE-NESTLOOP"><span class="term"><code class="varname">enable_nestloop</code> (<code class="type">boolean</code>) <a id="id-1.6.7.10.2.3.12.1.3" class="indexterm"></a></span> <a href="#GUC-ENABLE-NESTLOOP" class="id_link">#</a></dt><dd><p>Включает или отключает использование планировщиком планов соединения с вложенными циклами. Полностью исключить вложенные циклы невозможно, но при выключении этого параметра планировщик не будет использовать данный метод, если можно применить другие. По умолчанию этот параметр имеет значение <code class="literal">on</code>.</p></dd><dt id="GUC-ENABLE-PARALLEL-APPEND"><span class="term"><code class="varname">enable_parallel_append</code> (<code class="type">boolean</code>) <a id="id-1.6.7.10.2.3.13.1.3" class="indexterm"></a></span> <a href="#GUC-ENABLE-PARALLEL-APPEND" class="id_link">#</a></dt><dd><p>Включает или отключает использование планировщиком планов с распараллеливанием добавления данных. По умолчанию имеет значение <code class="literal">on</code> (вкл.).</p></dd><dt id="GUC-ENABLE-PARALLEL-HASH"><span class="term"><code class="varname">enable_parallel_hash</code> (<code class="type">boolean</code>) <a id="id-1.6.7.10.2.3.14.1.3" class="indexterm"></a></span> <a href="#GUC-ENABLE-PARALLEL-HASH" class="id_link">#</a></dt><dd><p>Включает или отключает использование планировщиком планов соединения по хешу с распараллеливанием хеширования. Не действует, если планы соединения по хешу отключены. По умолчанию имеет значение <code class="literal">on</code> (вкл.).</p></dd><dt id="GUC-ENABLE-PARTITION-PRUNING"><span class="term"><code class="varname">enable_partition_pruning</code> (<code class="type">boolean</code>) <a id="id-1.6.7.10.2.3.15.1.3" class="indexterm"></a></span> <a href="#GUC-ENABLE-PARTITION-PRUNING" class="id_link">#</a></dt><dd><p>Включает или отключает в планировщике возможность устранять секции секционированных таблиц из планов запроса. Также влияет на возможность планировщика генерировать планы запросов, позволяющие исполнителю пропускать (игнорировать) секции при выполнении запросов. По умолчанию имеет значение <code class="literal">on</code> (вкл.). За подробностями обратитесь к <a class="xref" href="ddl-partitioning.html#DDL-PARTITION-PRUNING" title="5.11.4. Устранение секций">Подразделу 5.11.4</a>.</p></dd><dt id="GUC-ENABLE-PARTITIONWISE-JOIN"><span class="term"><code class="varname">enable_partitionwise_join</code> (<code class="type">boolean</code>) <a id="id-1.6.7.10.2.3.16.1.3" class="indexterm"></a></span> <a href="#GUC-ENABLE-PARTITIONWISE-JOIN" class="id_link">#</a></dt><dd><p>Включает или отключает использование планировщиком соединения с учётом секционирования, что позволяет выполнять соединение секционированных таблиц путём соединения соответствующих секций. Соединение с учётом секционирования в настоящее время может применяться, только когда условия соединения включают все ключи секционирования; при этом ключи должны быть одного типа данных и дочерние секции должны соответствовать один-к-одному. Так как для планирования соединения с учётом секций может потребоваться гораздо больше процессорного времени и памяти, по умолчанию этот параметр выключен (<code class="literal">off</code>).</p></dd><dt id="GUC-ENABLE-PARTITIONWISE-AGGREGATE"><span class="term"><code class="varname">enable_partitionwise_aggregate</code> (<code class="type">boolean</code>) <a id="id-1.6.7.10.2.3.17.1.3" class="indexterm"></a></span> <a href="#GUC-ENABLE-PARTITIONWISE-AGGREGATE" class="id_link">#</a></dt><dd><p>Включает или отключает использование планировщиком группировки или агрегирования с учётом секционирования, что позволяет выполнять группировку или агрегирование в секционированных таблицах по отдельности для каждой секции. Если предложение <code class="literal">GROUP BY</code> не включает ключи секционирования, на уровне секций может быть выполнено только частичное агрегирование, а затем требуется итоговая обработка. Так как для планирования группировки или агрегирования может потребоваться гораздо больше процессорного времени и памяти, по умолчанию этот параметр выключен (<code class="literal">off</code>).</p></dd><dt id="GUC-ENABLE-PRESORTED-AGGREGATE"><span class="term"><code class="varname">enable_presorted_aggregate</code> (<code class="type">boolean</code>) <a id="id-1.6.7.10.2.3.18.1.3" class="indexterm"></a></span> <a href="#GUC-ENABLE-PRESORTED-AGGREGATE" class="id_link">#</a></dt><dd><p>Определяет, будет ли планировщик запросов создавать план, в котором строки предварительно отсортированы в порядке, необходимом для агрегатных функций запроса с предложениями <code class="literal">ORDER BY</code> / <code class="literal">DISTINCT</code>. Если этот параметр отключён, планировщик запросов будет создавать план, который всегда будет требовать от исполнителя выполнять сортировку перед вызовом каждой агрегатной функции с предложениями <code class="literal">ORDER BY</code> или <code class="literal">DISTINCT</code>. Когда этот параметр включён, планировщик пытается создать более эффективный план, предоставляющий входные данные для агрегатных функций, которые предварительно отсортированы в том порядке, который они требуют для агрегирования. Значение по умолчанию — <code class="literal">on</code>.</p></dd><dt id="GUC-ENABLE-SEQSCAN"><span class="term"><code class="varname">enable_seqscan</code> (<code class="type">boolean</code>) <a id="id-1.6.7.10.2.3.19.1.3" class="indexterm"></a> <a id="id-1.6.7.10.2.3.19.1.4" class="indexterm"></a></span> <a href="#GUC-ENABLE-SEQSCAN" class="id_link">#</a></dt><dd><p>Включает или отключает использование планировщиком планов последовательного сканирования. Полностью исключить последовательное сканирование невозможно, но при выключении этого параметра планировщик не будет использовать данный метод, если можно применить другие. По умолчанию этот параметр имеет значение <code class="literal">on</code>.</p></dd><dt id="GUC-ENABLE-SORT"><span class="term"><code class="varname">enable_sort</code> (<code class="type">boolean</code>) <a id="id-1.6.7.10.2.3.20.1.3" class="indexterm"></a></span> <a href="#GUC-ENABLE-SORT" class="id_link">#</a></dt><dd><p>Включает или отключает использование планировщиком шагов с явной сортировкой. Полностью исключить явную сортировку невозможно, но при выключении этого параметра планировщик не будет использовать данный метод, если можно применить другие. По умолчанию этот параметр имеет значение <code class="literal">on</code>.</p></dd><dt id="GUC-ENABLE-TIDSCAN"><span class="term"><code class="varname">enable_tidscan</code> (<code class="type">boolean</code>) <a id="id-1.6.7.10.2.3.21.1.3" class="indexterm"></a></span> <a href="#GUC-ENABLE-TIDSCAN" class="id_link">#</a></dt><dd><p>Включает или отключает использование планов сканирования <acronym class="acronym">TID</acronym>. По умолчанию имеет значение <code class="literal">on</code> (вкл.).</p></dd></dl></div></div><div class="sect2" id="RUNTIME-CONFIG-QUERY-CONSTANTS"><div class="titlepage"><div><div><h3 class="title">20.7.2. Константы стоимости для планировщика <a href="#RUNTIME-CONFIG-QUERY-CONSTANTS" class="id_link">#</a></h3></div></div></div><p>Переменные <em class="firstterm">стоимости</em>, описанные в данном разделе, задаются по произвольной шкале. Значение имеют только их отношения, поэтому умножение или деление всех переменных на один коэффициент никак не повлияет на выбор планировщика. По умолчанию эти переменные определяются относительно стоимости чтения последовательной страницы: то есть, переменную <code class="varname">seq_page_cost</code> удобно задать равной <code class="literal">1.0</code>, а все другие переменные стоимости определить относительно неё. Но при желании можно использовать и другую шкалу, например, выразить в миллисекундах фактическое время выполнения запросов на конкретной машине.</p><div class="note"><h3 class="title">Примечание</h3><p>К сожалению, какого-либо чётко определённого способа определения идеальных значений стоимости не существует. Лучше всего выбирать их как средние показатели при выполнении целого ряда разнообразных запросов, которые будет обрабатывать конкретная СУБД. Это значит, что менять их по результатам всего нескольких экспериментов очень рискованно.</p></div><div class="variablelist"><dl class="variablelist"><dt id="GUC-SEQ-PAGE-COST"><span class="term"><code class="varname">seq_page_cost</code> (<code class="type">floating point</code>) <a id="id-1.6.7.10.3.4.1.1.3" class="indexterm"></a></span> <a href="#GUC-SEQ-PAGE-COST" class="id_link">#</a></dt><dd><p>Задаёт приблизительную стоимость чтения одной страницы с диска, которое выполняется в серии последовательных чтений. Значение по умолчанию равно 1.0. Это значение можно переопределить для таблиц и индексов в определённом табличном пространстве, установив одноимённый параметр табличного пространства (см. <a class="xref" href="sql-altertablespace.html" title="ALTER TABLESPACE"><span class="refentrytitle">ALTER TABLESPACE</span></a>).</p></dd><dt id="GUC-RANDOM-PAGE-COST"><span class="term"><code class="varname">random_page_cost</code> (<code class="type">floating point</code>) <a id="id-1.6.7.10.3.4.2.1.3" class="indexterm"></a></span> <a href="#GUC-RANDOM-PAGE-COST" class="id_link">#</a></dt><dd><p>Задаёт приблизительную стоимость чтения одной произвольной страницы с диска. Значение по умолчанию равно 4.0. Это значение можно переопределить для таблиц и индексов в определённом табличном пространстве, установив одноимённый параметр табличного пространства (см. <a class="xref" href="sql-altertablespace.html" title="ALTER TABLESPACE"><span class="refentrytitle">ALTER TABLESPACE</span></a>).</p><p>При уменьшении этого значения по отношению к <code class="varname">seq_page_cost</code> система начинает предпочитать сканирование по индексу; при увеличении такое сканирование становится более дорогостоящим. Оба эти значения также можно увеличить или уменьшить одновременно, чтобы изменить стоимость операций ввода/вывода по отношению к стоимости процессорных операций, которая определяется следующими параметрами.</p><p>Произвольный доступ к механическому дисковому хранилищу обычно гораздо дороже последовательного доступа, более чем в четыре раза. Однако по умолчанию выбран небольшой коэффициент (4.0), в предположении, что большой объём данных при произвольном доступе, например, при чтении индекса, окажется в кеше. Таким образом, можно считать, что значение по умолчанию моделирует ситуацию, когда произвольный доступ в 40 раз медленнее последовательного, но 90% операций произвольного чтения удовлетворяются из кеша.</p><p>Если вы считаете, что для вашей рабочей нагрузки процент попаданий не достигает 90%, вы можете увеличить параметр random_page_cost, чтобы он больше соответствовал реальной стоимости произвольного чтения. И напротив, если ваши данные могут полностью поместиться в кеше, например, когда размер базы меньше общего объёма памяти сервера, может иметь смысл уменьшить random_page_cost. С хранилищем, у которого стоимость произвольного чтения не намного выше последовательного, как например, у твердотельных накопителей, так же лучше выбрать меньшее значение random_page_cost, например <code class="literal">1.1</code>.</p><div class="tip"><h3 class="title">Подсказка</h3><p>Хотя система позволяет сделать <code class="varname">random_page_cost</code> меньше, чем <code class="varname">seq_page_cost</code>, это лишено физического смысла. Однако сделать их равными имеет смысл, если база данных полностью кешируется в ОЗУ, так как в этом случае с обращением к страницам в произвольном порядке не связаны никакие дополнительные издержки. Кроме того, для сильно загруженной базы данных оба этих параметра следует понизить по отношению к стоимости процессорных операций, так как стоимость выборки страницы, уже находящейся в ОЗУ, оказывается намного меньше, чем обычно.</p></div></dd><dt id="GUC-CPU-TUPLE-COST"><span class="term"><code class="varname">cpu_tuple_cost</code> (<code class="type">floating point</code>) <a id="id-1.6.7.10.3.4.3.1.3" class="indexterm"></a></span> <a href="#GUC-CPU-TUPLE-COST" class="id_link">#</a></dt><dd><p>Задаёт приблизительную стоимость обработки каждой строки при выполнении запроса. Значение по умолчанию — 0.01.</p></dd><dt id="GUC-CPU-INDEX-TUPLE-COST"><span class="term"><code class="varname">cpu_index_tuple_cost</code> (<code class="type">floating point</code>) <a id="id-1.6.7.10.3.4.4.1.3" class="indexterm"></a></span> <a href="#GUC-CPU-INDEX-TUPLE-COST" class="id_link">#</a></dt><dd><p>Задаёт приблизительную стоимость обработки каждой записи индекса при сканировании индекса. Значение по умолчанию — 0.005.</p></dd><dt id="GUC-CPU-OPERATOR-COST"><span class="term"><code class="varname">cpu_operator_cost</code> (<code class="type">floating point</code>) <a id="id-1.6.7.10.3.4.5.1.3" class="indexterm"></a></span> <a href="#GUC-CPU-OPERATOR-COST" class="id_link">#</a></dt><dd><p>Задаёт приблизительную стоимость обработки оператора или функции при выполнении запроса. Значение по умолчанию — 0.0025.</p></dd><dt id="GUC-PARALLEL-SETUP-COST"><span class="term"><code class="varname">parallel_setup_cost</code> (<code class="type">floating point</code>) <a id="id-1.6.7.10.3.4.6.1.3" class="indexterm"></a></span> <a href="#GUC-PARALLEL-SETUP-COST" class="id_link">#</a></dt><dd><p>Задаёт приблизительную стоимость запуска параллельных рабочих процессов. Значение по умолчанию — 1000.</p></dd><dt id="GUC-PARALLEL-TUPLE-COST"><span class="term"><code class="varname">parallel_tuple_cost</code> (<code class="type">floating point</code>) <a id="id-1.6.7.10.3.4.7.1.3" class="indexterm"></a></span> <a href="#GUC-PARALLEL-TUPLE-COST" class="id_link">#</a></dt><dd><p>Задаёт приблизительную стоимость передачи одного кортежа от параллельного рабочего процесса другому процессу. Значение по умолчанию — 0.1.</p></dd><dt id="GUC-MIN-PARALLEL-TABLE-SCAN-SIZE"><span class="term"><code class="varname">min_parallel_table_scan_size</code> (<code class="type">integer</code>) <a id="id-1.6.7.10.3.4.8.1.3" class="indexterm"></a></span> <a href="#GUC-MIN-PARALLEL-TABLE-SCAN-SIZE" class="id_link">#</a></dt><dd><p>Задаёт минимальный объём данных таблицы, подлежащий сканированию, при котором может применяться параллельное сканирование. Для параллельного последовательного сканирования объём сканируемых данных всегда равняется размеру таблицы, но когда используются индексы, этот объём обычно меньше. Если это значение задаётся без единиц измерения, оно считается заданным в блоках (размер которых равен <code class="symbol">BLCKSZ</code> байт, обычно это 8 КБ). Значение по умолчанию — 8 мегабайт (<code class="literal">8MB</code>).</p></dd><dt id="GUC-MIN-PARALLEL-INDEX-SCAN-SIZE"><span class="term"><code class="varname">min_parallel_index_scan_size</code> (<code class="type">integer</code>) <a id="id-1.6.7.10.3.4.9.1.3" class="indexterm"></a></span> <a href="#GUC-MIN-PARALLEL-INDEX-SCAN-SIZE" class="id_link">#</a></dt><dd><p>Задаёт минимальный объём данных индекса, подлежащий сканированию, при котором может применяться параллельное сканирование. Заметьте, что при параллельном сканировании по индексу обычно не затрагивается весь индекс; здесь учитывается число страниц, которое по мнению планировщика будет затронуто при сканировании. Этот параметр также учитывается, когда нужно определить, может ли некоторый индекс обрабатываться при параллельной очистке. См. <a class="xref" href="sql-vacuum.html" title="VACUUM"><span class="refentrytitle">VACUUM</span></a>. Если это значение задаётся без единиц измерения, оно считается заданным в блоках (размер которых равен <code class="symbol">BLCKSZ</code> байт, обычно это 8 КБ). Значение по умолчанию — 512 килобайт (<code class="literal">512kB</code>).</p></dd><dt id="GUC-EFFECTIVE-CACHE-SIZE"><span class="term"><code class="varname">effective_cache_size</code> (<code class="type">integer</code>) <a id="id-1.6.7.10.3.4.10.1.3" class="indexterm"></a></span> <a href="#GUC-EFFECTIVE-CACHE-SIZE" class="id_link">#</a></dt><dd><p>Определяет представление планировщика об эффективном размере дискового кеша, доступном для одного запроса. Это представление влияет на оценку стоимости использования индекса; чем выше это значение, тем больше вероятность, что будет применяться сканирование по индексу, чем ниже, тем более вероятно, что будет выбрано последовательное сканирование. При установке этого параметра следует учитывать и объём разделяемых буферов <span class="productname">PostgreSQL</span>, и процент дискового кеша ядра, который будут занимать файлы данных <span class="productname">PostgreSQL</span>, хотя некоторые данные могут оказаться и там, и там. Кроме того, следует принять во внимание ожидаемое число параллельных запросов к разным таблицам, так как общий размер будет разделяться между ними. Этот параметр не влияет на размер разделяемой памяти, выделяемой <span class="productname">PostgreSQL</span>, и не задаёт размер резервируемого в ядре дискового кеша; он используется только в качестве ориентировочной оценки. При этом система не учитывает, что данные могут оставаться в дисковом кеше от запроса к запросу. Если это значение задаётся без единиц измерения, оно считается заданным в блоках (размер которых равен <code class="symbol">BLCKSZ</code> байт, обычно это 8 КБ). Значение по умолчанию — 4 гигабайта (<code class="literal">4GB</code>). Если <code class="symbol">BLCKSZ</code> отличен от 8 КБ, значение по умолчанию корректируется пропорционально.</p></dd><dt id="GUC-JIT-ABOVE-COST"><span class="term"><code class="varname">jit_above_cost</code> (<code class="type">floating point</code>) <a id="id-1.6.7.10.3.4.11.1.3" class="indexterm"></a></span> <a href="#GUC-JIT-ABOVE-COST" class="id_link">#</a></dt><dd><p>Устанавливает предел стоимости запроса, при превышении которого включается JIT-компиляция, если она поддерживается (см. <a class="xref" href="jit.html" title="Глава 32. JIT-компиляция">Главу 32</a>). Применение <acronym class="acronym">JIT</acronym> занимает время при планировании, но может ускорить выполнение запроса в целом. Значение <code class="literal">-1</code> отключает JIT-компиляцию. Значение по умолчанию — <code class="literal">100000</code>.</p></dd><dt id="GUC-JIT-INLINE-ABOVE-COST"><span class="term"><code class="varname">jit_inline_above_cost</code> (<code class="type">floating point</code>) <a id="id-1.6.7.10.3.4.12.1.3" class="indexterm"></a></span> <a href="#GUC-JIT-INLINE-ABOVE-COST" class="id_link">#</a></dt><dd><p>Устанавливает предел стоимости, при превышении которого будет допускаться встраивание функций и операторов в процессе JIT-компиляции. Встраивание занимает время при планировании, но в целом может ускорить выполнение. Присваивать этому параметру значение, меньшее чем <code class="varname">jit_above_cost</code>, не имеет смысла. Значение <code class="literal">-1</code> отключает встраивание. Значение по умолчанию — <code class="literal">500000</code>.</p></dd><dt id="GUC-JIT-OPTIMIZE-ABOVE-COST"><span class="term"><code class="varname">jit_optimize_above_cost</code> (<code class="type">floating point</code>) <a id="id-1.6.7.10.3.4.13.1.3" class="indexterm"></a></span> <a href="#GUC-JIT-OPTIMIZE-ABOVE-COST" class="id_link">#</a></dt><dd><p>Устанавливает предел стоимости, при превышении которого в JIT-компилированных программах может применяться дорогостоящая оптимизация. Такая оптимизация увеличивает время планирования, но в целом может ускорить выполнение. Присваивать этому параметру значение, меньшее чем <code class="varname">jit_above_cost</code>, не имеет смысла, а при значениях, превышающих <code class="varname">jit_inline_above_cost</code>, положительный эффект маловероятен. Значение <code class="literal">-1</code> отключает дорогостоящие оптимизации. Значение по умолчанию — <code class="literal">500000</code>.</p></dd></dl></div></div><div class="sect2" id="RUNTIME-CONFIG-QUERY-GEQO"><div class="titlepage"><div><div><h3 class="title">20.7.3. Генетический оптимизатор запросов <a href="#RUNTIME-CONFIG-QUERY-GEQO" class="id_link">#</a></h3></div></div></div><p>Генетический оптимизатор запросов (GEnetic Query Optimizer, GEQO) осуществляет планирование запросов, применяя эвристический поиск. Это позволяет сократить время планирования для сложных запросов (в которых соединяются множество отношений), ценой того, что иногда полученные планы уступают по качеству планам, выбираемым при полном переборе. За дополнительными сведениями обратитесь к <a class="xref" href="geqo.html" title="Глава 62. Генетический оптимизатор запросов">Главе 62</a>.</p><div class="variablelist"><dl class="variablelist"><dt id="GUC-GEQO"><span class="term"><code class="varname">geqo</code> (<code class="type">boolean</code>) <a id="id-1.6.7.10.4.3.1.1.3" class="indexterm"></a> <a id="id-1.6.7.10.4.3.1.1.4" class="indexterm"></a> <a id="id-1.6.7.10.4.3.1.1.5" class="indexterm"></a></span> <a href="#GUC-GEQO" class="id_link">#</a></dt><dd><p>Включает или отключает генетическую оптимизацию запросов. По умолчанию она включена. В производственной среде её лучше не отключать; более гибко управлять GEQO можно с помощью переменной <code class="varname">geqo_threshold</code>.</p></dd><dt id="GUC-GEQO-THRESHOLD"><span class="term"><code class="varname">geqo_threshold</code> (<code class="type">integer</code>) <a id="id-1.6.7.10.4.3.2.1.3" class="indexterm"></a></span> <a href="#GUC-GEQO-THRESHOLD" class="id_link">#</a></dt><dd><p>Задаёт минимальное число элементов во <code class="literal">FROM</code>, при котором для планирования запроса будет привлечён генетический оптимизатор. (Заметьте, что конструкция <code class="literal">FULL OUTER JOIN</code> считается одним элементом списка <code class="literal">FROM</code>.) Значение по умолчанию — 12. Для более простых запросов часто лучше использовать обычный планировщик, производящий полный перебор, но для запросов со множеством таблиц полный перебор займёт слишком много времени, чаще гораздо больше, чем будет потеряно из-за выбора не самого эффективного плана. Таким образом, ограничение по размеру запроса даёт удобную возможность управлять GEQO.</p></dd><dt id="GUC-GEQO-EFFORT"><span class="term"><code class="varname">geqo_effort</code> (<code class="type">integer</code>) <a id="id-1.6.7.10.4.3.3.1.3" class="indexterm"></a></span> <a href="#GUC-GEQO-EFFORT" class="id_link">#</a></dt><dd><p>Управляет выбором между сокращением временем планирования и повышением качества плана запроса в GEQO. Это значение должна задаваться целым числом от 1 до 10. Значение по умолчанию равно пяти. Чем больше значение этого параметра, тем больше времени будет потрачено на планирование запроса, но и тем больше вероятность, что будет выбран эффективный план.</p><p>Параметр <code class="varname">geqo_effort</code> сам по себе ничего не делает, он используется только для вычисления значений по умолчанию для других переменных, влияющих на поведение GEQO (они описаны ниже). При желании эти переменные можно просто установить вручную.</p></dd><dt id="GUC-GEQO-POOL-SIZE"><span class="term"><code class="varname">geqo_pool_size</code> (<code class="type">integer</code>) <a id="id-1.6.7.10.4.3.4.1.3" class="indexterm"></a></span> <a href="#GUC-GEQO-POOL-SIZE" class="id_link">#</a></dt><dd><p>Задаёт размер пула для алгоритма GEQO, то есть число особей в генетической популяции. Это число должно быть не меньше двух, но полезные значения обычно лежат в интервале от 100 до 1000. Если оно равно нулю (это значение по умолчанию), то подходящее число выбирается, исходя из значения <code class="varname">geqo_effort</code> и числа таблиц в запросе.</p></dd><dt id="GUC-GEQO-GENERATIONS"><span class="term"><code class="varname">geqo_generations</code> (<code class="type">integer</code>) <a id="id-1.6.7.10.4.3.5.1.3" class="indexterm"></a></span> <a href="#GUC-GEQO-GENERATIONS" class="id_link">#</a></dt><dd><p>Задаёт число поколений для GEQO, то есть число итераций этого алгоритма. Оно должно быть не меньше единицы, но полезные значения находятся в том же диапазоне, что и размер пула. Если оно равно нулю (это значение по умолчанию), то подходящее число выбирается, исходя из <code class="varname">geqo_pool_size</code>.</p></dd><dt id="GUC-GEQO-SELECTION-BIAS"><span class="term"><code class="varname">geqo_selection_bias</code> (<code class="type">floating point</code>) <a id="id-1.6.7.10.4.3.6.1.3" class="indexterm"></a></span> <a href="#GUC-GEQO-SELECTION-BIAS" class="id_link">#</a></dt><dd><p>Задаёт интенсивность селекции для GEQO, то есть селективное давление в популяции. Допустимые значения лежат в диапазоне от 1.50 до 2.00 (это значение по умолчанию).</p></dd><dt id="GUC-GEQO-SEED"><span class="term"><code class="varname">geqo_seed</code> (<code class="type">floating point</code>) <a id="id-1.6.7.10.4.3.7.1.3" class="indexterm"></a></span> <a href="#GUC-GEQO-SEED" class="id_link">#</a></dt><dd><p>Задаёт начальное значение для генератора случайных чисел, который применяется в GEQO для выбора случайных путей в пространстве поиска порядка соединений. Может иметь значение от нуля (по умолчанию) до одного. При изменении этого значения меняется набор анализируемых путей, в результате чего может быть найден как более, так и менее оптимальный путь.</p></dd></dl></div></div><div class="sect2" id="RUNTIME-CONFIG-QUERY-OTHER"><div class="titlepage"><div><div><h3 class="title">20.7.4. Другие параметры планировщика <a href="#RUNTIME-CONFIG-QUERY-OTHER" class="id_link">#</a></h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt id="GUC-DEFAULT-STATISTICS-TARGET"><span class="term"><code class="varname">default_statistics_target</code> (<code class="type">integer</code>) <a id="id-1.6.7.10.5.2.1.1.3" class="indexterm"></a></span> <a href="#GUC-DEFAULT-STATISTICS-TARGET" class="id_link">#</a></dt><dd><p>Устанавливает значение ориентира статистики по умолчанию, распространяющееся на столбцы, для которых командой <code class="command">ALTER TABLE SET STATISTICS</code> не заданы отдельные ограничения. Чем больше установленное значение, тем больше времени требуется для выполнения <code class="command">ANALYZE</code>, но тем выше может быть качество оценок планировщика. Значение этого параметра по умолчанию — 100. За дополнительными сведениями об использовании статистики планировщиком запросов <span class="productname">PostgreSQL</span> обратитесь к <a class="xref" href="planner-stats.html" title="14.2. Статистика, используемая планировщиком">Разделу 14.2</a>.</p></dd><dt id="GUC-CONSTRAINT-EXCLUSION"><span class="term"><code class="varname">constraint_exclusion</code> (<code class="type">enum</code>) <a id="id-1.6.7.10.5.2.2.1.3" class="indexterm"></a> <a id="id-1.6.7.10.5.2.2.1.4" class="indexterm"></a></span> <a href="#GUC-CONSTRAINT-EXCLUSION" class="id_link">#</a></dt><dd><p>Управляет использованием планировщиком ограничений таблицы для оптимизации запросов. Допустимые значения <code class="varname">constraint_exclusion</code>: <code class="literal">on</code> (задействовать ограничения всех таблиц), <code class="literal">off</code> (никогда не задействовать ограничения) и <code class="literal">partition</code> (задействовать ограничения только для дочерних таблиц и подзапросов <code class="literal">UNION ALL</code>). Значение по умолчанию — <code class="literal">partition</code>. Оно часто помогает увеличить производительность, когда применяются традиционные деревья наследования.</p><p>Когда данный параметр разрешает это для таблицы, планировщик сравнивает условия запроса с ограничениями <code class="literal">CHECK</code> данной таблицы и не сканирует её, если они оказываются несовместимыми. Например: </p><pre class="programlisting">CREATE TABLE parent(key integer, ...);
CREATE TABLE child1000(check (key between 1000 and 1999)) INHERITS(parent);
CREATE TABLE child2000(check (key between 2000 and 2999)) INHERITS(parent);
...
SELECT * FROM parent WHERE key = 2400;</pre><p> Если включено исключение по ограничению, команда <code class="command">SELECT</code> не будет сканировать таблицу <code class="structname">child1000</code>, в результате чего запрос выполнится быстрее.</p><p>В настоящее время исключение по ограничению разрешено по умолчанию только в условиях, возникающих при реализации секционирования через деревья наследования. Включение этой возможности для всех таблиц влечёт дополнительные издержки на планирование, довольно заметные для простых запросов, но может не дать никакого выигрыша. Если вы не применяете секционирование через деревья наследования, имеет смысл её полностью отключить. (Заметьте, что похожая функциональность для секционированных таблиц управляется отдельным параметром, <a class="xref" href="runtime-config-query.html#GUC-ENABLE-PARTITION-PRUNING">enable_partition_pruning</a>.)</p><p>За дополнительными сведениями о применении исключений по ограничению для секционирования таблиц обратитесь к <a class="xref" href="ddl-partitioning.html#DDL-PARTITIONING-CONSTRAINT-EXCLUSION" title="5.11.5. Секционирование и исключение по ограничению">Подразделу 5.11.5</a>.</p></dd><dt id="GUC-CURSOR-TUPLE-FRACTION"><span class="term"><code class="varname">cursor_tuple_fraction</code> (<code class="type">floating point</code>) <a id="id-1.6.7.10.5.2.3.1.3" class="indexterm"></a></span> <a href="#GUC-CURSOR-TUPLE-FRACTION" class="id_link">#</a></dt><dd><p>Задаёт для планировщика оценку процента строк, которые будут получены через курсор. Значение по умолчанию — 0.1 (10%). При меньших значениях планировщик будет склонен использовать для курсоров планы с <span class="quote">«<span class="quote">быстрым стартом</span>»</span>, позволяющие получать первые несколько строк очень быстро, хотя для выборки всех строк может уйти больше времени. При больших значениях планировщик стремится оптимизировать общее время запроса. При максимальном значении, равном 1.0, работа с курсорами планируется так же, как и обычные запросы — минимизируется только общее время, а не время получения первых строк.</p></dd><dt id="GUC-FROM-COLLAPSE-LIMIT"><span class="term"><code class="varname">from_collapse_limit</code> (<code class="type">integer</code>) <a id="id-1.6.7.10.5.2.4.1.3" class="indexterm"></a></span> <a href="#GUC-FROM-COLLAPSE-LIMIT" class="id_link">#</a></dt><dd><p>Задаёт максимальное число элементов в списке <code class="literal">FROM</code>, до которого планировщик будет объединять вложенные запросы с внешним запросом. При меньших значениях сокращается время планирования, но план запроса может стать менее эффективным. По умолчанию это значение равно восьми. За дополнительными сведениями обратитесь к <a class="xref" href="explicit-joins.html" title="14.3. Управление планировщиком с помощью явных предложений JOIN">Разделу 14.3</a>.</p><p>Если это значение сделать равным <a class="xref" href="runtime-config-query.html#GUC-GEQO-THRESHOLD">geqo_threshold</a> или больше, при таком объединении запросов может включиться планировщик GEQO и в результате будет получен неоптимальный план. См. <a class="xref" href="runtime-config-query.html#RUNTIME-CONFIG-QUERY-GEQO" title="20.7.3. Генетический оптимизатор запросов">Подраздел 20.7.3</a>.</p></dd><dt id="GUC-JIT"><span class="term"><code class="varname">jit</code> (<code class="type">boolean</code>) <a id="id-1.6.7.10.5.2.5.1.3" class="indexterm"></a></span> <a href="#GUC-JIT" class="id_link">#</a></dt><dd><p>Определяет, может ли <span class="productname">PostgreSQL</span> использовать компиляцию <acronym class="acronym">JIT</acronym>, если она поддерживается (см. <a class="xref" href="jit.html" title="Глава 32. JIT-компиляция">Главу 32</a>). По умолчанию он включён (<code class="literal">on</code>).</p></dd><dt id="GUC-JOIN-COLLAPSE-LIMIT"><span class="term"><code class="varname">join_collapse_limit</code> (<code class="type">integer</code>) <a id="id-1.6.7.10.5.2.6.1.3" class="indexterm"></a></span> <a href="#GUC-JOIN-COLLAPSE-LIMIT" class="id_link">#</a></dt><dd><p>Задаёт максимальное количество элементов в списке <code class="literal">FROM</code>, до достижения которого планировщик будет сносить в него явные конструкции <code class="literal">JOIN</code> (за исключением <code class="literal">FULL JOIN</code>). При меньших значениях сокращается время планирования, но план запроса может стать менее эффективным.</p><p>По умолчанию эта переменная имеет то же значение, что и <code class="varname">from_collapse_limit</code>, и это приемлемо в большинстве случаев. При значении, равном 1, предложения <code class="literal">JOIN</code> переставляться не будут, так что явно заданный в запросе порядок соединений определит фактический порядок, в котором будут соединяться отношения. Так как планировщик не всегда выбирает оптимальный порядок соединений, опытные пользователи могут временно задать для этой переменной значение 1, а затем явно определить желаемый порядок. За дополнительными сведениями обратитесь к <a class="xref" href="explicit-joins.html" title="14.3. Управление планировщиком с помощью явных предложений JOIN">Разделу 14.3</a>.</p><p>Если это значение сделать равным <a class="xref" href="runtime-config-query.html#GUC-GEQO-THRESHOLD">geqo_threshold</a> или больше, при таком объединении запросов может включиться планировщик GEQO и в результате будет получен неоптимальный план. См. <a class="xref" href="runtime-config-query.html#RUNTIME-CONFIG-QUERY-GEQO" title="20.7.3. Генетический оптимизатор запросов">Подраздел 20.7.3</a>.</p></dd><dt id="GUC-PLAN-CACHE-MODE"><span class="term"><code class="varname">plan_cache_mode</code> (<code class="type">enum</code>) <a id="id-1.6.7.10.5.2.7.1.3" class="indexterm"></a></span> <a href="#GUC-PLAN-CACHE-MODE" class="id_link">#</a></dt><dd><p>Подготовленные операторы (они могут быть подготовлены явно либо неявно, как например в PL/pgSQL) могут выполняться с использованием специализированных или общих планов. Специализированные планы строятся заново для каждого выполнения с конкретным набором значений параметров, тогда как общий план не зависит от значений параметров и может использоваться многократно. Таким образом, общий план позволяет сэкономить время планирования, но он может быть неэффективным, если идеальные планы в большой степени определяются значениями параметров. Выбор между этими вариантами обычно производится автоматически, но его можно переопределить, воспользовавшись параметром <code class="varname">plan_cache_mode</code>. Он может принимать значение <code class="literal">auto</code> (по умолчанию), <code class="literal">force_custom_plan</code> (принудительно использовать специализированные планы) и <code class="literal">force_generic_plan</code> (принудительно использовать общие планы). Значение этого параметра учитывается при выполнении плана, а не при построении. За дополнительными сведениями обратитесь к <a class="xref" href="sql-prepare.html" title="PREPARE"><span class="refentrytitle">PREPARE</span></a>.</p></dd><dt id="GUC-RECURSIVE-WORKTABLE-FACTOR"><span class="term"><code class="varname">recursive_worktable_factor</code> (<code class="type">floating point</code>) <a id="id-1.6.7.10.5.2.8.1.3" class="indexterm"></a></span> <a href="#GUC-RECURSIVE-WORKTABLE-FACTOR" class="id_link">#</a></dt><dd><p>Задаёт оценку планировщиком среднего размера рабочей таблицы <a class="link" href="queries-with.html#QUERIES-WITH-RECURSIVE" title="7.8.2. Рекурсивные запросы">рекурсивного запроса</a> как множитель ожидаемого размера начальной нерекурсивной части запроса. Это помогает планировщику выбрать наиболее подходящий метод для соединения этой рабочей таблицы с другими таблицами запроса. Значение по умолчанию — <code class="literal">10.0</code>. Меньшее значение, например <code class="literal">1.0</code>, может оказаться эффективнее, когда рекурсия слабо <span class="quote">«<span class="quote">разветвляется</span>»</span> от одного шага к другому, как, например, в запросах кратчайшего пути. При аналитической обработке графов оптимальные значения могут быть больше, чем значение по умолчанию.</p></dd></dl></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="runtime-config-replication.html" title="20.6. Репликация">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="runtime-config.html" title="Глава 20. Настройка сервера">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="runtime-config-logging.html" title="20.8. Регистрация ошибок и протоколирование работы сервера">След.</a></td></tr><tr><td width="40%" align="left" valign="top">20.6. Репликация </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 20.8. Регистрация ошибок и протоколирование работы сервера</td></tr></table></div></body></html>