<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>7.2. Табличные выражения</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="queries-overview.html" title="7.1. Обзор" /><link rel="next" href="queries-select-lists.html" title="7.3. Списки выборки" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">7.2. Табличные выражения</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="queries-overview.html" title="7.1. Обзор">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="queries.html" title="Глава 7. Запросы">Наверх</a></td><th width="60%" align="center">Глава 7. Запросы</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="queries-select-lists.html" title="7.3. Списки выборки">След.</a></td></tr></table><hr /></div><div class="sect1" id="QUERIES-TABLE-EXPRESSIONS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">7.2. Табличные выражения <a href="#QUERIES-TABLE-EXPRESSIONS" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="queries-table-expressions.html#QUERIES-FROM">7.2.1. Предложение <code class="literal">FROM</code></a></span></dt><dt><span class="sect2"><a href="queries-table-expressions.html#QUERIES-WHERE">7.2.2. Предложение <code class="literal">WHERE</code></a></span></dt><dt><span class="sect2"><a href="queries-table-expressions.html#QUERIES-GROUP">7.2.3. Предложения <code class="literal">GROUP BY</code> и <code class="literal">HAVING</code></a></span></dt><dt><span class="sect2"><a href="queries-table-expressions.html#QUERIES-GROUPING-SETS">7.2.4. <code class="literal">GROUPING SETS</code>, <code class="literal">CUBE</code> и <code class="literal">ROLLUP</code></a></span></dt><dt><span class="sect2"><a href="queries-table-expressions.html#QUERIES-WINDOW">7.2.5. Обработка оконных функций</a></span></dt></dl></div><a id="id-1.5.6.6.2" class="indexterm"></a><p><em class="firstterm">Табличное выражение</em> вычисляет таблицу. Это выражение содержит предложение <code class="literal">FROM</code>, за которым могут следовать предложения <code class="literal">WHERE</code>, <code class="literal">GROUP BY</code> и <code class="literal">HAVING</code>. Тривиальные табличные выражения просто ссылаются на физическую таблицу, её называют также базовой, но в более сложных выражениях такие таблицы можно преобразовывать и комбинировать самыми разными способами.</p><p>Необязательные предложения <code class="literal">WHERE</code>, <code class="literal">GROUP BY</code> и <code class="literal">HAVING</code> в табличном выражении определяют последовательность преобразований, осуществляемых с данными таблицы, полученной в предложении <code class="literal">FROM</code>. В результате этих преобразований образуется виртуальная таблица, строки которой передаются списку выборки, вычисляющему выходные строки запроса.</p><div class="sect2" id="QUERIES-FROM"><div class="titlepage"><div><div><h3 class="title">7.2.1. Предложение <code class="literal">FROM</code> <a href="#QUERIES-FROM" class="id_link">#</a></h3></div></div></div><p>Предложение <a class="link" href="sql-select.html#SQL-FROM" title="Предложение FROM"><code class="literal">FROM</code></a> образует таблицу из одной или нескольких ссылок на таблицы, разделённых запятыми. </p><pre class="synopsis">
FROM <em class="replaceable"><code>табличная_ссылка</code></em> [<span class="optional">, <em class="replaceable"><code>табличная_ссылка</code></em> [<span class="optional">, ...</span>]</span>]
</pre><p> Здесь табличной ссылкой может быть имя таблицы (возможно, с именем схемы), производная таблица, например подзапрос, соединение таблиц или сложная комбинация этих вариантов. Если в предложении <code class="literal">FROM</code> перечисляются несколько ссылок, для них применяется перекрёстное соединение (то есть декартово произведение их строк; см. ниже). Список <code class="literal">FROM</code> преобразуется в промежуточную виртуальную таблицу, которая может пройти через преобразования <code class="literal">WHERE</code>, <code class="literal">GROUP BY</code> и <code class="literal">HAVING</code>, и в итоге определит результат табличного выражения.</p><a id="id-1.5.6.6.5.3" class="indexterm"></a><p>Когда в табличной ссылке указывается таблица, являющаяся родительской в иерархии наследования, в результате будут получены строки не только этой таблицы, но и всех её дочерних таблиц. Чтобы выбрать строки только одной родительской таблицы, перед её именем нужно добавить ключевое слово <code class="literal">ONLY</code>. Учтите, что при этом будут получены только столбцы указанной таблицы — дополнительные столбцы дочерних таблиц не попадут в результат.</p><p>Если же вы не добавляете <code class="literal">ONLY</code> перед именем таблицы, вы можете дописать после него <code class="literal">*</code>, тем самым указав, что должны обрабатываться и все дочерние таблицы. Практических причин использовать этот синтаксис больше нет, так как поиск в дочерних таблицах теперь производится по умолчанию. Однако эта запись поддерживается для совместимости со старыми версиями.</p><div class="sect3" id="QUERIES-JOIN"><div class="titlepage"><div><div><h4 class="title">7.2.1.1. Соединённые таблицы <a href="#QUERIES-JOIN" class="id_link">#</a></h4></div></div></div><a id="id-1.5.6.6.5.6.2" class="indexterm"></a><p>Соединённая таблица ­­­­­­— это таблица, полученная из двух других (реальных или производных от них) таблиц в соответствии с правилами соединения конкретного типа. Общий синтаксис описания соединённой таблицы: </p><pre class="synopsis">
<em class="replaceable"><code>T1</code></em> <em class="replaceable"><code>тип_соединения</code></em> <em class="replaceable"><code>T2</code></em> [<span class="optional"> <em class="replaceable"><code>условие_соединения</code></em> </span>]
</pre><p>Соединения любых типов могут вкладываются друг в друга или объединяться: и <em class="replaceable"><code>T1</code></em>, и <em class="replaceable"><code>T2</code></em> могут быть результатами соединения. Для однозначного определения порядка соединений предложения <code class="literal">JOIN</code> можно заключать в скобки. Если скобки отсутствуют, предложения <code class="literal">JOIN</code> обрабатываются слева направо.</p><div class="variablelist"><p class="title"><strong>Типы соединений</strong></p><dl class="variablelist"><dt><span class="term">Перекрёстное соединение <a id="id-1.5.6.6.5.6.4.2.1.1" class="indexterm"></a> <a id="id-1.5.6.6.5.6.4.2.1.2" class="indexterm"></a></span></dt><dd><pre class="synopsis"><em class="replaceable"><code>T1</code></em> CROSS JOIN <em class="replaceable"><code>T2</code></em></pre><p>Соединённую таблицу образуют все возможные сочетания строк из <em class="replaceable"><code>T1</code></em> и <em class="replaceable"><code>T2</code></em> (т. е. их декартово произведение), а набор её столбцов объединяет в себе столбцы <em class="replaceable"><code>T1</code></em> со следующими за ними столбцами <em class="replaceable"><code>T2</code></em>. Если таблицы содержат N и M строк, соединённая таблица будет содержать N * M строк.</p><p><code class="literal">FROM <em class="replaceable"><code>T1</code></em> CROSS JOIN <em class="replaceable"><code>T2</code></em></code> равнозначно <code class="literal">FROM <em class="replaceable"><code>T1</code></em> INNER JOIN <em class="replaceable"><code>T2</code></em> ON TRUE</code> (см. ниже). Эта запись также равнозначна <code class="literal">FROM <em class="replaceable"><code>T1</code></em>, <em class="replaceable"><code>T2</code></em></code>. </p><div class="note"><h3 class="title">Примечание</h3><p>Последняя запись не полностью эквивалентна первым при указании более чем двух таблиц, так как <code class="literal">JOIN</code> связывает таблицы сильнее, чем запятая. Например, <code class="literal">FROM <em class="replaceable"><code>T1</code></em> CROSS JOIN <em class="replaceable"><code>T2</code></em> INNER JOIN <em class="replaceable"><code>T3</code></em> ON <em class="replaceable"><code>условие</code></em></code> не равнозначно <code class="literal">FROM <em class="replaceable"><code>T1</code></em>, <em class="replaceable"><code>T2</code></em> INNER JOIN <em class="replaceable"><code>T3</code></em> ON <em class="replaceable"><code>условие</code></em></code>, так как <em class="replaceable"><code>условие</code></em> может ссылаться на <em class="replaceable"><code>T1</code></em> в первом случае, но не во втором.</p></div></dd><dt><span class="term">Соединения с сопоставлениями строк <a id="id-1.5.6.6.5.6.4.3.1.1" class="indexterm"></a> <a id="id-1.5.6.6.5.6.4.3.1.2" class="indexterm"></a></span></dt><dd><pre class="synopsis"><em class="replaceable"><code>T1</code></em> { [<span class="optional">INNER</span>] | { LEFT | RIGHT | FULL } [<span class="optional">OUTER</span>] } JOIN <em class="replaceable"><code>T2</code></em>
  ON <em class="replaceable"><code>логическое_выражение</code></em>
<em class="replaceable"><code>T1</code></em> { [<span class="optional">INNER</span>] | { LEFT | RIGHT | FULL } [<span class="optional">OUTER</span>] } JOIN <em class="replaceable"><code>T2</code></em>
  USING ( <em class="replaceable"><code>список столбцов соединения</code></em> )
<em class="replaceable"><code>T1</code></em> NATURAL { [<span class="optional">INNER</span>] | { LEFT | RIGHT | FULL } [<span class="optional">OUTER</span>] } JOIN <em class="replaceable"><code>T2</code></em></pre><p>Слова <code class="literal">INNER</code> и <code class="literal">OUTER</code> необязательны во всех формах. По умолчанию подразумевается <code class="literal">INNER</code> (внутреннее соединение), а при указании <code class="literal">LEFT</code>, <code class="literal">RIGHT</code> и <code class="literal">FULL</code> — внешнее соединение.</p><p><em class="firstterm">Условие соединения</em> указывается в предложении <code class="literal">ON</code> или <code class="literal">USING</code>, либо неявно задаётся ключевым словом <code class="literal">NATURAL</code>. Это условие определяет, какие строки двух исходных таблиц считаются <span class="quote">«<span class="quote">соответствующими</span>»</span> друг другу (это подробно рассматривается ниже).</p><p>Возможные типы соединений с сопоставлениями строк: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">INNER JOIN</code></span></dt><dd><p>Для каждой строки R1 из T1 в результирующей таблице содержится строка для каждой строки в T2, удовлетворяющей условию соединения с R1.</p></dd><dt><span class="term"><code class="literal">LEFT OUTER JOIN</code>
         <a id="id-1.5.6.6.5.6.4.3.2.4.1.2.1.2" class="indexterm"></a>

         <a id="id-1.5.6.6.5.6.4.3.2.4.1.2.1.3" class="indexterm"></a>
         </span></dt><dd><p>Сначала выполняется внутреннее соединение (INNER JOIN). Затем в результат добавляются все строки из T1, которым не соответствуют никакие строки в T2, а вместо значений столбцов T2 вставляются NULL. Таким образом, в результирующей таблице всегда будет минимум одна строка для каждой строки из T1.</p></dd><dt><span class="term"><code class="literal">RIGHT OUTER JOIN</code>
         <a id="id-1.5.6.6.5.6.4.3.2.4.1.3.1.2" class="indexterm"></a>

         <a id="id-1.5.6.6.5.6.4.3.2.4.1.3.1.3" class="indexterm"></a>
         </span></dt><dd><p>Сначала выполняется внутреннее соединение (INNER JOIN). Затем в результат добавляются все строки из T2, которым не соответствуют никакие строки в T1, а вместо значений столбцов T1 вставляются NULL. Это соединение является обратным к левому (LEFT JOIN): в результирующей таблице всегда будет минимум одна строка для каждой строки из T2.</p></dd><dt><span class="term"><code class="literal">FULL OUTER JOIN</code></span></dt><dd><p>Сначала выполняется внутреннее соединение. Затем в результат добавляются все строки из T1, которым не соответствуют никакие строки в T2, а вместо значений столбцов T2 вставляются NULL. И наконец, в результат включаются все строки из T2, которым не соответствуют никакие строки в T1, а вместо значений столбцов T1 вставляются NULL.</p></dd></dl></div><p>Предложение <code class="literal">ON</code> определяет наиболее общую форму условия соединения: в нём указываются выражения логического типа, подобные тем, что используются в предложении <code class="literal">WHERE</code>. Пара строк из <em class="replaceable"><code>T1</code></em> и <em class="replaceable"><code>T2</code></em> соответствуют друг другу, если выражение <code class="literal">ON</code> возвращает для них true.</p><p><code class="literal">USING</code> — это сокращённая запись условия, полезная в ситуации, когда с обеих сторон соединения столбцы имеют одинаковые имена. Она принимает список общих имён столбцов через запятую и формирует условие соединения с равенством этих столбцов. Например, запись соединения <em class="replaceable"><code>T1</code></em> и <em class="replaceable"><code>T2</code></em> с <code class="literal">USING (a, b)</code> формирует условие <code class="literal">ON <em class="replaceable"><code>T1</code></em>.a = <em class="replaceable"><code>T2</code></em>.a AND <em class="replaceable"><code>T1</code></em>.b = <em class="replaceable"><code>T2</code></em>.b</code>.</p><p>Более того, при выводе <code class="literal">JOIN USING</code> исключаются избыточные столбцы: оба сопоставленных столбца выводить не нужно, так как они содержат одинаковые значения. Тогда как <code class="literal">JOIN ON</code> выдаёт все столбцы из <em class="replaceable"><code>T1</code></em>, а за ними все столбцы из <em class="replaceable"><code>T2</code></em>, <code class="literal">JOIN USING</code> выводит один столбец для каждой пары (в указанном порядке), за ними все оставшиеся столбцы из <em class="replaceable"><code>T1</code></em> и, наконец, все оставшиеся столбцы <em class="replaceable"><code>T2</code></em>.</p><p><a id="id-1.5.6.6.5.6.4.3.2.8.1" class="indexterm"></a> <a id="id-1.5.6.6.5.6.4.3.2.8.2" class="indexterm"></a> Наконец, <code class="literal">NATURAL</code> — сокращённая форма <code class="literal">USING</code>: она образует список <code class="literal">USING</code> из всех имён столбцов, существующих в обеих входных таблицах. Как и с <code class="literal">USING</code>, эти столбцы оказываются в выходной таблице в единственном экземпляре. Если столбцов с одинаковыми именами не находится, <code class="literal">NATURAL JOIN</code> действует как <code class="literal">JOIN ... ON TRUE</code> и выдаёт декартово произведение строк.</p><div class="note"><h3 class="title">Примечание</h3><p>Предложение <code class="literal">USING</code> разумно защищено от изменений в соединяемых отношениях, так как оно связывает только явно перечисленные столбцы. <code class="literal">NATURAL</code> считается более рискованным, так как при любом изменении схемы в одном или другом отношении, когда появляются столбцы с совпадающими именами, при соединении будут связываться и эти новые столбцы.</p></div></dd></dl></div><p>Для наглядности предположим, что у нас есть таблицы <code class="literal">t1</code>: </p><pre class="programlisting"> num | name
-----+------
   1 | a
   2 | b
   3 | c</pre><p> и <code class="literal">t2</code>: </p><pre class="programlisting"> num | value
-----+-------
   1 | xxx
   3 | yyy
   5 | zzz</pre><p> С ними для разных типов соединений мы получим следующие результаты: </p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM t1 CROSS JOIN t2;</code></strong>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   1 | a    |   3 | yyy
   1 | a    |   5 | zzz
   2 | b    |   1 | xxx
   2 | b    |   3 | yyy
   2 | b    |   5 | zzz
   3 | c    |   1 | xxx
   3 | c    |   3 | yyy
   3 | c    |   5 | zzz
(9 rows)

<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM t1 INNER JOIN t2 ON t1.num = t2.num;</code></strong>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   3 | c    |   3 | yyy
(2 rows)

<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM t1 INNER JOIN t2 USING (num);</code></strong>
 num | name | value
-----+------+-------
   1 | a    | xxx
   3 | c    | yyy
(2 rows)

<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM t1 NATURAL INNER JOIN t2;</code></strong>
 num | name | value
-----+------+-------
   1 | a    | xxx
   3 | c    | yyy
(2 rows)

<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num;</code></strong>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |   3 | yyy
(3 rows)

<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM t1 LEFT JOIN t2 USING (num);</code></strong>
 num | name | value
-----+------+-------
   1 | a    | xxx
   2 | b    |
   3 | c    | yyy
(3 rows)

<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM t1 RIGHT JOIN t2 ON t1.num = t2.num;</code></strong>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   3 | c    |   3 | yyy
     |      |   5 | zzz
(3 rows)

<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM t1 FULL JOIN t2 ON t1.num = t2.num;</code></strong>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |   3 | yyy
     |      |   5 | zzz
(4 rows)
</pre><p>Условие соединения в предложении <code class="literal">ON</code> может также содержать выражения, не связанные непосредственно с соединением. Это может быть полезно в некоторых запросах, но не следует использовать это необдуманно. Рассмотрите следующий запрос: </p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num AND t2.value = 'xxx';</code></strong>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |     |
(3 rows)
</pre><p> Заметьте, что если поместить ограничение в предложение <code class="literal">WHERE</code>, вы получите другой результат: </p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num WHERE t2.value = 'xxx';</code></strong>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
(1 row)
</pre><p> Это связано с тем, что ограничение, помещённое в предложение <code class="literal">ON</code>, обрабатывается <span class="emphasis"><em>до</em></span> операции соединения, тогда как ограничение в <code class="literal">WHERE</code> — <span class="emphasis"><em>после</em></span>. Это не имеет значения при внутренних соединениях, но важно при внешних.</p></div><div class="sect3" id="QUERIES-TABLE-ALIASES"><div class="titlepage"><div><div><h4 class="title">7.2.1.2. Псевдонимы таблиц и столбцов <a href="#QUERIES-TABLE-ALIASES" class="id_link">#</a></h4></div></div></div><a id="id-1.5.6.6.5.7.2" class="indexterm"></a><a id="id-1.5.6.6.5.7.3" class="indexterm"></a><p>Таблицам и ссылкам на сложные таблицы в запросе можно дать временное имя, по которому к ним можно будет обращаться в рамках запроса. Такое имя называется <em class="firstterm">псевдонимом таблицы</em>.</p><p>Определить псевдоним таблицы можно, написав </p><pre class="synopsis">
FROM <em class="replaceable"><code>табличная_ссылка</code></em> AS <em class="replaceable"><code>псевдоним</code></em>
</pre><p> или </p><pre class="synopsis">
FROM <em class="replaceable"><code>табличная_ссылка</code></em> <em class="replaceable"><code>псевдоним</code></em>
</pre><p> Ключевое слово <code class="literal">AS</code> является необязательным. Вместо <em class="replaceable"><code>псевдоним</code></em> здесь может быть любой идентификатор.</p><p>Псевдонимы часто применяются для назначения коротких идентификаторов длинным именам таблиц с целью улучшения читаемости запросов. Например: </p><pre class="programlisting">SELECT * FROM "очень_длинное_имя_таблицы" s JOIN "другое_длинное_имя" a
  ON s.id = a.num;</pre><p>Псевдоним становится новым именем таблицы в рамках текущего запроса, т. е. после назначения псевдонима использовать исходное имя таблицы в другом месте запроса нельзя. Таким образом, следующий запрос недопустим: </p><pre class="programlisting">SELECT * FROM my_table AS m WHERE my_table.a &gt; 5;    -- неправильно</pre><p>Хотя в основном псевдонимы используются для удобства, они бывают необходимы, когда таблица соединяется сама с собой, например: </p><pre class="programlisting">SELECT * FROM people AS mother JOIN people AS child
  ON mother.id = child.mother_id;</pre><p>В случае неоднозначности определения псевдонимов можно использовать скобки. В следующем примере первый оператор назначает псевдоним <code class="literal">b</code> второму экземпляру <code class="literal">my_table</code>, а второй оператор назначает псевдоним результату соединения: </p><pre class="programlisting">SELECT * FROM my_table AS a CROSS JOIN my_table AS b ...
SELECT * FROM (my_table AS a CROSS JOIN my_table) AS b ...</pre><p>В другой форме назначения псевдонима временные имена даются не только таблицам, но и её столбцам: </p><pre class="synopsis">
FROM <em class="replaceable"><code>табличная_ссылка</code></em> [<span class="optional">AS</span>] <em class="replaceable"><code>псевдоним</code></em> ( <em class="replaceable"><code>столбец1</code></em> [<span class="optional">, <em class="replaceable"><code>столбец2</code></em> [<span class="optional">, ...</span>]</span>] )
</pre><p> Если псевдонимов столбцов оказывается меньше, чем фактически столбцов в таблице, остальные столбцы сохраняют свои исходные имена. Эта запись особенно полезна для замкнутых соединений или подзапросов.</p><p>Когда псевдоним применяется к результату <code class="literal">JOIN</code>, он скрывает оригинальные имена таблиц внутри <code class="literal">JOIN</code>. Например, это допустимый SQL-запрос: </p><pre class="programlisting">SELECT a.* FROM my_table AS a JOIN your_table AS b ON ...</pre><p>а запрос: </p><pre class="programlisting">SELECT a.* FROM (my_table AS a JOIN your_table AS b ON ...) AS c</pre><p> ошибочный, так как псевдоним таблицы <code class="literal">a</code> не виден снаружи определения псевдонима <code class="literal">c</code>.</p></div><div class="sect3" id="QUERIES-SUBQUERIES"><div class="titlepage"><div><div><h4 class="title">7.2.1.3. Подзапросы <a href="#QUERIES-SUBQUERIES" class="id_link">#</a></h4></div></div></div><a id="id-1.5.6.6.5.8.2" class="indexterm"></a><p>Подзапросы, образующие таблицы, должны заключаться в скобки. Им могут назначаться псевдонимы таблиц и, если необходимо, псевдонимы столбцов (как описано в <a class="xref" href="queries-table-expressions.html#QUERIES-TABLE-ALIASES" title="7.2.1.2. Псевдонимы таблиц и столбцов">Подразделе 7.2.1.2</a>). Например: </p><pre class="programlisting">FROM (SELECT * FROM table1) AS псевдоним</pre><p>Этот пример равносилен записи <code class="literal">FROM table1 AS псевдоним</code>. Более интересные ситуации, которые нельзя свести к простому соединению, возникают, когда в подзапросе используются агрегирующие функции или группировка.</p><p>Подзапросом может также быть список <code class="command">VALUES</code>: </p><pre class="programlisting">FROM (VALUES ('anne', 'smith'), ('bob', 'jones'), ('joe', 'blow'))
     AS names(first, last)</pre><p> Такому подзапросу может быть назначен псевдоним. Назначать псевдонимы столбцам списка <code class="command">VALUES</code> не требуется, но вообще это хороший приём. Подробнее это описано в <a class="xref" href="queries-values.html" title="7.7. Списки VALUES">Разделе 7.7</a>.</p><p>Согласно стандарту SQL подзапросу должен назначаться псевдоним таблицы. <span class="productname">PostgreSQL</span> позволяет опускать <code class="literal">AS</code> и псевдоним, тем не менее хорошей практикой считается указывать псевдоним в коде SQL, который может быть портирован в другую систему.</p></div><div class="sect3" id="QUERIES-TABLEFUNCTIONS"><div class="titlepage"><div><div><h4 class="title">7.2.1.4. Табличные функции <a href="#QUERIES-TABLEFUNCTIONS" class="id_link">#</a></h4></div></div></div><a id="id-1.5.6.6.5.9.2" class="indexterm"></a><a id="id-1.5.6.6.5.9.3" class="indexterm"></a><p>Табличные функции — это функции, выдающие набор строк, содержащих либо базовые типы данных (скалярных типов), либо составные типы (табличные строки). Они применяются в запросах как таблицы, представления или подзапросы в предложении <code class="literal">FROM</code>. Столбцы, возвращённые табличными функциями, можно включить в выражения <code class="literal">SELECT</code>, <code class="literal">JOIN</code> или <code class="literal">WHERE</code> так же, как столбцы таблиц, представлений или подзапросов.</p><p>Табличные функции можно также скомбинировать, используя запись <code class="literal">ROWS FROM</code>. Результаты функций будут возвращены в параллельных столбцах; число строк в этом случае будет наибольшим из результатов всех функций, а результаты функций с меньшим количеством строк будут дополнены значениями NULL.</p><pre class="synopsis"><em class="replaceable"><code>вызов_функции</code></em> [<span class="optional">WITH ORDINALITY</span>] [<span class="optional">[<span class="optional">AS</span>] <em class="replaceable"><code>псевдоним_таблицы</code></em> [<span class="optional">(<em class="replaceable"><code>псевдоним_столбца</code></em> [<span class="optional">, ...</span>])</span>]</span>]
ROWS FROM( <em class="replaceable"><code>вызов_функции</code></em> [<span class="optional">, ...</span>] ) [<span class="optional">WITH ORDINALITY</span>] [<span class="optional">[<span class="optional">AS</span>] <em class="replaceable"><code>псевдоним_таблицы</code></em> [<span class="optional">(<em class="replaceable"><code>псевдоним_столбца</code></em> [<span class="optional">, ...</span>])</span>]</span>]</pre><p>Если указано предложение <code class="literal">WITH ORDINALITY</code>, к столбцам результатов функций будет добавлен ещё один, с типом <code class="type">bigint</code>. В этом столбце нумеруются строки результирующего набора, начиная с 1. (Это обобщение стандартного SQL-синтаксиса <code class="literal">UNNEST ... WITH ORDINALITY</code>.) По умолчанию, этот столбец называется <code class="literal">ordinality</code>, но ему можно присвоить и другое имя с помощью указания <code class="literal">AS</code>.</p><p>Специальную табличную функцию <code class="literal">UNNEST</code> можно вызвать с любым числом параметров-массивов, а возвращает она соответствующее число столбцов, как если бы <code class="literal">UNNEST</code> (<a class="xref" href="functions-array.html" title="9.19. Функции и операторы для работы с массивами">Раздел 9.19</a>) вызывалась для каждого параметра в отдельности, а результаты объединялись с помощью конструкции <code class="literal">ROWS FROM</code>.</p><pre class="synopsis">UNNEST( <em class="replaceable"><code>выражение_массива</code></em> [<span class="optional">, ...</span>] ) [<span class="optional">WITH ORDINALITY</span>] [<span class="optional">[<span class="optional">AS</span>] <em class="replaceable"><code>псевдоним_таблицы</code></em> [<span class="optional">(<em class="replaceable"><code>псевдоним_столбца</code></em> [<span class="optional">, ...</span>])</span>]</span>]</pre><p>Если <em class="replaceable"><code>псевдоним_таблицы</code></em> не указан, в качестве имени таблицы используется имя функции; в случае с конструкцией <code class="literal">ROWS FROM()</code> — имя первой функции.</p><p>Если псевдонимы столбцов не указаны, то для функции, возвращающей базовый тип данных, именем столбца будет имя функции. Для функций, возвращающих составной тип, имена результирующих столбцов определяются индивидуальными атрибутами типа.</p><p>Несколько примеров: </p><pre class="programlisting">CREATE TABLE foo (fooid int, foosubid int, fooname text);

CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT * FROM getfoo(1) AS t1;

SELECT * FROM foo
    WHERE foosubid IN (
                        SELECT foosubid
                        FROM getfoo(foo.fooid) z
                        WHERE z.fooid = foo.fooid
                      );

CREATE VIEW vw_getfoo AS SELECT * FROM getfoo(1);

SELECT * FROM vw_getfoo;</pre><p>В некоторых случаях бывает удобно определить табличную функцию, возвращающую различные наборы столбцов при разных вариантах вызова. Это можно сделать, объявив функцию, не имеющую выходных параметров (<code class="literal">OUT</code>) и возвращающую псевдотип <code class="type">record</code>. Используя такую функцию, ожидаемую структуру строк нужно описать в самом запросе, чтобы система знала, как разобрать запрос и составить его план. Записывается это так:</p><pre class="synopsis"><em class="replaceable"><code>вызов_функции</code></em> [<span class="optional">AS</span>] <em class="replaceable"><code>псевдоним</code></em> (<em class="replaceable"><code>определение_столбца</code></em> [<span class="optional">, ...</span>])
<em class="replaceable"><code>вызов_функции</code></em> AS [<span class="optional"><em class="replaceable"><code>псевдоним</code></em></span>] (<em class="replaceable"><code>определение_столбца</code></em> [<span class="optional">, ...</span>])
ROWS FROM( ... <em class="replaceable"><code>вызов_функции</code></em> AS (<em class="replaceable"><code>определение_столбца</code></em> [<span class="optional">, ...</span>]) [<span class="optional">, ...</span>] )</pre><p>Без <code class="literal">ROWS FROM()</code> список <em class="replaceable"><code>определения_столбцов</code></em> заменяет список псевдонимов, который можно также добавить в предложении <code class="literal">FROM</code>; имена в определениях столбцов служат псевдонимами. С <code class="literal">ROWS FROM()</code> список <em class="replaceable"><code>определения_столбцов</code></em> можно добавить к каждой функции отдельно, либо в случае с одной функцией и без предложения <code class="literal">WITH ORDINALITY</code>, список <em class="replaceable"><code>определения_столбцов</code></em> можно записать вместо списка с псевдонимами столбцов после <code class="literal">ROWS FROM()</code>.</p><p>Взгляните на этот пример: </p><pre class="programlisting">SELECT *
    FROM dblink('dbname=mydb', 'SELECT proname, prosrc FROM pg_proc')
      AS t1(proname name, prosrc text)
    WHERE proname LIKE 'bytea%';</pre><p> Здесь функция <a class="xref" href="contrib-dblink-function.html" title="dblink"><span class="refentrytitle">dblink</span></a> (из модуля <a class="xref" href="dblink.html" title="F.12. dblink — подключение к другим базам данных PostgreSQL">dblink</a>) выполняет удалённый запрос. Она объявлена как функция, возвращающая тип <code class="type">record</code>, так как он подойдёт для запроса любого типа. В этом случае фактический набор столбцов функции необходимо описать в вызывающем её запросе, чтобы анализатор запроса знал, например, как преобразовать <code class="literal">*</code>.</p><p>В этом примере используется конструкция <code class="literal">ROWS FROM</code>: </p><pre class="programlisting">SELECT *
FROM ROWS FROM
    (
        json_to_recordset('[{"a":40,"b":"foo"},{"a":"100","b":"bar"}]')
            AS (a INTEGER, b TEXT),
        generate_series(1, 3)
    ) AS x (p, q, s)
ORDER BY p;

  p  |  q  | s
-----+-----+---
  40 | foo | 1
 100 | bar | 2
     |     | 3</pre><p> Она объединяет результаты двух функций в одном отношении <code class="literal">FROM</code>. В данном случае <code class="function">json_to_recordset()</code> должна выдавать два столбца, первый <code class="type">integer</code> и второй <code class="type">text</code>, а результат <code class="function">generate_series()</code> используется непосредственно. Предложение <code class="literal">ORDER BY</code> упорядочивает значения первого столбца как целочисленные.</p></div><div class="sect3" id="QUERIES-LATERAL"><div class="titlepage"><div><div><h4 class="title">7.2.1.5. Подзапросы <code class="literal">LATERAL</code> <a href="#QUERIES-LATERAL" class="id_link">#</a></h4></div></div></div><a id="id-1.5.6.6.5.10.2" class="indexterm"></a><p>Перед подзапросами в предложении <code class="literal">FROM</code> можно добавить ключевое слово <code class="literal">LATERAL</code>. Это позволит ссылаться в них на столбцы предшествующих элементов списка <code class="literal">FROM</code>. (Без <code class="literal">LATERAL</code> каждый подзапрос выполняется независимо и поэтому не может обращаться к другим элементам <code class="literal">FROM</code>.)</p><p>Перед табличными функциями в предложении <code class="literal">FROM</code> также можно указать <code class="literal">LATERAL</code>, но для них это ключевое слово необязательно; в аргументах функций в любом случае можно обращаться к столбцам в предыдущих элементах <code class="literal">FROM</code>.</p><p>Элемент <code class="literal">LATERAL</code> может находиться на верхнем уровне списка <code class="literal">FROM</code> или в дереве <code class="literal">JOIN</code>. В последнем случае он может также ссылаться на любые элементы в левой части <code class="literal">JOIN</code>, справа от которого он находится.</p><p>Когда элемент <code class="literal">FROM</code> содержит ссылки <code class="literal">LATERAL</code>, запрос выполняется следующим образом: сначала для строки элемента <code class="literal">FROM</code> с целевыми столбцами, или набора строк из нескольких элементов <code class="literal">FROM</code>, содержащих целевые столбцы, вычисляется элемент <code class="literal">LATERAL</code> со значениями этих столбцов. Затем результирующие строки обычным образом соединяются со строками, из которых они были вычислены. Эта процедура повторяется для всех строк исходных таблиц.</p><p><code class="literal">LATERAL</code> можно использовать так: </p><pre class="programlisting">SELECT * FROM foo, LATERAL (SELECT * FROM bar WHERE bar.id = foo.bar_id) ss;</pre><p> Здесь это не очень полезно, так как тот же результат можно получить более простым и привычным способом: </p><pre class="programlisting">SELECT * FROM foo, bar WHERE bar.id = foo.bar_id;</pre><p> Применять <code class="literal">LATERAL</code> имеет смысл в основном, когда для вычисления соединяемых строк необходимо обратиться к столбцам других таблиц. В частности, это полезно, когда нужно передать значение функции, возвращающей набор данных. Например, если предположить, что <code class="function">vertices(polygon)</code> возвращает набор вершин многоугольника, близкие вершины многоугольников из таблицы polygons можно получить так: </p><pre class="programlisting">SELECT p1.id, p2.id, v1, v2
FROM polygons p1, polygons p2,
     LATERAL vertices(p1.poly) v1,
     LATERAL vertices(p2.poly) v2
WHERE (v1 &lt;-&gt; v2) &lt; 10 AND p1.id != p2.id;</pre><p> Этот запрос можно записать и так: </p><pre class="programlisting">SELECT p1.id, p2.id, v1, v2
FROM polygons p1 CROSS JOIN LATERAL vertices(p1.poly) v1,
     polygons p2 CROSS JOIN LATERAL vertices(p2.poly) v2
WHERE (v1 &lt;-&gt; v2) &lt; 10 AND p1.id != p2.id;</pre><p> или переформулировать другими способами. (Как уже упоминалось, в данном примере ключевое слово <code class="literal">LATERAL</code> не требуется, но мы добавили его для ясности.)</p><p>Особенно полезно бывает использовать <code class="literal">LEFT JOIN</code> с подзапросом <code class="literal">LATERAL</code>, чтобы исходные строки оказывались в результате, даже если подзапрос <code class="literal">LATERAL</code> не возвращает строк. Например, если функция <code class="function">get_product_names()</code> выдаёт названия продуктов, выпущенных определённым производителем, но о продукции некоторых производителей информации нет, мы можем найти, каких именно, примерно так: </p><pre class="programlisting">SELECT m.name
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true
WHERE pname IS NULL;</pre></div></div><div class="sect2" id="QUERIES-WHERE"><div class="titlepage"><div><div><h3 class="title">7.2.2. Предложение <code class="literal">WHERE</code> <a href="#QUERIES-WHERE" class="id_link">#</a></h3></div></div></div><a id="id-1.5.6.6.6.2" class="indexterm"></a><p>Предложение <a class="link" href="sql-select.html#SQL-WHERE" title="Предложение WHERE"><code class="literal">WHERE</code></a> записывается так: </p><pre class="synopsis">
WHERE <em class="replaceable"><code>условие_ограничения</code></em>
</pre><p> где <em class="replaceable"><code>условие_ограничения</code></em> — любое выражение значения (см. <a class="xref" href="sql-expressions.html" title="4.2. Выражения значения">Раздел 4.2</a>), выдающее результат типа <code class="type">boolean</code>.</p><p>После обработки предложения <code class="literal">FROM</code> каждая строка полученной виртуальной таблицы проходит проверку по условию ограничения. Если результат условия равен true, эта строка остаётся в выходной таблице, а иначе (если результат равен false или NULL) отбрасывается. В условии ограничения, как правило, задействуется минимум один столбец из таблицы, полученной на выходе <code class="literal">FROM</code>. Хотя строго говоря, это не требуется, но в противном случае предложение <code class="literal">WHERE</code> будет бессмысленным.</p><div class="note"><h3 class="title">Примечание</h3><p>Условие для внутреннего соединения можно записать как в предложении <code class="literal">WHERE</code>, так и в предложении <code class="literal">JOIN</code>. Например, это выражение: </p><pre class="programlisting">FROM a, b WHERE a.id = b.id AND b.val &gt; 5</pre><p> равнозначно этому: </p><pre class="programlisting">FROM a INNER JOIN b ON (a.id = b.id) WHERE b.val &gt; 5</pre><p> и возможно, даже этому: </p><pre class="programlisting">FROM a NATURAL JOIN b WHERE b.val &gt; 5</pre><p> Какой вариант выбрать, в основном дело вкуса и стиля. Вариант с <code class="literal">JOIN</code> внутри предложения <code class="literal">FROM</code>, возможно, не лучший с точки зрения совместимости с другими СУБД, хотя он и описан в стандарте SQL. Но для внешних соединений других вариантов нет: их можно записывать только во <code class="literal">FROM</code>. Предложения <code class="literal">ON</code> и <code class="literal">USING</code> во внешних соединениях <span class="emphasis"><em>не</em></span> равнозначны условию <code class="literal">WHERE</code>, так как они могут добавлять строки (для входных строк без соответствия), а также удалять их из конечного результата.</p></div><p>Несколько примеров запросов с <code class="literal">WHERE</code>: </p><pre class="programlisting">SELECT ... FROM fdt WHERE c1 &gt; 5

SELECT ... FROM fdt WHERE c1 IN (1, 2, 3)

SELECT ... FROM fdt WHERE c1 IN (SELECT c1 FROM t2)

SELECT ... FROM fdt WHERE c1 IN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10)

SELECT ... FROM fdt WHERE c1 BETWEEN
  (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10) AND 100

SELECT ... FROM fdt WHERE EXISTS (SELECT c1 FROM t2 WHERE c2 &gt; fdt.c1)</pre><p> <code class="literal">fdt</code> — название таблицы, порождённой в предложении <code class="literal">FROM</code>. Строки, которые не соответствуют условию <code class="literal">WHERE</code>, исключаются из <code class="literal">fdt</code>. Обратите внимание, как в качестве выражений значения используются скалярные подзапросы. Как и любые другие запросы, подзапросы могут содержать сложные табличные выражения. Заметьте также, что <code class="literal">fdt</code> используется в подзапросах. Дополнение имени <code class="literal">c1</code> в виде <code class="literal">fdt.c1</code> необходимо только, если в порождённой таблице в подзапросе также оказывается столбец <code class="literal">c1</code>. Полное имя придаёт ясность даже там, где без него можно обойтись. Этот пример показывает, как область именования столбцов внешнего запроса распространяется на все вложенные в него внутренние запросы.</p></div><div class="sect2" id="QUERIES-GROUP"><div class="titlepage"><div><div><h3 class="title">7.2.3. Предложения <code class="literal">GROUP BY</code> и <code class="literal">HAVING</code> <a href="#QUERIES-GROUP" class="id_link">#</a></h3></div></div></div><a id="id-1.5.6.6.7.2" class="indexterm"></a><a id="id-1.5.6.6.7.3" class="indexterm"></a><p>Строки порождённой входной таблицы, прошедшие фильтр <code class="literal">WHERE</code>, можно сгруппировать с помощью предложения <code class="literal">GROUP BY</code>, а затем оставить в результате только нужные группы строк, используя предложение <code class="literal">HAVING</code>.</p><pre class="synopsis">SELECT <em class="replaceable"><code>список_выборки</code></em>
    FROM ...
    [<span class="optional">WHERE ...</span>]
    GROUP BY <em class="replaceable"><code>группирующий_столбец</code></em> [<span class="optional">, <em class="replaceable"><code>группирующий_столбец</code></em></span>]...</pre><p>Предложение <a class="link" href="sql-select.html#SQL-GROUPBY" title="Предложение GROUP BY"><code class="literal">GROUP BY</code></a> группирует строки таблицы, объединяя их в одну группу при совпадении значений во всех перечисленных столбцах. Порядок, в котором указаны столбцы, не имеет значения. В результате наборы строк с одинаковыми значениями преобразуются в отдельные строки, представляющие все строки группы. Это может быть полезно для устранения избыточности выходных данных и/или для вычисления агрегатных функций, применённых к этим группам. Например: </p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM test1;</code></strong>
 x | y
---+---
 a | 3
 c | 2
 b | 5
 a | 1
(4 rows)

<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT x FROM test1 GROUP BY x;</code></strong>
 x
---
 a
 b
 c
(3 rows)
</pre><p>Во втором запросе мы не могли написать <code class="literal">SELECT * FROM test1 GROUP BY x</code>, так как для столбца <code class="literal">y</code> нет единого значения, связанного с каждой группой. Однако столбцы, по которым выполняется группировка, можно использовать в списке выборки, так как они имеют единственное значение в каждой группе.</p><p>Вообще говоря, в группированной таблице столбцы, не включённые в список <code class="literal">GROUP BY</code>, можно использовать только в агрегатных выражениях. Пример такого агрегатного выражения: </p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT x, sum(y) FROM test1 GROUP BY x;</code></strong>
 x | sum
---+-----
 a |   4
 b |   5
 c |   2
(3 rows)
</pre><p> Здесь <code class="literal">sum</code> — агрегатная функция, вычисляющая единственное значение для всей группы. Подробную информацию о существующих агрегатных функциях можно найти в <a class="xref" href="functions-aggregate.html" title="9.21. Агрегатные функции">Разделе 9.21</a>.</p><div class="tip"><h3 class="title">Подсказка</h3><p>Группировка без агрегатных выражений по сути выдаёт набор различающихся значений столбцов. Этот же результат можно получить с помощью предложения <code class="literal">DISTINCT</code> (см. <a class="xref" href="queries-select-lists.html#QUERIES-DISTINCT" title="7.3.3. DISTINCT">Подраздел 7.3.3</a>).</p></div><p>Взгляните на следующий пример: в нём вычисляется общая сумма продаж по каждому продукту (а не общая сумма по всем продуктам): </p><pre class="programlisting">SELECT product_id, p.name, (sum(s.units) * p.price) AS sales
    FROM products p LEFT JOIN sales s USING (product_id)
    GROUP BY product_id, p.name, p.price;</pre><p> В этом примере столбцы <code class="literal">product_id</code>, <code class="literal">p.name</code> и <code class="literal">p.price</code> должны присутствовать в списке <code class="literal">GROUP BY</code>, так как они используются в списке выборки. Столбец <code class="literal">s.units</code> может отсутствовать в списке <code class="literal">GROUP BY</code>, так как он используется только в агрегатном выражении (<code class="literal">sum(...)</code>), вычисляющем сумму продаж. Для каждого продукта этот запрос возвращает строку с итоговой суммой по всем продажам данного продукта.</p><a id="id-1.5.6.6.7.11" class="indexterm"></a><p>Если бы в таблице products по столбцу <code class="literal">product_id</code> был создан первичный ключ, тогда в данном примере было бы достаточно сгруппировать строки по <code class="literal">product_id</code>, так как название и цена продукта <em class="firstterm">функционально зависят</em> от кода продукта и можно однозначно определить, какое название и цену возвращать для каждой группы по ID.</p><p>В стандарте SQL <code class="literal">GROUP BY</code> может группировать только по столбцам исходной таблицы, но расширение <span class="productname">PostgreSQL</span> позволяет использовать в <code class="literal">GROUP BY</code> столбцы из списка выборки. Также возможна группировка по выражениям, а не просто именам столбцов.</p><a id="id-1.5.6.6.7.14" class="indexterm"></a><p>Если таблица была сгруппирована с помощью <code class="literal">GROUP BY</code>, но интерес представляют только некоторые группы, отфильтровать их можно с помощью предложения <code class="literal">HAVING</code>, действующего подобно <code class="literal">WHERE</code>. Записывается это так: </p><pre class="synopsis">
SELECT <em class="replaceable"><code>список_выборки</code></em> FROM ... [<span class="optional">WHERE ...</span>] GROUP BY ...
  HAVING <em class="replaceable"><code>логическое_выражение</code></em>
</pre><p> В предложении <code class="literal">HAVING</code> могут использоваться и группирующие выражения, и выражения, не участвующие в группировке (в этом случае это должны быть агрегирующие функции).</p><p>Пример: </p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT x, sum(y) FROM test1 GROUP BY x HAVING sum(y) &gt; 3;</code></strong>
 x | sum
---+-----
 a |   4
 b |   5
(2 rows)

<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT x, sum(y) FROM test1 GROUP BY x HAVING x &lt; 'c';</code></strong>
 x | sum
---+-----
 a |   4
 b |   5
(2 rows)
</pre><p>И ещё один более реалистичный пример: </p><pre class="programlisting">SELECT product_id, p.name, (sum(s.units) * (p.price - p.cost)) AS profit
    FROM products p LEFT JOIN sales s USING (product_id)
    WHERE s.date &gt; CURRENT_DATE - INTERVAL '4 weeks'
    GROUP BY product_id, p.name, p.price, p.cost
    HAVING sum(p.price * s.units) &gt; 5000;</pre><p> В данном примере предложение <code class="literal">WHERE</code> выбирает строки по столбцу, не включённому в группировку (выражение истинно только для продаж за последние четыре недели), тогда как предложение <code class="literal">HAVING</code> отфильтровывает группы с общей суммой продаж больше 5000. Заметьте, что агрегатные выражения не обязательно должны быть одинаковыми во всех частях запроса.</p><p>Если в запросе есть вызовы агрегатных функций, но нет предложения <code class="literal">GROUP BY</code>, строки всё равно будут группироваться: в результате окажется одна строка группы (или возможно, ни одной строки, если эта строка будет отброшена предложением <code class="literal">HAVING</code>). Это справедливо и для запросов, которые содержат только предложение <code class="literal">HAVING</code>, но не содержат вызовы агрегатных функций и предложение <code class="literal">GROUP BY</code>.</p></div><div class="sect2" id="QUERIES-GROUPING-SETS"><div class="titlepage"><div><div><h3 class="title">7.2.4. <code class="literal">GROUPING SETS</code>, <code class="literal">CUBE</code> и <code class="literal">ROLLUP</code> <a href="#QUERIES-GROUPING-SETS" class="id_link">#</a></h3></div></div></div><a id="id-1.5.6.6.8.2" class="indexterm"></a><a id="id-1.5.6.6.8.3" class="indexterm"></a><a id="id-1.5.6.6.8.4" class="indexterm"></a><p>Более сложные, чем описанные выше, операции группировки возможны с концепцией <em class="firstterm">наборов группирования</em>. Данные, выбранные предложениями <code class="literal">FROM</code> и <code class="literal">WHERE</code>, группируются отдельно для каждого заданного набора группирования, затем для каждой группы вычисляются агрегатные функции как для простых предложений <code class="literal">GROUP BY</code>, и в конце возвращаются результаты. Например: </p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM items_sold;</code></strong>
 brand | size | sales
-------+------+-------
 Foo   | L    |  10
 Foo   | M    |  20
 Bar   | M    |  15
 Bar   | L    |  5
(4 rows)

<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT brand, size, sum(sales) FROM items_sold GROUP BY GROUPING SETS ((brand), (size), ());</code></strong>
 brand | size | sum
-------+------+-----
 Foo   |      |  30
 Bar   |      |  20
       | L    |  15
       | M    |  35
       |      |  50
(5 rows)
</pre><p>В каждом внутреннем списке <code class="literal">GROUPING SETS</code> могут задаваться ноль или более столбцов или выражений, которые воспринимаются так же, как если бы они были непосредственно записаны в предложении <code class="literal">GROUP BY</code>. Пустой набор группировки означает, что все строки сводятся к одной группе (которая выводится, даже если входных строк нет), как описано выше для агрегатных функций без предложения <code class="literal">GROUP BY</code>.</p><p>Ссылки на группирующие столбцы или выражения заменяются в результирующих строках значениями NULL для тех группирующих наборов, в которых эти столбцы отсутствуют. Чтобы можно было понять, результатом какого группирования стала конкретная выходная строка, предназначена функция, описанная в <a class="xref" href="functions-aggregate.html#FUNCTIONS-GROUPING-TABLE" title="Таблица 9.63. Операции группировки">Таблице 9.63</a>.</p><p>Для указания двух распространённых видов наборов группирования предусмотрена краткая запись. Предложение формы </p><pre class="programlisting">ROLLUP ( <em class="replaceable"><code>e1</code></em>, <em class="replaceable"><code>e2</code></em>, <em class="replaceable"><code>e3</code></em>, ... )</pre><p> представляет заданный список выражений и всех префиксов списка, включая пустой список; то есть оно равнозначно записи </p><pre class="programlisting">GROUPING SETS (
    ( <em class="replaceable"><code>e1</code></em>, <em class="replaceable"><code>e2</code></em>, <em class="replaceable"><code>e3</code></em>, ... ),
    ...
    ( <em class="replaceable"><code>e1</code></em>, <em class="replaceable"><code>e2</code></em> ),
    ( <em class="replaceable"><code>e1</code></em> ),
    ( )
)</pre><p> Оно часто применяется для анализа иерархических данных, например, для суммирования зарплаты по отделам, подразделениям и компании в целом.</p><p>Предложение формы </p><pre class="programlisting">CUBE ( <em class="replaceable"><code>e1</code></em>, <em class="replaceable"><code>e2</code></em>, ... )</pre><p> представляет заданный список и все его возможные подмножества (степень множества). Таким образом, запись </p><pre class="programlisting">CUBE ( a, b, c )</pre><p> равнозначна </p><pre class="programlisting">GROUPING SETS (
    ( a, b, c ),
    ( a, b    ),
    ( a,    c ),
    ( a       ),
    (    b, c ),
    (    b    ),
    (       c ),
    (         )
)</pre><p>Элементами предложений <code class="literal">CUBE</code> и <code class="literal">ROLLUP</code> могут быть либо отдельные выражения, либо вложенные списки элементов в скобках. Вложенные списки обрабатываются как атомарные единицы, с которыми формируются отдельные наборы группирования. Например: </p><pre class="programlisting">CUBE ( (a, b), (c, d) )</pre><p> равнозначно </p><pre class="programlisting">GROUPING SETS (
    ( a, b, c, d ),
    ( a, b       ),
    (       c, d ),
    (            )
)</pre><p> и </p><pre class="programlisting">ROLLUP ( a, (b, c), d )</pre><p> равнозначно </p><pre class="programlisting">GROUPING SETS (
    ( a, b, c, d ),
    ( a, b, c    ),
    ( a          ),
    (            )
)</pre><p>Конструкции <code class="literal">CUBE</code> и <code class="literal">ROLLUP</code> могут применяться либо непосредственно в предложении <code class="literal">GROUP BY</code>, либо вкладываться внутрь предложения <code class="literal">GROUPING SETS</code>. Если одно предложение <code class="literal">GROUPING SETS</code> вкладывается внутрь другого, результат будет таким же, как если бы все элементы внутреннего предложения были записаны непосредственно во внешнем.</p><p>Если в одном предложении <code class="literal">GROUP BY</code> задаётся несколько элементов группирования, окончательный список наборов группирования образуется как прямое произведение этих элементов. Например: </p><pre class="programlisting">GROUP BY a, CUBE (b, c), GROUPING SETS ((d), (e))</pre><p> равнозначно </p><pre class="programlisting">GROUP BY GROUPING SETS (
    (a, b, c, d), (a, b, c, e),
    (a, b, d),    (a, b, e),
    (a, c, d),    (a, c, e),
    (a, d),       (a, e)
)</pre><p><a id="id-1.5.6.6.8.13.1" class="indexterm"></a> <a id="id-1.5.6.6.8.13.2" class="indexterm"></a> Если задаётся несколько элементов группирования, окончательный список наборов группирования может содержать дублирующиеся результаты. Например: </p><pre class="programlisting">GROUP BY ROLLUP (a, b), ROLLUP (a, c)</pre><p> равнозначно </p><pre class="programlisting">GROUP BY GROUPING SETS (
    (a, b, c),
    (a, b),
    (a, b),
    (a, c),
    (a),
    (a),
    (a, c),
    (a),
    ()
)</pre><p> Если эти дублирующиеся результаты нежелательны, их можно убрать, добавив <code class="literal">DISTINCT</code> непосредственно в предложение <code class="literal">GROUP BY</code>. Таким образом: </p><pre class="programlisting">GROUP BY <span class="emphasis"><strong>DISTINCT</strong></span> ROLLUP (a, b), ROLLUP (a, c)</pre><p> равнозначно </p><pre class="programlisting">GROUP BY GROUPING SETS (
    (a, b, c),
    (a, b),
    (a, c),
    (a),
    ()
)</pre><p> Это не то же самое, что <code class="literal">SELECT DISTINCT</code>, поскольку результирующие строки всё же могут содержать дублирующиеся записи. Если любой из столбцов, не участвующих в группировании, содержит значение NULL, в результате оно не будет отличаться от NULL, полученного при группировании этого столбца.</p><div class="note"><h3 class="title">Примечание</h3><p>Конструкция <code class="literal">(a, b)</code> обычно воспринимается в выражениях как <a class="link" href="sql-expressions.html#SQL-SYNTAX-ROW-CONSTRUCTORS" title="4.2.13. Конструкторы табличных строк">конструктор строки</a>. Однако в предложении <code class="literal">GROUP BY</code> на верхнем уровне выражений запись <code class="literal">(a, b)</code> воспринимается как список выражений, как описано выше. Если вам по какой-либо причине <span class="emphasis"><em>нужен</em></span> именно конструктор строки в выражении группирования, используйте запись <code class="literal">ROW(a, b)</code>.</p></div></div><div class="sect2" id="QUERIES-WINDOW"><div class="titlepage"><div><div><h3 class="title">7.2.5. Обработка оконных функций <a href="#QUERIES-WINDOW" class="id_link">#</a></h3></div></div></div><a id="id-1.5.6.6.9.2" class="indexterm"></a><p>Если запрос содержит оконные функции (см. <a class="xref" href="tutorial-window.html" title="3.5. Оконные функции">Раздел 3.5</a>, <a class="xref" href="functions-window.html" title="9.22. Оконные функции">Раздел 9.22</a> и <a class="xref" href="sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS" title="4.2.8. Вызовы оконных функций">Подраздел 4.2.8</a>), эти функции вычисляются после каждой группировки, агрегатных выражений и фильтрации <code class="literal">HAVING</code>. Другими словами, если в запросе есть агрегатные функции, предложения <code class="literal">GROUP BY</code> или <code class="literal">HAVING</code>, оконные функции видят не исходные строки, полученные из <code class="literal">FROM</code>/<code class="literal">WHERE</code>, а сгруппированные.</p><p>Когда используются несколько оконных функций, все оконные функции, имеющие в своих определениях синтаксически равнозначные предложения <code class="literal">PARTITION BY</code> и <code class="literal">ORDER BY</code>, гарантированно обрабатывают данные за один проход. Таким образом, они увидят один порядок сортировки, даже если <code class="literal">ORDER BY</code> не определяет порядок однозначно. Однако относительно функций с разными формулировками <code class="literal">PARTITION BY</code> и <code class="literal">ORDER BY</code> никаких гарантий не даётся. (В таких случаях между проходами вычислений оконных функций обычно требуется дополнительный этап сортировки и эта сортировка может не сохранять порядок строк, равнозначный с точки зрения <code class="literal">ORDER BY</code>.)</p><p>В настоящее время оконные функции всегда требуют предварительно отсортированных данных, так что результат запроса будет отсортирован согласно тому или иному предложению <code class="literal">PARTITION BY</code>/<code class="literal">ORDER BY</code> оконных функций. Однако полагаться на это не следует. Если вы хотите, чтобы результаты сортировались определённым образом, явно добавьте предложение <code class="literal">ORDER BY</code> на верхнем уровне запроса.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="queries-overview.html" title="7.1. Обзор">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="queries.html" title="Глава 7. Запросы">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="queries-select-lists.html" title="7.3. Списки выборки">След.</a></td></tr><tr><td width="40%" align="left" valign="top">7.1. Обзор </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 7.3. Списки выборки</td></tr></table></div></body></html>