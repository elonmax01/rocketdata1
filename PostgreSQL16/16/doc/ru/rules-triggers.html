<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>41.7. Сравнение правил и триггеров</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="rules-status.html" title="41.6. Правила и статус команд" /><link rel="next" href="xplang.html" title="Глава 42. Процедурные языки" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">41.7. Сравнение правил и триггеров</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="rules-status.html" title="41.6. Правила и статус команд">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="rules.html" title="Глава 41. Система правил">Наверх</a></td><th width="60%" align="center">Глава 41. Система правил</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="xplang.html" title="Глава 42. Процедурные языки">След.</a></td></tr></table><hr /></div><div class="sect1" id="RULES-TRIGGERS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">41.7. Сравнение правил и триггеров <a href="#RULES-TRIGGERS" class="id_link">#</a></h2></div></div></div><a id="id-1.8.6.12.2" class="indexterm"></a><a id="id-1.8.6.12.3" class="indexterm"></a><p>Многие вещи, которые можно сделать с помощью триггеров, можно также реализовать, используя систему правил <span class="productname">PostgreSQL</span>. Однако, используя правила, нельзя реализовать, например, некоторые типы ограничений, в частности, внешние ключи. Хотя можно определить правило с ограничивающим условием, которое будет преобразовать команду в <code class="literal">NOTHING</code>, если значение ключа не находится в другой таблице, но при этом неподходящие данные будут отбрасываться молча, а это не самый лучший вариант. Также, если требуется проверить правильность значений и, обнаружив неверное значение, выдать ошибку, это нужно делать в триггере.</p><p>В этой главе мы разберём использование правил для изменения представлений. Все правила, приведённые в примерах этой главы, можно также заменить триггерами <code class="literal">INSTEAD OF</code> для представлений. Написать такие триггеры часто бывает проще, чем разработать правила, особенно если для изменений применяется сложная логика.</p><p>Для тех задач, которые можно решить обоими способами, лучший выбирается в зависимости от характера использования базы данных. Следует учитывать, что триггер срабатывает для каждой обрабатываемой строки, а правило изменяет существующий запрос или создаёт ещё один. Поэтому, если один оператор обрабатывает сразу много строк, правило, добавляющее дополнительную команду, скорее всего, будет работать быстрее, чем триггер, который вызывается для каждой очередной строки и должен каждый раз определять, что с ней делать. Однако триггеры концептуально гораздо проще правил, и использовать их правильно новичкам гораздо проще.</p><p>Давайте рассмотрим пример, показывающий, как выбор в пользу правил вместо триггеров оказывается выигрышным в определённой ситуации. Пусть у нас есть две таблицы: </p><pre class="programlisting">CREATE TABLE computer (
    hostname        text,    -- индексированное
    manufacturer    text     -- индексированное
);

CREATE TABLE software (
    software        text,    -- индексированное
    hostname        text     -- индексированное
);</pre><p> Обе таблицы содержат несколько тысяч строк, а индексы по полю <code class="structfield">hostname</code> являются уникальными. Правило или триггер должны реализовать ограничение, которое удалит строки из таблицы <code class="literal">software</code>, ссылающиеся на удаляемый компьютер. Триггер выполнял бы такую команду: </p><pre class="programlisting">DELETE FROM software WHERE hostname = $1;</pre><p> Так как триггер вызывается для каждой отдельной строки, удаляемой из таблицы <code class="literal">computer</code>, он может подготовить и сохранить план этой команды, а затем передавать значение <code class="structfield">hostname</code> подготовленному запросу в параметрах. Правило же можно записать так: </p><pre class="programlisting">CREATE RULE computer_del AS ON DELETE TO computer
    DO DELETE FROM software WHERE hostname = OLD.hostname;</pre><p>Теперь давайте взглянем на разные варианты удаления. В этом случае: </p><pre class="programlisting">DELETE FROM computer WHERE hostname = 'mypc.local.net';</pre><p> таблица <code class="literal">computer</code> сканируется по индексу (быстро), и команда, выполняемая триггером, так же будет применять сканирование по индексу (тоже быстро). Дополнительной командой правила будет: </p><pre class="programlisting">DELETE FROM software WHERE computer.hostname = 'mypc.local.net'
                       AND software.hostname = computer.hostname;</pre><p> Так как созданы все необходимые индексы, планировщик создаст план </p><pre class="literallayout">
Nestloop
  -&gt;  Index Scan using comp_hostidx on computer
  -&gt;  Index Scan using soft_hostidx on software
</pre><p> Таким образом, большого различия в скорости между реализациями с триггером и с правилом не будет.</p><p>Теперь мы хотим избавиться от 2000 компьютеров, у которых <code class="structfield">hostname</code> начинается с <code class="literal">old</code>. Это можно сделать двумя командами. Первая: </p><pre class="programlisting">DELETE FROM computer WHERE hostname &gt;= 'old'
                       AND hostname &lt;  'ole'</pre><p> Правило преобразует её в: </p><pre class="programlisting">DELETE FROM software WHERE computer.hostname &gt;= 'old' AND computer.hostname &lt; 'ole'
                       AND software.hostname = computer.hostname;</pre><p> с планом: </p><pre class="literallayout">
Hash Join
  -&gt;  Seq Scan on software
  -&gt;  Hash
    -&gt;  Index Scan using comp_hostidx on computer
</pre><p> С другой возможной командой: </p><pre class="programlisting">DELETE FROM computer WHERE hostname ~ '^old';</pre><p> для запроса, преобразованного правилом, получается следующий план: </p><pre class="literallayout">
Nestloop
  -&gt;  Index Scan using comp_hostidx on computer
  -&gt;  Index Scan using soft_hostidx on software
</pre><p> Это показывает, что планировщик не понимает, что ограничение по <code class="structfield">hostname</code> в <code class="literal">computer</code> можно также использовать для сканирования по индексу в <code class="literal">software</code>, когда несколько условий объединяются с помощью <code class="literal">AND</code>, что он успешно делает для варианта команды с регулярным выражением. Триггер будет вызываться для каждой из 2000 удаляемых записей о старых компьютерах, и это приведёт к одному сканированию индекса в таблице <code class="literal">computer</code> и 2000 сканированиям индекса в таблице <code class="literal">software</code>. Реализация с правилом делает это двумя командами, применяющими индексы. Будет ли правило быстрее при последовательном сканировании, зависит от общего размера таблицы <code class="literal">software</code>. С другой стороны, выполнение 2000 команд из триггера через менеджер SPI всё равно займёт время, даже если все блоки индекса вскоре окажутся в кеше.</p><p>В завершение взгляните на эту команду: </p><pre class="programlisting">DELETE FROM computer WHERE manufacturer = 'bim';</pre><p> Она также может привести к удалению множества строк из таблицы <code class="literal">computer</code>. Поэтому триггер снова пропустит через исполнитель такое же множество команд. Правило же выдаст следующую команду: </p><pre class="programlisting">DELETE FROM software WHERE computer.manufacturer = 'bim'
                       AND software.hostname = computer.hostname;</pre><p> План для этой команды снова будет содержать вложенный цикл по двум сканированиям индекса, но на этот раз с другим индексом таблицы <code class="literal">computer</code>: </p><pre class="programlisting">Nestloop
  -&gt;  Index Scan using comp_manufidx on computer
  -&gt;  Index Scan using soft_hostidx on software</pre><p> Во всех этих случаях дополнительные команды будут более-менее независимыми от числа затрагиваемых строк.</p><p>Таким образом, правила будут значительно медленнее триггеров, только если их действия приводят к образованию больших и плохо связанных соединений, когда планировщик оказывается бессилен.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="rules-status.html" title="41.6. Правила и статус команд">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="rules.html" title="Глава 41. Система правил">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="xplang.html" title="Глава 42. Процедурные языки">След.</a></td></tr><tr><td width="40%" align="left" valign="top">41.6. Правила и статус команд </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> Глава 42. Процедурные языки</td></tr></table></div></body></html>