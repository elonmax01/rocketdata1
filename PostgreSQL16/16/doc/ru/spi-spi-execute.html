<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>SPI_execute</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="spi-spi-finish.html" title="SPI_finish" /><link rel="next" href="spi-spi-exec.html" title="SPI_exec" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">SPI_execute</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="spi-spi-finish.html" title="SPI_finish">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="spi-interface.html" title="47.1. Интерфейсные функции">Наверх</a></td><th width="60%" align="center">47.1. Интерфейсные функции</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="spi-spi-exec.html" title="SPI_exec">След.</a></td></tr></table><hr /></div><div class="refentry" id="SPI-SPI-EXECUTE"><div class="titlepage"></div><a id="id-1.8.12.8.4.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">SPI_execute</span></h2><p>SPI_execute — выполнить команду</p></div><div class="refsynopsisdiv"><h2>Синтаксис</h2><pre class="synopsis">int SPI_execute(const char * <em class="parameter"><code>command</code></em>, bool <em class="parameter"><code>read_only</code></em>, long <em class="parameter"><code>count</code></em>)</pre></div><div class="refsect1" id="id-1.8.12.8.4.5"><h2>Описание</h2><p><code class="function">SPI_execute</code> выполняет заданную команду SQL для получения строк в количестве, ограниченном <em class="parameter"><code>count</code></em>. С параметром <em class="parameter"><code>read_only</code></em>, равным <code class="literal">true</code>, команда должна только читать данные; это несколько сокращает издержки на её выполнение.</p><p>Эту функцию можно вызывать только из подключённой функции на C.</p><p>Если <em class="parameter"><code>count</code></em> равен 0, команда выполняется для всех строк, к которым она применима. Если <em class="parameter"><code>count</code></em> больше нуля, будет получено не более чем <em class="parameter"><code>count</code></em> строк; выполнение команды остановится при достижении этого предела, практически так же, как и с предложением <code class="literal">LIMIT</code> в запросе. Например, команда: </p><pre class="programlisting">SPI_execute("SELECT * FROM foo", true, 5);</pre><p> получит из таблицы не более 5 строк. Заметьте, что это ограничение действует, только когда команда действительно возвращает строки. Например, эта команда: </p><pre class="programlisting">SPI_execute("INSERT INTO foo SELECT * FROM bar", false, 5);</pre><p> вставляет все строки из <code class="structname">bar</code>, игнорируя параметр <em class="parameter"><code>count</code></em>. Однако команда </p><pre class="programlisting">SPI_execute("INSERT INTO foo SELECT * FROM bar RETURNING *", false, 5);</pre><p> вставит не более 5 строк, так как её выполнение будет остановлено после получения пятой строки, выданной предложением <code class="literal">RETURNING</code>.</p><p>В одной строке можно передать несколько команд; <code class="function">SPI_execute</code> возвращает результат команды, выполненной последней. Параметр <em class="parameter"><code>count</code></em> при этом будет применяться к каждой команде по отдельности (несмотря даже на то, что возвращён будет только последний результат). Это ограничение не будет распространяться на скрытые команды, генерируемые правилами.</p><p>Когда параметр <em class="parameter"><code>read_only</code></em> равен <code class="literal">false</code>, <code class="function">SPI_execute</code> увеличивает счётчик команд и получает новый <em class="firstterm">снимок</em> перед выполнением каждой очередной команды в строке. Этот снимок фактически не меняется при текущем уровне изоляции транзакций <code class="literal">SERIALIZABLE</code> или <code class="literal">REPEATABLE READ</code>, но в режиме <code class="literal">READ COMMITTED</code> после обновления снимка очередная команда может видеть результаты только что зафиксированных транзакций из других сеансов. Это важно для согласованного поведения, когда команды модифицируют базу данных.</p><p>Когда параметр <em class="parameter"><code>read_only</code></em> равен <code class="literal">true</code>, <code class="function">SPI_execute</code> не обновляет снимок и не увеличивает счётчик команд, и допускает в строке команд только <code class="command">SELECT</code>. Заданные команды выполняются со снимком, ранее полученным для окружающего запроса. Этот режим выполнения несколько быстрее режима чтения/записи вследствие исключения издержек, связанных с отдельными командами. Он также позволяет создавать подлинно <em class="firstterm">стабильные</em> функции: так как последующие вызовы в транзакции будут использовать один снимок, результаты команд не изменятся.</p><p>Смешивать команды, только читающие, с командами, читающими и пишущими, в одной процедуре, использующей SPI, обычно неразумно; запросы только на чтение не увидят результатов изменений в базе данных, произведённых пишущими запросами.</p><p>Число строк, которые были фактически обработаны командой (последней), возвращается в глобальной переменной <code class="varname">SPI_processed</code>. Если эта функция возвращает значение <code class="symbol">SPI_OK_SELECT</code>, <code class="symbol">SPI_OK_INSERT_RETURNING</code>, <code class="symbol">SPI_OK_DELETE_RETURNING</code> или <code class="symbol">SPI_OK_UPDATE_RETURNING</code>, вы можете обратиться по глобальному указателю <code class="literal">SPITupleTable *SPI_tuptable</code> и прочитать строки результата. Некоторые служебные команды (например, <code class="command">EXPLAIN</code>) также возвращают наборы строк, и <code class="literal">SPI_tuptable</code> будет содержать их результаты и в этих случаях. Другие вспомогательные команды (<code class="command">COPY</code>, <code class="command">CREATE TABLE AS</code>) не возвращают набор строк, так что указатель <code class="literal">SPI_tuptable</code> равен NULL, но они так же возвращают число обработанных строк в <code class="varname">SPI_processed</code>.</p><p>Структура <code class="structname">SPITupleTable</code> определена так: </p><pre class="programlisting">typedef struct SPITupleTable
{
    /* Открытые члены */
    TupleDesc   tupdesc;        /* дескриптор кортежа */
    HeapTuple  *vals;           /* массив кортежей */
    uint64      numvals;        /* число фактически представленных кортежей */

    /* Закрытые члены, не предназначенные для внешнего использования */
    uint64      alloced;        /* зарезервированное в памяти число элементов vals */
    MemoryContext tuptabcxt;    /* контекст таблицы результатов в памяти */
    slist_node  next;           /* ссылка для внутреннего обслуживания */
    SubTransactionId subid;     /* подтранзакция, создавшая структуру tuptable */
} SPITupleTable;</pre><p> Поля <code class="structfield">tupdesc</code>, <code class="structfield">vals</code> и <code class="structfield">numvals</code> могут использоваться кодом, вызывающим SPI, остальные поля являются внутренними. <code class="structfield">vals</code> представляет собой массив указателей на кортежи. Число записей в нём указывается в <code class="structfield">numvals</code> (по некоторым историческим причинам это число также возвращается в <code class="varname">SPI_processed</code>). Поле <code class="structfield">tupdesc</code> содержит дескриптор кортежа, который вы сможете передать функциям SPI, работающими с кортежами.</p><p><code class="function">SPI_finish</code> освобождает все структуры <code class="structname">SPITupleTable</code>, размещённые в памяти для текущей функции на C. Вы можете освободить структуру конкретной результирующей таблицы, если она вам не нужна, вызвав <code class="function">SPI_freetuptable</code>.</p></div><div class="refsect1" id="id-1.8.12.8.4.6"><h2>Аргументы</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">const char * <em class="parameter"><code>command</code></em></code></span></dt><dd><p>строка с командой, которая должна быть выполнена</p></dd><dt><span class="term"><code class="literal">bool <em class="parameter"><code>read_only</code></em></code></span></dt><dd><p><code class="literal">true</code> для режима выполнения «только чтение»</p></dd><dt><span class="term"><code class="literal">long <em class="parameter"><code>count</code></em></code></span></dt><dd><p>максимальное число строк, которое должно быть возвращено; с <code class="literal">0</code> ограничения нет</p></dd></dl></div></div><div class="refsect1" id="id-1.8.12.8.4.7"><h2>Возвращаемое значение</h2><p>Если команда была выполнена успешно, возвращается одно из следующих (неотрицательных) значений: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="symbol">SPI_OK_SELECT</code></span></dt><dd><p>если выполнялась команда <code class="command">SELECT</code> (но не <code class="command">SELECT INTO</code>)</p></dd><dt><span class="term"><code class="symbol">SPI_OK_SELINTO</code></span></dt><dd><p>если выполнялась команда <code class="command">SELECT INTO</code></p></dd><dt><span class="term"><code class="symbol">SPI_OK_INSERT</code></span></dt><dd><p>если выполнялась команда <code class="command">INSERT</code></p></dd><dt><span class="term"><code class="symbol">SPI_OK_DELETE</code></span></dt><dd><p>если выполнялась команда <code class="command">DELETE</code></p></dd><dt><span class="term"><code class="symbol">SPI_OK_UPDATE</code></span></dt><dd><p>если выполнялась команда <code class="command">UPDATE</code></p></dd><dt><span class="term"><code class="symbol">SPI_OK_MERGE</code></span></dt><dd><p>если выполнялась команда <code class="command">MERGE</code></p></dd><dt><span class="term"><code class="symbol">SPI_OK_INSERT_RETURNING</code></span></dt><dd><p>если выполнялась команда <code class="command">INSERT RETURNING</code></p></dd><dt><span class="term"><code class="symbol">SPI_OK_DELETE_RETURNING</code></span></dt><dd><p>если выполнялась команда <code class="command">DELETE RETURNING</code></p></dd><dt><span class="term"><code class="symbol">SPI_OK_UPDATE_RETURNING</code></span></dt><dd><p>если выполнялась команда <code class="command">UPDATE RETURNING</code></p></dd><dt><span class="term"><code class="symbol">SPI_OK_UTILITY</code></span></dt><dd><p>если выполнялась служебная команда (например, <code class="command">CREATE TABLE</code>)</p></dd><dt><span class="term"><code class="symbol">SPI_OK_REWRITTEN</code></span></dt><dd><p>если команда была преобразована <a class="link" href="rules.html" title="Глава 41. Система правил">правилом</a> в команду другого вида (например, <code class="command">UPDATE</code> стал командой <code class="command">INSERT</code>).</p></dd></dl></div><p>В случае ошибки возвращается одно из следующих отрицательных значений: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="symbol">SPI_ERROR_ARGUMENT</code></span></dt><dd><p>если в качестве <em class="parameter"><code>command</code></em> передан <code class="symbol">NULL</code> или <em class="parameter"><code>count</code></em> меньше 0</p></dd><dt><span class="term"><code class="symbol">SPI_ERROR_COPY</code></span></dt><dd><p>при попытке выполнить <code class="command">COPY TO stdout</code> или <code class="command">COPY FROM stdin</code></p></dd><dt><span class="term"><code class="symbol">SPI_ERROR_TRANSACTION</code></span></dt><dd><p>при попытке выполнить команду управления транзакциями (<code class="command">BEGIN</code>, <code class="command">COMMIT</code>, <code class="command">ROLLBACK</code>, <code class="command">SAVEPOINT</code>, <code class="command">PREPARE TRANSACTION</code>, <code class="command">COMMIT PREPARED</code>, <code class="command">ROLLBACK PREPARED</code> или любую их вариацию)</p></dd><dt><span class="term"><code class="symbol">SPI_ERROR_OPUNKNOWN</code></span></dt><dd><p>если тип команды неизвестен (такого быть не должно)</p></dd><dt><span class="term"><code class="symbol">SPI_ERROR_UNCONNECTED</code></span></dt><dd><p>если вызывается из неподключённой функции на C</p></dd></dl></div></div><div class="refsect1" id="id-1.8.12.8.4.8"><h2>Замечания</h2><p>Все функции SPI, выполняющие запросы, заполняют и <code class="varname">SPI_processed</code>, и <code class="varname">SPI_tuptable</code> (только указатель, но не содержимое структуры). Сохраните эти две глобальные переменные в локальных переменных функции на C, если хотите обращаться к таблице результата <code class="function">SPI_execute</code> или другой функции, выполняющей запрос, в нескольких вызовах процедуры.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="spi-spi-finish.html" title="SPI_finish">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="spi-interface.html" title="47.1. Интерфейсные функции">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="spi-spi-exec.html" title="SPI_exec">След.</a></td></tr><tr><td width="40%" align="left" valign="top">SPI_finish </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> SPI_exec</td></tr></table></div></body></html>