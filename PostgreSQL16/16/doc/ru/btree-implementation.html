<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>67.4. Реализация</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="btree-support-funcs.html" title="67.3. Опорные функции B-деревьев" /><link rel="next" href="gist.html" title="Глава 68. Индексы GiST" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">67.4. Реализация</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="btree-support-funcs.html" title="67.3. Опорные функции B-деревьев">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="btree.html" title="Глава 67. Индексы B-деревья">Наверх</a></td><th width="60%" align="center">Глава 67. Индексы B-деревья</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="gist.html" title="Глава 68. Индексы GiST">След.</a></td></tr></table><hr /></div><div class="sect1" id="BTREE-IMPLEMENTATION"><div class="titlepage"><div><div><h2 class="title" style="clear: both">67.4. Реализация <a href="#BTREE-IMPLEMENTATION" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="btree-implementation.html#BTREE-STRUCTURE">67.4.1. Структура B-дерева</a></span></dt><dt><span class="sect2"><a href="btree-implementation.html#BTREE-DELETION">67.4.2. Восходящее удаление индексных кортежей</a></span></dt><dt><span class="sect2"><a href="btree-implementation.html#BTREE-DEDUPLICATION">67.4.3. Исключение дубликатов</a></span></dt></dl></div><p>В этом разделе освещаются детали реализации индекса-B-дерева, знание которых может быть полезно для специалистов. В дереве исходного кода имеется файл <code class="filename">src/backend/access/nbtree/README</code>, в котором реализация B-дерева рассматривается ещё глубже, на уровне алгоритмов.</p><div class="sect2" id="BTREE-STRUCTURE"><div class="titlepage"><div><div><h3 class="title">67.4.1. Структура B-дерева <a href="#BTREE-STRUCTURE" class="id_link">#</a></h3></div></div></div><p>Индексы-B-деревья в <span class="productname">PostgreSQL</span> представляют собой многоуровневые иерархические структуры, в которых каждый уровень дерева может использоваться как двусвязный список страниц. Единственная метастраница индекса хранится в фиксированной позиции в начале первого файла сегмента индекса. Все остальные страницы делятся на внутренние и на листовые. Листовые страницы находятся на самом нижнем уровне дерева. Все более высокие уровни состоят из внутренних страниц. Листовая страница содержит кортежи, указывающие на строки в таблице, а внутренняя страница — кортежи, указывающие на следующий уровень в дереве. Обычно листовые страницы составляют около 99% всех страниц индекса. И для тех, и для других страниц используется один стандартный формат, описанный в <a class="xref" href="storage-page-layout.html" title="73.6. Компоновка страницы базы данных">Разделе 73.6</a>.</p><p>Новые листовые страницы добавляются в B-дерево когда существующая листовая страница не может вместить новый поступающий кортеж. При этом выполняется операция <em class="firstterm">разделения страницы</em>, освобождающая место на переполнившейся странице, перенося подмножество изначально содержащихся на ней элементов на новую страницу. При разделении страницы в её родительскую страницу также должна быть добавлена <em class="firstterm">ссылка вниз</em>, что может потребовать произвести разделение и этой родительской страницы. Разделение страниц <span class="quote">«<span class="quote">каскадно поднимается вверх</span>»</span> рекурсивным образом. Когда же и корневая страница не может вместить новую ссылку вниз, производится операция <em class="firstterm">разделения корневой страницы</em>. При этом в структуру дерева добавляется новый уровень, на котором оказывается новая корневая страница, стоящая над той, что была корневой ранее.</p></div><div class="sect2" id="BTREE-DELETION"><div class="titlepage"><div><div><h3 class="title">67.4.2. Восходящее удаление индексных кортежей <a href="#BTREE-DELETION" class="id_link">#</a></h3></div></div></div><p>В реализации индексов-B-деревьев не учитывается, что в среде MVCC может быть несколько версий одной логической строки таблицы; для индекса каждый кортеж является независимым объектом, требующим отдельного элемента в индексе. Кортежи <span class="quote">«<span class="quote">отработанных версий</span>»</span> иногда могут накапливаться, что чревато задержками и замедлением при выполнении запросов. Это обычно происходит при нагрузке с преобладанием <code class="command">UPDATE</code>, когда для большинства отдельных операций изменения данных нельзя применить оптимизацию <a class="link" href="storage-hot.html" title="73.7. Кортежи только в куче (Heap-Only Tuples, HOT)"><acronym class="acronym">HOT</acronym></a>. Изменение значения даже одного индексируемого столбца во время <code class="command">UPDATE</code> <span class="emphasis"><em>всегда</em></span> требует добавления нового набора индексных кортежей — отдельного кортежа для <span class="emphasis"><em>каждого</em></span> индекса в таблице. Более того, обратите внимание, что новые кортежи требуются и для тех индексов, которые не были <span class="quote">«<span class="quote">логически изменены</span>»</span> командой <code class="command">UPDATE</code>. Во всех индексах будут нужны дополнительные физические кортежи, указывающие на последнюю версию строки в таблице. Каждый новый кортеж в каждом индексе, как правило, должен сосуществовать с исходным подвергшимся изменению кортежем в течение короткого периода времени (обычно недолго после фиксации транзакции <code class="command">UPDATE</code>).</p><p>В индексах-B-деревьях постепенно удаляются кортежи отработанных версий в ходе процедуры <em class="firstterm">восходящего удаления индексных кортежей</em>. Каждый проход процедуры удаления вызывается, когда ожидается, что произойдёт <span class="quote">«<span class="quote">разделение страниц из-за отрабатывания версий</span>»</span>. Это касается только тех индексов, которые не были логически изменены операторами <code class="command">UPDATE</code>, так как именно в них возможно концентрированное накопление устаревших версий на определённых страницах. Реализация обычно старается избежать разделения страниц, хотя вполне возможно, что определённые решения на её уровне не позволят идентифицировать и удалить ни одного мусорного кортежа в индексе (в этом случае проблема размещения нового кортежа на заполненной листовой странице решается путём разделения страницы или в результате исключения дубликатов). Большое количество версий каждой отдельной логической строки, которое нужно прочитать при каждом сканировании индекса, является важным отрицательным фактором общей производительности и скорости отклика системы. Процедура восходящего удаления индексных кортежей выбирает на листовой странице предположительно мусорные кортежи на основании <span class="emphasis"><em>качественных</em></span> характеристик, определяемых логическими строками и версиями. Это отличает её от <span class="quote">«<span class="quote">нисходящей</span>»</span> уборки индекса, выполняемой процессами автоочистки, которая запускается при превышении определённых <span class="emphasis"><em>количественных</em></span> пороговых значений на уровне таблицы (см. <a class="xref" href="routine-vacuuming.html#AUTOVACUUM" title="25.1.6. Демон автоочистки">Подраздел 25.1.6</a>).</p><div class="note"><h3 class="title">Примечание</h3><p>Не все операции удаления, выполняемые в индексах-B-деревьях, реализуются процедурой восходящего удаления. Существует другая категория таких операций: <em class="firstterm">простое удаление индексных кортежей</em>. Это отложенная операция обслуживания, удаляющая индексные кортежи, о которых известно, что их можно безопасно стереть (то есть те, для идентификаторов которых установлен бит <code class="literal">LP_DEAD</code>). Как и восходящее удаление индексных кортежей, простое удаление происходит в тот момент, когда ожидается разделение страницы, для предотвращения этого разделения.</p><p>Простое удаление выполняется по возможности в том смысле, что оно может произойти только при условии, что в результате недавних сканирований индекса были установлены биты <code class="literal">LP_DEAD</code> для обработанных элементов. До <span class="productname">PostgreSQL</span> 14 единственной категорией операций удаления в B-дереве было простое удаление. Основное различие между простым и восходящим удалением заключается в том, что только первое обусловлено активностью сканирований индекса, а второе ориентировано именно на активность отрабатывания версий, вызываемую командами <code class="command">UPDATE</code>, которые не изменяют логически индексированные столбцы.</p></div><p>При определённой нагрузке восходящее удаление индексных кортежей выполняет основную работу по уборке мусорных кортежей из индексов. Такой эффект ожидается для любого индекса-B-дерева, который в значительной мере затрагивается активностью отрабатывания версий из-за команд <code class="command">UPDATE</code>, почти никогда не изменяющих логически столбцы, покрываемые индексом. Среднее и наибольшее количество версий для логической строки может поддерживаться на низком уровне исключительно за счёт постоянных точечных проходов удаления. Вполне возможно, что размер определённых индексов на диске никогда не увеличится ни на одну страницу/блок, несмотря на <span class="emphasis"><em>постоянное</em></span> отрабатывание версий, вызываемое командами <code class="command">UPDATE</code>. Но даже в этом случае в конце концов потребуется полная <span class="quote">«<span class="quote">зачистка</span>»</span> индекса процедурой <code class="command">VACUUM</code> (обычно запускаемой в рабочем процессе автоочистки) как часть <span class="emphasis"><em>совместной</em></span> уборки таблицы и всех её индексов.</p><p>В отличие от <code class="command">VACUUM</code>, восходящее удаление не даёт никаких надёжных гарантий относительно возраста старейшего мусорного индексного кортежа. Ни в одном индексе не допускается сохранение <span class="quote">«<span class="quote">плавающих мусорных</span>»</span> кортежей, ставших мёртвыми до консервативной точки отсечения, являющейся общей для таблицы и всех её индексов. Этот фундаментальный инвариант на уровне таблицы позволяет обеспечивать безопасную циркуляцию табличных идентификаторов (<acronym class="acronym">TID</acronym>). Именно таким образом разные логические строки могут повторно использовать один и тот же идентификатор с течением времени (хотя это невозможно для двух логических строк, время жизни которых укладывается в один и тот же цикл <code class="command">VACUUM</code>).</p></div><div class="sect2" id="BTREE-DEDUPLICATION"><div class="titlepage"><div><div><h3 class="title">67.4.3. Исключение дубликатов <a href="#BTREE-DEDUPLICATION" class="id_link">#</a></h3></div></div></div><p>Дубликатом называется кортеж на листовой странице (кортеж, указывающий на строку таблицы), у которого <span class="emphasis"><em>все</em></span> ключевые столбцы индекса имеют значения, соответствующие значениям столбцов из как минимум одного другого кортежа на листовой странице в том же индексе. Дублирующиеся кортежи довольно часто встречаются на практике. В индексах-B-деревьях такие дубликаты могут представляться особым экономичным образом при включении дополнительного механизма — <em class="firstterm">исключения дубликатов</em>.</p><p>Работа этого механизма заключается в периодическом объединении групп дублирующихся кортежей и формировании одного кортежа со <em class="firstterm">списком идентификаторов</em> для каждой группы. В таком представлении значения ключевых столбцов хранятся в единственном экземпляре, а за ними идёт отсортированный массив идентификаторов <acronym class="acronym">TID</acronym>, указывающих на строки в таблице. Это существенно уменьшает размер хранящихся индексов, в которых каждое значение (или каждое уникальное сочетание значений столбцов) появляется в среднем несколько раз. В результате может значительно увеличиться скорость выполнения запросов, а также могут сократиться издержки, связанные с регулярной очисткой индексов.</p><div class="note"><h3 class="title">Примечание</h3><p>Исключение дубликатов в B-дереве работает эффективно и с <span class="quote">«<span class="quote">дубликатами</span>»</span>, содержащими значение NULL, несмотря на то, что значения NULL не считаются равными между собой согласно операторам <code class="literal">=</code>, входящим в классы операторов btree. Это объясняется тем, что с точки зрения реализации, работающей с внутренним представлением структуры B-дерева, NULL является просто одним из элементов множества всех возможных значений в индексе.</p></div><p>Процесс исключения дубликатов осуществляется по необходимости, когда вставляется новый элемент, не умещающийся на существующей листовой странице, но только тогда, когда удаление индексного кортежа не может освободить достаточно места для нового элемента (обычно удаление недолго рассматривается, а затем пропускается). В отличие от кортежей со списками идентификаторов GIN, в B-дереве эти кортежи не должны расширяться при каждом добавлении нового дубликата; они просто образуют другое физическое представление исходного логического содержимого листовой страницы. При таком подходе обеспечивается стабильная производительность при смешанной нагрузке чтения-записи. Исключение дубликатов должно дать как минимум заметное увеличение производительности для большинства клиентских приложений. По умолчанию оно включено.</p><p>Команды <code class="command">CREATE INDEX</code> и <code class="command">REINDEX</code> также выполняют исключение дубликатов, создавая кортежи со списками идентификаторов, но применяют несколько другую стратегию. Каждая группа дублирующихся обычных кортежей, обнаруженных в отсортированных данных, преобразуется в кортеж со списком идентификаторов <span class="emphasis"><em>до того</em></span>, как данные добавляются в текущую листовую страницу. При этом в каждый такой кортеж упаковывается как можно больше идентификаторов (<acronym class="acronym">TID</acronym>). После этого листовые страницы записываются обычным способом, без дополнительного прохода для исключения дубликатов. Эта стратегия подходит для команд <code class="command">CREATE INDEX</code> и <code class="command">REINDEX</code>, так как они обрабатывают все данные сразу.</p><p>Если же в профиле нагрузки преобладает запись и исключение дубликатов не приносит выигрыша ввиду отсутствия или небольшого числа дублирующихся значений, этот механизм может породить небольшие постоянные издержки (если он не отключён). В таких случаях его можно отключить для отдельных индексов с помощью параметра хранения <code class="literal">deduplicate_items</code>. При нагрузке только на чтение никакие дополнительные издержки не возникают, так как кортежи со списком идентификаторов читаются так же эффективно, как и кортежи в стандартном представлении. Поэтому чаще всего отключение этого механизма не будет полезным.</p><p>Исключение дубликатов иногда может использоваться для уникальных индексов (а также уникальных ограничений). Благодаря этому дополнительные дубликаты отработанных версий могут временно <span class="quote">«<span class="quote">поглощаться</span>»</span> листовыми страницами. Исключение дубликатов в уникальных индексах дополняет восходящее удаление индексных кортежей, особенно в тех случаях, когда длительная транзакция держит снимок, препятствующий сборке мусора. Тем самым выигрывается время для восстановления эффективности стратегии восходящего удаления индексных кортежей. Откладывание разделения страниц до естественного завершения одной длительной транзакции позволяет успешно произвести проход восходящего удаления, который ранее был невозможен.</p><div class="tip"><h3 class="title">Подсказка</h3><p>Для определения необходимости провести процедуру исключения дубликатов в уникальном индексе применяются дополнительные соображения. В таких индексах как правило можно перейти сразу к разделению листовой страницы, не расходуя лишние циклы на бесполезные проходы в поиске дубликатов. Если вас беспокоят возможные издержки, которые могут быть связаны с исключением дубликатов, вы можете установить значение <code class="literal">deduplicate_items = off</code> для отдельных индексов. Однако его вполне можно оставить включённым и для уникальных индексов.</p></div><p>Исключение дубликатов может применяться не всегда ввиду ограничений на уровне реализации. Возможность его применения определяется во время выполнения <code class="command">CREATE INDEX</code> или <code class="command">REINDEX</code>.</p><p>Учтите, что исключение дубликатов считается небезопасным и не может применяться в следующих случаях, когда возможны семантические различия равных значений:</p><p>
   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Исключение дубликатов не может применяться с типами <code class="type">text</code>, <code class="type">varchar</code> и <code class="type">char</code> в случае использования <span class="emphasis"><em>недетерминированных</em></span> правил сортировки, так как в равных значениях должны сохраняться возможные различия в регистре и диакритических знаках.</p></li><li class="listitem"><p>Исключение дубликатов невозможно с типом <code class="type">numeric</code>, так как для равных значений должен сохраняться числовой масштаб, который может быть разным.</p></li><li class="listitem"><p>Исключение дубликатов не может применяться с типом <code class="type">jsonb</code>, так как внутри класса операторов B-дерева <code class="type">jsonb</code> используется тип <code class="type">numeric</code>.</p></li><li class="listitem"><p>Исключение дубликатов невозможно для типов <code class="type">float4</code> и <code class="type">float8</code>. В этих типах имеются разные представления значений <code class="literal">-0</code> и <code class="literal">0</code>, которые при этом считаются равными. Однако отличие между ними должно сохраняться.</p></li></ul></div><p>
  </p><p>Имеется ещё одно ограничение на уровне реализации, которое может быть снято в будущих версиях <span class="productname">PostgreSQL</span>:</p><p>
   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Исключение дубликатов невозможно с типами-контейнерами (это составные, диапазонные типы, а также массивы).</p></li></ul></div><p>
  </p><p>Есть ещё одно ограничение на уровне реализации, действующее вне зависимости от применяемого класса операторов или правила сортировки:</p><p>
   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Исключение дубликатов не может применяться в индексах с <code class="literal">INCLUDE</code>.</p></li></ul></div><p>
  </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="btree-support-funcs.html" title="67.3. Опорные функции B-деревьев">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="btree.html" title="Глава 67. Индексы B-деревья">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="gist.html" title="Глава 68. Индексы GiST">След.</a></td></tr><tr><td width="40%" align="left" valign="top">67.3. Опорные функции B-деревьев </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> Глава 68. Индексы GiST</td></tr></table></div></body></html>