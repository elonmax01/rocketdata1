<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>10.5. UNION, CASE и связанные конструкции</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="typeconv-query.html" title="10.4. Хранимое значение" /><link rel="next" href="typeconv-select.html" title="10.6. Выходные столбцы SELECT" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">10.5. <code class="literal">UNION</code>, <code class="literal">CASE</code> и связанные конструкции</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="typeconv-query.html" title="10.4. Хранимое значение">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="typeconv.html" title="Глава 10. Преобразование типов">Наверх</a></td><th width="60%" align="center">Глава 10. Преобразование типов</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="typeconv-select.html" title="10.6. Выходные столбцы SELECT">След.</a></td></tr></table><hr /></div><div class="sect1" id="TYPECONV-UNION-CASE"><div class="titlepage"><div><div><h2 class="title" style="clear: both">10.5. <code class="literal">UNION</code>, <code class="literal">CASE</code> и связанные конструкции <a href="#TYPECONV-UNION-CASE" class="id_link">#</a></h2></div></div></div><a id="id-1.5.9.10.2" class="indexterm"></a><a id="id-1.5.9.10.3" class="indexterm"></a><a id="id-1.5.9.10.4" class="indexterm"></a><a id="id-1.5.9.10.5" class="indexterm"></a><a id="id-1.5.9.10.6" class="indexterm"></a><a id="id-1.5.9.10.7" class="indexterm"></a><p>SQL-конструкция <code class="literal">UNION</code> взаимодействует с системой типов, так как ей приходится объединять значения возможно различных типов в единый результирующий набор. Алгоритм разрешения типов при этом применяется независимо к каждому выходному столбцу запроса. Конструкции <code class="literal">INTERSECT</code> и <code class="literal">EXCEPT</code> сопоставляют различные типы подобно <code class="literal">UNION</code>. По такому же алгоритму сопоставляют типы выражений и определяют тип своего результата некоторые другие конструкции, включая <code class="literal">CASE</code>, <code class="literal">ARRAY</code>, <code class="literal">VALUES</code> и функции <code class="function">GREATEST</code> и <code class="function">LEAST</code>.</p><div class="procedure" id="id-1.5.9.10.9"><p class="title"><strong>Разрешение типов для <code class="literal">UNION</code>, <code class="literal">CASE</code> и связанных конструкций</strong></p><ol class="procedure" type="1"><li class="step"><p>Если все данные одного типа и это не тип <code class="type">unknown</code>, выбрать его.</p></li><li class="step"><p>Если тип данных — домен, далее считать их типом базовый тип домена. <a href="#ftn.id-1.5.9.10.9.3.1.1" class="footnote"><sup class="footnote" id="id-1.5.9.10.9.3.1.1">[12]</sup></a></p></li><li class="step"><p>Если все данные типа <code class="type">unknown</code>, выбрать для результата тип <code class="type">text</code> (предпочитаемый для категории string). В противном случае значения <code class="type">unknown</code> для остальных правил игнорируются.</p></li><li class="step"><p>Если известные типы входных данных оказываются не из одной категории, констатировать неудачу.</p></li><li class="step"><p>Выбрать первый известный тип данных в качестве типа-кандидата, затем рассмотреть все остальные известные типы данных, слева направо. <a href="#ftn.id-1.5.9.10.9.6.1.1" class="footnote"><sup class="footnote" id="id-1.5.9.10.9.6.1.1">[13]</sup></a> Если ранее выбранный тип может быть неявно преобразован к другому типу, но преобразовать второй в первый нельзя, выбрать второй тип в качестве нового кандидата. Затем продолжать рассмотрение последующих данных. Если на любом этапе этого процесса выбирается предпочитаемый тип, следующие данные больше не рассматриваются.</p></li><li class="step"><p>Привести все данные к окончательно выбранному типу. Констатировать неудачу, если неявное преобразование из типа входных данных в выбранный тип невозможно.</p></li></ol></div><p>Ниже это проиллюстрировано на примерах.</p><div class="example" id="id-1.5.9.10.11"><p class="title"><strong>Пример 10.10. Разрешение типов с частичным определением в Union</strong></p><div class="example-contents"><pre class="screen">
SELECT text 'a' AS "text" UNION SELECT 'b';

 text
------
 a
 b
(2 rows)
</pre><p> В данном случае константа <code class="literal">'b'</code> неизвестного типа будет преобразована в тип <code class="type">text</code>.</p></div></div><br class="example-break" /><div class="example" id="id-1.5.9.10.12"><p class="title"><strong>Пример 10.11. Разрешение типов в простом объединении</strong></p><div class="example-contents"><pre class="screen">
SELECT 1.2 AS "numeric" UNION SELECT 1;

 numeric
---------
       1
     1.2
(2 rows)
</pre><p> Константа <code class="literal">1.2</code> имеет тип <code class="type">numeric</code> и целочисленное значение <code class="literal">1</code> может быть неявно приведено к типу <code class="type">numeric</code>, так что используется этот тип.</p></div></div><br class="example-break" /><div class="example" id="id-1.5.9.10.13"><p class="title"><strong>Пример 10.12. Разрешение типов в противоположном объединении</strong></p><div class="example-contents"><pre class="screen">
SELECT 1 AS "real" UNION SELECT CAST('2.2' AS REAL);

 real
------
    1
  2.2
(2 rows)
</pre><p> Здесь значение типа <code class="type">real</code> нельзя неявно привести к <code class="type">integer</code>, но <code class="type">integer</code> можно неявно привести к <code class="type">real</code>, поэтому типом результата объединения будет <code class="type">real</code>.</p></div></div><br class="example-break" /><div class="example" id="id-1.5.9.10.14"><p class="title"><strong>Пример 10.13. Разрешение типов во вложенном объединении</strong></p><div class="example-contents"><pre class="screen">
SELECT NULL UNION SELECT NULL UNION SELECT 1;

ERROR:  UNION types text and integer cannot be matched
</pre><p> Эта ошибка возникает из-за того, что <span class="productname">PostgreSQL</span> воспринимает множественные <code class="literal">UNION</code> как пары с вложенными операциями, то есть как запись </p><pre class="screen">
(SELECT NULL UNION SELECT NULL) UNION SELECT 1;
</pre><p> Внутренний <code class="literal">UNION</code> разрешается как выдающий тип <code class="type">text</code>, согласно правилам, приведённым выше. Затем внешний <code class="literal">UNION</code> получает на вход типы <code class="type">text</code> и <code class="type">integer</code>, что и приводит к показанной ошибке. Эту проблему можно устранить, сделав так, чтобы у самого левого <code class="literal">UNION</code> минимум с одной стороны были данные желаемого типа результата.</p><p>Операции <code class="literal">INTERSECT</code> и <code class="literal">EXCEPT</code> также разрешаются по парам. Однако остальные конструкции, описанные в этом разделе, рассматривают все входные данные сразу.</p></div></div><br class="example-break" /><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.id-1.5.9.10.9.3.1.1" class="footnote"><p><a href="#id-1.5.9.10.9.3.1.1" class="para"><sup class="para">[12] </sup></a>Так же, как домены воспринимаются при выборе операторов и функций, доменные типы могут сохраняться в конструкции <code class="literal">UNION</code> или подобной, если пользователь позаботится о том, чтобы все входные данные приводились к этому типу явно или неявно. В противном случае будет использоваться базовый тип домена.</p></div><div id="ftn.id-1.5.9.10.9.6.1.1" class="footnote"><p><a href="#id-1.5.9.10.9.6.1.1" class="para"><sup class="para">[13] </sup></a>По историческим причинам в конструкции <code class="literal">CASE</code> выражение в предложении <code class="literal">ELSE</code> (если оно есть) обрабатывается как <span class="quote">«<span class="quote">первое</span>»</span>, а предложения <code class="literal">THEN</code> рассматриваются после. Во всех остальных случаях, <span class="quote">«<span class="quote">слева направо</span>»</span> означает порядок, в котором выражения действительно идут в тексте запроса.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="typeconv-query.html" title="10.4. Хранимое значение">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="typeconv.html" title="Глава 10. Преобразование типов">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="typeconv-select.html" title="10.6. Выходные столбцы SELECT">След.</a></td></tr><tr><td width="40%" align="left" valign="top">10.4. Хранимое значение </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 10.6. Выходные столбцы <code class="literal">SELECT</code></td></tr></table></div></body></html>