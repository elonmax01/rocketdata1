<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Глава 63. Определение интерфейса для табличных методов доступа</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="geqo-biblio.html" title="62.4. Дополнительные источники информации" /><link rel="next" href="indexam.html" title="Глава 64. Определение интерфейса для индексных методов доступа" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">Глава 63. Определение интерфейса для табличных методов доступа</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="geqo-biblio.html" title="62.4. Дополнительные источники информации">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="internals.html" title="Часть VII. Внутреннее устройство">Наверх</a></td><th width="60%" align="center">Часть VII. Внутреннее устройство</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="indexam.html" title="Глава 64. Определение интерфейса для индексных методов доступа">След.</a></td></tr></table><hr /></div><div class="chapter" id="TABLEAM"><div class="titlepage"><div><div><h2 class="title">Глава 63. Определение интерфейса для табличных методов доступа</h2></div></div></div><a id="id-1.10.14.2" class="indexterm"></a><a id="id-1.10.14.3" class="indexterm"></a><p>В этой главе описывается интерфейс между ядром системы <span class="productname">PostgreSQL</span> и <em class="firstterm">табличными методами доступа</em>, которые управляют хранением таблиц. Ядро системы не знает об этих метода доступа ничего, кроме того, что описано здесь; благодаря этому можно реализовывать абсолютно новые типы методов в рамках расширений.</p><p>Каждый табличный метод доступа описывается строкой в системном каталоге <a class="link" href="catalog-pg-am.html" title="53.3. pg_am"><code class="structname">pg_am</code></a>. В записи <code class="structname">pg_am</code> указывается имя и <em class="firstterm">функция-обработчик</em> для этого табличного метода. Эти записи могут создаваться и удаляться командами SQL <a class="xref" href="sql-create-access-method.html" title="CREATE ACCESS METHOD"><span class="refentrytitle">CREATE ACCESS METHOD</span></a> и <a class="xref" href="sql-drop-access-method.html" title="DROP ACCESS METHOD"><span class="refentrytitle">DROP ACCESS METHOD</span></a>.</p><p>Функция-обработчик табличного метода доступа должна объявляться как принимающая один аргумент типа <code class="type">internal</code> и возвращающая псевдотип <code class="type">table_am_handler</code>. Аргумент в данном случае фиктивный и нужен только для того, чтобы эту функцию нельзя было вызывать непосредственно из команд SQL. Возвращать эта функция должна указатель на структуру типа <code class="structname">TableAmRoutine</code>, содержащую всё, что нужно знать коду ядра, чтобы использовать этот метод доступа. Возвращаемое значение должно существовать всё время жизни сервера, что обычно достигается объявлением глобальной переменной <code class="literal">static const</code>. Структура <code class="structname">TableAmRoutine</code>, также называемая структурой API метода доступа, определяет поведение метода доступа через обработчики. Эти обработчики задаются как обычные указатели на функции уровня C, поэтому они не видны и не доступны на уровне SQL. Все обработчики и их свойства задаются в структуре <code class="structname">TableAmRoutine</code>, в определении которой можно найти комментарии с требованиями к ним. Для большинства обработчиков созданы функции-обёртки, документированные с точки зрения пользователя (а не разработчика) табличного метода доступа. Более подробно это описывается в файле <a class="ulink" href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/include/access/tableam.h;hb=HEAD" target="_top"><code class="filename">src/include/access/tableam.h</code></a>.</p><p>Чтобы реализовать метод доступа (МД), разработчик обычно должен создать для него специальный слот таблицы кортежей (см. <a class="ulink" href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/include/executor/tuptable.h;hb=HEAD" target="_top"><code class="filename">src/include/executor/tuptable.h</code></a>), позволяющий коду снаружи метода доступа иметь ссылки на кортежи данного МД и обращаться к столбцам кортежа.</p><p>В настоящее время способ хранения данных, определяемый МД, может быть практически любым. Например, МД может по своему усмотрению использовать кеш общих буферов. Если этот кеш используется, скорее всего имеет смысл применять и стандартную компоновку страницы, описанную в <a class="xref" href="storage-page-layout.html" title="73.6. Компоновка страницы базы данных">Разделе 73.6</a>.</p><p>Одним довольно серьёзным ограничением API табличных методов доступа является то, что в настоящее время МД может поддерживать модификации данных и/или индексы, только если для каждого кортежа имеется идентификатор (<acronym class="acronym">TID</acronym>), состоящий из номера блока и номера элемента (см. также <a class="xref" href="storage-page-layout.html" title="73.6. Компоновка страницы базы данных">Раздел 73.6</a>). Компоненты <acronym class="acronym">TIDs</acronym> в принципе могут иметь значение, отличное от принятого для метода <code class="literal">heap</code>, но если желательно поддерживать сканирование по битовой карте (вообще это не обязательно), номер блока должен обеспечивать локальность данных.</p><p>Для восстановления при сбое МД может использовать <a class="link" href="wal.html" title="Глава 30. Надёжность и журнал предзаписи"><acronym class="acronym">WAL</acronym></a> сервера или собственную реализацию журнала. В случае использования <acronym class="acronym">WAL</acronym> в МД можно задействовать <a class="link" href="generic-wal.html" title="Глава 65. Унифицированные записи WAL">Унифицированные записи WAL</a> или реализовать <a class="link" href="custom-rmgr.html" title="Глава 66. Пользовательские менеджеры ресурсов WAL">Пользовательский журнал ресурсов WAL</a>.</p><p>Чтобы реализовать поддержку транзакций способом, позволяющим обращаться к различным табличным методам в одной транзакции, скорее всего потребуется интегрировать её в механизм <code class="filename">src/backend/access/transam/xlog.c</code>.</p><p>Разработчик нового <code class="literal">табличного метода доступа</code> может почерпнуть другую полезную информацию из реализации существующего метода <code class="literal">heap</code>, находящейся в <code class="filename">src/backend/access/heap/heapam_handler.c</code>.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="geqo-biblio.html" title="62.4. Дополнительные источники информации">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="internals.html" title="Часть VII. Внутреннее устройство">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="indexam.html" title="Глава 64. Определение интерфейса для индексных методов доступа">След.</a></td></tr><tr><td width="40%" align="left" valign="top">62.4. Дополнительные источники информации </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> Глава 64. Определение интерфейса для индексных методов доступа</td></tr></table></div></body></html>