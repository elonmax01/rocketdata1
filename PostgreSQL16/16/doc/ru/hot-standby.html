<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>27.4. Горячий резерв</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="warm-standby-failover.html" title="27.3. Отработка отказа" /><link rel="next" href="monitoring.html" title="Глава 28. Мониторинг работы СУБД" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">27.4. Горячий резерв</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="warm-standby-failover.html" title="27.3. Отработка отказа">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="high-availability.html" title="Глава 27. Отказоустойчивость, балансировка нагрузки и репликация">Наверх</a></td><th width="60%" align="center">Глава 27. Отказоустойчивость, балансировка нагрузки и репликация</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="monitoring.html" title="Глава 28. Мониторинг работы СУБД">След.</a></td></tr></table><hr /></div><div class="sect1" id="HOT-STANDBY"><div class="titlepage"><div><div><h2 class="title" style="clear: both">27.4. Горячий резерв <a href="#HOT-STANDBY" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="hot-standby.html#HOT-STANDBY-USERS">27.4.1. Обзор на уровне пользователя</a></span></dt><dt><span class="sect2"><a href="hot-standby.html#HOT-STANDBY-CONFLICT">27.4.2. Обработка конфликтов запросов</a></span></dt><dt><span class="sect2"><a href="hot-standby.html#HOT-STANDBY-ADMIN">27.4.3. Обзор административной части</a></span></dt><dt><span class="sect2"><a href="hot-standby.html#HOT-STANDBY-PARAMETERS">27.4.4. Ссылки на параметры горячего резерва</a></span></dt><dt><span class="sect2"><a href="hot-standby.html#HOT-STANDBY-CAVEATS">27.4.5. Ограничения</a></span></dt></dl></div><a id="id-1.6.14.18.2" class="indexterm"></a><p>Термин «горячий резерв» используется для описания возможности подключаться к серверу и выполнять запросы на чтение, в то время как сервер находится в режиме резерва или восстановления архива. Это полезно и для целей репликации, и для восстановления желаемого состояния из резервной копии с высокой точностью. Так же термин «горячий резерв» описывает способность сервера переходить из режима восстановления к обычной работе, в то время как пользователи продолжают выполнять запросы и/или их соединения остаются открытыми.</p><p>В режиме горячего резерва запросы выполняются примерно так же, как и в обычном режиме, с некоторыми отличиями в использовании и администрировании, описанными ниже.</p><div class="sect2" id="HOT-STANDBY-USERS"><div class="titlepage"><div><div><h3 class="title">27.4.1. Обзор на уровне пользователя <a href="#HOT-STANDBY-USERS" class="id_link">#</a></h3></div></div></div><p>Когда параметр <a class="xref" href="runtime-config-replication.html#GUC-HOT-STANDBY">hot_standby</a> на резервном сервере установлен в true, то он начинает принимать соединения сразу как только система придёт в согласованное состояние в процессе восстановления. Для таких соединений будет разрешено только чтение, запись невозможна даже во временные таблицы.</p><p>Для того, чтобы данные с ведущего сервера были получены на резервном, требуется некоторое время. Таким образом, имеется измеряемая задержка между ведущим и резервным серверами. Поэтому запуск одинаковых запросов примерно в одно время на ведущем и резервном серверах может вернуть разный результат. Можно сказать, что данные на резервном сервере <em class="firstterm">в конечном счёте согласуются</em> с ведущим. После того как запись о зафиксированной транзакции воспроизводится на резервном сервере, изменения, совершённые в этой транзакции, становится видны в любых последующих снимках данных на резервном сервере. Снимок может быть сделан в начале каждого запроса или в начале каждой транзакции в зависимости от уровня изоляции транзакции. Более подробно см. <a class="xref" href="transaction-iso.html" title="13.2. Изоляция транзакций">Раздел 13.2</a>.</p><p>Транзакции, запущенные в режиме горячего резерва, могут выполнять следующие команды: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Доступ к данным: <code class="command">SELECT</code>, <code class="command">COPY TO</code></p></li><li class="listitem"><p>Команды для работы с курсором: <code class="command">DECLARE</code>, <code class="command">FETCH</code>, <code class="command">CLOSE</code></p></li><li class="listitem"><p>Параметры: <code class="command">SHOW</code>, <code class="command">SET</code>, <code class="command">RESET</code></p></li><li class="listitem"><p>Команды явного управления транзакциями: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><code class="command">BEGIN</code>, <code class="command">END</code>, <code class="command">ABORT</code>, <code class="command">START TRANSACTION</code></p></li><li class="listitem"><p><code class="command">SAVEPOINT</code>, <code class="command">RELEASE</code>, <code class="command">ROLLBACK TO SAVEPOINT</code></p></li><li class="listitem"><p>Блок <code class="command">EXCEPTION</code> и другие внутренние подчиненные транзакции</p></li></ul></div></li><li class="listitem"><p><code class="command">LOCK TABLE</code>, только когда исполняется в явном виде в следующем режиме: <code class="literal">ACCESS SHARE</code>, <code class="literal">ROW SHARE</code> или <code class="literal">ROW EXCLUSIVE</code>.</p></li><li class="listitem"><p>Планы и ресурсы: <code class="command">PREPARE</code>, <code class="command">EXECUTE</code>, <code class="command">DEALLOCATE</code>, <code class="command">DISCARD</code></p></li><li class="listitem"><p>Дополнения и расширения: <code class="command">LOAD</code></p></li><li class="listitem"><p>
       <code class="command">UNLISTEN</code>
      </p></li></ul></div><p>Транзакции, запущенные в режиме горячего резерва, никогда не получают ID транзакции и не могут быть записаны в журнал предзаписи. Поэтому при попытке выполнить следующие действия возникнут ошибки: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Команды манипуляции данными (DML): <code class="command">INSERT</code>, <code class="command">UPDATE</code>, <code class="command">DELETE</code>, <code class="command">MERGE</code>, <code class="command">COPY FROM</code>, <code class="command">TRUNCATE</code>. Следует отметить, что нет разрешённых действий, которые приводили бы к срабатыванию триггера во время исполнения на резервном сервере. Это ограничение так же касается и временных таблиц, так как строки таблицы не могут быть прочитаны или записаны без обращения к ID транзакции, что в настоящее время не возможно в среде горячего резерва.</p></li><li class="listitem"><p>Команды определения данных (DDL): <code class="command">CREATE</code>, <code class="command">DROP</code>, <code class="command">ALTER</code>, <code class="command">COMMENT</code>. Эти ограничения так же относятся и к временным таблицам, так как операции могут потребовать обновления таблиц системных каталогов.</p></li><li class="listitem"><p><code class="command">SELECT ... FOR SHARE | UPDATE</code>, так как блокировка строки не может быть проведена без обновления соответствующих файлов данных.</p></li><li class="listitem"><p>Правила для выражений <code class="command">SELECT</code>, которые приводят к выполнению команд DML.</p></li><li class="listitem"><p><code class="command">LOCK</code> которая явно требует режим более строгий чем <code class="literal">ROW EXCLUSIVE MODE</code>.</p></li><li class="listitem"><p><code class="command">LOCK</code> в короткой форме с умолчаниями, так как требует <code class="literal">ACCESS EXCLUSIVE MODE</code>.</p></li><li class="listitem"><p>Команды управления транзакциями, которые в явном виде требуют режим не только для чтения </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><code class="command">BEGIN READ WRITE</code>, <code class="command">START TRANSACTION READ WRITE</code></p></li><li class="listitem"><p><code class="command">SET TRANSACTION READ WRITE</code>, <code class="command">SET SESSION CHARACTERISTICS AS TRANSACTION READ WRITE</code></p></li><li class="listitem"><p>
           <code class="command">SET transaction_read_only = off</code>
          </p></li></ul></div></li><li class="listitem"><p>Команды двухфазной фиксации: <code class="command">PREPARE TRANSACTION</code>, <code class="command">COMMIT PREPARED</code>, <code class="command">ROLLBACK PREPARED</code>, так как даже транзакции только для чтения нуждаются в записи в WAL на этапе подготовки (первая фаза двухфазной фиксации).</p></li><li class="listitem"><p>Обновление последовательностей: <code class="function">nextval()</code>, <code class="function">setval()</code></p></li><li class="listitem"><p><code class="command">LISTEN</code>, <code class="command">NOTIFY</code></p></li></ul></div><p>При обычной работе транзакции <span class="quote">«<span class="quote">только для чтения</span>»</span> могут использовать команды <code class="command">LISTEN</code> и <code class="command">NOTIFY</code>; таким образом, сеансы горячего резерва работают с несколько большими ограничениями, чем обычные только читающие сеансы. Возможно, что некоторые из этих ограничений будут ослаблены в следующих выпусках.</p><p>В режиме горячего резерва параметр <code class="varname">transaction_read_only</code> всегда имеет значение true и изменить его нельзя. Но если не пытаться модифицировать содержимое БД, подключение к серверу в этом режиме не отличается от подключений к обычным базам данных. При отработке отказа или переключении ролей база данных переходит в обычный режим работы. Когда сервер меняет режим работы, установленные сеансы остаются подключёнными. После выхода из режима горячего резерва становится возможным запускать пишущие транзакции (даже в сеансах, начатых ещё в режиме горячего резерва).</p><p>Пользователи могут узнать, активен ли режим горячего резерва в их сеансе, выполнив команду <code class="command">SHOW in_hot_standby</code>. (Параметр <code class="varname">in_hot_standby</code> появился в 14 версии сервера; с более старыми серверами работает другой вариант — <code class="command">SHOW transaction_read_only</code>.) Кроме того, пользователи могут получить информацию о резервном сервере, используя ряд функций (см. <a class="xref" href="functions-admin.html#FUNCTIONS-RECOVERY-INFO-TABLE" title="Таблица 9.92. Функции для получения информации о восстановлении">Таблицу 9.92</a>). Эти средства позволяют как создавать программы, учитывающие текущий статус базы данных, так и отслеживать процесс восстановления или разрабатывать более сложные программы для восстановления баз данных в нужном состоянии.</p></div><div class="sect2" id="HOT-STANDBY-CONFLICT"><div class="titlepage"><div><div><h3 class="title">27.4.2. Обработка конфликтов запросов <a href="#HOT-STANDBY-CONFLICT" class="id_link">#</a></h3></div></div></div><p>Ведущий и резервный серверы связаны между собой многими слабыми связями. События на ведущем сервере оказывают влияние на резервный. В результате имеется потенциальная возможность отрицательного влияния или конфликта между ними. Наиболее простой для понимания конфликт — быстродействие: если на ведущем происходит загрузка очень большого объёма данных, то происходит создание соответствующего потока записей WAL на резервный сервер. Таким образом, запросы на резервном конкурируют за системные ресурсы, например, ввод-вывод.</p><p>Так же может возникнуть дополнительный тип конфликта на сервере горячего резерва. Этот конфликт называется <span class="emphasis"><em>жёстким конфликтом</em></span>, оказывает влияние на запросы, приводя к их отмене, а в некоторых случаях и к обрыву сеанса для разрешения конфликтов. Пользователям предоставлен набор средств для обработки подобных конфликтов. Случаи конфликтов включают: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Установка эксклюзивной блокировки на ведущем сервере, как с помощью явной команды <code class="command">LOCK</code>, так и при различных <acronym class="acronym">DDL</acronym>, что приводит к конфликту доступа к таблицам на резервном.</p></li><li class="listitem"><p>Удаление табличного пространства на ведущем сервере приводит к конфликту на резервном когда запросы используют это пространство для хранения временных рабочих файлов.</p></li><li class="listitem"><p>Удаление базы данных на ведущем сервере конфликтует с сеансами, подключёнными к этой БД на резервном.</p></li><li class="listitem"><p>Приложение очистки устаревших транзакций из WAL конфликтует с транзакциями на резервном сервере, которые используют снимок данных, который всё ещё видит какие-то из очищенных на ведущем строк.</p></li><li class="listitem"><p>Приложение очистки устаревших транзакций из WAL конфликтует с запросами к целевой странице на резервном сервере вне зависимости от того, являются ли данные удалёнными или видимыми.</p></li></ul></div><p>В этих случаях на ведущем сервере просто происходит ожидание; пользователю следует выбрать какую их конфликтующих сторон отменить. Тем не менее на резервном нет выбора: действия из WAL уже произошли на ведущем, поэтому резервный обязан применить их. Более того, позволять обработчику WAL ожидать неограниченно долго может быть крайне нежелательно, так как отставание резервного сервера от ведущего может всё возрастать. Таким образом, механизм обеспечивает принудительную отмену запросов на резервном сервере, которые конфликтуют с применяемыми записями WAL.</p><p>Примером такой проблемы может быть ситуация: администратор на ведущем сервере выполнил команду <code class="command">DROP TABLE</code> для таблицы, которая сейчас участвует в запросе на резервном. Понятно, что этот запрос нельзя будет выполнять дальше, если команда <code class="command">DROP TABLE</code> применится на резервном. Если бы этот запрос выполнялся на ведущем, команда <code class="command">DROP TABLE</code> ждала бы его окончания. Но когда на ведущем выполняется только команда <code class="command">DROP TABLE</code>, ведущий сервер не знает, какие запросы выполняются на резервном, поэтому он не может ждать завершения подобных запросов. Поэтому если записи WAL с изменением прибудут на резервный сервер, когда запрос будет продолжать выполняться, возникнет конфликт. В этом случае резервный сервер должен либо задержать применение этих записей WAL (и всех остальных, следующих за ними), либо отменить конфликтующий запрос, чтобы можно было применить <code class="command">DROP TABLE</code>.</p><p>Если конфликтный запрос короткий, обычно желательно разрешить ему завершиться, ненадолго задержав применение записей WAL, но слишком большая задержка в применении WAL обычно нежелательна. Поэтому механизм отмены имеет параметры <a class="xref" href="runtime-config-replication.html#GUC-MAX-STANDBY-ARCHIVE-DELAY">max_standby_archive_delay</a> и <a class="xref" href="runtime-config-replication.html#GUC-MAX-STANDBY-STREAMING-DELAY">max_standby_streaming_delay</a>, которые определяют максимально допустимое время задержки применения WAL. Конфликтующие запросы будут отменены, если они длятся дольше допустимого времени задержки применения очередных записей WAL. Два параметра существуют для того, чтобы можно было задать разные значения для чтения записей WAL из архива (то есть при начальном восстановлении из базовой копии либо при <span class="quote">«<span class="quote">навёрстывании</span>»</span> ведущего сервера в случае большого отставания) и для получения записей WAL при потоковой репликации.</p><p>На резервном сервере, созданном преимущественно для отказоустойчивости, лучше выставлять параметры задержек относительно небольшими, чтобы он не мог сильно отстать от ведущего из-за задержек, связанных с ожиданием запросов горячего резерва. Однако если резервный сервер предназначен для выполнения длительных запросов, то высокое значение или даже бесконечное ожидание могут быть предпочтительнее. Тем не менее следует иметь в виду, что длительные запросы могут оказать влияние на другие сеансы на резервном сервере в виде отсутствия последних изменений от ведущего из-за задержки применения записей WAL.</p><p>В случае, если задержка, определённая <code class="varname">max_standby_archive_delay</code> или <code class="varname">max_standby_streaming_delay</code> будет превышена, конфликтующий запрос будет отменён. Обычно это выражается в виде ошибки отмены, но в случае проигрывания команды <code class="command">DROP DATABASE</code> обрывается весь конфликтный сеанс. Так же, если конфликт произошел при блокировке, вызванной транзакцией в состоянии IDLE, конфликтный сеанс разрывается (это поведение может изменить в будущем).</p><p>Отменённые запросы могут быть немедленно повторены (конечно после старта новой транзакции). Так как причина отмены зависит от природы проигрываемых записей WAL, запрос, который был отменён, может быть успешно выполнен вновь.</p><p>Следует учесть, что параметры задержки отсчитываются от времени получения резервным сервером данных WAL. Таким образом, период дозволенной работы для запроса на резервном сервере никогда не может быть длиннее параметра задержки и может быть существенно короче, если резервный уже находится в режиме задержки в результате ожидания предыдущего запроса или результат не доступен из-за высокой нагрузки обновлений.</p><p>Наиболее частой причиной конфликтов между запросами на резервном сервере и проигрыванием WAL является преждевременная очистка. Обычно <span class="productname">PostgreSQL</span> допускает очистку старых версий записей при условии что ни одна из транзакций их не видит согласно правилам видимости данных для MVCC. Тем не менее эти правила применяются только для транзакций, выполняемых на главном сервере. Таким образом, допустима ситуация, когда на главном запись уже очищена, но эта же запись всё ещё видна для транзакций на резервном сервере.</p><p>Очистка старых версий строк — не единственная потенциальная причина конфликтов с запросами на резервном сервере. Все сканирования только индекса (включая те, которые выполняются на резервных серверах) должны использовать снимок <acronym class="acronym">MVCC</acronym>, который <span class="quote">«<span class="quote">согласуется</span>»</span> с картой видимости. Поэтому конфликты необходимы всякий раз, когда <code class="command">VACUUM</code> помечает страницу, в которой есть одна или несколько строк, <span class="emphasis"><em>невидимых</em></span> для всех запросов резервного сервера, как полностью видимую в <a class="link" href="routine-vacuuming.html#VACUUM-FOR-VISIBILITY-MAP" title="25.1.4. Обновление карты видимости">карте видимости</a>. Таким образом, даже выполнение <code class="command">VACUUM</code> для таблицы без изменённых или удалённых строк, требующих очистки, может привести к конфликтам.</p><p>Пользователи должны понимать, что регулярное и активное изменение данных в таблицах на ведущем сервере чревато отменой длительных запросов на резервном. В таком случае установка конечного значения для <code class="varname">max_standby_archive_delay</code> или <code class="varname">max_standby_streaming_delay</code> действует подобно ограничению <code class="varname">statement_timeout</code>.</p><p>В случае, если количество отменённых запросов на резервном сервере получается неприемлемым, существует ряд дополнительных возможностей. Первая возможность — установить параметр <code class="varname">hot_standby_feedback</code>, который не даёт команде <code class="command">VACUUM</code> удалять записи, ставшие недействительными недавно, что предотвращает конфликты очистки. При этом следует учесть, что это вызывает задержку очистки мёртвых строк на ведущем, что может привести к нежелательному раздуванию таблицы. Тем не менее в итоге ситуация будет не хуже, чем если бы запросы к резервному серверу исполнялись непосредственно на ведущем, но при этом сохранится положительный эффект от разделения нагрузки. В случае, когда соединение резервных серверов с ведущим часто разрывается, следует скорректировать период, в течение которого обратная связь через <code class="varname">hot_standby_feedback</code> не обеспечивается. Например, следует подумать об увеличении <code class="varname">max_standby_archive_delay</code>, чтобы запросы отменялись не сразу при конфликтах с архивом WAL в период разъединения. Также может иметь смысл увеличить <code class="varname">max_standby_streaming_delay</code> для предотвращения быстрой отмены запросов из-за полученных записей WAL после восстановления соединения.</p><p>Количество отменённых запросов и причины отмены можно просмотреть через системное представление <code class="structname">pg_stat_database_conflicts</code> на резервном сервере. Системное представление <code class="structname">pg_stat_database</code> так же содержит итоговую информацию.</p><p>Используя параметр <a class="xref" href="runtime-config-logging.html#GUC-LOG-RECOVERY-CONFLICT-WAITS">log_recovery_conflict_waits</a>, пользователь может регулировать, вносятся ли в журнал сообщения о том, что при воспроизведении WAL время ожидания разрешения конфликта превысило <code class="varname">deadlock_timeout</code>.</p></div><div class="sect2" id="HOT-STANDBY-ADMIN"><div class="titlepage"><div><div><h3 class="title">27.4.3. Обзор административной части <a href="#HOT-STANDBY-ADMIN" class="id_link">#</a></h3></div></div></div><p>Если в файле <code class="filename">postgresql.conf</code> параметр <code class="varname">hot_standby</code> имеет значение <code class="literal">on</code> (значение по умолчанию) и существует файл <a class="link" href="warm-standby.html#FILE-STANDBY-SIGNAL"><code class="filename">standby.signal</code></a><a id="id-1.6.14.18.7.2.5" class="indexterm"></a>, сервер запустится в режиме горячего резерва. Однако может пройти некоторое время, прежде чем к нему можно будет подключиться, так как он не будет принимать подключения, пока не произведёт восстановление до согласованного состояния, подходящего для выполнения запросов. (Информация о согласованности состояния записывается на ведущем сервере в контрольной точке.) В течение этого периода клиенты при попытке подключения будут получать сообщение об ошибке. Убедиться, что сервер включился в работу, можно либо повторяя попытки подключения из приложения до успешного подключения, либо дождавшись появления в журналах сервера таких сообщений: </p><pre class="programlisting">LOG:  entering standby mode

... then some time later ...

LOG:  consistent recovery state reached
LOG:  database system is ready to accept read-only connections</pre><p> Включить горячий резерв нельзя, если WAL был записан в период, когда на ведущем сервере параметр <code class="varname">wal_level</code> имел значение, отличное от <code class="literal">replica</code> и <code class="literal">logical</code>. Достижение согласованного состояния также может быть отсрочено, если имеют место оба этих условия: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Пишущая транзакция имеет более 64 подтранзакций</p></li><li class="listitem"><p>Очень длительные пишущие транзакции</p></li></ul></div><p> Если вы применяете файловую репликацию журналов («тёплый резерв»), возможно, придётся ожидать прибытия следующего файла WAL (максимальное время ожидания задаётся параметром <code class="varname">archive_timeout</code> на ведущем сервере).</p><p>Значения некоторых параметров определяют размер общей памяти для отслеживания идентификаторов транзакций, блокировок и подготовленных транзакций. Эти структуры общей памяти на резервном сервере должны быть не меньше, чем аналогичные структуры на ведущем, чтобы гарантировать, что резервный сервер не исчерпает общую память во время восстановления. Например, если на ведущем сервере выполнялась подготовленная транзакция, но резервный сервер не выделил никакой общей памяти для отслеживания подготовленных транзакций, то восстановление не сможет продолжаться пока не будет изменена конфигурация резервного сервера. Это касается следующих параметров: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
         <code class="varname">max_connections</code>
        </p></li><li class="listitem"><p>
         <code class="varname">max_prepared_transactions</code>
        </p></li><li class="listitem"><p>
         <code class="varname">max_locks_per_transaction</code>
        </p></li><li class="listitem"><p>
         <code class="varname">max_wal_senders</code>
        </p></li><li class="listitem"><p>
         <code class="varname">max_worker_processes</code>
        </p></li></ul></div><p> Самый простой способ избежать данной проблемы — установить на резервных серверах такие значения этих параметров, которые будут больше значений на основном или равны им. Поэтому, если вы хотите увеличить эти значения, сначала вы должны сделать это на всех резервных серверах, а затем внести изменения на ведущем сервере. И наоборот, если вы хотите уменьшить эти значения, сначала следует сделать это на ведущем сервере, а затем вносить изменения на всех резервных серверах. Имейте в виду, что когда резервный сервер повышается до ведущего, он становится новым источником необходимых значений параметров для следующих за ним резервных серверов. Чтобы это не стало проблемой во время переключения узлов или отработки отказа, рекомендуется устанавливать одинаковые значения на всех резервных серверах.</p><p>Изменения этих параметров на ведущем сервере отслеживаются в WAL. Если в процессе чтения WAL сервер горячего резерва обнаруживает, что на ведущем сервере текущее значение оказалось больше, чем значение в его собственной конфигурации, он выдаёт предупреждение и приостанавливает восстановление, например: </p><pre class="screen">
WARNING:  hot standby is not possible because of insufficient parameter settings
DETAIL:  max_connections = 80 is a lower setting than on the primary server, where its value was 100.
LOG:  recovery has paused
DETAIL:  If recovery is unpaused, the server will shut down.
HINT:  You can then restart the server after making the necessary configuration changes.
</pre><p> Прежде чем продолжить восстановление, на этом этапе необходимо изменить значения на резервном сервере и перезапустить экземпляр СУБД. Если резервный сервер не является сервером горячего резерва, то при обнаружении несовместимого изменения параметра он немедленно отключится без приостановки, поскольку в этом случае нет смысла поддерживать его в рабочем состоянии.</p><p>Очень важно для администратора выбрать подходящие значения для <a class="xref" href="runtime-config-replication.html#GUC-MAX-STANDBY-ARCHIVE-DELAY">max_standby_archive_delay</a> и <a class="xref" href="runtime-config-replication.html#GUC-MAX-STANDBY-STREAMING-DELAY">max_standby_streaming_delay</a>. Оптимальное значение зависит от приоритетов. Например, если основное назначение сервера — обеспечение высокой степени доступности, то следует установить короткий период, возможно даже нулевой, хотя это очень жёсткий вариант. Если резервный сервер планируется как дополнительный сервер для аналитических запросов, то приемлемой будет максимальная задержка в несколько часов или даже -1, что означает бесконечное ожидание окончания запроса.</p><p>Вспомогательные биты статуса транзакций, записанные на ведущем, не попадают в WAL, так что они, скорее всего, будут перезаписаны на нём при работе с данными. Таким образом, резервный сервер будет производить запись на диск, даже если все пользователи только читают данные, ничего не меняя. Кроме того, пользователи будут записывать временные файлы при сортировке больших объёмов и обновлять файлы кеша. Поэтому в режиме горячего резерва ни одна часть базы данных фактически не работает в режиме «только чтение». Следует отметить, что также возможно выполнить запись в удалённую базу данных с помощью модуля <span class="application">dblink</span> и другие операции вне базы данных с применением PL-функций, несмотря на то, что транзакции по-прежнему смогут только читать данные.</p><p>Следующие типы административных команд недоступны в течение режима восстановления: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Команды определения данных (DDL): <code class="command">CREATE INDEX</code> и т. п.</p></li><li class="listitem"><p>Команды управления правами и назначения владельца: <code class="command">GRANT</code>, <code class="command">REVOKE</code>, <code class="command">REASSIGN</code></p></li><li class="listitem"><p>Команды обслуживания: <code class="command">ANALYZE</code>, <code class="command">VACUUM</code>, <code class="command">CLUSTER</code>, <code class="command">REINDEX</code></p></li></ul></div><p>Ещё раз следует отметить, что некоторые из этих команд фактически доступны на ведущем сервере для транзакций в режиме только для чтения.</p><p>В результате нельзя создать дополнительные индексы или статистику, чтобы они существовали только на резервном. Если подобные административные команды нужны, то их следует выполнить на ведущем сервере, затем эти изменения будут распространены на резервные серверы.</p><p>Функции <code class="function">pg_cancel_backend()</code> и <code class="function">pg_terminate_backend()</code> работают на стороне пользователя, но не для процесса запуска, который обеспечивает восстановление. Представление <code class="structname">pg_stat_activity</code> не показывает восстанавливаемые транзакции как активные. Поэтому представление <code class="structname">pg_prepared_xacts</code> всегда пусто в ходе восстановления. Если требуется разобрать сомнительные подготовленные транзакции, следует обратиться к <code class="literal">pg_prepared_xacts</code> на ведущем и выполнить команды для разбора транзакций там либо разобрать их по окончании восстановления.</p><p><code class="structname">pg_locks</code> отображает блокировки, происходящие в процессе работы сервера как обычно. <code class="structname">pg_locks</code> так же показывает виртуальные транзакции, обработанные процессом запуска, которому принадлежат все <code class="literal">AccessExclusiveLocks</code>, наложенные транзакциями в режиме восстановления. Следует отметить, что процесс запуска не запрашивает блокировки, чтобы внести изменения в базу данных, поэтому блокировки, отличные от <code class="literal">AccessExclusiveLocks</code> не показываются в <code class="structname">pg_locks</code> для процесса запуска, подразумевается их существование.</p><p>Модуль <span class="productname">check_pgsql</span> для <span class="productname">Nagios</span> будет работать, так как сервер выдаёт простую информацию, наличие которой он проверяет. Скрипт мониторинга <span class="productname">check_postgres</span> так же работает, хотя для некоторых выдаваемых показателей результаты могут различаться или вводить в заблуждение. Например, нельзя отследить время последней очистки, так как очистка не производится на резервном сервере. Очистка запускается на ведущем сервере и результаты её работы передаются резервному.</p><p>Команды управления файлами WAL, например <code class="function">pg_backup_start</code>, <code class="function">pg_switch_wal</code> и т. д. не будут работать во время восстановления.</p><p>Динамически загружаемые модули работать будут, включая <code class="structname">pg_stat_statements</code>.</p><p>Рекомендательная блокировка работает обычно при восстановлении, включая обнаружение взаимных блокировок. Следует отметить, что рекомендательная блокировка никогда не попадает в WAL, таким образом для рекомендательной блокировки как на ведущем сервере, так и на резервном, невозможен конфликт с проигрыванием WAL. Но возможно получение рекомендательной блокировки на ведущем сервере, а затем получение подобной рекомендательной блокировки на резервном. Рекомендательная блокировка относится только к серверу, на котором она получена.</p><p>Системы репликации на базе триггеров, подобные <span class="productname">Slony</span>, <span class="productname">Londiste</span> и <span class="productname">Bucardo</span> не могут запускаться на резервном сервере вовсе, хотя они превосходно работают на ведущем до тех пор, пока не будет подана команда не пересылать изменения на резервный. Проигрывание WAL не основано на триггерах, поэтому поток WAL нельзя транслировать с резервного сервера в другую систему, которая требует дополнительной записи в БД или работает на основе триггеров.</p><p>Новые OID не могут быть выданы, хотя, например генераторы <acronym class="acronym">UUID</acronym> смогут работать, если они не пытаются записывать новое состояние в базу данных.</p><p>На данный момент создание временных таблиц недопустимо в транзакции только для чтения, поэтому в некоторых случаях существующие скрипты будут работать некорректно. Сейчас это не поддерживается как из соображений совместимости со стандартом SQL, так и из соображений технического плана.</p><p>Команда <code class="command">DROP TABLESPACE</code> может быть выполнена только если табличное пространство пусто. Некоторые пользователи резервного сервера могут активно использовать табличное пространство через параметр <code class="varname">temp_tablespaces</code>. Если имеются временные файлы в табличных пространствах, все активные запросы отменяются для обеспечения удаления временных файлов, затем табличное пространство может быть удалено и продолжено проигрывание WAL.</p><p>Выполнение команды <code class="command">DROP DATABASE</code> или <code class="command">ALTER DATABASE ... SET TABLESPACE</code> на ведущем сервере приводит к созданию записи в WAL, которая вызывает принудительное отключение всех пользователей, подключённых к этой базе данных на резервном. Это происходит немедленно, вне зависимости от значения <code class="varname">max_standby_streaming_delay</code>. Следует отметить, что команда <code class="command">ALTER DATABASE ... RENAME</code> не приводит к отключению пользователей, так что обычно она действует незаметно, хотя в некоторых случаях возможны сбои программ, которые зависят от имени базы данных.</p><p>Если вы в обычном режиме (не в режиме восстановления) выполните <code class="command">DROP USER</code> или <code class="command">DROP ROLE</code> для роли с возможностью подключения, в момент, когда этот пользователь подключён, на данном пользователе это никак не отразится — он останется подключённым. Однако переподключиться он уже не сможет. Это же поведение действует в режиме восстановления — если выполнить <code class="command">DROP USER</code> на ведущем сервере, пользователь не будет отключён от резервного.</p><p>Система накопительной статистики работает во время восстановления. Все операции сканирования, чтения, использование блоков, индексов и т. п. будут отражены в статистике на резервном сервере обычным образом. Однако при воспроизведении WAL не будут увеличиваться счётчики уровня отношений и баз данных, то есть при воспроизведении не будут увеличиваться значения столбцов в <code class="structname">pg_stat_all_tables</code> (например, <code class="structfield">n_tup_ins</code>), операции чтения и записи, выполняемые процессом запуска, не будут отражаться в представлениях <code class="structname">pg_statio_</code>, а также не будут увеличиваться значения связанных столбцов <code class="structname">pg_stat_database</code>.</p><p>Автоматическая очистка не работает во время восстановления. Она запустится в обычном режиме после завершения восстановления.</p><p>Во время восстановления работает процесс контрольных точек и процесс фоновой записи. Процесс контрольных точек обрабатывает точки перезапуска (подобные контрольным точкам на ведущем сервере), а процесс фоновой записи выполняет обычные операции по очистке блоков. В том числе он может обновлять вспомогательные биты, сохранённые на резервном сервере. Во время восстановления принимается команда <code class="command">CHECKPOINT</code>, но она производит точку перезапуска, а не создаёт новую точку восстановления.</p></div><div class="sect2" id="HOT-STANDBY-PARAMETERS"><div class="titlepage"><div><div><h3 class="title">27.4.4. Ссылки на параметры горячего резерва <a href="#HOT-STANDBY-PARAMETERS" class="id_link">#</a></h3></div></div></div><p>Различные параметры были упомянуты выше в <a class="xref" href="hot-standby.html#HOT-STANDBY-CONFLICT" title="27.4.2. Обработка конфликтов запросов">Подразделе 27.4.2</a> и <a class="xref" href="hot-standby.html#HOT-STANDBY-ADMIN" title="27.4.3. Обзор административной части">Подразделе 27.4.3</a>.</p><p>На ведущем сервере может применяться параметр <a class="xref" href="runtime-config-wal.html#GUC-WAL-LEVEL">wal_level</a>. Параметры <a class="xref" href="runtime-config-replication.html#GUC-MAX-STANDBY-ARCHIVE-DELAY">max_standby_archive_delay</a> и <a class="xref" href="runtime-config-replication.html#GUC-MAX-STANDBY-STREAMING-DELAY">max_standby_streaming_delay</a> на ведущем сервере не действуют.</p><p>На резервном сервере могут применяться параметры <a class="xref" href="runtime-config-replication.html#GUC-HOT-STANDBY">hot_standby</a>, <a class="xref" href="runtime-config-replication.html#GUC-MAX-STANDBY-ARCHIVE-DELAY">max_standby_archive_delay</a> и <a class="xref" href="runtime-config-replication.html#GUC-MAX-STANDBY-STREAMING-DELAY">max_standby_streaming_delay</a>.</p></div><div class="sect2" id="HOT-STANDBY-CAVEATS"><div class="titlepage"><div><div><h3 class="title">27.4.5. Ограничения <a href="#HOT-STANDBY-CAVEATS" class="id_link">#</a></h3></div></div></div><p>Имеются следующие ограничения горячего резерва. Они могут и скорее всего будут исправлены в следующих выпусках: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Требуется информация о всех запущенных транзакциях перед тем как будет создан снимок данных. Транзакции, использующие большое количество подтранзакций (в настоящий момент больше 64), будут задерживать начало соединения только для чтения до завершения самой длинной пишущей транзакции. При возникновении этой ситуации поясняющее сообщение будет записано в журнал сервера.</p></li><li class="listitem"><p>Подходящие стартовые точки для запросов на резервном сервере создаются при каждой контрольной точке на главном. Если резервный сервер отключается, в то время как главный был в отключённом состоянии, может оказаться невозможным возобновить его работу в режиме горячего резерва, до того, как запустится ведущий и добавит следующие стартовые точки в журналы WAL. Подобная ситуация не является проблемой для большинства случаев, в которых она может произойти. Обычно, если ведущий сервер выключен и больше не доступен, это является следствием серьёзного сбоя и в любом случае требует преобразования резервного в новый ведущий. Так же в ситуации, когда ведущий отключён намеренно, проверка готовности резервного к преобразованию в ведущий тоже является обычной процедурой.</p></li><li class="listitem"><p>В конце восстановления блокировки <code class="literal">AccessExclusiveLocks</code>, вызванные подготовленными транзакциями, требуют удвоенное, в сравнении с нормальным, количество блокировок записей таблицы. Если планируется использовать либо большое количество конкурирующих подготовленных транзакций, обычно вызывающие <code class="literal">AccessExclusiveLocks</code>, либо большие транзакции с применением большого количества <code class="literal">AccessExclusiveLocks</code>, то рекомендуется выбрать большое значение параметра <code class="varname">max_locks_per_transaction</code>, возможно в два раза большее, чем значение параметра на ведущем сервере. Всё это не имеет значения, когда <code class="varname">max_prepared_transactions</code> равно 0.</p></li><li class="listitem"><p>Уровень изоляции транзакции Serializable в настоящее время недоступен в горячем резерве. (За подробностями обратитесь к <a class="xref" href="transaction-iso.html#XACT-SERIALIZABLE" title="13.2.3. Уровень изоляции Serializable">Подразделу 13.2.3</a> и <a class="xref" href="applevel-consistency.html#SERIALIZABLE-CONSISTENCY" title="13.4.1. Обеспечение согласованности в сериализуемых транзакциях">Подразделу 13.4.1</a>) Попытка выставить для транзакции такой уровень изоляции в режиме горячего резерва вызовет ошибку.</p></li></ul></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="warm-standby-failover.html" title="27.3. Отработка отказа">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="high-availability.html" title="Глава 27. Отказоустойчивость, балансировка нагрузки и репликация">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="monitoring.html" title="Глава 28. Мониторинг работы СУБД">След.</a></td></tr><tr><td width="40%" align="left" valign="top">27.3. Отработка отказа </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> Глава 28. Мониторинг работы СУБД</td></tr></table></div></body></html>