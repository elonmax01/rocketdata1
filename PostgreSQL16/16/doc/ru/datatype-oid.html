<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>8.19. Идентификаторы объектов</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="domains.html" title="8.18. Типы доменов" /><link rel="next" href="datatype-pg-lsn.html" title="8.20. Тип pg_lsn" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">8.19. Идентификаторы объектов</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="domains.html" title="8.18. Типы доменов">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="datatype.html" title="Глава 8. Типы данных">Наверх</a></td><th width="60%" align="center">Глава 8. Типы данных</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="datatype-pg-lsn.html" title="8.20. Тип pg_lsn">След.</a></td></tr></table><hr /></div><div class="sect1" id="DATATYPE-OID"><div class="titlepage"><div><div><h2 class="title" style="clear: both">8.19. Идентификаторы объектов <a href="#DATATYPE-OID" class="id_link">#</a></h2></div></div></div><a id="id-1.5.7.27.2" class="indexterm"></a><a id="id-1.5.7.27.3" class="indexterm"></a><a id="id-1.5.7.27.4" class="indexterm"></a><a id="id-1.5.7.27.5" class="indexterm"></a><a id="id-1.5.7.27.6" class="indexterm"></a><a id="id-1.5.7.27.7" class="indexterm"></a><a id="id-1.5.7.27.8" class="indexterm"></a><a id="id-1.5.7.27.9" class="indexterm"></a><a id="id-1.5.7.27.10" class="indexterm"></a><a id="id-1.5.7.27.11" class="indexterm"></a><a id="id-1.5.7.27.12" class="indexterm"></a><a id="id-1.5.7.27.13" class="indexterm"></a><a id="id-1.5.7.27.14" class="indexterm"></a><a id="id-1.5.7.27.15" class="indexterm"></a><a id="id-1.5.7.27.16" class="indexterm"></a><a id="id-1.5.7.27.17" class="indexterm"></a><a id="id-1.5.7.27.18" class="indexterm"></a><p>Идентификатор объекта (Object Identifier, OID) используется внутри <span class="productname">PostgreSQL</span> в качестве первичного ключа различных системных таблиц. Идентификатор объекта представляется в типе <code class="type">oid</code>. Также существуют различные типы-псевдонимы для <code class="type">oid</code>, с именами <code class="type">reg<em class="replaceable"><code>сущность</code></em></code>. Обзор этих типов приведён в <a class="xref" href="datatype-oid.html#DATATYPE-OID-TABLE" title="Таблица 8.26. Идентификаторы объектов">Таблице 8.26</a>.</p><p>В настоящее время тип <code class="type">oid</code> реализован как четырёхбайтное целое число без знака. Таким образом, значение этого типа может быть недостаточно большим для обеспечения уникальности в базе данных или даже в отдельных больших таблицах.</p><p>Для самого типа <code class="type">oid</code> помимо сравнения определены всего несколько операторов. Однако его можно привести к целому и затем задействовать в обычных целочисленных вычислениях. (При этом следует опасаться путаницы со знаковыми/беззнаковыми значениями.)</p><p>Типы-псевдонимы OID сами по себе не вводят новых операций и отличаются только специализированными функциями ввода/вывода. Эти функции могут принимать и выводить не просто числовые значения, как тип <code class="type">oid</code>, а символические имена системных объектов. Эти типы позволяют упростить поиск объектов по значениям OID. Например, чтобы выбрать из <code class="structname">pg_attribute</code> строки, относящиеся к таблице <code class="literal">mytable</code>, можно написать: </p><pre class="programlisting">SELECT * FROM pg_attribute WHERE attrelid = 'mytable'::regclass;</pre><p> вместо: </p><pre class="programlisting">SELECT * FROM pg_attribute
  WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'mytable');</pre><p> Хотя второй вариант выглядит не таким уж плохим, но это лишь очень простой запрос. Если же потребуется выбрать правильный OID, когда таблица <code class="literal">mytable</code> есть в нескольких схемах, вложенный подзапрос будет гораздо сложнее. Преобразователь вводимого значения типа <code class="type">regclass</code> находит таблицу согласно заданному пути поиска схем, так что он делает <span class="quote">«<span class="quote">всё правильно</span>»</span> автоматически. Аналогично, приведя идентификатор таблицы к типу <code class="type">regclass</code>, можно получить символическое представление числового кода.</p><div class="table" id="DATATYPE-OID-TABLE"><p class="title"><strong>Таблица 8.26. Идентификаторы объектов</strong></p><div class="table-contents"><table class="table" summary="Идентификаторы объектов" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Name</th><th>Ссылки</th><th>Описание</th><th>Пример значения</th></tr></thead><tbody><tr><td><code class="type">oid</code></td><td>any</td><td>числовой идентификатор объекта</td><td><code class="literal">564182</code></td></tr><tr><td><code class="type">regclass</code></td><td><code class="structname">pg_class</code></td><td>имя отношения</td><td><code class="literal">pg_type</code></td></tr><tr><td><code class="type">regcollation</code></td><td><code class="structname">pg_collation</code></td><td>имя правила сортировки</td><td><code class="literal">"POSIX"</code></td></tr><tr><td><code class="type">regconfig</code></td><td><code class="structname">pg_ts_config</code></td><td>конфигурация текстового поиска</td><td><code class="literal">english</code></td></tr><tr><td><code class="type">regdictionary</code></td><td><code class="structname">pg_ts_dict</code></td><td>словарь текстового поиска</td><td><code class="literal">simple</code></td></tr><tr><td><code class="type">regnamespace</code></td><td><code class="structname">pg_namespace</code></td><td>пространство имён</td><td><code class="literal">pg_catalog</code></td></tr><tr><td><code class="type">regoper</code></td><td><code class="structname">pg_operator</code></td><td>имя оператора</td><td><code class="literal">+</code></td></tr><tr><td><code class="type">regoperator</code></td><td><code class="structname">pg_operator</code></td><td>оператор с типами аргументов</td><td><code class="literal">*(integer,​integer)</code> или <code class="literal">-(NONE,​integer)</code></td></tr><tr><td><code class="type">regproc</code></td><td><code class="structname">pg_proc</code></td><td>имя функции</td><td><code class="literal">sum</code></td></tr><tr><td><code class="type">regprocedure</code></td><td><code class="structname">pg_proc</code></td><td>функция с типами аргументов</td><td><code class="literal">sum(int4)</code></td></tr><tr><td><code class="type">regrole</code></td><td><code class="structname">pg_authid</code></td><td>имя роли</td><td><code class="literal">smithee</code></td></tr><tr><td><code class="type">regtype</code></td><td><code class="structname">pg_type</code></td><td>имя типа данных</td><td><code class="literal">integer</code></td></tr></tbody></table></div></div><br class="table-break" /><p>Все типы псевдонимов OID для объектов, сгруппированных в пространство имён, принимают имена, дополненные именем схемы, и выводят имена со схемой, если данный объект нельзя будет найти в текущем пути поиска без имени схемы. Например, <code class="literal">myschema.mytable</code> является приемлемым входным значением для <code class="type">regclass</code> (если существует такая таблица). Это значение может выводиться как <code class="literal">myschema.mytable</code> или просто <code class="literal">mytable</code>, в зависимости от текущего пути поиска. Типы <code class="type">regproc</code> и <code class="type">regoper</code> принимают только уникальные вводимые имена (не перегруженные), что ограничивает их применимость; в большинстве случаев лучше использовать <code class="type">regprocedure</code> или <code class="type">regoperator</code>. Для типа <code class="type">regoperator</code> в записи унарного оператора неиспользуемый операнд заменяется словом <code class="literal">NONE</code>.</p><p>Функции ввода для данных типов допускают пробелы между компонентами и приводят буквы верхнего регистра к нижнему, за исключением строки в двойных кавычках; это сделано для того, чтобы правила записи были похожи на принятые для записи имён объектов в SQL. И наоборот, функции вывода будут добавлять двойные кавычки, если это необходимо, чтобы выводимая строка была допустимым идентификатором SQL. Например, OID функции с именем <code class="literal">Foo</code> (с <code class="literal">F</code> в верхнем регистре), принимающей два целочисленных аргумента, можно ввести как <code class="literal">' "Foo" ( int, integer ) '::regprocedure</code>. Результат будет выглядеть как <code class="literal">"Foo"(integer,integer)</code>. И имя функции, и имена типов аргументов также могут быть дополнены схемой.</p><p>Многие встроенные функции <span class="productname">PostgreSQL</span> принимают OID таблицы или другого типа объекта БД и для удобства объявляются как принимающие <code class="type">regclass</code> (или соответствующий тип-псевдоним OID). Это означает, что вам не нужно искать OID объекта вручную, а можно просто ввести его имя в виде строки. Например, функция <code class="function">nextval (regclass)</code> принимает OID отношения последовательности, поэтому её можно вызвать так: </p><pre class="programlisting">nextval('foo')              <em class="lineannotation"><span class="lineannotation">обращается к последовательности <code class="literal">foo</code></span></em>
nextval('FOO')              <em class="lineannotation"><span class="lineannotation">то же самое</span></em>
nextval('"Foo"')            <em class="lineannotation"><span class="lineannotation">обращается к последовательности <code class="literal">Foo</code></span></em>
nextval('myschema.foo')     <em class="lineannotation"><span class="lineannotation">обращается к <code class="literal">myschema.foo</code></span></em>
nextval('"myschema".foo')   <em class="lineannotation"><span class="lineannotation">то же самое</span></em>
nextval('foo')              <em class="lineannotation"><span class="lineannotation">ищет <code class="literal">foo</code> в пути поиска</span></em></pre><div class="note"><h3 class="title">Примечание</h3><p>Когда аргумент такой функции записывается как текстовая строка в чистом виде, она становится константой типа <code class="type">regclass</code>. Так как фактически это будет просто значение OID, оно будет привязано к изначально идентифицированной последовательности, несмотря на то, что она может быть переименована, перенесена в другую схему и т. д. Такое <span class="quote">«<span class="quote">раннее связывание</span>»</span> обычно желательно для ссылок на последовательности в значениях столбцов по умолчанию и представлениях. Но иногда возникает необходимость в <span class="quote">«<span class="quote">позднем связывании</span>»</span>, когда ссылки на последовательности распознаются в процессе выполнения. Чтобы получить такое поведение, нужно принудительно изменить тип константы с <code class="type">regclass</code> на <code class="type">text</code>: </p><pre class="programlisting">nextval('foo'::text)      <em class="lineannotation"><span class="lineannotation"><code class="literal">foo</code> распознаётся во время выполнения</span></em></pre><p> Для поиска во время выполнения также может использоваться функция <code class="function">to_regclass()</code> и подобные. См. <a class="xref" href="functions-info.html#FUNCTIONS-INFO-CATALOG-TABLE" title="Таблица 9.72. Функции для обращения к системным каталогам">Таблицу 9.72</a>.</p></div><p>Другой практический пример использования <code class="type">regclass</code> — поиск OID таблицы, отображённой в представлениях <code class="literal">information_schema</code>, которые не предоставляют такие OID напрямую. Например, можно вызвать функцию <code class="function">pg_relation_size()</code>, для которой требуется OID таблицы. С учётом указанных выше правил, далее представлен корректный способ вызова данной функции </p><pre class="programlisting">SELECT table_schema, table_name,
       pg_relation_size((quote_ident(table_schema) || '.' ||
                         quote_ident(table_name))::regclass)
FROM information_schema.tables
WHERE ...</pre><p>. Функция <code class="function">quote_ident()</code> заключит идентификатор в двойные кавычки, когда это необходимо. Более простым способом кажется </p><pre class="programlisting">SELECT pg_relation_size(table_name)
FROM information_schema.tables
WHERE ...</pre><p> но использовать его <span class="emphasis"><em>не рекомендуется</em></span>, потому что он не сработает для таблиц, которые не входят в заданный путь поиска или имена которых нужно заключать в кавычки.</p><p>Дополнительным свойством большинства типов псевдонимов OID является образование зависимостей. Когда в сохранённом выражении фигурирует константа одного из этих типов (например, в представлении или в значении столбца по умолчанию), это создаёт зависимость от целевого объекта. Например, если значение по умолчанию определяется выражением <code class="literal">nextval('my_seq'::regclass)</code>, <span class="productname">PostgreSQL</span> понимает, что это выражение зависит от последовательности <code class="literal">my_seq</code>, и не позволит удалить последовательность раньше, чем будет удалено это выражение. Альтернативная запись <code class="literal">nextval('my_seq'::text)</code> не создаёт зависимость. (Единственным исключением является тип <code class="type">regrole</code>. Константы этого типа в таких выражениях не допускаются.)</p><p>Есть ещё один тип системных идентификаторов, <code class="type">xid</code>, представляющий идентификатор транзакции (сокращённо <abbr class="abbrev">xact</abbr>). Этот тип имеют системные столбцы <code class="structfield">xmin</code> и <code class="structfield">xmax</code>. Идентификаторы транзакций определяются 32-битными числами. В некоторых контекстах используется 64-битный вариант <code class="type">xid8</code>. В отличие от <code class="type">xid</code>, значения <code class="type">xid8</code> увеличиваются строго монотонно и никогда не повторяются на протяжении всего существования кластера баз данных. За подробностями обратитесь к <a class="xref" href="transaction-id.html" title="74.1. Транзакции и идентификаторы">Разделу 74.1</a>.</p><p>Третий тип идентификаторов, используемых в системе, — <code class="type">cid</code>, идентификатор команды (command identifier). Этот тип данных имеют системные столбцы <code class="structfield">cmin</code> и <code class="structfield">cmax</code>. Идентификаторы команд — это тоже 32-битные числа.</p><p>И наконец, последний тип системных идентификаторов — <code class="type">tid</code>, идентификатор строки/кортежа (tuple identifier). Этот тип данных имеет системный столбец <code class="structfield">ctid</code>. Идентификатор кортежа представляет собой пару (из номера блока и индекса кортежа в блоке), идентифицирующую физическое расположение строки в таблице.</p><p>(Подробнее о системных столбцах рассказывается в <a class="xref" href="ddl-system-columns.html" title="5.5. Системные столбцы">Разделе 5.5</a>.)</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="domains.html" title="8.18. Типы доменов">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="datatype.html" title="Глава 8. Типы данных">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="datatype-pg-lsn.html" title="8.20. Тип pg_lsn">След.</a></td></tr><tr><td width="40%" align="left" valign="top">8.18. Типы доменов </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 8.20. Тип <code class="type">pg_lsn</code></td></tr></table></div></body></html>