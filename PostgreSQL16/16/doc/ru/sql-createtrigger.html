<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CREATE TRIGGER</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sql-createtransform.html" title="CREATE TRANSFORM" /><link rel="next" href="sql-createtype.html" title="CREATE TYPE" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">CREATE TRIGGER</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-createtransform.html" title="CREATE TRANSFORM">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><th width="60%" align="center">Команды SQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-createtype.html" title="CREATE TYPE">След.</a></td></tr></table><hr /></div><div class="refentry" id="SQL-CREATETRIGGER"><div class="titlepage"></div><a id="id-1.9.3.93.1" class="indexterm"></a><a id="id-1.9.3.93.2" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">CREATE TRIGGER</span></h2><p>CREATE TRIGGER — создать триггер</p></div><div class="refsynopsisdiv"><h2>Синтаксис</h2><pre class="synopsis">CREATE [ OR REPLACE ] [ CONSTRAINT ] TRIGGER <em class="replaceable"><code>имя</code></em> { BEFORE | AFTER | INSTEAD OF } { <em class="replaceable"><code>событие</code></em> [ OR ... ] }
    ON <em class="replaceable"><code>имя_таблицы</code></em>
    [ FROM <em class="replaceable"><code>ссылающаяся_таблица</code></em> ]
    [ NOT DEFERRABLE | [ DEFERRABLE ] [ INITIALLY IMMEDIATE | INITIALLY DEFERRED ] ]
    [ REFERENCING { { OLD | NEW } TABLE [ AS ] <em class="replaceable"><code>имя_переходного_отношения</code></em> } [ ... ] ]
    [ FOR [ EACH ] { ROW | STATEMENT } ]
    [ WHEN ( <em class="replaceable"><code>условие</code></em> ) ]
    EXECUTE { FUNCTION | PROCEDURE } <em class="replaceable"><code>имя_функции</code></em> ( <em class="replaceable"><code>аргументы</code></em> )

<span class="phrase">Здесь допускается <em class="replaceable"><code>событие</code></em>:</span>

    INSERT
    UPDATE [ OF <em class="replaceable"><code>имя_столбца</code></em> [, ... ] ]
    DELETE
    TRUNCATE</pre></div><div class="refsect1" id="id-1.9.3.93.6"><h2>Описание</h2><p><code class="command">CREATE TRIGGER</code> создаёт новый триггер, а <code class="command">CREATE OR REPLACE TRIGGER</code> создаёт новый триггер или заменяет существующий. Триггер будет связан с указанной таблицей, представлением или сторонней таблицей и будет выполнять заданную функцию <em class="replaceable"><code>имя_функции</code></em> при определённых операциях с этой таблицей.</p><p>Чтобы заменить текущее определение существующего триггера, воспользуйтесь командой <code class="command">CREATE OR REPLACE TRIGGER</code>, указав в ней имя существующего триггера и родительскую таблицу. Все остальные свойства этого триггера будут изменены.</p><p>Триггер можно настроить так, чтобы он срабатывал до операции со строкой (до проверки ограничений и попытки выполнить <code class="command">INSERT</code>, <code class="command">UPDATE</code> или <code class="command">DELETE</code>) или после её завершения (после проверки ограничений и выполнения <code class="command">INSERT</code>, <code class="command">UPDATE</code> или <code class="command">DELETE</code>), либо вместо операции (при добавлении, изменении и удалении строк в представлении). Если триггер срабатывает до или вместо события, он может пропустить операцию с текущей строкой, либо изменить добавляемую строку (только для операций <code class="command">INSERT</code> и <code class="command">UPDATE</code>). Если триггер срабатывает после события, он <span class="quote">«<span class="quote">видит</span>»</span> все изменения, включая результат действия других триггеров.</p><p>Триггер с пометкой <code class="literal">FOR EACH ROW</code> вызывается один раз для каждой строки, изменяемой в процессе операции. Например, операция <code class="command">DELETE</code>, удаляющая 10 строк, приведёт к срабатыванию всех триггеров <code class="literal">ON DELETE</code> в целевом отношении 10 раз подряд, по одному разу для каждой удаляемой строки. Триггер с пометкой <code class="literal">FOR EACH STATEMENT</code>, напротив, вызывается только один раз для конкретной операции, вне зависимости от того, как много строк она изменила (в частности, при выполнении операции, изменяющей ноль строк, всё равно будут вызваны все триггеры <code class="literal">FOR EACH STATEMENT</code>).</p><p>Триггеры, срабатывающие в режиме <code class="literal">INSTEAD OF</code>, должны быть помечены <code class="literal">FOR EACH ROW</code> и могут быть определены только для представлений. Триггеры <code class="literal">BEFORE</code> и <code class="literal">AFTER</code> для представлений должны быть помечены <code class="literal">FOR EACH STATEMENT</code>.</p><p>Кроме того, триггеры можно определить и для команды <code class="command">TRUNCATE</code>, но только типа <code class="literal">FOR EACH STATEMENT</code>.</p><p>В следующей таблице перечисляются типы триггеров, которые могут использоваться для таблиц, представлений и сторонних таблиц:</p><div class="informaltable" id="SUPPORTED-TRIGGER-TYPES"><table class="informaltable" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Когда</th><th>Событие</th><th>На уровне строк</th><th>На уровне оператора</th></tr></thead><tbody><tr><td rowspan="2" align="center"><code class="literal">BEFORE</code></td><td align="center"><code class="command">INSERT</code>/<code class="command">UPDATE</code>/<code class="command">DELETE</code></td><td align="center">Таблицы и сторонние таблицы</td><td align="center">Таблицы, представления и сторонние таблицы</td></tr><tr><td align="center"><code class="command">TRUNCATE</code></td><td align="center">—</td><td align="center">Таблицы и сторонние таблицы</td></tr><tr><td rowspan="2" align="center"><code class="literal">AFTER</code></td><td align="center"><code class="command">INSERT</code>/<code class="command">UPDATE</code>/<code class="command">DELETE</code></td><td align="center">Таблицы и сторонние таблицы</td><td align="center">Таблицы, представления и сторонние таблицы</td></tr><tr><td align="center"><code class="command">TRUNCATE</code></td><td align="center">—</td><td align="center">Таблицы и сторонние таблицы</td></tr><tr><td rowspan="2" align="center"><code class="literal">INSTEAD OF</code></td><td align="center"><code class="command">INSERT</code>/<code class="command">UPDATE</code>/<code class="command">DELETE</code></td><td align="center">Представления</td><td align="center">—</td></tr><tr><td align="center"><code class="command">TRUNCATE</code></td><td align="center">—</td><td align="center">—</td></tr></tbody></table></div><p>Кроме того, в определении триггера можно указать логическое условие <code class="literal">WHEN</code>, которое определит, вызывать триггер или нет. В триггерах на уровне строк условия <code class="literal">WHEN</code> могут проверять старые и/или новые значения столбцов в строке. Триггеры на уровне оператора так же могут содержать условие <code class="literal">WHEN</code>, хотя для них это не столь полезно, так как в этом условии нельзя ссылаться на какие-либо значения в таблице.</p><p>Если для одного события определено несколько триггеров одного типа, они будут срабатывать в алфавитном порядке их имён.</p><p>Когда указывается параметр <code class="literal">CONSTRAINT</code>, эта команда создаёт <em class="firstterm">триггер ограничения</em>.<a id="id-1.9.3.93.6.12.3" class="indexterm"></a> Он подобен обычным триггерам, но отличается тем, что время его срабатывания можно изменить командой <a class="link" href="sql-set-constraints.html" title="SET CONSTRAINTS"><code class="command">SET CONSTRAINTS</code></a>. Триггеры ограничений должны быть триггерами типа <code class="literal">AFTER ROW</code> для обычных (не сторонних) таблиц. Они могут срабатывать либо в конце оператора, вызвавшего целевое событие, либо в конце содержащей его транзакции; в последнем случае они называются <em class="firstterm">отложенными</em>. Срабатывание ожидающего отложенного триггера можно вызвать немедленно, воспользовавшись командой <code class="command">SET CONSTRAINTS</code>. Предполагается, что триггеры ограничений будут генерировать исключения при нарушении ограничений.</p><p>Когда указывается <code class="literal">REFERENCING</code>, для триггера собираются <em class="firstterm">переходные отношения</em>, представляющие собой множества строк, включающие все строки, которые были добавлены, удалены или изменены текущим оператором SQL. Это позволяет триггеру наблюдать общую картину того, что сделал оператор, а не только одну строку за другой. Это указание допускается только для триггера <code class="literal">AFTER</code>, не являющегося триггером ограничения; кроме того, если это триггер для <code class="literal">UPDATE</code>, у него должен отсутствовать список <em class="replaceable"><code>имён_столбцов</code></em>. Указание <code class="literal">OLD TABLE</code> может быть задано только один раз и только для триггера, который может срабатывать при <code class="literal">UPDATE</code> или <code class="literal">DELETE</code>; оно создаёт переходное отношение, содержащее <em class="firstterm">образы-до-изменения</em> всех строк, модифицированных или удалённых оператором. Указание <code class="literal">NEW TABLE</code>, подобным образом, может быть задано только единожды и только для триггера, который может срабатывать для <code class="literal">UPDATE</code> или <code class="literal">INSERT</code>; оно создаёт переходное отношение, содержащее <em class="firstterm">образы-после-изменения</em> всех строк, модифицированных или добавленных оператором.</p><p><code class="command">SELECT</code> не изменяет никакие строки, поэтому создавать триггеры для <code class="command">SELECT</code> нельзя. Для решения задач, в которых требуются подобные триггеры, могут подойти правила или представления.</p><p>За дополнительными сведениями о триггерах обратитесь к <a class="xref" href="triggers.html" title="Глава 39. Триггеры">Главе 39</a>.</p></div><div class="refsect1" id="id-1.9.3.93.7"><h2>Параметры</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>имя</code></em></span></dt><dd><p>Имя, назначаемое новому триггеру. Это имя должно отличаться от имени любого другого триггера в этой же таблице. Имя не может быть дополнено схемой — триггер наследует схему от своей таблицы. Для триггеров ограничений это имя также используется, когда требуется скорректировать поведение триггера с помощью команды <code class="command">SET CONSTRAINTS</code>.</p></dd><dt><span class="term"><code class="literal">BEFORE</code><br /></span><span class="term"><code class="literal">AFTER</code><br /></span><span class="term"><code class="literal">INSTEAD OF</code></span></dt><dd><p>Определяет, будет ли заданная функция вызываться до, после или вместо события. Для триггера ограничения можно указать только <code class="literal">AFTER</code>.</p></dd><dt><span class="term"><em class="replaceable"><code>событие</code></em></span></dt><dd><p>Принимает одно из значений: <code class="literal">INSERT</code>, <code class="literal">UPDATE</code>, <code class="literal">DELETE</code> или <code class="literal">TRUNCATE</code>; этот параметр определяет событие, при котором будет срабатывать триггер. Несколько событий можно указать, добавив между ними слово <code class="literal">OR</code>, если только не запрашиваются переходные отношения.</p><p>Для событий <code class="literal">UPDATE</code> можно указать список столбцов, используя такую запись: </p><pre class="synopsis">
UPDATE OF <em class="replaceable"><code>имя_столбца1</code></em> [, <em class="replaceable"><code>имя_столбца2</code></em> ... ]
</pre><p> Такой триггер сработает, только если в списке столбцов, указанном в целевой команде <code class="command">UPDATE</code>, окажется минимум один из перечисленных или если какой-нибудь из них будет генерируемым и при этом зависящим от столбца, который фигурирует в <code class="command">UPDATE</code>.</p><p>Для событий <code class="literal">INSTEAD OF UPDATE</code> указание списка столбцов не допускается. Список столбцов также нельзя задать, когда запрашиваются переходные отношения.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_таблицы</code></em></span></dt><dd><p>Имя (возможно, дополненное схемой) таблицы, представления или сторонней таблицы, для которых предназначен триггер.</p></dd><dt><span class="term"><em class="replaceable"><code>ссылающаяся_таблица</code></em></span></dt><dd><p>Имя (возможно, дополненное схемой) другой таблицы, на которую ссылается ограничение. Оно используется для ограничений внешнего ключа и не рекомендуется для обычного применения. Это указание допускается только для триггеров ограничений.</p></dd><dt><span class="term"><code class="literal">DEFERRABLE</code><br /></span><span class="term"><code class="literal">NOT DEFERRABLE</code><br /></span><span class="term"><code class="literal">INITIALLY IMMEDIATE</code><br /></span><span class="term"><code class="literal">INITIALLY DEFERRED</code></span></dt><dd><p>Время срабатывания триггера по умолчанию. Подробнее возможные варианты описаны в документации <a class="xref" href="sql-createtable.html" title="CREATE TABLE"><span class="refentrytitle">CREATE TABLE</span></a>. Это указание допускается только для триггеров ограничений.</p></dd><dt><span class="term"><code class="literal">REFERENCING</code></span></dt><dd><p>Это ключевое слово непосредственно предшествует объявлению одного или двух имён, по которым можно будет обращаться к переходным отношениями, образуемым при выполнении целевого оператора.</p></dd><dt><span class="term"><code class="literal">OLD TABLE</code><br /></span><span class="term"><code class="literal">NEW TABLE</code></span></dt><dd><p>Это предложение указывает, будет ли следующее имя относиться к переходному отношению с образом-до-изменения или к переходному отношению с образом-после-изменения.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_переходного_отношения</code></em></span></dt><dd><p>Имя (неполное, без схемы), которое будет использоваться в триггере для обращения к этому переходному отношению.</p></dd><dt><span class="term"><code class="literal">FOR EACH ROW</code><br /></span><span class="term"><code class="literal">FOR EACH STATEMENT</code></span></dt><dd><p>Определяет, будет ли функция триггера срабатывать один раз для каждой строки, либо для SQL-оператора. Если не указано ничего, подразумевается <code class="literal">FOR EACH STATEMENT</code> (для оператора). Для триггеров ограничений можно указать только <code class="literal">FOR EACH ROW</code>.</p></dd><dt><span class="term"><em class="replaceable"><code>условие</code></em></span></dt><dd><p>Логическое выражение, определяющее, будет ли выполняться функция триггера. Если для триггера задано указание <code class="literal">WHEN</code>, функция будет вызываться, только когда <em class="replaceable"><code>условие</code></em> возвращает <code class="literal">true</code>. В триггерах <code class="literal">FOR EACH ROW</code> условие <code class="literal">WHEN</code> может ссылаться на значения столбца в старой и/или новой строке, в виде <code class="literal">OLD.<em class="replaceable"><code>имя_столбца</code></em></code> и <code class="literal">NEW.<em class="replaceable"><code>имя_столбца</code></em></code>, соответственно. Разумеется, триггеры <code class="literal">INSERT</code> не могут ссылаться на <code class="literal">OLD</code>, а триггеры <code class="literal">DELETE</code> не могут ссылаться на <code class="literal">NEW</code>.</p><p>Триггеры <code class="literal">INSTEAD OF</code> не поддерживают условия <code class="literal">WHEN</code>.</p><p>В настоящее время выражения <code class="literal">WHEN</code> не могут содержать подзапросы.</p><p>Учтите, что для триггеров ограничений вычисление условия <code class="literal">WHEN</code> не откладывается, а выполняется немедленно после операции, изменяющей строки. Если результат условия — ложь, сам триггер не откладывается для последующего выполнения.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_функции</code></em></span></dt><dd><p>Заданная пользователем функция, объявленная как функция без аргументов и возвращающая тип <code class="literal">trigger</code>, которая будет вызываться при срабатывании триггера.</p><p>В синтаксисе <code class="literal">CREATE TRIGGER</code> ключевые слова <code class="literal">FUNCTION</code> и <code class="literal">PROCEDURE</code> равнозначны, но указываемая триггерная функция должна в любом случае быть функцией, а не процедурой. Ключевое слово <code class="literal">PROCEDURE</code> здесь поддерживается по историческим причинам и считается устаревшим.</p></dd><dt><span class="term"><em class="replaceable"><code>аргументы</code></em></span></dt><dd><p>Необязательный список аргументов через запятую, которые будут переданы функции при срабатывании триггера. В качестве аргументов функции передаются строковые константы. И хотя в этом списке можно записать и простые имена или числовые константы, они тоже будут преобразованы в строки. Порядок обращения к таким аргументам в функции триггера может отличаться от обычных аргументов, поэтому его следует уточнить в описании языка реализации этой функции.</p></dd></dl></div></div><div class="refsect1" id="SQL-CREATETRIGGER-NOTES"><h2>Замечания</h2><p>Чтобы создать или изменить триггер, пользователь должен иметь право <code class="literal">TRIGGER</code> для этой таблицы. Также пользователь должен иметь право <code class="literal">EXECUTE</code> для триггерной функции.</p><p>Для удаления триггера применяется команда <a class="link" href="sql-droptrigger.html" title="DROP TRIGGER"><code class="command">DROP TRIGGER</code></a>.</p><p>При создании триггера уровня строк для секционированной таблицы такой же <span class="quote">«<span class="quote">клонированный</span>»</span> триггер будет создан в каждой из её существующих секций; идентичный триггер будет установлен и в каждой секции, создаваемой или присоединяемой позднее. Если в дочерней таблице встретится триггер с конфликтующим именем, возникнет ошибка. Исключение составляет команда <code class="command">CREATE OR REPLACE TRIGGER</code>, которая заменит существующий одноимённый триггер клонированным. При отсоединения секции от родительской таблицы клонированные триггеры в ней удаляется.</p><p>Триггер для избранных столбцов (определённый с помощью <code class="literal">UPDATE OF <em class="replaceable"><code>имя_столбца</code></em></code>) будет срабатывать, когда его столбцы перечислены в качестве целевых в списке <code class="literal">SET</code> команды <code class="command">UPDATE</code>. Изменения, вносимые в строки триггерами <code class="literal">BEFORE UPDATE</code>, при этом не учитываются, поэтому значения столбцов можно изменить так, что триггер не сработает. И наоборот, при выполнении команды <code class="literal">UPDATE ... SET x = x ...</code> триггер для столбца <code class="literal">x</code> сработает, хотя значение столбца не меняется.</p><p>В триггере <code class="literal">BEFORE</code> условие <code class="literal">WHEN</code> вычисляется непосредственно перед возможным вызовом функции, поэтому проверка <code class="literal">WHEN</code> существенно не отличается от проверки того же условия в начале функции триггера. В частности, учтите, что строка <code class="literal">NEW</code>, которую видит ограничение, содержит текущие значения, возможно изменённые предыдущими триггерами. Кроме того, в триггере <code class="literal">BEFORE</code> условие <code class="literal">WHEN</code> не может проверять системные столбцы в строке <code class="literal">NEW</code> (например, <code class="literal">ctid</code>), так как они ещё не установлены.</p><p>В триггере <code class="literal">AFTER</code> условие <code class="literal">WHEN</code> проверяется сразу после изменения строки, и если оно выполняется, событие запоминается, чтобы вызвать триггер в конце оператора. Если же для триггера <code class="literal">AFTER</code> условие <code class="literal">WHEN</code> не выполняется, нет необходимости запоминать событие для последующей обработки или заново перечитывать строку в конце оператора. Это приводит к значительному ускорению операторов, изменяющих множество строк, когда триггер должен срабатывать только для некоторых из них.</p><p>В некоторых случаях одна команда SQL может вызывать сразу нескольких видов триггеров. Например, <code class="command">INSERT</code> с предложением <code class="literal">ON CONFLICT DO UPDATE</code> может выполнять операции как добавления, так и изменения, так что она при необходимости будет вызывать триггеры обоих видов. При этом переходные отношения, предоставляемые триггерам, будут разными в зависимости от типа события; то есть триггер <code class="command">INSERT</code> будет видеть только добавленные строки, а триггер <code class="command">UPDATE</code> — только изменённые.</p><p>Изменения или удаления строк, вызванные действиями по обеспечению целостности внешнего ключа, например, <code class="literal">ON UPDATE CASCADE</code> или <code class="literal">ON DELETE SET NULL</code>, считаются частью SQL-команды, вызвавшей эти действия (заметьте, что такие действия не могут быть отложенными). В затрагиваемой таблице будут вызваны соответствующие триггеры, и таким образом появляется возможность вызова триггеров для SQL-команды, не соответствующей непосредственно их типу. В простых ситуациях триггеры, запрашивающие переходные отношения, будут видеть все изменения, произведённые в их таблице одной исходной командой SQL, в виде одного переходного отношения. Однако возможны случаи, в которых присутствие триггера <code class="literal">AFTER ROW</code>, запрашивающего переходные отношения, приведёт к тому, что операции для обеспечения целостности внешнего ключа, вызванные одной SQL-командой, будут разделены на несколько этапов, и на каждом будут свои переходные отношения. В таких случаях все существующие триггеры уровня оператора будут срабатывать единожды при создании набора переходных отношений, что гарантирует, что эти триггеры будут видеть каждую обрабатываемую строку в переходном отношении один и только один раз.</p><p>Триггеры уровня операторов для представления срабатывают, только если операция с представлением обрабатывается триггером уровня строк <code class="literal">INSTEAD OF</code>. Если операция обрабатывается правилом <code class="literal">INSTEAD</code>, то вместо исходного оператора, обращающегося к представлению, выполняются те операторы, что генерирует правило, поэтому вызываться будут триггеры, связанные с таблицами, к которым обращаются эти заменяющие операторы. Аналогично, для автоматически изменяемого представления выполнение операции сводится к переписыванию оператора в виде операции с базовой таблицей представления, так что срабатывать будут триггеры уровня операторов для базовой таблицы.</p><p>При изменении данных в секционированной таблице или таблице с потомками срабатывают триггеры уровня оператора, связанные с явно задействованной таблицей, но не триггеры уровня оператора для её секций или дочерних таблиц. Триггеры уровня строк, напротив, срабатывают для строк в затрагиваемых секциях или дочерних таблицах, даже если они явно не присутствуют в запросе. Если триггер уровня оператора был определён с переходными отношениями, названными в указании <code class="literal">REFERENCING</code>, то в них будут видны образы строк из всех затронутых секций или дочерних таблиц. В случае с потомками в иерархии наследования образы строк будут содержать только столбцы, присутствующие в таблице, с которой связан триггер.</p><p>В настоящее время триггеры уровня строки с переходными отношениями нельзя определить для секций или дочерних таблиц в иерархии наследования. Кроме того, для секционированных таблиц нельзя определить триггеры <code class="literal">INSTEAD OF</code>.</p><p>В настоящее время указание <code class="literal">OR REPLACE</code> не поддерживается для триггеров ограничений.</p><p>Заменять существующий триггер в рамках транзакции, которая уже выполнила действие, изменяющее данные в таблице триггера, не рекомендуется. Решения по срабатыванию триггера, как и их составляющие, принятые ранее, не будут пересмотрены, поэтому эффект такой операции может быть неожиданным.</p><p>Некоторые общие задачи можно решить с применением встроенных триггерных функций, обойдясь без написания собственного кода; см. <a class="xref" href="functions-trigger.html" title="9.28. Триггерные функции">Раздел 9.28</a>.</p></div><div class="refsect1" id="SQL-CREATETRIGGER-EXAMPLES"><h2>Примеры</h2><p>Выполнение функции <code class="function">check_account_update</code> перед любым изменением строк в таблице <code class="literal">accounts</code>: </p><pre class="programlisting">CREATE TRIGGER check_update
    BEFORE UPDATE ON accounts
    FOR EACH ROW
    EXECUTE FUNCTION check_account_update();</pre><p> Изменение определения триггера, чтобы данная функция выполнялась только при указании столбца <code class="literal">balance</code> в качестве целевого столбца команды <code class="command">UPDATE</code>: </p><pre class="programlisting">CREATE OR REPLACE TRIGGER check_update
    BEFORE UPDATE OF balance ON accounts
    FOR EACH ROW
    EXECUTE FUNCTION check_account_update();</pre><p> В этом примере функция будет выполняться, если значение столбца <code class="literal">balance</code> в действительности изменилось: </p><pre class="programlisting">CREATE TRIGGER check_update
    BEFORE UPDATE ON accounts
    FOR EACH ROW
    WHEN (OLD.balance IS DISTINCT FROM NEW.balance)
    EXECUTE FUNCTION check_account_update();</pre><p> Вызов функции, ведущей журнал изменений в <code class="literal">accounts</code>, но только если что-то изменилось: </p><pre class="programlisting">CREATE TRIGGER log_update
    AFTER UPDATE ON accounts
    FOR EACH ROW
    WHEN (OLD.* IS DISTINCT FROM NEW.*)
    EXECUTE FUNCTION log_account_update();</pre><p> Выполнение для каждой строки функции <code class="function">view_insert_row</code>, которая будет вставлять строки в нижележащие таблицы представления: </p><pre class="programlisting">CREATE TRIGGER view_insert
    INSTEAD OF INSERT ON my_view
    FOR EACH ROW
    EXECUTE FUNCTION view_insert_row();</pre><p> Выполнение функции <code class="function">check_transfer_balances_to_zero</code> для каждого оператора, проверяющей, что строки <code class="literal">transfer</code> в совокупности дают нулевой баланс: </p><pre class="programlisting">CREATE TRIGGER transfer_insert
    AFTER INSERT ON transfer
    REFERENCING NEW TABLE AS inserted
    FOR EACH STATEMENT
    EXECUTE FUNCTION check_transfer_balances_to_zero();</pre><p> Выполнение функции <code class="function">check_matching_pairs</code> для каждой строки, проверяющей, что соответствующие пары пунктов изменены синхронно (одним оператором): </p><pre class="programlisting">CREATE TRIGGER paired_items_update
    AFTER UPDATE ON paired_items
    REFERENCING NEW TABLE AS newtab OLD TABLE AS oldtab
    FOR EACH ROW
    EXECUTE FUNCTION check_matching_pairs();</pre><p>В <a class="xref" href="trigger-example.html" title="39.4. Полный пример триггера">Разделе 39.4</a> приведён полный пример функции триггера, написанной на C.</p></div><div class="refsect1" id="SQL-CREATETRIGGER-COMPATIBILITY"><h2>Совместимость</h2><p>Оператор <code class="command">CREATE TRIGGER</code> в <span class="productname">PostgreSQL</span> реализует подмножество возможностей, описанных в стандарте <acronym class="acronym">SQL</acronym>. В настоящее время в нём отсутствует следующая функциональность: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Тогда как имена переходных таблиц для триггеров <code class="literal">AFTER</code> задаются предложением <code class="literal">REFERENCING</code> стандартным образом, переменные строк, применяемые в триггерах <code class="literal">FOR EACH ROW</code> нельзя объявлять в предложении <code class="literal">REFERENCING</code>. Порядок обращения к таким строкам зависит от языка, на котором написана триггерная функция, но для каждого языка он вполне определённый. Некоторые языки по сути действуют так, как будто в команде присутствует предложение <code class="literal">REFERENCING</code> с указанием <code class="literal">OLD ROW AS OLD NEW ROW AS NEW</code>.</p></li><li class="listitem"><p>Стандарт позволяет использовать переходные таблицы с триггерами <code class="literal">UPDATE</code>, ограничивающими набор отслеживаемых столбцов, но тогда и набор строк, видимых в переходных таблицах, должен зависеть от списка целевых столбцов триггера. В настоящее время такое поведение в <span class="productname">PostgreSQL</span> не реализовано.</p></li><li class="listitem"><p><span class="productname">PostgreSQL</span> позволяет задать в качестве действия триггера только функцию, определённую пользователем. Стандарт допускает также выполнение ряда других команд SQL, например, <code class="command">CREATE TABLE</code>. Однако это ограничение несложно преодолеть, создав пользовательскую функцию, выполняющую требуемые команды.</p></li></ul></div><p>В стандарте SQL определено, что несколько триггеров должны срабатывать по порядку создания. <span class="productname">PostgreSQL</span> упорядочивает их по именам, так как это было признано более удобным.</p><p>В стандарте SQL определено, что триггеры <code class="literal">BEFORE DELETE</code> при каскадном удалении срабатывают <span class="emphasis"><em>после</em></span> завершения каскадного <code class="literal">DELETE</code>. В <span class="productname">PostgreSQL</span> триггеры <code class="literal">BEFORE DELETE</code> всегда срабатывают перед операцией удаления, даже если она каскадная. Это поведение выбрано как более логичное. Ещё одно отклонение от стандарта проявляется, когда триггеры <code class="literal">BEFORE</code>, срабатывающие в результате ссылочной операции, изменяют строки или не дают выполнить изменение. Это может привести к нарушению ограничений или сохранению данных, не соблюдающих ссылочную целостность.</p><p>Возможность задать несколько действий для одного триггера с помощью ключевого слова <code class="literal">OR</code> — реализованное в <span class="productname">PostgreSQL</span> расширение стандарта SQL.</p><p>Возможность вызывать триггеры для <code class="command">TRUNCATE</code> — реализованное в <span class="productname">PostgreSQL</span> расширение стандарта SQL, как и возможность определять триггеры на уровне оператора для представлений.</p><p><code class="command">CREATE CONSTRAINT TRIGGER</code> — реализованное в <span class="productname">PostgreSQL</span> расширение стандарта <acronym class="acronym">SQL</acronym>, так же как и указание <code class="literal">OR REPLACE</code>.</p></div><div class="refsect1" id="id-1.9.3.93.11"><h2>См. также</h2><span class="simplelist"><a class="xref" href="sql-altertrigger.html" title="ALTER TRIGGER"><span class="refentrytitle">ALTER TRIGGER</span></a>, <a class="xref" href="sql-droptrigger.html" title="DROP TRIGGER"><span class="refentrytitle">DROP TRIGGER</span></a>, <a class="xref" href="sql-createfunction.html" title="CREATE FUNCTION"><span class="refentrytitle">CREATE FUNCTION</span></a>, <a class="xref" href="sql-set-constraints.html" title="SET CONSTRAINTS"><span class="refentrytitle">SET CONSTRAINTS</span></a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-createtransform.html" title="CREATE TRANSFORM">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-createtype.html" title="CREATE TYPE">След.</a></td></tr><tr><td width="40%" align="left" valign="top">CREATE TRANSFORM </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> CREATE TYPE</td></tr></table></div></body></html>