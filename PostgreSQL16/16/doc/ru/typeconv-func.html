<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>10.3. Функции</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="typeconv-oper.html" title="10.2. Операторы" /><link rel="next" href="typeconv-query.html" title="10.4. Хранимое значение" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">10.3. Функции</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="typeconv-oper.html" title="10.2. Операторы">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="typeconv.html" title="Глава 10. Преобразование типов">Наверх</a></td><th width="60%" align="center">Глава 10. Преобразование типов</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="typeconv-query.html" title="10.4. Хранимое значение">След.</a></td></tr></table><hr /></div><div class="sect1" id="TYPECONV-FUNC"><div class="titlepage"><div><div><h2 class="title" style="clear: both">10.3. Функции <a href="#TYPECONV-FUNC" class="id_link">#</a></h2></div></div></div><a id="id-1.5.9.8.2" class="indexterm"></a><p>При выборе конкретной функции, задействованной в выражении, <span class="productname">PostgreSQL</span> следует описанному ниже алгоритму.</p><div class="procedure" id="id-1.5.9.8.4"><p class="title"><strong>Разрешение функции по типу</strong></p><ol class="procedure" type="1"><li class="step"><p>Выбрать функции для рассмотрения из системного каталога <code class="classname">pg_proc</code>. Если имя функции не дополнено именем схемы, будут рассматриваться все функции с подходящим именем и числом аргументов, видимые в текущем пути поиска (см. <a class="xref" href="ddl-schemas.html#DDL-SCHEMAS-PATH" title="5.9.3. Путь поиска схемы">Подраздел 5.9.3</a>). Если имя функции определено полностью, в рассмотрение принимаются только функции из указанной схемы.</p><ol type="a" class="substeps"><li class="step"><p>Если в пути поиска оказывается несколько функций с одинаковыми типами аргументов, учитываются только те из них, которые находятся в пути раньше. Функции с разными типами аргументов рассматриваются на равных правах вне зависимости от их положения в пути поиска.</p></li><li class="step"><p>Если в числе параметров функции есть массив <code class="literal">VARIADIC</code> и при вызове не указывается ключевое слово <code class="literal">VARIADIC</code>, функция обрабатывается, как если бы этот параметр был заменён одним или несколькими параметрами типа элементов массива, по числу аргументов при вызове. После такого расширения по фактическим типам аргументов она может совпасть с некоторой функцией с постоянным числом аргументов. В этом случае используется функция, которая находится в пути раньше, а если они оказываются в одной схеме, предпочитается вариант с постоянными аргументами.</p><p>Это создаёт угрозу безопасности при вызове с полным именем <a href="#ftn.FUNC-QUALIFIED-SECURITY" class="footnote"><sup class="footnote" id="FUNC-QUALIFIED-SECURITY">[10]</sup></a> функции с переменным числом аргументов, которая может оказаться в схеме, где могут создавать объекты недоверенные пользователи. Злонамеренный пользователь может перехватывать управление и выполнять произвольные SQL-функции, как будто их выполняете вы. Запись вызова с ключевым словом <code class="literal">VARIADIC</code> устраняет эту угрозу. Однако для вызовов с передачей параметров <code class="literal">VARIADIC "any"</code> часто не существует необходимой формулировки с ключом <code class="literal">VARIADIC</code>. Чтобы такие вызовы были безопасными, создание объектов в схеме функции должно разрешаться только доверенным пользователям.</p></li><li class="step"><p>Функции, для которых определены значения параметров по умолчанию, считаются совпадающими с вызовом, в котором опущено ноль или более параметров в соответствующих позициях. Если для вызова подходят несколько функций, используется та, что обнаруживается в пути поиска раньше. Если в одной схеме оказываются несколько функций с одинаковыми типами в позициях обязательных параметров (что возможно, если в них определены разные наборы пропускаемых параметров), система не сможет выбрать оптимальную, и выдаст ошибку <span class="quote">«<span class="quote">неоднозначный вызов функции</span>»</span>, если лучшее соответствие для вызова не будет найдено.</p><p>Это создаёт угрозу при вызове с полным именем <a href="typeconv-func.html#ftn.FUNC-QUALIFIED-SECURITY" class="footnoteref"><sup class="footnoteref">[10]</sup></a> любой функции, которая может оказаться в схеме, где могут создавать объекты недоверенные пользователи. Злонамеренный пользователь может создать функцию с именем уже существующей, продублировав параметры исходной и добавив дополнительные со значениями по умолчанию. В результате при последующих вызовах будет выполняться не исходная функция. Для ликвидации этой угрозы помещайте функции в схемы, в которых создавать объекты могут только доверенные объекты.</p></li></ol></li><li class="step"><p>Проверить, нет ли функции, принимающей в точности типы входных аргументов. Если такая функция есть (она может быть только одной в отобранном ранее наборе), использовать её. Отсутствие точного совпадения создаёт угрозу вызова с полным именем <a href="typeconv-func.html#ftn.FUNC-QUALIFIED-SECURITY" class="footnoteref"><sup class="footnoteref">[10]</sup></a> функции в схеме, где могут создавать объекты недоверенные пользователи. В таких ситуациях приведите типы аргументов для получения точного соответствия. (В случаях с <code class="type">unknown</code> совпадения на этом этапе не будет никогда.)</p></li><li class="step"><p>Если точное совпадение не найдено, проверить, не похож ли вызов функции на особую форму преобразования типов. Это имеет место, когда при вызове функции передаётся всего один аргумент и имя функции совпадает с именем (внутренним) некоторого типа данных. Более того, аргументом функции должна быть либо строка неопределённого типа, либо значение типа, двоично-совместимого с указанным или приводимого к нему с помощью функций ввода/вывода типа (то есть, преобразований в стандартный строковый тип и обратно). Если эти условия выполняются, вызов функции воспринимается как особая форма конструкции <code class="literal">CAST</code>. <a href="#ftn.id-1.5.9.8.4.4.1.2" class="footnote"><sup class="footnote" id="id-1.5.9.8.4.4.1.2">[11]</sup></a></p></li><li class="step"><p>Найти самый подходящий.</p><ol type="a" class="substeps"><li class="step"><p>Отбросить кандидатов, для которых входные типы не совпадают и не могут быть преобразованы (неявным образом) так, чтобы они совпали. В данном случае считается, что константы типа <code class="type">unknown</code> можно преобразовать во что угодно. Если остаётся только один кандидат, использовать его, в противном случае перейти к следующему шагу.</p></li><li class="step"><p>Если один из аргументов имеет тип домен, далее считать его типом базовый тип домена. Благодаря этому при поиске неоднозначно заданной функции домены будут подобны свои базовым типам.</p></li><li class="step"><p>Просмотреть всех кандидатов и оставить только тех, для которых точно совпадают как можно больше типов аргументов. Оставить всех кандидатов, если точных совпадений нет. Если остаётся только один кандидат, использовать его, в противном случае перейти к следующему шагу.</p></li><li class="step"><p>Просмотреть всех кандидатов и оставить только тех, которые принимают предпочитаемые типы (из категории типов входных значений) в наибольшем числе позиций, где требуется преобразование типов. Оставить всех кандидатов, если ни один не принимает предпочитаемые типы. Если остаётся только один кандидат, использовать его, в противном случае перейти к следующему шагу.</p></li><li class="step"><p>Если какие-либо значения имеют тип <code class="type">unknown</code>, проверить категории типов, принимаемых в данных позициях аргументов оставшимися кандидатами. Для каждой позиции выбрать категорию <code class="type">string</code>, если какой-либо кандидат принимает эту категорию. (Эта склонность к строкам объясняется тем, что константа типа unknown выглядит как строка.) Если эта категория не подходит, но все оставшиеся кандидаты принимают одну категорию, выбрать её; в противном случае констатировать неудачу — сделать правильный выбор без дополнительных подсказок нельзя. Затем отбросить кандидатов, которые не принимают типы выбранной категории. Далее, если какой-либо кандидат принимает предпочитаемый тип из этой категории, отбросить кандидатов, принимающих другие, не предпочитаемые типы для данного аргумента. Оставить всех кандидатов, если эти проверки не прошёл ни один. Если остаётся только один кандидат, использовать его, в противном случае перейти к следующему шагу.</p></li><li class="step"><p>Если в списке аргументов есть аргументы и типа <code class="type">unknown</code>, и известного типа, и этот известный тип один для всех аргументов, предположить, что аргументы типа <code class="type">unknown</code> также имеют этот тип, и проверить, какие кандидаты могут принимать этот тип в позиции аргумента <code class="type">unknown</code>. Если остаётся только один кандидат, использовать его, в противном случае констатировать неудачу.</p></li></ol></li></ol></div><p>Заметьте, что для функций действуют те же правила <span class="quote">«<span class="quote">оптимального соответствия</span>»</span>, что и для операторов. Они проиллюстрированы следующими примерами.</p><div class="example" id="id-1.5.9.8.6"><p class="title"><strong>Пример 10.6. Разрешение функции округления по типам аргументов</strong></p><div class="example-contents"><p>В <span class="productname">PostgreSQL</span> есть только одна функция <code class="function">round</code>, принимающая два аргумента: первый типа <code class="type">numeric</code>, а второй — <code class="type">integer</code>. Поэтому в следующем запросе первый аргумент <code class="type">integer</code> автоматически приводится к типу <code class="type">numeric</code>: </p><pre class="screen">
SELECT round(4, 4);

 round
--------
 4.0000
(1 row)
</pre><p> Таким образом, анализатор преобразует этот запрос в: </p><pre class="screen">
SELECT round(CAST (4 AS numeric), 4);
</pre><p>Так как числовые константы с десятичными точками изначально относятся к типу <code class="type">numeric</code>, для следующего запроса преобразование типов не потребуется, так что он немного эффективнее: </p><pre class="screen">
SELECT round(4.0, 4);
</pre></div></div><br class="example-break" /><div class="example" id="id-1.5.9.8.7"><p class="title"><strong>Пример 10.7. Разрешение функций с переменными параметрами</strong></p><div class="example-contents"><pre class="screen">
CREATE FUNCTION public.variadic_example(VARIADIC numeric[]) RETURNS int
  LANGUAGE sql AS 'SELECT 1';
CREATE FUNCTION
</pre><p> Эта функция принимает в аргументах ключевое слово VARIADIC, но может вызываться и без него. Ей можно передавать и целочисленные, и любые числовые аргументы: </p><pre class="screen">
SELECT public.variadic_example(0),
       public.variadic_example(0.0),
       public.variadic_example(VARIADIC array[0.0]);
 variadic_example | variadic_example | variadic_example
------------------+------------------+------------------
                1 |                1 |                1
(1 row)
</pre><p> Однако для первого и второго вызова предпочтительнее окажутся специализированные функции, если таковые есть: </p><pre class="screen">
CREATE FUNCTION public.variadic_example(numeric) RETURNS int
  LANGUAGE sql AS 'SELECT 2';
CREATE FUNCTION

CREATE FUNCTION public.variadic_example(int) RETURNS int
  LANGUAGE sql AS 'SELECT 3';
CREATE FUNCTION

SELECT public.variadic_example(0),
       public.variadic_example(0.0),
       public.variadic_example(VARIADIC array[0.0]);
 variadic_example | variadic_example | variadic_example
------------------+------------------+------------------
                3 |                2 |                1
(1 row)
</pre><p> Если используется конфигурация по умолчанию и существует только первая функция, первый и второй вызовы будут небезопасными. Любой пользователь может перехватить их, создав вторую или третью функцию. Безопасным будет третий вызов, в котором тип аргумента соответствует в точности и используется ключевое слово <code class="literal">VARIADIC</code>.</p></div></div><br class="example-break" /><div class="example" id="id-1.5.9.8.8"><p class="title"><strong>Пример 10.8. Разрешение функции извлечения подстроки</strong></p><div class="example-contents"><p>В <span class="productname">PostgreSQL</span> есть несколько вариантов функции <code class="function">substr</code>, и один из них принимает аргументы типов <code class="type">text</code> и <code class="type">integer</code>. Если эта функция вызывается со строковой константой неопределённого типа, система выбирает функцию, принимающую аргумент предпочитаемой категории <code class="literal">string</code> (а конкретнее, типа <code class="type">text</code>). </p><pre class="screen">
SELECT substr('1234', 3);

 substr
--------
     34
(1 row)
</pre><p>Если текстовая строка имеет тип <code class="type">varchar</code>, например когда данные поступают из таблицы, анализатор попытается привести её к типу <code class="type">text</code>: </p><pre class="screen">
SELECT substr (varchar '1234', 3);

 substr
--------
     34
(1 row)
</pre><p> Этот запрос анализатор фактически преобразует в: </p><pre class="screen">
SELECT substr(CAST (varchar '1234' AS text), 3);
</pre><p>
</p><div class="note"><h3 class="title">Примечание</h3><p>Анализатор узнаёт из каталога <code class="structname">pg_cast</code>, что типы <code class="type">text</code> и <code class="type">varchar</code> двоично-совместимы, что означает, что один тип можно передать функции, принимающей другой, не выполняя физического преобразования. Таким образом, в данном случае операция преобразования на самом не добавляется.</p></div><p>
</p><p>И если функция вызывается с аргументом типа <code class="type">integer</code>, анализатор попытается преобразовать его в тип <code class="type">text</code>: </p><pre class="screen">
SELECT substr(1234, 3);
ОШИБКА: функция substr(integer, integer) не существует
ПОДСКАЗКА: Функция с данными именем и типами аргументов не найдена. Возможно, вам
следует добавить явные преобразования типов.
</pre><p> Этот вариант не работает, так как <code class="type">integer</code> нельзя неявно преобразовать в <code class="type">text</code>. Однако с явным преобразованием запрос выполняется: </p><pre class="screen">
SELECT substr(CAST (1234 AS text), 3);

 substr
--------
     34
(1 row)
</pre></div></div><br class="example-break" /><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.FUNC-QUALIFIED-SECURITY" class="footnote"><p><a href="#FUNC-QUALIFIED-SECURITY" class="para"><sup class="para">[10] </sup></a>Эта угроза неактуальна для имён без схемы, так как путь поиска, содержащий схемы, в которых недоверенные пользователи могут создавать объекты, не соответствует <a class="link" href="ddl-schemas.html#DDL-SCHEMAS-PATTERNS" title="5.9.6. Шаблоны использования">шаблону безопасного использования схем</a>.</p></div><div id="ftn.id-1.5.9.8.4.4.1.2" class="footnote"><p><a href="#id-1.5.9.8.4.4.1.2" class="para"><sup class="para">[11] </sup></a>Этот шаг нужен для поддержки приведений типов в стиле вызова функции, когда на самом деле соответствующей функции приведения нет. Если такая функция приведения есть, она обычно называется именем выходного типа и необходимости в особом подходе нет. За дополнительными комментариями обратитесь к <a class="xref" href="sql-createcast.html" title="CREATE CAST"><span class="refentrytitle">CREATE CAST</span></a>.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="typeconv-oper.html" title="10.2. Операторы">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="typeconv.html" title="Глава 10. Преобразование типов">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="typeconv-query.html" title="10.4. Хранимое значение">След.</a></td></tr><tr><td width="40%" align="left" valign="top">10.2. Операторы </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 10.4. Хранимое значение</td></tr></table></div></body></html>