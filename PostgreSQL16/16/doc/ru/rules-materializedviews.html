<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>41.3. Материализованные представления</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="rules-views.html" title="41.2. Система правил и представления" /><link rel="next" href="rules-update.html" title="41.4. Правила для INSERT, UPDATE и DELETE" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">41.3. Материализованные представления</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="rules-views.html" title="41.2. Система правил и представления">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="rules.html" title="Глава 41. Система правил">Наверх</a></td><th width="60%" align="center">Глава 41. Система правил</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="rules-update.html" title="41.4. Правила для INSERT, UPDATE и DELETE">След.</a></td></tr></table><hr /></div><div class="sect1" id="RULES-MATERIALIZEDVIEWS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">41.3. Материализованные представления <a href="#RULES-MATERIALIZEDVIEWS" class="id_link">#</a></h2></div></div></div><a id="id-1.8.6.8.2" class="indexterm"></a><a id="id-1.8.6.8.3" class="indexterm"></a><a id="id-1.8.6.8.4" class="indexterm"></a><p>Материализованные представления в <span class="productname">PostgreSQL</span> основаны на системе правил, как и представления, но их содержимое сохраняется как таблица. Основное отличие между: </p><pre class="programlisting">CREATE MATERIALIZED VIEW mymatview AS SELECT * FROM mytab;</pre><p> и этой командой: </p><pre class="programlisting">CREATE TABLE mymatview AS SELECT * FROM mytab;</pre><p> состоит в том, что материализованное представление впоследствии нельзя будет изменить непосредственно, а запрос, создающий материализованное представление, сохраняется точно так же, как запрос представления, и получить актуальные данные в материализованном представлении можно так: </p><pre class="programlisting">REFRESH MATERIALIZED VIEW mymatview;</pre><p> Информация о материализованном представлении в системных каталогах <span class="productname">PostgreSQL</span> ничем не отличается от информации о таблице или представлении. Поэтому для анализатора запроса материализованное представление является просто отношением, как таблица или представление. Когда запрос обращается к материализованному представлению, данные возвращаются непосредственно из него, как из таблицы; правило применяется, только чтобы его наполнить.</p><p>Хотя обращение к данным в материализованном представлении часто выполняется гораздо быстрее, чем обращение к нижележащим таблицам напрямую или через представление, данные в нём не всегда актуальные (но иногда это вполне приемлемо). Рассмотрим таблицу с данными продаж: </p><pre class="programlisting">CREATE TABLE invoice (
    invoice_no    integer        PRIMARY KEY,
    seller_no     integer,       -- идентификатор продавца
    invoice_date  date,          -- дата продажи
    invoice_amt   numeric(13,2)  -- сумма продажи
);</pre><p> Если пользователям нужно быстро обработать исторические данные, возможно их интересуют только общие показатели, а полнота данных на текущий момент не важна: </p><pre class="programlisting">CREATE MATERIALIZED VIEW sales_summary AS
  SELECT
      seller_no,
      invoice_date,
      sum(invoice_amt)::numeric(13,2) as sales_amt
    FROM invoice
    WHERE invoice_date &lt; CURRENT_DATE
    GROUP BY
      seller_no,
      invoice_date;

CREATE UNIQUE INDEX sales_summary_seller
  ON sales_summary (seller_no, invoice_date);</pre><p> Это материализованное представление может быть полезно для построения графика в информационной панели менеджеров по продажам. Для ежесуточного обновления статистики можно запланировать задание по расписанию, которое будет выполнять этот оператор: </p><pre class="programlisting">REFRESH MATERIALIZED VIEW sales_summary;</pre><p>Ещё одно применение материализованного представления — предоставить быстрый доступ к данным, получаемым с удалённой системы через обёртку сторонних данных. Ниже приведён простой пример с обёрткой <code class="literal">file_fdw</code>, с замерами времени, но так как при этом использовался кеш локальной системы, выигрыш в производительности при обращении к удалённой системе обычно будет гораздо больше, чем показано здесь. Заметьте, что мы также использовали возможность добавить индекс в материализованное представление, тогда как <code class="literal">file_fdw</code> индексы не поддерживает; при других видах доступа к сторонним данным такого преимущества может не быть.</p><p>Подготовка: </p><pre class="programlisting">CREATE EXTENSION file_fdw;
CREATE SERVER local_file FOREIGN DATA WRAPPER file_fdw;
CREATE FOREIGN TABLE words (word text NOT NULL)
  SERVER local_file
  OPTIONS (filename '/usr/share/dict/words');
CREATE MATERIALIZED VIEW wrd AS SELECT * FROM words;
CREATE UNIQUE INDEX wrd_word ON wrd (word);
CREATE EXTENSION pg_trgm;
CREATE INDEX wrd_trgm ON wrd USING gist (word gist_trgm_ops);
VACUUM ANALYZE wrd;</pre><p> Теперь давайте проверим написание слова. Сначала непосредственно через обёртку <code class="literal">file_fdw</code>: </p><pre class="programlisting">SELECT count(*) FROM words WHERE word = 'caterpiler';

 count
-------
     0
(1 row)</pre><p> Выполнив <code class="command">EXPLAIN ANALYZE</code>, мы получаем: </p><pre class="programlisting"> Aggregate  (cost=21763.99..21764.00 rows=1 width=0) (actual time=188.180..188.181 rows=1 loops=1)
   -&gt;  Foreign Scan on words  (cost=0.00..21761.41 rows=1032 width=0) (actual time=188.177..188.177 rows=0 loops=1)
         Filter: (word = 'caterpiler'::text)
         Rows Removed by Filter: 479829
         Foreign File: /usr/share/dict/words
         Foreign File Size: 4953699
 Planning time: 0.118 ms
 Execution time: 188.273 ms</pre><p> Если же теперь обратиться к материализованному представлению, запрос выполнится гораздо быстрее: </p><pre class="programlisting"> Aggregate  (cost=4.44..4.45 rows=1 width=0) (actual time=0.042..0.042 rows=1 loops=1)
   -&gt;  Index Only Scan using wrd_word on wrd  (cost=0.42..4.44 rows=1 width=0) (actual time=0.039..0.039 rows=0 loops=1)
         Index Cond: (word = 'caterpiler'::text)
         Heap Fetches: 0
 Planning time: 0.164 ms
 Execution time: 0.117 ms</pre><p> В любом случае слово записано неправильно, поэтому давайте попробуем найти то, что имелось в виду. Сначала опять через <code class="literal">file_fdw</code> и <code class="literal">pg_trgm</code>: </p><pre class="programlisting">SELECT word FROM words ORDER BY word &lt;-&gt; 'caterpiler' LIMIT 10;

     word
---------------
 cater
 caterpillar
 Caterpillar
 caterpillars
 caterpillar's
 Caterpillar's
 caterer
 caterer's
 caters
 catered
(10 rows)</pre><p> </p><pre class="programlisting"> Limit  (cost=11583.61..11583.64 rows=10 width=32) (actual time=1431.591..1431.594 rows=10 loops=1)
   -&gt;  Sort  (cost=11583.61..11804.76 rows=88459 width=32) (actual time=1431.589..1431.591 rows=10 loops=1)
         Sort Key: ((word &lt;-&gt; 'caterpiler'::text))
         Sort Method: top-N heapsort  Memory: 25kB
         -&gt;  Foreign Scan on words  (cost=0.00..9672.05 rows=88459 width=32) (actual time=0.057..1286.455 rows=479829 loops=1)
               Foreign File: /usr/share/dict/words
               Foreign File Size: 4953699
 Planning time: 0.128 ms
 Execution time: 1431.679 ms</pre><p> Затем через материализованное представление: </p><pre class="programlisting"> Limit  (cost=0.29..1.06 rows=10 width=10) (actual time=187.222..188.257 rows=10 loops=1)
   -&gt;  Index Scan using wrd_trgm on wrd  (cost=0.29..37020.87 rows=479829 width=10) (actual time=187.219..188.252 rows=10 loops=1)
         Order By: (word &lt;-&gt; 'caterpiler'::text)
 Planning time: 0.196 ms
 Execution time: 198.640 ms</pre><p> Если периодическое обновление данных из другого источника в локальной базе данных вас устраивает, этот подход может дать значительный выигрыш в скорости.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="rules-views.html" title="41.2. Система правил и представления">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="rules.html" title="Глава 41. Система правил">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="rules-update.html" title="41.4. Правила для INSERT, UPDATE и DELETE">След.</a></td></tr><tr><td width="40%" align="left" valign="top">41.2. Система правил и представления </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 41.4. Правила для <code class="command">INSERT</code>, <code class="command">UPDATE</code> и <code class="command">DELETE</code></td></tr></table></div></body></html>