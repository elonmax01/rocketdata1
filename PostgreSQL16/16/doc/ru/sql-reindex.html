<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>REINDEX</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sql-refreshmaterializedview.html" title="REFRESH MATERIALIZED VIEW" /><link rel="next" href="sql-release-savepoint.html" title="RELEASE SAVEPOINT" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">REINDEX</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-refreshmaterializedview.html" title="REFRESH MATERIALIZED VIEW">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><th width="60%" align="center">Команды SQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-release-savepoint.html" title="RELEASE SAVEPOINT">След.</a></td></tr></table><hr /></div><div class="refentry" id="SQL-REINDEX"><div class="titlepage"></div><a id="id-1.9.3.163.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">REINDEX</span></h2><p>REINDEX — перестроить индексы</p></div><div class="refsynopsisdiv"><h2>Синтаксис</h2><pre class="synopsis">REINDEX [ ( <em class="replaceable"><code>параметр</code></em> [, ...] ) ] { INDEX | TABLE | SCHEMA } [ CONCURRENTLY ] <em class="replaceable"><code>имя</code></em>
REINDEX [ ( <em class="replaceable"><code>параметр</code></em> [, ...] ) ] { DATABASE | SYSTEM } [ CONCURRENTLY ] [ <em class="replaceable"><code>имя</code></em> ]

<span class="phrase">Здесь допускается <em class="replaceable"><code>параметр</code></em>:</span>

    CONCURRENTLY [ <em class="replaceable"><code>логическое_значение</code></em> ]
    TABLESPACE <em class="replaceable"><code>новое_табл_пространство</code></em>
    VERBOSE [ <em class="replaceable"><code>логическое_значение</code></em> ]</pre></div><div class="refsect1" id="id-1.9.3.163.5"><h2>Описание</h2><p><code class="command">REINDEX</code> перестраивает индекс, обрабатывая данные таблицы, к которой относится индекс, и в результате заменяет старую копию индекса. Команда <code class="command">REINDEX</code> применяется в следующих ситуациях: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Индекс был повреждён, его содержимое стало некорректным. Хотя в теории этого не должно случаться, на практике индексы могут испортиться из-за программных ошибок или аппаратных сбоев. В таких случаях <code class="command">REINDEX</code> служит методом восстановления индекса.</p></li><li class="listitem"><p>Индекс стал <span class="quote">«<span class="quote">раздутым</span>»</span>, то есть в нём оказалось много пустых или почти пустых страниц. Это может происходить с B-деревьями в <span class="productname">PostgreSQL</span> при определённых, достаточно редких сценариях использования. <code class="command">REINDEX</code> даёт возможность сократить объём, занимаемый индексом, записывая новую версию индекса без «мёртвых» страниц. За подробностями обратитесь к <a class="xref" href="routine-reindex.html" title="25.2. Регулярная переиндексация">Разделу 25.2</a>.</p></li><li class="listitem"><p>Параметр хранения индекса (например, фактор заполнения) был изменён, и теперь требуется, чтобы это изменение вступило в силу в полной мере.</p></li><li class="listitem"><p>Если построить индекс в режиме <code class="literal">CONCURRENTLY</code> не удаётся, индекс остаётся в <span class="quote">«<span class="quote">нерабочем</span>»</span> состоянии. Такие индексы бесполезны, но их можно легко перестроить, воспользовавшись командой <code class="command">REINDEX</code>. Однако заметьте, что перестраивать индекс в неблокирующем режиме может только команда <code class="command">REINDEX INDEX</code>.</p></li></ul></div></div><div class="refsect1" id="id-1.9.3.163.6"><h2>Параметры</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">INDEX</code></span></dt><dd><p>Перестраивает указанный индекс. Эту форму <code class="command">REINDEX</code> нельзя выполнить в блоке транзакции, если индекс является секционированным.</p></dd><dt><span class="term"><code class="literal">TABLE</code></span></dt><dd><p>Перестраивает все индексы указанной таблицы. Если таблица имеет вторичную таблицу <span class="quote">«<span class="quote">TOAST</span>»</span>, она также будет переиндексирована. Эту форму <code class="command">REINDEX</code> нельзя выполнить в блоке транзакции, если таблица является секционированной.</p></dd><dt><span class="term"><code class="literal">SCHEMA</code></span></dt><dd><p>Перестраивает все индексы в указанной схеме. Если таблица в этой схеме имеет вторичную таблицу <span class="quote">«<span class="quote">TOAST</span>»</span>, она также будет переиндексирована. При этом обрабатываются и индексы в общих системных каталогах. Эту форму <code class="command">REINDEX</code> нельзя выполнить в блоке транзакции.</p></dd><dt><span class="term"><code class="literal">DATABASE</code></span></dt><dd><p>Перестраивает все индексы в текущей базе данных. При этом индексы в системных каталогах не обрабатываются. Эту форму <code class="command">REINDEX</code> нельзя выполнить в блоке транзакции.</p></dd><dt><span class="term"><code class="literal">SYSTEM</code></span></dt><dd><p>Перестраивает все индексы в системных каталогах текущей базы данных. При этом обрабатываются также индексы в общих системных каталогах, но индексы в таблицах пользователя не затрагиваются. Эту форму <code class="command">REINDEX</code> нельзя выполнить в блоке транзакции.</p></dd><dt><span class="term"><em class="replaceable"><code>имя</code></em></span></dt><dd><p>Имя определённого индекса, таблицы или базы данных, подлежащих переиндексации. В настоящее время <code class="command">REINDEX DATABASE</code> и <code class="command">REINDEX SYSTEM</code> могут переиндексировать только текущую базу данных, так что их параметр (необязательный) должен соответствовать имени текущей базы данных.</p></dd><dt><span class="term"><code class="literal">CONCURRENTLY</code></span></dt><dd><p>С этим указанием <span class="productname">PostgreSQL</span> перестроит индекс, не устанавливая никаких блокировок, которые бы предотвращали добавление, изменение или удаление записей в таблице, тогда как по умолчанию операция перестроения индекса блокирует запись (но не чтение) в таблице до своего завершения. При переиндексации в неблокирующем режиме есть ряд особенностей, о которых следует знать, — см. <a class="xref" href="sql-reindex.html#SQL-REINDEX-CONCURRENTLY" title="Неблокирующее перестроение индексов">Неблокирующее перестроение индексов</a> ниже.</p><p>Для временных таблиц <code class="command">REINDEX</code> всегда выполняется более простым, неблокирующим способом, так как они не могут использоваться никакими другими сеансами.</p></dd><dt><span class="term"><code class="literal">TABLESPACE</code></span></dt><dd><p>Задаёт новое табличное пространство, в котором будут перестроены индексы.</p></dd><dt><span class="term"><code class="literal">VERBOSE</code></span></dt><dd><p>Выводит отчёт о прогрессе после переиндексации каждого индекса.</p></dd><dt><span class="term"><em class="replaceable"><code>логическое_значение</code></em></span></dt><dd><p>Включает или отключает заданный параметр. Для включения параметра можно написать <code class="literal">TRUE</code>, <code class="literal">ON</code> или <code class="literal">1</code>, а для отключения — <code class="literal">FALSE</code>, <code class="literal">OFF</code> или <code class="literal">0</code>. Значение <em class="replaceable"><code>boolean</code></em> можно опустить, в этом случае подразумевается <code class="literal">TRUE</code>.</p></dd><dt><span class="term"><em class="replaceable"><code>новое_табл_пространство</code></em></span></dt><dd><p>Табличное пространство, в котором будут перестраиваться индексы.</p></dd></dl></div></div><div class="refsect1" id="id-1.9.3.163.7"><h2>Замечания</h2><p>В случае подозрений в повреждении индекса таблицы пользователя, этот индекс или все индексы таблицы можно перестроить, используя команду <code class="command">REINDEX INDEX</code> или <code class="command">REINDEX TABLE</code>.</p><p>Всё усложняется, если возникает необходимость восстановить повреждённый индекс системной таблицы. В этом случае важно, чтобы система сама не использовала этот индекс. (На самом деле в таких случаях вы, скорее всего, столкнётесь с падением процессов сервера в момент запуска, как раз вследствие испорченных индексов.) Чтобы надёжно восстановить рабочее состояние, сервер следует запускать с параметром <code class="option">-P</code>, который отключает использование индексов при поиске в системных каталогах.</p><p>Один из вариантов сделать это — выключить сервер <span class="productname">PostgreSQL</span> и запустить его снова в однопользовательском режиме, с параметром <code class="option">-P</code> в командной строке. Затем можно выполнить <code class="command">REINDEX DATABASE</code>, <code class="command">REINDEX SYSTEM</code>, <code class="command">REINDEX TABLE</code> или <code class="command">REINDEX INDEX</code>, в зависимости от того, что вы хотите восстановить. В случае сомнений выполните <code class="command">REINDEX SYSTEM</code>, чтобы перестроить все системные индексы в базе данных. Затем завершите однопользовательский сеанс сервера и перезапустите сервер в обычном режиме. Чтобы подробнее узнать, как работать с сервером в однопользовательском интерфейсе, обратитесь к справочной странице <a class="xref" href="app-postgres.html" title="postgres"><span class="refentrytitle"><span class="application">postgres</span></span></a>.</p><p>Можно так же запустить обычный экземпляр сервера, но добавить в параметры командной строки <code class="option">-P</code>. В разных клиентах это может делаться по-разному, но во всех клиентах на базе <span class="application">libpq</span> можно установить для переменной окружения <code class="envar">PGOPTIONS</code> значение <code class="literal">-P</code> до запуска клиента. Учтите, что хотя этот метод не препятствует работе других клиентов, всё же имеет смысл не позволять им подключаться к повреждённой базе данных до завершения восстановления.</p><p>Действие <code class="command">REINDEX</code> подобно удалению и пересозданию индекса в том смысле, что содержимое индекса пересоздаётся с нуля, но блокировки при этом устанавливаются другие. <code class="command">REINDEX</code> блокирует запись, но не чтение родительской таблицы индекса. В частности, планировщик пытается установить блокировку <code class="literal">ACCESS SHARE</code> для каждого индекса таблицы, независимо от запроса, поэтому <code class="command">REINDEX</code> блокирует практически любые запросы, кроме некоторых подготовленных запросов, план которых был кеширован и которые не используют этот конкретный индекс. <code class="command">DROP INDEX</code>, напротив, моментально устанавливает блокировку <code class="literal">ACCESS EXCLUSIVE</code> на родительскую таблицу, блокируя и запись, и чтение. Последующая команда <code class="command">CREATE INDEX</code> блокирует запись, но не чтение; так как индекс отсутствует, обращений к нему ни при каком чтении не будет, что означает, что блокироваться чтение не будет, но выполняться оно будет как дорогостоящее последовательное сканирование.</p><p>Для перестраивания одного индекса или индексов таблицы необходимо быть владельцем этого индекса или таблицы. Для переиндексирования схемы или базы данных необходимо быть владельцем этой схемы или базы. Заметьте в частности, что вследствие этого не только суперпользователи могут перестраивать индексы таблиц, принадлежащих другим пользователям. Однако из этих правил есть исключение — когда команду <code class="command">REINDEX DATABASE</code>, <code class="command">REINDEX SCHEMA</code> или <code class="command">REINDEX SYSTEM</code> выполняет не суперпользователь, индексы общих каталогов будут пропускаться, если только данный каталог не принадлежит этому пользователю (как правило, это так). Разумеется, суперпользователи могут переиндексировать всё без ограничений.</p><p>Перестроение секционированных индексов или индексов секционированных таблиц поддерживается соответственно командами <code class="command">REINDEX INDEX</code> и <code class="command">REINDEX TABLE</code>. Каждая секция указанного секционированного отношения переиндексируется в отдельной транзакции. Когда эти команды применяются для обработки секционированной таблицы или индекса, они не могут находиться в блоке транзакции.</p><p>Когда для команды <code class="command">REINDEX</code>, обрабатывающей секционированный индекс или таблицу, применяется указание <code class="literal">TABLESPACE</code>, ссылки на табличное пространство меняются только в конечных секциях. Так как собственно секционированные индексы не модифицируются, для них рекомендуется отдельно выполнить <code class="command">ALTER TABLE ONLY</code>, чтобы любые секции, присоединяемые в будущем, относились к новому табличному пространству. В случае сбоя эта команда может не перенести все индексы в новое табличное пространство. При повторном запуске она будет перестраивать все конечные секции и перенесёт ранее необработанные индексы в новое пространство.</p><p>Если указание <code class="literal">TABLESPACE</code> задаётся вместе с <code class="literal">SCHEMA</code>, <code class="literal">DATABASE</code> или <code class="literal">SYSTEM</code>, системные отношения пропускаются и выдаётся единственное предупреждение об этом. Индексы TOAST-таблиц перестраиваются, но не перемещаются в новое табличное пространство.</p><div class="refsect2" id="SQL-REINDEX-CONCURRENTLY"><h3>Неблокирующее перестроение индексов</h3><a id="id-1.9.3.163.7.11.2" class="indexterm"></a><p>Перестроение индекса может мешать обычной работе с базой данных. Обычно <span class="productname">PostgreSQL</span> блокирует запись в переиндексируемую таблицу и выполняет всю операцию построения индекса за одно сканирование таблицы. Другие транзакции могут продолжать читать таблицу, но при попытке вставить, изменить или удалить строки в таблице они будут заблокированы до завершения перестроения индекса. Это может оказать нежелательное влияние на работу производственной базы данных. Индексация очень больших таблиц может занимать много часов, и даже для маленьких таблиц перестроение индекса может заблокировать записывающие процессы на время, неприемлемое для производственной системы.</p><p><span class="productname">PostgreSQL</span> поддерживает перестроение индексов в режиме минимизации блокировок записи. Этот режим включается указанием <code class="literal">CONCURRENTLY</code> команды <code class="command">REINDEX</code>. С данным указанием <span class="productname">PostgreSQL</span> должен выполнить два сканирования таблицы для каждого индекса, который нужно перестроить, и должен дождаться завершения всех активных транзакций, которые могут использовать данный индекс. В связи с этим в неблокирующем режиме производится в целом больше действий, и длительность переиндексирования значительно увеличивается. Однако благодаря тому, что во время перестроения индекса могут выполняться другие обычные операции, этот режим полезен, когда требуется перестроить индексы в производственной среде. Разумеется, другие операции могут несколько замедлиться из-за дополнительной нагрузки на процессор, память и ввод/вывод, связанной с перестроением индекса.</p><p>В ходе неблокирующего переиндексирования производятся следующие действия (каждое в отдельной транзакции). Если переиндексированию подлежат несколько индексов, сначала для всех индексов полностью выполняется один этап, а затем другой. </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>В каталог <code class="literal">pg_index</code> добавляется переходное определение индекса, которое затем заменит старое. Для предотвращения каких-либо изменений в схеме во время операции обрабатываемые индексы, а также связанные с ними таблицы защищаются блокировкой <code class="literal">SHARE UPDATE EXCLUSIVE</code> на уровне сеанса.</p></li><li class="listitem"><p>Для каждого нового индекса выполняется первый проход, на котором строится индекс. Когда индекс построен, его флаг <code class="literal">pg_index.indisready</code> переходит в состояние <span class="quote">«<span class="quote">true</span>»</span>, чтобы этот индекс был готов к добавлениям, и таким образом он становится видимым для других сеансов сразу после окончания построившей его транзакции. Это действие выполняется в отдельной транзакции для каждого индекса.</p></li><li class="listitem"><p>Затем выполняется второй проход, на котором в индекс вносятся кортежи, добавленные в таблицу во время первого прохода. Это действие также выполняется в отдельной транзакции для каждого индекса.</p></li><li class="listitem"><p>Все ограничения, ссылающиеся на индекс, переключаются на определение нового индекса, а также меняются имена индексов. В этот момент флаг <code class="literal">pg_index.indisvalid</code> нового индекса принимает значение <span class="quote">«<span class="quote">true</span>»</span>, а старого — <span class="quote">«<span class="quote">false</span>»</span>, и производится сброс кеша, в результате чего все сеансы, обращавшиеся к старому индексу, получают новую информацию.</p></li><li class="listitem"><p>Флаг <code class="literal">pg_index.indisready</code> старого индекса сбрасывается в <span class="quote">«<span class="quote">false</span>»</span> во избежание добавления в него новых кортежей, как только завершатся текущие запросы, которые могли обращаться к этому индексу.</p></li><li class="listitem"><p>Старые индексы удаляются. Блокировки <code class="literal">SHARE UPDATE EXCLUSIVE</code> уровня сеанса, установленные для индексов и таблиц, снимаются.</p></li></ol></div><p>Если при перестроении индексов возникает проблема, например нарушение уникальности в уникальном индексе, <code class="command">REINDEX</code> прерывается, но оставляет после себя <span class="quote">«<span class="quote">нерабочий</span>»</span> новый индекс в дополнение к уже существующему. Этот индекс будет игнорироваться запросами, так как он может быть неполным; тем не менее он будет обновляться при изменении данных, что повлечёт дополнительные издержки. Команда <span class="application">psql</span> <code class="command">\d</code> будет обозначать такой индекс как <code class="literal">INVALID</code> (нерабочий): </p><pre class="programlisting">postgres=# \d tab
       Table "public.tab"
 Column |  Type   | Modifiers
--------+---------+-----------
 col    | integer |
Indexes:
    "idx" btree (col)
    "idx_ccnew" btree (col) INVALID</pre><p> Если имя индекса с пометкой <code class="literal">INVALID</code> оканчивается на <code class="literal">ccnew</code>, это переходный индекс созданный при параллельной операции, и для исправления ситуации рекомендуется удалить его, выполнив <code class="literal">DROP INDEX</code>, а затем попытаться ещё раз выполнить <code class="command">REINDEX CONCURRENTLY</code>. Если же имя нерабочего индекса оканчивается на <code class="literal">ccold</code>, значит, это исходный индекс, удалить который по какой-то причине не получилось. Такой индекс рекомендуется просто удалить, так как нужный индекс был перестроен успешно.</p><p>Обычное построение индекса допускает одновременное построение других индексов для таблицы обычным методом, но неблокирующее построение для конкретной таблицы в один момент времени допускается только одно. Однако в любом случае никакие другие изменения схемы таблицы в это время не разрешаются. Другое отличие состоит в том, что в блоке транзакции может быть выполнена обычная команда <code class="command">REINDEX TABLE</code> или <code class="command">REINDEX INDEX</code>, но не <code class="command">REINDEX CONCURRENTLY</code>.</p><p>Как и любая длительная транзакция, операция <code class="command">REINDEX</code> с таблицей может повлиять на возможность удаления кортежей параллельной операцией <code class="command">VACUUM</code> с какой-либо другой таблицей.</p><p>Команда <code class="command">REINDEX SYSTEM</code> не поддерживает указание <code class="command">CONCURRENTLY</code>, так как системные каталоги нельзя переиндексировать в неблокирующем режиме.</p><p>Более того, в неблокирующем режиме нельзя перестроить индексы, связанные с ограничениями-исключениями. Если явно указать имя такого индекса в команде, будет выдана ошибка. Когда в неблокирующем режиме переиндексируется таблица или база данных, содержащая такие индексы, эти индексы пропускаются. (Перестроить такие индексы можно в обычном режиме, без указания <code class="command">CONCURRENTLY</code>.)</p><p>Каждый процесс, выполняющий операцию <code class="command">REINDEX</code>, будет выдавать информацию о ходе её выполнения, отображаемую в представлении <code class="structname">pg_stat_progress_create_index</code>. За подробностями обратитесь к <a class="xref" href="progress-reporting.html#CREATE-INDEX-PROGRESS-REPORTING" title="28.4.4. Отслеживание выполнения CREATE INDEX">Подразделу 28.4.4</a>.</p></div></div><div class="refsect1" id="id-1.9.3.163.8"><h2>Примеры</h2><p>Перестроение одного индекса: </p><pre class="programlisting">REINDEX INDEX my_index;</pre><p>Перестроение всех индексов таблицы <code class="literal">my_table</code>: </p><pre class="programlisting">REINDEX TABLE my_table;</pre><p>Перестроение всех индексов в определённой базе данных, в предположении, что целостность системных индексов под сомнением: </p><pre class="programlisting">$ <strong class="userinput"><code>export PGOPTIONS="-P"</code></strong>
$ <strong class="userinput"><code>psql broken_db</code></strong>
...
broken_db=&gt; REINDEX DATABASE broken_db;
broken_db=&gt; \q</pre><p>Перестроение индексов таблицы, допускающее одновременные операции чтения и записи с затрагиваемыми в процессе переиндексации отношениями: </p><pre class="programlisting">REINDEX TABLE CONCURRENTLY my_broken_table;</pre></div><div class="refsect1" id="id-1.9.3.163.9"><h2>Совместимость</h2><p>Команда <code class="command">REINDEX</code> отсутствует в стандарте SQL.</p></div><div class="refsect1" id="id-1.9.3.163.10"><h2>См. также</h2><span class="simplelist"><a class="xref" href="sql-createindex.html" title="CREATE INDEX"><span class="refentrytitle">CREATE INDEX</span></a>, <a class="xref" href="sql-dropindex.html" title="DROP INDEX"><span class="refentrytitle">DROP INDEX</span></a>, <a class="xref" href="app-reindexdb.html" title="reindexdb"><span class="refentrytitle"><span class="application">reindexdb</span></span></a>, <a class="xref" href="progress-reporting.html#CREATE-INDEX-PROGRESS-REPORTING" title="28.4.4. Отслеживание выполнения CREATE INDEX">Подраздел 28.4.4</a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-refreshmaterializedview.html" title="REFRESH MATERIALIZED VIEW">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-release-savepoint.html" title="RELEASE SAVEPOINT">След.</a></td></tr><tr><td width="40%" align="left" valign="top">REFRESH MATERIALIZED VIEW </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> RELEASE SAVEPOINT</td></tr></table></div></body></html>