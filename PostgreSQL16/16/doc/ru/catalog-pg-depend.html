<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>53.18. pg_depend</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="catalog-pg-default-acl.html" title="53.17. pg_default_acl" /><link rel="next" href="catalog-pg-description.html" title="53.19. pg_description" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">53.18. <code class="structname">pg_depend</code></th></tr><tr><td width="10%" align="left"><a accesskey="p" href="catalog-pg-default-acl.html" title="53.17. pg_default_acl">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="catalogs.html" title="Глава 53. Системные каталоги">Наверх</a></td><th width="60%" align="center">Глава 53. Системные каталоги</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="catalog-pg-description.html" title="53.19. pg_description">След.</a></td></tr></table><hr /></div><div class="sect1" id="CATALOG-PG-DEPEND"><div class="titlepage"><div><div><h2 class="title" style="clear: both">53.18. <code class="structname">pg_depend</code> <a href="#CATALOG-PG-DEPEND" class="id_link">#</a></h2></div></div></div><a id="id-1.10.4.20.2" class="indexterm"></a><p>В каталоге <code class="structname">pg_depend</code> записываются отношения зависимости между объектами базы данных. Благодаря этой информации, команды <code class="command">DROP</code> могут найти, какие объекты должны удаляться при использовании <code class="command">DROP CASCADE</code>, или когда нужно запрещать удаление при <code class="command">DROP RESTRICT</code>.</p><p>Также смотрите описание каталога <a class="link" href="catalog-pg-shdepend.html" title="53.48. pg_shdepend"><code class="structname">pg_shdepend</code></a>, который играет подобную роль в отношении совместно используемых объектов в кластере баз данных.</p><div class="table" id="id-1.10.4.20.5"><p class="title"><strong>Таблица 53.18. Столбцы <code class="structname">pg_depend</code></strong></p><div class="table-contents"><table class="table" summary="Столбцы pg_depend" border="1"><colgroup><col /></colgroup><thead><tr><th class="catalog_table_entry"><p class="column_definition">Тип столбца</p>
      <p>Описание</p></th></tr></thead><tbody><tr><td class="catalog_table_entry"><p class="column_definition"><code class="structfield">classid</code> <code class="type">oid</code> (ссылается на <a class="link" href="catalog-pg-class.html" title="53.11. pg_class"><code class="structname">pg_class</code></a>.<code class="structfield">oid</code>)</p>
      <p>OID системного каталога, в котором находится зависимый объект</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition"><code class="structfield">objid</code> <code class="type">oid</code> (ссылается на какой-либо столбец OID)</p>
      <p>OID определённого зависимого объекта</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">objsubid</code> <code class="type">int4</code>
      </p>
      <p>Для столбца таблицы это номер столбца (<code class="structfield">objid</code> и <code class="structfield">classid</code> указывают на саму таблицу). Для всех других типов объектов это поле содержит ноль.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition"><code class="structfield">refclassid</code> <code class="type">oid</code> (ссылается на <a class="link" href="catalog-pg-class.html" title="53.11. pg_class"><code class="structname">pg_class</code></a>.<code class="structfield">oid</code>)</p>
      <p>OID системного каталога, в котором находится вышестоящий объект</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition"><code class="structfield">refobjid</code> <code class="type">oid</code> (ссылается на какой-либо столбец OID)</p>
      <p>OID определённого вышестоящего объекта</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">refobjsubid</code> <code class="type">int4</code>
      </p>
      <p>Для столбца таблицы это номер столбца (<code class="structfield">refobjid</code> и <code class="structfield">refclassid</code> указывают на саму таблицу). Для всех других типов объектов это поле содержит ноль.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">deptype</code> <code class="type">char</code>
      </p>
      <p>Код, определяющий конкретную семантику данного отношения зависимости; см. текст</p></td></tr></tbody></table></div></div><br class="table-break" /><p>Во всех случаях, запись в <code class="structname">pg_depend</code> показывает, что вышестоящий объект нельзя удалить, не удаляя подчинённый объект. Однако есть несколько подвидов зависимости, задаваемых в поле <code class="structfield">deptype</code>: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="symbol">DEPENDENCY_NORMAL</code> (<code class="literal">n</code>)</span></dt><dd><p>Обычное отношение между отдельно создаваемыми объектами. Подчинённый объект можно удалить, не затрагивая вышестоящий объект. Вышестоящий объект можно удалить только с указанием <code class="literal">CASCADE</code>, при этом будет удалён и подчинённый объект. Например, столбец таблицы находится в обычной зависимости от своего типа данных.</p></dd><dt><span class="term"><code class="symbol">DEPENDENCY_AUTO</code> (<code class="literal">a</code>)</span></dt><dd><p>Подчинённый объект может быть удалён отдельно от вышестоящего и должен быть удалён автоматически (вне зависимости от указаний <code class="literal">RESTRICT</code> и <code class="literal">CASCADE</code>), если удаляется вышестоящий объект. Например, именованное ограничение для таблицы находится в автоматической зависимости от таблицы, так что оно исчезнет при удалении таблицы.</p></dd><dt><span class="term"><code class="symbol">DEPENDENCY_INTERNAL</code> (<code class="literal">i</code>)</span></dt><dd><p>Подчинённый объект был создан в процессе создания вышестоящего и на самом деле является только частью его внутренней реализации. Для такого объекта будет запрещена команда <code class="command">DROP</code> (мы подскажем пользователю, что вместо этого надо выполнить <code class="command">DROP</code> для вышестоящего объекта). Действие <code class="command">DROP</code> для вышестоящего объекта будет автоматически распространено и на этот подчинённый объект, вне зависимости от присутствия указания <code class="command">CASCADE</code>. Если подчинённый объект должен быть удалён вследствие зависимости от какого-то другого удаляемого объекта, удаление подчинённого преобразуется в удаление вышестоящего, то есть зависимости <code class="literal">NORMAL</code> и <code class="literal">AUTO</code> подчинённого объекта во многом действуют как зависимости вышестоящего объекта. Например, правило <code class="literal">ON SELECT</code> для представления автоматически становится внутренне зависимым от этого представления, что не позволяет удалить это правило, пока существует представление. Зависимости этого правила (например, от таблиц, которые в нём фигурируют) будут действовать так же, как если бы они были зависимостями самого представления.</p></dd><dt><span class="term"><code class="symbol">DEPENDENCY_PARTITION_PRI</code> (<code class="literal">P</code>)<br /></span><span class="term"><code class="symbol">DEPENDENCY_PARTITION_SEC</code> (<code class="literal">S</code>)</span></dt><dd><p>Подчинённый объект (секция) был создан в процессе создания вышестоящего (секционированного отношения) и на самом деле является только частью его внутренней реализации; однако у него есть несколько вышестоящих объектов, что отличает эту зависимость от <code class="literal">INTERNAL</code>. Такой подчинённый объект должен удаляться только тогда, когда удаляется хотя бы один из этих вышестоящих объектов; в этом случае не должно иметь значения наличие указания <code class="literal">CASCADE</code>. Также с такой зависимостью, в отличие от <code class="literal">INTERNAL</code>, попытка удаления некоторого другого объекта, от которого зависит подчинённый, не приводит к автоматическому удалению какого-либо из связанных секционированных отношений. Таким образом, если удаление не доходит до минимум одного из вышестоящих объектов по какому-то пути, оно не будет произведено. (В большинстве случаев подчинённый объект разделяет все свои несекционные зависимости с минимум одним секционно-связанным объектом, чтобы это ограничение не блокировало каскадные удаления.) Первичные (PRI) и вторичные (SEC) секционные зависимости похожи, и отличаются только тем, что первичные зависимости предпочитаются при формировании сообщений об ошибках; поэтому секционно-подчинённый объект, как правило, будет иметь одну первичную секционную зависимость и одну или несколько вторичных. Заметьте, что секционные зависимости создаются в дополнение, но не вместо обычных зависимостей, которые будет иметь объект. Это упрощает операции <code class="command">ATTACH/DETACH PARTITION</code>: они будут просто добавлять или удалять секционные зависимости. Например, дочерний секционированный индекс оказывается секционно-зависимым и от собственной секционированной таблицы, и от родительского секционированного индекса, так что он будет удалён при удалении одного из этих объектов, но не в других случаях. Зависимость от родительского секционированного индекса является первичной, поэтому если пользователь пытается удалить дочерний секционированный индекс, в сообщении об ошибке будет предложено удалить родительский индекс (а не таблицу).</p></dd><dt><span class="term"><code class="symbol">DEPENDENCY_EXTENSION</code> (<code class="literal">e</code>)</span></dt><dd><p>Подчинённый объект входит в состав <em class="firstterm">расширения</em>, которое является вышестоящим объектом (см. <a class="link" href="catalog-pg-extension.html" title="53.22. pg_extension"><code class="structname">pg_extension</code></a>). Удалить подчинённый объект можно, только выполнив команду <a class="link" href="sql-dropextension.html" title="DROP EXTENSION"><code class="command">DROP EXTENSION</code></a> для вышестоящего объекта. Функционально этот тип зависимости действует так же, как и внутренняя (<code class="literal">INTERNAL</code>) зависимость, но он выделен для наглядности и упрощения <span class="application">pg_dump</span>.</p></dd><dt><span class="term"><code class="symbol">DEPENDENCY_AUTO_EXTENSION</code> (<code class="literal">x</code>)</span></dt><dd><p>Подчинённый объект не входит в состав расширения, являющегося вышестоящим объектом (и поэтому он не должен игнорироваться программой <span class="application">pg_dump</span>), но он не может функционировать без расширения и должен удаляться автоматически при удалении расширения. Такой объект также может быть удалён сам по себе. Функционально эта зависимость работает как зависимость <code class="literal">AUTO</code>, но она выделена для наглядности и упрощения <span class="application">pg_dump</span>.</p></dd></dl></div><p> В будущем могут появиться и другие подвиды зависимости.</p><p>Заметьте, что два объекта вполне могут быть связаны между собой более чем одной записью в <code class="structname">pg_depend</code>. Например, дочерний секционированный индекс будет иметь и зависимость секционного типа от связанной секционированной таблицы, и автоматическую зависимость от каждого столбца таблицы, входящего в индекс. В подобных ситуациях имеет место совмещение зависимостей, несущих разных смысл. И если какая-либо из зависимостей удовлетворяет условиям для автоматического удаления, подчинённый объект может быть удалён без указания <code class="literal">CASCADE</code>. При этом, конечно, должны быть удовлетворены все ограничения зависимостей, определяющих подлежащие удалению объекты.</p><p>Большинство объектов, созданных во время работы <span class="application">initdb</span>, считаются <span class="quote">«<span class="quote">закреплёнными</span>»</span>, что означает, что сама система зависит от них. Поэтому их нельзя удалять ни при каких условиях. Кроме того, зная, что закреплённые объекты не будут удалены, механизм зависимостей не создаёт в <code class="structname">pg_depend</code> записи, показывающие зависимости от этих объектов. Так, например, столбец таблицы типа <code class="type">numeric</code> условно имеет зависимость <code class="literal">NORMAL</code> от типа данных <code class="type">numeric</code>, но на самом деле такая запись не появляется в <code class="structname">pg_depend</code>.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="catalog-pg-default-acl.html" title="53.17. pg_default_acl">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="catalogs.html" title="Глава 53. Системные каталоги">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="catalog-pg-description.html" title="53.19. pg_description">След.</a></td></tr><tr><td width="40%" align="left" valign="top">53.17. <code class="structname">pg_default_acl</code> </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 53.19. <code class="structname">pg_description</code></td></tr></table></div></body></html>