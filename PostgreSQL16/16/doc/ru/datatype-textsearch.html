<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>8.11. Типы, предназначенные для текстового поиска</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="datatype-bit.html" title="8.10. Битовые строки" /><link rel="next" href="datatype-uuid.html" title="8.12. Тип UUID" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">8.11. Типы, предназначенные для текстового поиска</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="datatype-bit.html" title="8.10. Битовые строки">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="datatype.html" title="Глава 8. Типы данных">Наверх</a></td><th width="60%" align="center">Глава 8. Типы данных</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="datatype-uuid.html" title="8.12. Тип UUID">След.</a></td></tr></table><hr /></div><div class="sect1" id="DATATYPE-TEXTSEARCH"><div class="titlepage"><div><div><h2 class="title" style="clear: both">8.11. Типы, предназначенные для текстового поиска <a href="#DATATYPE-TEXTSEARCH" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="datatype-textsearch.html#DATATYPE-TSVECTOR">8.11.1. <code class="type">tsvector</code></a></span></dt><dt><span class="sect2"><a href="datatype-textsearch.html#DATATYPE-TSQUERY">8.11.2. <code class="type">tsquery</code></a></span></dt></dl></div><a id="id-1.5.7.19.2" class="indexterm"></a><a id="id-1.5.7.19.3" class="indexterm"></a><p><span class="productname">PostgreSQL</span> предоставляет два типа данных для поддержки полнотекстового поиска. Текстовым поиском называется операция анализа набора <em class="firstterm">документов</em> с текстом на естественном языке, в результате которой находятся фрагменты, наиболее соответствующие <em class="firstterm">запросу</em>. Тип <code class="type">tsvector</code> представляет документ в виде, оптимизированном для текстового поиска, а <code class="type">tsquery</code> представляет запрос текстового поиска в подобном виде. Более подробно это описывается в <a class="xref" href="textsearch.html" title="Глава 12. Полнотекстовый поиск">Главе 12</a>, а все связанные функции и операторы перечислены в <a class="xref" href="functions-textsearch.html" title="9.13. Функции и операторы текстового поиска">Разделе 9.13</a>.</p><div class="sect2" id="DATATYPE-TSVECTOR"><div class="titlepage"><div><div><h3 class="title">8.11.1. <code class="type">tsvector</code> <a href="#DATATYPE-TSVECTOR" class="id_link">#</a></h3></div></div></div><a id="id-1.5.7.19.5.2" class="indexterm"></a><p>Значение типа <code class="type">tsvector</code> содержит отсортированный список неповторяющихся <em class="firstterm">лексем</em>, т. е. слов, <em class="firstterm">нормализованных</em> так, что все словоформы сводятся к одной (подробнее это описано в <a class="xref" href="textsearch.html" title="Глава 12. Полнотекстовый поиск">Главе 12</a>). Сортировка и исключение повторяющихся слов производится автоматически при вводе значения, как показано в этом примере: </p><pre class="programlisting">SELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector;
                      tsvector
----------------------------------------------------
 'a' 'and' 'ate' 'cat' 'fat' 'mat' 'on' 'rat' 'sat'</pre><p> Для представления в виде лексем пробелов или знаков препинания их нужно заключить в апострофы: </p><pre class="programlisting">SELECT $$the lexeme '    ' contains spaces$$::tsvector;
                 tsvector
-------------------------------------------
 '    ' 'contains' 'lexeme' 'spaces' 'the'</pre><p> (В данном и следующих примерах мы используем строку в долларах, чтобы не дублировать все апострофы в таких строках.) При этом включаемый апостроф или обратную косую черту нужно продублировать: </p><pre class="programlisting">SELECT $$the lexeme 'Joe''s' contains a quote$$::tsvector;
                    tsvector
------------------------------------------------
 'Joe''s' 'a' 'contains' 'lexeme' 'quote' 'the'</pre><p> Также для лексем можно указать их целочисленные <em class="firstterm">позиции</em>: </p><pre class="programlisting">SELECT 'a:1 fat:2 cat:3 sat:4 on:5 a:6 mat:7 and:8 ate:9 a:10 fat:11 rat:12'::tsvector;
                                  tsvector
-------------------------------------------------------------------​------------
 'a':1,6,10 'and':8 'ate':9 'cat':3 'fat':2,11 'mat':7 'on':5 'rat':12 'sat':4</pre><p> Позиция обычно указывает положение исходного слова в документе. Информация о расположении слов затем может использоваться для <em class="firstterm">оценки близости</em>. Позиция может задаваться числом от 1 до 16383; большие значения просто заменяются на 16383. Если для одной лексемы дважды указывается одно положение, такое повторение отбрасывается.</p><p>Лексемам, для которых заданы позиции, также можно назначить <em class="firstterm">вес</em>, выраженный буквами <code class="literal">A</code>, <code class="literal">B</code>, <code class="literal">C</code> или <code class="literal">D</code>. Вес <code class="literal">D</code> подразумевается по умолчанию и поэтому он не показывается при выводе: </p><pre class="programlisting">SELECT 'a:1A fat:2B,4C cat:5D'::tsvector;
          tsvector
----------------------------
 'a':1A 'cat':5 'fat':2B,4C</pre><p> Веса обычно применяются для отражения структуры документа, например для придания особого значения словам в заголовке по сравнению со словами в обычном тексте. Назначенным весам можно сопоставить числовые приоритеты в функциях ранжирования результатов.</p><p>Важно понимать, что тип <code class="type">tsvector</code> сам по себе не выполняет нормализацию слов; предполагается, что в сохраняемом значении слова уже нормализованы приложением. Например: </p><pre class="programlisting">SELECT 'The Fat Rats'::tsvector;
      tsvector
--------------------
 'Fat' 'Rats' 'The'</pre><p> Для большинства англоязычных приложений приведённые выше слова будут считаться ненормализованными, но для <code class="type">tsvector</code> это не важно. Поэтому исходный документ обычно следует обработать функцией <code class="function">to_tsvector</code>, нормализующей слова для поиска: </p><pre class="programlisting">SELECT to_tsvector('english', 'The Fat Rats');
   to_tsvector
-----------------
 'fat':2 'rat':3</pre><p> И это подробнее описано в <a class="xref" href="textsearch.html" title="Глава 12. Полнотекстовый поиск">Главе 12</a>.</p></div><div class="sect2" id="DATATYPE-TSQUERY"><div class="titlepage"><div><div><h3 class="title">8.11.2. <code class="type">tsquery</code> <a href="#DATATYPE-TSQUERY" class="id_link">#</a></h3></div></div></div><a id="id-1.5.7.19.6.2" class="indexterm"></a><p>Значение <code class="type">tsquery</code> содержит искомые лексемы, объединяемые логическими операторами <code class="literal">&amp;</code> (И), <code class="literal">|</code> (ИЛИ) и <code class="literal">!</code> (НЕ), а также оператором поиска фраз <code class="literal">&lt;-&gt;</code> (ПРЕДШЕСТВУЕТ). Также допускается вариация оператора ПРЕДШЕСТВУЕТ вида <code class="literal">&lt;<em class="replaceable"><code>N</code></em>&gt;</code>, где <em class="replaceable"><code>N</code></em> — целочисленная константа, задающая расстояние между двумя искомыми лексемами. Запись оператора <code class="literal">&lt;-&gt;</code> равнозначна <code class="literal">&lt;1&gt;</code>.</p><p>Для группировки операторов могут использоваться скобки. Без скобок эти операторы имеют разные приоритеты, в порядке убывания: <code class="literal">!</code> (НЕ), <code class="literal">&lt;-&gt;</code> (ПРЕДШЕСТВУЕТ), <code class="literal">&amp;</code> (И) и <code class="literal">|</code> (ИЛИ).</p><p>Несколько примеров: </p><pre class="programlisting">SELECT 'fat &amp; rat'::tsquery;
    tsquery
---------------
 'fat' &amp; 'rat'

SELECT 'fat &amp; (rat | cat)'::tsquery;
          tsquery
---------------------------
 'fat' &amp; ( 'rat' | 'cat' )

SELECT 'fat &amp; rat &amp; ! cat'::tsquery;
        tsquery
------------------------
 'fat' &amp; 'rat' &amp; !'cat'</pre><p>Лексемам в <code class="type">tsquery</code> можно дополнительно сопоставить буквы весов, при этом они будут соответствовать только тем лексемам в <code class="type">tsvector</code>, которые имеют какой-либо из этих весов: </p><pre class="programlisting">SELECT 'fat:ab &amp; cat'::tsquery;
    tsquery
------------------
 'fat':AB &amp; 'cat'</pre><p>Кроме того, в лексемах <code class="type">tsquery</code> можно использовать знак <code class="literal">*</code> для поиска по префиксу: </p><pre class="programlisting">SELECT 'super:*'::tsquery;
  tsquery
-----------
 'super':*</pre><p> Этот запрос найдёт все слова в <code class="type">tsvector</code>, начинающиеся с приставки <span class="quote">«<span class="quote">super</span>»</span>.</p><p>Апострофы в лексемах этого типа можно использовать так же, как и в лексемах в <code class="type">tsvector</code>; и так же, как и для типа <code class="type">tsvector</code>, необходимая нормализация слова должна выполняться до приведения значения к типу <code class="type">tsquery</code>. Для такой нормализации удобно использовать функцию <code class="function">to_tsquery</code>: </p><pre class="programlisting">SELECT to_tsquery('Fat:ab &amp; Cats');
    to_tsquery
------------------
 'fat':AB &amp; 'cat'</pre><p> Заметьте, что функция <code class="function">to_tsquery</code> будет обрабатывать префиксы подобно другим словам, поэтому следующее сравнение возвращает true: </p><pre class="programlisting">SELECT to_tsvector( 'postgraduate' ) @@ to_tsquery( 'postgres:*' );
 ?column?
----------
 t</pre><p> так как <code class="literal">postgres</code> преобразуется стеммером в <code class="literal">postgr</code>: </p><pre class="programlisting">SELECT to_tsvector( 'postgraduate' ), to_tsquery( 'postgres:*' );
  to_tsvector  | to_tsquery
---------------+------------
 'postgradu':1 | 'postgr':*</pre><p> и эта приставка находится в преобразованной форме слова <code class="literal">postgraduate</code>.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="datatype-bit.html" title="8.10. Битовые строки">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="datatype.html" title="Глава 8. Типы данных">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="datatype-uuid.html" title="8.12. Тип UUID">След.</a></td></tr><tr><td width="40%" align="left" valign="top">8.10. Битовые строки </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 8.12. Тип <acronym class="acronym">UUID</acronym></td></tr></table></div></body></html>