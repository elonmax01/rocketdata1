<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>12.3. Управление текстовым поиском</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="textsearch-tables.html" title="12.2. Таблицы и индексы" /><link rel="next" href="textsearch-features.html" title="12.4. Дополнительные возможности" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">12.3. Управление текстовым поиском</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="textsearch-tables.html" title="12.2. Таблицы и индексы">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="textsearch.html" title="Глава 12. Полнотекстовый поиск">Наверх</a></td><th width="60%" align="center">Глава 12. Полнотекстовый поиск</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="textsearch-features.html" title="12.4. Дополнительные возможности">След.</a></td></tr></table><hr /></div><div class="sect1" id="TEXTSEARCH-CONTROLS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">12.3. Управление текстовым поиском <a href="#TEXTSEARCH-CONTROLS" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="textsearch-controls.html#TEXTSEARCH-PARSING-DOCUMENTS">12.3.1. Разбор документов</a></span></dt><dt><span class="sect2"><a href="textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES">12.3.2. Разбор запросов</a></span></dt><dt><span class="sect2"><a href="textsearch-controls.html#TEXTSEARCH-RANKING">12.3.3. Ранжирование результатов поиска</a></span></dt><dt><span class="sect2"><a href="textsearch-controls.html#TEXTSEARCH-HEADLINE">12.3.4. Выделение результатов</a></span></dt></dl></div><p>Для реализации полнотекстового поиска необходимы функции, позволяющие создать <code class="type">tsvector</code> из документа и <code class="type">tsquery</code> из запроса пользователя. Кроме того, результаты нужно выдавать в удобном порядке, так что нам потребуется функция, оценивающая релевантность документа для данного запроса. Важно также иметь возможность выводить найденный текст подходящим образом. В <span class="productname">PostgreSQL</span> есть все необходимые для этого функции.</p><div class="sect2" id="TEXTSEARCH-PARSING-DOCUMENTS"><div class="titlepage"><div><div><h3 class="title">12.3.1. Разбор документов <a href="#TEXTSEARCH-PARSING-DOCUMENTS" class="id_link">#</a></h3></div></div></div><p>Для преобразования документа в тип <code class="type">tsvector</code> <span class="productname">PostgreSQL</span> предоставляет функцию <code class="function">to_tsvector</code>.</p><a id="id-1.5.11.6.3.3" class="indexterm"></a><pre class="synopsis">to_tsvector([<span class="optional"><em class="replaceable"><code>конфигурация</code></em> <code class="type">regconfig</code>,</span>] <em class="replaceable"><code>документ</code></em> <code class="type">text</code>) returns <code class="type">tsvector</code></pre><p><code class="function">to_tsvector</code> разбирает текстовый документ на фрагменты, сводит фрагменты к лексемам и возвращает значение <code class="type">tsvector</code>, в котором перечисляются лексемы и их позиции в документе. При обработке документа используется указанная конфигурация текстового поиска или конфигурация по умолчанию. Простой пример: </p><pre class="screen">
SELECT to_tsvector('english', 'a fat  cat sat on a mat - it ate a fat rats');
                  to_tsvector
-----------------------------------------------------
 'ate':9 'cat':3 'fat':2,11 'mat':7 'rat':12 'sat':4
</pre><p>В этом примере мы видим, что результирующий <code class="type">tsvector</code> не содержит слова <code class="literal">a</code>, <code class="literal">on</code> и <code class="literal">it</code>, слово <code class="literal">rats</code> превратилось <code class="literal">rat</code>, а знак препинания <span class="quote">«<span class="quote"><code class="literal">-</code></span>»</span> был проигнорирован.</p><p>Функция <code class="function">to_tsvector</code> внутри вызывает анализатор, который разбивает текст документа на фрагменты и классифицирует их. Для каждого фрагмента она проверяет список словарей (<a class="xref" href="textsearch-dictionaries.html" title="12.6. Словари">Раздел 12.6</a>), определяемый типом фрагмента. Первый же словарь, <em class="firstterm">распознавший</em> фрагмент, выдаёт одну или несколько представляющих его <em class="firstterm">лексем</em>. Например, <code class="literal">rats</code> превращается в <code class="literal">rat</code>, так как один из словарей понимает, что слово <code class="literal">rats</code> — это слово <code class="literal">rat</code> во множественном числе. Некоторое слова распознаются как <em class="firstterm">стоп-слова</em> (<a class="xref" href="textsearch-dictionaries.html#TEXTSEARCH-STOPWORDS" title="12.6.1. Стоп-слова">Подраздел 12.6.1</a>) и игнорируются как слова, фигурирующие в тексте настолько часто, что искать их бессмысленно. В нашем примере это <code class="literal">a</code>, <code class="literal">on</code> и <code class="literal">it</code>. Если фрагмент не воспринимается ни одним словарём из списка, он так же игнорируется. В данном примере это происходит со знаком препинания <code class="literal">-</code>, так как с таким типом фрагмента (<code class="literal">символы-разделители</code>) не связан никакой словарь и значит такие фрагменты никогда не будут индексироваться. Выбор анализатора, словарей и индексируемых типов фрагментов определяется конфигурацией текстового поиска (<a class="xref" href="textsearch-configuration.html" title="12.7. Пример конфигурации">Раздел 12.7</a>). В одной базе данных можно использовать разные конфигурации, в том числе, предопределённые конфигурации для разных языков. В нашем примере мы использовали конфигурацию по умолчанию для английского языка — <code class="literal">english</code>.</p><p>Для назначения элементам <code class="type">tsvector</code> разных <em class="firstterm">весов</em> используется функция <code class="function">setweight</code>. Вес элемента задаётся буквой <code class="literal">A</code>, <code class="literal">B</code>, <code class="literal">C</code> или <code class="literal">D</code>. Обычно это применяется для обозначения важности слов в разных частях документа, например в заголовке или в теле документа. Затем эта информация может использоваться при ранжировании результатов поиска.</p><p>Так как <code class="function">to_tsvector</code>(<code class="literal">NULL</code>) вернёт <code class="literal">NULL</code>, мы советуем использовать <code class="function">coalesce</code> везде, где соответствующее поле может быть NULL. Создавать <code class="type">tsvector</code> из структурированного документа рекомендуется так: </p><pre class="programlisting">UPDATE tt SET ti =
    setweight(to_tsvector(coalesce(title,'')), 'A')    ||
    setweight(to_tsvector(coalesce(keyword,'')), 'B')  ||
    setweight(to_tsvector(coalesce(abstract,'')), 'C') ||
    setweight(to_tsvector(coalesce(body,'')), 'D');</pre><p> Здесь мы использовали <code class="function">setweight</code> для пометки происхождения каждой лексемы в сформированных значениях <code class="type">tsvector</code> и объединили помеченные значения с помощью оператора конкатенации типов <code class="type">tsvector</code> <code class="literal">||</code>. (Подробнее эти операции рассматриваются в <a class="xref" href="textsearch-features.html#TEXTSEARCH-MANIPULATE-TSVECTOR" title="12.4.1. Обработка документов">Подразделе 12.4.1</a>.)</p></div><div class="sect2" id="TEXTSEARCH-PARSING-QUERIES"><div class="titlepage"><div><div><h3 class="title">12.3.2. Разбор запросов <a href="#TEXTSEARCH-PARSING-QUERIES" class="id_link">#</a></h3></div></div></div><p><span class="productname">PostgreSQL</span> предоставляет функции <code class="function">to_tsquery</code>, <code class="function">plainto_tsquery</code>, <code class="function">phraseto_tsquery</code> и <code class="function">websearch_to_tsquery</code> для приведения запроса к типу <code class="type">tsquery</code>. Функция <code class="function">to_tsquery</code> даёт больше возможностей, чем <code class="function">plainto_tsquery</code> или <code class="function">phraseto_tsquery</code>, но более строга к входным данным. Функция <code class="function">websearch_to_tsquery</code> представляет собой упрощённую версию <code class="function">to_tsquery</code> с альтернативным синтаксисом, подобным тому, что принят в поисковых системах в Интернете.</p><a id="id-1.5.11.6.4.3" class="indexterm"></a><pre class="synopsis">to_tsquery([<span class="optional"><em class="replaceable"><code>конфигурация</code></em> <code class="type">regconfig</code>,</span>] <em class="replaceable"><code>текст_запроса</code></em> <code class="type">text</code>) returns <code class="type">tsquery</code></pre><p><code class="function">to_tsquery</code> создаёт значение <code class="type">tsquery</code> из <em class="replaceable"><code>текста_запроса</code></em>, который может состоять из простых фрагментов, разделённых логическими операторами <code class="type">tsquery</code>: <code class="literal">&amp;</code> (И), <code class="literal">|</code> (ИЛИ), <code class="literal">!</code> (НЕ) и <code class="literal">&lt;-&gt;</code> (ПРЕДШЕСТВУЕТ), возможно, сгруппированных скобками. Другими словами, входное значение для <code class="function">to_tsquery</code> должно уже соответствовать общим правилам для значений <code class="type">tsquery</code>, описанным в <a class="xref" href="datatype-textsearch.html#DATATYPE-TSQUERY" title="8.11.2. tsquery">Подразделе 8.11.2</a>. Различие их состоит в том, что во вводимом в <code class="type">tsquery</code> значении фрагменты воспринимаются буквально, тогда как <code class="function">to_tsquery</code> нормализует фрагменты, приводя их к лексемам, используя явно указанную или подразумеваемую конфигурацию, и отбрасывая стоп-слова. Например: </p><pre class="screen">
SELECT to_tsquery('english', 'The &amp; Fat &amp; Rats');
  to_tsquery
---------------
 'fat' &amp; 'rat'
</pre><p> Как и при вводе значения <code class="type">tsquery</code>, для каждой лексемы можно задать вес(а), чтобы при поиске можно было выбрать из <code class="type">tsvector</code> только лексемы с заданными весами. Например: </p><pre class="screen">
SELECT to_tsquery('english', 'Fat | Rats:AB');
    to_tsquery
------------------
 'fat' | 'rat':AB
</pre><p> К лексеме также можно добавить <code class="literal">*</code>, определив таким образом условие поиска по префиксу: </p><pre class="screen">
SELECT to_tsquery('supern:*A &amp; star:A*B');
        to_tsquery        
--------------------------
 'supern':*A &amp; 'star':*AB
</pre><p> Такая лексема будет соответствовать любому слову в <code class="type">tsvector</code>, начинающемуся с данной подстроки.</p><p><code class="function">to_tsquery</code> может также принимать фразы в апострофах. Это полезно в основном когда конфигурация включает тезаурус, который может обрабатывать такие фразы. В показанном ниже примере предполагается, что тезаурус содержит правило <code class="literal">supernovae stars : sn</code>: </p><pre class="screen">
SELECT to_tsquery('''supernovae stars'' &amp; !crab');
  to_tsquery
---------------
 'sn' &amp; !'crab'
</pre><p> Если убрать эти апострофы, <code class="function">to_tsquery</code> не примет фрагменты, не разделённые операторами И, ИЛИ и ПРЕДШЕСТВУЕТ, и выдаст синтаксическую ошибку.</p><a id="id-1.5.11.6.4.7" class="indexterm"></a><pre class="synopsis">plainto_tsquery([<span class="optional"><em class="replaceable"><code>конфигурация</code></em> <code class="type">regconfig</code>,</span>] <em class="replaceable"><code>текст_запроса</code></em> <code class="type">text</code>) returns <code class="type">tsquery</code></pre><p><code class="function">plainto_tsquery</code> преобразует неформатированный <em class="replaceable"><code>текст_запроса</code></em> в значение <code class="type">tsquery</code>. Текст разбирается и нормализуется подобно тому, как это делает <code class="function">to_tsvector</code>, а затем между оставшимися словами вставляются операторы <code class="literal">&amp;</code> (И) типа <code class="type">tsquery</code>.</p><p>Пример: </p><pre class="screen">
SELECT plainto_tsquery('english', 'The Fat Rats');
 plainto_tsquery
-----------------
 'fat' &amp; 'rat'
</pre><p> Заметьте, что <code class="function">plainto_tsquery</code> не распознает во входной строке операторы <code class="type">tsquery</code>, метки весов или обозначения префиксов: </p><pre class="screen">
SELECT plainto_tsquery('english', 'The Fat &amp; Rats:C');
   plainto_tsquery
---------------------
 'fat' &amp; 'rat' &amp; 'c'
</pre><p> В данном случае все знаки пунктуации были отброшены.</p><a id="id-1.5.11.6.4.11" class="indexterm"></a><pre class="synopsis">phraseto_tsquery([<span class="optional"><em class="replaceable"><code>конфигурация</code></em> <code class="type">regconfig</code>,</span>] <em class="replaceable"><code>текст_запроса</code></em> <code class="type">text</code>) returns <code class="type">tsquery</code></pre><p><code class="function">phraseto_tsquery</code> ведёт себя подобно <code class="function">plainto_tsquery</code>, за исключением того, что она вставляет между оставшимися словами оператор <code class="literal">&lt;-&gt;</code> (ПРЕДШЕСТВУЕТ) вместо оператора <code class="literal">&amp;</code> (И). Кроме того, стоп-слова не просто отбрасываются, а подсчитываются, и вместо операторов <code class="literal">&lt;-&gt;</code> используются операторы <code class="literal">&lt;<em class="replaceable"><code>N</code></em>&gt;</code> с подсчитанным числом. Эта функция полезна при поиске точных последовательностей лексем, так как операторы ПРЕДШЕСТВУЕТ проверяют не только наличие всех лексем, но и их порядок.</p><p>Пример: </p><pre class="screen">
SELECT phraseto_tsquery('english', 'The Fat Rats');
 phraseto_tsquery
------------------
 'fat' &lt;-&gt; 'rat'
</pre><p> Как и <code class="function">plainto_tsquery</code>, функция <code class="function">phraseto_tsquery</code> не распознает во входной строке операторы типа <code class="type">tsquery</code>, метки весов или обозначения префиксов: </p><pre class="screen">
SELECT phraseto_tsquery('english', 'The Fat &amp; Rats:C');
      phraseto_tsquery
-----------------------------
 'fat' &lt;-&gt; 'rat' &lt;-&gt; 'c'
</pre><pre class="synopsis">websearch_to_tsquery([<span class="optional"><em class="replaceable"><code>конфигурация</code></em> <code class="type">regconfig</code>,</span>] <em class="replaceable"><code>текст_запроса</code></em> <code class="type">text</code>) returns <code class="type">tsquery</code></pre><p>Функция <code class="function">websearch_to_tsquery</code> создаёт значение <code class="type">tsquery</code> из <em class="replaceable"><code>текста_запроса</code></em>, используя альтернативный синтаксис, в котором запрос задаётся просто неформатированным текстом. В отличие от <code class="function">plainto_tsquery</code> и <code class="function">phraseto_tsquery</code>, она также принимает определённые операторы. Более того, эта функция никогда не выдаёт синтаксические ошибки, что позволяет осуществлять поиск по произвольному заданному пользователем запросу. Она поддерживает следующий синтаксис: </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p><code class="literal">текст не в кавычках</code>: текст, не заключённый в кавычки, который будет преобразован в слова, разделяемые операторами <code class="literal">&amp;</code>, как его восприняла бы функция <code class="function">plainto_tsquery</code>.</p></li><li class="listitem" style="list-style-type: disc"><p><code class="literal">"текст в кавычках"</code>: текст, заключённый в кавычки, будет преобразован в слова, разделяемые операторами <code class="literal">&lt;-&gt;</code>, как его восприняла бы функция <code class="function">phraseto_tsquery</code>.</p></li><li class="listitem" style="list-style-type: disc"><p><code class="literal">OR</code>: слово <span class="quote">«<span class="quote">or</span>»</span> будет преобразовано в оператор <code class="literal">|</code>.</p></li><li class="listitem" style="list-style-type: disc"><p><code class="literal">-</code>: знак минуса будет преобразован в оператор <code class="literal">!</code>.</p></li></ul></div><p> Другая пунктуация игнорируется. Поэтому функция <code class="function">websearch_to_tsquery</code>, как и <code class="function">plainto_tsquery</code> с <code class="function">phraseto_tsquery</code>, не распознаёт во входной строке операторы <code class="type">tsquery</code>, метки весов или обозначения префиксов.</p><p>Примеры: </p><pre class="screen">
SELECT websearch_to_tsquery('english', 'The fat rats');
 websearch_to_tsquery
----------------------
 'fat' &amp; 'rat'
(1 row)

SELECT websearch_to_tsquery('english', '"supernovae stars" -crab');
       websearch_to_tsquery
----------------------------------
 'supernova' &lt;-&gt; 'star' &amp; !'crab'
(1 row)

SELECT websearch_to_tsquery('english', '"sad cat" or "fat rat"');
       websearch_to_tsquery
-----------------------------------
 'sad' &lt;-&gt; 'cat' | 'fat' &lt;-&gt; 'rat'
(1 row)

SELECT websearch_to_tsquery('english', 'signal -"segmentation fault"');
         websearch_to_tsquery
---------------------------------------
 'signal' &amp; !( 'segment' &lt;-&gt; 'fault' )
(1 row)

SELECT websearch_to_tsquery('english', '""" )( dummy \\ query &lt;-&gt;');
 websearch_to_tsquery
----------------------
 'dummi' &amp; 'queri'
(1 row)
</pre></div><div class="sect2" id="TEXTSEARCH-RANKING"><div class="titlepage"><div><div><h3 class="title">12.3.3. Ранжирование результатов поиска <a href="#TEXTSEARCH-RANKING" class="id_link">#</a></h3></div></div></div><p>Ранжирование документов можно представить как попытку оценить, насколько они релевантны заданному запросу и отсортировать их так, чтобы наиболее релевантные выводились первыми. В <span class="productname">PostgreSQL</span> встроены две функции ранжирования, принимающие во внимание лексическую, позиционную и структурную информацию; то есть, они учитывают, насколько часто и насколько близко встречаются в документе ключевые слова и какова важность содержащей их части документа. Однако само понятие релевантности довольно размытое и во многом определяется приложением. Приложения могут использовать для ранжирования и другую информацию, например, время изменения документа. Встроенные функции ранжирования можно рассматривать лишь как примеры реализации. Для своих конкретных задач вы можете разработать собственные функции ранжирования и/или учесть при обработке их результатов дополнительные факторы.</p><p>Ниже описаны две встроенные функции ранжирования: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
       <a id="id-1.5.11.6.5.3.1.1.1.1" class="indexterm"></a>

       <code class="literal">ts_rank([<span class="optional"><em class="replaceable"><code>веса</code></em> <code class="type">float4[]</code>,</span>] <em class="replaceable"><code>вектор</code></em> <code class="type">tsvector</code>, <em class="replaceable"><code>запрос</code></em> <code class="type">tsquery</code> [<span class="optional">, <em class="replaceable"><code>нормализация</code></em> <code class="type">integer</code></span>]) returns <code class="type">float4</code></code>
      </span></dt><dd><p>Ранжирует векторы по частоте найденных лексем.</p></dd><dt><span class="term">
      <a id="id-1.5.11.6.5.3.1.2.1.1" class="indexterm"></a>

       <code class="literal">ts_rank_cd([<span class="optional"><em class="replaceable"><code>веса</code></em> <code class="type">float4[]</code>,</span>] <em class="replaceable"><code>вектор</code></em> <code class="type">tsvector</code>, <em class="replaceable"><code>запрос</code></em> <code class="type">tsquery</code> [<span class="optional">, <em class="replaceable"><code>нормализация</code></em> <code class="type">integer</code></span>]) returns <code class="type">float4</code></code>
      </span></dt><dd><p>Эта функция вычисляет <em class="firstterm">плотность покрытия</em> для данного вектора документа и запроса, используя метод, разработанный Кларком, Кормаком и Тадхоуп и описанный в статье «Relevance Ranking for One to Three Term Queries» в журнале «Information Processing and Management» в 1999 г. Плотность покрытия вычисляется подобно рангу <code class="function">ts_rank</code>, но в расчёт берётся ещё и близость соответствующих лексем друг к другу.</p><p>Для вычисления результата этой функции требуется информация о позиции лексем. Поэтому она игнорируют <span class="quote">«<span class="quote">очищенные</span>»</span> от этой информации лексемы в <code class="type">tsvector</code>. Если во входных данных нет неочищенных лексем, результат будет равен нулю. (За дополнительными сведениями о функции <code class="function">strip</code> и позиционной информации в данных <code class="type">tsvector</code> обратитесь к <a class="xref" href="textsearch-features.html#TEXTSEARCH-MANIPULATE-TSVECTOR" title="12.4.1. Обработка документов">Подразделу 12.4.1</a>.)</p></dd></dl></div><p>Для обеих этих функций аргумент <em class="replaceable"><code>веса</code></em> позволяет придать больший или меньший вес словам, в зависимости от их меток. В передаваемом массиве весов определяется, насколько весома каждая категория слов, в следующем порядке: </p><pre class="synopsis">
{вес D, вес C, вес B, вес A}
</pre><p> Если этот аргумент опускается, подразумеваются следующие значения: </p><pre class="programlisting">{0.1, 0.2, 0.4, 1.0}</pre><p> Обычно весами выделяются слова из особых областей документа, например из заголовка или краткого введения, с тем, чтобы эти слова считались более и менее значимыми, чем слова в основном тексте документа.</p><p>Так как вероятность найти ключевые слова увеличивается с размером документа, при ранжировании имеет смысл учитывать его, чтобы, например, документ с сотней слов, содержащий пять вхождений искомых слов, считался более релевантным, чем документ с тысячей слов и теми же пятью вхождениями. Обе функции ранжирования принимают целочисленный параметр <em class="replaceable"><code>нормализации</code></em>, определяющий, как ранг документа будет зависеть от его размера. Этот параметр представляет собой битовую маску и управляет несколькими режимами: вы можете включить сразу несколько режимов, объединив значения оператором <code class="literal">|</code> (например так: <code class="literal">2|4</code>). </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p>0 (по умолчанию): длина документа не учитывается</p></li><li class="listitem" style="list-style-type: disc"><p>1: ранг документа делится на 1 + логарифм длины документа</p></li><li class="listitem" style="list-style-type: disc"><p>2: ранг документа делится на его длину</p></li><li class="listitem" style="list-style-type: disc"><p>4: ранг документа делится на среднее гармоническое расстояние между блоками (это реализовано только в <code class="function">ts_rank_cd</code>)</p></li><li class="listitem" style="list-style-type: disc"><p>8: ранг документа делится на число уникальных слов в документе</p></li><li class="listitem" style="list-style-type: disc"><p>16: ранг документа делится на 1 + логарифм числа уникальных слов в документе</p></li><li class="listitem" style="list-style-type: disc"><p>32: ранг делится своё же значение + 1</p></li></ul></div><p> Если включены несколько флагов, соответствующие операции выполняются в показанном порядке.</p><p>Важно заметить, что функции ранжирования не используют никакую внешнюю информацию, так что добиться нормализации до 1% или 100% невозможно, хотя иногда это желательно. Применив параметр 32 (<code class="literal">rank/(rank+1)</code>), можно свести все ранги к диапазону 0..1, но это изменение будет лишь косметическим, на порядке сортировки результатов это не отразится.</p><p>В данном примере выбираются десять найденных документов с максимальным рангом: </p><pre class="screen">
SELECT title, ts_rank_cd(textsearch, query) AS rank
FROM apod, to_tsquery('neutrino|(dark &amp; matter)') query
WHERE query @@ textsearch
ORDER BY rank DESC
LIMIT 10;
                     title                     |   rank
-----------------------------------------------+----------
 Neutrinos in the Sun                          |      3.1
 The Sudbury Neutrino Detector                 |      2.4
 A MACHO View of Galactic Dark Matter          |  2.01317
 Hot Gas and Dark Matter                       |  1.91171
 The Virgo Cluster: Hot Plasma and Dark Matter |  1.90953
 Rafting for Solar Neutrinos                   |      1.9
 NGC 4650A: Strange Galaxy and Dark Matter     |  1.85774
 Hot Gas and Dark Matter                       |   1.6123
 Ice Fishing for Cosmic Neutrinos              |      1.6
 Weak Lensing Distorts the Universe            | 0.818218
</pre><p> Тот же пример с нормализованным рангом: </p><pre class="screen">
SELECT title, ts_rank_cd(textsearch, query, 32 /* rank/(rank+1) */ ) AS rank
FROM apod, to_tsquery('neutrino|(dark &amp; matter)') query
WHERE  query @@ textsearch
ORDER BY rank DESC
LIMIT 10;
                     title                     |        rank
-----------------------------------------------+-------------------
 Neutrinos in the Sun                          | 0.756097569485493
 The Sudbury Neutrino Detector                 | 0.705882361190954
 A MACHO View of Galactic Dark Matter          | 0.668123210574724
 Hot Gas and Dark Matter                       |  0.65655958650282
 The Virgo Cluster: Hot Plasma and Dark Matter | 0.656301290640973
 Rafting for Solar Neutrinos                   | 0.655172410958162
 NGC 4650A: Strange Galaxy and Dark Matter     | 0.650072921219637
 Hot Gas and Dark Matter                       | 0.617195790024749
 Ice Fishing for Cosmic Neutrinos              | 0.615384618911517
 Weak Lensing Distorts the Universe            | 0.450010798361481
</pre><p>Ранжирование может быть довольно дорогостоящей операцией, так как для вычисления ранга необходимо прочитать <code class="type">tsvector</code> каждого подходящего документа и это займёт значительное время, если придётся обращаться к диску. К сожалению, избежать этого вряд ли возможно, так как на практике по многим запросам выдаётся большое количество результатов.</p></div><div class="sect2" id="TEXTSEARCH-HEADLINE"><div class="titlepage"><div><div><h3 class="title">12.3.4. Выделение результатов <a href="#TEXTSEARCH-HEADLINE" class="id_link">#</a></h3></div></div></div><p>Представляя результаты поиска, в идеале нужно выделять часть документа и показывать, как он связан с запросом. Обычно поисковые системы показывают фрагменты документа с отмеченными искомыми словами. В <span class="productname">PostgreSQL</span> для реализации этой возможности представлена функция <code class="function">ts_headline</code>.</p><a id="id-1.5.11.6.6.3" class="indexterm"></a><pre class="synopsis">ts_headline([<span class="optional"><em class="replaceable"><code>конфигурация</code></em> <code class="type">regconfig</code>,</span>] <em class="replaceable"><code>документ</code></em> <code class="type">text</code>, <em class="replaceable"><code>запрос</code></em> <code class="type">tsquery</code> [<span class="optional">, <em class="replaceable"><code>параметры</code></em> <code class="type">text</code></span>])
  returns <code class="type">text</code></pre><p><code class="function">ts_headline</code> принимает документ вместе с запросом и возвращает выдержку из документа, в которой выделяются слова из запроса. В частности, функция будет использовать запрос для выбора соответствующих фрагментов текста, а затем выделять все слова, которые встречаются в запросе, даже если позиции этих слов не соответствуют ограничениям запроса. Применяемую для разбора документа конфигурацию можно указать в параметре <em class="replaceable"><code>config</code></em>. Если этот параметр опущен, применяется конфигурация <code class="varname">default_text_search_config</code>.</p><p>Если в параметрах передаётся строка <em class="replaceable"><code>options</code></em>, она должна состоять из списка разделённых запятыми пар <em class="replaceable"><code>параметр</code></em><code class="literal">=</code><em class="replaceable"><code>значение</code></em>. Параметры могут быть следующими: </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p><code class="literal">MaxWords</code>, <code class="literal">MinWords</code> (целочисленные): эти числа определяют нижний и верхний предел размера выдержки. Значения по умолчанию: 35 и 15, соответственно.</p></li><li class="listitem" style="list-style-type: disc"><p><code class="literal">ShortWord</code> (целочисленный): слова такой длины или короче в начале и конце выдержки будут отбрасываться, за исключением искомых слов. Значение по умолчанию, равное 3, исключает распространённые английские артикли.</p></li><li class="listitem" style="list-style-type: disc"><p><code class="literal">HighlightAll</code> (логический): при значении <code class="literal">true</code> выдержкой будет весь документ, и три предыдущие параметра игнорируются. Значение по умолчанию: <code class="literal">false</code>.</p></li><li class="listitem" style="list-style-type: disc"><p><code class="literal">MaxFragments</code> (целочисленный): максимальное число выводимых текстовых фрагментов. Значение по умолчанию, равное нулю, выбирает режим создания выдержек без фрагментов. При положительном значении выбирается режим с фрагментами (см. ниже).</p></li><li class="listitem" style="list-style-type: disc"><p><code class="literal">StartSel</code>, <code class="literal">StopSel</code>: строки, которые будут разграничивать слова запроса в документе, выделяя их среди остальных. Если эти строки содержат пробелы или запятые, их нужно заключить в кавычки.</p></li><li class="listitem" style="list-style-type: disc"><p><code class="literal">FragmentDelimiter</code> (строка): в случае, когда фрагментов несколько, они будут разделяться указанной строкой. Значение по умолчанию: <span class="quote">«<span class="quote"><code class="literal"> ... </code></span>»</span>.</p></li></ul></div><p> Имена этих параметров распознаются без учёта регистра. Значения, содержащие пробелы или запятые, должны заключаться в двойные кавычки.</p><p>В режиме формирования выдержек без фрагментов <code class="function">ts_headline</code> находит вхождения слов заданного <em class="replaceable"><code>запроса</code></em> и возвращает одно из вхождений, предпочитая те, что содержат как можно больше слов из запроса в пределах допустимого размера выдержки. В режиме с фрагментами <code class="function">ts_headline</code> находит вхождения слов запроса и разделяет эти вхождения на <span class="quote">«<span class="quote">фрагменты</span>»</span>, состоящие не более чем из <code class="literal">MaxWords</code> слов, предпочитая те, что содержат больше искомых слов, а затем может <span class="quote">«<span class="quote">растянуть</span>»</span> фрагменты, добавив в них соседние слова. Второй режим полезнее, когда слова запроса находятся не рядом, а разбросаны по документу, или когда желательно увидеть сразу несколько вхождений. В случаях, когда соответствие запросу найти не удаётся, в обоих режимах возвращаются первые <code class="literal">MinWords</code> слов из документа.</p><p>Пример использования: </p><pre class="screen">
SELECT ts_headline('english',
  'The most common type of search
is to find all documents containing given query terms
and return them in order of their similarity to the
query.',
  to_tsquery('english', 'query &amp; similarity'));
                        ts_headline
------------------------------------------------------------
 containing given &lt;b&gt;query&lt;/b&gt; terms                       +
 and return them in order of their &lt;b&gt;similarity&lt;/b&gt; to the+
 &lt;b&gt;query&lt;/b&gt;.

SELECT ts_headline('english',
  'Search terms may occur
many times in a document,
requiring ranking of the search matches to decide which
occurrences to display in the result.',
  to_tsquery('english', 'search &amp; term'),
  'MaxFragments=10, MaxWords=7, MinWords=3, StartSel=&lt;&lt;, StopSel=&gt;&gt;');
                        ts_headline
------------------------------------------------------------
 &lt;&lt;Search&gt;&gt; &lt;&lt;terms&gt;&gt; may occur                            +
 many times ... ranking of the &lt;&lt;search&gt;&gt; matches to decide
</pre><p>Функция <code class="function">ts_headline</code> работает с оригинальным документом, а не его сжатым представлением <code class="type">tsvector</code>, так что она может быть медленной и использовать её следует осмотрительно.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="textsearch-tables.html" title="12.2. Таблицы и индексы">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="textsearch.html" title="Глава 12. Полнотекстовый поиск">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="textsearch-features.html" title="12.4. Дополнительные возможности">След.</a></td></tr><tr><td width="40%" align="left" valign="top">12.2. Таблицы и индексы </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 12.4. Дополнительные возможности</td></tr></table></div></body></html>