<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>34.10. Функции, связанные с командой COPY</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="libpq-notify.html" title="34.9. Асинхронное уведомление" /><link rel="next" href="libpq-control.html" title="34.11. Функции управления" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">34.10. Функции, связанные с командой <code class="command">COPY</code></th></tr><tr><td width="10%" align="left"><a accesskey="p" href="libpq-notify.html" title="34.9. Асинхронное уведомление">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="libpq.html" title="Глава 34. libpq — библиотека для языка C">Наверх</a></td><th width="60%" align="center">Глава 34. <span class="application">libpq</span> — библиотека для языка C</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="libpq-control.html" title="34.11. Функции управления">След.</a></td></tr></table><hr /></div><div class="sect1" id="LIBPQ-COPY"><div class="titlepage"><div><div><h2 class="title" style="clear: both">34.10. Функции, связанные с командой <code class="command">COPY</code> <a href="#LIBPQ-COPY" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="libpq-copy.html#LIBPQ-COPY-SEND">34.10.1. Функции для передачи данных <code class="command">COPY</code></a></span></dt><dt><span class="sect2"><a href="libpq-copy.html#LIBPQ-COPY-RECEIVE">34.10.2. Функции для приёма данных <code class="command">COPY</code></a></span></dt><dt><span class="sect2"><a href="libpq-copy.html#LIBPQ-COPY-DEPRECATED">34.10.3. Устаревшие функции для <code class="command">COPY</code></a></span></dt></dl></div><a id="id-1.7.3.17.2" class="indexterm"></a><p>Команда <code class="command">COPY</code> в <span class="productname">PostgreSQL</span> имеет возможность читать и записывать данные через сетевое подключение, установленное <span class="application">libpq</span>. Описанные в этом разделе функции позволяют приложениям воспользоваться этой возможностью для передачи или приёма копируемых данных.</p><p>Общая процедура такова: сначала приложение выдаёт SQL-команду <code class="command">COPY</code>, вызывая <a class="xref" href="libpq-exec.html#LIBPQ-PQEXEC"><code class="function">PQexec</code></a> или одну из подобных функций. В ответ оно должно получить (если не возникла ошибка) объект <code class="structname">PGresult</code> с кодом состояния <code class="literal">PGRES_COPY_OUT</code> или <code class="literal">PGRES_COPY_IN</code> (в зависимости от направления копирования). Затем приложение должно использовать функции, описанные в этом разделе, и принимать или передавать строки данных. По завершении передачи возвращается ещё один объект <code class="structname">PGresult</code>, сообщающий о состоянии завершения передачи. В случае успеха он содержит код состояния <code class="literal">PGRES_COMMAND_OK</code>, а если возникает какая-то проблема — <code class="literal">PGRES_FATAL_ERROR</code>. После этого можно продолжать выполнять SQL-команды через <a class="xref" href="libpq-exec.html#LIBPQ-PQEXEC"><code class="function">PQexec</code></a>. (Пока операция <code class="command">COPY</code> не завершена, выполнять другие SQL-команды через то же подключение нельзя.)</p><p>Если команда <code class="command">COPY</code> была выполнена через <a class="xref" href="libpq-exec.html#LIBPQ-PQEXEC"><code class="function">PQexec</code></a> в строке, содержащей дополнительные команды, приложение должно продолжать получать результаты через <a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a> после завершения последовательности <code class="command">COPY</code>. Только когда <a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a> возвращает <code class="symbol">NULL</code>, можно с уверенностью считать, что переданные <code class="function">PQexec</code> команды выполнены полностью, и безопасно передавать другие команды.</p><p>Функции, описанные в этом разделе, должны выполняться только после получения кода состояния <code class="literal">PGRES_COPY_OUT</code> или <code class="literal">PGRES_COPY_IN</code> от функции <a class="xref" href="libpq-exec.html#LIBPQ-PQEXEC"><code class="function">PQexec</code></a> или <a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a>.</p><p>Объект <code class="structname">PGresult</code> с таким кодом состояния содержит дополнительные данные о начавшейся операции <code class="command">COPY</code>. Эти данные можно получить функциями, также применяющимися при обработке результатов запроса: </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQNFIELDS-1"><span class="term"><code class="function">PQnfields</code><a id="id-1.7.3.17.7.3.1.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQNFIELDS-1" class="id_link">#</a></dt><dd><p>Возвращает число копируемых столбцов (полей).</p></dd><dt id="LIBPQ-PQBINARYTUPLES-1"><span class="term"><code class="function">PQbinaryTuples</code><a id="id-1.7.3.17.7.3.2.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQBINARYTUPLES-1" class="id_link">#</a></dt><dd><p>Значение 0 указывает, что для всей операции копирования применяется текстовый формат (строки разделяются символами новой строки, столбцы разделяются символами-разделителями и т. д.). Значение 1 указывает, что для всей операции копирования применяется двоичный формат. За дополнительными сведениями обратитесь к <a class="xref" href="sql-copy.html" title="COPY"><span class="refentrytitle">COPY</span></a>.</p></dd><dt id="LIBPQ-PQFFORMAT-1"><span class="term"><code class="function">PQfformat</code><a id="id-1.7.3.17.7.3.3.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQFFORMAT-1" class="id_link">#</a></dt><dd><p>Возвращает код формата (0 — текстовый, 1 — двоичный), связанный с каждым копируемым столбцом. Коды форматов столбцов всегда будут нулевыми, если общий формат копирования — текстовый, но с двоичным форматом поддерживаются и текстовые, и двоичные столбцы. (Однако в текущей реализации <code class="command">COPY</code> при двоичном копировании столбцы могут быть только двоичными, так что форматы столбцов должны всегда соответствовать общему формату.)</p></dd></dl></div><div class="sect2" id="LIBPQ-COPY-SEND"><div class="titlepage"><div><div><h3 class="title">34.10.1. Функции для передачи данных <code class="command">COPY</code> <a href="#LIBPQ-COPY-SEND" class="id_link">#</a></h3></div></div></div><p>Эти функции применяются для передачи данных при операции <code class="literal">COPY FROM STDIN</code>. Они не будут работать, если подключение находится не в состоянии <code class="literal">COPY_IN</code>.</p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQPUTCOPYDATA"><span class="term"><code class="function">PQputCopyData</code><a id="id-1.7.3.17.8.3.1.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQPUTCOPYDATA" class="id_link">#</a></dt><dd><p>Отправляет данные на сервер, когда активно состояние <code class="literal">COPY_IN</code>. </p><pre class="synopsis">
int PQputCopyData(PGconn *conn,
                  const char *buffer,
                  int nbytes);
</pre><p>Передаёт серверу данные <code class="command">COPY</code> из указанного буфера (<em class="parameter"><code>buffer</code></em>), длиной <em class="parameter"><code>nbytes</code></em> байт. Она возвращает 1, если данные были переданы, 0, если они не попали в очередь, так как буферы были заполнены (это возможно только в неблокирующем режиме), или -1, если произошла ошибка. (Если возвращено -1, подробности ошибки можно узнать, вызвав <a class="xref" href="libpq-status.html#LIBPQ-PQERRORMESSAGE"><code class="function">PQerrorMessage</code></a>. Если получен 0, дождитесь состояния готовности к записи и повторите попытку.)</p><p>Приложение может разделять поток данных <code class="command">COPY</code> на буферизуемые блоки любого удобного размера. Границы буфера не имеют семантического значения при передаче. Содержимое потока данных должно соответствовать формату данных, ожидаемому командой <code class="command">COPY</code>; за подробностями обратитесь к <a class="xref" href="sql-copy.html" title="COPY"><span class="refentrytitle">COPY</span></a>.</p></dd><dt id="LIBPQ-PQPUTCOPYEND"><span class="term"><code class="function">PQputCopyEnd</code><a id="id-1.7.3.17.8.3.2.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQPUTCOPYEND" class="id_link">#</a></dt><dd><p>Отправляет признак конца данных на сервер, когда активно состояние <code class="literal">COPY_IN</code>. </p><pre class="synopsis">
int PQputCopyEnd(PGconn *conn,
                 const char *errormsg);
</pre><p>Завершает операцию <code class="literal">COPY_IN</code> с успешным результатом, если в <em class="parameter"><code>errormsg</code></em> передаётся <code class="symbol">NULL</code>. Если <em class="parameter"><code>errormsg</code></em> не <code class="symbol">NULL</code>, команда <code class="command">COPY</code> будет завершена с ошибкой, а сообщением об ошибке будет строка, переданная в <em class="parameter"><code>errormsg</code></em>. (Однако не следует полагать, что именно это сообщение будет получено от сервера назад, так как сервер мог уже прервать операцию <code class="command">COPY</code> по своим причинам.)</p><p>Эта функция возвращает 1, если сообщение завершения было передано; в неблокирующем режиме это означает только, что сообщение завершения успешно поставлено в очередь. (Чтобы удостовериться, что данные были успешно отправлены в неблокирующем режиме, следует дождаться готовности к записи и вызывать <a class="xref" href="libpq-async.html#LIBPQ-PQFLUSH"><code class="function">PQflush</code></a> в цикле, пока она не вернёт ноль.) Нулевой результат означает, что функция не смогла поставить сообщение завершения в очередь по причине заполнения буферов; это возможно только в неблокирующем режиме. (В этом случае нужно дождаться готовности к записи и попытаться вызвать <a class="xref" href="libpq-copy.html#LIBPQ-PQPUTCOPYEND"><code class="function">PQputCopyEnd</code></a> снова.) Если действительно происходит ошибка, возвращается -1; получить её подробности можно, вызвав <a class="xref" href="libpq-status.html#LIBPQ-PQERRORMESSAGE"><code class="function">PQerrorMessage</code></a>.</p><p>После успешного вызова <a class="xref" href="libpq-copy.html#LIBPQ-PQPUTCOPYEND"><code class="function">PQputCopyEnd</code></a> вызовите <a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a>, чтобы узнать окончательный результат команды <code class="command">COPY</code>. Ожидать появления этого результата можно обычным образом. Затем вернитесь к обычным операциям.</p></dd></dl></div></div><div class="sect2" id="LIBPQ-COPY-RECEIVE"><div class="titlepage"><div><div><h3 class="title">34.10.2. Функции для приёма данных <code class="command">COPY</code> <a href="#LIBPQ-COPY-RECEIVE" class="id_link">#</a></h3></div></div></div><p>Эти функции применяются для получения данных при операции <code class="literal">COPY TO STDOUT</code>. Они не будут работать, если подключение находится не в состоянии <code class="literal">COPY_OUT</code>.</p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQGETCOPYDATA"><span class="term"><code class="function">PQgetCopyData</code><a id="id-1.7.3.17.9.3.1.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQGETCOPYDATA" class="id_link">#</a></dt><dd><p>Принимает данные от сервера, когда активно состояние <code class="literal">COPY_OUT</code>. </p><pre class="synopsis">
int PQgetCopyData(PGconn *conn,
                  char **buffer,
                  int async);
</pre><p>Запрашивает следующую строку данных с сервера в процессе операции <code class="command">COPY</code>. Данные всегда возвращаются строка за строкой; если поступила только часть строки, она не возвращается. Успешное получение строки данных подразумевает выделение блока памяти для этих данных. В параметре <em class="parameter"><code>buffer</code></em> ей передаётся указатель, отличный от <code class="symbol">NULL</code>. По адресу <em class="parameter"><code>*buffer</code></em> записывается указатель на выделенную память, либо <code class="symbol">NULL</code>, когда буфер не возвращается. Если буфер результата отличен от <code class="symbol">NULL</code>, его следует освободить, когда он станет не нужен, вызвав <a class="xref" href="libpq-misc.html#LIBPQ-PQFREEMEM"><code class="function">PQfreemem</code></a>.</p><p>Когда строка получена успешно, возвращается число байт данных в этой строке (это число всегда больше нуля). Возвращаемое строковое значение всегда завершается нулём, хотя это полезно, вероятно, только для текстовой <code class="command">COPY</code>. Нулевой результат означает, что операция <code class="command">COPY</code> продолжает выполняться, но строка ещё не готова (это возможно, только когда параметр <em class="parameter"><code>async</code></em> равен true). Возвращённое значение -1 означает, что команда <code class="command">COPY</code> завершена, а -2 показывает, что произошла ошибка (её причину можно узнать с помощью <a class="xref" href="libpq-status.html#LIBPQ-PQERRORMESSAGE"><code class="function">PQerrorMessage</code></a>).</p><p>Когда параметр <em class="parameter"><code>async</code></em> отличен от нуля (признак установлен), функция <a class="xref" href="libpq-copy.html#LIBPQ-PQGETCOPYDATA"><code class="function">PQgetCopyData</code></a> не будет блокироваться, ожидая данных; она возвратит ноль, если выполнение <code class="command">COPY</code> продолжается, но полная строка ещё не получена. (В этом случае нужно дождаться готовности к чтению и затем вызвать <a class="xref" href="libpq-async.html#LIBPQ-PQCONSUMEINPUT"><code class="function">PQconsumeInput</code>
     </a>, прежде чем вызывать <a class="xref" href="libpq-copy.html#LIBPQ-PQGETCOPYDATA"><code class="function">PQgetCopyData</code></a> ещё раз.) Когда <em class="parameter"><code>async</code></em> равен нулю (признак не установлен), <a class="xref" href="libpq-copy.html#LIBPQ-PQGETCOPYDATA"><code class="function">PQgetCopyData</code></a> будет заблокирована до поступления данных или окончания операции.</p><p>Когда <a class="xref" href="libpq-copy.html#LIBPQ-PQGETCOPYDATA"><code class="function">PQgetCopyData</code></a> возвращает -1, вызовите <a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a>, чтобы узнать окончательный результат команды <code class="command">COPY</code>. Ожидать появления этого результата можно обычным образом. Затем вернитесь к обычным операциям.</p></dd></dl></div></div><div class="sect2" id="LIBPQ-COPY-DEPRECATED"><div class="titlepage"><div><div><h3 class="title">34.10.3. Устаревшие функции для <code class="command">COPY</code> <a href="#LIBPQ-COPY-DEPRECATED" class="id_link">#</a></h3></div></div></div><p>Эти функции представляют старые методы выполнения операции <code class="command">COPY</code>. Хотя они продолжают работать, они признаны устаревшими из-за плохой обработки ошибок, неудобных способов обнаружения конца данных и отсутствия поддержки двоичных или неблокирующих передач.</p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQGETLINE"><span class="term"><code class="function">PQgetline</code><a id="id-1.7.3.17.10.3.1.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQGETLINE" class="id_link">#</a></dt><dd><p>Читает передаваемую сервером строку символов, завершающуюся символом новой строки, в буфер (buffer) размера <em class="parameter"><code>length</code></em>. </p><pre class="synopsis">
int PQgetline(PGconn *conn,
              char *buffer,
              int length);
</pre><p>Эта функция копирует <em class="parameter"><code>length</code></em>-1 символов в буфер и преобразует символ конца строки в нулевой байт. <a class="xref" href="libpq-copy.html#LIBPQ-PQGETLINE"><code class="function">PQgetline</code></a> возвращает <code class="symbol">EOF</code> в конце ввода, 0, если была прочитана вся строка, и 1, если буфер заполнен, но завершающий символ конца строки ещё не прочитан.</p><p>Заметьте, что приложение должно проверить, не состоит ли новая строка в точности из двух символов <code class="literal">\.</code>, что будет означать, что сервер завершил передачу результатов команды <code class="command">COPY</code>. Если приложение может принимать строки длиннее <em class="parameter"><code>length</code></em>-1 символов, необходимо позаботиться о том, чтобы оно корректно распознавало строку <code class="literal">\.</code> (а не воспринимало, например, конец длинной строки данных как завершающую строку).</p></dd><dt id="LIBPQ-PQGETLINEASYNC"><span class="term"><code class="function">PQgetlineAsync</code><a id="id-1.7.3.17.10.3.2.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQGETLINEASYNC" class="id_link">#</a></dt><dd><p>Читает передаваемую сервером строку данных <code class="command">COPY</code> в буфер без блокировки. </p><pre class="synopsis">
int PQgetlineAsync(PGconn *conn,
                   char *buffer,
                   int bufsize);
</pre><p>Эта функция похожа на <a class="xref" href="libpq-copy.html#LIBPQ-PQGETLINE"><code class="function">PQgetline</code></a>, но может применяться в приложениях, которые должны читать данные <code class="command">COPY</code> асинхронно, то есть без блокировки. Запустив команду <code class="command">COPY</code> и получив ответ <code class="literal">PGRES_COPY_OUT</code>, приложение должно вызывать <a class="xref" href="libpq-async.html#LIBPQ-PQCONSUMEINPUT"><code class="function">PQconsumeInput</code>
     </a> и <a class="xref" href="libpq-copy.html#LIBPQ-PQGETLINEASYNC"><code class="function">PQgetlineAsync</code></a>, пока не будет получен сигнал «конец данных».</p><p>В отличие от <a class="xref" href="libpq-copy.html#LIBPQ-PQGETLINE"><code class="function">PQgetline</code></a>, эта функция сама отвечает за обнаружение конца данных.</p><p>При каждом вызове <a class="xref" href="libpq-copy.html#LIBPQ-PQGETLINEASYNC"><code class="function">PQgetlineAsync</code></a> будет возвращать данные, если во входном буфере <span class="application">libpq</span> оказывается полная строка данных. В противном случае никакие данные не возвращаются до поступления остального содержимого строки. Эта функция возвращает -1, если обнаруживается признак завершения копирования, или 0, если данные не получены, или положительное количество возвращённых байт данных. Если возвращается -1, вызывающий код должен затем вызвать <a class="xref" href="libpq-copy.html#LIBPQ-PQENDCOPY"><code class="function">PQendcopy</code></a> и после этого перейти в обычный режим работы.</p><p>Возвращаемые данные не будут пересекать границы строк данных. При этом может быть возвращена одна строка целиком. Но если буфер, выделенный вызывающим кодом, оказывается слишком мал для строки, передаваемой сервером, возвращена будет часть строки. Когда передаются текстовые данные, это можно выявить, проверив, содержит ли последний возвращаемый байт символ <code class="literal">\n</code>. (Для <code class="command">COPY</code> в двоичном формате потребуется собственно разобрать формат данных <code class="command">COPY</code>, чтобы выявить подобную ситуацию.) Возвращаемая строка не завершается нулём. (Если вы хотите получить строку с нулём в конце, передайте в <em class="parameter"><code>bufsize</code></em> число на единицу меньше фактического размера блока.)</p></dd><dt id="LIBPQ-PQPUTLINE"><span class="term"><code class="function">PQputline</code><a id="id-1.7.3.17.10.3.3.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQPUTLINE" class="id_link">#</a></dt><dd><p>Передаёт серверу строку, завершённую нулём. Возвращает 0 в случае успеха, либо <code class="symbol">EOF</code>, если передать строку не удаётся. </p><pre class="synopsis">
int PQputline(PGconn *conn,
              const char *string);
</pre><p>Поток данных <code class="command">COPY</code>, передаваемых последовательностью вызовов <a class="xref" href="libpq-copy.html#LIBPQ-PQPUTLINE"><code class="function">PQputline</code></a>, имеет тот же формат, что возвращает <a class="xref" href="libpq-copy.html#LIBPQ-PQGETLINEASYNC"><code class="function">PQgetlineAsync</code></a>, за исключением того, что приложения не обязательно должны передавать по одной строке данных за вызов <a class="xref" href="libpq-copy.html#LIBPQ-PQPUTLINE"><code class="function">PQputline</code></a>; они могут посылать части строк или сразу несколько строк.</p><div class="note"><h3 class="title">Примечание</h3><p>До версии 3.0 протокола <span class="productname">PostgreSQL</span> приложение должно было явно отправлять два символа <code class="literal">\.</code> последней строкой, чтобы сообщить серверу, что оно закончило передачу данных <code class="command">COPY</code>. Хотя это по-прежнему работает, такое поведение считается устаревшим и ожидается, что особое значение <code class="literal">\.</code> будет исключено в будущих версиях. Сейчас, передав собственно данные, достаточно вызвать <a class="xref" href="libpq-copy.html#LIBPQ-PQENDCOPY"><code class="function">PQendcopy</code></a>.</p></div></dd><dt id="LIBPQ-PQPUTNBYTES"><span class="term"><code class="function">PQputnbytes</code><a id="id-1.7.3.17.10.3.4.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQPUTNBYTES" class="id_link">#</a></dt><dd><p>Передаёт серверу строку, не завершённую нулём. Возвращает 0 в случае успеха, либо <code class="symbol">EOF</code>, если передать строку не удаётся. </p><pre class="synopsis">
int PQputnbytes(PGconn *conn,
                const char *buffer,
                int nbytes);
</pre><p>Поведение этой функции не отличается от <a class="xref" href="libpq-copy.html#LIBPQ-PQPUTLINE"><code class="function">PQputline</code></a>, но её буфер данных не должен содержать завершающий ноль, так как для неё число передаваемых байт задаётся непосредственным образом. Используйте эту функцию для передачи двоичных данных.</p></dd><dt id="LIBPQ-PQENDCOPY"><span class="term"><code class="function">PQendcopy</code><a id="id-1.7.3.17.10.3.5.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQENDCOPY" class="id_link">#</a></dt><dd><p>Производит синхронизацию с сервером. </p><pre class="synopsis">
int PQendcopy(PGconn *conn);
</pre><p> Эта функция ожидает завершения копирования сервером. Её следует вызывать, либо когда серверу была передана последняя строка функцией <a class="xref" href="libpq-copy.html#LIBPQ-PQPUTLINE"><code class="function">PQputline</code></a>, либо когда от сервера была получена последняя строка функцией <code class="function">PQgetline</code>. Если её не вызвать, сервер <span class="quote">«<span class="quote">потеряет синхронизацию</span>»</span> с клиентом. После завершения этой функции сервер готов принимать следующую команду SQL. В случае успешного завершения возвращается 0, в противном случае — ненулевое значение. (Чтобы получить подробности ошибки при ненулевом значении, вызовите <a class="xref" href="libpq-status.html#LIBPQ-PQERRORMESSAGE"><code class="function">PQerrorMessage</code></a>.)</p><p>Вызывая <a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a>, приложение должно обрабатывать результат <code class="literal">PGRES_COPY_OUT</code>, в цикле выполняя <a class="xref" href="libpq-copy.html#LIBPQ-PQGETLINE"><code class="function">PQgetline</code></a>, а обнаружив завершающую строку, вызвать <a class="xref" href="libpq-copy.html#LIBPQ-PQENDCOPY"><code class="function">PQendcopy</code></a>. Затем оно должно вернуться к циклу <a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a> и выйти из него, когда <a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a> возвратит нулевой указатель. Подобным образом, получив результат <code class="literal">PGRES_COPY_IN</code>, приложение должно выполнить серию вызовов <a class="xref" href="libpq-copy.html#LIBPQ-PQPUTLINE"><code class="function">PQputline</code></a>, завершить её, вызвав <a class="xref" href="libpq-copy.html#LIBPQ-PQENDCOPY"><code class="function">PQendcopy</code></a>, а затем вернуться к циклу <a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a>. При такой организации обработки команда <code class="command">COPY</code> будет корректно выполняться и в составе последовательности команд <acronym class="acronym">SQL</acronym>.</p><p>Старые приложения обычно передают команду <code class="command">COPY</code> через <a class="xref" href="libpq-exec.html#LIBPQ-PQEXEC"><code class="function">PQexec</code></a> и рассчитывают, что транзакция будет завершена после <a class="xref" href="libpq-copy.html#LIBPQ-PQENDCOPY"><code class="function">PQendcopy</code></a>. Это будет работать, только если команда <code class="command">COPY</code> является единственной <acronym class="acronym">SQL</acronym>-командой в строке запроса.</p></dd></dl></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="libpq-notify.html" title="34.9. Асинхронное уведомление">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="libpq.html" title="Глава 34. libpq — библиотека для языка C">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="libpq-control.html" title="34.11. Функции управления">След.</a></td></tr><tr><td width="40%" align="left" valign="top">34.9. Асинхронное уведомление </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 34.11. Функции управления</td></tr></table></div></body></html>