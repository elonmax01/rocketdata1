<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>38.11. Информация для оптимизации функций</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="xfunc-c.html" title="38.10. Функции на языке C" /><link rel="next" href="xaggr.html" title="38.12. Пользовательские агрегатные функции" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">38.11. Информация для оптимизации функций</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="xfunc-c.html" title="38.10. Функции на языке C">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="extend.html" title="Глава 38. Расширение SQL">Наверх</a></td><th width="60%" align="center">Глава 38. Расширение <acronym class="acronym">SQL</acronym></th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="xaggr.html" title="38.12. Пользовательские агрегатные функции">След.</a></td></tr></table><hr /></div><div class="sect1" id="XFUNC-OPTIMIZATION"><div class="titlepage"><div><div><h2 class="title" style="clear: both">38.11. Информация для оптимизации функций <a href="#XFUNC-OPTIMIZATION" class="id_link">#</a></h2></div></div></div><a id="id-1.8.3.14.2" class="indexterm"></a><p>Сама по себе функция для СУБД является просто <span class="quote">«<span class="quote">чёрным ящиком</span>»</span>, о поведении которого известно очень мало. Это означает, что запросы, вызывающие функции, могут выполняться гораздо менее эффективно, чем могли бы в теории. Поэтому имеется возможность сообщить планировщику дополнительные сведения о функции, которые помогут ему оптимизировать вызовы функций.</p><p>Некоторые основные факты передаются декларативным образом в команде <a class="link" href="sql-createfunction.html" title="CREATE FUNCTION"><code class="command">CREATE FUNCTION</code></a>; в их числе один из самых значимых — <a class="link" href="xfunc-volatility.html" title="38.7. Категории изменчивости функций">характеристика изменчивости</a> (<code class="literal">IMMUTABLE</code>, <code class="literal">STABLE</code> или <code class="literal">VOLATILE</code>). Создавая любую функцию, очень важно правильно определить эту характеристику. Также может определяться характеристика распараллеливания (<code class="literal">PARALLEL UNSAFE</code>, <code class="literal">PARALLEL RESTRICTED</code> или <code class="literal">PARALLEL SAFE</code>), если вы рассчитываете, что эта функция будет использоваться в распараллеливаемых запросах. Кроме того, для функции может задаваться примерная стоимость выполнения и/или оценка количества строк, выдаваемого функцией, возвращающей множество. Однако декларативный способ описания двух последних фактов позволяет задать только некоторое постоянное значение, а это полезно далеко не всегда.</p><p>Но имеется также возможность связать <em class="firstterm">вспомогательную функцию для планировщика</em> с вызываемой из SQL функцией (она будет <em class="firstterm">целевой функцией</em> для первой), и передать через неё ту информацию о целевой функции, которая слишком сложна для представления в декларативном виде. Вспомогательные функции для планировщика должным быть написаны на C (хотя язык целевых функций может быть любым), что переводит их в категорию расширенных возможностей, и разрабатывать их будут относительно немногие пользователи.</p><p>Вспомогательная функция должна иметь в SQL такую сигнатуру: </p><pre class="programlisting">supportfn(internal) returns internal</pre><p> Она связывается с целевой функцией с помощью указания <code class="literal">SUPPORT</code> в команде, создающей целевую функцию.</p><p>Подробное описание API можно найти в файле <code class="filename">src/include/nodes/supportnodes.h</code> в исходном коде <span class="productname">PostgreSQL</span>. Здесь даётся только общее представление о том, что могут делать вспомогательные функции для планировщика. Множество запросов к вспомогательным функциям расширяемое, так что в будущих версиях у них могут появиться и другие возможности</p><p>Некоторые вызовы функций можно упростить во время планирования, в зависимости от особенностей функции. Например, вызов <code class="literal">int4mul(n, 1)</code> можно свести просто к <code class="literal">n</code>. Преобразование такого рода может выполняться вспомогательной функцией, если она обрабатывает запросы типа <code class="literal">SupportRequestSimplify</code>. Эта вспомогательная функция будет вызываться для каждого экземпляра вызова целевой функции, найденного в дереве разобранного запроса. Если она обнаруживает, что этот конкретный вызов можно упростить и привести к другому виду, она может построить и возвратить другое дерево с изменённым выражением. Это будет автоматически работать и для операторов, основанных на функциях, — в данном примере <code class="literal">n * 1</code> будет также упрощено до <code class="literal">n</code>. (Но заметьте, что это просто иллюстрация; конкретно эту оптимизацию стандартный <span class="productname">PostgreSQL</span> не производит). При этом не гарантируется, что <span class="productname">PostgreSQL</span> никогда не вызовет целевую функцию в случаях, которые может упростить вспомогательная функция. С учётом этого важно обеспечить строгую идентичность упрощённого выражения фактическому выполнению целевой функции.</p><p>Для целевой функции, возвращающей значение <code class="type">boolean</code>, часто бывает полезно оценить, какой процент строк будет выбран предложением <code class="literal">WHERE</code>, в котором вызывается эта функция. Эту оценку позволяет получить вспомогательная функция, обрабатывающая запросы типа <code class="literal">SupportRequestSelectivity</code>.</p><p>Если алгоритм работы целевой функции значительно меняется в зависимости от её аргументов, для неё может иметь смысл вычислять переменную оценку стоимости. Это можно сделать, реализовав вспомогательную функцию, которая будет обрабатывать запросы типа <code class="literal">SupportRequestCost</code>.</p><p>Для целевой функции, возвращающей множество, часто полезно иметь переменную оценку числа выдаваемых строк. Реализовать это позволяет вспомогательная функция, обрабатывающая запросы типа <code class="literal">SupportRequestRows</code>.</p><p>Для целевой функции, возвращающей значение <code class="type">boolean</code>, может существовать возможность преобразовать вызов функции в условии <code class="literal">WHERE</code> в предложение(я) с индексируемыми операторами. Преобразованные предложения должны быть в точности идентичны условию функции либо могут быть несколько менее строгими (то есть они могут принимать некоторые значения, не удовлетворяющие условию с функцией). В последнем случае условие с индексом считается <em class="firstterm">неточным</em>; оно может использоваться для поиска по индексу, но для каждой строки, полученной при таком поиске, должна вызываться функция, чтобы точно определить, удовлетворяет ли строка условию <code class="literal">WHERE</code>. Для создания таких условий вспомогательная функция должна обрабатывать запросы типа <code class="literal">SupportRequestIndexCondition</code>.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="xfunc-c.html" title="38.10. Функции на языке C">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="extend.html" title="Глава 38. Расширение SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="xaggr.html" title="38.12. Пользовательские агрегатные функции">След.</a></td></tr><tr><td width="40%" align="left" valign="top">38.10. Функции на языке C </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 38.12. Пользовательские агрегатные функции</td></tr></table></div></body></html>