<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>53.64. pg_type</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="catalog-pg-ts-template.html" title="53.63. pg_ts_template" /><link rel="next" href="catalog-pg-user-mapping.html" title="53.65. pg_user_mapping" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">53.64. <code class="structname">pg_type</code></th></tr><tr><td width="10%" align="left"><a accesskey="p" href="catalog-pg-ts-template.html" title="53.63. pg_ts_template">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="catalogs.html" title="Глава 53. Системные каталоги">Наверх</a></td><th width="60%" align="center">Глава 53. Системные каталоги</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="catalog-pg-user-mapping.html" title="53.65. pg_user_mapping">След.</a></td></tr></table><hr /></div><div class="sect1" id="CATALOG-PG-TYPE"><div class="titlepage"><div><div><h2 class="title" style="clear: both">53.64. <code class="structname">pg_type</code> <a href="#CATALOG-PG-TYPE" class="id_link">#</a></h2></div></div></div><a id="id-1.10.4.66.2" class="indexterm"></a><p>В каталоге <code class="structname">pg_type</code> хранится информация о типах данных. Базовые типы и типы-перечисления (скалярные типы) создаются командой <a class="link" href="sql-createtype.html" title="CREATE TYPE"><code class="command">CREATE TYPE</code></a>, а домены — командой <a class="link" href="sql-createdomain.html" title="CREATE DOMAIN"><code class="command">CREATE DOMAIN</code></a>. При добавлении любой таблицы в базу данных автоматически создаётся составной тип, представляющий структуру строки таблицы. Также возможно создавать составные типы с помощью команды <code class="command">CREATE TYPE AS</code>.</p><div class="table" id="id-1.10.4.66.4"><p class="title"><strong>Таблица 53.64. Столбцы <code class="structname">pg_type</code></strong></p><div class="table-contents"><table class="table" summary="Столбцы pg_type" border="1"><colgroup><col /></colgroup><thead><tr><th class="catalog_table_entry"><p class="column_definition">Тип столбца</p>
      <p>Описание</p></th></tr></thead><tbody><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">oid</code> <code class="type">oid</code>
      </p>
      <p>Идентификатор строки</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">typname</code> <code class="type">name</code>
      </p>
      <p>Имя типа данных</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition"><code class="structfield">typnamespace</code> <code class="type">oid</code> (ссылается на <a class="link" href="catalog-pg-namespace.html" title="53.32. pg_namespace"><code class="structname">pg_namespace</code></a>.<code class="structfield">oid</code>)</p>
      <p>OID пространства имён, содержащего этот тип</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition"><code class="structfield">typowner</code> <code class="type">oid</code> (ссылается на <a class="link" href="catalog-pg-authid.html" title="53.8. pg_authid"><code class="structname">pg_authid</code></a>.<code class="structfield">oid</code>)</p>
      <p>Владелец типа</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">typlen</code> <code class="type">int2</code>
      </p>
      <p>Для типа фиксированного размера в <code class="structfield">typlen</code> задаётся число байт во внутреннем представлении типа. Но для типов переменной длины, <code class="structfield">typlen</code> будет отрицательным. Значение -1 обозначает тип <span class="quote">«<span class="quote">varlena</span>»</span> (он содержит машинное слово, определяющее длину), а -2 обозначает строку в стиле C, оканчивающуюся нулём.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">typbyval</code> <code class="type">bool</code>
      </p>
      <p>Поле <code class="structfield">typbyval</code> определяет, будут ли внутренние процедуры передавать переменные этого типа по значению или по ссылке. Полю <code class="structfield">typbyval</code> лучше присвоить false, если длина <code class="structfield">typlen</code> не равна 1, 2 или 4 (либо 8, на 64-битных машинах). Типы переменной длины всегда передаются по ссылке. Заметьте, что <code class="structfield">typbyval</code> может быть false, даже если размер типа позволяет передачу по значению.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">typtype</code> <code class="type">char</code>
      </p>
      <p>Поле <code class="structfield">typtype</code> принимает значение <code class="literal">b</code> для базового типа (base), <code class="literal">c</code> для составного (composite), то есть типа строки таблицы, <code class="literal">d</code> для домена (domain), <code class="literal">e</code> для перечисления (enum), <code class="literal">p</code> для псевдотипа (pseudo-type), <code class="literal">r</code> для диапазона (range) или <code class="literal">m</code> для мультидиапазона (multirange). См. также <code class="structfield">typrelid</code> и <code class="structfield">typbasetype</code>.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">typcategory</code> <code class="type">char</code>
      </p>
      <p>В поле <code class="structfield">typcategory</code> задаётся произвольная классификация типов данных, на основе которой анализатор запросов может определить, какие неявные приведения будут <span class="quote">«<span class="quote">предпочитаемыми</span>»</span>. См. <a class="xref" href="catalog-pg-type.html#CATALOG-TYPCATEGORY-TABLE" title="Таблица 53.65. Коды typcategory">Таблицу 53.65</a>.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">typispreferred</code> <code class="type">bool</code>
      </p>
      <p>True, если этот тип является предпочитаемым целевым типом в своей категории (<code class="structfield">typcategory</code>)</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">typisdefined</code> <code class="type">bool</code>
      </p>
      <p>True, если тип определён, и false, если это тип-заготовка для ещё не определённого типа. Когда значение <code class="structfield">typisdefined</code> — false, можно полагаться только на заданное имя, пространство имён и OID типа.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">typdelim</code> <code class="type">char</code>
      </p>
      <p>Символ, разделяющий два значения этого типа при разборе вводимого массива. Заметьте, что этот разделитель связывается с типом данных элемента массива, а не с типом самого массива.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition"><code class="structfield">typrelid</code> <code class="type">oid</code> (ссылается на <a class="link" href="catalog-pg-class.html" title="53.11. pg_class"><code class="structname">pg_class</code></a>.<code class="structfield">oid</code>)</p>
      <p>Если это составной тип (см. <code class="structfield">typtype</code>), этот столбец указывает на запись <a class="link" href="catalog-pg-class.html" title="53.11. pg_class"><code class="structname">pg_class</code></a>, определяющую соответствующую таблицу. (Для независимого составного типа запись в <a class="link" href="catalog-pg-class.html" title="53.11. pg_class"><code class="structname">pg_class</code></a> на самом деле не представляет таблицу, но она всё равно нужна для связывания с записями <a class="link" href="catalog-pg-attribute.html" title="53.7. pg_attribute"><code class="structname">pg_attribute</code></a> этого типа.) Для не составных типов содержит ноль.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition"><code class="structfield">typsubscript</code> <code class="type">regproc</code> (ссылается на <a class="link" href="catalog-pg-proc.html" title="53.39. pg_proc"><code class="structname">pg_proc</code></a>.<code class="structfield">oid</code>)</p>
      <p>OID функции обработки индексов элементов или ноль, если этот тип не поддерживает обращение к элементам по индексу. Для <span class="quote">«<span class="quote">настоящих</span>»</span> типов массивов <code class="structfield">typsubscript</code> = <code class="function">array_subscript_handler</code>, но другие типы могут реализовывать обращение к элементам по индексу особым образом.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition"><code class="structfield">typelem</code> <code class="type">oid</code> (ссылается на <a class="link" href="catalog-pg-type.html" title="53.64. pg_type"><code class="structname">pg_type</code></a>.<code class="structfield">oid</code>)</p>
      <p>Если значение <code class="structfield">typelem</code> ненулевое, оно указывает на другую строку в <code class="structname">pg_type</code>, определяя тип, возвращаемый при обращении по индексу. Если значение <code class="structfield">typsubscript</code> нулевое, то и значение <code class="structfield">typelem</code> должно быть нулевым. Однако в некоторых случаях оно может быть нулевым и когда значение <code class="structfield">typsubscript</code> ненулевое, если обработчик не учитывает <code class="structfield">typelem</code> при определении типа результата. Обратите внимание, что зависимость <code class="structfield">typelem</code> подразумевает физическое включение типа элемента в целевой тип; поэтому возможности изменения DDL типа элемента могут быть ограничены существованием данного типа.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition"><code class="structfield">typarray</code> <code class="type">oid</code> (ссылается на <a class="link" href="catalog-pg-type.html" title="53.64. pg_type"><code class="structname">pg_type</code></a>.<code class="structfield">oid</code>)</p>
      <p>Если значение <code class="structfield">typarray</code> ненулевое, оно указывает на другую запись в <code class="structname">pg_type</code>, описывающую <span class="quote">«<span class="quote">настоящий</span>»</span> тип массива, в которой этот тип будет элементом</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition"><code class="structfield">typinput</code> <code class="type">regproc</code> (ссылается на <a class="link" href="catalog-pg-proc.html" title="53.39. pg_proc"><code class="structname">pg_proc</code></a>.<code class="structfield">oid</code>)</p>
      <p>Функция преобразования ввода (из текстового формата)</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition"><code class="structfield">typoutput</code> <code class="type">regproc</code> (ссылается на <a class="link" href="catalog-pg-proc.html" title="53.39. pg_proc"><code class="structname">pg_proc</code></a>.<code class="structfield">oid</code>)</p>
      <p>Функция преобразования вывода (в текстовый формат)</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition"><code class="structfield">typreceive</code> <code class="type">regproc</code> (ссылается на <a class="link" href="catalog-pg-proc.html" title="53.39. pg_proc"><code class="structname">pg_proc</code></a>.<code class="structfield">oid</code>)</p>
      <p>Функция преобразования ввода (из двоичного формата), либо ноль, если её нет</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition"><code class="structfield">typsend</code> <code class="type">regproc</code> (ссылается на <a class="link" href="catalog-pg-proc.html" title="53.39. pg_proc"><code class="structname">pg_proc</code></a>.<code class="structfield">oid</code>)</p>
      <p>Функция преобразования вывода (в двоичный формат), либо ноль, если её нет</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition"><code class="structfield">typmodin</code> <code class="type">regproc</code> (ссылается на <a class="link" href="catalog-pg-proc.html" title="53.39. pg_proc"><code class="structname">pg_proc</code></a>.<code class="structfield">oid</code>)</p>
      <p>Функция ввода модификатора типа, либо ноль, если тип не поддерживает модификаторы</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition"><code class="structfield">typmodout</code> <code class="type">regproc</code> (ссылается на <a class="link" href="catalog-pg-proc.html" title="53.39. pg_proc"><code class="structname">pg_proc</code></a>.<code class="structfield">oid</code>)</p>
      <p>Функция вывода модификатора типа, либо ноль для использования стандартного формата</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition"><code class="structfield">typanalyze</code> <code class="type">regproc</code> (ссылается на <a class="link" href="catalog-pg-proc.html" title="53.39. pg_proc"><code class="structname">pg_proc</code></a>.<code class="structfield">oid</code>)</p>
      <p>Нестандартная функция <code class="command">ANALYZE</code>, либо ноль для использования стандартной функции</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">typalign</code> <code class="type">char</code>
      </p>
      <p>Переменная <code class="structfield">typalign</code> определяет выравнивание, требуемое при хранении значения этого типа. Эта величина применяется при хранении на диске, а также для большинства представлений значений внутри <span class="productname">PostgreSQL</span>. Когда последовательно хранятся несколько значений, как например в представлении полной строки на диске, дополнительные байты добавляются перед значением этого типа, чтобы оно начиналось с указанной границы. Заданное выравнивание определяет смещение первого элемента последовательности. Возможные значения: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">c</code> = выравнивание по символам (<code class="type">char</code>), то есть выравнивание не требуется.</p></li><li class="listitem"><p><code class="literal">s</code> = выравнивание по коротким словам (<code class="type">short</code>), 2 байта для большинства машин.</p></li><li class="listitem"><p><code class="literal">i</code> = выравнивание по целым (<code class="type">int</code>), 4 байта для большинства машин.</p></li><li class="listitem"><p><code class="literal">d</code> = выравнивание по двойным словам (<code class="type">double</code>), 8 байт для большинства машин, но не для всех.</p></li></ul></div></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">typstorage</code> <code class="type">char</code>
      </p>
      <p>Значение <code class="structfield">typstorage</code> для типов varlena (типов с <code class="structfield">typlen</code> = -1) говорит, готов ли тип для помещения в TOAST, и какова стратегия по умолчанию для хранения атрибутов этого типа. Возможные значения: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">p</code> (plain, простое): Значение всегда должно храниться простым образом (этот вариант используется для всех типов постоянной длины).</p></li><li class="listitem"><p><code class="literal">e</code> (external, внешнее): Значения могут храниться во вторичном отношении <span class="quote">«<span class="quote">TOAST</span>»</span> (если оно есть, см. <code class="literal">pg_class.reltoastrelid</code>).</p></li><li class="listitem"><p><code class="literal">m</code> (main, основное): Значения могут сжиматься и храниться внутри кортежа.</p></li><li class="listitem"><p><code class="literal">x</code> (extended, расширенное): Значения могут сжиматься и/или перемещаться во вторичное хранилище.</p></li></ul></div><p> Для типов, которые могут быть помещены в TOAST, обычно применяется стратегия <code class="literal">x</code>. Заметьте, что значения <code class="literal">m</code> тоже могут быть помещены во вторичное хранилище, но только в качестве последней меры (в первую очередь в него помещаются значения <code class="literal">e</code> и <code class="literal">x</code>).</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">typnotnull</code> <code class="type">bool</code>
      </p>
      <p>Поле <code class="structfield">typnotnull</code> представляет ограничение «не NULL» для типа. Применяется только для доменов.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition"><code class="structfield">typbasetype</code> <code class="type">oid</code> (ссылается на <a class="link" href="catalog-pg-type.html" title="53.64. pg_type"><code class="structname">pg_type</code></a>.<code class="structfield">oid</code>)</p>
      <p>Если это домен (см. <code class="structfield">typtype</code>), то <code class="structfield">typbasetype</code> указывает на тип, на котором он основан. Ноль, если это не домен.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">typtypmod</code> <code class="type">int4</code>
      </p>
      <p>Домены используют <code class="structfield">typtypmod</code> для записи модификатора (<code class="literal">typmod</code>), применяемого к их базовому типу (-1, если базовый тип не использует <code class="literal">typmod</code>). Если тип не является доменом, принимает значение -1.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">typndims</code> <code class="type">int4</code>
      </p>
      <p>Значение <code class="structfield">typndims</code> задаёт число размерностей массива для домена, определённого поверх массива (то есть когда <code class="structfield">typbasetype</code> — тип массива). Для типов, отличных от доменов поверх типов массивов, принимает значение 0.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition"><code class="structfield">typcollation</code> <code class="type">oid</code> (ссылается на <a class="link" href="catalog-pg-collation.html" title="53.12. pg_collation"><code class="structname">pg_collation</code></a>.<code class="structfield">oid</code>)</p>
      <p>Значение <code class="structfield">typcollation</code> задаёт правило сортировки для типа. Если тип не является сортируемым, оно будет нулевым. У базового типа, поддерживающего правила сортировки, в этом поле будет ненулевое значение, обычно <code class="symbol">DEFAULT_COLLATION_OID</code>. Домен на базе сортируемого типа может иметь другой OID правила сортировки, если оно было изменено для домена.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">typdefaultbin</code> <code class="type">pg_node_tree</code>
      </p>
      <p>Если поле <code class="structfield">typdefaultbin</code> не NULL, в нём содержится представление выражения по умолчанию для этого типа (совместимое с <code class="function">nodeToString()</code>. Это поле используется только для доменов.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">typdefault</code> <code class="type">text</code>
      </p>
      <p>Поле <code class="structfield">typdefault</code> содержит NULL, если с типом не связано значение по умолчанию. Если <code class="structfield">typdefaultbin</code> не NULL, <code class="structfield">typdefault</code> должно содержать понятную человеку версию выражения значения по умолчанию, записанного в <code class="structfield">typdefaultbin</code>. Если <code class="structfield">typdefaultbin</code> содержит NULL, а <code class="structfield">typdefault</code> нет, то в <code class="structfield">typdefault</code> находится внешнее представление значения по умолчанию, которое можно передать функции преобразования ввода и получить константу.</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">typacl</code> <code class="type">aclitem[]</code>
      </p>
      <p>Права доступа; за подробностями обратитесь к <a class="xref" href="ddl-priv.html" title="5.7. Права">Разделу 5.7</a>.</p></td></tr></tbody></table></div></div><br class="table-break" /><div class="note"><h3 class="title">Примечание</h3><p>Для типов фиксированного размера, используемых в системных таблицах, важно, чтобы размер и выравнивание, определённые в <code class="structname">pg_type</code>, согласовывались с тем, как компилятор располагает этот столбец в структуре, представляющей строку таблицы.</p></div><p>В <a class="xref" href="catalog-pg-type.html#CATALOG-TYPCATEGORY-TABLE" title="Таблица 53.65. Коды typcategory">Таблице 53.65</a> перечисляются определённые в системе значения <code class="structfield">typcategory</code>. Если этот список будет дополняться в будущем, в него будут добавляться тоже буквы ASCII в верхнем регистре. Все другие символы ASCII зарезервированы для категорий, определяемых пользователями.</p><div class="table" id="CATALOG-TYPCATEGORY-TABLE"><p class="title"><strong>Таблица 53.65. Коды <code class="structfield">typcategory</code></strong></p><div class="table-contents"><table class="table" summary="Коды typcategory" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Код</th><th>Категория</th></tr></thead><tbody><tr><td><code class="literal">A</code></td><td>Типы массивов</td></tr><tr><td><code class="literal">B</code></td><td>Логические типы</td></tr><tr><td><code class="literal">C</code></td><td>Составные типы</td></tr><tr><td><code class="literal">D</code></td><td>Типы даты/времени</td></tr><tr><td><code class="literal">E</code></td><td>Типы-перечисления</td></tr><tr><td><code class="literal">G</code></td><td>Геометрические типы</td></tr><tr><td><code class="literal">I</code></td><td>Типы, описывающие сетевые адреса</td></tr><tr><td><code class="literal">N</code></td><td>Числовые типы</td></tr><tr><td><code class="literal">P</code></td><td>Псевдотипы</td></tr><tr><td><code class="literal">R</code></td><td>Диапазонные типы</td></tr><tr><td><code class="literal">S</code></td><td>Строковые типы</td></tr><tr><td><code class="literal">T</code></td><td>Интервальные типы</td></tr><tr><td><code class="literal">U</code></td><td>Пользовательские типы</td></tr><tr><td><code class="literal">V</code></td><td>Типы битовых строк</td></tr><tr><td><code class="literal">X</code></td><td>Неизвестный тип (<code class="type">unknown</code>)</td></tr><tr><td><code class="literal">Z</code></td><td>Типы для внутреннего пользования</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="catalog-pg-ts-template.html" title="53.63. pg_ts_template">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="catalogs.html" title="Глава 53. Системные каталоги">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="catalog-pg-user-mapping.html" title="53.65. pg_user_mapping">След.</a></td></tr><tr><td width="40%" align="left" valign="top">53.63. <code class="structname">pg_ts_template</code> </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 53.65. <code class="structname">pg_user_mapping</code></td></tr></table></div></body></html>