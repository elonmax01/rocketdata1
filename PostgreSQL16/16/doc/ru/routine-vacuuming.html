<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>25.1. Регламентная очистка</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="maintenance.html" title="Глава 25. Регламентные задачи обслуживания базы данных" /><link rel="next" href="routine-reindex.html" title="25.2. Регулярная переиндексация" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">25.1. Регламентная очистка</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="maintenance.html" title="Глава 25. Регламентные задачи обслуживания базы данных">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="maintenance.html" title="Глава 25. Регламентные задачи обслуживания базы данных">Наверх</a></td><th width="60%" align="center">Глава 25. Регламентные задачи обслуживания базы данных</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="routine-reindex.html" title="25.2. Регулярная переиндексация">След.</a></td></tr></table><hr /></div><div class="sect1" id="ROUTINE-VACUUMING"><div class="titlepage"><div><div><h2 class="title" style="clear: both">25.1. Регламентная очистка <a href="#ROUTINE-VACUUMING" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="routine-vacuuming.html#VACUUM-BASICS">25.1.1. Основные принципы очистки</a></span></dt><dt><span class="sect2"><a href="routine-vacuuming.html#VACUUM-FOR-SPACE-RECOVERY">25.1.2. Высвобождение дискового пространства</a></span></dt><dt><span class="sect2"><a href="routine-vacuuming.html#VACUUM-FOR-STATISTICS">25.1.3. Обновление статистики планировщика</a></span></dt><dt><span class="sect2"><a href="routine-vacuuming.html#VACUUM-FOR-VISIBILITY-MAP">25.1.4. Обновление карты видимости</a></span></dt><dt><span class="sect2"><a href="routine-vacuuming.html#VACUUM-FOR-WRAPAROUND">25.1.5. Предотвращение ошибок из-за зацикливания счётчика транзакций</a></span></dt><dt><span class="sect2"><a href="routine-vacuuming.html#AUTOVACUUM">25.1.6. Демон автоочистки</a></span></dt></dl></div><a id="id-1.6.12.10.2" class="indexterm"></a><p>Базы данных <span class="productname">PostgreSQL</span> требуют периодического проведения процедуры обслуживания, которая называется <em class="firstterm">очисткой</em>. Во многих случаях очистку достаточно выполнять с помощью <em class="firstterm">демона автоочистки</em>, который описан в <a class="xref" href="routine-vacuuming.html#AUTOVACUUM" title="25.1.6. Демон автоочистки">Подразделе 25.1.6</a>. Возможно, в вашей ситуации для получения оптимальных результатов потребуется настроить описанные там же параметры автоочистки. Некоторые администраторы СУБД могут дополнить или заменить действие этого демона командами <code class="command">VACUUM</code> (обычно они выполняются по расписанию в заданиях <span class="application">cron</span> или <span class="application">Планировщика задач</span>). Чтобы правильно организовать очистку вручную, необходимо понимать темы, которые будут рассмотрены в следующих подразделах. Администраторы, которые полагаются на автоочистку, возможно, всё же захотят просмотреть этот материал, чтобы лучше понимать и настраивать эту процедуру.</p><div class="sect2" id="VACUUM-BASICS"><div class="titlepage"><div><div><h3 class="title">25.1.1. Основные принципы очистки <a href="#VACUUM-BASICS" class="id_link">#</a></h3></div></div></div><p>Команды <a class="link" href="sql-vacuum.html" title="VACUUM"><code class="command">VACUUM</code></a> в <span class="productname">PostgreSQL</span> должны обрабатывать каждую таблицу по следующим причинам: </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">Для высвобождения или повторного использования дискового пространства, занятого изменёнными или удалёнными строками.</li><li class="listitem">Для обновления статистики по данным, используемой планировщиком запросов <span class="productname">PostgreSQL</span>.</li><li class="listitem">Для обновления карты видимости, которая ускоряет <a class="link" href="indexes-index-only-scans.html" title="11.9. Сканирование только индекса и покрывающие индексы">сканирование только индекса</a>.</li><li class="listitem">Для предотвращения потери очень старых данных из-за зацикливания идентификаторов <em class="firstterm">транзакций</em> или <em class="firstterm">мультитранзакций</em>.</li></ol></div><p> Разные причины диктуют выполнение действий <code class="command">VACUUM</code> с разной частотой и в разном объёме, как рассматривается в следующих подразделах.</p><p>Существует два варианта <code class="command">VACUUM</code>: обычный <code class="command">VACUUM</code> и <code class="command">VACUUM FULL</code>. Команда <code class="command">VACUUM FULL</code> может высвободить больше дискового пространства, однако работает медленнее. Кроме того, обычная команда <code class="command">VACUUM</code> может выполняться параллельно с использованием производственной базы данных. (При этом такие команды как <code class="command">SELECT</code>, <code class="command">INSERT</code>, <code class="command">UPDATE</code> и <code class="command">DELETE</code> будут выполняться нормально, хотя нельзя будет изменить определение таблицы командами типа <code class="command">ALTER TABLE</code>.) Команда <code class="command">VACUUM FULL</code> требует блокировки обрабатываемой таблицы в режиме <code class="literal">ACCESS EXCLUSIVE</code> и поэтому не может выполняться параллельно с другими операциями с этой таблицей. По этой причине администраторы, как правило, должны стараться использовать обычную команду <code class="command">VACUUM</code> и избегать <code class="command">VACUUM FULL</code>.</p><p>Команда <code class="command">VACUUM</code> порождает существенный объём трафика ввода/вывода, который может стать причиной низкой производительности в других активных сеансах. Это влияние фоновой очистки можно регулировать, настраивая параметры конфигурации (см. <a class="xref" href="runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-VACUUM-COST" title="20.4.4. Задержка очистки по стоимости">Подраздел 20.4.4</a>).</p></div><div class="sect2" id="VACUUM-FOR-SPACE-RECOVERY"><div class="titlepage"><div><div><h3 class="title">25.1.2. Высвобождение дискового пространства <a href="#VACUUM-FOR-SPACE-RECOVERY" class="id_link">#</a></h3></div></div></div><a id="id-1.6.12.10.5.2" class="indexterm"></a><p>В <span class="productname">PostgreSQL</span> команды <code class="command">UPDATE</code> или <code class="command">DELETE</code> не вызывают немедленного удаления старой версии изменяемых строк. Этот подход необходим для реализации эффективного многоверсионного управления конкурентным доступом (<acronym class="acronym">MVCC</acronym>, см. <a class="xref" href="mvcc.html" title="Глава 13. Управление конкурентным доступом">Главу 13</a>): версия строки не должна удаляться до тех пор, пока она остаётся потенциально видимой для других транзакций. Однако в конце концов устаревшая или удалённая версия строки оказывается не нужна ни одной из транзакций. После этого занимаемое ей место должно быть освобождено и может быть отдано новым строкам, во избежание неограниченного роста потребности в дисковом пространстве. Это происходит при выполнении команды <code class="command">VACUUM</code>.</p><p>Обычная форма <code class="command">VACUUM</code> удаляет неиспользуемые версии строк в таблицах и индексах и помечает пространство свободным для дальнейшего использования. Однако это дисковое пространство не возвращается операционной системе, кроме особого случая, когда полностью освобождаются одна или несколько страниц в конце таблицы и можно легко получить исключительную блокировку таблицы. Команда <code class="command">VACUUM FULL</code>, напротив, кардинально сжимает таблицы, записывая абсолютно новую версию файла таблицы без неиспользуемого пространства. Это минимизирует размер таблицы, однако может занять много времени. Кроме того, для этого требуется больше места на диске для записи новой копии таблицы до завершения операции.</p><p>Обычно цель регулярной очистки — выполнять простую очистку (<code class="command">VACUUM</code>) достаточно часто, чтобы не возникала необходимость в <code class="command">VACUUM FULL</code>. Демон автоочистки пытается работать в этом режиме, и на самом деле он сам никогда не выполняет <code class="command">VACUUM FULL</code>. Основная идея такого подхода не в том, чтобы минимизировать размер таблиц, а в том, чтобы поддерживать использование дискового пространства на стабильном уровне: каждая таблица занимает объём, равный её минимальному размеру, плюс объём, который был занят между процедурами очистки. Хотя с помощью <code class="command">VACUUM FULL</code> можно сжать таблицу до минимума и возвратить дисковое пространство операционной системе, большого смысла в этом нет, если в будущем таблица так же вырастет снова. Следовательно, для активно изменяемых таблиц лучше с умеренной частотой выполнять <code class="command">VACUUM</code>, чем очень редко выполнять <code class="command">VACUUM FULL</code>.</p><p>Некоторые администраторы предпочитают планировать очистку БД самостоятельно, например, проводя все работы ночью в период низкой загрузки. Однако очистка только по фиксированному расписанию плоха тем, что при резком скачке интенсивности изменений раздувание таблицы может привести к тому, что для высвобождения пространства действительно понадобится выполнить <code class="command">VACUUM FULL</code>. Использование демона автоочистки снимает эту проблему, поскольку он планирует очистку динамически, отслеживая интенсивность изменений. Полностью отключать этот демон может иметь смысл, только если вы имеете дело с предельно предсказуемой загрузкой. Возможен и компромиссный вариант — настроить параметры демона автоочистки так, чтобы он реагировал только на необычайно высокую интенсивность изменений и мог удержать ситуацию под контролем, в то время как команды <code class="command">VACUUM</code>, запускаемые по расписанию, будут выполнять основную работу в периоды нормальной загрузки.</p><p>Если же автоочистка не применяется, обычно планируется выполнение <code class="command">VACUUM</code> для всей базы данных раз в сутки в период низкой активности, и в случае необходимости оно дополняется более частой очисткой интенсивно изменяемых таблиц. (В некоторых ситуациях, когда изменения производятся крайне интенсивно, самые востребованные таблицы могут очищаться раз в несколько минут.) Если в вашем кластере несколько баз данных, не забывайте выполнять <code class="command">VACUUM</code> для каждой из них; при этом может быть полезна программа <a class="xref" href="app-vacuumdb.html" title="vacuumdb"><span class="refentrytitle"><span class="application">vacuumdb</span></span></a>.</p><div class="tip"><h3 class="title">Подсказка</h3><p>Результат обычного <code class="command">VACUUM</code> может быть неудовлетворительным, когда вследствие массового изменения или удаления в таблице оказывается много мёртвых версий строк. Если у вас есть такая таблица и вам нужно освободить лишнее пространство, которое она занимает, используйте команду <code class="command">VACUUM FULL</code> или, в качестве альтернативы, <a class="link" href="sql-cluster.html" title="CLUSTER"><code class="command">CLUSTER</code></a> или один из вариантов <a class="link" href="sql-altertable.html" title="ALTER TABLE"><code class="command">ALTER TABLE</code></a>, выполняющий перезапись таблицы. Эти команды записывают абсолютно новую копию таблицы и строят для неё индексы. Все эти варианты требуют блокировки в режиме <code class="literal">ACCESS EXCLUSIVE</code>. Заметьте, что они также на время требуют дополнительного пространства на диске в объёме, приблизительно равном размеру таблицы, поскольку старые копии таблицы и индексов нельзя удалить до завершения создания новых копий.</p></div><div class="tip"><h3 class="title">Подсказка</h3><p>Если у вас есть таблица, всё содержимое которой периодически нужно удалять, имеет смысл делать это, выполняя только <a class="link" href="sql-truncate.html" title="TRUNCATE"><code class="command">TRUNCATE</code></a>, а не <code class="command">DELETE</code> и затем <code class="command">VACUUM</code>. <code class="command">TRUNCATE</code> немедленно удаляет всё содержимое таблицы, не требуя последующей очистки (<code class="command">VACUUM</code> или <code class="command">VACUUM FULL</code>) для высвобождения неиспользуемого дискового пространства. Недостатком такого подхода является нарушение строгой семантики MVCC.</p></div></div><div class="sect2" id="VACUUM-FOR-STATISTICS"><div class="titlepage"><div><div><h3 class="title">25.1.3. Обновление статистики планировщика <a href="#VACUUM-FOR-STATISTICS" class="id_link">#</a></h3></div></div></div><a id="id-1.6.12.10.6.2" class="indexterm"></a><a id="id-1.6.12.10.6.3" class="indexterm"></a><p>Планировщик запросов в <span class="productname">PostgreSQL</span>, выбирая эффективные планы запросов, полагается на статистическую информацию о содержимом таблиц. Эта статистика собирается командой <a class="link" href="sql-analyze.html" title="ANALYZE"><code class="command">ANALYZE</code></a>, которая может вызываться сама по себе или как дополнительное действие команды <code class="command">VACUUM</code>. Статистика должна быть достаточно точной, так как в противном случае неудачно выбранные планы запросов могут снизить производительность базы данных.</p><p>Демон автоочистки, если он включён, будет автоматически выполнять <code class="command">ANALYZE</code> после существенных изменений содержимого таблицы. Однако администраторы могут предпочесть выполнение <code class="command">ANALYZE</code> вручную, в частности, если известно, что производимые в таблице изменения не повлияют на статистику по <span class="quote">«<span class="quote">интересным</span>»</span> столбцам. Демон же планирует выполнение <code class="command">ANALYZE</code> в зависимости только от количества вставленных или изменённых строк; он не знает, приведут ли они к значимым изменениям статистики.</p><p>Изменение кортежей в дочерних таблицах и секциях не считается поводом для запуска анализа родительской таблицы. Если родительская таблица пуста или изменяется редко, процесс автоочистки может никогда не затронуть её и статистика иерархии наследования собираться не будет. Поэтому необходимо выполнять <code class="command">ANALYZE</code> для родительской таблицы вручную, чтобы поддерживать статистику в актуальном состоянии.</p><p>Как и процедура очистки для высвобождения пространства, частое обновление статистики полезнее для интенсивно изменяемых таблиц, нежели для тех таблиц, которые изменяются редко. Однако даже в случае часто изменяемой таблицы обновление статистики может не требоваться, если статистическое распределение данных меняется слабо. Как правило, достаточно оценить, насколько меняются максимальное и минимальное значения в столбцах таблицы. Например, максимальное значение в столбце <code class="type">timestamp</code>, хранящем время изменения строки, будет постоянно увеличиваться по мере добавления и изменения строк; для такого столбца может потребоваться более частое обновление статистики, чем, к примеру, для столбца, содержащего адреса страниц (URL), которые запрашивались с сайта. Столбец с URL-адресами может меняться столь же часто, однако статистическое распределение его значений, вероятно, будет изменяться относительно медленно.</p><p>Команду <code class="command">ANALYZE</code> можно выполнять для отдельных таблиц и даже просто для отдельных столбцов таблицы, поэтому, если того требует приложение, одни статистические данные можно обновлять чаще, чем другие. Однако на практике обычно лучше просто анализировать всю базу данных, поскольку это быстрая операция, так как <code class="command">ANALYZE</code> читает не каждую отдельную строку, а статистически случайную выборку строк таблицы.</p><div class="tip"><h3 class="title">Подсказка</h3><p>Хотя индивидуальная настройка частоты <code class="command">ANALYZE</code> для отдельных столбцов может быть не очень полезной, смысл может иметь настройка детализации статистики, собираемой командой <code class="command">ANALYZE</code>. Для столбцов, которые часто используются в предложениях <code class="literal">WHERE</code>, и имеют очень неравномерное распределение данных, может потребоваться более детальная, по сравнению с другими столбцами, гистограмма данных. В таких случаях можно воспользоваться командой <code class="command">ALTER TABLE SET STATISTICS</code> или изменить значение по умолчанию параметра уровня БД <a class="xref" href="runtime-config-query.html#GUC-DEFAULT-STATISTICS-TARGET">default_statistics_target</a>.</p><p>Кроме того, по умолчанию информация об избирательности функций ограничена. Однако если вы создаёте объект статистики или индекс по выражению с вызовом функции, об этой функции будет собрана полезная статистическая информация, которая может значительно улучшить планы запросов, задействующие данный индекс.</p></div><div class="tip"><h3 class="title">Подсказка</h3><p>Демон автоочистки не выполняет команды <code class="command">ANALYZE</code> для сторонних таблиц, поскольку он не знает, как часто это следует делать. Если для получения качественных планов вашим запросам необходима статистика по сторонним таблицам, будет хорошей идеей дополнительно запускать <code class="command">ANALYZE</code> для них по подходящему расписанию.</p></div><div class="tip"><h3 class="title">Подсказка</h3><p>Демон автоочистки не выполняет команды <code class="command">ANALYZE</code> для секционированных таблиц. В иерархии наследования анализ родительской таблицы проводится, только если меняются данные в ней самой — изменения в дочерней таблице не считаются поводом для автоанализа родительской таблицы. Если для получения качественных планов вашим запросам необходима статистика по родительским таблицам, нужно периодически выполнять <code class="command">ANALYZE</code> вручную, чтобы их статистика была актуальной.</p></div></div><div class="sect2" id="VACUUM-FOR-VISIBILITY-MAP"><div class="titlepage"><div><div><h3 class="title">25.1.4. Обновление карты видимости <a href="#VACUUM-FOR-VISIBILITY-MAP" class="id_link">#</a></h3></div></div></div><p>Процедура очистки поддерживает <a class="link" href="storage-vm.html" title="73.4. Карта видимости">карты видимости</a> для каждой таблицы, позволяющие определить, в каких страницах есть только записи, заведомо видимые для всех активных транзакций (и всех будущих транзакций, пока страница не будет изменена). Это имеет два применения. Во-первых, сам процесс очистки может пропускать такие страницы при следующем запуске, поскольку на этих страницах вычищать нечего.</p><p>Во-вторых, с такими картами <span class="productname">PostgreSQL</span> может выдавать результаты некоторых запросов, используя только индекс, не обращаясь к данным таблицы. Так как индексы <span class="productname">PostgreSQL</span> не содержат информацию о видимости записей, при обычном сканировании по индексу необходимо извлечь соответствующую запись из таблицы и проверить её видимость для текущей транзакции. Поэтому при <a class="link" href="indexes-index-only-scans.html" title="11.9. Сканирование только индекса и покрывающие индексы"><em class="firstterm">сканировании только индекса</em></a>, наоборот, сначала проверяется карта видимости. Если известно, что все записи на странице видимы, то выборку из таблицы можно пропустить. Это наиболее полезно с большими наборами данных, когда благодаря карте видимости можно оптимизировать чтение с диска. Карта видимости значительно меньше таблицы, поэтому она легко помещается в кеш, даже когда объём самих страниц очень велик.</p></div><div class="sect2" id="VACUUM-FOR-WRAPAROUND"><div class="titlepage"><div><div><h3 class="title">25.1.5. Предотвращение ошибок из-за зацикливания счётчика транзакций <a href="#VACUUM-FOR-WRAPAROUND" class="id_link">#</a></h3></div></div></div><a id="id-1.6.12.10.8.2" class="indexterm"></a><a id="id-1.6.12.10.8.3" class="indexterm"></a><p>В <span class="productname">PostgreSQL</span> семантика транзакций <a class="link" href="mvcc-intro.html" title="13.1. Введение">MVCC</a> зависит от возможности сравнения номеров идентификаторов транзакций (<acronym class="acronym">XID</acronym>): версия строки, у которой XID добавившей её транзакции больше, чем XID текущей транзакции, относится <span class="quote">«<span class="quote">к будущему</span>»</span> и не должна быть видна в текущей транзакции. Однако поскольку идентификаторы транзакций имеют ограниченный размер (32 бита), кластер, работающий долгое время (более 4 миллиардов транзакций) столкнётся с <em class="firstterm">зацикливанием идентификаторов транзакций</em>: счётчик XID прокрутится до нуля, и внезапно транзакции, которые относились к прошлому, окажутся в будущем — это означает, что их результаты станут невидимыми. Одним словом, это катастрофическая потеря данных. (На самом деле данные никуда не пропадают, однако если вы не можете их получить, то это слабое утешение.) Для того чтобы этого избежать, необходимо выполнять очистку для каждой таблицы в каждой базе данных как минимум единожды на два миллиарда транзакций.</p><p>Периодическое выполнение очистки решает эту проблему, потому что процедура <code class="command">VACUUM</code> помечает строки как <span class="emphasis"><em>замороженные</em></span>, указывая, что они были вставлены транзакцией, зафиксированной достаточно давно, так что эффект добавляющей транзакции с точки зрения MVCC определённо будет виден во всех текущих и будущих транзакциях. Обычные значения XID сравниваются по модулю 2<sup>32</sup>. Это означает, что для каждого обычного XID существуют два миллиарда значений XID, которые <span class="quote">«<span class="quote">старше</span>»</span> него, и два миллиарда значений, которые <span class="quote">«<span class="quote">младше</span>»</span> него; другими словами, пространство значений XID циклично и не имеет конечной точки. Следовательно, как только создаётся версия строки с обычным XID, для следующих двух миллиардов транзакций эта версия строки оказывается <span class="quote">«<span class="quote">в прошлом</span>»</span>, неважно о каком значении обычного XID идет речь. Если после двух миллиардов транзакций эта версия строки всё ещё существует, она внезапно окажется в будущем. Для того чтобы это предотвратить, в какой-то момент значение XID для старых версий строк должно быть заменено на <code class="literal">FrozenTransactionId</code> (заморожено) до того, как будет достигнута граница в два миллиарда транзакций. После получения этого особенного XID для всех обычных транзакций эти версии строк будут относиться <span class="quote">«<span class="quote">к прошлому</span>»</span>, независимо от зацикливания, и, таким образом, эти версии строк будут действительны до момента их удаления, когда бы это ни произошло.</p><div class="note"><h3 class="title">Примечание</h3><p>В версиях <span class="productname">PostgreSQL</span> до 9.4 замораживание было реализовано как замена XID добавления строки специальным идентификатором <code class="literal">FrozenTransactionId</code>, который можно было увидеть в системной колонке <code class="structname">xmin</code> данной строки. В новых версиях просто устанавливается битовый флаг, а исходный <code class="structname">xmin</code> строки сохраняется для возможного расследования в будущем. Однако строки с <code class="structname">xmin</code>, равным <code class="literal">FrozenTransactionId</code> (2), можно по-прежнему встретить в базах данных, обновлённых (с применением <span class="application">pg_upgrade</span>) с версий до 9.4.</p><p>Также системные каталоги могут содержать строки со значением <code class="structname">xmin</code>, равным <code class="literal">BootstrapTransactionId</code> (1), показывающим, что они были вставлены на первом этапе <span class="application">initdb</span>. Как и <code class="literal">FrozenTransactionId</code>, этот специальный XID считается более старым, чем любой обычный XID.</p></div><p>Параметр <a class="xref" href="runtime-config-client.html#GUC-VACUUM-FREEZE-MIN-AGE">vacuum_freeze_min_age</a> определяет, насколько старым должен стать XID, чтобы строки с таким XID были заморожены. Увеличение его значения помогает избежать ненужной работы, если строки, которые могли бы быть заморожены в ближайшее время, будут изменены ещё раз, а уменьшение приводит к увеличению количества транзакций, которые могут выполниться, прежде чем потребуется очередная очистка таблицы.</p><p><code class="command">VACUUM</code> определяет, какие страницы таблицы нужно сканировать, анализируя <a class="link" href="storage-vm.html" title="73.4. Карта видимости">карту видимости</a>. Обычно при этой операции пропускаются страницы, в которых нет мёртвых версий строк, даже если в них могут быть версии строк со старыми XID. Таким образом, обычная команда <code class="command">VACUUM</code> не всегда замораживает все старые версии строк, имеющиеся в таблице. Когда это имеет место, операция <code class="command">VACUUM</code> в конце концов должна провести <em class="firstterm">агрессивную очистку</em> и заморозить все подходящие незамороженные значения XID и MXID, в том числе на полностью видимых, но не полностью замороженных страницах. На практике периодическая агрессивная очистка требуется для большинства таблиц. Когда <code class="command">VACUUM</code> будет делать это — зависит от параметра <a class="xref" href="runtime-config-client.html#GUC-VACUUM-FREEZE-TABLE-AGE">vacuum_freeze_table_age</a>: полностью видимые, но не полностью замороженные страницы будут сканироваться, если число транзакций, прошедших со времени последнего такого сканирования, оказывается больше чем <code class="varname">vacuum_freeze_table_age</code> минус <code class="varname">vacuum_freeze_min_age</code>. Если <code class="varname">vacuum_freeze_table_age</code> равно 0, <code class="command">VACUUM</code> будет применять агрессивную стратегию всегда.</p><p>Максимальное время, в течение которого таблица может обходиться без очистки, составляет два миллиарда транзакций минус значение <code class="varname">vacuum_freeze_min_age</code> с момента последней агрессивной очистки. Если бы таблица не подвергалась очистке дольше, была бы возможна потеря данных. Чтобы гарантировать, что это не произойдёт, для любой таблицы, которая может содержать значения XID старше, чем возраст, указанный в конфигурационном параметре <a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-FREEZE-MAX-AGE">autovacuum_freeze_max_age</a>, вызывается автоочистка. (Это случится, даже если автоочистка отключена.)</p><p>Это означает, что если очистка таблицы не вызывается другим способом, то автоочистка для неё будет вызываться приблизительно через каждые <code class="varname">autovacuum_freeze_max_age</code> минус <code class="varname">vacuum_freeze_min_age</code> транзакций. Для таблиц, очищаемых регулярно для высвобождения пространства, это неактуально. В то же время статичные таблицы (включая таблицы, в которых данные вставляются, но не изменяются и не удаляются) не нуждаются в очистке для высвобождения пространства, поэтому для очень больших статичных таблиц имеет смысл увеличить интервал между вынужденными запусками автоочистки. Очевидно, это можно сделать, либо увеличив <code class="varname">autovacuum_freeze_max_age</code>, либо уменьшив <code class="varname">vacuum_freeze_min_age</code>.</p><p>Фактический максимум для <code class="varname">vacuum_freeze_table_age</code> составляет 0.95 * <code class="varname">autovacuum_freeze_max_age</code>; большее значение будет ограничено этим пределом. Значение, превышающее <code class="varname">autovacuum_freeze_max_age</code>, не имело бы смысла, поскольку по достижении этого значения в любом случае вызывалась бы автоочистка для предотвращения зацикливания, а коэффициент 0.95 оставляет немного времени для того, чтобы запустить команду <code class="command">VACUUM</code> вручную до того, как это произойдёт. Как правило, установленное значение <code class="command">vacuum_freeze_table_age</code> должно быть несколько меньше <code class="varname">autovacuum_freeze_max_age</code>, чтобы оставленный промежуток был достаточен для выполнения в этом окне <code class="command">VACUUM</code> по расписанию или автоочистки, управляемой обычной активностью операций удаления и изменения. Если это значение будет слишком близким к максимуму, автоочистка для предотвращения зацикливания будет выполняться, даже если таблица только что была очищена для высвобождения пространства, в то же время при небольшом значении будет чаще производиться агрессивная очистка.</p><p>Единственный минус увеличения <code class="varname">autovacuum_freeze_max_age</code> (и <code class="varname">vacuum_freeze_table_age</code> с ним) заключается в том, что подкаталоги <code class="filename">pg_xact</code> и <code class="filename">pg_commit_ts</code> в кластере баз данных будут занимать больше места, поскольку в них нужно будет хранить статус и (при включённом <code class="varname">track_commit_timestamp</code>) время фиксации всех транзакций вплоть до горизонта <code class="varname">autovacuum_freeze_max_age</code>. Для статуса фиксации используется по два бита на транзакцию, поэтому если в <code class="varname">autovacuum_freeze_max_age</code> установлено максимально допустимое значение в два миллиарда, то размер <code class="filename">pg_xact</code> может составить примерно половину гигабайта, а <code class="filename">pg_commit_ts</code> примерно 20 ГБ. Если по сравнению с объёмом вашей базы данных этот объём незначителен, тогда рекомендуется установить для <code class="varname">autovacuum_freeze_max_age</code> максимально допустимое значение. В противном случае установите значение этого параметра в зависимости от объёма, который вы готовы выделить для <code class="filename">pg_xact</code> и <code class="filename">pg_commit_ts</code>. (Значению по умолчанию, 200 миллионам транзакций, соответствует приблизительно 50 МБ в <code class="filename">pg_xact</code> и около 2 ГБ в <code class="filename">pg_commit_ts</code>.)</p><p>Уменьшение значения <code class="varname">vacuum_freeze_min_age</code>, с другой стороны, чревато тем, что команда <code class="command">VACUUM</code> может выполнять бесполезную работу: замораживание версии строки — пустая трата времени, если эта строка будет вскоре изменена (и в результате получит новый XID). Поэтому значение этого параметра должно быть достаточно большим для того, чтобы строки не замораживались, пока их последующее изменение не станет маловероятным.</p><p>Для отслеживания возраста самых старых незамороженных значений XID в базе данных команда <code class="command">VACUUM</code> сохраняет статистику по XID в системных таблицах <code class="structname">pg_class</code> и <code class="structname">pg_database</code>. В частности, столбец <code class="structfield">relfrozenxid</code> в записи для определённой таблицы в <code class="structname">pg_class</code> содержит самое старое оставшееся незамороженное значение XID на конец последней операции <code class="command">VACUUM</code>, которая увеличила значение <code class="structfield">relfrozenxid</code> (обычно это последняя операция агрессивной очистки). Аналогично столбец <code class="structfield">datfrozenxid</code> в записи для базы данных в <code class="structname">pg_database</code> представляет нижнюю границу обычных значений XID, встречающихся в этой базе, — он просто хранит минимальное из всех значений <code class="structfield">relfrozenxid</code> для таблиц этой базы. Эту информацию удобно получать с помощью таких запросов: </p><pre class="programlisting">SELECT c.oid::regclass as table_name,
       greatest(age(c.relfrozenxid),age(t.relfrozenxid)) as age
FROM pg_class c
LEFT JOIN pg_class t ON c.reltoastrelid = t.oid
WHERE c.relkind IN ('r', 'm');

SELECT datname, age(datfrozenxid) FROM pg_database;</pre><p> Столбец <code class="literal">age</code> показывает количество транзакций от граничного значения XID до XID текущей транзакции.</p><div class="tip"><h3 class="title">Подсказка</h3><p>Если для команды <code class="command">VACUUM</code> указан параметр <code class="literal">VERBOSE</code>, <code class="command">VACUUM</code> выводит различную статистику по таблице, в том числе информацию об увеличении значений <code class="structfield">relfrozenxid</code> и <code class="structfield">relminmxid</code>, а также о количестве новых замороженных страниц. Те же сведения вносятся в журнал сервера, когда в него записываются сообщения об операции <code class="command">VACUUM</code>, выполненной процессом автоочистки (этим управляет параметр <a class="xref" href="runtime-config-logging.html#GUC-LOG-AUTOVACUUM-MIN-DURATION">log_autovacuum_min_duration</a>).</p></div><p>Обычно <code class="command">VACUUM</code> сканирует только те страницы, которые изменялись после последней очистки, однако <code class="structfield">relfrozenxid</code> может увеличиться только при сканировании всех страниц таблицы, включая те, что могут содержать незамороженные XID. Это происходит, когда возраст <code class="structfield">relfrozenxid</code> превышает <code class="varname">vacuum_freeze_table_age</code> транзакций, когда <code class="command">VACUUM</code> вызывается с указанием <code class="literal">FREEZE</code>, или когда оказывается, что очистку для удаления мёртвых версий строк нужно провести во всех ещё не замороженных страницах. Когда <code class="command">VACUUM</code> сканирует в таблице каждую ещё не полностью замороженную страницу, значение <code class="literal">age(relfrozenxid)</code> в результате должно стать немного больше, чем установленное значение <code class="varname">vacuum_freeze_min_age</code> (больше на число транзакций, начатых с момента запуска <code class="command">VACUUM</code>). <code class="command">VACUUM</code> установит для <code class="structfield">relfrozenxid</code> значение, равное самому старому XID, остающемуся в таблице, поэтому возможно, что окончательное значение будет новее, чем требовалось. Если по достижении <code class="varname">autovacuum_freeze_max_age</code> для таблицы ни разу не будет увеличен <code class="structfield">relfrozenxid</code>, в скором времени для неё будет принудительно запущена автоочистка.</p><p>Если по какой-либо причине автоочистка не может вычистить старые значения XID из таблицы, система начинает выдавать предупреждающие сообщения, подобные приведённому ниже, когда самое старое значение XID в базе данных оказывается в сорока миллионах транзакций от точки зацикливания: </p><pre class="programlisting">ПРЕДУПРЕЖДЕНИЕ:  база данных "mydb" должна быть очищена (предельное число транзакций: 39985967)
ПОДСКАЗКА:  Во избежание отключения базы данных выполните очистку (VACUUM) всей базы.</pre><p> (Проблему можно решить, как предлагает подсказка, запустив <code class="command">VACUUM</code> вручную; однако учтите, что выполнять <code class="command">VACUUM</code> должен суперпользователь, в противном случае эта процедура не сможет обработать системные каталоги и, следовательно, не сможет увеличить значение <code class="structfield">datfrozenxid</code> для базы данных.) Если эти предупреждения игнорировать, система отключится и не будет начинать никаких транзакций, как только до точки зацикливания останется менее трёх миллионов транзакций: </p><pre class="programlisting">ОШИБКА:  база данных не принимает команды во избежание потери данных из-за зацикливания в БД "mydb"
ПОДСКАЗКА:  Остановите управляющий процесс (postmaster) и выполните очистку (VACUUM) базы данных в однопользовательском режиме.</pre><p> В этом состоянии любые уже выполняемые транзакции могут продолжаться, но могут быть запущены лишь транзакции только для чтения. Операции, изменяющие записи базы данных или удаляющие отношения, завершатся ошибкой. Команду <code class="command">VACUUM</code> по-прежнему можно запускать в обычном режиме. Вопреки тому, что говорится в подсказке, нет необходимости или даже нежелательно останавливать управляющий процесс postmaster или входить в однопользовательский режим, чтобы восстановить нормальную работу. Вместо этого выполните следующие действия: </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">Разберите старые подготовленные транзакции. Их можно найти, проверив <a class="link" href="view-pg-prepared-xacts.html" title="54.16. pg_prepared_xacts">pg_prepared_xacts</a> на наличие строк с большим значением <code class="literal">age(transactionid)</code>. Такие транзакции следует фиксировать или отменять.</li><li class="listitem">Завершите длительные открытые транзакции. Их можно найти, проверив <a class="link" href="monitoring-stats.html#MONITORING-PG-STAT-ACTIVITY-VIEW" title="28.2.3. pg_stat_activity">pg_stat_activity</a> на наличие строк с большим значением <code class="literal">age(backend_xid)</code> или <code class="literal">age(backend_xmin)</code>. Такие транзакции следует фиксировать или отменять, либо можно завершить сеанс с помощью <code class="literal">pg_terminate_backend</code>.</li><li class="listitem">Удалите все старые слоты репликации. Используйте <a class="link" href="monitoring-stats.html#MONITORING-PG-STAT-REPLICATION-VIEW" title="28.2.4. pg_stat_replication">pg_stat_replication</a>, чтобы найти слоты с большим значением <code class="literal">age(xmin)</code> или <code class="literal">age(catalog_xmin)</code>. Во многих случаях такие слоты создавались для репликации на серверы, которых уже нет или которые давно не работают. Если удалить слот для сервера, который всё ещё существует и может по-прежнему пытаться подключиться к этому слоту, возможно, эту реплику придётся пересоздать.</li><li class="listitem">Выполните <code class="command">VACUUM</code> в целевой базе данных. Проще всего использовать <code class="literal">VACUUM</code> для всей базы данных. Чтобы сократить время выполнения, также можно вручную выполнить команды <code class="command">VACUUM</code> для таблиц с самым старым <code class="structfield">relminxid</code>. Не используйте <code class="literal">VACUUM FULL</code> в этом сценарии, поскольку для него требуется XID и, следовательно, произойдёт сбой, за исключением режима суперпользователя, где напротив будет обрабатываться XID и, таким образом, увеличится риск зацикливания счётчика идентификатора транзакции. Не используйте <code class="literal">VACUUM FREEZE</code>, поскольку при этом выполнится объём работы, который будет больше минимально необходимого для восстановления нормального функционирования.</li><li class="listitem">После восстановления нормальной работы проверьте, что автоочистка правильно настроена в целевой базе данных, чтобы избежать проблем в будущем.</li></ol></div><div class="note"><h3 class="title">Примечание</h3><p>В более ранних версиях иногда было необходимо останавливать процесс postmaster и выполнять <code class="command">VACUUM</code> для базы данных в однопользовательском режиме. В типичных сценариях в этом больше нет необходимости, поэтому по возможности следует избегать этих действий, поскольку они могут привести к сбою системы и повышают риски, так как отключают защиту от зацикливания идентификатора транзакции, предназначенную для предотвращения потери данных. Использовать однопользовательский режим в этом сценарии следует лишь при желании выполнить <code class="command">TRUNCATE</code> или <code class="command">DROP</code> ненужных таблиц, чтобы избежать необходимости выполнять для них <code class="command">VACUUM</code>. Резерв в три миллиона транзакций позволяет администратору это сделать. За подробной информацией об использовании однопользовательского режима обратитесь к странице справки по <a class="xref" href="app-postgres.html" title="postgres"><span class="refentrytitle"><span class="application">postgres</span></span></a>.</p></div><div class="sect3" id="VACUUM-FOR-MULTIXACT-WRAPAROUND"><div class="titlepage"><div><div><h4 class="title">25.1.5.1. Мультитранзакции и зацикливание <a href="#VACUUM-FOR-MULTIXACT-WRAPAROUND" class="id_link">#</a></h4></div></div></div><a id="id-1.6.12.10.8.19.2" class="indexterm"></a><a id="id-1.6.12.10.8.19.3" class="indexterm"></a><p><em class="firstterm">Идентификаторы мультитранзакций</em> используются для поддержки блокировки строк несколькими транзакциями одновременно. Поскольку в заголовке строки есть только ограниченное пространство для хранения информации о блокировках, в нём указывается <span class="quote">«<span class="quote">идентификатор множественной транзакции</span>»</span>, или идентификатор мультитранзакции для краткости, когда строку блокируют одновременно несколько транзакций. Информация о том, какие именно идентификаторы транзакций относятся к определённой мультитранзакции, хранится отдельно в подкаталоге <code class="filename">pg_multixact</code>, а в поле <code class="structfield">xmax</code> в заголовке строки сохраняется только идентификатор мультитранзакции. Как и идентификаторы транзакций, идентификаторы мультитранзакций исполнены в виде 32-разрядного счётчика и хранятся аналогично, что требует аккуратного управления их возрастом, очисткой хранилища и предотвращением зацикливаний. Существует отдельная область, в которой содержится список членов каждой мультитранзакции, где счётчики также 32-битные и требуют должного контроля.</p><p>Когда <code class="command">VACUUM</code> сканирует какую-либо часть таблицы, каждый идентификатор мультитранзакции старее чем <a class="xref" href="runtime-config-client.html#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE">vacuum_multixact_freeze_min_age</a> заменяется другим значением, которое может быть нулевым, идентификатором одиночной транзакции или новым идентификатором мультитранзакции. Для каждой таблицы в <code class="structname">pg_class</code>.<code class="structfield">relminmxid</code> хранится самый старый возможный идентификатор мультитранзакции, всё ещё задействованный в какой-либо строке этой таблицы. Если это значение оказывается старее <a class="xref" href="runtime-config-client.html#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE">vacuum_multixact_freeze_table_age</a>, выполняется агрессивная очистка. Как рассказывалось в предыдущем разделе, при агрессивной очистке будут пропускаться только те страницы, которые считаются полностью замороженными. Узнать возраст <code class="structname">pg_class</code>.<code class="structfield">relminmxid</code> можно с помощью функции <code class="function">mxid_age()</code>.</p><p>Благодаря агрессивным операциям <code class="command">VACUUM</code>, вне зависимости от их причины, <span class="emphasis"><em>гарантируется</em></span> увеличение значения <code class="structfield">relminmxid</code> для таблицы. В конце концов, по мере сканирования всех таблиц во всех базах данных и увеличения их старейших значений мультитранзакций, информация о старых мультитранзакциях может быть удалена с диска.</p><p>В качестве меры защиты, агрессивное сканирование с целью очистки будет происходить для любой таблицы, возраст мультитранзакций которой больше, чем <a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE">autovacuum_multixact_freeze_max_age</a>. Агрессивное сканирование также будет выполняться чаще со всеми таблицами, начиная с имеющих старейшие мультитранзакции, если объём занятой области членов мультитранзакций превышает 2GB. Эти два варианта агрессивного сканирования осуществляются, даже если процесс автоочистки отключён.</p><p>Как и в случае с XID, если при автоочистке не удаётся удалить старые MXID из таблицы, система начнет выдавать сообщения с предупреждением, когда самые старые MXID базы данных достигнут сорока миллионов транзакций от точки зацикливания. И снова, как и в случае с XID, если эти предупреждения игнорировать, система перестанет генерировать новые MXID, если до точки зацикливания останется менее трёх миллионов транзакций.</p><p>Когда заканчиваются MXID, нормальную работу можно восстановить практически так же, как когда заканчиваются XID. Выполните те же действия, что и в предыдущем разделе, но со следующими отличиями: </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">Запущенные транзакции и подготовленные транзакции можно игнорировать, если они точно не могут появиться в мультитранзакции.</li><li class="listitem">Информация о MXID не отображается напрямую в системных представлениях, таких как <code class="literal">pg_stat_activity</code>, однако поиск старых XID по-прежнему позволяет эффективно определить, какие транзакции вызывают проблемы с зацикливанием MXID.</li><li class="listitem">Когда заканчиваются XID, блокируются все пишущие транзакции, а когда заканчиваются MXID, блокируется только подмножество пишущих транзакций, а именно те, которые включают блокировки строк, требующие MXID.</li></ol></div></div></div><div class="sect2" id="AUTOVACUUM"><div class="titlepage"><div><div><h3 class="title">25.1.6. Демон автоочистки <a href="#AUTOVACUUM" class="id_link">#</a></h3></div></div></div><a id="id-1.6.12.10.9.2" class="indexterm"></a><p>В <span class="productname">PostgreSQL</span> имеется не обязательная, но настоятельно рекомендуемая к использованию функция, называемая <em class="firstterm">автоочисткой</em>, предназначение которой — автоматизировать выполнение команд <code class="command">VACUUM</code> и <code class="command">ANALYZE</code>. Когда автоочистка включена, она проверяет, в каких таблицах было вставлено, изменено или удалено много строк. При этих проверках используются средства сбора статистики; поэтому автоочистка будет работать, только если параметр <a class="xref" href="runtime-config-statistics.html#GUC-TRACK-COUNTS">track_counts</a> имеет значение <code class="literal">true</code>. В конфигурации по умолчанию автоочистка включена и соответствующие параметры имеют подходящие значения.</p><p><span class="quote">«<span class="quote">Демон автоочистки</span>»</span> на самом деле состоит из нескольких процессов. Существует постоянный фоновый процесс, называемый <em class="firstterm">процессом запуска автоочистки</em>, который отвечает за запуск <em class="firstterm">рабочих процессов автоочистки</em> для всех баз данных. Этот контролирующий процесс распределяет работу по времени, стараясь запускать рабочий процесс для каждой базы данных каждые <a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-NAPTIME">autovacuum_naptime</a> секунд. (Следовательно, если всего имеется <em class="replaceable"><code>N</code></em> баз данных, новый рабочий процесс будет запускаться каждые <code class="varname">autovacuum_naptime</code>/<em class="replaceable"><code>N</code></em> секунд.) Одновременно могут выполняться до <a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-MAX-WORKERS">autovacuum_max_workers</a> рабочих процессов. Если число баз данных, требующих обработки, превышает <code class="varname">autovacuum_max_workers</code>, обработка следующей базы начинается сразу по завершении первого рабочего процесса. Каждый рабочий процесс проверяет все таблицы в своей базе данных и в случае необходимости выполняет <code class="command">VACUUM</code> и/или <code class="command">ANALYZE</code>. Для отслеживания действий рабочих процессов можно установить параметр <a class="xref" href="runtime-config-logging.html#GUC-LOG-AUTOVACUUM-MIN-DURATION">log_autovacuum_min_duration</a>.</p><p>Если в течение короткого промежутка времени потребность в очистке возникает для нескольких больших таблиц, все рабочие процессы автоочистки могут продолжительное время заниматься очисткой только этих таблиц. В результате другие таблицы и базы данных будут ожидать очистки, пока не появится свободный рабочий процесс. Число рабочих процессов для одной базы не ограничивается, при этом каждый процесс старается не повторять работу, только что выполненную другими. Заметьте, что в ограничениях <a class="xref" href="runtime-config-connection.html#GUC-MAX-CONNECTIONS">max_connections</a> или <a class="xref" href="runtime-config-connection.html#GUC-SUPERUSER-RESERVED-CONNECTIONS">superuser_reserved_connections</a> число выполняющихся рабочих процессов не учитывается.</p><p>Для таблиц с <code class="structfield">relfrozenxid</code>, устаревшим более чем на <a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-FREEZE-MAX-AGE">autovacuum_freeze_max_age</a> транзакций, очистка выполняется всегда (это также применимо к таблицам, для которых максимальный порог заморозки был изменён через параметры хранения; см. ниже). В противном случае очистка таблицы производится, если количество кортежей, устаревших с момента последнего выполнения <code class="command">VACUUM</code>, превышает <span class="quote">«<span class="quote">пороговое значение очистки</span>»</span>. Пороговое значение очистки определяется как: </p><pre class="programlisting">порог очистки = базовый порог очистки + коэффициент доли для очистки * количество кортежей</pre><p> где базовый порог очистки — значение <a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-VACUUM-THRESHOLD">autovacuum_vacuum_threshold</a>, коэффициент доли — <a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-VACUUM-SCALE-FACTOR">autovacuum_vacuum_scale_factor</a>, а количество кортежей — <code class="structname">pg_class</code>.<code class="structfield">reltuples</code>.</p><p>Таблица также очищается, если число кортежей, добавленных после предыдущей очистки, превышает установленный порог очистки при добавлении, который определяется так: </p><pre class="programlisting">порог очистки при добавлении = базовый порог очистки при добавлении + коэффициент доли для очистки при добавлении * количество кортежей</pre><p> Базовый порог очистки при добавлении и коэффициент доли для очистки при добавлении определяются параметрами <a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-VACUUM-INSERT-THRESHOLD">autovacuum_vacuum_insert_threshold</a> и <a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-VACUUM-INSERT-SCALE-FACTOR">autovacuum_vacuum_insert_scale_factor</a>, соответственно. При такой очистке часть страниц таблицы могут быть помечены как <em class="firstterm">полностью видимые</em> и могут быть также заморожены кортежи, что уменьшит объём работы, которую нужно будет проделать при следующей очистке. Для таблиц, в которых выполняются в основном операции <code class="command">INSERT</code> и практически не выполняются <code class="command">UPDATE</code>/<code class="command">DELETE</code>, может иметь смысл уменьшить параметр таблицы <a class="xref" href="sql-createtable.html#RELOPTION-AUTOVACUUM-FREEZE-MIN-AGE">autovacuum_freeze_min_age</a>, так как это позволит замораживать кортежи раньше. Количество устаревших и добавленных кортежей получается от системы накопительной статистики; оно представляет собой приблизительное число, обновляемое после каждой операции <code class="command">UPDATE</code>, <code class="command">DELETE</code> и <code class="command">INSERT</code>. (Точность не гарантируется, потому что при большой нагрузке часть информации может быть потеряна.) Если значение <code class="structfield">relfrozenxid</code> для таблицы старее <code class="varname">vacuum_freeze_table_age</code> транзакций, производится агрессивная очистка с целью заморозить старые версии строк и увеличить значение <code class="structfield">relfrozenxid</code>; в противном случае сканируются только страницы, изменённые после последней очистки.</p><p>Для выполнения сбора статистики используется аналогичное условие: пороговое значение, определяемое как: </p><pre class="programlisting">порог анализа = базовый порог анализа + коэффициент доли для анализа * количество кортежей</pre><p> сравнивается с общим количеством кортежей добавленных, изменённых или удалённых после последнего выполнения <code class="command">ANALYZE</code>.</p><p>В секционированных таблицах кортежи не хранятся напрямую и, следовательно, не обрабатываются автоочисткой. (Автоочистка обрабатывает секции таблицы так же, как и другие таблицы.) К сожалению, это означает, что автоочистка не запускает <code class="command">ANALYZE</code> для секционированных таблиц, в результате чего создаются неоптимальные планы для запросов, ссылающихся на статистику секционированных таблиц. Эту проблему можно обойти, вручную запуская <code class="command">ANALYZE</code> для секционированных таблиц при их первом заполнении, а также всякий раз, когда распределение данных в их секциях существенно меняется.</p><p>Автоочистка не обрабатывает временные таблицы. Поэтому очистку и сбор статистики в них нужно производить с помощью SQL-команд в обычном сеансе.</p><p>Используемые по умолчанию пороговые значения и коэффициенты берутся из <code class="filename">postgresql.conf</code>, однако их (и многие другие параметры, управляющие автоочисткой) можно переопределить для каждой таблицы; за подробностями обратитесь к разделу <a class="xref" href="sql-createtable.html#SQL-CREATETABLE-STORAGE-PARAMETERS" title="Параметры хранения">Параметры хранения</a>. Если какие-либо значения определены через параметры хранения таблицы, при обработке этой таблицы действуют они, а в противном случае — глобальные параметры. За более подробной информацией о глобальных параметрах обратитесь к <a class="xref" href="runtime-config-autovacuum.html" title="20.10. Автоматическая очистка">Разделу 20.10</a>.</p><p>Когда выполняются несколько рабочих процессов, параметры задержки автоочистки по стоимости (см. <a class="xref" href="runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-VACUUM-COST" title="20.4.4. Задержка очистки по стоимости">Подраздел 20.4.4</a>) <span class="quote">«<span class="quote">распределяются</span>»</span> между всеми этими процессами, так что общее воздействие на систему остаётся неизменным, независимо от их числа. Однако этот алгоритм распределения нагрузки не учитывает процессы, обрабатывающие таблицы с индивидуальными значениями параметров хранения <code class="literal">autovacuum_vacuum_cost_delay</code> и <code class="literal">autovacuum_vacuum_cost_limit</code>.</p><p>Рабочие процессы автоочистки обычно не мешают выполнению других команд. Если какой-либо процесс попытается получить блокировку, конфликтующую с блокировкой <code class="literal">SHARE UPDATE EXCLUSIVE</code>, которая удерживается в ходе автоочистки, автоочистка прервётся и процесс получит нужную ему блокировку. Конфликтующие режимы блокировок отмечены в <a class="xref" href="explicit-locking.html#TABLE-LOCK-COMPATIBILITY" title="Таблица 13.2. Конфликтующие режимы блокировки">Таблице 13.2</a>. Однако если автоочистка выполняется для предотвращения зацикливания идентификаторов транзакций (т. е. описание запроса автоочистки в представлении <code class="structname">pg_stat_activity</code> заканчивается на <code class="literal">(to prevent wraparound)</code>), автоочистка не прерывается без ручного вмешательства.</p><div class="warning"><h3 class="title">Предупреждение</h3><p>При частом выполнении таких команд, как ANALYZE, которые затребуют блокировки, конфликтующие с <code class="literal">SHARE UPDATE EXCLUSIVE</code>, может получиться так, что автоочистка не будет успевать завершаться в принципе.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="maintenance.html" title="Глава 25. Регламентные задачи обслуживания базы данных">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="maintenance.html" title="Глава 25. Регламентные задачи обслуживания базы данных">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="routine-reindex.html" title="25.2. Регулярная переиндексация">След.</a></td></tr><tr><td width="40%" align="left" valign="top">Глава 25. Регламентные задачи обслуживания базы данных </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 25.2. Регулярная переиндексация</td></tr></table></div></body></html>