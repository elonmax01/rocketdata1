<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>15.3. Параллельные планы</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="when-can-parallel-query-be-used.html" title="15.2. Когда может применяться распараллеливание запросов?" /><link rel="next" href="parallel-safety.html" title="15.4. Безопасность распараллеливания" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">15.3. Параллельные планы</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="when-can-parallel-query-be-used.html" title="15.2. Когда может применяться распараллеливание запросов?">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="parallel-query.html" title="Глава 15. Параллельный запрос">Наверх</a></td><th width="60%" align="center">Глава 15. Параллельный запрос</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="parallel-safety.html" title="15.4. Безопасность распараллеливания">След.</a></td></tr></table><hr /></div><div class="sect1" id="PARALLEL-PLANS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">15.3. Параллельные планы <a href="#PARALLEL-PLANS" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="parallel-plans.html#PARALLEL-SCANS">15.3.1. Параллельные сканирования</a></span></dt><dt><span class="sect2"><a href="parallel-plans.html#PARALLEL-JOINS">15.3.2. Параллельные соединения</a></span></dt><dt><span class="sect2"><a href="parallel-plans.html#PARALLEL-AGGREGATION">15.3.3. Параллельное агрегирование</a></span></dt><dt><span class="sect2"><a href="parallel-plans.html#PARALLEL-APPEND">15.3.4. Параллельное присоединение</a></span></dt><dt><span class="sect2"><a href="parallel-plans.html#PARALLEL-PLAN-TIPS">15.3.5. Советы по параллельным планам</a></span></dt></dl></div><p>Так как каждый рабочий процесс выполняет параллельную часть плана до конца, нельзя просто взять обычный план запроса и запустить его в нескольких исполнителях. В этом случае все исполнители выдавали бы полные копии выходного набора результатов, так что запрос выполнится не быстрее, чем обычно, а его результаты могут быть некорректными. Вместо этого параллельной частью плана должно быть то, что для оптимизатора представляется как <em class="firstterm">частичный план</em>; то есть такой план, при выполнении которого в отдельном процессе будет получено только подмножество выходных строк, а каждая требующаяся строка результата будет гарантированно выдана ровно одним из сотрудничающих процессов. Вообще говоря, это означает, что сканирование нижележащей таблицы запроса должно проводиться с учётом распараллеливания.</p><div class="sect2" id="PARALLEL-SCANS"><div class="titlepage"><div><div><h3 class="title">15.3.1. Параллельные сканирования <a href="#PARALLEL-SCANS" class="id_link">#</a></h3></div></div></div><p>В настоящее время поддерживаются следующие виды сканирований таблицы, рассчитанные на параллельное выполнение. </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>При <span class="emphasis"><em>параллельном последовательном сканировании</em></span> блоки таблицы будут разделены на диапазоны, распределяемые между взаимодействующими процессами. Каждый рабочий процесс сначала завершает сканирование полученного диапазона блоков, а затем запрашивает следующий диапазон.</p></li><li class="listitem"><p>При <span class="emphasis"><em>параллельном сканировании кучи по битовой карте</em></span> один процесс выбирается на роль ведущего. Этот процесс производит сканирование одного или нескольких индексов и строит битовую карту, показывающую, какие блоки таблицы нужно посетить. Затем эти блоки разделяются между взаимодействующими процессами как при параллельном последовательном сканировании. Другими словами, сканирование кучи выполняется в параллельном режиме, а сканирование нижележащего индекса — нет.</p></li><li class="listitem"><p>При <span class="emphasis"><em>параллельном сканировании по индексу</em></span> или <span class="emphasis"><em>параллельном сканировании только индекса</em></span> взаимодействующие процессы читают данные из индекса по очереди. В настоящее время параллельное сканирование индекса поддерживается только для индексов-B-деревьев. Каждый процесс будет выбирать один блок индекса с тем, чтобы просканировать и вернуть все кортежи, на которые он ссылается; другие процессы могут в то же время возвращать кортежи для другого блока индекса. Результаты параллельного сканирования B-дерева каждый рабочий процесс возвращает в отсортированном порядке.</p></li></ul></div><p> В будущем может появиться поддержка параллельного выполнения и для других вариантов сканирования, например, сканирования индексов, отличных от B-дерева.</p></div><div class="sect2" id="PARALLEL-JOINS"><div class="titlepage"><div><div><h3 class="title">15.3.2. Параллельные соединения <a href="#PARALLEL-JOINS" class="id_link">#</a></h3></div></div></div><p>Как и в непараллельном плане, целевая таблица может соединяться с одной или несколькими другими таблицами с использованием вложенных циклов, соединения по хешу или соединения слиянием. Внутренней стороной соединения может быть любой вид непараллельного плана, который в остальном поддерживается планировщиком, при условии, что он безопасен для выполнения в параллельном исполнителе. Внутренней стороной может быть и параллельный план, в зависимости от типа соединения.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>В <span class="emphasis"><em>соединении с вложенным циклом</em></span> внутренняя сторона всегда непараллельная. Хотя она выполняется полностью, это эффективно, если с внутренней стороны производится сканирование индекса, так как внешние кортежи, а значит и циклы, находящие значения в индексе, разделяются по параллельным процессам.</p></li><li class="listitem"><p>При <span class="emphasis"><em>соединении слиянием</em></span> с внутренней стороны всегда будет непараллельный план и, таким образом, он будет выполняться полностью. Это может быть неэффективно, особенно если потребуется произвести сортировку, так как работа и конечные данные будут повторяться в каждом параллельном процессе.</p></li><li class="listitem"><p>При <span class="emphasis"><em>соединении по хешу</em></span> (непараллельном, без префикса «parallel») внутреннее соединение выполняется полностью в каждом параллельном процессе, и в результате они строят одинаковые копии хеш-таблицы. Это может быть неэффективно при большой хеш-таблице или дорогостоящем плане. В <span class="emphasis"><em>параллельном соединении по хешу</em></span> с внутренней стороны выполняется <span class="emphasis"><em>параллельное хеширование</em></span>, при котором работа по построению общей хеш-таблицы разделяется между параллельными процессами.</p></li></ul></div></div><div class="sect2" id="PARALLEL-AGGREGATION"><div class="titlepage"><div><div><h3 class="title">15.3.3. Параллельное агрегирование <a href="#PARALLEL-AGGREGATION" class="id_link">#</a></h3></div></div></div><p><span class="productname">PostgreSQL</span> поддерживает параллельное агрегирование, выполняя агрегирование в два этапа. Сначала каждый процесс, задействованный в параллельной части запроса, выполняет шаг агрегирования, выдавая частичный результат для каждой известной ему группы. В плане это отражает узел <code class="literal">Partial Aggregate</code>. Затем эти промежуточные результаты передаются ведущему через узел <code class="literal">Gather</code> или <code class="literal">Gather Merge</code>. И наконец, ведущий заново агрегирует результаты всех рабочих процессов, чтобы получить окончательный результат. Это отражает в плане узел <code class="literal">Finalize Aggregate</code>.</p><p>Так как узел <code class="literal">Finalize Aggregate</code> выполняется в ведущем процессе, запросы, выдающие достаточно большое количество групп по отношению к числу входных строк, будут расцениваться планировщиком как менее предпочтительные. Например, в худшем случае количество групп, выявленных узлом <code class="literal">Finalize Aggregate</code>, может равняться числу входных строк, обработанных всеми рабочими процессами на этапе <code class="literal">Partial Aggregate</code>. Очевидно, что в такой ситуации использование параллельного агрегирования не даст никакого выигрыша производительности. Планировщик запросов учитывает это в процессе планирования, так что выбор параллельного агрегирования в подобных случаях очень маловероятен.</p><p>Параллельное агрегирование поддерживается не во всех случаях. Чтобы оно поддерживалось, агрегатная функция должна быть <a class="link" href="parallel-safety.html" title="15.4. Безопасность распараллеливания">безопасной</a> для распараллеливания и должна иметь комбинирующую функцию. Если переходное состояние агрегатной функции имеет тип <code class="literal">internal</code>, она должна также иметь функции сериализации и десериализации. За подробностями обратитесь к <a class="xref" href="sql-createaggregate.html" title="CREATE AGGREGATE"><span class="refentrytitle">CREATE AGGREGATE</span></a>. Параллельное агрегирование не поддерживается, если вызов агрегатной функции содержит предложение <code class="literal">DISTINCT</code> или <code class="literal">ORDER BY</code>. Также оно не поддерживается для сортирующих агрегатов или когда запрос включает предложение <code class="literal">GROUPING SETS</code>. Оно может использоваться только когда все соединения, задействованные в запросе, также входят в параллельную часть плана.</p></div><div class="sect2" id="PARALLEL-APPEND"><div class="titlepage"><div><div><h3 class="title">15.3.4. Параллельное присоединение <a href="#PARALLEL-APPEND" class="id_link">#</a></h3></div></div></div><p>Когда требуется объединить строки из различных источников в единый набор результатов, в <span class="productname">PostgreSQL</span> используются узлы плана <code class="literal">Append</code> или <code class="literal">MergeAppend</code>. Это обычно происходит при реализации <code class="literal">UNION ALL</code> или при сканировании секционированной таблицы. Данные узлы могут применяться как в параллельных, так и в обычных планах. Однако в параллельных планах планировщик может заменить их на узел <code class="literal">Parallel Append</code>.</p><p>Если в параллельном плане используется узел <code class="literal">Append</code>, все задействованные процессы выполняют очередной дочерний план совместно, пока он не будет завершён, и лишь затем, примерно в одно время, переходят к выполнению следующего дочернего плана. Когда же применяется <code class="literal">Parallel Append</code>, исполнитель старается равномерно распределить между задействованными процессами все дочерние планы, чтобы они выполнялись параллельно. Это позволяет избежать конкуренции и не тратить ресурсы на запуск дочернего плана для тех процессов, которые не будут его выполнять.</p><p>Кроме того, в отличие от обычного узла <code class="literal">Append</code>, использование которого внутри параллельного плана допускается только для частичных дочерних планов, узел <code class="literal">Parallel Append</code> может обрабатывать как частичные, так и не частичные дочерние планы. Для сканирования не частичного плана будет использоваться только один процесс, поскольку его многократное сканирование приведёт лишь к дублированию результатов. Таким образом, для планов, объединяющих несколько наборов результатов, можно достичь параллельного выполнения на высоком уровне, даже когда эффективные частичные планы отсутствуют. Например, рассмотрим запрос к секционированной таблице, который может быть эффективно реализован только с помощью индекса, не поддерживающего параллельное сканирование. Планировщик может выбрать узел <code class="literal">Parallel Append</code> для параллельного объединения нескольких обычных планов <code class="literal">Index Scan</code>; в этом случае каждое сканирование индекса будет выполняться до полного завершения одним процессом, но при этом разные сканирования будут осуществляться параллельно.</p><p>Отключить данную функциональность можно с помощью <a class="xref" href="runtime-config-query.html#GUC-ENABLE-PARALLEL-APPEND">enable_parallel_append</a>.</p></div><div class="sect2" id="PARALLEL-PLAN-TIPS"><div class="titlepage"><div><div><h3 class="title">15.3.5. Советы по параллельным планам <a href="#PARALLEL-PLAN-TIPS" class="id_link">#</a></h3></div></div></div><p>Если для запроса ожидается параллельный план, но такой план не строится, можно попытаться уменьшить <a class="xref" href="runtime-config-query.html#GUC-PARALLEL-SETUP-COST">parallel_setup_cost</a> или <a class="xref" href="runtime-config-query.html#GUC-PARALLEL-TUPLE-COST">parallel_tuple_cost</a>. Разумеется, этот план может оказаться медленнее последовательного плана, предпочитаемого планировщиком, но не всегда. Если вы не получаете параллельный план даже с очень маленькими значениями этих параметров (например, сбросив оба их в ноль), может быть какая-то веская причина тому, что планировщик запросов не может построить параллельный план для вашего запроса. За информацией о возможных причинах обратитесь к <a class="xref" href="when-can-parallel-query-be-used.html" title="15.2. Когда может применяться распараллеливание запросов?">Разделу 15.2</a> и <a class="xref" href="parallel-safety.html" title="15.4. Безопасность распараллеливания">Разделу 15.4</a>.</p><p>Когда выполняется параллельный план, вы можете применить <code class="literal">EXPLAIN (ANALYZE, VERBOSE)</code>, чтобы просмотреть статистику по каждому узлу плана в разрезе рабочих процессов. Это может помочь определить, равномерно ли распределяется работа между всеми узлами плана, и на более общем уровне понимать характеристики производительности плана.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="when-can-parallel-query-be-used.html" title="15.2. Когда может применяться распараллеливание запросов?">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="parallel-query.html" title="Глава 15. Параллельный запрос">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="parallel-safety.html" title="15.4. Безопасность распараллеливания">След.</a></td></tr><tr><td width="40%" align="left" valign="top">15.2. Когда может применяться распараллеливание запросов? </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 15.4. Безопасность распараллеливания</td></tr></table></div></body></html>