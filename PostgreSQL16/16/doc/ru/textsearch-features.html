<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>12.4. Дополнительные возможности</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="textsearch-controls.html" title="12.3. Управление текстовым поиском" /><link rel="next" href="textsearch-parsers.html" title="12.5. Анализаторы" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">12.4. Дополнительные возможности</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="textsearch-controls.html" title="12.3. Управление текстовым поиском">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="textsearch.html" title="Глава 12. Полнотекстовый поиск">Наверх</a></td><th width="60%" align="center">Глава 12. Полнотекстовый поиск</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="textsearch-parsers.html" title="12.5. Анализаторы">След.</a></td></tr></table><hr /></div><div class="sect1" id="TEXTSEARCH-FEATURES"><div class="titlepage"><div><div><h2 class="title" style="clear: both">12.4. Дополнительные возможности <a href="#TEXTSEARCH-FEATURES" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="textsearch-features.html#TEXTSEARCH-MANIPULATE-TSVECTOR">12.4.1. Обработка документов</a></span></dt><dt><span class="sect2"><a href="textsearch-features.html#TEXTSEARCH-MANIPULATE-TSQUERY">12.4.2. Обработка запросов</a></span></dt><dt><span class="sect2"><a href="textsearch-features.html#TEXTSEARCH-UPDATE-TRIGGERS">12.4.3. Триггеры для автоматического обновления</a></span></dt><dt><span class="sect2"><a href="textsearch-features.html#TEXTSEARCH-STATISTICS">12.4.4. Сбор статистики по документу</a></span></dt></dl></div><p>В этом разделе описываются дополнительные функции и операторы, которые могут быть полезны при поиске текста.</p><div class="sect2" id="TEXTSEARCH-MANIPULATE-TSVECTOR"><div class="titlepage"><div><div><h3 class="title">12.4.1. Обработка документов <a href="#TEXTSEARCH-MANIPULATE-TSVECTOR" class="id_link">#</a></h3></div></div></div><p>В <a class="xref" href="textsearch-controls.html#TEXTSEARCH-PARSING-DOCUMENTS" title="12.3.1. Разбор документов">Подразделе 12.3.1</a> показывалось, как обычные текстовые документы можно преобразовать в значения <code class="type">tsvector</code>. <span class="productname">PostgreSQL</span> предлагает также набор функций и операторов для обработки документов, уже представленных в формате <code class="type">tsvector</code>.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
     <a id="id-1.5.11.7.3.3.1.1.1" class="indexterm"></a>

      <code class="literal"><code class="type">tsvector</code> || <code class="type">tsvector</code></code>
     </span></dt><dd><p>Оператор конкатенации значений <code class="type">tsvector</code> возвращает вектор, объединяющий лексемы и позиционную информацию двух векторов, переданных ему в аргументах. В полученном результате сохраняются позиции и метки весов. При этом позиции в векторе справа сдвигаются на максимальное значение позиции в векторе слева, что почти равносильно применению <code class="function">to_tsvector</code> к результату конкатенации двух исходных строк документов. (Почти, потому что стоп-слова, исключаемые в конце левого аргумента, при конкатенации исходных строк влияют на позиции лексем в правой части, а при конкатенации <code class="type">tsvector</code> — нет.)</p><p>Преимущество же конкатенации документов в векторной форме по сравнению с конкатенацией текста до вызова <code class="function">to_tsvector</code> заключается в том, что так можно разбирать разные части документа, применяя разные конфигурации. И так как функция <code class="function">setweight</code> помечает все лексемы данного вектора одинаково, разбирать текст и выполнять <code class="function">setweight</code> нужно до объединения разных частей документа с подразумеваемым разным весом.</p></dd><dt><span class="term">
     <a id="id-1.5.11.7.3.3.2.1.1" class="indexterm"></a>

      <code class="literal">setweight(<em class="replaceable"><code>вектор</code></em> <code class="type">tsvector</code>, <em class="replaceable"><code>вес</code></em> <code class="type">"char"</code>) returns <code class="type">tsvector</code></code>
     </span></dt><dd><p><code class="function">setweight</code> возвращает копию входного вектора, помечая в ней каждую позицию заданным <em class="replaceable"><code>весом</code></em>, меткой <code class="literal">A</code>, <code class="literal">B</code>, <code class="literal">C</code> или <code class="literal">D</code>. (Метка <code class="literal">D</code> по умолчанию назначается всем векторам, так что при выводе она опускается.) Эти метки сохраняются при конкатенации векторов, что позволяет придавать разные веса словам из разных частей документа и, как следствие, ранжировать их по-разному.</p><p>Заметьте, что веса назначаются <span class="emphasis"><em>позициям</em></span>, а не <span class="emphasis"><em>лексемам</em></span>. Если входной вектор очищен от позиционной информации, <code class="function">setweight</code> не делает ничего.</p></dd><dt><span class="term">
     <a id="id-1.5.11.7.3.3.3.1.1" class="indexterm"></a>

      <code class="literal">length(<em class="replaceable"><code>вектор</code></em> <code class="type">tsvector</code>) returns <code class="type">integer</code></code>
     </span></dt><dd><p>Возвращает число лексем, сохранённых в векторе.</p></dd><dt><span class="term">
     <a id="id-1.5.11.7.3.3.4.1.1" class="indexterm"></a>

      <code class="literal">strip(<em class="replaceable"><code>вектор</code></em> <code class="type">tsvector</code>) returns <code class="type">tsvector</code></code>
     </span></dt><dd><p>Возвращает вектор с теми же лексемами, что и в данном, но без информации о позиции и весе. Очищенный вектор обычно оказывается намного меньше исходного, но при этом и менее полезным. С очищенными векторами хуже работает ранжирование, а также оператор <code class="literal">&lt;-&gt;</code> (ПРЕДШЕСТВУЕТ) типа <code class="type">tsquery</code> никогда не найдёт соответствие в них, так как не сможет определить расстояние между вхождениями лексем.</p></dd></dl></div><p>Полный список связанных с <code class="type">tsvector</code> функций приведён в <a class="xref" href="functions-textsearch.html#TEXTSEARCH-FUNCTIONS-TABLE" title="Таблица 9.43. Функции текстового поиска">Таблице 9.43</a>.</p></div><div class="sect2" id="TEXTSEARCH-MANIPULATE-TSQUERY"><div class="titlepage"><div><div><h3 class="title">12.4.2. Обработка запросов <a href="#TEXTSEARCH-MANIPULATE-TSQUERY" class="id_link">#</a></h3></div></div></div><p>В <a class="xref" href="textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES" title="12.3.2. Разбор запросов">Подразделе 12.3.2</a> показывалось, как обычные текстовые запросы можно преобразовывать в значения <code class="type">tsquery</code>. <span class="productname">PostgreSQL</span> предлагает также набор функций и операторов для обработки запросов, уже представленных в формате <code class="type">tsquery</code>.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
      <code class="literal"><code class="type">tsquery</code> &amp;&amp; <code class="type">tsquery</code></code>
     </span></dt><dd><p>Возвращает логическое произведение (AND) двух данных запросов.</p></dd><dt><span class="term">
      <code class="literal"><code class="type">tsquery</code> || <code class="type">tsquery</code></code>
     </span></dt><dd><p>Возвращает логическое объединение (OR) двух данных запросов.</p></dd><dt><span class="term">
      <code class="literal">!! <code class="type">tsquery</code></code>
     </span></dt><dd><p>Возвращает логическое отрицание (NOT) данного запроса.</p></dd><dt><span class="term">
      <code class="literal"><code class="type">tsquery</code> &lt;-&gt; <code class="type">tsquery</code></code>
     </span></dt><dd><p>Возвращает запрос, который ищет соответствие первому данному запросу, за которым следует соответствие второму данному запросу, с применением оператора <code class="literal">&lt;-&gt;</code> (ПРЕДШЕСТВУЕТ) типа <code class="type">tsquery</code>. Например: </p><pre class="screen">
SELECT to_tsquery('fat') &lt;-&gt; to_tsquery('cat | rat');
          ?column?
----------------------------
 'fat' &lt;-&gt; ( 'cat' | 'rat' )
</pre></dd><dt><span class="term">
     <a id="id-1.5.11.7.4.3.5.1.1" class="indexterm"></a>

      <code class="literal">tsquery_phrase(<em class="replaceable"><code>запрос1</code></em> <code class="type">tsquery</code>, <em class="replaceable"><code>запрос2</code></em> <code class="type">tsquery</code> [, <em class="replaceable"><code>расстояние</code></em> <code class="type">integer</code> ]) returns <code class="type">tsquery</code></code>
     </span></dt><dd><p>Возвращает запрос, который ищет соответствие первому данному запросу, за которым следует соответствие второму данному запросу (точное число лексем между ними задаётся параметром <em class="replaceable"><code>расстояние</code></em>), с применением оператора <code class="literal">&lt;<em class="replaceable"><code>N</code></em>&gt;</code> типа <code class="type">tsquery</code>. Например: </p><pre class="screen">
SELECT tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'), 10);
  tsquery_phrase
------------------
 'fat' &lt;10&gt; 'cat'
</pre></dd><dt><span class="term">
     <a id="id-1.5.11.7.4.3.6.1.1" class="indexterm"></a>

      <code class="literal">numnode(<em class="replaceable"><code>запрос</code></em> <code class="type">tsquery</code>) returns <code class="type">integer</code></code>
     </span></dt><dd><p>Возвращает число узлов (лексем и операторов) в значении <code class="type">tsquery</code>. Эта функция помогает определить, имеет ли смысл <em class="replaceable"><code>запрос</code></em> (тогда её результат &gt; 0) или он содержит только стоп-слова (тогда она возвращает 0). Примеры: </p><pre class="screen">
 SELECT numnode(plainto_tsquery('the any'));
ЗАМЕЧАНИЕ:  запрос поиска текста игнорируется, так как содержит
 только стоп-слова или не содержит лексем
 numnode
---------
       0

SELECT numnode('foo &amp; bar'::tsquery);
 numnode
---------
       3
</pre></dd><dt><span class="term">
     <a id="id-1.5.11.7.4.3.7.1.1" class="indexterm"></a>

      <code class="literal">querytree(<em class="replaceable"><code>запрос</code></em> <code class="type">tsquery</code>) returns <code class="type">text</code></code>
     </span></dt><dd><p>Возвращает часть <code class="type">tsquery</code>, которую можно использовать для поиска по индексу. Эта функция помогает выявить неиндексируемые запросы, к примеру такие, которые содержат только стоп-слова или условия отрицания. Например: </p><pre class="screen">
SELECT querytree(to_tsquery('defined'));
 querytree
-----------
 'defin'

SELECT querytree(to_tsquery('!defined'));
 querytree
-----------
 T
</pre></dd></dl></div><div class="sect3" id="TEXTSEARCH-QUERY-REWRITING"><div class="titlepage"><div><div><h4 class="title">12.4.2.1. Перезапись запросов <a href="#TEXTSEARCH-QUERY-REWRITING" class="id_link">#</a></h4></div></div></div><a id="id-1.5.11.7.4.4.2" class="indexterm"></a><p>Семейство запросов <code class="function">ts_rewrite</code> ищет в данном <code class="type">tsquery</code> вхождения целевого подзапроса и заменяет каждое вхождение указанной подстановкой. По сути эта операция похожа на замену подстроки в строке, только рассчитана на работу с <code class="type">tsquery</code>. Сочетание целевого подзапроса с подстановкой можно считать <em class="firstterm">правилом перезаписи запроса</em>. Набор таких правил перезаписи может быть очень полезен при поиске. Например, вы можете улучшить результаты, добавив синонимы (например, <code class="literal">big apple</code>, <code class="literal">nyc</code> и <code class="literal">gotham</code> для <code class="literal">new york</code>) или сузить область поиска, чтобы нацелить пользователя на некоторую область. Это в некотором смысле пересекается с функциональностью тезаурусов (<a class="xref" href="textsearch-dictionaries.html#TEXTSEARCH-THESAURUS" title="12.6.4. Тезаурус">Подраздел 12.6.4</a>). Однако при таком подходе вы можете изменять правила перезаписи «на лету», тогда как при обновлении тезауруса необходима переиндексация.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
       <code class="literal">ts_rewrite (<em class="replaceable"><code>запрос</code></em> <code class="type">tsquery</code>, <em class="replaceable"><code>цель</code></em> <code class="type">tsquery</code>, <em class="replaceable"><code>замена</code></em> <code class="type">tsquery</code>) returns <code class="type">tsquery</code></code>
      </span></dt><dd><p>Эта форма <code class="function">ts_rewrite</code> просто применяет одно правило перезаписи: <em class="replaceable"><code>цель</code></em> заменяется <em class="replaceable"><code>подстановкой</code></em> везде, где она находится в <em class="replaceable"><code>запросе</code></em>. Например: </p><pre class="screen">
SELECT ts_rewrite('a &amp; b'::tsquery, 'a'::tsquery, 'c'::tsquery);
 ts_rewrite
------------
 'b' &amp; 'c'
</pre></dd><dt><span class="term">
       <code class="literal">ts_rewrite (<em class="replaceable"><code>запрос</code></em> <code class="type">tsquery</code>, <em class="replaceable"><code>выборка</code></em> <code class="type">text</code>) returns <code class="type">tsquery</code></code>
      </span></dt><dd><p>Эта форма <code class="function">ts_rewrite</code> принимает начальный <em class="replaceable"><code>запрос</code></em> и SQL-команду <em class="replaceable"><code>select</code></em>, которая задаётся текстовой строкой. Команда <em class="replaceable"><code>select</code></em> должна выдавать два столбца типа <code class="type">tsquery</code>. Для каждой строки результата <em class="replaceable"><code>select</code></em> вхождения первого столбца (цели) заменяются значениями второго столбца (подстановкой) в тексте <em class="replaceable"><code>запроса</code></em>. Например: </p><pre class="screen">
CREATE TABLE aliases (t tsquery PRIMARY KEY, s tsquery);
INSERT INTO aliases VALUES('a', 'c');

SELECT ts_rewrite('a &amp; b'::tsquery, 'SELECT t,s FROM aliases');
 ts_rewrite
------------
 'b' &amp; 'c'
</pre><p>Заметьте, что когда таким способом применяются несколько правил перезаписи, порядок их применения может иметь значение, поэтому в исходном запросе следует добавить <code class="literal">ORDER BY</code> по какому-либо ключу.</p></dd></dl></div><p>Давайте рассмотрим практический пример на тему астрономии. Мы развернём запрос <code class="literal">supernovae</code>, используя правила перезаписи в таблице: </p><pre class="screen">
CREATE TABLE aliases (t tsquery primary key, s tsquery);
INSERT INTO aliases VALUES(to_tsquery('supernovae'),
  to_tsquery('supernovae|sn'));

SELECT ts_rewrite(to_tsquery('supernovae &amp; crab'), 'SELECT * FROM aliases');
           ts_rewrite
---------------------------------
 'crab' &amp; ( 'supernova' | 'sn' )
</pre><p> Мы можем скорректировать правила перезаписи, просто изменив таблицу: </p><pre class="screen">
UPDATE aliases
SET s = to_tsquery('supernovae|sn &amp; !nebulae')
WHERE t = to_tsquery('supernovae');

SELECT ts_rewrite(to_tsquery('supernovae &amp; crab'), 'SELECT * FROM aliases');
                 ts_rewrite
---------------------------------------------
 'crab' &amp; ( 'supernova' | 'sn' &amp; !'nebula' )
</pre><p>Перезапись может быть медленной, когда задано много правил перезаписи, так как соответствия будут проверяться для каждого правила. Чтобы отфильтровать явно неподходящие правила, можно использовать проверки включения для типа <code class="type">tsquery</code>. В следующем примере выбираются только те правила, которые могут соответствовать исходному запросу: </p><pre class="screen">
SELECT ts_rewrite('a &amp; b'::tsquery,
                  'SELECT t,s FROM aliases WHERE ''a &amp; b''::tsquery @&gt; t');
 ts_rewrite
------------
 'b' &amp; 'c'
</pre></div></div><div class="sect2" id="TEXTSEARCH-UPDATE-TRIGGERS"><div class="titlepage"><div><div><h3 class="title">12.4.3. Триггеры для автоматического обновления <a href="#TEXTSEARCH-UPDATE-TRIGGERS" class="id_link">#</a></h3></div></div></div><a id="id-1.5.11.7.5.2" class="indexterm"></a><div class="note"><h3 class="title">Примечание</h3><p>Описанный в этом разделе подход считается устаревшим в связи с появлением возможности использовать генерируемые столбцы, как описано в <a class="xref" href="textsearch-tables.html#TEXTSEARCH-TABLES-INDEX" title="12.2.2. Создание индексов">Подразделе 12.2.2</a>.</p></div><p>Когда представление документа в формате <code class="type">tsvector</code> хранится в отдельном столбце, необходимо создать триггер, который будет обновлять его содержимое при изменении столбцов, из которых составляется исходный документ. Для этого можно использовать две встроенные триггерные функции или написать свои собственные.</p><pre class="synopsis">tsvector_update_trigger(<em class="replaceable"><code>столбец_tsvector</code></em>,​ <em class="replaceable"><code>имя_конфигурации</code></em>, <em class="replaceable"><code>столбец_текста</code></em> [<span class="optional">, ...</span>])
tsvector_update_trigger_column(<em class="replaceable"><code>столбец_tsvector</code></em>,​ <em class="replaceable"><code>столбец_конфигурации</code></em>, <em class="replaceable"><code>столбец_текста</code></em> [<span class="optional">, ...</span>])</pre><p>Эти триггерные функции автоматически вычисляют значение для столбца <code class="type">tsvector</code> из одного или нескольких текстовых столбцов с параметрами, указанными в команде <code class="command">CREATE TRIGGER</code>. Пример их использования: </p><pre class="screen">
CREATE TABLE messages (
    title       text,
    body        text,
    tsv         tsvector
);

CREATE TRIGGER tsvectorupdate BEFORE INSERT OR UPDATE
ON messages FOR EACH ROW EXECUTE FUNCTION
tsvector_update_trigger(tsv, 'pg_catalog.english', title, body);

INSERT INTO messages VALUES('title here', 'the body text is here');

SELECT * FROM messages;
   title    |         body          |            tsv
------------+-----------------------+----------------------------
 title here | the body text is here | 'bodi':4 'text':5 'titl':1

SELECT title, body FROM messages WHERE tsv @@ to_tsquery('title &amp; body');
   title    |         body
------------+-----------------------
 title here | the body text is here
</pre><p> С таким триггером любое изменение в полях <code class="structfield">title</code> или <code class="structfield">body</code> будет автоматически отражаться в содержимом <code class="structfield">tsv</code>, так что приложению не придётся заниматься этим.</p><p>Первым аргументом этих функций должно быть имя столбца <code class="type">tsvector</code>, содержимое которого будет обновляться. Ещё один аргумент — конфигурация текстового поиска, которая будет использоваться для преобразования. Для <code class="function">tsvector_update_trigger</code> имя конфигурации передаётся просто как второй аргумент триггера. Это имя должно быть определено полностью, чтобы поведение триггера не менялось при изменениях в пути поиска (<code class="varname">search_path</code>). Для <code class="function">tsvector_update_trigger_column</code> во втором аргументе триггера передаётся имя другого столбца таблицы, который должен иметь тип <code class="type">regconfig</code>. Это позволяет использовать разные конфигурации для разных строк. В оставшихся аргументах передаются имена текстовых столбцов (типа <code class="type">text</code>, <code class="type">varchar</code> или <code class="type">char</code>). Их содержимое будет включено в документ в заданном порядке. При этом значения NULL будут пропущены (а другие столбцы будут индексироваться).</p><p>Ограничение этих встроенных триггеров заключается в том, что они обрабатывают все столбцы одинаково. Чтобы столбцы обрабатывались по-разному, например для текста заголовка задавался не тот же вес, что для тела документа, потребуется разработать свой триггер. К примеру, так это можно сделать на языке <span class="application">PL/pgSQL</span>: </p><pre class="programlisting">CREATE FUNCTION messages_trigger() RETURNS trigger AS $$
begin
  new.tsv :=
     setweight(to_tsvector('pg_catalog.english', coalesce(new.title,'')), 'A') ||
     setweight(to_tsvector('pg_catalog.english', coalesce(new.body,'')), 'D');
  return new;
end
$$ LANGUAGE plpgsql;

CREATE TRIGGER tsvectorupdate BEFORE INSERT OR UPDATE
    ON messages FOR EACH ROW EXECUTE FUNCTION messages_trigger();</pre><p>Помните, что, создавая значения <code class="type">tsvector</code> в триггерах, важно явно указывать имя конфигурации, чтобы содержимое столбца не зависело от изменений <code class="varname">default_text_search_config</code>. В противном случае могут возникнуть проблемы, например результаты поиска изменятся после выгрузки и восстановления данных.</p></div><div class="sect2" id="TEXTSEARCH-STATISTICS"><div class="titlepage"><div><div><h3 class="title">12.4.4. Сбор статистики по документу <a href="#TEXTSEARCH-STATISTICS" class="id_link">#</a></h3></div></div></div><a id="id-1.5.11.7.6.2" class="indexterm"></a><p>Функция <code class="function">ts_stat</code> может быть полезна для проверки конфигурации и нахождения возможных стоп-слов.</p><pre class="synopsis">ts_stat(<em class="replaceable"><code>sql_запрос</code></em> <code class="type">text</code>, [<span class="optional"><em class="replaceable"><code>веса</code></em> <code class="type">text</code>,</span>]
        OUT <em class="replaceable"><code>слово</code></em> <code class="type">text</code>, OUT <em class="replaceable"><code>число_док</code></em> <code class="type">integer</code>,
        OUT <em class="replaceable"><code>число_вхожд</code></em> <code class="type">integer</code>) returns <code class="type">setof record</code></pre><p>Здесь <em class="replaceable"><code>sql_запрос</code></em> — текстовая строка, содержащая SQL-запрос, который должен возвращать один столбец <code class="type">tsvector</code>. Функция <code class="function">ts_stat</code> выполняет запрос и возвращает статистику по каждой отдельной лексеме (слову), содержащейся в данных <code class="type">tsvector</code>. Её результат представляется в столбцах </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p><em class="replaceable"><code>слово</code></em> <code class="type">text</code> — значение лексемы</p></li><li class="listitem" style="list-style-type: disc"><p><em class="replaceable"><code>число_док</code></em> <code class="type">integer</code> — число документов (значений <code class="type">tsvector</code>), в которых встретилось слово</p></li><li class="listitem" style="list-style-type: disc"><p><em class="replaceable"><code>число_вхожд</code></em> <code class="type">integer</code> — общее число вхождений слова</p></li></ul></div><p> Если передаётся параметр <em class="replaceable"><code>weights</code></em>, то подсчитываются только вхождения с указанными в нём весами.</p><p>Например, найти десять наиболее часто используемых слов в коллекции документов можно так: </p><pre class="programlisting">SELECT * FROM ts_stat('SELECT vector FROM apod')
ORDER BY nentry DESC, ndoc DESC, word
LIMIT 10;</pre><p> Следующий запрос возвращает тоже десять слов, но при выборе их учитываются только вхождения с весами <code class="literal">A</code> или <code class="literal">B</code>: </p><pre class="programlisting">SELECT * FROM ts_stat('SELECT vector FROM apod', 'ab')
ORDER BY nentry DESC, ndoc DESC, word
LIMIT 10;</pre></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="textsearch-controls.html" title="12.3. Управление текстовым поиском">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="textsearch.html" title="Глава 12. Полнотекстовый поиск">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="textsearch-parsers.html" title="12.5. Анализаторы">След.</a></td></tr><tr><td width="40%" align="left" valign="top">12.3. Управление текстовым поиском </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 12.5. Анализаторы</td></tr></table></div></body></html>