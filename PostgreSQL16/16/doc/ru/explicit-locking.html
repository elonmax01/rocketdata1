<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>13.3. Явные блокировки</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="transaction-iso.html" title="13.2. Изоляция транзакций" /><link rel="next" href="applevel-consistency.html" title="13.4. Проверки целостности данных на уровне приложения" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">13.3. Явные блокировки</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="transaction-iso.html" title="13.2. Изоляция транзакций">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="mvcc.html" title="Глава 13. Управление конкурентным доступом">Наверх</a></td><th width="60%" align="center">Глава 13. Управление конкурентным доступом</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="applevel-consistency.html" title="13.4. Проверки целостности данных на уровне приложения">След.</a></td></tr></table><hr /></div><div class="sect1" id="EXPLICIT-LOCKING"><div class="titlepage"><div><div><h2 class="title" style="clear: both">13.3. Явные блокировки <a href="#EXPLICIT-LOCKING" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="explicit-locking.html#LOCKING-TABLES">13.3.1. Блокировки на уровне таблицы</a></span></dt><dt><span class="sect2"><a href="explicit-locking.html#LOCKING-ROWS">13.3.2. Блокировки на уровне строк</a></span></dt><dt><span class="sect2"><a href="explicit-locking.html#LOCKING-PAGES">13.3.3. Блокировки на уровне страниц</a></span></dt><dt><span class="sect2"><a href="explicit-locking.html#LOCKING-DEADLOCKS">13.3.4. Взаимоблокировки</a></span></dt><dt><span class="sect2"><a href="explicit-locking.html#ADVISORY-LOCKS">13.3.5. Рекомендательные блокировки</a></span></dt></dl></div><a id="id-1.5.12.6.2" class="indexterm"></a><p>Для управления параллельным доступом к данным в таблицах <span class="productname">PostgreSQL</span> предоставляет несколько режимов явных блокировок. Эти режимы могут применяться для блокировки данных со стороны приложения в ситуациях, когда <acronym class="acronym">MVCC</acronym> не даёт желаемый результат. Кроме того, большинство команд <span class="productname">PostgreSQL</span> автоматически получают блокировки соответствующих режимов, защищающие от удаления или изменения задействованных таблиц, несовместимого с характером выполняемой команды. (Например, <code class="command">TRUNCATE</code> не может безопасно выполняться одновременно с другими операциями с этой таблицей, так что во избежание конфликта эта команда получает блокировку <code class="literal">ACCESS EXCLUSIVE</code> для данной таблицы.)</p><p>Список текущих активных блокировок на сервере можно получить, прочитав системное представление <a class="link" href="view-pg-locks.html" title="54.12. pg_locks"><code class="structname">pg_locks</code></a>. За дополнительными сведениями о наблюдении за состоянием менеджера блокировок обратитесь к <a class="xref" href="monitoring.html" title="Глава 28. Мониторинг работы СУБД">Главе 28</a>.</p><div class="sect2" id="LOCKING-TABLES"><div class="titlepage"><div><div><h3 class="title">13.3.1. Блокировки на уровне таблицы <a href="#LOCKING-TABLES" class="id_link">#</a></h3></div></div></div><a id="id-1.5.12.6.5.2" class="indexterm"></a><p>В приведённом ниже списке перечислены имеющиеся режимы блокировок и контексты, где их автоматически применяет <span class="productname">PostgreSQL</span>. Вы можете также явно запросить любую из этих блокировок с помощью команды <a class="xref" href="sql-lock.html" title="LOCK"><span class="refentrytitle">LOCK</span></a>. Помните, что все эти режимы работают на уровне таблицы, даже если имя режима содержит слово <span class="quote">«<span class="quote">row</span>»</span>; такие имена сложились исторически. В некоторой степени эти имена отражают типичное применение каждого режима блокировки, но смысл у всех один. Единственное, что действительно отличает один режим блокировки от другого, это набор режимов, с которыми конфликтует каждый из них (см. <a class="xref" href="explicit-locking.html#TABLE-LOCK-COMPATIBILITY" title="Таблица 13.2. Конфликтующие режимы блокировки">Таблицу 13.2</a>). Две транзакции не могут одновременно владеть блокировками конфликтующих режимов для одной и той же таблицы. (Однако учтите, что транзакция никогда не конфликтует с собой. Например, она может запросить блокировку <code class="literal">ACCESS EXCLUSIVE</code>, а затем <code class="literal">ACCESS SHARE</code> для той же таблицы.) При этом разные транзакции свободно могут одновременно владеть блокировками неконфликтующих режимов. Заметьте, что некоторые режимы блокировки конфликтуют сами с собой (например, блокировкой <code class="literal">ACCESS EXCLUSIVE</code> в один момент времени может владеть только одна транзакция), а некоторые — нет (например, блокировку <code class="literal">ACCESS SHARE</code> могут получить сразу несколько транзакций).</p><div class="variablelist"><p class="title"><strong>Режимы блокировок на уровне таблицы</strong></p><dl class="variablelist"><dt><span class="term"><code class="literal">ACCESS SHARE</code> (<code class="literal">AccessShareLock</code>)</span></dt><dd><p>Конфликтует только с режимом блокировки <code class="literal">ACCESS EXCLUSIVE</code>.</p><p>Команда <code class="command">SELECT</code> получает такую блокировку для таблиц, на которые она ссылается. Вообще говоря, блокировку в этом режиме получает любой запрос, который только <span class="emphasis"><em>читает</em></span> таблицу, но не меняет её данные.</p></dd><dt><span class="term"><code class="literal">ROW SHARE</code> (<code class="literal">RowShareLock</code>)</span></dt><dd><p>Конфликтует с режимами блокировки <code class="literal">EXCLUSIVE</code> и <code class="literal">ACCESS EXCLUSIVE</code>.</p><p>Команда <code class="command">SELECT</code> устанавливает блокировку в этом режиме для всех таблиц, для которых задано указание <code class="option">FOR UPDATE</code>, <code class="option">FOR NO KEY UPDATE</code>, <code class="option">FOR SHARE</code> или <code class="option">FOR KEY SHARE</code> (в дополнение к блокировкам <code class="literal">ACCESS SHARE</code> для любых других таблиц, задействованных без каких-либо явных указаний блокировки <code class="option">FOR .. .</code>).</p></dd><dt><span class="term"><code class="literal">ROW EXCLUSIVE</code> (<code class="literal">RowExclusiveLock</code>)</span></dt><dd><p>Конфликтует с режимами блокировки <code class="literal">SHARE</code>, <code class="literal">SHARE ROW EXCLUSIVE</code>, <code class="literal">EXCLUSIVE</code> и <code class="literal">ACCESS EXCLUSIVE</code>.</p><p>Команды <code class="command">UPDATE</code>, <code class="command">DELETE</code>, <code class="command">INSERT</code> и <code class="command">MERGE</code> получают такую блокировку для целевой таблицы (в дополнение к блокировкам <code class="literal">ACCESS SHARE</code> для всех других задействованных таблиц). Вообще говоря, блокировку в этом режиме получает любая команда, которая <span class="emphasis"><em>изменяет данные</em></span> в таблице.</p></dd><dt><span class="term"><code class="literal">SHARE UPDATE EXCLUSIVE</code> (<code class="literal">ShareUpdateExclusiveLock</code>)</span></dt><dd><p>Конфликтует с режимами блокировки <code class="literal">SHARE UPDATE EXCLUSIVE</code>, <code class="literal">SHARE</code>, <code class="literal">SHARE ROW EXCLUSIVE</code>, <code class="literal">EXCLUSIVE</code> и <code class="literal">ACCESS EXCLUSIVE</code>. Этот режим защищает таблицу от параллельного изменения схемы и запуска процесса <code class="command">VACUUM</code>.</p><p>Запрашивается командами <code class="command">VACUUM</code> (без <code class="option">FULL</code>), <code class="command">ANALYZE</code>, <code class="command">CREATE INDEX CONCURRENTLY</code>, <code class="command">CREATE STATISTICS</code>, <code class="command">COMMENT ON</code>, <code class="command">REINDEX CONCURRENTLY</code> и некоторыми формами <a class="link" href="sql-alterindex.html" title="ALTER INDEX"><code class="command">ALTER INDEX</code></a> и <a class="link" href="sql-altertable.html" title="ALTER TABLE"><code class="command">ALTER TABLE</code></a> (за подробностями обратитесь к описанию этих команд).</p></dd><dt><span class="term"><code class="literal">SHARE</code> (<code class="literal">ShareLock</code>)</span></dt><dd><p>Конфликтует с режимами блокировки <code class="literal">ROW EXCLUSIVE</code>, <code class="literal">SHARE UPDATE EXCLUSIVE</code>, <code class="literal">SHARE ROW EXCLUSIVE</code>, <code class="literal">EXCLUSIVE</code> и <code class="literal">ACCESS EXCLUSIVE</code>. Этот режим защищает таблицу от параллельного изменения данных.</p><p>Запрашивается командой <code class="command">CREATE INDEX</code> (без параметра <code class="option">CONCURRENTLY</code>).</p></dd><dt><span class="term"><code class="literal">SHARE ROW EXCLUSIVE</code> (<code class="literal">ShareRowExclusiveLock</code>)</span></dt><dd><p>Конфликтует с режимами блокировки <code class="literal">ROW EXCLUSIVE</code>, <code class="literal">SHARE UPDATE EXCLUSIVE</code>, <code class="literal">SHARE</code>, <code class="literal">SHARE ROW EXCLUSIVE</code>, <code class="literal">EXCLUSIVE</code> и <code class="literal">ACCESS EXCLUSIVE</code>. Этот режим защищает таблицу от параллельных изменений данных и при этом он является самоисключающим, так что такую блокировку может получить только один сеанс.</p><p>Запрашивается командой <code class="command">CREATE TRIGGER</code> и некоторыми формами <a class="link" href="sql-altertable.html" title="ALTER TABLE"><code class="command">ALTER TABLE</code></a>).</p></dd><dt><span class="term"><code class="literal">EXCLUSIVE</code> (<code class="literal">ExclusiveLock</code>)</span></dt><dd><p>Конфликтует с режимами блокировки <code class="literal">ROW SHARE</code>, <code class="literal">ROW EXCLUSIVE</code>, <code class="literal">SHARE UPDATE EXCLUSIVE</code>, <code class="literal">SHARE</code>, <code class="literal">SHARE ROW EXCLUSIVE</code>, <code class="literal">EXCLUSIVE</code> и <code class="literal">ACCESS EXCLUSIVE</code>. Этот режим совместим только с блокировкой <code class="literal">ACCESS SHARE</code>, то есть параллельно с транзакцией, получившей блокировку в этом режиме, допускается только чтение таблицы.</p><p>Запрашивается командой <code class="command">REFRESH MATERIALIZED VIEW CONCURRENTLY</code>.</p></dd><dt><span class="term"><code class="literal">ACCESS EXCLUSIVE</code> (<code class="literal">AccessExclusiveLock</code>)</span></dt><dd><p>Конфликтует со всеми режимами блокировки (<code class="literal">ACCESS SHARE</code>, <code class="literal">ROW SHARE</code>, <code class="literal">ROW EXCLUSIVE</code>, <code class="literal">SHARE UPDATE EXCLUSIVE</code>, <code class="literal">SHARE</code>, <code class="literal">SHARE ROW EXCLUSIVE</code>, <code class="literal">EXCLUSIVE</code> и <code class="literal">ACCESS EXCLUSIVE</code>). Этот режим гарантирует, что кроме транзакции, получившей эту блокировку, никакая другая транзакция не может обращаться к таблице каким-либо способом.</p><p>Запрашивается командами <code class="command">DROP TABLE</code>, <code class="command">TRUNCATE</code>, <code class="command">REINDEX</code>, <code class="command">CLUSTER</code>, <code class="command">VACUUM FULL</code> и <code class="command">REFRESH MATERIALIZED VIEW</code> (без <code class="option">CONCURRENTLY</code>). Блокировку на этом уровне запрашивают также многие виды <code class="command">ALTER INDEX</code> и <code class="command">ALTER TABLE</code>. В этом режиме по умолчанию запрашивают блокировку и операторы <code class="command">LOCK TABLE</code>, если явно не выбран другой режим.</p></dd></dl></div><div class="tip"><h3 class="title">Подсказка</h3><p>Только блокировка <code class="literal">ACCESS EXCLUSIVE</code> блокирует оператор <code class="command">SELECT</code> (без <code class="option">FOR UPDATE/SHARE</code>).</p></div><p>Полученная транзакцией блокировка обычно сохраняется до конца транзакции. Но если блокировка получена после установки точки сохранения, она освобождается немедленно в случае отката к этой точке. Это согласуется с принципом действия <code class="command">ROLLBACK</code> — эта команда отменяет эффекты всех команд после точки сохранения. То же справедливо и для блокировок, полученных в блоке исключений <span class="application">PL/pgSQL</span>: при выходе из блока с ошибкой такие блокировки освобождаются.</p><div class="table" id="TABLE-LOCK-COMPATIBILITY"><p class="title"><strong>Таблица 13.2. Конфликтующие режимы блокировки</strong></p><div class="table-contents"><table class="table" summary="Конфликтующие режимы блокировки" border="1"><colgroup><col /><col class="lockst" /><col /><col /><col /><col /><col /><col /><col class="lockend" /></colgroup><thead><tr><th rowspan="2">Запраши​ваемый режим блоки​ровки</th><th colspan="8" align="center">Существующий режим блокировки</th></tr><tr><th><code class="literal">ACCESS SHARE</code></th><th><code class="literal">ROW SHARE</code></th><th><code class="literal">ROW EXCL.</code></th><th><code class="literal">SHARE UPDATE EXCL.</code></th><th><code class="literal">SHARE</code></th><th><code class="literal">SHARE ROW EXCL.</code></th><th><code class="literal">EXCL.</code></th><th><code class="literal">ACCESS EXCL.</code></th></tr></thead><tbody><tr><td><code class="literal">ACCESS SHARE</code></td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center">X</td></tr><tr><td><code class="literal">ROW SHARE</code></td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center">X</td><td align="center">X</td></tr><tr><td><code class="literal">ROW EXCL.</code></td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td><code class="literal">SHARE UPDATE EXCL.</code></td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td><code class="literal">SHARE</code></td><td align="center"> </td><td align="center"> </td><td align="center">X</td><td align="center">X</td><td align="center"> </td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td><code class="literal">SHARE ROW EXCL.</code></td><td align="center"> </td><td align="center"> </td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td><code class="literal">EXCL.</code></td><td align="center"> </td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td><code class="literal">ACCESS EXCL.</code></td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect2" id="LOCKING-ROWS"><div class="titlepage"><div><div><h3 class="title">13.3.2. Блокировки на уровне строк <a href="#LOCKING-ROWS" class="id_link">#</a></h3></div></div></div><p>Помимо блокировок на уровне таблицы, существуют блокировки на уровне строк, перечисленные ниже с контекстами, где <span class="productname">PostgreSQL</span> применяет их по умолчанию. Полный перечень конфликтов блокировок на уровне строк приведён в <a class="xref" href="explicit-locking.html#ROW-LOCK-COMPATIBILITY" title="Таблица 13.3. Конфликтующие блокировки на уровне строк">Таблице 13.3</a>. Заметьте, что одна транзакция может владеть несколькими конфликтующими блокировками одной строки, даже в разных подтранзакциях; но две разных транзакции никогда не получат конфликтующие блокировки одной и той же строки. Блокировки на уровне строк блокируют только <span class="emphasis"><em>запись в определённые строки</em></span>, но никак не влияют на выборку. Снимаются такие блокировки, как и блокировки на уровне таблицы, в конце транзакции или при откате к точке сохранения.</p><div class="variablelist"><p class="title"><strong>Режимы блокировки на уровне строк</strong></p><dl class="variablelist"><dt><span class="term">
        <code class="literal">FOR UPDATE</code>
       </span></dt><dd><p>В режиме <code class="literal">FOR UPDATE</code> строки, выданные оператором <code class="command">SELECT</code>, блокируются как для изменения. При этом они защищаются от блокировки, изменения и удаления другими транзакциями до завершения текущей. То есть другие транзакции, пытающиеся выполнить <code class="command">UPDATE</code>, <code class="command">DELETE</code>, <code class="command">SELECT FOR UPDATE</code>, <code class="command">SELECT FOR NO KEY UPDATE</code>, <code class="command">SELECT FOR SHARE</code> или <code class="command">SELECT FOR KEY SHARE</code> с этими строками, будут заблокированы до завершения текущей транзакции; и наоборот, команда <code class="command">SELECT FOR UPDATE</code> будет ожидать окончания параллельной транзакции, в которой выполнилась одна из этих команд с той же строкой, а затем установит блокировку и вернёт изменённую строку (или не вернёт, если она была удалена). Однако в транзакции <code class="literal">REPEATABLE READ</code> или <code class="literal">SERIALIZABLE</code> возникнет ошибка, если блокируемая строка изменилась с момента начала транзакции. Подробнее это обсуждается в <a class="xref" href="applevel-consistency.html" title="13.4. Проверки целостности данных на уровне приложения">Разделе 13.4</a>.</p><p>Режим блокировки <code class="literal">FOR UPDATE</code> также запрашивается на уровне строки любой командой <code class="command">DELETE</code> и командой <code class="command">UPDATE</code>, изменяющей значения определённых столбцов. В настоящее время блокировка с <code class="command">UPDATE</code> касается столбцов, по которым создан уникальный индекс, применимый в качестве внешнего ключа (так что на частичные индексы и индексы выражений это не распространяется), но в будущем это может поменяться.</p></dd><dt><span class="term">
        <code class="literal">FOR NO KEY UPDATE</code>
       </span></dt><dd><p>Действует подобно <code class="literal">FOR UPDATE</code>, но запрашиваемая в этом режиме блокировка слабее: она не будет блокировать команды <code class="literal">SELECT FOR KEY SHARE</code>, пытающиеся получить блокировку тех же строк. Этот режим блокировки также запрашивается любой командой <code class="command">UPDATE</code>, которая не требует блокировки <code class="literal">FOR UPDATE</code>.</p></dd><dt><span class="term">
        <code class="literal">FOR SHARE</code>
       </span></dt><dd><p>Действует подобно <code class="literal">FOR NO KEY UPDATE</code>, за исключением того, что для каждой из полученных строк запрашивается разделяемая, а не исключительная блокировка. Разделяемая блокировка не позволяет другим транзакциям выполнять с этими строками <code class="command">UPDATE</code>, <code class="command">DELETE</code>, <code class="command">SELECT FOR UPDATE</code> или <code class="command">SELECT FOR NO KEY UPDATE</code>, но допускает <code class="command">SELECT FOR SHARE</code> и <code class="command">SELECT FOR KEY SHARE</code>.</p></dd><dt><span class="term">
        <code class="literal">FOR KEY SHARE</code>
       </span></dt><dd><p>Действует подобно <code class="literal">FOR SHARE</code>, но устанавливает более слабую блокировку: блокируется <code class="literal">SELECT FOR UPDATE</code>, но не <code class="literal">SELECT FOR NO KEY UPDATE</code>. Блокировка разделяемого ключа не позволяет другим транзакциям выполнять команды <code class="command">DELETE</code> и <code class="command">UPDATE</code>, только если они меняют значение ключа (но не другие <code class="command">UPDATE</code>), и при этом допускает выполнение команд <code class="command">SELECT FOR NO KEY UPDATE</code>, <code class="command">SELECT FOR SHARE</code> и <code class="command">SELECT FOR KEY SHARE</code>.</p></dd></dl></div><p><span class="productname">PostgreSQL</span> не держит информацию об изменённых строках в памяти, так что никаких ограничений на число блокируемых строк нет. Однако блокировка строки может повлечь запись на диск, например, если <code class="command">SELECT FOR UPDATE</code> изменяет выбранные строки, чтобы заблокировать их, при этом происходит запись на диск.</p><div class="table" id="ROW-LOCK-COMPATIBILITY"><p class="title"><strong>Таблица 13.3. Конфликтующие блокировки на уровне строк</strong></p><div class="table-contents"><table class="table" summary="Конфликтующие блокировки на уровне строк" border="1"><colgroup><col class="col1" /><col class="lockst" /><col class="col3" /><col class="col4" /><col class="lockend" /></colgroup><thead><tr><th rowspan="2">Запраши​ваемый режим блоки​ровки</th><th colspan="4">Текущий режим блокировки</th></tr><tr><th>FOR KEY SHARE</th><th>FOR SHARE</th><th>FOR NO KEY UPDATE</th><th>FOR UPDATE</th></tr></thead><tbody><tr><td>FOR KEY SHARE</td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center">X</td></tr><tr><td>FOR SHARE</td><td align="center"> </td><td align="center"> </td><td align="center">X</td><td align="center">X</td></tr><tr><td>FOR NO KEY UPDATE</td><td align="center"> </td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td>FOR UPDATE</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect2" id="LOCKING-PAGES"><div class="titlepage"><div><div><h3 class="title">13.3.3. Блокировки на уровне страниц <a href="#LOCKING-PAGES" class="id_link">#</a></h3></div></div></div><p>В дополнение к блокировкам на уровне таблицы и строк, для управления доступом к страницам таблиц в общих буферах используются блокировки на уровне страниц, исключительные и разделяемые. Эти блокировки освобождаются немедленно после выборки или изменения строк. Разработчикам приложений обычно можно не задумываться о блокировках страниц, здесь они упоминаются только для полноты картины.</p></div><div class="sect2" id="LOCKING-DEADLOCKS"><div class="titlepage"><div><div><h3 class="title">13.3.4. Взаимоблокировки <a href="#LOCKING-DEADLOCKS" class="id_link">#</a></h3></div></div></div><a id="id-1.5.12.6.8.2" class="indexterm"></a><p>Частое применение явных блокировок может увеличить вероятность <em class="firstterm">взаимоблокировок</em>, то есть ситуаций, когда две (или более) транзакций держат блокировки так, что взаимно блокируют друг друга. Например, если транзакция 1 получает исключительную блокировку таблицы A, а затем пытается получить исключительную блокировку таблицы B, которую до этого получила транзакция 2, в данный момент требующая исключительную блокировку таблицы A, ни одна из транзакций не сможет продолжить работу. <span class="productname">PostgreSQL</span> автоматически выявляет такие ситуации и разрешает их, прерывая одну из сцепившихся транзакций и тем самым позволяя другой (другим) продолжить работу. (Какая именно транзакция будет прервана, обычно сложно предсказать, так что рассчитывать на определённое поведение не следует.)</p><p>Заметьте, что взаимоблокировки могут вызываться и блокировками на уровне строк (таким образом, они возможны, даже если не применяются явные блокировки). Рассмотрим случай, когда две параллельных транзакции изменяют таблицу. Первая транзакция выполняет: </p><pre class="screen">
UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 11111;
</pre><p> При этом она получает блокировку строки с указанным номером счёта. Затем вторая транзакция выполняет: </p><pre class="screen">
UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 22222;
UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 11111;
</pre><p> Первый оператор <code class="command">UPDATE</code> успешно получает блокировку указанной строки и изменяет данные в ней. Однако второй оператор <code class="command">UPDATE</code> обнаруживает, что строка, которую он пытается изменить, уже заблокирована, так что он ждёт завершения транзакции, получившей блокировку. Таким образом, вторая транзакция сможет продолжиться только после завершения первой. Теперь первая транзакция выполняет: </p><pre class="screen">
UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 22222;
</pre><p> Первая транзакция пытается получить блокировку заданной строки, но ей это не удаётся: эта блокировка уже принадлежит второй транзакции. Поэтому первой транзакции остаётся только ждать завершения второй. В результате первая транзакция блокируется второй, а вторая — первой: происходит взаимоблокировка. <span class="productname">PostgreSQL</span> выявляет эту ситуацию и прерывает одну из транзакций.</p><p>Обычно лучший способ предотвращения взаимоблокировок — добиться, чтобы все приложения, обращающиеся к базе данных, запрашивали блокировки нескольких объектов единообразно. В данном примере, если бы обе транзакции изменяли строки в одном порядке, взаимоблокировка бы не произошла. Блокировки в транзакции следует упорядочивать так, чтобы первой для какого-либо объекта запрашивалась наиболее ограничивающая из тех, которые для него потребуются. Если заранее обеспечить такой порядок нельзя, взаимоблокировки можно обработать по факту, повторяя прерванные транзакции.</p><p>Если ситуация взаимоблокировки не будет выявлена, транзакция, ожидающая блокировки на уровне таблицы или строки, будет ждать её освобождения неограниченное время. Это означает, что приложения не должны оставлять транзакции открытыми долгое время (например, ожидая ввода пользователя).</p></div><div class="sect2" id="ADVISORY-LOCKS"><div class="titlepage"><div><div><h3 class="title">13.3.5. Рекомендательные блокировки <a href="#ADVISORY-LOCKS" class="id_link">#</a></h3></div></div></div><a id="id-1.5.12.6.9.2" class="indexterm"></a><a id="id-1.5.12.6.9.3" class="indexterm"></a><p><span class="productname">PostgreSQL</span> также имеет средства создания блокировок, смысл которых определяют сами приложения. Такие блокировки называются <em class="firstterm">рекомендательными</em>, так как система не форсирует их использование — правильно их использовать должно само приложение. Рекомендательные блокировки бывают полезны для реализаций стратегий блокирования, плохо вписывающихся в модель MVCC. Например, рекомендательные блокировки часто применяются для исполнения стратегии пессимистичной блокировки, типичной для систем управления данными <span class="quote">«<span class="quote">плоский файл</span>»</span>. Хотя для этого можно использовать и дополнительные флаги в таблицах, рекомендательные блокировки работают быстрее, не приводят к раздуванию таблиц и автоматически ликвидируются сервером в конце сеанса.</p><p>В <span class="productname">PostgreSQL</span> есть два варианта получить рекомендательные блокировки: на уровне сеанса и на уровне транзакции. Рекомендательная блокировка, полученная на уровне сеанса, удерживается, пока она не будет явно освобождена, или до конца сеанса. В отличие от стандартных рекомендательные блокировки уровня сеанса нарушают логику транзакций — блокировка, полученная в транзакции, даже если произойдёт откат этой транзакции, будет сохраняться в сеансе; аналогично, освобождение блокировки остаётся в силе, даже если транзакция, в которой оно было выполнено, позже прерывается. Вызывающий процесс может запросить блокировку несколько раз; при этом каждому запросу блокировки должен соответствовать запрос освобождения, чтобы она была действительно освобождена. Рекомендательные блокировки на уровне транзакций, напротив, во многом похожи на обычные блокировки: они автоматически освобождаются в конце транзакций и не требуют явного освобождения. Для кратковременного применения блокировок это поведение часто более уместно, чем поведение рекомендательных блокировок на уровне сеанса. Запросы рекомендательных блокировок одного идентификатора на уровне сеанса и на уровне транзакции будут блокировать друг друга вполне предсказуемым образом. Если сеанс уже владеет данной рекомендательной блокировкой, дополнительные запросы её в том же сеансе будут всегда успешны, даже если её ожидают другие сеансы. Это утверждение справедливо вне зависимости от того, на каком уровне (сеанса или транзакции) установлены или запрашиваются новые блокировки.</p><p>Как и остальные блокировки в <span class="productname">PostgreSQL</span>, все рекомендательные блокировки, связанные с любыми сеансами, можно просмотреть в системном представлении <a class="link" href="view-pg-locks.html" title="54.12. pg_locks"><code class="structname">pg_locks</code></a>.</p><p>И рекомендательные, и обычные блокировки сохраняются в области общей памяти, размер которой определяется параметрами конфигурации <a class="xref" href="runtime-config-locks.html#GUC-MAX-LOCKS-PER-TRANSACTION">max_locks_per_transaction</a> и <a class="xref" href="runtime-config-connection.html#GUC-MAX-CONNECTIONS">max_connections</a>. Важно, чтобы этой памяти было достаточно, так как в противном случае сервер не сможет выдать никакую блокировку. Таким образом, число рекомендательных блокировок, которые может выдать сервер, ограничивается обычно десятками или сотнями тысяч в зависимости от конфигурации сервера.</p><p>В определённых случаях при использовании рекомендательных блокировок, особенно в запросах с явными указаниями <code class="literal">ORDER BY</code> и <code class="literal">LIMIT</code>, важно учитывать, что получаемые блокировки могут зависеть от порядка вычисления SQL-выражений. Например: </p><pre class="screen">
SELECT pg_advisory_lock(id) FROM foo WHERE id = 12345; -- ok
SELECT pg_advisory_lock(id) FROM foo WHERE id &gt; 12345 LIMIT 100; -- опасно!
SELECT pg_advisory_lock(q.id) FROM
(
  SELECT id FROM foo WHERE id &gt; 12345 LIMIT 100
) q; -- ok
</pre><p> В этом примере второй вариант опасен, так как <code class="literal">LIMIT</code> не обязательно будет применяться перед вызовом функции блокировки. В результате приложение может получить блокировки, на которые оно не рассчитывает и которые оно не сможет освободить (до завершения сеанса). С точки зрения приложения такие блокировки окажутся в подвешенном состоянии, хотя они и будут отображаться в <code class="structname">pg_locks</code>.</p><p>Функции, предназначенные для работы с рекомендательными блокировками, описаны в <a class="xref" href="functions-admin.html#FUNCTIONS-ADVISORY-LOCKS" title="9.27.10. Функции управления рекомендательными блокировками">Подразделе 9.27.10</a>.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="transaction-iso.html" title="13.2. Изоляция транзакций">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="mvcc.html" title="Глава 13. Управление конкурентным доступом">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="applevel-consistency.html" title="13.4. Проверки целостности данных на уровне приложения">След.</a></td></tr><tr><td width="40%" align="left" valign="top">13.2. Изоляция транзакций </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 13.4. Проверки целостности данных на уровне приложения</td></tr></table></div></body></html>