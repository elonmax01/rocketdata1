<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>EXPLAIN</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sql-execute.html" title="EXECUTE" /><link rel="next" href="sql-fetch.html" title="FETCH" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">EXPLAIN</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-execute.html" title="EXECUTE">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><th width="60%" align="center">Команды SQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-fetch.html" title="FETCH">След.</a></td></tr></table><hr /></div><div class="refentry" id="SQL-EXPLAIN"><div class="titlepage"></div><a id="id-1.9.3.148.1" class="indexterm"></a><a id="id-1.9.3.148.2" class="indexterm"></a><a id="id-1.9.3.148.3" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">EXPLAIN</span></h2><p>EXPLAIN — показать план выполнения оператора</p></div><div class="refsynopsisdiv"><h2>Синтаксис</h2><pre class="synopsis">EXPLAIN [ ( <em class="replaceable"><code>параметр</code></em> [, ...] ) ] <em class="replaceable"><code>оператор</code></em>
EXPLAIN [ ANALYZE ] [ VERBOSE ] <em class="replaceable"><code>оператор</code></em>

<span class="phrase">Здесь допускается <em class="replaceable"><code>параметр</code></em>:</span>

    ANALYZE [ <em class="replaceable"><code>boolean</code></em> ]
    VERBOSE [ <em class="replaceable"><code>boolean</code></em> ]
    COSTS [ <em class="replaceable"><code>boolean</code></em> ]
    SETTINGS [ <em class="replaceable"><code>boolean</code></em> ]
    GENERIC_PLAN [ <em class="replaceable"><code>boolean</code></em> ]
    BUFFERS [ <em class="replaceable"><code>boolean</code></em> ]
    WAL [ <em class="replaceable"><code>boolean</code></em> ]
    TIMING [ <em class="replaceable"><code>boolean</code></em> ]
    SUMMARY [ <em class="replaceable"><code>boolean</code></em> ]
    FORMAT { TEXT | XML | JSON | YAML }</pre></div><div class="refsect1" id="id-1.9.3.148.7"><h2>Описание</h2><p>Эта команда выводит план выполнения, генерируемый планировщиком <span class="productname">PostgreSQL</span> для заданного оператора. План выполнения показывает, как будут сканироваться таблицы, затрагиваемые оператором — просто последовательно, по индексу и т. д. — а если запрос связывает несколько таблиц, какой алгоритм соединения будет выбран для объединения считанных из них строк.</p><p>Наибольший интерес в выводимой информации представляет ожидаемая стоимость выполнения оператора, которая показывает, сколько, по мнению планировщика, будет выполняться этот оператор (это значение измеряется в единицах стоимости, которые не имеют точного определения, но обычно это обращение к странице на диске). Фактически выводятся два числа: стоимость запуска до выдачи первой строки и общая стоимость выдачи всех строк. Для большинства запросов важна общая стоимость, но в таких контекстах, как подзапрос в <code class="literal">EXISTS</code>, планировщик будет минимизировать стоимость запуска, а не общую стоимость (так как исполнение запроса всё равно завершится сразу после получения одной строки). Кроме того, если количество возвращаемых строк ограничивается предложением <code class="literal">LIMIT</code>, планировщик интерполирует стоимость между двумя этими числами, выбирая наиболее выгодный план.</p><p>С параметром <code class="literal">ANALYZE</code> оператор будет выполнен на самом деле, а не только запланирован. При этом в вывод добавляются фактические сведения о времени выполнения, включая общее время, затраченное на каждый узел плана (в миллисекундах) и общее число строк, выданных в результате. Это помогает понять, насколько близки к реальности предварительные оценки планировщика.</p><div class="important"><h3 class="title">Важно</h3><p>Имейте в виду, что с указанием <code class="literal">ANALYZE</code> оператор действительно выполняется. Хотя <code class="command">EXPLAIN</code> отбрасывает результат, который вернул бы <code class="command">SELECT</code>, в остальном все действия выполняются как обычно. Если вы хотите выполнить <code class="command">EXPLAIN ANALYZE</code> с командой <code class="command">INSERT</code>, <code class="command">UPDATE</code>, <code class="command">DELETE</code>, <code class="command">MERGE</code>, <code class="command">CREATE TABLE AS</code> или <code class="command">EXECUTE</code>, не допуская изменения данных этой командой, воспользуйтесь таким приёмом: </p><pre class="programlisting">BEGIN;
EXPLAIN ANALYZE ...;
ROLLBACK;</pre></div><p>Без скобок для этого оператора можно указать только параметры <code class="literal">ANALYZE</code> и <code class="literal">VERBOSE</code> и только в таком порядке. В <span class="productname">PostgreSQL</span> до версии 9.0 поддерживался только синтаксис без скобок, однако в дальнейшем ожидается, что все новые параметры будут восприниматься только в скобках.</p></div><div class="refsect1" id="id-1.9.3.148.8"><h2>Параметры</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">ANALYZE</code></span></dt><dd><p>Выполнить команду и вывести фактическое время выполнения и другую статистику. По умолчанию этот параметр равен <code class="literal">FALSE</code>.</p></dd><dt><span class="term"><code class="literal">VERBOSE</code></span></dt><dd><p>Вывести дополнительную информацию о плане запроса. В частности, включить список столбцов результата для каждого узла в дереве плана, дополнить схемой имена таблиц и функций, всегда указывать для переменных в выражениях псевдоним их таблицы, а также выводить имена всех триггеров, для которых выдаётся статистика. Также для данного запроса будет выводиться идентификатор, если он был вычислен; за подробностями обратитесь к <a class="xref" href="runtime-config-statistics.html#GUC-COMPUTE-QUERY-ID">compute_query_id</a>. По умолчанию этот параметр равен <code class="literal">FALSE</code>.</p></dd><dt><span class="term"><code class="literal">COSTS</code></span></dt><dd><p>Вывести рассчитанную стоимость запуска и общую стоимость каждого узла плана, а также рассчитанное число строк и ширину каждой строки. Этот параметр по умолчанию равен <code class="literal">TRUE</code>.</p></dd><dt><span class="term"><code class="literal">SETTINGS</code></span></dt><dd><p>Вывести информацию о параметрах конфигурации. А именно, будут выведены параметры, влияющие на планирование, значения которых отличаются от стандартных значений по умолчанию. В отсутствие данного указания подразумевается <code class="literal">FALSE</code> (эта информация не выводится).</p></dd><dt><span class="term"><code class="literal">GENERIC_PLAN</code></span></dt><dd><p>Использовать операторы с шаблонами параметров в виде <code class="literal">$1</code> и создать общий план, не зависящий от значений параметров. За подробной информацией об общих планах и типах операторов, поддерживающих параметры, обратитесь к <a class="link" href="sql-prepare.html" title="PREPARE"><code class="command">PREPARE</code></a>. Этот параметр нельзя использовать с <code class="literal">ANALYZE</code>. Значение по умолчанию — <code class="literal">FALSE</code>.</p></dd><dt><span class="term"><code class="literal">BUFFERS</code></span></dt><dd><p>Включить информацию об использовании буфера. В частности, вывести число попаданий, блоков прочитанных, загрязнённых и записанных в разделяемом и локальном буфере, число прочитанных и записанных временных блоков, а также время в миллисекундах, потраченное на чтение и запись блоков файлов данных и блоков временных файлов, если включён параметр <a class="xref" href="runtime-config-statistics.html#GUC-TRACK-IO-TIMING">track_io_timing</a>. <span class="emphasis"><em>Попаданием</em></span> (hit) считается ситуация, когда требуемый блок уже находится в кеше и чтения с диска удаётся избежать. Блоки в общем буфере содержат данные обычных таблиц и индексов, в локальном — данные временных таблиц и индексов, а временные блоки предназначены для краткосрочного использования при выполнении сортировки, хеширования, материализации и подобных узлов плана. Число <span class="emphasis"><em>загрязнённых</em></span> блоков (dirtied) показывает, сколько ранее не модифицированных блоков изменила данная операция; тогда как число <span class="emphasis"><em>записанных</em></span> блоков (written) показывает, сколько ранее загрязнённых блоков данный серверный процесс вынес из кеша при обработке запроса. Значения, указываемые для узла верхнего уровня, включают значения всех его дочерних узлов. В текстовом формате выводятся только ненулевые значения. Этот параметр действует только в режиме <code class="literal">ANALYZE</code>. По умолчанию его значение равно <code class="literal">FALSE</code>.</p></dd><dt><span class="term"><code class="literal">WAL</code></span></dt><dd><p>Включить информацию о формировании записей WAL. В частности, вывести число записей, число полных образов страниц (fpi, full page images) и объём сгенерированных записей в байтах. В текстовом формате выводятся только ненулевые значения. Этот параметр может использоваться, только если также включён режим <code class="literal">ANALYZE</code>. По умолчанию он отключён (<code class="literal">FALSE</code>).</p></dd><dt><span class="term"><code class="literal">TIMING</code></span></dt><dd><p>Включить в вывод фактическое время запуска и время, затраченное на каждый узел. Постоянное чтение системных часов может значительно замедлить запрос, так что если достаточно знать фактическое число строк, имеет смысл сделать этот параметр равным <code class="literal">FALSE</code>. Время выполнения всего оператора замеряется всегда, даже когда этот параметр выключен и на уровне узлов время не подсчитывается. Этот параметр действует только в режиме <code class="literal">ANALYZE</code>. По умолчанию его значение равно <code class="literal">TRUE</code>.</p></dd><dt><span class="term"><code class="literal">SUMMARY</code></span></dt><dd><p>Включить сводку (например, суммарное время) после плана запроса. Сводка включается по умолчанию, когда используется <code class="literal">ANALYZE</code>, но этот параметр позволяет получить её и с другими вариантами команды. Время планирования в <code class="command">EXPLAIN EXECUTE</code> включает время извлечения плана из кеша и время перепланирования, если оно потребовалось.</p></dd><dt><span class="term"><code class="literal">FORMAT</code></span></dt><dd><p>Установить один из следующих форматов вывода: TEXT, XML, JSON или YAML. Последние три формата содержат ту же информацию, что и текстовый, но больше подходят для программного разбора. По умолчанию выбирается формат <code class="literal">TEXT</code>.</p></dd><dt><span class="term"><em class="replaceable"><code>boolean</code></em></span></dt><dd><p>Включает или отключает заданный параметр. Для включения параметра можно написать <code class="literal">TRUE</code>, <code class="literal">ON</code> или <code class="literal">1</code>, а для отключения — <code class="literal">FALSE</code>, <code class="literal">OFF</code> или <code class="literal">0</code>. Значение <em class="replaceable"><code>boolean</code></em> можно опустить, в этом случае подразумевается <code class="literal">TRUE</code>.</p></dd><dt><span class="term"><em class="replaceable"><code>оператор</code></em></span></dt><dd><p>Любой оператор <code class="command">SELECT</code>, <code class="command">INSERT</code>, <code class="command">UPDATE</code>, <code class="command">DELETE</code>, <code class="command">MERGE</code>, <code class="command">VALUES</code>, <code class="command">EXECUTE</code>, <code class="command">DECLARE</code>, <code class="command">CREATE TABLE AS</code> и <code class="command">CREATE MATERIALIZED VIEW AS</code>, план выполнения которого вас интересует.</p></dd></dl></div></div><div class="refsect1" id="id-1.9.3.148.9"><h2>Выводимая информация</h2><p>Результатом команды будет текстовое описание плана, выбранного для <em class="replaceable"><code>оператора</code></em>, возможно, дополненное статистикой выполнения. Представленная информация описана в <a class="xref" href="using-explain.html" title="14.1. Использование EXPLAIN">Разделе 14.1</a>.</p></div><div class="refsect1" id="id-1.9.3.148.10"><h2>Замечания</h2><p>Чтобы планировщик запросов <span class="productname">PostgreSQL</span> был достаточно информирован для эффективной оптимизации запросов, данные в <a class="link" href="catalog-pg-statistic.html" title="53.51. pg_statistic"><code class="structname">pg_statistic</code></a> должны быть актуальными для всех таблиц, задействованных в запросе. Обычно об этом автоматически заботится <a class="link" href="routine-vacuuming.html#AUTOVACUUM" title="25.1.6. Демон автоочистки">демон автоочистки</a>. Но если в таблице недавно произошли значительные изменения, может потребоваться вручную выполнить <a class="link" href="sql-analyze.html" title="ANALYZE"><code class="command">ANALYZE</code></a>, не дожидаясь, пока автоочистка обработает эти изменения.</p><p>Измеряя фактическую стоимость выполнения каждого узла в плане, текущая реализация <code class="command">EXPLAIN ANALYZE</code> привносит накладные расходы профилирования в выполнение запроса. В результате этого, при запуске запроса командой <code class="command">EXPLAIN ANALYZE</code> он может выполняться значительно дольше, чем при обычном выполнении. Объём накладных расходов зависит от природы запроса, а также от используемой платформы. Худшая ситуация наблюдается для узлов плана, которые сами по себе выполняются очень быстро, и в операционных системах, где получение текущего времени относительно длительная операция.</p></div><div class="refsect1" id="id-1.9.3.148.11"><h2>Примеры</h2><p>Получение плана простого запроса для таблицы, содержащей единственный столбец типа <code class="type">integer</code>, с 10000 строк: </p><pre class="programlisting">EXPLAIN SELECT * FROM foo;

                       QUERY PLAN
---------------------------------------------------------
 Seq Scan on foo  (cost=0.00..155.00 rows=10000 width=4)
(1 row)</pre><p>План того же запроса, но выведенный в формате JSON: </p><pre class="programlisting">EXPLAIN (FORMAT JSON) SELECT * FROM foo;
           QUERY PLAN
--------------------------------
 [                             +
   {                           +
     "Plan": {                 +
       "Node Type": "Seq Scan",+
       "Relation Name": "foo", +
       "Alias": "foo",         +
       "Startup Cost": 0.00,   +
       "Total Cost": 155.00,   +
       "Plan Rows": 10000,     +
       "Plan Width": 4         +
     }                         +
   }                           +
 ]
(1 row)</pre><p>Если в таблице есть индекс, а в запросе присутствует условие <code class="literal">WHERE</code>, для которого полезен этот индекс, <code class="command">EXPLAIN</code> может показать другой план: </p><pre class="programlisting">EXPLAIN SELECT * FROM foo WHERE i = 4;

                         QUERY PLAN
--------------------------------------------------------------
 Index Scan using fi on foo  (cost=0.00..5.98 rows=1 width=4)
   Index Cond: (i = 4)
(2 rows)</pre><p>План того же запроса, но в формате YAML: </p><pre class="programlisting">EXPLAIN (FORMAT YAML) SELECT * FROM foo WHERE i='4';
          QUERY PLAN
-------------------------------
 - Plan:                      +
     Node Type: "Index Scan"  +
     Scan Direction: "Forward"+
     Index Name: "fi"         +
     Relation Name: "foo"     +
     Alias: "foo"             +
     Startup Cost: 0.00       +
     Total Cost: 5.98         +
     Plan Rows: 1             +
     Plan Width: 4            +
     Index Cond: "(i = 4)"
(1 row)</pre><p> Рассмотрение формата XML оставлено в качестве упражнения для читателя.</p><p>План того же запроса без вывода оценок стоимости: </p><pre class="programlisting">EXPLAIN (COSTS FALSE) SELECT * FROM foo WHERE i = 4;

        QUERY PLAN
----------------------------
 Index Scan using fi on foo
   Index Cond: (i = 4)
(2 rows)</pre><p>Пример плана для запроса с агрегатной функцией: </p><pre class="programlisting">EXPLAIN SELECT sum(i) FROM foo WHERE i &lt; 10;

                             QUERY PLAN
-------------------------------------------------------------------​--
 Aggregate  (cost=23.93..23.93 rows=1 width=4)
   -&gt;  Index Scan using fi on foo  (cost=0.00..23.92 rows=6 width=4)
         Index Cond: (i &lt; 10)
(3 rows)</pre><p>Пример использования <code class="command">EXPLAIN EXECUTE</code> для отображения плана выполнения подготовленного запроса: </p><pre class="programlisting">PREPARE query(int, int) AS SELECT sum(bar) FROM test
    WHERE id &gt; $1 AND id &lt; $2
    GROUP BY foo;

EXPLAIN ANALYZE EXECUTE query(100, 200);

                                                       QUERY PLAN
-------------------------------------------------------------------​------------------------------------------------------
 HashAggregate  (cost=10.77..10.87 rows=10 width=12) (actual time=0.043..0.044 rows=10 loops=1)
   Group Key: foo
   Batches: 1  Memory Usage: 24kB
   -&gt;  Index Scan using test_pkey on test  (cost=0.29..10.27 rows=99 width=8) (actual time=0.009..0.025 rows=99 loops=1)
         Index Cond: ((id &gt; 100) AND (id &lt; 200))
 Planning Time: 0.244 ms
 Execution Time: 0.073 ms
(7 rows)</pre><p>Разумеется, конкретные числа, показанные здесь, зависят от фактического содержимого задействованных таблиц. Также учтите, что эти числа и даже выбранная стратегия выполнения запроса могут меняться от версии к версии <span class="productname">PostgreSQL</span> вследствие усовершенствования планировщика. Кроме того, команда <code class="command">ANALYZE</code> при обработке статистических данных производит случайные выборки, так что оценки стоимости могут меняться при каждом чистом запуске <code class="command">ANALYZE</code>, даже когда фактическое распределение данных в таблице не меняется.</p><p>Обратите внимание, что в предыдущем примере показан <span class="quote">«<span class="quote">специализированный</span>»</span> план для запроса <code class="command">EXECUTE</code> с определёнными значениями параметров. С помощью <code class="literal">GENERIC_PLAN</code> можно также посмотреть общий план для параметризованного запроса: </p><pre class="programlisting">EXPLAIN (GENERIC_PLAN)
  SELECT sum(bar) FROM test
    WHERE id &gt; $1 AND id &lt; $2
    GROUP BY foo;

                                  QUERY PLAN
-------------------------------------------------------------------​------------
 HashAggregate  (cost=26.79..26.89 rows=10 width=12)
   Group Key: foo
   -&gt;  Index Scan using test_pkey on test  (cost=0.29..24.29 rows=500 width=8)
         Index Cond: ((id &gt; $1) AND (id &lt; $2))
(4 rows)</pre><p> В этом случае анализатор запроса корректно предполагает, что <code class="literal">$1</code> и <code class="literal">$2</code> должны иметь тот же тип данных, что и <code class="literal">id</code>, так что отсутствие информации о типе данных из <code class="command">PREPARE</code> не представляет проблемы. В других случаях может потребоваться явно указать типы для символов параметров, что можно сделать путём приведения типов, например: </p><pre class="programlisting">EXPLAIN (GENERIC_PLAN)
  SELECT sum(bar) FROM test
    WHERE id &gt; $1::integer AND id &lt; $2::integer
    GROUP BY foo;</pre></div><div class="refsect1" id="id-1.9.3.148.12"><h2>Совместимость</h2><p>Оператор <code class="command">EXPLAIN</code> отсутствует в стандарте SQL.</p></div><div class="refsect1" id="id-1.9.3.148.13"><h2>См. также</h2><span class="simplelist"><a class="xref" href="sql-analyze.html" title="ANALYZE"><span class="refentrytitle">ANALYZE</span></a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-execute.html" title="EXECUTE">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-fetch.html" title="FETCH">След.</a></td></tr><tr><td width="40%" align="left" valign="top">EXECUTE </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> FETCH</td></tr></table></div></body></html>