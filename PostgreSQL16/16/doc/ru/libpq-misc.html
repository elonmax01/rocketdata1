<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>34.12. Функции разного назначения</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="libpq-control.html" title="34.11. Функции управления" /><link rel="next" href="libpq-notice-processing.html" title="34.13. Обработка замечаний" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">34.12. Функции разного назначения</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="libpq-control.html" title="34.11. Функции управления">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="libpq.html" title="Глава 34. libpq — библиотека для языка C">Наверх</a></td><th width="60%" align="center">Глава 34. <span class="application">libpq</span> — библиотека для языка C</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="libpq-notice-processing.html" title="34.13. Обработка замечаний">След.</a></td></tr></table><hr /></div><div class="sect1" id="LIBPQ-MISC"><div class="titlepage"><div><div><h2 class="title" style="clear: both">34.12. Функции разного назначения <a href="#LIBPQ-MISC" class="id_link">#</a></h2></div></div></div><p>Как всегда, находятся функции, которые не попадают ни в одну из категорий.</p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQFREEMEM"><span class="term"><code class="function">PQfreemem</code><a id="id-1.7.3.19.3.1.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQFREEMEM" class="id_link">#</a></dt><dd><p>Освобождает память, которую выделила <span class="application">libpq</span>. </p><pre class="synopsis">
void PQfreemem(void *ptr);
</pre><p>Освобождает память, выделенную библиотекой <span class="application">libpq</span>, а именно функциями <a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPEBYTEACONN"><code class="function">PQescapeByteaConn</code></a>, <a class="xref" href="libpq-exec.html#LIBPQ-PQESCAPEBYTEA"><code class="function">PQescapeBytea</code></a>, <a class="xref" href="libpq-exec.html#LIBPQ-PQUNESCAPEBYTEA"><code class="function">PQunescapeBytea</code></a> и <code class="function">PQnotifies</code>. Особенно важно использовать именно эту функцию, а не <code class="function">free()</code>, в Microsoft Windows. Это связано с тем, что выделение памяти в DLL и освобождение её в приложении будет работать, только если флаги многопоточной/однопоточной, выпускаемой/отладочной или статической/динамической сборки для DLL и приложения полностью совпадают. На других платформах эта функция действует так же, как стандартная библиотечная функция <code class="function">free()</code>.</p></dd><dt id="LIBPQ-PQCONNINFOFREE"><span class="term"><code class="function">PQconninfoFree</code><a id="id-1.7.3.19.3.2.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQCONNINFOFREE" class="id_link">#</a></dt><dd><p>Освобождает структуры данных, выделенные функциями <a class="xref" href="libpq-connect.html#LIBPQ-PQCONNDEFAULTS"><code class="function">PQconndefaults</code></a> и <a class="xref" href="libpq-connect.html#LIBPQ-PQCONNINFOPARSE"><code class="function">PQconninfoParse</code></a>. </p><pre class="synopsis">
void PQconninfoFree(PQconninfoOption *connOptions);
</pre><p> Если аргумент является указателем <code class="symbol">NULL</code>, операция не выполняется.</p><p>Простая функция <a class="xref" href="libpq-misc.html#LIBPQ-PQFREEMEM"><code class="function">PQfreemem</code></a> не подойдёт для этого, так как эти структуры содержат ссылки на подчинённые строки.</p></dd><dt id="LIBPQ-PQENCRYPTPASSWORDCONN"><span class="term"><code class="function">PQencryptPasswordConn</code><a id="id-1.7.3.19.3.3.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQENCRYPTPASSWORDCONN" class="id_link">#</a></dt><dd><p>Подготавливает зашифрованную форму пароля <span class="productname">PostgreSQL</span>. </p><pre class="synopsis">
char *PQencryptPasswordConn(PGconn *conn, const char *passwd, const char *user, const char *algorithm);
</pre><p> Эта функция предназначена для клиентских приложений, желающих передавать команды вида <code class="literal">ALTER USER joe PASSWORD 'pwd'</code>. В такой команде лучше не передавать исходный пароль открытым текстом, так как он может появиться в журналах команд, мониторе активности и т. д. Вместо этого воспользуйтесь данной функцией и переведите пароль в зашифрованную форму.</p><p>В аргументах <em class="parameter"><code>passwd</code></em> и <em class="parameter"><code>user</code></em> задаётся пароль в открытом виде и SQL-имя пользователя, для которого он задаётся. В аргументе <em class="parameter"><code>algorithm</code></em> задаётся алгоритм для шифрования пароля. В настоящее время поддерживаются алгоритмы <code class="literal">md5</code> и <code class="literal">scram-sha-256</code> (в качестве альтернативных обозначений <code class="literal">md5</code> для совместимости со старыми версиями сервера поддерживаются значения <code class="literal">on</code> и <code class="literal">off</code>). Заметьте, что поддержка <code class="literal">scram-sha-256</code> появилась в <span class="productname">PostgreSQL</span> версии 10 и со старыми версиями серверов этот вариант работать не будет. Если <em class="parameter"><code>algorithm</code></em> равен <code class="symbol">NULL</code>, эта функция запросит у сервера текущее значение параметра <a class="xref" href="runtime-config-connection.html#GUC-PASSWORD-ENCRYPTION">password_encryption</a>. При этом возможна блокировка и отказ при выполнении функции, если текущая транзакция прерывается или если в текущем соединении выполняется другой запрос. Если вы хотите использовать алгоритм по умолчанию для данного сервера, но при этом избежать блокировки, получите значение <code class="varname">password_encryption</code> самостоятельно до вызова <a class="xref" href="libpq-misc.html#LIBPQ-PQENCRYPTPASSWORDCONN"><code class="function">PQencryptPasswordConn</code></a> и передайте его в параметре <em class="parameter"><code>algorithm</code></em>.</p><p>Эта функция возвращает строку, выделенную функцией <code class="function">malloc</code>. Вызывающий код может рассчитывать на то, что эта строка не содержит никаких спецсимволов, требующих экранирования. Закончив работу с ней, освободите память, вызвав <a class="xref" href="libpq-misc.html#LIBPQ-PQFREEMEM"><code class="function">PQfreemem</code></a>. В случае ошибки эта функция возвращает <code class="symbol">NULL</code>, а соответствующее сообщение помещается в объект соединения.</p></dd><dt id="LIBPQ-PQENCRYPTPASSWORD"><span class="term"><code class="function">PQencryptPassword</code><a id="id-1.7.3.19.3.4.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQENCRYPTPASSWORD" class="id_link">#</a></dt><dd><p>Подготавливает зашифрованную md5 форму пароля <span class="productname">PostgreSQL</span>. </p><pre class="synopsis">
char *PQencryptPassword(const char *passwd, const char *user);
</pre><p> <a class="xref" href="libpq-misc.html#LIBPQ-PQENCRYPTPASSWORD"><code class="function">PQencryptPassword</code></a> — старая, подлежащая ликвидации версия <a class="xref" href="libpq-misc.html#LIBPQ-PQENCRYPTPASSWORDCONN"><code class="function">PQencryptPasswordConn</code></a>. Отличие состоит в том, что для <a class="xref" href="libpq-misc.html#LIBPQ-PQENCRYPTPASSWORD"><code class="function">PQencryptPassword</code></a> не требуется объект соединения, а в качестве алгоритма шифрования всегда используется <code class="literal">md5</code>.</p></dd><dt id="LIBPQ-PQMAKEEMPTYPGRESULT"><span class="term"><code class="function">PQmakeEmptyPGresult</code><a id="id-1.7.3.19.3.5.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQMAKEEMPTYPGRESULT" class="id_link">#</a></dt><dd><p>Конструирует пустой объект <code class="structname">PGresult</code> с указанным состоянием. </p><pre class="synopsis">
PGresult *PQmakeEmptyPGresult(PGconn *conn, ExecStatusType status);
</pre><p>Это внутренняя функция <span class="application">libpq</span>, выделяющая память и инициализирующая пустой объект <code class="structname">PGresult</code>. Эта функция возвращает <code class="symbol">NULL</code>, если не может выделить память. Она сделана экспортируемой, так как некоторые приложения находят полезным создавать объекты результатов (в частности, объекты с состоянием ошибки) самостоятельно. Если в <em class="parameter"><code>conn</code></em> передаётся не null и <em class="parameter"><code>status</code></em> указывает на ошибку, в <code class="structname">PGresult</code> копируется текущее сообщение об ошибке для заданного соединения. Также, если в <em class="parameter"><code>conn</code></em> передаётся не null, в <code class="structname">PGresult</code> копируются все процедуры событий, зарегистрированные для этого соединения. (При этом вызовы <code class="literal">PGEVT_RESULTCREATE</code> не выполняются; см. описание <a class="xref" href="libpq-misc.html#LIBPQ-PQFIRERESULTCREATEEVENTS"><code class="function">PQfireResultCreateEvents</code></a>.) Заметьте, что в конце для этого объекта следует вызвать <a class="xref" href="libpq-exec.html#LIBPQ-PQCLEAR"><code class="function">PQclear</code></a>, как и для объекта <code class="structname">PGresult</code>, возвращённого самой библиотекой <span class="application">libpq</span>.</p></dd><dt id="LIBPQ-PQFIRERESULTCREATEEVENTS"><span class="term"><code class="function">PQfireResultCreateEvents</code><a id="id-1.7.3.19.3.6.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQFIRERESULTCREATEEVENTS" class="id_link">#</a></dt><dd><p>Вызывает событие <code class="literal">PGEVT_RESULTCREATE</code> (см. <a class="xref" href="libpq-events.html" title="34.14. Система событий">Раздел 34.14</a>) для каждой процедуры событий, зарегистрированной в объекте <code class="structname">PGresult</code>. Возвращает ненулевое значение в случае успеха или ноль в случае ошибки в одной из процедур. </p><pre class="synopsis">
int PQfireResultCreateEvents(PGconn *conn, PGresult *res);
</pre><p>Аргумент <code class="literal">conn</code> передаётся процедурам событий, но непосредственно не используется. Он может быть равен <code class="symbol">NULL</code>, если он не нужен процедурам событий.</p><p>Процедуры событий, уже получившие событие <code class="literal">PGEVT_RESULTCREATE</code> или <code class="literal">PGEVT_RESULTCOPY</code> для этого объекта, больше не вызываются.</p><p>Основная причина отделения этой функции от <a class="xref" href="libpq-misc.html#LIBPQ-PQMAKEEMPTYPGRESULT"><code class="function">PQmakeEmptyPGresult</code></a> в том, что часто требуется создать объект <code class="structname">PGresult</code> и наполнить его данными, прежде чем вызывать процедуры событий.</p></dd><dt id="LIBPQ-PQCOPYRESULT"><span class="term"><code class="function">PQcopyResult</code><a id="id-1.7.3.19.3.7.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQCOPYRESULT" class="id_link">#</a></dt><dd><p>Создаёт копию объекта <code class="structname">PGresult</code>. Эта копия никак не связана с исходным результатом и поэтому, когда она становится не нужна, необходимо вызвать <a class="xref" href="libpq-exec.html#LIBPQ-PQCLEAR"><code class="function">PQclear</code></a>. Если функция завершается ошибкой, она возвращает <code class="symbol">NULL</code>. </p><pre class="synopsis">
PGresult *PQcopyResult(const PGresult *src, int flags);
</pre><p>Создаваемая копия не будет точной. В возвращаемый результат всегда помещается состояние <code class="literal">PGRES_TUPLES_OK</code> и в него не копируются никакие сообщения об ошибках из исходного объекта. (Однако в него копируется строка состояния команды.) Что ещё в него будет копироваться, определяет аргумент <em class="parameter"><code>flags</code></em>, в котором складываются несколько флагов. Флаг <code class="literal">PG_COPYRES_ATTRS</code> включает копирование атрибутов исходного объекта (определений столбцов), а флаг <code class="literal">PG_COPYRES_TUPLES</code> включает копирование кортежей из исходного объекта (при этом также копируются и атрибуты.) Флаг <code class="literal">PG_COPYRES_NOTICEHOOKS</code> включает копирование обработчиков замечаний, а флаг <code class="literal">PG_COPYRES_EVENTS</code> — событий из исходного объекта результата. (Но любые данные, связанные с экземпляром исходного объекта, не копируются.) Процедуры событий получают события <code class="literal">PGEVT_RESULTCOPY</code>.</p></dd><dt id="LIBPQ-PQSETRESULTATTRS"><span class="term"><code class="function">PQsetResultAttrs</code><a id="id-1.7.3.19.3.8.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQSETRESULTATTRS" class="id_link">#</a></dt><dd><p>Устанавливает атрибуты объекта <code class="structname">PGresult</code>. </p><pre class="synopsis">
int PQsetResultAttrs(PGresult *res, int numAttributes, PGresAttDesc *attDescs);
</pre><p>Предоставленная структура <em class="parameter"><code>attDescs</code></em> копируется в результат. Если указатель <em class="parameter"><code>attDescs</code></em> равен <code class="symbol">NULL</code> или <em class="parameter"><code>numAttributes</code></em> меньше одного, запрос игнорируется и функция выполняется без ошибки. Если <em class="parameter"><code>res</code></em> уже содержит атрибуты, функция завершается ошибкой. В случае ошибки функция возвращает ноль, а в обратном случае — ненулевое значение.</p></dd><dt id="LIBPQ-PQSETVALUE"><span class="term"><code class="function">PQsetvalue</code><a id="id-1.7.3.19.3.9.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQSETVALUE" class="id_link">#</a></dt><dd><p>Устанавливает значение поля кортежа в объекте <code class="structname">PGresult</code>. </p><pre class="synopsis">
int PQsetvalue(PGresult *res, int tup_num, int field_num, char *value, int len);
</pre><p>Эта функция автоматически увеличивает внутренний массив кортежей при необходимости. Однако значение <em class="parameter"><code>tup_num</code></em> должно быть меньше или равно <a class="xref" href="libpq-exec.html#LIBPQ-PQNTUPLES"><code class="function">PQntuples</code></a>, что означает, что эта функция может увеличивать массив кортежей только на один кортеж. Но в существующем кортеже любые поля могут изменяться в любом порядке. Если значение в поле с номером <em class="parameter"><code>field_num</code></em> уже существует, оно будет перезаписано. Если <em class="parameter"><code>len</code></em> равно -1 или <em class="parameter"><code>value</code></em> равно <code class="symbol">NULL</code>, в поле будет записано значение SQL NULL. Устанавливаемое значение (<em class="parameter"><code>value</code></em>) копируется в закрытую область объекта результата, так что от него можно избавиться после завершения функции. Если функция завершается ошибкой, она возвращает ноль, а в обратном случае — ненулевое значение.</p></dd><dt id="LIBPQ-PQRESULTALLOC"><span class="term"><code class="function">PQresultAlloc</code><a id="id-1.7.3.19.3.10.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQRESULTALLOC" class="id_link">#</a></dt><dd><p>Выделяет подчинённую область памяти для объекта <code class="structname">PGresult</code>. </p><pre class="synopsis">
void *PQresultAlloc(PGresult *res, size_t nBytes);
</pre><p>Любая память, выделенная этой функцией, будет освобождена при очистке объекта <em class="parameter"><code>res</code></em>. В случае ошибки эта функция возвращает <code class="symbol">NULL</code>. Результат гарантированно выравнивается должным образом для любого типа данных, как и при <code class="function">malloc</code>.</p></dd><dt id="LIBPQ-PQRESULTMEMORYSIZE"><span class="term"><code class="function">PQresultMemorySize</code><a id="id-1.7.3.19.3.11.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQRESULTMEMORYSIZE" class="id_link">#</a></dt><dd><p>Выдаёт объём памяти (в байтах), выделенной для объекта <code class="structname">PGresult</code>. </p><pre class="synopsis">
size_t PQresultMemorySize(const PGresult *res);
</pre><p>Этот объём равен сумме размеров всех запросов <code class="function">malloc</code>, связанных с данным объектом <code class="structname">PGresult</code>, то есть это общий объём памяти, который будет освобождён функцией <a class="xref" href="libpq-exec.html#LIBPQ-PQCLEAR"><code class="function">PQclear</code></a>. Данная информация может быть полезна для управления потреблением памяти.</p></dd><dt id="LIBPQ-PQLIBVERSION"><span class="term"><code class="function">PQlibVersion</code><a id="id-1.7.3.19.3.12.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQLIBVERSION" class="id_link">#</a></dt><dd><p>Возвращает версию используемой библиотеки <span class="productname">libpq</span>. </p><pre class="synopsis">
int PQlibVersion(void);
</pre><p>По результату этой функции можно во время выполнения определить, предоставляется ли определённая функциональность загруженной в данный момент версией libpq. Эта функция может использоваться, например, чтобы понять, какие параметры соединения может принять <a class="xref" href="libpq-connect.html#LIBPQ-PQCONNECTDB"><code class="function">PQconnectdb</code></a>.</p><p>Это число формируется в результате умножения номера основной версии библиотеки на 10000 и добавления номера дополнительной версии. Например, для версии 10.1 будет выдано 100001, а для версии 11.0 — 110000.</p><p>До версии 10, в <span class="productname">PostgreSQL</span> номера версий образовывались из трёх чисел, первые два из которых представляли основную версию. Для таких версий <a class="xref" href="libpq-misc.html#LIBPQ-PQLIBVERSION"><code class="function">PQlibVersion</code></a> отводит на каждое число по две цифры; например, для версии 9.1.5 будет выдано 90105, а для версии 9.2.0 — 90200.</p><p>Таким образом, чтобы получить логический номер версии для определения доступности функционала, приложения должны разделить результат <a class="xref" href="libpq-misc.html#LIBPQ-PQLIBVERSION"><code class="function">PQlibVersion</code></a> на 100, а не на 10000. Во всех сериях номера дополнительных (корректирующих) выпусков различаются только в двух последних цифрах.</p><div class="note"><h3 class="title">Примечание</h3><p>Эта функция появилась в <span class="productname">PostgreSQL</span> версии 9.1, поэтому с её помощью нельзя проверить функциональность предыдущих версий, так как при вызове её будет создана зависимость от версии 9.1 или новее.</p></div></dd></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="libpq-control.html" title="34.11. Функции управления">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="libpq.html" title="Глава 34. libpq — библиотека для языка C">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="libpq-notice-processing.html" title="34.13. Обработка замечаний">След.</a></td></tr><tr><td width="40%" align="left" valign="top">34.11. Функции управления </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 34.13. Обработка замечаний</td></tr></table></div></body></html>