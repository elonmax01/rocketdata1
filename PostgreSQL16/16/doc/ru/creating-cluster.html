<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>19.2. Создание кластера баз данных</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="postgres-user.html" title="19.1. Учётная запись пользователя PostgreSQL" /><link rel="next" href="server-start.html" title="19.3. Запуск сервера баз данных" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">19.2. Создание кластера баз данных</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="postgres-user.html" title="19.1. Учётная запись пользователя PostgreSQL">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="runtime.html" title="Глава 19. Подготовка к работе и сопровождение сервера">Наверх</a></td><th width="60%" align="center">Глава 19. Подготовка к работе и сопровождение сервера</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="server-start.html" title="19.3. Запуск сервера баз данных">След.</a></td></tr></table><hr /></div><div class="sect1" id="CREATING-CLUSTER"><div class="titlepage"><div><div><h2 class="title" style="clear: both">19.2. Создание кластера баз данных <a href="#CREATING-CLUSTER" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="creating-cluster.html#CREATING-CLUSTER-MOUNT-POINTS">19.2.1. Использование дополнительных файловых систем</a></span></dt><dt><span class="sect2"><a href="creating-cluster.html#CREATING-CLUSTER-FILESYSTEM">19.2.2. Файловые системы</a></span></dt></dl></div><a id="id-1.6.6.5.2" class="indexterm"></a><a id="id-1.6.6.5.3" class="indexterm"></a><p>Прежде чем вы сможете работать с базами данных, вы должны проинициализировать область хранения баз данных на диске. Мы называем это хранилище <em class="firstterm">кластером баз данных</em>. (В <acronym class="acronym">SQL</acronym> применяется термин «кластер каталога».) Кластер баз данных представляет собой набор баз, управляемых одним экземпляром работающего сервера. После инициализации кластер будет содержать базу данных с именем <code class="literal">postgres</code>, предназначенную для использования по умолчанию утилитами, пользователями и сторонними приложениями. Сам сервер баз данных не требует наличия базы <code class="literal">postgres</code>, но многие внешние вспомогательные программы рассчитывают на её существование. При инициализации в каждом кластере создаются ещё две базы: <code class="literal">template1</code> и <code class="literal">template0</code>. Как можно понять из их имён, они применяются впоследствии в качестве шаблонов создаваемых баз данных; использовать их в качестве рабочих не следует. (За информацией о создании новых баз данных в кластере обратитесь к <a class="xref" href="managing-databases.html" title="Глава 23. Управление базами данных">Главе 23</a>.)</p><p>С точки зрения файловой системы кластер баз данных представляет собой один каталог, в котором будут храниться все данные. Мы называем его <em class="firstterm">каталогом данных</em> или <em class="firstterm">областью данных</em>. Где именно хранить данные, вы абсолютно свободно можете выбирать сами. Какого-либо стандартного пути не существует, но часто данные размещаются в <code class="filename">/usr/local/pgsql/data</code> или в <code class="filename">/var/lib/pgsql/data</code>. Прежде чем с каталогом данных можно будет работать, его нужно инициализировать, используя программу <a class="xref" href="app-initdb.html" title="initdb"><span class="refentrytitle"><span class="application">initdb</span></span></a><a id="id-1.6.6.5.5.6" class="indexterm"></a>, которая устанавливается в составе <span class="productname">PostgreSQL</span>.</p><p>Если вы используете <span class="productname">PostgreSQL</span> в виде готового продукта, в нём могут быть приняты определённые соглашения о расположении каталога данных, и может также предоставляться скрипт для создания этого каталога данных. В этом случае следует воспользоваться этим скриптом, а не запускать непосредственно <code class="command">initdb</code>. За подробностями обратитесь к документации используемого вами продукта.</p><p>Чтобы инициализировать кластер баз данных вручную, запустите <code class="command">initdb</code>, передав в параметре <code class="option">-D</code> путь к желаемому расположению данных кластера в файловой системе, например: </p><pre class="screen">
<code class="prompt">$</code> <strong class="userinput"><code>initdb -D /usr/local/pgsql/data</code></strong>
</pre><p> Заметьте, что эту команду нужно выполнять от имени пользователя <span class="productname">PostgreSQL</span>, о котором говорится в предыдущем разделе.</p><div class="tip"><h3 class="title">Подсказка</h3><p>В качестве альтернативы параметра <code class="option">-D</code> можно установить переменную окружения <code class="envar">PGDATA</code>. <a id="id-1.6.6.5.8.1.3" class="indexterm"></a></p></div><p>Также можно запустить команду <code class="command">initdb</code>, воспользовавшись программой <a class="xref" href="app-pg-ctl.html" title="pg_ctl"><span class="refentrytitle"><span class="application">pg_ctl</span></span></a> <a id="id-1.6.6.5.9.3" class="indexterm"></a>, примерно так: </p><pre class="screen">
<code class="prompt">$</code> <strong class="userinput"><code>pg_ctl -D /usr/local/pgsql/data initdb</code></strong>
</pre><p> Этот вариант может быть удобнее, если вы используете <code class="command">pg_ctl</code> для запуска и остановки сервера (см. <a class="xref" href="server-start.html" title="19.3. Запуск сервера баз данных">Раздел 19.3</a>), так как <code class="command">pg_ctl</code> будет единственной командой, с помощью которой вы будете управлять экземпляром сервера баз данных.</p><p>Команда <code class="command">initdb</code> попытается создать указанный вами каталог, если он не существует. Конечно, она не сможет это сделать, если <code class="command">initdb</code> не будет разрешено записывать в родительский каталог. Вообще рекомендуется, чтобы пользователь <span class="productname">PostgreSQL</span> был владельцем не только каталога данных, но и родительского каталога, так что такой проблемы быть не должно. Если же и нужный родительский каталог не существует, вам нужно будет сначала создать его, используя права root, если вышестоящий каталог защищён от записи. Таким образом, процедура может быть такой: </p><pre class="screen">
root# <strong class="userinput"><code>mkdir /usr/local/pgsql</code></strong>
root# <strong class="userinput"><code>chown postgres /usr/local/pgsql</code></strong>
root# <strong class="userinput"><code>su postgres</code></strong>
postgres$ <strong class="userinput"><code>initdb -D /usr/local/pgsql/data</code></strong>
</pre><p>Команда <code class="command">initdb</code> не будет работать, если указанный каталог данных уже существует и содержит файлы; это мера предохранения от случайной перезаписи существующей инсталляции.</p><p>Так как каталог данных содержит все данные базы, очень важно защитить его от неавторизованного доступа. Для этого <code class="command">initdb</code> лишает прав доступа к нему всех пользователей, кроме пользователя <span class="productname">PostgreSQL</span> и, возможно, его группы. Если группе разрешается доступ, то только для чтения. Это позволяет непривилегированному пользователю, входящему в одну группу с владельцем кластера, делать резервные копии данных кластера или выполнять другие операции, для которых достаточно доступа только для чтения.</p><p>Заметьте, чтобы корректно разрешить или запретить доступ группы к данным существующего кластера, необходимо выключить кластер и установить соответствующий режим для всех каталогов и файлов до запуска <span class="productname">PostgreSQL</span>. В противном случае в каталоге данных возможно смешение режимов. Для кластеров, к которым имеет доступ только владелец, требуется установить режим <code class="literal">0700</code> для каталогов и <code class="literal">0600</code> для файлов, а для кластеров, в которых также разрешается чтение группой, режим <code class="literal">0750</code> для каталогов и <code class="literal">0640</code> для файлов.</p><p>Однако даже когда содержимое каталога защищено, если проверка подлинности клиентов настроена по умолчанию, любой локальный пользователь может подключиться к базе данных и даже стать суперпользователем. Если вы не доверяете другим локальным пользователям, мы рекомендуем использовать один из параметров команды <code class="command">initdb</code>: <code class="option">-W</code>, <code class="option">--pwprompt</code> или <code class="option">--pwfile</code>, — и назначить пароль суперпользователя баз данных. <a id="id-1.6.6.5.14.5" class="indexterm"></a> Кроме того, воспользуйтесь параметром <code class="option">-A scram-sha-256</code>, чтобы отключить разрешённый по умолчанию режим аутентификации <code class="literal">trust</code>; либо измените сгенерированный файл <code class="filename">pg_hba.conf</code> после выполнения <code class="command">initdb</code>, но <span class="emphasis"><em>перед</em></span> тем, как запустить сервер в первый раз. (Возможны и другие разумные подходы — применить режим проверки подлинности <code class="literal">peer</code> или ограничить подключения на уровне файловой системы. За дополнительными сведениями обратитесь к <a class="xref" href="client-authentication.html" title="Глава 21. Аутентификация клиентского приложения">Главе 21</a>.)</p><p>Команда <code class="command">initdb</code> также устанавливает для кластера баз данных локаль <a id="id-1.6.6.5.15.2" class="indexterm"></a> по умолчанию. Обычно она просто берёт параметры локали из текущего окружения и применяет их к инициализируемой базе данных. Однако можно выбрать и другую локаль для базы данных; за дополнительной информацией обратитесь к <a class="xref" href="locale.html" title="24.1. Поддержка языковых стандартов">Разделу 24.1</a>. Команда <code class="command">initdb</code> задаёт порядок сортировки по умолчанию для применения в определённом кластере баз данных, и хотя новые базы данных могут создаваться с иным порядком сортировки, порядок в базах-шаблонах, создаваемых initdb, можно изменить, только если удалить и пересоздать их. Также учтите, что при использовании локалей, отличных от <code class="literal">C</code> и <code class="literal">POSIX</code>, возможно снижение производительности. Поэтому важно правильно выбрать локаль с самого начала.</p><p>Команда <code class="command">initdb</code> также задаёт кодировку символов по умолчанию для кластера баз данных. Обычно она должна соответствовать кодировке локали. За подробностями обратитесь к <a class="xref" href="multibyte.html" title="24.3. Поддержка кодировок">Разделу 24.3</a>.</p><p>Для локалей, отличных от <code class="literal">C</code> и <code class="literal">POSIX</code>, порядок сортировки символов зависит от системной библиотеки локализации, а он, в свою очередь, влияет на порядок ключей в индексах. Поэтому кластер нельзя перевести на несовместимую версию библиотеки ни путём восстановления снимка, ни через двоичную репликацию, ни перейдя на другую операционную систему или обновив её версию.</p><div class="sect2" id="CREATING-CLUSTER-MOUNT-POINTS"><div class="titlepage"><div><div><h3 class="title">19.2.1. Использование дополнительных файловых систем <a href="#CREATING-CLUSTER-MOUNT-POINTS" class="id_link">#</a></h3></div></div></div><a id="id-1.6.6.5.18.2" class="indexterm"></a><p>Во многих инсталляциях кластеры баз данных создаются не в <span class="quote">«<span class="quote">корневом</span>»</span> томе, а в отдельных файловых системах (томах). Если вы решите сделать так же, то не следует выбирать в качестве каталога данных самый верхний каталог дополнительного тома (точку монтирования). Лучше всего создать внутри каталога точки монтирования каталог, принадлежащий пользователю <span class="productname">PostgreSQL</span>, а затем создать внутри него каталог данных. Это исключит проблемы с разрешениями, особенно для таких операций, как <span class="application">pg_upgrade</span>, и при этом гарантирует чистое поведение в случае, если дополнительный том окажется отключён.</p></div><div class="sect2" id="CREATING-CLUSTER-FILESYSTEM"><div class="titlepage"><div><div><h3 class="title">19.2.2. Файловые системы <a href="#CREATING-CLUSTER-FILESYSTEM" class="id_link">#</a></h3></div></div></div><p>Вообще говоря, для PostgreSQL может использоваться любая файловая система с семантикой POSIX. Пользователи предпочитают различные файловые системы по самым разным причинам, в частности, по соображениям производительности, изученности или поддержки поставщиком. Как показывает практика, в результате лишь смены файловой системы или корректировки её параметров при прочих равных не следует ожидать значительного изменения производительности или поведения.</p><div class="sect3" id="CREATING-CLUSTER-NFS"><div class="titlepage"><div><div><h4 class="title">19.2.2.1. NFS <a href="#CREATING-CLUSTER-NFS" class="id_link">#</a></h4></div></div></div><a id="id-1.6.6.5.19.3.2" class="indexterm"></a><p>Каталог данных <span class="productname">PostgreSQL</span> может размещаться и в файловой системе <acronym class="acronym">NFS</acronym>. <span class="productname">PostgreSQL</span> не подстраивается специально под <acronym class="acronym">NFS</acronym>, что означает, что с <acronym class="acronym">NFS</acronym> он работает точно так же, как и с локально подключёнными устройствами. <span class="productname">PostgreSQL</span> не использует такую функциональность файловых систем, которая имеет свои особенности в <acronym class="acronym">NFS</acronym>, например блокировки файлов.</p><p>Единственное убедительное требование — используя <acronym class="acronym">NFS</acronym> c <span class="productname">PostgreSQL</span>, монтируйте эту файловую систему в режиме <code class="literal">hard</code>. При использовании режима <code class="literal">hard</code> процессы могут <span class="quote">«<span class="quote">зависать</span>»</span> на неопределённое время в случае сетевых проблем, поэтому могут потребоваться особые меры контроля. В режиме <code class="literal">soft</code> системные вызовы будут прерываться в случаях перебоев в сети, но <span class="productname">PostgreSQL</span> не повторяет вызовы, прерванные таким образом, и это будет проявляться в ошибках ввода/вывода.</p><p>Использовать параметр монтирования <code class="literal">sync</code> не обязательно. Поведения режима <code class="literal">async</code> достаточно, так как <span class="productname">PostgreSQL</span> вызывает <code class="literal">fsync</code> в нужные моменты для сброса кеша записи (так же, как и с локальной файловой системой). Однако параметр <code class="literal">sync</code> настоятельно рекомендуется использовать при экспортировании файловой системы на <span class="emphasis"><em>сервере</em></span> NFS в тех ОС, где он поддерживается (в основном это касается Linux). В противном случае не гарантируется, что в результате выполнения <code class="literal">fsync</code> или аналогичного вызова NFS-клиентом данные действительно окажутся в надёжном хранилище на сервере, вследствие чего возможно повреждение данных, как и при выключенном параметре <a class="xref" href="runtime-config-wal.html#GUC-FSYNC">fsync</a>. Значения по умолчанию параметров монтирования и экспортирования меняются от производителя к производителю и от версии к версии, поэтому рекомендуется перепроверить их или, возможно, явно задать нужные значения во избежание неоднозначности.</p><p>В некоторых случаях внешнее устройство хранение может быть подключено по NFS или посредством низкоуровневого протокола, например iSCSI. В последнем случае такое хранилище представляется в виде блочного устройства, и на нём можно создать любую файловую систему. При этом администратору не придётся иметь дело со странностями NFS, но надо понимать, что сложности управления удалённым хранилищем в таком случае просто перемещаются на другие уровни.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="postgres-user.html" title="19.1. Учётная запись пользователя PostgreSQL">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="runtime.html" title="Глава 19. Подготовка к работе и сопровождение сервера">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="server-start.html" title="19.3. Запуск сервера баз данных">След.</a></td></tr><tr><td width="40%" align="left" valign="top">19.1. Учётная запись пользователя <span class="productname">PostgreSQL</span> </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 19.3. Запуск сервера баз данных</td></tr></table></div></body></html>