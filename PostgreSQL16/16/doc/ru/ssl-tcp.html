<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>19.9. Защита соединений TCP/IP с применением SSL</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="encryption-options.html" title="19.8. Возможности шифрования" /><link rel="next" href="gssapi-enc.html" title="19.10. Защита соединений TCP/IP с применением GSSAPI" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">19.9. Защита соединений TCP/IP с применением SSL</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="encryption-options.html" title="19.8. Возможности шифрования">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="runtime.html" title="Глава 19. Подготовка к работе и сопровождение сервера">Наверх</a></td><th width="60%" align="center">Глава 19. Подготовка к работе и сопровождение сервера</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="gssapi-enc.html" title="19.10. Защита соединений TCP/IP с применением GSSAPI">След.</a></td></tr></table><hr /></div><div class="sect1" id="SSL-TCP"><div class="titlepage"><div><div><h2 class="title" style="clear: both">19.9. Защита соединений TCP/IP с применением SSL <a href="#SSL-TCP" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="ssl-tcp.html#SSL-SETUP">19.9.1. Базовая настройка</a></span></dt><dt><span class="sect2"><a href="ssl-tcp.html#SSL-OPENSSL-CONFIG">19.9.2. Конфигурация OpenSSL</a></span></dt><dt><span class="sect2"><a href="ssl-tcp.html#SSL-CLIENT-CERTIFICATES">19.9.3. Использование клиентских сертификатов</a></span></dt><dt><span class="sect2"><a href="ssl-tcp.html#SSL-SERVER-FILES">19.9.4. Файлы, используемые SSL-сервером</a></span></dt><dt><span class="sect2"><a href="ssl-tcp.html#SSL-CERTIFICATE-CREATION">19.9.5. Создание сертификатов</a></span></dt></dl></div><a id="id-1.6.6.12.2" class="indexterm"></a><p>В <span class="productname">PostgreSQL</span> встроена поддержка <acronym class="acronym">SSL</acronym> для шифрования трафика между клиентом и сервером, что повышает уровень безопасности системы. Для использования этой возможности необходимо, чтобы и на сервере, и на клиенте был установлен <span class="productname">OpenSSL</span>, и поддержка <acronym class="acronym">SSL</acronym> была разрешена в <span class="productname">PostgreSQL</span> при сборке (см. <a class="xref" href="installation.html" title="Глава 17. Установка из исходного кода">Главу 17</a>).</p><p>Термины <acronym class="acronym">SSL</acronym> и <acronym class="acronym">TLS</acronym> часто используются взаимозаменяемо для обозначения безопасного зашифрованного соединения по протоколу <acronym class="acronym">TLS</acronym>. Хотя <acronym class="acronym">SSL</acronym>-протоколы, являющиеся предшественниками <acronym class="acronym">TLS</acronym>-протоколов, уже не поддерживаются, термин <acronym class="acronym">SSL</acronym> всё ещё используется. В <span class="productname">PostgreSQL</span> термины <acronym class="acronym">SSL</acronym> и <acronym class="acronym">TLS</acronym> взаимозаменяемы.</p><div class="sect2" id="SSL-SETUP"><div class="titlepage"><div><div><h3 class="title">19.9.1. Базовая настройка <a href="#SSL-SETUP" class="id_link">#</a></h3></div></div></div><p>Когда сервер <span class="productname">PostgreSQL</span> скомпилирован с <acronym class="acronym">SSL</acronym>, его можно запустить с включённой поддержкой зашифрованных соединений по протоколам <acronym class="acronym">TLS</acronym>, задав в <code class="filename">postgresql.conf</code> для параметра <a class="xref" href="runtime-config-connection.html#GUC-SSL">ssl</a> значение <code class="literal">on</code>. Запущенный сервер будет принимать как обычные, так и <acronym class="acronym">SSL</acronym>-подключения в одном порту TCP и будет согласовывать использование <acronym class="acronym">SSL</acronym> с каждым клиентом. По умолчанию клиент выбирает режим подключения сам; как настроить сервер, чтобы он требовал использования только <acronym class="acronym">SSL</acronym> для всех или некоторых подключений, вы можете узнать в <a class="xref" href="auth-pg-hba-conf.html" title="21.1. Файл pg_hba.conf">Разделе 21.1</a>.</p><p>Чтобы сервер мог работать в режиме <acronym class="acronym">SSL</acronym>, ему необходимы файлы с сертификатом сервера и закрытым ключом. По умолчанию это должны быть файлы <code class="filename">server.crt</code> и <code class="filename">server.key</code>, соответственно, расположенные в каталоге данных, но можно использовать и другие имена и местоположения файлов, задав их в конфигурационных параметрах <a class="xref" href="runtime-config-connection.html#GUC-SSL-CERT-FILE">ssl_cert_file</a> и <a class="xref" href="runtime-config-connection.html#GUC-SSL-KEY-FILE">ssl_key_file</a>.</p><p>В Unix-подобных системах к файлу <code class="filename">server.key</code> должен быть запрещён любой доступ группы и всех остальных; чтобы установить такое ограничение, выполните <code class="command">chmod 0600 server.key</code>. Возможен и другой вариант, когда этим файлом владеет root, а группа имеет доступ на чтение (то есть, маска разрешений <code class="literal">0640</code>). Данный вариант предназначен для систем, в которых файлами сертификатов и ключей управляет сама операционная система. В этом случае пользователь, запускающий сервер <span class="productname">PostgreSQL</span>, должен быть членом группы, имеющей доступ к указанным файлам сертификата и ключа.</p><p>Если к каталогу данных разрешён доступ группы, файлы сертификатов должны размещаться вне этого каталога для удовлетворения озвученных выше требований безопасности. Вообще говоря, доступ группы разрешается для того, чтобы непривилегированный пользователь мог производить резервное копирование базы данных, и в этом случае средство резервного копирования не сможет прочитать файлы сертификатов, что скорее всего приведёт к ошибке.</p><p>Если закрытый ключ защищён паролем, сервер спросит этот пароль и не будет запускаться, пока он не будет введён. По умолчанию использование такого пароля лишает возможности изменять конфигурацию SSL без перезагрузки сервера, однако параметр <a class="xref" href="runtime-config-connection.html#GUC-SSL-PASSPHRASE-COMMAND-SUPPORTS-RELOAD">ssl_passphrase_command_supports_reload</a> при некоторых условиях позволяет делать это. Более того, закрытые ключи, защищённые паролем, не годятся для использования в Windows.</p><p>Первым сертификатом в <code class="filename">server.crt</code> должен быть сертификат сервера, так как он должен соответствовать закрытому ключу сервера. В этот файл также могут быть добавлены сертификаты <span class="quote">«<span class="quote">промежуточных</span>»</span> центров сертификации. Это избавляет от необходимости хранить все промежуточные сертификаты на клиентах, при условии, что корневой и промежуточные сертификаты были созданы с расширениями <code class="literal">v3_ca</code>. (При этом в основных ограничениях сертификата устанавливается свойство <code class="literal">CA</code>, равное <code class="literal">true</code>.) Это также упрощает управление промежуточными сертификатами с истекающим сроком.</p><p>Добавлять корневой сертификат в <code class="filename">server.crt</code> нет необходимости. Вместо этого клиенты должны иметь этот сертификат в цепочке сертификатов сервера.</p></div><div class="sect2" id="SSL-OPENSSL-CONFIG"><div class="titlepage"><div><div><h3 class="title">19.9.2. Конфигурация OpenSSL <a href="#SSL-OPENSSL-CONFIG" class="id_link">#</a></h3></div></div></div><p><span class="productname">PostgreSQL</span> читает системный файл конфигурации <span class="productname">OpenSSL</span>. По умолчанию этот файл называется <code class="filename">openssl.cnf</code> и находится в каталоге, который сообщает команда <code class="literal">openssl version -d</code>. Если требуется указать другое расположение файла конфигурации, его можно задать в переменной окружения <code class="envar">OPENSSL_CONF</code>.</p><p><span class="productname">OpenSSL</span> предоставляет широкий выбор шифров и алгоритмов аутентификации разной защищённости. Хотя список шифров может быть задан непосредственно в файле конфигурации <span class="productname">OpenSSL</span>, можно задать отдельные шифры именно для сервера баз данных, указав их в параметре <a class="xref" href="runtime-config-connection.html#GUC-SSL-CIPHERS">ssl_ciphers</a> в <code class="filename">postgresql.conf</code>.</p><div class="note"><h3 class="title">Примечание</h3><p>Накладные расходы, связанные с шифрованием, в принципе можно исключить, ограничившись только проверкой подлинности, то есть применяя шифр <code class="literal">NULL-SHA</code> или <code class="literal">NULL-MD5</code>. Однако в этом случае посредник сможет пропускать через себя и читать весь трафик между клиентом и сервером. Кроме того, шифрование привносит минимальную дополнительную нагрузку по сравнению с проверкой подлинности. По этим причинам использовать шифры NULL не рекомендуется.</p></div></div><div class="sect2" id="SSL-CLIENT-CERTIFICATES"><div class="titlepage"><div><div><h3 class="title">19.9.3. Использование клиентских сертификатов <a href="#SSL-CLIENT-CERTIFICATES" class="id_link">#</a></h3></div></div></div><p>Чтобы клиенты должны были предоставлять серверу доверенные сертификаты, поместите сертификаты корневых центров сертификации (<acronym class="acronym">ЦС</acronym>), которым вы доверяете, в файл в каталоге данных, укажите в параметре <a class="xref" href="runtime-config-connection.html#GUC-SSL-CA-FILE">ssl_ca_file</a> в <code class="filename">postgresql.conf</code> имя этого файла и добавьте вариант аутентификации <code class="literal">clientcert=verify-ca</code> или <code class="literal">clientcert=verify-full</code> в соответствующие строки <code class="literal">hostssl</code> в <code class="filename">pg_hba.conf</code>. В результате от клиента в процессе установления SSL-подключения будет затребован сертификат. (Как настроить сертификаты на стороне клиента, описывается в <a class="xref" href="libpq-ssl.html" title="34.19. Поддержка SSL">Разделе 34.19</a>.)</p><p>Для записи <code class="literal">hostssl</code> с указанием <code class="literal">clientcert=verify-ca</code> сервер будет проверять, подписан ли сертификат клиента доверенным для него центром сертификации. Для указания <code class="literal">clientcert=verify-full</code> сервер не только проверяет сертификат по цепочке доверия, но и сверяет имя пользователя или имя, сопоставленное ему, с общим именем (<code class="literal">cn</code>, Common Name), указанным в представленном сертификате. Заметьте, что цепочка доверия для сертификата при использовании метода аутентификации <code class="literal">cert</code> проверяется всегда (см. <a class="xref" href="auth-cert.html" title="21.12. Аутентификация по сертификату">Раздел 21.12</a>).</p><p>Промежуточные сертификаты, которые составляют цепочку с существующими корневыми сертификатами, можно также включить в файл <a class="xref" href="runtime-config-connection.html#GUC-SSL-CA-FILE">ssl_ca_file</a>, если вы не хотите хранить их на стороне клиента (предполагается, что корневой и промежуточный сертификаты были созданы с расширениями <code class="literal">v3_ca</code>). Если установлен параметр <a class="xref" href="runtime-config-connection.html#GUC-SSL-CRL-FILE">ssl_crl_file</a> или <a class="xref" href="runtime-config-connection.html#GUC-SSL-CRL-DIR">ssl_crl_dir</a>, также проверяются списки отзыва сертификатов (Certificate Revocation List, CRL).</p><p>Параметр аутентификации <code class="literal">clientcert</code> можно использовать с любым методом проверки подлинности, но только в строках <code class="filename">pg_hba.conf</code> типа <code class="literal">hostssl</code>. Когда <code class="literal">clientcert</code> не задан, сервер проверяет клиентский сертификат по своему списку ЦС, только если сертификат предоставлен и этот список определён.</p><p>Есть два способа потребовать от пользователей предоставления сертификата при подключении.</p><p>Первый вариант заключается в использовании метода аутентификации <code class="literal">cert</code> в записях <code class="literal">hostssl</code> в <code class="filename">pg_hba.conf</code>. При этом сертификат будет использоваться и для проверки подлинности, и для защиты SSL-подключения. За подробностями обратитесь к <a class="xref" href="auth-cert.html" title="21.12. Аутентификация по сертификату">Разделу 21.12</a>. (Задавать явно какие-либо значения для параметра <code class="literal">clientcert</code> при использовании метода аутентификации <code class="literal">cert</code> не требуется.) В этом случае в качестве имени пользователя или сопоставляемого имени используется имя из поля <code class="literal">cn</code> (Common Name, Общее имя) сертификата.</p><p>Второй вариант сочетает использование произвольного метода аутентификации в записях <code class="literal">hostssl</code> с проверкой клиентских сертификатов, которая выполняется при значении параметра <code class="literal">clientcert</code>, равном <code class="literal">verify-ca</code> или <code class="literal">verify-full</code>. Первое значение включает только проверку достоверности сертификата, а последнее также сверяет имя пользователя или применяемое сопоставление с общим именем <code class="literal">cn</code> (Common Name), указанным в сертификате.</p></div><div class="sect2" id="SSL-SERVER-FILES"><div class="titlepage"><div><div><h3 class="title">19.9.4. Файлы, используемые SSL-сервером <a href="#SSL-SERVER-FILES" class="id_link">#</a></h3></div></div></div><p>В <a class="xref" href="ssl-tcp.html#SSL-FILE-USAGE" title="Таблица 19.2. Файлы, используемые SSL-сервером">Таблице 19.2</a> кратко описаны все файлы, имеющие отношение к настройке SSL на сервере. (Здесь приведены стандартные имена файлов. В конкретной системе они могут быть другими.)</p><div class="table" id="SSL-FILE-USAGE"><p class="title"><strong>Таблица 19.2. Файлы, используемые SSL-сервером</strong></p><div class="table-contents"><table class="table" summary="Файлы, используемые SSL-сервером" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Файл</th><th>Содержимое</th><th>Назначение</th></tr></thead><tbody><tr><td><a class="xref" href="runtime-config-connection.html#GUC-SSL-CERT-FILE">ssl_cert_file</a> (<code class="filename">$PGDATA/server.crt</code>)</td><td>сертификат сервера</td><td>отправляется клиенту для идентификации сервера</td></tr><tr><td><a class="xref" href="runtime-config-connection.html#GUC-SSL-KEY-FILE">ssl_key_file</a> (<code class="filename">$PGDATA/server.key</code>)</td><td>закрытый ключ сервера</td><td>подтверждает, что сертификат сервера был передан его владельцем; не гарантирует, что его владельцу можно доверять</td></tr><tr><td><a class="xref" href="runtime-config-connection.html#GUC-SSL-CA-FILE">ssl_ca_file</a></td><td>сертификаты доверенных ЦС</td><td>позволяет проверить, что сертификат клиента подписан доверенным центром сертификации</td></tr><tr><td><a class="xref" href="runtime-config-connection.html#GUC-SSL-CRL-FILE">ssl_crl_file</a></td><td>сертификаты, отозванные центрами сертификации</td><td>сертификат клиента должен отсутствовать в этом списке</td></tr></tbody></table></div></div><br class="table-break" /><p>Сервер читает эти файлы при запуске или при перезагрузке конфигурации. В системах <span class="systemitem">Windows</span> они также считываются заново, когда для нового клиентского подключения запускается новый обслуживающий процесс.</p><p>Если в этих файлах при запуске сервера обнаружится ошибка, сервер откажется запускаться. Но если ошибка обнаруживается при перезагрузке конфигурации, эти файлы игнорируются и продолжает использоваться старая конфигурация SSL. В системах <span class="systemitem">Windows</span>, если в одном из этих файлов обнаруживается ошибка при запуске обслуживающего процесса, этот процесс не сможет устанавливать SSL-соединения. Во всех таких случаях в журнал событий сервера выводится сообщение об ошибке.</p></div><div class="sect2" id="SSL-CERTIFICATE-CREATION"><div class="titlepage"><div><div><h3 class="title">19.9.5. Создание сертификатов <a href="#SSL-CERTIFICATE-CREATION" class="id_link">#</a></h3></div></div></div><p>Чтобы создать простой самоподписанный сертификат для сервера, действующий 365 дней, выполните следующую команду <span class="productname">OpenSSL</span>, заменив <em class="replaceable"><code>dbhost.yourdomain.com</code></em> именем компьютера, где размещён сервер: </p><pre class="programlisting">openssl req -new -x509 -days 365 -nodes -text -out server.crt \
  -keyout server.key -subj "/CN=<em class="replaceable"><code>dbhost.yourdomain.com</code></em>"</pre><p> Затем выполните: </p><pre class="programlisting">chmod og-rwx server.key</pre><p> так как сервер не примет этот файл, если разрешения будут более либеральными, чем показанные. За дополнительными сведениями относительно создания закрытого ключа и сертификата сервера обратитесь к документации <span class="productname">OpenSSL</span>.</p><p>Хотя самоподписанный сертификат может успешно применяться при тестировании, в производственной среде следует использовать сертификат, подписанный центром сертификации (<acronym class="acronym">ЦС</acronym>) (обычно это корневой <acronym class="acronym">ЦС</acronym> предприятия).</p><p>Чтобы создать сертификат сервера, подлинность которого смогут проверять клиенты, сначала создайте запрос на получение сертификата (<acronym class="acronym">CSR</acronym>) и файлы открытого/закрытого ключа: </p><pre class="programlisting">openssl req -new -nodes -text -out root.csr \
  -keyout root.key -subj "/CN=<em class="replaceable"><code>root.yourdomain.com</code></em>"
chmod og-rwx root.key</pre><p> Затем подпишите запрос ключом, чтобы создать корневой центр сертификации (с файлом конфигурации <span class="productname">OpenSSL</span>, помещённым в <span class="productname">Linux</span> в расположение по умолчанию): </p><pre class="programlisting">openssl x509 -req -in root.csr -text -days 3650 \
  -extfile /etc/ssl/openssl.cnf -extensions v3_ca \
  -signkey root.key -out root.crt</pre><p> Наконец, создайте сертификат сервера, подписанный новым корневым центром сертификации: </p><pre class="programlisting">openssl req -new -nodes -text -out server.csr \
  -keyout server.key -subj "/CN=<em class="replaceable"><code>dbhost.yourdomain.com</code></em>"
chmod og-rwx server.key

openssl x509 -req -in server.csr -text -days 365 \
  -CA root.crt -CAkey root.key -CAcreateserial \
  -out server.crt</pre><p> <code class="filename">server.crt</code> и <code class="filename">server.key</code> должны быть сохранены на сервере, а <code class="filename">root.crt</code> — на клиенте, чтобы клиент мог убедиться в том, что конечный сертификат сервера подписан центром сертификации, которому он доверяет. Файл <code class="filename">root.key</code> следует хранить в изолированном месте для создания сертификатов в будущем.</p><p>Также возможно создать цепочку доверия, включающую промежуточные сертификаты: </p><pre class="programlisting"># корневой сертификат
openssl req -new -nodes -text -out root.csr \
  -keyout root.key -subj "/CN=<em class="replaceable"><code>root.yourdomain.com</code></em>"
chmod og-rwx root.key
openssl x509 -req -in root.csr -text -days 3650 \
  -extfile /etc/ssl/openssl.cnf -extensions v3_ca \
  -signkey root.key -out root.crt

# промежуточный
openssl req -new -nodes -text -out intermediate.csr \
  -keyout intermediate.key -subj "/CN=<em class="replaceable"><code>intermediate.yourdomain.com</code></em>"
chmod og-rwx intermediate.key
openssl x509 -req -in intermediate.csr -text -days 1825 \
  -extfile /etc/ssl/openssl.cnf -extensions v3_ca \
  -CA root.crt -CAkey root.key -CAcreateserial \
  -out intermediate.crt

# конечный
openssl req -new -nodes -text -out server.csr \
  -keyout server.key -subj "/CN=<em class="replaceable"><code>dbhost.yourdomain.com</code></em>"
chmod og-rwx server.key
openssl x509 -req -in server.csr -text -days 365 \
  -CA intermediate.crt -CAkey intermediate.key -CAcreateserial \
  -out server.crt</pre><p> <code class="filename">server.crt</code> и <code class="filename">intermediate.crt</code> следует сложить вместе в пакет сертификатов и сохранить на сервере. Также на сервере следует сохранить <code class="filename">server.key</code>. Файл <code class="filename">root.crt</code> нужно сохранить на клиенте, чтобы клиент мог убедиться в том, что конечный сертификат сервера был подписан по цепочке сертификатов, связанных с корневым сертификатом, которому он доверяет. Файлы <code class="filename">root.key</code> и <code class="filename">intermediate.key</code> следует хранить в изолированном месте для создания сертификатов в будущем.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="encryption-options.html" title="19.8. Возможности шифрования">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="runtime.html" title="Глава 19. Подготовка к работе и сопровождение сервера">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="gssapi-enc.html" title="19.10. Защита соединений TCP/IP с применением GSSAPI">След.</a></td></tr><tr><td width="40%" align="left" valign="top">19.8. Возможности шифрования </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 19.10. Защита соединений TCP/IP с применением GSSAPI</td></tr></table></div></body></html>