<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>43.1. Обзор</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="plpgsql.html" title="Глава 43. PL/pgSQL — процедурный язык SQL" /><link rel="next" href="plpgsql-structure.html" title="43.2. Структура PL/pgSQL" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">43.1. Обзор</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="plpgsql.html" title="Глава 43. PL/pgSQL — процедурный язык SQL">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="plpgsql.html" title="Глава 43. PL/pgSQL — процедурный язык SQL">Наверх</a></td><th width="60%" align="center">Глава 43. <span class="application">PL/pgSQL</span> — процедурный язык <acronym class="acronym">SQL</acronym></th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="plpgsql-structure.html" title="43.2. Структура PL/pgSQL">След.</a></td></tr></table><hr /></div><div class="sect1" id="PLPGSQL-OVERVIEW"><div class="titlepage"><div><div><h2 class="title" style="clear: both">43.1. Обзор <a href="#PLPGSQL-OVERVIEW" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="plpgsql-overview.html#PLPGSQL-ADVANTAGES">43.1.1. Преимущества использования <span class="application">PL/pgSQL</span></a></span></dt><dt><span class="sect2"><a href="plpgsql-overview.html#PLPGSQL-ARGS-RESULTS">43.1.2. Поддерживаемые типы данных аргументов и возвращаемых значений</a></span></dt></dl></div><p><span class="application">PL/pgSQL</span> это процедурный язык для СУБД <span class="productname">PostgreSQL</span>. Целью проектирования <span class="application">PL/pgSQL</span> было создание загружаемого процедурного языка, который: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>используется для создания функций, процедур и триггеров,</p></li><li class="listitem"><p>добавляет управляющие структуры к языку <acronym class="acronym">SQL</acronym>,</p></li><li class="listitem"><p>может выполнять сложные вычисления,</p></li><li class="listitem"><p>наследует все пользовательские типы, функции, процедуры и операторы,</p></li><li class="listitem"><p>может быть определён как доверенный язык,</p></li><li class="listitem"><p>прост в использовании.</p></li></ul></div><p>Функции <span class="application">PL/pgSQL</span> могут использоваться везде, где допустимы встроенные функции. Например, можно создать функции со сложными вычислениями и условной логикой, а затем использовать их при определении операторов или в индексных выражениях.</p><p>В версии <span class="productname">PostgreSQL</span> 9.0 и выше <span class="application">PL/pgSQL</span> устанавливается по умолчанию. Тем не менее это по-прежнему загружаемый модуль и администраторы, особо заботящиеся о безопасности, могут удалить его при необходимости.</p><div class="sect2" id="PLPGSQL-ADVANTAGES"><div class="titlepage"><div><div><h3 class="title">43.1.1. Преимущества использования <span class="application">PL/pgSQL</span> <a href="#PLPGSQL-ADVANTAGES" class="id_link">#</a></h3></div></div></div><p><span class="productname">PostgreSQL</span> и большинство других СУБД используют <acronym class="acronym">SQL</acronym> в качестве языка запросов. <acronym class="acronym">SQL</acronym> хорошо переносим и прост в изучении. Однако каждый оператор <acronym class="acronym">SQL</acronym> выполняется индивидуально на сервере базы данных.</p><p>Это значит, что ваше клиентское приложение должно каждый запрос отправлять на сервер, ждать пока он будет обработан, получать результат, делать некоторые вычисления, затем отправлять последующие запросы на сервер. Всё это требует межпроцессного взаимодействия, а также несёт нагрузку на сеть, если клиент и сервер базы данных расположены на разных компьютерах.</p><p><span class="application">PL/pgSQL</span> позволяет сгруппировать блок вычислений и последовательность запросов <span class="emphasis"><em>внутри</em></span> сервера базы данных, таким образом, мы получаем силу процедурного языка и простоту использования <acronym class="acronym">SQL</acronym> при значительной экономии накладных расходов на клиент-серверное взаимодействие.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Исключаются дополнительные обращения между клиентом и сервером</p></li><li class="listitem"><p>Промежуточные ненужные результаты не передаются между сервером и клиентом</p></li><li class="listitem"><p>Есть возможность избежать многочисленных разборов одного запроса</p></li></ul></div><p>В результате это приводит к значительному увеличению производительности по сравнению с приложением, которое не использует хранимых функций.</p><p>Кроме того, <span class="application">PL/pgSQL</span> позволяет использовать все типы данных, операторы и функции <acronym class="acronym">SQL</acronym>.</p></div><div class="sect2" id="PLPGSQL-ARGS-RESULTS"><div class="titlepage"><div><div><h3 class="title">43.1.2. Поддерживаемые типы данных аргументов и возвращаемых значений <a href="#PLPGSQL-ARGS-RESULTS" class="id_link">#</a></h3></div></div></div><p>Функции на <span class="application">PL/pgSQL</span> могут принимать в качестве аргументов все поддерживаемые сервером скалярные типы данных или массивы и возвращать в качестве результата любой из этих типов. Они могут принимать и возвращать любой именованный составной тип (тип кортежа). Также есть возможность объявить функцию на <span class="application">PL/pgSQL</span> как принимающую <code class="type">record</code>, то есть ей может быть передан любой составной тип, или как возвращающую <code class="type">record</code>, то есть её результатом будет кортеж, столбцы которого определит спецификация вызывающего запроса, как описано в <a class="xref" href="queries-table-expressions.html#QUERIES-TABLEFUNCTIONS" title="7.2.1.4. Табличные функции">Подразделе 7.2.1.4</a>.</p><p>Использование маркера <code class="literal">VARIADIC</code> позволяет объявлять функции на <span class="application">PL/pgSQL</span> с переменным числом аргументов. Это работает точно так же, как и для функций на SQL, как описано в <a class="xref" href="xfunc-sql.html#XFUNC-SQL-VARIADIC-FUNCTIONS" title="38.5.6. Функции SQL с переменным числом аргументов">Подразделе 38.5.6</a>.</p><p>Функции на <span class="application">PL/pgSQL</span> могут также принимать и возвращать полиморфные типы, описанные в <a class="xref" href="extend-type-system.html#EXTEND-TYPES-POLYMORPHIC" title="38.2.5. Полиморфные типы">Подразделе 38.2.5</a>, вследствие чего фактические типы данных, обрабатываемые функцией, могут меняться от вызова к вызову. Примеры приведены в <a class="xref" href="plpgsql-declarations.html#PLPGSQL-DECLARATION-PARAMETERS" title="43.3.1. Объявление параметров функции">Подразделе 43.3.1</a>.</p><p>Функции на <span class="application">PL/pgSQL</span> могут возвращать <span class="quote">«<span class="quote">множества</span>»</span> (или таблицы) любого типа, которые могут быть возвращены в виде одного объекта. Такие функции генерируют вывод, выполняя команду <code class="command">RETURN NEXT</code> для каждого элемента результирующего набора или <code class="command">RETURN QUERY</code> для вывода результата запроса.</p><p>Наконец, при отсутствии полезного возвращаемого значения функция на <span class="application">PL/pgSQL</span> может возвращать <code class="type">void</code>. (С другой стороны, её также можно оформить в виде процедуры.)</p><p>Функции на <span class="application">PL/pgSQL</span> можно объявить с выходными параметрами вместо явного задания типа возвращаемого значения. Это не добавляет никаких фундаментальных возможностей языку, но часто бывает удобно, особенно для возвращения нескольких значений. Нотация <code class="literal">RETURNS TABLE</code> может использоваться вместо <code class="literal">RETURNS SETOF</code>.</p><p>Конкретные примеры рассматриваются в <a class="xref" href="plpgsql-declarations.html#PLPGSQL-DECLARATION-PARAMETERS" title="43.3.1. Объявление параметров функции">Подразделе 43.3.1</a> и <a class="xref" href="plpgsql-control-structures.html#PLPGSQL-STATEMENTS-RETURNING" title="43.6.1. Команды, возвращающие значения из функции">Подразделе 43.6.1</a>.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="plpgsql.html" title="Глава 43. PL/pgSQL — процедурный язык SQL">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="plpgsql.html" title="Глава 43. PL/pgSQL — процедурный язык SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="plpgsql-structure.html" title="43.2. Структура PL/pgSQL">След.</a></td></tr><tr><td width="40%" align="left" valign="top">Глава 43. <span class="application">PL/pgSQL</span> — процедурный язык <acronym class="acronym">SQL</acronym> </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 43.2. Структура <span class="application">PL/pgSQL</span></td></tr></table></div></body></html>