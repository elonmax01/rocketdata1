<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CREATE RULE</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sql-createrole.html" title="CREATE ROLE" /><link rel="next" href="sql-createschema.html" title="CREATE SCHEMA" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">CREATE RULE</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-createrole.html" title="CREATE ROLE">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><th width="60%" align="center">Команды SQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-createschema.html" title="CREATE SCHEMA">След.</a></td></tr></table><hr /></div><div class="refentry" id="SQL-CREATERULE"><div class="titlepage"></div><a id="id-1.9.3.79.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">CREATE RULE</span></h2><p>CREATE RULE — создать правило перезаписи</p></div><div class="refsynopsisdiv"><h2>Синтаксис</h2><pre class="synopsis">CREATE [ OR REPLACE ] RULE <em class="replaceable"><code>имя</code></em> AS ON <em class="replaceable"><code>событие</code></em>
    TO <em class="replaceable"><code>имя_таблицы</code></em> [ WHERE <em class="replaceable"><code>условие</code></em> ]
    DO [ ALSO | INSTEAD ] { NOTHING | <em class="replaceable"><code>команда</code></em> | ( <em class="replaceable"><code>команда</code></em> ; <em class="replaceable"><code>команда</code></em> ... ) }

<span class="phrase">Здесь допускается <em class="replaceable"><code>событие</code></em>:</span>

    SELECT | INSERT | UPDATE | DELETE</pre></div><div class="refsect1" id="id-1.9.3.79.5"><h2>Описание</h2><p><code class="command">CREATE RULE</code> создаёт правило, применяемое к указанной таблице или представлению. <code class="command">CREATE OR REPLACE RULE</code> либо создаёт новое правило, либо заменяет существующее с тем же именем для той же таблицы.</p><p>Система правил <span class="productname">PostgreSQL</span> позволяет определить альтернативное действие, заменяющее операции добавления, изменения или удаления данных в таблицах базы данных. Грубо говоря, правило описывает дополнительные команды, которые будут выполняться при вызове определённой команды для определённой таблицы. Кроме того, правило <code class="literal">INSTEAD</code> может заменить заданную команду другой, либо сделать, чтобы она не выполнялась вовсе. Правила также применяются для реализации SQL-запросов. Важно понимать, что правило это фактически механизм преобразования команд (макрос). Заданное преобразование имеет место до начала выполнения команды. Когда требуется выполнить некоторую операцию независимо для каждой физической строки, скорее всего, для этого нужно применять триггер, а не правило. Более подробно о системе правил можно узнать в <a class="xref" href="rules.html" title="Глава 41. Система правил">Главе 41</a>.</p><p>В настоящее время правила <code class="literal">ON SELECT</code> можно применять только к представлениям. Такое правило должно называться <code class="literal">"_RETURN"</code>, быть безусловным, с характеристикой <code class="literal">INSTEAD</code> (вместо исходного), и его действия должны состоять из единственной команды <code class="command">SELECT</code>, определяющей видимое содержимое представления. (Само представление по сути является фиктивной таблицей без хранилища.) Лучше всего рассматривать такое правило как деталь реализации. Хотя представление можно переопределить с помощью <code class="literal">CREATE OR REPLACE RULE "_RETURN" AS ...</code>, лучше использовать <code class="literal">CREATE OR REPLACE VIEW</code>.</p><p>С помощью правил можно создать иллюзию изменяемого представления, определив правила <code class="literal">ON INSERT</code>, <code class="literal">ON UPDATE</code> и <code class="literal">ON DELETE</code> (либо только те, которых достаточно для решения поставленной задачи) и заменив операции изменения данных в представлении соответствующими действиями с другими таблицами. Если требуется поддерживать оператор <code class="command">INSERT RETURNING</code> и подобные ему, в каждое из этих правило обязательно нужно поместить подходящее предложение <code class="literal">RETURNING</code>.</p><p>Использование правил с условиями для сложных изменений представлений связано с одним ограничением: для каждого действия, которое вы хотите разрешить для представления, <span class="emphasis"><em>необходимо</em></span> определить безусловное правило <code class="literal">INSTEAD</code>. Если определено только условное правило, или правило не типа <code class="literal">INSTEAD</code>, система отвергнет попытки выполнить изменения, предполагая, что в некоторых случаях изменения могут свестись к операциям с фиктивной нижележащей таблицей. При желании обработать все полезные случаи изменений в условных правилах, добавьте безусловное правило <code class="literal">DO INSTEAD NOTHING</code>, чтобы система понимала, что ей никогда не придётся изменять нижележащую таблицу. Затем создайте условные правила без свойства <code class="literal">INSTEAD</code>; в тех случаях, когда они будут применяться, их действия будут добавлены к действию по умолчанию <code class="literal">INSTEAD NOTHING</code>. (Однако этот способ в настоящее время не подходит для реализации запросов <code class="literal">RETURNING</code>.)</p><div class="note"><h3 class="title">Примечание</h3><p>Представления, достаточно простые для реализации автоматического обновления (см. <a class="xref" href="sql-createview.html" title="CREATE VIEW"><span class="refentrytitle">CREATE VIEW</span></a>), могут быть изменяемыми без пользовательских правил. Хотя вы тем не менее можете создать явное правило, обычно автоматическое преобразование будет работать лучше такого правила.</p><p>Другая, заслуживающая рассмотрения, альтернатива правилам — триггеры <code class="literal">INSTEAD OF</code> (см. <a class="xref" href="sql-createtrigger.html" title="CREATE TRIGGER"><span class="refentrytitle">CREATE TRIGGER</span></a>).</p></div></div><div class="refsect1" id="id-1.9.3.79.6"><h2>Параметры</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>имя</code></em></span></dt><dd><p>Имя создаваемого правила. Оно должно отличаться от имён любых других правил для той же таблицы. При наличии нескольких правил для одной таблицы и одного типа события они применяются в алфавитном порядке.</p></dd><dt><span class="term"><em class="replaceable"><code>событие</code></em></span></dt><dd><p>Тип события: <code class="literal">SELECT</code>, <code class="literal">INSERT</code>, <code class="literal">UPDATE</code> или <code class="literal">DELETE</code>. Заметьте, что команду <code class="command">INSERT</code> с предложением <code class="literal">ON CONFLICT</code> нельзя использовать с таблицами, для которых определены правила <code class="literal">INSERT</code> или <code class="literal">UPDATE</code>. В этом случае подумайте о применении изменяемых представлений.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_таблицы</code></em></span></dt><dd><p>Имя (возможно, дополненное схемой) существующей таблицы (или представления), к которой применяется это правило.</p></dd><dt><span class="term"><em class="replaceable"><code>условие</code></em></span></dt><dd><p>Любое выражение условия <acronym class="acronym">SQL</acronym> (возвращающее <code class="type">boolean</code>). Это выражение не может ссылаться на какие-либо таблицы, кроме как на <code class="literal">NEW</code> и <code class="literal">OLD</code>, и не может содержать агрегатные функции.</p></dd><dt><span class="term"><code class="option">INSTEAD</code></span></dt><dd><p><code class="literal">INSTEAD</code> указывает, что заданные команды должны выполняться <span class="emphasis"><em>вместо</em></span> исходной команды.</p></dd><dt><span class="term"><code class="option">ALSO</code></span></dt><dd><p><code class="literal">ALSO</code> указывает, что заданные команды должны выполняться <span class="emphasis"><em>в дополнение к</em></span> исходной команде.</p><p>Если ни <code class="literal">ALSO</code>, ни <code class="literal">INSTEAD</code> не указано, по умолчанию подразумевается <code class="literal">ALSO</code>.</p></dd><dt><span class="term"><em class="replaceable"><code>команда</code></em></span></dt><dd><p>Команда или команды, составляющие действие правила. Здесь допустимы команды: <code class="command">SELECT</code>, <code class="command">INSERT</code>, <code class="command">UPDATE</code>, <code class="command">DELETE</code> и <code class="command">NOTIFY</code>.</p></dd></dl></div><p>В параметрах <em class="replaceable"><code>условие</code></em> и <em class="replaceable"><code>команда</code></em> можно использовать имена специальных таблиц <code class="literal">NEW</code> и <code class="literal">OLD</code> для обращения к значениям в соответствующей таблице. <code class="literal">NEW</code> (новая) принимается в правилах <code class="literal">ON INSERT</code> и <code class="literal">ON UPDATE</code> и обозначает ссылку на новую строку, добавляемую или изменяемую. <code class="literal">OLD</code> (старая) принимается в правилах <code class="literal">ON UPDATE</code> и <code class="literal">ON DELETE</code> и обозначает ссылку на существующую строку, изменяемую или удаляемую.</p></div><div class="refsect1" id="id-1.9.3.79.7"><h2>Замечания</h2><p>Чтобы создать или изменить правила для таблицы, нужно быть её владельцем.</p><p>В правило для <code class="literal">INSERT</code>, <code class="literal">UPDATE</code> или <code class="literal">DELETE</code> для представления можно добавить предложение <code class="literal">RETURNING</code>, выдающее столбцы представления. Это предложение будет генерировать результат, если правило сработает при выполнении команды <code class="command">INSERT RETURNING</code>, <code class="command">UPDATE RETURNING</code> или <code class="command">DELETE RETURNING</code>. Когда правило срабатывает при выполнении команды без <code class="literal">RETURNING</code>, предложение <code class="literal">RETURNING</code> этого правила игнорируется. В текущей реализации только безусловные правила <code class="literal">INSTEAD</code> могут содержать <code class="literal">RETURNING</code>; более того, допускается максимум одно предложение <code class="literal">RETURNING</code> среди всех правил для некоторого события. (Благодаря этому ограничению, только одно предложение <code class="literal">RETURNING</code> может быть выбрано для вычисления результатов.) Запросы с <code class="literal">RETURNING</code> к данному представлению не будут выполняться, если ни одно из определённых для него правил не содержит предложение <code class="literal">RETURNING</code>.</p><p>Очень важно следить за тем, чтобы правила не зацикливались. Например, два следующих определения правил будут приняты <span class="productname">PostgreSQL</span>, но при попытке выполнить команду <code class="command">SELECT</code> <span class="productname">PostgreSQL</span> сообщит об ошибке из-за рекурсивного расширения правила: </p><pre class="programlisting">CREATE RULE "_RETURN" AS
    ON SELECT TO t1
    DO INSTEAD
        SELECT * FROM t2;

CREATE RULE "_RETURN" AS
    ON SELECT TO t2
    DO INSTEAD
        SELECT * FROM t1;

SELECT * FROM t1;</pre><p>В настоящее время, если действие правила содержит команду <code class="command">NOTIFY</code>, эта команда будет выполняться безусловно, то есть, <code class="command">NOTIFY</code> будет выдаваться, даже если не найдётся никаких строк, к которым бы применялось правило. Например, в следующем примере: </p><pre class="programlisting">CREATE RULE notify_me AS ON UPDATE TO mytable DO ALSO NOTIFY mytable;

UPDATE mytable SET name = 'foo' WHERE id = 42;</pre><p> одно событие <code class="command">NOTIFY</code> будет отправлено при выполнении команды <code class="command">UPDATE</code>, даже если никакие строки не соответствуют условию <code class="literal">id = 42</code>. Это недостаток текущей реализации, который может быть исправлен в будущих версиях.</p></div><div class="refsect1" id="id-1.9.3.79.8"><h2>Совместимость</h2><p>Оператор <code class="command">CREATE RULE</code> является языковым расширением <span class="productname">PostgreSQL</span>, как и вся система перезаписи запросов.</p></div><div class="refsect1" id="id-1.9.3.79.9"><h2>См. также</h2><span class="simplelist"><a class="xref" href="sql-alterrule.html" title="ALTER RULE"><span class="refentrytitle">ALTER RULE</span></a>, <a class="xref" href="sql-droprule.html" title="DROP RULE"><span class="refentrytitle">DROP RULE</span></a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-createrole.html" title="CREATE ROLE">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-createschema.html" title="CREATE SCHEMA">След.</a></td></tr><tr><td width="40%" align="left" valign="top">CREATE ROLE </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> CREATE SCHEMA</td></tr></table></div></body></html>