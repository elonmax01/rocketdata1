<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>5.10. Наследование</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="ddl-schemas.html" title="5.9. Схемы" /><link rel="next" href="ddl-partitioning.html" title="5.11. Секционирование таблиц" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">5.10. Наследование</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="ddl-schemas.html" title="5.9. Схемы">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="ddl.html" title="Глава 5. Определение данных">Наверх</a></td><th width="60%" align="center">Глава 5. Определение данных</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="ddl-partitioning.html" title="5.11. Секционирование таблиц">След.</a></td></tr></table><hr /></div><div class="sect1" id="DDL-INHERIT"><div class="titlepage"><div><div><h2 class="title" style="clear: both">5.10. Наследование <a href="#DDL-INHERIT" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="ddl-inherit.html#DDL-INHERIT-CAVEATS">5.10.1. Ограничения</a></span></dt></dl></div><a id="id-1.5.4.12.2" class="indexterm"></a><a id="id-1.5.4.12.3" class="indexterm"></a><p><span class="productname">PostgreSQL</span> реализует наследование таблиц, что может быть полезно для проектировщиков баз данных. (Стандарт SQL:1999 и более поздние версии определяют возможность наследования типов, но это во многом отличается от того, что описано здесь.)</p><p>Давайте начнём со следующего примера: предположим, что мы создаём модель данных для городов. В каждом штате есть множество городов, но лишь одна столица. Мы хотим иметь возможность быстро получать город-столицу для любого штата. Это можно сделать, создав две таблицы: одну для столиц штатов, а другую для городов, не являющихся столицами. Однако что делать, если нам нужно получить информацию о любом городе, будь то столица штата или нет? В решении этой проблемы может помочь наследование. Мы определим таблицу <code class="structname">capitals</code> как наследника <code class="structname">cities</code>: </p><pre class="programlisting">CREATE TABLE cities (
    name            text,
    population      float,
    elevation       int     -- в футах
);

CREATE TABLE capitals (
    state           char(2)
) INHERITS (cities);</pre><p> В этом случае таблица <code class="structname">capitals</code> <em class="firstterm">наследует</em> все столбцы своей родительской таблицы, <code class="structname">cities</code>. Столицы штатов также имеют дополнительный столбец <code class="structfield">state</code>, в котором будет указан штат.</p><p>В <span class="productname">PostgreSQL</span> таблица может наследоваться от нуля или нескольких других таблиц, а запросы могут выбирать все строки родительской таблицы или все строки родительской и всех дочерних таблиц. По умолчанию принят последний вариант. Например, следующий запрос найдёт названия всех городов, включая столицы штатов, расположенных выше 500 футов: </p><pre class="programlisting">SELECT name, elevation
    FROM cities
    WHERE elevation &gt; 500;</pre><p> Для данных из введения (см. <a class="xref" href="tutorial-sql-intro.html" title="2.1. Введение">Раздел 2.1</a>) он выдаст: </p><pre class="programlisting">   name    | elevation
-----------+-----------
 Las Vegas |      2174
 Mariposa  |      1953
 Madison   |       845</pre><p>А следующий запрос находит все города, которые не являются столицами штатов, но также находятся на высоте выше 500 футов: </p><pre class="programlisting">SELECT name, elevation
    FROM ONLY cities
    WHERE elevation &gt; 500;

   name    | elevation
-----------+-----------
 Las Vegas |      2174
 Mariposa  |      1953</pre><p>Здесь ключевое слово <code class="literal">ONLY</code> указывает, что запрос должен применяться только к таблице <code class="structname">cities</code>, но не к таблицам, расположенным ниже <code class="structname">cities</code> в иерархии наследования. Многие операторы, которые мы уже обсудили, — <code class="command">SELECT</code>, <code class="command">UPDATE</code> и <code class="command">DELETE</code> — поддерживают ключевое слово <code class="literal">ONLY</code>.</p><p>Вы также можете добавить после имени таблицы <code class="literal">*</code>, чтобы явно указать, что должны включаться и дочерние таблицы: </p><pre class="programlisting">SELECT name, elevation
    FROM cities*
    WHERE elevation &gt; 500;</pre><p> Указывать <code class="literal">*</code> не обязательно, так как теперь это поведение всегда подразумевается по умолчанию. Однако такая запись всё ещё поддерживается для совместимости со старыми версиями, где поведение по умолчанию могло быть изменено.</p><p>В некоторых ситуациях бывает необходимо узнать, из какой таблицы выбрана конкретная строка. Для этого вы можете воспользоваться системным столбцом <code class="structfield">tableoid</code>, присутствующим в каждой таблице: </p><pre class="programlisting">SELECT c.tableoid, c.name, c.elevation
FROM cities c
WHERE c.elevation &gt; 500;</pre><p> этот запрос выдаст: </p><pre class="programlisting"> tableoid |   name    | elevation
----------+-----------+-----------
   139793 | Las Vegas |      2174
   139793 | Mariposa  |      1953
   139798 | Madison   |       845</pre><p> (Если вы попытаетесь выполнить его у себя, скорее всего вы получите другие значения OID.) Собственно имена таблиц вы можете получить, обратившись к <code class="structname">pg_class</code>: </p><pre class="programlisting">SELECT p.relname, c.name, c.elevation
FROM cities c, pg_class p
WHERE c.elevation &gt; 500 AND c.tableoid = p.oid;</pre><p> в результате вы получите: </p><pre class="programlisting"> relname  |   name    | elevation
----------+-----------+-----------
 cities   | Las Vegas |      2174
 cities   | Mariposa  |      1953
 capitals | Madison   |       845</pre><p>Тот же эффект можно получить другим способом, используя альтернативный тип <code class="type">regclass</code>; при этом OID таблицы выводится в символьном виде: </p><pre class="programlisting">SELECT c.tableoid::regclass, c.name, c.elevation
FROM cities c
WHERE c.elevation &gt; 500;</pre><p>Механизм наследования не способен автоматически распределять данные команд <code class="command">INSERT</code> или <code class="command">COPY</code> по таблицам в иерархии наследования. Поэтому в нашем примере этот оператор <code class="command">INSERT</code> не выполнится: </p><pre class="programlisting">INSERT INTO cities (name, population, elevation, state)
VALUES ('Albany', NULL, NULL, 'NY');</pre><p> Мы могли надеяться на то, что данные каким-то образом попадут в таблицу <code class="structname">capitals</code>, но этого не происходит: <code class="command">INSERT</code> всегда вставляет данные непосредственно в указанную таблицу. В некоторых случаях добавляемые данные можно перенаправлять, используя правила (см. <a class="xref" href="rules.html" title="Глава 41. Система правил">Главу 41</a>). Однако в нашем случае это не поможет, так как таблица <code class="structname">cities</code> не содержит столбца <code class="structfield">state</code> и команда будет отвергнута до применения правила.</p><p>Дочерние таблицы автоматически наследуют от родительской таблицы ограничения-проверки и ограничения NOT NULL (если только для них не задано явно <code class="literal">NO INHERIT</code>). Все остальные ограничения (уникальности, первичный ключ и внешние ключи) не наследуются.</p><p>Таблица может наследоваться от нескольких родительских таблиц, в этом случае она будет объединять в себе все столбцы этих таблиц, а также столбцы, описанные непосредственно в её определении. Если в определениях родительских и дочерней таблиц встретятся столбцы с одним именем, эти столбцы будут <span class="quote">«<span class="quote">объединены</span>»</span>, так что в дочерней таблице окажется только один столбец. Чтобы такое объединение было возможно, столбцы должны иметь одинаковый тип данных, в противном случае произойдёт ошибка. Наследуемые ограничения-проверки и ограничения NOT NULL объединяются подобным образом. Так, например, объединяемый столбец получит свойство NOT NULL, если какое-либо из порождающих его определений имеет свойство NOT NULL. Ограничения-проверки объединяются, если они имеют одинаковые имена; но если их условия различаются, происходит ошибка.</p><p>Отношение наследования между таблицами обычно устанавливается при создании дочерней таблицы с использованием предложения <code class="literal">INHERITS</code> оператора <a class="link" href="sql-createtable.html" title="CREATE TABLE"><code class="command">CREATE TABLE</code></a>. Другой способ добавить такое отношение для таблицы, определённой подходящим образом, — использовать <code class="literal">INHERIT</code> с оператором <a class="link" href="sql-altertable.html" title="ALTER TABLE"><code class="command">ALTER TABLE</code></a>. Для этого будущая дочерняя таблица должна уже включать те же столбцы (с совпадающими именами и типами), что и родительская таблица. Также она должна включать аналогичные ограничения-проверки (с теми же именами и выражениями). Удалить отношение наследования можно с помощью указания <code class="literal">NO INHERIT</code> оператора <code class="command">ALTER TABLE</code>. Динамическое добавление и удаление отношений наследования может быть полезно при реализации секционирования таблиц (см. <a class="xref" href="ddl-partitioning.html" title="5.11. Секционирование таблиц">Раздел 5.11</a>).</p><p>Для создания таблицы, которая затем может стать наследником другой, удобно воспользоваться предложением <code class="literal">LIKE</code> оператора <code class="command">CREATE TABLE</code>. Такая команда создаст новую таблицу с теми же столбцами, что имеются в исходной. Если в исходной таблицы определены ограничения <code class="literal">CHECK</code>, для создания полностью совместимой таблицы их тоже нужно скопировать, и это можно сделать, добавив к предложению <code class="literal">LIKE</code> параметр <code class="literal">INCLUDING CONSTRAINTS</code>.</p><p>Родительскую таблицу нельзя удалить, пока существуют унаследованные от неё. При этом в дочерних таблицах нельзя удалять или модифицировать столбцы или ограничения-проверки, унаследованные от родительских таблиц. Если вы хотите удалить таблицу вместе со всеми её потомками, это легко сделать, добавив в команду удаления родительской таблицы параметр <code class="literal">CASCADE</code> (см. <a class="xref" href="ddl-depend.html" title="5.14. Отслеживание зависимостей">Раздел 5.14</a>).</p><p>При изменениях определений и ограничений столбцов команда <code class="command">ALTER TABLE</code> распространяет эти изменения вниз в иерархии наследования. Однако удалить столбцы, унаследованные дочерними таблицами, можно только с помощью параметра <code class="literal">CASCADE</code>. При создании отношений наследования команда <code class="command">ALTER TABLE</code> следует тем же правилам объединения дублирующихся столбцов, что и <code class="command">CREATE TABLE</code>.</p><p>В запросах с наследуемыми таблицами проверка прав доступа выполняется только в родительской таблице. Так, например, наличие разрешения <code class="literal">UPDATE</code> для таблицы <code class="structname">cities</code> подразумевает право на изменение строк также в таблице <code class="structname">capitals</code>, когда к ним происходит обращение через таблицу <code class="structname">cities</code>. Это сохраняет видимость того, что эти данные (также) находятся в родительской таблице. Но изменить таблицу <code class="structname">capitals</code> напрямую без дополнительного разрешения нельзя. Подобным образом, политики защиты на уровне строк (см. <a class="xref" href="ddl-rowsecurity.html" title="5.8. Политики защиты строк">Раздел 5.8</a>) для родительской таблицы применяются к строкам, получаемым из дочерних таблиц при выполнении запроса с наследованием. Политики же дочерних таблиц, если они определены, действуют только когда такие таблицы явно задействуются в запросе; в этом случае все политики, связанные с родительскими таблицами, игнорируются.</p><p>Сторонние таблицы (см. <a class="xref" href="ddl-foreign-data.html" title="5.12. Сторонние данные">Раздел 5.12</a>) могут также входить в иерархию наследования как родительские или дочерние таблицы, так же, как и обычные. Если в иерархию наследования входит сторонняя таблица, все операции, не поддерживаемые ей, не будут поддерживаться иерархией в целом.</p><div class="sect2" id="DDL-INHERIT-CAVEATS"><div class="titlepage"><div><div><h3 class="title">5.10.1. Ограничения <a href="#DDL-INHERIT-CAVEATS" class="id_link">#</a></h3></div></div></div><p>Заметьте, что не все SQL-команды могут работать с иерархиями наследования. Команды, выполняющие выборку данных, изменение данных или модификацию схемы (например <code class="literal">SELECT</code>, <code class="literal">UPDATE</code>, <code class="literal">DELETE</code>, большинство вариантов <code class="literal">ALTER TABLE</code>, но не <code class="literal">INSERT</code> и <code class="literal">ALTER TABLE ... RENAME</code>), обычно по умолчанию обрабатывают данные дочерних таблиц и могут исключать их, если поддерживают указание <code class="literal">ONLY</code>. Команды для обслуживания и настройки базы данных (например <code class="literal">REINDEX</code> и <code class="literal">VACUUM</code>) обычно работают только с отдельными физическими таблицами и не поддерживают рекурсивную обработку отношений наследования. Соответствующее поведение каждой команды описано в её справке (<a class="xref" href="sql-commands.html" title="Команды SQL">Команды SQL</a>).</p><p>Возможности наследования серьёзно ограничены тем, что индексы (включая ограничения уникальности) и ограничения внешних ключей относятся только к отдельным таблицам, но не к их потомкам. Это касается обеих сторон ограничений внешних ключей. Таким образом, применительно к нашему примеру: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Если мы объявим <code class="structname">cities</code>.<code class="structfield">name</code> с ограничением <code class="literal">UNIQUE</code> или <code class="literal">PRIMARY KEY</code>, это не помешает добавить в таблицу <code class="structname">capitals</code> строки с названиями городов, уже существующими в таблице <code class="structname">cities</code>. И эти дублирующиеся строки по умолчанию будут выводиться в результате запросов к <code class="structname">cities</code>. На деле таблица <code class="structname">capitals</code> по умолчанию вообще не будет содержать ограничение уникальности, так что в ней могут оказаться несколько строк с одним названием. Хотя вы можете добавить в <code class="structname">capitals</code> соответствующее ограничение, но это не предотвратит дублирование при объединении с <code class="structname">cities</code>.</p></li><li class="listitem"><p>Подобным образом, если мы укажем, что <code class="structname">cities</code>.<code class="structfield">name</code> ссылается (<code class="literal">REFERENCES</code>) на какую-то другую таблицу, это ограничение не будет автоматически распространено на <code class="structname">capitals</code>. В этом случае решением может стать явное добавление такого же ограничения <code class="literal">REFERENCES</code> в таблицу <code class="structname">capitals</code>.</p></li><li class="listitem"><p>Если вы сделаете, чтобы столбец другой таблицы ссылался на <code class="literal">cities(name)</code>, в этом столбце можно будет указывать только названия городов, но не столиц. В этом случае хорошего решения нет.</p></li></ul></div><p> Некоторая функциональность, не реализованная для иерархий наследования, реализована для декларативного секционирования. Поэтому обязательно взвесьте все за и против, прежде чем применять в своих приложениях секционирование с использованием устаревшего наследования.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ddl-schemas.html" title="5.9. Схемы">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="ddl.html" title="Глава 5. Определение данных">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="ddl-partitioning.html" title="5.11. Секционирование таблиц">След.</a></td></tr><tr><td width="40%" align="left" valign="top">5.9. Схемы </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 5.11. Секционирование таблиц</td></tr></table></div></body></html>