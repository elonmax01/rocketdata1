<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>13.5. Обработка сбоев сериализации</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="applevel-consistency.html" title="13.4. Проверки целостности данных на уровне приложения" /><link rel="next" href="mvcc-caveats.html" title="13.6. Ограничения" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">13.5. Обработка сбоев сериализации</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="applevel-consistency.html" title="13.4. Проверки целостности данных на уровне приложения">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="mvcc.html" title="Глава 13. Управление конкурентным доступом">Наверх</a></td><th width="60%" align="center">Глава 13. Управление конкурентным доступом</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="mvcc-caveats.html" title="13.6. Ограничения">След.</a></td></tr></table><hr /></div><div class="sect1" id="MVCC-SERIALIZATION-FAILURE-HANDLING"><div class="titlepage"><div><div><h2 class="title" style="clear: both">13.5. Обработка сбоев сериализации <a href="#MVCC-SERIALIZATION-FAILURE-HANDLING" class="id_link">#</a></h2></div></div></div><a id="id-1.5.12.8.2" class="indexterm"></a><a id="id-1.5.12.8.3" class="indexterm"></a><p>На уровнях изоляции Repeatable Read и Serializable могут выдаваться ошибки с целью предотвращения аномалий сериализации. Как отмечалось ранее, приложения, использующие эти уровни, должны быть готовы повторить транзакции, завершившиеся сбоем из-за ошибок сериализации. Текст такого сообщения об ошибке может варьироваться в зависимости от конкретных обстоятельств, но код SQLSTATE всегда будет <code class="literal">40001</code> (<code class="literal">serialization_failure</code>).</p><p>Также может иметь смысл повторять запросы в случае ошибок взаимоблокировки. Такие ошибки имеют код SQLSTATE <code class="literal">40P01</code> (<code class="literal">deadlock_detected</code>).</p><p>В некоторых случаях также целесообразно повторять запросы после ошибок уникальности ключа, которые имеют код SQLSTATE <code class="literal">23505</code> (<code class="literal">unique_violation</code>), и ошибок нарушения исключения, которые имеют код SQLSTATE <code class="literal">23P01</code> (<code class="literal">exclusion_violation</code>). Например, если приложение выбирает новое значение для столбца первичного ключа, предварительно выяснив, какие значения уже есть, оно может столкнуться с ошибкой уникальности ключа, потому что другой экземпляр этого же приложения одновременно выбрал то же значение. По сути, это ошибка сериализации, но сервер не обнаруживает её как таковую, потому что он не может <span class="quote">«<span class="quote">видеть</span>»</span> связь между добавляемым значением и предыдущим чтением. Есть также некоторые особые случаи, когда сервер выдаёт ошибку уникального ключа или нарушения исключения, даже если у него в принципе достаточно информации, чтобы определить, что основной причиной является проблема сериализации. Тогда как запросы, вызвавшие ошибки <code class="literal">serialization_failure</code>, рекомендуется просто повторять, это не распространяется на запросы, завершающиеся ошибками с другими кодами, поскольку такие ошибки могут свидетельствовать о постоянных проблемах, а не о временных сбоях.</p><p>Повторять транзакцию важно целиком, включая всю логику, которая решает, какой SQL выдавать и/или какие значения использовать. <span class="productname">PostgreSQL</span> не предлагает средства автоматического повторения запросов, так как не может гарантировать их правильность.</p><p>Повторение транзакции не гарантирует, что такая транзакция будет завершена успешно; может потребоваться несколько повторных попыток. Когда уровень конкуренции очень высок, для успешного выполнения транзакции может потребоваться много попыток. В случаях, когда конфликт связан с подготовленной транзакцией, разрешить конфликт может быть невозможно, пока подготовленная транзакция не будет зафиксирована или отменена.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="applevel-consistency.html" title="13.4. Проверки целостности данных на уровне приложения">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="mvcc.html" title="Глава 13. Управление конкурентным доступом">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="mvcc-caveats.html" title="13.6. Ограничения">След.</a></td></tr><tr><td width="40%" align="left" valign="top">13.4. Проверки целостности данных на уровне приложения </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 13.6. Ограничения</td></tr></table></div></body></html>