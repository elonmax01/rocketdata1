<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>2.7. Агрегатные функции</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="tutorial-join.html" title="2.6. Соединения таблиц" /><link rel="next" href="tutorial-update.html" title="2.8. Изменение данных" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">2.7. Агрегатные функции</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="tutorial-join.html" title="2.6. Соединения таблиц">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="tutorial-sql.html" title="Глава 2. Язык SQL">Наверх</a></td><th width="60%" align="center">Глава 2. Язык <acronym class="acronym">SQL</acronym></th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="tutorial-update.html" title="2.8. Изменение данных">След.</a></td></tr></table><hr /></div><div class="sect1" id="TUTORIAL-AGG"><div class="titlepage"><div><div><h2 class="title" style="clear: both">2.7. Агрегатные функции <a href="#TUTORIAL-AGG" class="id_link">#</a></h2></div></div></div><a id="id-1.4.4.8.2" class="indexterm"></a><p>Как большинство других серверов реляционных баз данных, <span class="productname">PostgreSQL</span> поддерживает <em class="firstterm">агрегатные функции</em>. Агрегатная функция вычисляет единственное значение, обрабатывая множество строк. Например, есть агрегатные функции, вычисляющие: <code class="function">count</code> (количество), <code class="function">sum</code> (сумму), <code class="function">avg</code> (среднее), <code class="function">max</code> (максимум) и <code class="function">min</code> (минимум) для набора строк.</p><p>К примеру, мы можем найти самую высокую из всех минимальных дневных температур: </p><pre class="programlisting">SELECT max(temp_lo) FROM weather;</pre><p> </p><pre class="screen">
 max
-----
  46
(1 row)
</pre><p><a id="id-1.4.4.8.5.1" class="indexterm"></a> Если мы хотим узнать, в каком городе (или городах) наблюдалась эта температура, можно попробовать: </p><pre class="programlisting">SELECT city FROM weather WHERE temp_lo = max(temp_lo);     <em class="lineannotation"><span class="lineannotation">НЕВЕРНО</span></em></pre><p> но это не будет работать, так как агрегатную функцию <code class="function">max</code> нельзя использовать в предложении <code class="literal">WHERE</code>. (Это ограничение объясняется тем, что предложение <code class="literal">WHERE</code> должно определить, для каких строк вычислять агрегатную функцию, так что оно, очевидно, должно вычисляться до агрегатных функций.) Однако как часто бывает, запрос можно переписать и получить желаемый результат, применив <em class="firstterm">подзапрос</em>: </p><pre class="programlisting">SELECT city FROM weather
    WHERE temp_lo = (SELECT max(temp_lo) FROM weather);</pre><p> </p><pre class="screen">
     city
---------------
 San Francisco
(1 row)
</pre><p> Теперь всё в порядке — подзапрос выполняется отдельно и результат агрегатной функции вычисляется вне зависимости от того, что происходит во внешнем запросе.</p><p><a id="id-1.4.4.8.6.1" class="indexterm"></a> <a id="id-1.4.4.8.6.2" class="indexterm"></a> Агрегатные функции также очень полезны в сочетании с предложением <code class="literal">GROUP BY</code>. Например, мы можем получить количество замеров и максимум минимальной дневной температуры в разрезе городов: </p><pre class="programlisting">SELECT city, count(*), max(temp_lo)
    FROM weather
    GROUP BY city;</pre><p> </p><pre class="screen">
     city      | count | max
---------------+-------+-----
 Hayward       |     1 |  37
 San Francisco |     2 |  46
(2 rows)
</pre><p> Здесь мы получаем по одной строке для каждого города. Каждый агрегатный результат вычисляется по строкам таблицы, соответствующим отдельному городу. Мы можем отфильтровать сгруппированные строки с помощью предложения <code class="literal">HAVING</code>: </p><pre class="programlisting">SELECT city, count(*), max(temp_lo)
    FROM weather
    GROUP BY city
    HAVING max(temp_lo) &lt; 40;</pre><p> </p><pre class="screen">
  city   | count | max
---------+-------+-----
 Hayward |     1 |  37
(1 row)
</pre><p> Мы получаем те же результаты, но только для тех городов, где все значения <code class="structfield">temp_lo</code> меньше 40. Наконец, если нас интересуют только города, названия которых начинаются с <span class="quote">«<span class="quote"><code class="literal">S</code></span>»</span>, мы можем сделать: </p><pre class="programlisting">SELECT city, count(*), max(temp_lo)
    FROM weather
    WHERE city LIKE 'S%'            -- <span id="co.tutorial-agg-like"></span>(1)
    GROUP BY city;</pre><p> </p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#co.tutorial-agg-like">(1)</a> </p></td><td valign="top" align="left"><p>Оператор <code class="literal">LIKE</code> (выполняющий сравнение по шаблону) рассматривается в <a class="xref" href="functions-matching.html" title="9.7. Поиск по шаблону">Разделе 9.7</a>.</p></td></tr></table></div><p>Важно понимать, как соотносятся агрегатные функции и <acronym class="acronym">SQL</acronym>-предложения <code class="literal">WHERE</code> и <code class="literal">HAVING</code>. Основное отличие <code class="literal">WHERE</code> от <code class="literal">HAVING</code> заключается в том, что <code class="literal">WHERE</code> сначала выбирает строки, а затем группирует их и вычисляет агрегатные функции (таким образом, она отбирает строки для вычисления агрегатов), тогда как <code class="literal">HAVING</code> отбирает строки групп после группировки и вычисления агрегатных функций. Как следствие, предложение <code class="literal">WHERE</code> не должно содержать агрегатных функций; не имеет смысла использовать агрегатные функции для определения строк для вычисления агрегатных функций. Предложение <code class="literal">HAVING</code>, напротив, всегда содержит агрегатные функции. (Строго говоря, вы можете написать предложение <code class="literal">HAVING</code>, не используя агрегаты, но это редко бывает полезно. То же самое условие может работать более эффективно на стадии <code class="literal">WHERE</code>.)</p><p>В предыдущем примере мы смогли применить фильтр по названию города в предложении <code class="literal">WHERE</code>, так как названия не нужно агрегировать. Такой фильтр эффективнее, чем дополнительное ограничение <code class="literal">HAVING</code>, потому что с ним не приходится группировать и вычислять агрегаты для всех строк, не удовлетворяющих условию <code class="literal">WHERE</code>.</p><p>Ещё один способ выбрать строки, которые входят в составные вычисления, — это использовать предложение <code class="literal">FILTER</code>, которое указывается для каждой агрегатной функции: </p><pre class="programlisting">SELECT city, count(*) FILTER (WHERE temp_lo &lt; 45), max(temp_lo)
    FROM weather
    GROUP BY city;</pre><p> </p><pre class="screen">
     city      | count | max
---------------+-------+-----
 Hayward       |     1 |  37
 San Francisco |     1 |  46
(2 rows)
</pre><p> Предложение <code class="literal">FILTER</code> очень похоже на <code class="literal">WHERE</code>, за исключением того, что отбрасываются входные строки только конкретной агрегатной функции, с которой оно используется. Здесь агрегатная функция <code class="literal">count</code> подсчитывает только строки с <code class="literal">temp_lo</code> ниже 45; но агрегатная функция <code class="literal">max</code> по-прежнему применяется ко всем строкам, поэтому находит значение 46.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="tutorial-join.html" title="2.6. Соединения таблиц">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="tutorial-sql.html" title="Глава 2. Язык SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="tutorial-update.html" title="2.8. Изменение данных">След.</a></td></tr><tr><td width="40%" align="left" valign="top">2.6. Соединения таблиц </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 2.8. Изменение данных</td></tr></table></div></body></html>