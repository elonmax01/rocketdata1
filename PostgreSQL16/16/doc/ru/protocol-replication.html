<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>55.4. Протокол потоковой репликации</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sasl-authentication.html" title="55.3. Аутентификация SASL" /><link rel="next" href="protocol-logical-replication.html" title="55.5. Протокол логической потоковой репликации" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">55.4. Протокол потоковой репликации</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sasl-authentication.html" title="55.3. Аутентификация SASL">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="protocol.html" title="Глава 55. Клиент-серверный протокол">Наверх</a></td><th width="60%" align="center">Глава 55. Клиент-серверный протокол</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="protocol-logical-replication.html" title="55.5. Протокол логической потоковой репликации">След.</a></td></tr></table><hr /></div><div class="sect1" id="PROTOCOL-REPLICATION"><div class="titlepage"><div><div><h2 class="title" style="clear: both">55.4. Протокол потоковой репликации <a href="#PROTOCOL-REPLICATION" class="id_link">#</a></h2></div></div></div><p>Чтобы инициировать потоковую репликацию, клиент передаёт в стартовом сообщении параметр <code class="literal">replication</code>. Логическое значение <code class="literal">true</code> (или <code class="literal">on</code>, <code class="literal">yes</code>, <code class="literal">1</code>) этого параметра указывает обслуживающему процессу перейти в режим передатчика данных физической репликации. В этом режиме вместо SQL-операторов клиент может выдавать только ограниченный набор команд репликации, показанный ниже.</p><p>Если параметр <code class="literal">replication</code> имеет значение <code class="literal">database</code>, обслуживающий процесс должен перейти в режим передатчика данных логической репликации. При этом выполняется подключение к базе данных, заданной в параметре <code class="literal">dbname</code>. В режиме логической репликации могут выполняться как команды репликации, показанные ниже, так и обычные SQL-команды.</p><p>В режиме передачи данных физической или логической репликации может использоваться только простой протокол запросов.</p><p>Для тестирования команд репликации вы можете установить соединение для репликации, запустив <span class="application">psql</span> или другую программу на базе <span class="application">libpq</span> со строкой подключения, включающей параметр <code class="literal">replication</code>, например так: </p><pre class="programlisting">psql "dbname=postgres replication=database" -c "IDENTIFY_SYSTEM;"</pre><p> Однако часто полезнее использовать <a class="xref" href="app-pgreceivewal.html" title="pg_receivewal"><span class="refentrytitle"><span class="application">pg_receivewal</span></span></a> (для физической репликации) или <a class="xref" href="app-pgrecvlogical.html" title="pg_recvlogical"><span class="refentrytitle"><span class="application">pg_recvlogical</span></span></a> (для логической).</p><p>Команды репликации записываются в журнал работы сервера, когда включён параметр <a class="xref" href="runtime-config-logging.html#GUC-LOG-REPLICATION-COMMANDS">log_replication_commands</a>.</p><p>В режиме репликации принимаются следующие команды: </p><div class="variablelist"><dl class="variablelist"><dt id="PROTOCOL-REPLICATION-IDENTIFY-SYSTEM"><span class="term"><code class="literal">IDENTIFY_SYSTEM</code>
      <a id="id-1.10.6.9.7.1.1.1.2" class="indexterm"></a>
     </span> <a href="#PROTOCOL-REPLICATION-IDENTIFY-SYSTEM" class="id_link">#</a></dt><dd><p>Запрашивает идентификационные данные сервера. Сервер возвращает набор результатов с одной строкой, содержащей четыре поля:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">systemid</code> (<code class="type">text</code>)</span></dt><dd><p>Уникальный идентификатор системы, идентифицирующий кластер. По нему можно определить, что базовая резервная копия, из которой инициализировался резервный сервер, получена из того же кластера.</p></dd><dt><span class="term"><code class="literal">timeline</code> (<code class="type">int8</code>)</span></dt><dd><p>Идентификатор текущей линии времени. Также полезен для того, чтобы убедиться, что резервный сервер согласован с главным.</p></dd><dt><span class="term"><code class="literal">xlogpos</code> (<code class="type">text</code>)</span></dt><dd><p>Текущее положение сохранённых данных в WAL. Позволяет узнать, с какой позиции в журнале предзаписи может начаться потоковая передача.</p></dd><dt><span class="term"><code class="literal">dbname</code> (<code class="type">text</code>)</span></dt><dd><p>Подключённая база данных или NULL.</p></dd></dl></div></dd><dt id="PROTOCOL-REPLICATION-SHOW"><span class="term"><code class="literal">SHOW</code> <em class="replaceable"><code>имя</code></em>
      <a id="id-1.10.6.9.7.1.2.1.3" class="indexterm"></a>
     </span> <a href="#PROTOCOL-REPLICATION-SHOW" class="id_link">#</a></dt><dd><p>Запрашивает у сервера текущее значение параметра времени выполнения. Эта команда подобна SQL-команде <a class="xref" href="sql-show.html" title="SHOW"><span class="refentrytitle">SHOW</span></a>.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>имя</code></em></span></dt><dd><p>Имя параметра времени выполнения. Доступные параметры описаны в <a class="xref" href="runtime-config.html" title="Глава 20. Настройка сервера">Главе 20</a>.</p></dd></dl></div></dd><dt id="PROTOCOL-REPLICATION-TIMELINE-HISTORY"><span class="term"><code class="literal">TIMELINE_HISTORY</code> <em class="replaceable"><code>лин_врем</code></em>
      <a id="id-1.10.6.9.7.1.3.1.3" class="indexterm"></a>
     </span> <a href="#PROTOCOL-REPLICATION-TIMELINE-HISTORY" class="id_link">#</a></dt><dd><p>Запрашивает с сервера файл истории для линии времени <em class="replaceable"><code>лин_врем</code></em>. Сервер возвращает набор результатов в одной строке, содержащей два поля. Эти поля обозначены как имеющие тип <code class="type">text</code>, но фактически они содержат просто байты, не в текстовой кодировке:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">filename</code> (<code class="type">text</code>)</span></dt><dd><p>Имя файла с историей линии времени, например <code class="filename">00000002.history</code>.</p></dd><dt><span class="term"><code class="literal">content</code> (<code class="type">text</code>)</span></dt><dd><p>Содержимое файла с историей линией времени.</p></dd></dl></div></dd><dt id="PROTOCOL-REPLICATION-CREATE-REPLICATION-SLOT"><span class="term"><code class="literal">CREATE_REPLICATION_SLOT</code> <em class="replaceable"><code>имя_слота</code></em> [ <code class="literal">TEMPORARY</code> ] { <code class="literal">PHYSICAL</code> | <code class="literal">LOGICAL</code> <em class="replaceable"><code>модуль_вывода</code></em> } [ ( <em class="replaceable"><code>параметр</code></em> [, ...] ) ] <a id="id-1.10.6.9.7.1.4.1.8" class="indexterm"></a></span> <a href="#PROTOCOL-REPLICATION-CREATE-REPLICATION-SLOT" class="id_link">#</a></dt><dd><p>Создаёт слот физической или логической репликации. Слоты репликации описаны подробно в <a class="xref" href="warm-standby.html#STREAMING-REPLICATION-SLOTS" title="27.2.6. Слоты репликации">Подразделе 27.2.6</a>.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>имя_слота</code></em></span></dt><dd><p>Имя создаваемого слота. Заданное имя должно быть допустимым для слота репликации (см. <a class="xref" href="warm-standby.html#STREAMING-REPLICATION-SLOTS-MANIPULATION" title="27.2.6.1. Запросы и действия слотов репликации">Подраздел 27.2.6.1</a>).</p></dd><dt><span class="term"><em class="replaceable"><code>модуль_вывода</code></em></span></dt><dd><p>Имя модуля вывода, применяемого для логического декодирования (см. <a class="xref" href="logicaldecoding-output-plugin.html" title="49.6. Модули вывода логического декодирования">Раздел 49.6</a>).</p></dd><dt><span class="term"><code class="literal">TEMPORARY</code></span></dt><dd><p>Это указание отмечает, что данный слот репликации является временным. Временные слоты не сохраняются на диске и автоматически удаляются при ошибке или завершении сеанса.</p></dd></dl></div><p>Поддерживаются следующие параметры:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">TWO_PHASE [ <em class="replaceable"><code>boolean</code></em> ]</code></span></dt><dd><p>Если параметр включён (по умолчанию он отключён), этот слот логической репликации поддерживает декодирование двухфазной фиксации. С этим параметром декодируются и передаются серверу команды, связанные с двухфазной фиксацией: <code class="literal">PREPARE TRANSACTION</code>, <code class="literal">COMMIT PREPARED</code> и <code class="literal">ROLLBACK PREPARED</code>. Транзакция будет декодироваться и передаваться во время <code class="literal">PREPARE TRANSACTION</code>.</p></dd><dt><span class="term"><code class="literal">RESERVE_WAL [ <em class="replaceable"><code>boolean</code></em> ]</code></span></dt><dd><p>Если параметр включён (по умолчанию он отключён), этот слот физической репликации резервирует <acronym class="acronym">WAL</acronym> немедленно. Без этого указания <acronym class="acronym">WAL</acronym> резервируется только при подключении клиента потоковой репликации.</p></dd><dt><span class="term"><code class="literal">SNAPSHOT { 'export' | 'use' | 'nothing' }</code></span></dt><dd><p>Эти указания выбирают, что делать со снимком, создаваемым при инициализации логического слота. С указанием <code class="literal">'export'</code>, подразумеваемым по умолчанию, этот снимок будет экспортироваться для использования в других сеансах. Это указание нельзя использовать внутри транзакции. С указанием <code class="literal">'use'</code> снимок будет использоваться для текущей транзакции, в которой выполняется команда. Это указание должно использоваться в транзакции, при этом команда <code class="literal">CREATE_REPLICATION_SLOT</code> должна быть первой в этой транзакции. Наконец, с <code class="literal">'nothing'</code> снимок будет использоваться только для логического декодирования в обычном режиме, и ничего больше с ним делать нельзя.</p></dd></dl></div><p>В ответ на эту команду сервер передаст набор результатов с одной строкой, содержащей следующие поля: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">slot_name</code> (<code class="type">text</code>)</span></dt><dd><p>Имя создаваемого слота репликации.</p></dd><dt><span class="term"><code class="literal">consistent_point</code> (<code class="type">text</code>)</span></dt><dd><p>Позиция в WAL, в которой слот достиг согласованного состояния. Это самая ранняя позиция, с которой может начаться трансляция через этот слот репликации.</p></dd><dt><span class="term"><code class="literal">snapshot_name</code> (<code class="type">text</code>)</span></dt><dd><p>Идентификатор снимка, экспортированного командой. Этот снимок действителен до тех пор, пока через это соединение не будет выполнена следующая команда или соединение не будет закрыто. Null, если созданный слот — физический.</p></dd><dt><span class="term"><code class="literal">output_plugin</code> (<code class="type">text</code>)</span></dt><dd><p>Имя модуля вывода, используемого созданным слотом репликации. Null, если созданный слот — физический.</p></dd></dl></div></dd><dt id="PROTOCOL-REPLICATION-CREATE-REPLICATION-SLOT-LEGACY"><span class="term"><code class="literal">CREATE_REPLICATION_SLOT</code> <em class="replaceable"><code>имя_слота</code></em> [ <code class="literal">TEMPORARY</code> ] { <code class="literal">PHYSICAL</code> [ <code class="literal">RESERVE_WAL</code> ] | <code class="literal">LOGICAL</code> <em class="replaceable"><code>модуль_вывода</code></em> [ <code class="literal">EXPORT_SNAPSHOT</code> | <code class="literal">NOEXPORT_SNAPSHOT</code> | <code class="literal">USE_SNAPSHOT</code> | <code class="literal">TWO_PHASE</code> ] }</span> <a href="#PROTOCOL-REPLICATION-CREATE-REPLICATION-SLOT-LEGACY" class="id_link">#</a></dt><dd><p>Такой вариант записи команды <code class="literal">CREATE_REPLICATION_SLOT</code> по-прежнему поддерживается для совместимости со старыми версиями.</p></dd><dt id="PROTOCOL-REPLICATION-READ-REPLICATION-SLOT"><span class="term"><code class="literal">READ_REPLICATION_SLOT</code> <em class="replaceable"><code>имя_слота</code></em>
      <a id="id-1.10.6.9.7.1.6.1.3" class="indexterm"></a>
     </span> <a href="#PROTOCOL-REPLICATION-READ-REPLICATION-SLOT" class="id_link">#</a></dt><dd><p>Считывает информацию о слоте репликации. Возвращает кортеж со значениями <code class="literal">NULL</code>, если указанный слот репликации не существует. Эта команда поддерживается только для слотов физической репликации.</p><p>В ответ на эту команду сервер вернёт набор результатов с одной строкой, содержащей следующие поля: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">slot_type</code> (<code class="type">text</code>)</span></dt><dd><p>Тип слота репликации: <code class="literal">physical</code> или <code class="literal">NULL</code>.</p></dd><dt><span class="term"><code class="literal">restart_lsn</code> (<code class="type">text</code>)</span></dt><dd><p><code class="literal">restart_lsn</code> слота репликации.</p></dd><dt><span class="term"><code class="literal">restart_tli</code> (<code class="type">int8</code>)</span></dt><dd><p>Идентификатор линии времени, связанной с <code class="literal">restart_lsn</code>, в текущей истории линии времени.</p></dd></dl></div></dd><dt id="PROTOCOL-REPLICATION-START-REPLICATION"><span class="term"><code class="literal">START_REPLICATION</code> [ <code class="literal">SLOT</code> <em class="replaceable"><code>имя_слота</code></em> ] [ <code class="literal">PHYSICAL</code> ] <em class="replaceable"><code>XXX/XXX</code></em> [ <code class="literal">TIMELINE</code> <em class="replaceable"><code>лин_врем</code></em> ] <a id="id-1.10.6.9.7.1.7.1.8" class="indexterm"></a></span> <a href="#PROTOCOL-REPLICATION-START-REPLICATION" class="id_link">#</a></dt><dd><p>Указывает серверу начать потоковую передачу WAL, начиная с позиции <em class="replaceable"><code>XXX/XXX</code></em> в WAL. Если указывается параметр <code class="literal">TIMELINE</code>, передача начинается на линии времени <em class="replaceable"><code>лин_врем</code></em>, иначе выбирается текущая линия времени сервера. Сервер может вернуть в ответ ошибку, например, если запрошенный сегмент WAL уже потерян. Если проблем не возникает, сервер возвращает сообщение CopyBothResponse, а затем начинает передавать поток WAL клиенту.</p><p>Если в параметрах передаётся <em class="replaceable"><code>имя_слота</code></em>, сервер будет отражать состояние репликации в этом слоте и отслеживать, какие сегменты, а если включён режим <code class="varname">hot_standby_feedback</code>, то и в каких транзакциях, всё ещё нужны этому резервному серверу.</p><p>Если клиент запрашивает не последнюю, но существующую в истории сервера линию времени, сервер будет передавать весь WAL на этой линии времени, начиная с запрошенной стартовой точки до момента, когда сервер переключился на другую линию времени. Если клиент запрашивает передачу с начальной позицией точно в конце старой линии времени, сервер полностью пропускает режим COPY.</p><p>После передачи всех записей WAL на линии времени, не являющейся текущей, сервер завершает потоковую передачу, выходя из режима копирования. Когда клиент подтверждает завершение передачи, также выходя из режима копирования, сервер возвращает набор результатов в одной строке с двумя столбцами, сообщая таким образом о следующей линии времени в истории сервера. В первом столбце передаётся идентификатор следующей линии времени (типа <code class="type">int8</code>), а во втором — позиция в WAL, в которой произошло переключение (типа <code class="type">text</code>). Обычно в этой же позиции завершается передача потока WAL, но возможны исключения, когда сервер может передавать записи WAL из старой линии времени, которые он сам ещё не воспроизвёл до переключения. Наконец сервер передаёт два сообщения CommandComplete (одно говорит о завершении CopyData, а второе — о завершении самой команды <code class="literal">START_REPLICATION</code>), после чего он готов принять следующую команду.</p><p>Данные WAL передаются в серии сообщений CopyData. (Это позволяет перемежать их с другой информацией; в частности, сервер может передать сообщение ErrorResponse, если он столкнулся с проблемами, уже начав передачу потока.) Полезная нагрузка каждого сообщения CopyData от сервера к клиенту содержит данные в одном из следующих форматов:</p><div class="variablelist"><dl class="variablelist"><dt id="PROTOCOL-REPLICATION-XLOGDATA"><span class="term">XLogData (B) — данные журнала транзакций</span> <a href="#PROTOCOL-REPLICATION-XLOGDATA" class="id_link">#</a></dt><dd><div class="variablelist"><dl class="variablelist"><dt><span class="term">Byte1('w')</span></dt><dd><p>Указывает, что в этом сообщении передаются данные WAL.</p></dd><dt><span class="term">Int64</span></dt><dd><p>Начальная точка данных WAL в этом сообщении.</p></dd><dt><span class="term">Int64</span></dt><dd><p>Текущее положение конца WAL на сервере.</p></dd><dt><span class="term">Int64</span></dt><dd><p>Показания системных часов сервера в момент передачи, в микросекундах с полуночи 2000-01-01.</p></dd><dt><span class="term">Byte<em class="replaceable"><code>n</code></em></span></dt><dd><p>Фрагмент потока данных WAL.</p><p>Одна запись WAL никогда не разделяется на два сообщения XLogData. Когда запись WAL пересекает границу страницы WAL, и таким образом от неё уже оказывается отделена продолжающая запись, её можно разделить на сообщения по границе страницы. Другими словами, первая основная запись WAL и продолжающие её записи могут быть переданы в различных сообщениях XLogData.</p></dd></dl></div></dd><dt id="PROTOCOL-REPLICATION-PRIMARY-KEEPALIVE-MESSAGE"><span class="term">Primary keepalive message (B) — Сообщение об активности ведущего</span> <a href="#PROTOCOL-REPLICATION-PRIMARY-KEEPALIVE-MESSAGE" class="id_link">#</a></dt><dd><div class="variablelist"><dl class="variablelist"><dt><span class="term">Byte1('k')</span></dt><dd><p>Указывает, что это сообщение об активности отправителя.</p></dd><dt><span class="term">Int64</span></dt><dd><p>Текущее положение конца WAL на сервере.</p></dd><dt><span class="term">Int64</span></dt><dd><p>Показания системных часов сервера в момент передачи, в микросекундах с полуночи 2000-01-01.</p></dd><dt><span class="term">Byte1</span></dt><dd><p>Значение 1 означает, что клиент должен ответить на это сообщение как можно скорее, во избежание отключения по тайм-ауту. Со значением 0 это не требуется.</p></dd></dl></div></dd></dl></div><p>Принимающий процесс может передавать ответы отправителю в любое время, используя один из следующих форматов данных (также в полезной нагрузке сообщения CopyData):</p><div class="variablelist"><dl class="variablelist"><dt id="PROTOCOL-REPLICATION-STANDBY-STATUS-UPDATE"><span class="term">Standby status update (F) — Обновление состояния резервного сервера</span> <a href="#PROTOCOL-REPLICATION-STANDBY-STATUS-UPDATE" class="id_link">#</a></dt><dd><div class="variablelist"><dl class="variablelist"><dt><span class="term">Byte1('r')</span></dt><dd><p>Указывает, что это сообщение передаёт обновлённое состояние получателя.</p></dd><dt><span class="term">Int64</span></dt><dd><p>Положение следующего за последним байтом WAL, полученным и записанным на диск на резервном сервере.</p></dd><dt><span class="term">Int64</span></dt><dd><p>Положение следующего за последним байтом WAL, сохранённым на диске на резервном сервере.</p></dd><dt><span class="term">Int64</span></dt><dd><p>Положение следующего за последним байтом WAL, применённым на резервном сервере.</p></dd><dt><span class="term">Int64</span></dt><dd><p>Показания системных часов клиента в момент передачи, в микросекундах с полуночи 2000-01-01.</p></dd><dt><span class="term">Byte1</span></dt><dd><p>Если содержит 1, клиент запрашивает от сервера немедленный ответ на это сообщение. Так клиент может запросить отклик сервера и проверить, продолжает ли функционировать соединение.</p></dd></dl></div></dd><dt id="PROTOCOL-REPLICATION-HOT-STANDBY-FEEDBACK-MESSAGE"><span class="term">Hot standby feedback message (F) — Сообщение обратной связи горячего резерва</span> <a href="#PROTOCOL-REPLICATION-HOT-STANDBY-FEEDBACK-MESSAGE" class="id_link">#</a></dt><dd><div class="variablelist"><dl class="variablelist"><dt><span class="term">Byte1('h')</span></dt><dd><p>Указывает, что это сообщение обратной связи горячего резерва.</p></dd><dt><span class="term">Int64</span></dt><dd><p>Показания системных часов клиента в момент передачи, в микросекундах с полуночи 2000-01-01.</p></dd><dt><span class="term">Int32</span></dt><dd><p>Текущее глобальное значение xmin данного резервного сервера, не учитывающее catalog_xmin всех слотов репликации. Если и это значение, и следующее catalog_xmin, равны 0, это воспринимается как уведомление о том, что через данное подключение больше не будут передаваться сообщения обратной связи горячего резерва. Последующие ненулевые сообщения могут возобновить работу механизма обратной связи.</p></dd><dt><span class="term">Int32</span></dt><dd><p>Эпоха глобального идентификатора транзакции xmin на резервном сервере.</p></dd><dt><span class="term">Int32</span></dt><dd><p>Наименьшее значение catalog_xmin для всех слотов репликации на резервном сервере. Значение 0 показывает, что на резервном сервере нет catalog_xmin, либо обратная связь горячего резерва отключена.</p></dd><dt><span class="term">Int32</span></dt><dd><p>Эпоха идентификатора транзакции catalog_xmin на резервном сервере.</p></dd></dl></div></dd></dl></div></dd><dt id="PROTOCOL-REPLICATION-START-REPLICATION-SLOT-LOGICAL"><span class="term"><code class="literal">START_REPLICATION</code> <code class="literal">SLOT</code> <em class="replaceable"><code>имя_слота</code></em> <code class="literal">LOGICAL</code> <em class="replaceable"><code>XXX/XXX</code></em> [ ( <em class="replaceable"><code>имя_параметра</code></em> [ <em class="replaceable"><code>значение_параметра</code></em> ] [, ...] ) ]</span> <a href="#PROTOCOL-REPLICATION-START-REPLICATION-SLOT-LOGICAL" class="id_link">#</a></dt><dd><p>Указывает серверу начинать потоковую передачу WAL для логической репликации с позиции <em class="replaceable"><code>XXX/XXX</code></em> в WAL или с <code class="literal">confirmed_flush_lsn</code> слота (см. <a class="xref" href="view-pg-replication-slots.html" title="54.19. pg_replication_slots">Раздел 54.19</a>), если это значение больше. Таким образом клиентам не приходится обновлять локальный статус LSN, если не нужно обрабатывать данные. Однако в случаях, когда репликация начинается не с запрошенного LSN, некоторые ошибки на стороне клиента могут остаться незамеченными. Поэтому прежде чем передавать <code class="literal">START_REPLICATION</code>, имеет смысл запросить значение <code class="literal">confirmed_flush_lsn</code> и убедиться в том, что оно соответствует ожиданиям.</p><p>Сервер может вернуть в ответ ошибку, например, если такого слота нет. Если проблем не возникает, сервер возвращает сообщение CopyBothResponse, а затем начинает передавать поток WAL клиенту.</p><p>Данные, передаваемые внутри сообщений CopyBothResponse, имеют тот же формат, что описан для команды <code class="literal">START_REPLICATION ... PHYSICAL</code>, включая два сообщения CommandComplete.</p><p>Обработку выводимых данных для передачи выполняет модуль вывода, связанный с выбранным слотом.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">SLOT</code> <em class="replaceable"><code>имя_слота</code></em></span></dt><dd><p>Имя слота, из которого передаются изменения. Это имя является обязательным, оно должно соответствовать существующему логическому слоту репликации, созданному командой <code class="literal">CREATE_REPLICATION_SLOT</code> в режиме <code class="literal">LOGICAL</code>.</p></dd><dt><span class="term"><em class="replaceable"><code>XXX/XXX</code></em></span></dt><dd><p>Позиция в WAL, с которой должна начаться передача.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_параметра</code></em></span></dt><dd><p>Имя параметра, передаваемого модулю вывода логического декодирования для выбранного слота. Параметры, принимаемые стандартным модулем (<code class="literal">pgoutput</code>), описаны в <a class="xref" href="protocol-logical-replication.html" title="55.5. Протокол логической потоковой репликации">Разделе 55.5</a>.</p></dd><dt><span class="term"><em class="replaceable"><code>значение_параметра</code></em></span></dt><dd><p>Необязательное значение, в форме строковой константы, связываемое с указанным параметром.</p></dd></dl></div></dd><dt id="PROTOCOL-REPLICATION-DROP-REPLICATION-SLOT"><span class="term">
      <code class="literal">DROP_REPLICATION_SLOT</code> <em class="replaceable"><code>имя_слота</code></em> [<span class="optional"> <code class="literal">WAIT</code> </span>]
      <a id="id-1.10.6.9.7.1.9.1.4" class="indexterm"></a>
     </span> <a href="#PROTOCOL-REPLICATION-DROP-REPLICATION-SLOT" class="id_link">#</a></dt><dd><p>Удаляет слот репликации, что приводит к освобождению всех занятых им ресурсов на стороне сервера. Если слот представляет собой логический слот, созданный не в той базе данных, к которой подключён walsender, команда завершается ошибкой.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>имя_слота</code></em></span></dt><dd><p>Имя слота, подлежащего удалению.</p></dd><dt><span class="term"><code class="literal">WAIT</code></span></dt><dd><p>С этим указанием команда будет ждать, пока активный слот не станет неактивным (по умолчанию в этом случае выдаётся ошибка).</p></dd></dl></div></dd><dt id="PROTOCOL-REPLICATION-BASE-BACKUP"><span class="term"><code class="literal">BASE_BACKUP</code> [ ( <em class="replaceable"><code>параметр</code></em> [, ...] ) ] <a id="id-1.10.6.9.7.1.10.1.3" class="indexterm"></a></span> <a href="#PROTOCOL-REPLICATION-BASE-BACKUP" class="id_link">#</a></dt><dd><p>Указывает серверу начать потоковую передачу базовой копии. Система автоматически переходит в режим резервного копирования до начала передачи, и выходит из него после завершения копирования. Эта команда принимает следующие параметры: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">LABEL</code> <em class="replaceable"><code>'метка'</code></em></span></dt><dd><p>Устанавливает метку для резервной копии. Если метка не задана, по умолчанию устанавливается метка <code class="literal">base backup</code>. Для метки действуют те же правила применения кавычек, что и для стандартных строк SQL при включённым режиме <a class="xref" href="runtime-config-compatible.html#GUC-STANDARD-CONFORMING-STRINGS">standard_conforming_strings</a>.</p></dd><dt><span class="term"><code class="literal">TARGET</code> <em class="replaceable"><code>получатель</code></em></span></dt><dd><p>Указывает серверу, куда передавать резервную копию. Если выбрано значение <code class="literal">client</code>, используемое по умолчанию, данные резервной копии передаются клиенту. При значении <code class="literal">server</code> файлы копии записываются на сервере в каталог, заданный параметром <code class="literal">TARGET_DETAIL</code>. При значении <code class="literal">blackhole</code> данные никуда не передаются, а просто отбрасываются.</p><p>Чтобы установить значение <code class="literal">server</code>, нужно иметь права суперпользователя или роли <code class="literal">pg_write_server_files</code>.</p></dd><dt><span class="term"><code class="literal">TARGET_DETAIL</code> <em class="replaceable"><code>дополнительная_информация</code></em></span></dt><dd><p>Дополнительная информация о получателе.</p><p>Сейчас этот параметр можно использовать, только когда получателем является <code class="literal">server</code>. Указывает каталог хранения данных на целевом сервере.</p></dd><dt><span class="term"><code class="literal">PROGRESS [ <em class="replaceable"><code>boolean</code></em> ]</code></span></dt><dd><p>Если параметр включён (по умолчанию он отключён), запрашивается информация, необходимая для отслеживания прогресса операции. Сервер передаёт в ответ приблизительный размер в заголовке каждого табличного пространства, исходя из которого можно понять, насколько продвинулась передача потока. Для вычисления этого размера анализируются размеры всех файлов ещё до начала передачи, и это может негативно повлиять на производительность — в частности, может увеличиться задержка передачи первых данных. Так как файлы базы данных могут меняться во время резервного копирования, оценка размера не будет точной; размер базы может увеличиться или уменьшиться за время от вычисления этой оценки до передачи актуальных файлов.</p></dd><dt><span class="term"><code class="literal">CHECKPOINT { 'fast' | 'spread' }</code></span></dt><dd><p>Задаёт тип контрольной точки, которая будет выполняться в начале базового копирования. По умолчанию <code class="literal">spread</code> (протяжённая).</p></dd><dt><span class="term"><code class="literal">WAL [ <em class="replaceable"><code>boolean</code></em> ]</code></span></dt><dd><p>Если параметр включён (по умолчанию он отключён), в резервную копию помещаются необходимые сегменты WAL. При этом в подкаталог <code class="filename">pg_wal</code> архива базового каталога будут помещены все файлы с начала до конца копирования.</p></dd><dt><span class="term"><code class="literal">WAIT [ <em class="replaceable"><code>boolean</code></em> ]</code></span></dt><dd><p>Если параметр включён (по умолчанию), при копировании ожидается завершение архивации последнего требуемого сегмента WAL либо выдаётся предупреждение, если архивация WAL не включена. Если отключён, при копировании не будет ни ожидания, ни предупреждений, так что обеспечение наличия требуемого журнала становится задачей клиента.</p></dd><dt><span class="term"><code class="literal">COMPRESSION</code> <em class="replaceable"><code>метод</code></em></span></dt><dd><p>Указывает серверу метод сжатия данных резервной копии. На данный момент поддерживаются следующие методы: <code class="literal">gzip</code>, <code class="literal">lz4</code> и <code class="literal">zstd</code>.</p></dd><dt><span class="term"><code class="literal">COMPRESSION_DETAIL</code> <em class="replaceable"><code>дополнительная_информация</code></em></span></dt><dd><p>Дополнительная информация для выбранного метода сжатия. Используется только вместе с параметром <code class="literal">COMPRESSION</code>. Если значение параметра — целое число, оно обозначает уровень сжатия. В противном случае значение должно представлять собой список ключевых слов, разделённых запятыми, в форме <em class="replaceable"><code>ключевое_слово</code></em> или <em class="replaceable"><code>ключевое_слово=значение</code></em>. На данный момент поддерживаются ключевые слова <code class="literal">level</code>, <code class="literal">long</code> и <code class="literal">workers</code>.</p><p>Ключевое слово <code class="literal">level</code> задаёт уровень сжатия. Для <code class="literal">gzip</code> уровень сжатия задаётся целым числом от <code class="literal">1</code> до <code class="literal">9</code> (по умолчанию <code class="literal">Z_DEFAULT_COMPRESSION</code> или <code class="literal">-1</code>), для <code class="literal">lz4</code> — целым числом от 1 до 12 (по умолчанию <code class="literal">0</code> для максимально быстрого сжатия), а для <code class="literal">zstd</code> — целым числом от <code class="literal">ZSTD_minCLevel()</code> (обычно <code class="literal">-131072</code>) до <code class="literal">ZSTD_maxCLevel()</code> (обычно <code class="literal">22</code>), по умолчанию <code class="literal">ZSTD_CLEVEL_DEFAULT</code> или <code class="literal">3</code>.</p><p>Ключевое слово <code class="literal">long</code> включает режим поиска соответствий на большой дистанции для улучшения коэффициента сжатия за счёт повышения нагрузки на память. Этот режим поддерживается только для <code class="literal">zstd</code>.</p><p>Ключевое слово <code class="literal">workers</code> задаёт число параллельных потоков для сжатия. Сжатие в несколько параллельных потоков поддерживается только для <code class="literal">zstd</code>.</p></dd><dt><span class="term"><code class="literal">MAX_RATE</code> <em class="replaceable"><code>скорость</code></em></span></dt><dd><p>Ограничивает (сдерживает) максимальный объём данных, передаваемый от сервера клиенту за единицу времени. Единица измерения этого параметра — килобайты в секунду. Если задаётся этот параметр, его значение должно быть равно нулю, либо должно находиться в диапазоне от 32 (килобайт/сек) до 1 Гбайта/сек (включая границы). Если передаётся ноль, либо параметр не задаётся, скорость передачи не ограничивается.</p></dd><dt><span class="term"><code class="literal">TABLESPACE_MAP [ <em class="replaceable"><code>boolean</code></em> ]</code></span></dt><dd><p>Если параметр включён (по умолчанию он отключён), информация о символических ссылках, существующих в каталоге <code class="filename">pg_tblspc</code>, включается в файл <code class="filename">tablespace_map</code>. Файл карты табличных пространств содержит имена всех ссылок, содержащихся в каталоге <code class="filename">pg_tblspc/</code>, и полный путь для каждой ссылки.</p></dd><dt><span class="term"><code class="literal">VERIFY_CHECKSUMS [ <em class="replaceable"><code>boolean</code></em> ]</code></span></dt><dd><p>Если параметр включён (по умолчанию), контрольные суммы проверяются в процессе резервного копирования, когда они присутствуют. При отключении параметра эта проверка опускается.</p></dd><dt><span class="term"><code class="literal">MANIFEST</code> <em class="replaceable"><code>параметр_манифеста</code></em></span></dt><dd><p>Когда указывается этот параметр, и он имеет значение <code class="literal">yes</code> или <code class="literal">force-encode</code>, вместе с копией создаётся и передаётся манифест копии. Манифест содержит список всех файлов, содержащихся в копии, за исключением файлов WAL, которые могут быть добавлены дополнительно. В нём также сохраняется размер, дата последнего изменения и, возможно, контрольная сумма каждого файла. Значение <code class="literal">force-encode</code> указывает, что все имена файлов должны кодироваться в шестнадцатеричном виде; по умолчанию кодироваться будут только те имена, которые представлены не байтовыми последовательностями UTF-8. Это значение предназначено в первую очередь для тестирования, чтобы можно было проверить, что клиентские программы могут корректно прочитать закодированные имена. Для совместимости с предыдущими версиями подразумевается значение <code class="literal">MANIFEST 'no'</code>.</p></dd><dt><span class="term"><code class="literal">MANIFEST_CHECKSUMS</code> <em class="replaceable"><code>алгоритм_контрольной_суммы</code></em></span></dt><dd><p>Задаёт алгоритм контрольных сумм, которые будут рассчитываться для всех файлов, описанных в манифесте копии. В настоящее время поддерживаются алгоритмы <code class="literal">NONE</code> (отсутствует), <code class="literal">CRC32C</code>, <code class="literal">SHA224</code>, <code class="literal">SHA256</code>, <code class="literal">SHA384</code> и <code class="literal">SHA512</code>. По умолчанию применяется <code class="literal">CRC32C</code>.</p></dd></dl></div><p>Когда запускается копирование, сервер сначала передаёт два обычных набора результатов, за которыми следуют один или более результатов CopyOutResponse.</p><p>В первом обычном наборе результатов передаётся начальная позиция резервной копии, в одной строке с двумя столбцами. В первом столбце содержится стартовая позиция в формате XLogRecPtr, а во втором идентификатор соответствующей линии времени.</p><p>Во втором обычном наборе результатов передаётся по одной строке для каждого табличного пространства. Эта строка содержит следующие поля: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">spcoid</code> (<code class="type">oid</code>)</span></dt><dd><p>OID табличного пространства либо NULL, если это базовый каталог.</p></dd><dt><span class="term"><code class="literal">spclocation</code> (<code class="type">text</code>)</span></dt><dd><p>Полный путь к каталогу табличного пространства либо NULL, если это базовый каталог.</p></dd><dt><span class="term"><code class="literal">size</code> (<code class="type">int8</code>)</span></dt><dd><p>Приблизительный размер табличного пространства (в килобайтах, размером 1024 байта), если была запрошена информация о прогрессе операции; в противном случае NULL.</p></dd></dl></div><p>За вторым обычным набором результатов следует сообщение CopyOutResponse. Полезной нагрузкой каждого последующего сообщения CopyData будет сообщение в одном из следующих форматов:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">new archive (B)</span></dt><dd><div class="variablelist"><dl class="variablelist"><dt><span class="term">Byte1('n')</span></dt><dd><p>Указывает, что это сообщение начинает новый архив. Сервер передаст один архив для основного каталога данных и по одному для каждого дополнительного табличного пространства. Данные в архиве представлены в формате tar (<span class="quote">«<span class="quote">формате обмена ustar</span>»</span>, описанном в стандарте POSIX 1003.1-2008).</p></dd><dt><span class="term">String</span></dt><dd><p>Имя файла этого архива.</p></dd><dt><span class="term">String</span></dt><dd><p>Для основного каталога данных пустая строка. Для других табличных пространств — полный путь к каталогу, для которого был создан архив.</p></dd></dl></div></dd><dt><span class="term">manifest (B)</span></dt><dd><div class="variablelist"><dl class="variablelist"><dt><span class="term">Byte1('m')</span></dt><dd><p>Указывает, что это сообщение начинает манифест копии.</p></dd></dl></div></dd><dt><span class="term">archive or manifest data (B)</span></dt><dd><div class="variablelist"><dl class="variablelist"><dt><span class="term">Byte1('d')</span></dt><dd><p>Указывает, что это сообщение передаёт данные архива или манифеста.</p></dd><dt><span class="term">Byte<em class="replaceable"><code>n</code></em></span></dt><dd><p>Байты данных.</p></dd></dl></div></dd><dt><span class="term">progress report (B)</span></dt><dd><div class="variablelist"><dl class="variablelist"><dt><span class="term">Byte1('p')</span></dt><dd><p>Указывает, что в этом сообщении передаётся отчёт о выполнении.</p></dd><dt><span class="term">Int64</span></dt><dd><p>Объём обработанных данных в текущем табличном пространстве в байтах.</p></dd></dl></div></dd></dl></div><p>После передачи сообщения CopyOutResponse или всех таких сообщений передаётся обычный набор результатов, в котором содержится конечная позиция копии в WAL, в том же формате, что и стартовая позиция.</p><p>Архив tar каталога данных и всех табличных пространств будет содержать все файлы в этих каталогах, будь то файлы <span class="productname">PostgreSQL</span> или посторонние файлы, добавленные в эти каталоги. Исключение составляют только следующие файлы: </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p>
          <code class="filename">postmaster.pid</code>
         </p></li><li class="listitem" style="list-style-type: disc"><p>
          <code class="filename">postmaster.opts</code>
         </p></li><li class="listitem" style="list-style-type: disc"><p><code class="filename">pg_internal.init</code> (находится в нескольких каталогах)</p></li><li class="listitem" style="list-style-type: disc"><p>Различные временные файлы и каталоги, создаваемые в процессе работы сервером PostgreSQL, в частности, файлы и каталоги с именами, начинающимися с <code class="filename">pgsql_tmp</code>, и временные отношения.</p></li><li class="listitem" style="list-style-type: disc"><p>Нежурналируемые отношения, за исключением слоя инициализации, который необходим при восстановлении для пересоздания нежурналируемого отношения (пустого).</p></li><li class="listitem" style="list-style-type: disc"><p><code class="filename">pg_wal</code>, включая подкаталоги. Если в резервную копию включаются файлы WAL, в архив входит преобразованная версия <code class="filename">pg_wal</code>, в которой будут находиться только файлы, необходимые для восстановления копии, но не всё остальное содержимое этого каталога</p></li><li class="listitem" style="list-style-type: disc"><p><code class="filename">pg_dynshmem</code>, <code class="filename">pg_notify</code>, <code class="filename">pg_replslot</code>, <code class="filename">pg_serial</code>, <code class="filename">pg_snapshots</code>, <code class="filename">pg_stat_tmp</code> и <code class="filename">pg_subtrans</code> копируются как пустые каталоги (даже если это символические ссылки)</p></li><li class="listitem" style="list-style-type: disc"><p>Файлы, кроме обычных файлов и каталогов, например, символические ссылки (кроме вышеупомянутых каталогов), а также файлы специальных устройств и файлы операционных систем, пропускаются (символические ссылки в <code class="filename">pg_tblspc</code> сохраняются).</p></li></ul></div><p> Если файловая система сервера поддерживает это, в архив включается информация о владельце, группе и режиме файла.</p></dd></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sasl-authentication.html" title="55.3. Аутентификация SASL">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="protocol.html" title="Глава 55. Клиент-серверный протокол">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="protocol-logical-replication.html" title="55.5. Протокол логической потоковой репликации">След.</a></td></tr><tr><td width="40%" align="left" valign="top">55.3. Аутентификация SASL </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 55.5. Протокол логической потоковой репликации</td></tr></table></div></body></html>