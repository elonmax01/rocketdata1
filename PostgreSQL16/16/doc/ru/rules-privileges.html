<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>41.5. Правила и права</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="rules-update.html" title="41.4. Правила для INSERT, UPDATE и DELETE" /><link rel="next" href="rules-status.html" title="41.6. Правила и статус команд" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">41.5. Правила и права</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="rules-update.html" title="41.4. Правила для INSERT, UPDATE и DELETE">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="rules.html" title="Глава 41. Система правил">Наверх</a></td><th width="60%" align="center">Глава 41. Система правил</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="rules-status.html" title="41.6. Правила и статус команд">След.</a></td></tr></table><hr /></div><div class="sect1" id="RULES-PRIVILEGES"><div class="titlepage"><div><div><h2 class="title" style="clear: both">41.5. Правила и права <a href="#RULES-PRIVILEGES" class="id_link">#</a></h2></div></div></div><a id="id-1.8.6.10.2" class="indexterm"></a><a id="id-1.8.6.10.3" class="indexterm"></a><p>В результате переписывания запросов системой правил <span class="productname">PostgreSQL</span> обращение может происходить не к тем таблицам/представлениям, к которым обращался исходный запрос. С правилами для изменения возможна так же и запись в другие таблицы.</p><p>Правила перезаписи не имеют отдельного владельца — владельцем правил перезаписи, определённых для отношения (таблицы или представления), автоматически считается владелец этого отношения. Система правил <span class="productname">PostgreSQL</span> меняет поведение стандартного механизма управления доступом. Ко всем отношениям, используемым вследствие применения правил, проверяется доступ владельца правила, но не пользователя, выполняющего запрос (кроме представлений с характеристикой SECURITY INVOKER по правилам <code class="literal">SELECT</code>, см. <a class="link" href="sql-createview.html" title="CREATE VIEW"><code class="command">CREATE VIEW</code></a>). Это значит, что если речь идёт не о таких представлениях, пользователь должен иметь права, необходимые только для обращения к таблицам/представлениям, которые он явно упоминает в своих запросах.</p><p>Например, представим, что у пользователя есть список телефонных номеров, некоторые из которых личные, а некоторые должна знать его ассистентка. Он может построить следующую конструкцию: </p><pre class="programlisting">CREATE TABLE phone_data (person text, phone text, private boolean);
CREATE VIEW phone_number AS
    SELECT person, CASE WHEN NOT private THEN phone END AS phone
    FROM phone_data;
GRANT SELECT ON phone_number TO assistant;</pre><p> Никто, кроме него (и суперпользователей базы данных) не сможет обратиться к таблице <code class="literal">phone_data</code>. Но так как ассистентке было дано (<code class="command">GRANT</code>) соответствующее право, она сможет выполнить <code class="command">SELECT</code> для представления <code class="literal">phone_number</code>. Система правил преобразует <code class="command">SELECT</code> из <code class="literal">phone_number</code> в <code class="command">SELECT</code> из таблицы <code class="literal">phone_data</code>. Так как пользователь является владельцем <code class="literal">phone_number</code>, он же считается владельцем правила, доступ на чтение <code class="literal">phone_data</code> проверяется для него, и выполнение запроса разрешается. Проверка прав доступа к <code class="literal">phone_number</code> тоже выполняется, но при этом проверяется пользователь, выполняющий запрос, так что обращаться к этому представлению смогут только сам пользователь и его ассистентка.</p><p>Права проверяются правило за правилом. То есть, в данный момент только ассистентка может видеть открытые телефонные номера. Но она может создать другое представление и дать доступ к нему всем (роли <code class="literal">public</code>), после чего все смогут видеть данные <code class="literal">phone_number</code> через представление ассистентки. Что она не может сделать, так это создать представление, которое обращается к <code class="literal">phone_data</code> напрямую. (Вообще она может это сделать, но такое представление не будет работать, так как при любой попытке прочитать его доступ к таблице будет запрещён.) И как только пользователь заметит, что ассистентка открыла доступ к своему представлению <code class="literal">phone_number</code>, он может лишить её права чтения этого представления. В результате все сразу потеряют доступ и к представлению ассистентки.</p><p>Может показаться, что такая проверка <span class="quote">«<span class="quote">правило-за-правилом</span>»</span> представляет уязвимость, но это не так. Если бы даже этот механизм не работал, ассистентка могла бы создать таблицу со столбцами как в <code class="literal">phone_number</code> и регулярно копировать туда данные. Тогда это были бы её собственные данные и она могла бы открывать доступ к ним кому угодно. Другими словами, команда <code class="command">GRANT</code> означает <span class="quote">«<span class="quote">Я доверяю тебе</span>»</span>. Если кто-то, кому вы доверяете, проделывает такие операции, стоит задуматься и, возможно, лишить его доступа к данным, применив <code class="command">REVOKE</code>.</p><p>Хотя представления могут применяться для скрытия содержимого определённых столбцов, как описано выше, с их помощью нельзя надёжно скрыть данные в невидимых строках, если только не установлен флаг <code class="literal">security_barrier</code>. Например, следующее представление небезопасно: </p><pre class="programlisting">CREATE VIEW phone_number AS
    SELECT person, phone FROM phone_data WHERE phone NOT LIKE '412%';</pre><p> Может показаться, что всё в порядке, ведь система правил преобразует <code class="command">SELECT</code> из <code class="literal">phone_number</code> в <code class="command">SELECT</code> из <code class="literal">phone_data</code> и добавит ограничивающее условие, чтобы выдавались только строки с полем <code class="literal">phone</code>, начинающимся не с 412. Но если пользователь может создавать собственные функции, ему будет не сложно заставить планировщик выполнять функцию пользователя перед выражением <code class="function">NOT LIKE</code>. Например: </p><pre class="programlisting">CREATE FUNCTION tricky(text, text) RETURNS bool AS $$
BEGIN
    RAISE NOTICE '% =&gt; %', $1, $2;
    RETURN true;
END;
$$ LANGUAGE plpgsql COST 0.0000000000000000000001;

SELECT * FROM phone_number WHERE tricky(person, phone);</pre><p> Так он сможет получить все имена и номера телефонов из таблицы <code class="literal">phone_data</code> через сообщения <code class="literal">NOTICE</code>, так как планировщик решит, что лучше выполнить недорогую функцию <code class="function">tricky</code> перед более дорогой операцией <code class="function">NOT LIKE</code>. И даже если пользователь не имеет права создавать новые функции, он может использовать для подобных атак встроенные функции. (Например, многие функции приведения показывают входные значения в сообщениях об ошибках.)</p><p>Подобные соображения распространяются и на правила для изменения. Применительно к примерам предыдущего раздела, владелец таблиц в базе данных может дать кому-нибудь другому для представления <code class="literal">shoelace</code> права <code class="literal">SELECT</code>, <code class="literal">INSERT</code>, <code class="literal">UPDATE</code> и <code class="literal">DELETE</code>, а для <code class="literal">shoelace_log</code> только <code class="literal">SELECT</code>. Действие правила, добавляющее записи в журнал, всё равно будет выполняться успешно, а этот другой пользователь сможет видеть записи в журнале. Но он не сможет создавать поддельные записи, равно как и модифицировать или удалять существующие. В этом случае нет никакой возможности заставить планировщик изменить порядок операций, так как единственное правило, которое обращается к <code class="literal">shoelace_log</code> — это безусловный <code class="literal">INSERT</code>. В более сложных сценариях это может быть не так.</p><p>Когда требуется, чтобы представление обеспечивало защиту на уровне строк, к нему нужно применить атрибут <code class="literal">security_barrier</code>. Это предотвратит утечку содержимого строк из злонамеренно выбранных функций и операторов до того, как строки будут отфильтрованы представлением. Например, показанное выше представление будет безопасным, если создать его так: </p><pre class="programlisting">CREATE VIEW phone_number WITH (security_barrier) AS
    SELECT person, phone FROM phone_data WHERE phone NOT LIKE '412%';</pre><p> Представления, созданные с атрибутом <code class="literal">security_barrier</code>, могут работать гораздо медленнее, чем обычные. И вообще говоря, это неизбежно: самый быстрый план должен быть отвергнут, если он может скомпрометировать защиту. Поэтому данный атрибут по умолчанию не устанавливается.</p><p>Планировщик запросов имеет больше свободы, работая с функциями, лишёнными побочных эффектов. Такие функции называются герметичными (<code class="literal">LEAKPROOF</code>) и включают только простые часто используемые операторы, например, операторы равенства. Планировщик запросов может безопасно вычислять такие функции в любой момент выполнения запроса, так как при вызове их для строк, невидимых пользователю, не просочится никакая информация об этих строках. Более того, функции, которые не принимают аргументы или которым не передаются аргументы из представления с барьером безопасности, можно не помечать как <code class="literal">LEAKPROOF</code>, чтобы они вышли наружу, так как они никогда не получат данные из представления. И напротив, функции, которые могут вызвать ошибку в зависимости от значений аргументов (например, в случае переполнения или деления на ноль), герметичными не являются, и могут выдать существенную информацию о невидимых строках, если будут выполнены перед фильтрами строк.</p><p>Важно понимать, что даже представление, созданное с атрибутом <code class="literal">security_barrier</code>, остаётся безопасным только в том смысле, что содержимое невидимых строк не будет передаваться потенциально небезопасным функциям. Но пользователь может собрать некоторые сведения о невидимых данных и другими способами; например, он может проанализировать план запроса, полученный с <code class="command">EXPLAIN</code>, или замерить время выполнения запросов с этим представлением. Злоумышленник может сделать определённые выводы об объёме невидимых данных или даже получить некоторую информацию о распределении данных или наиболее частых значениях (так как всё это отражается в статистике для оптимизатора и, как следствие, влияет на время выполнения плана или даже на выбор плана). Если возможность атаки через скрытые каналы вызывает опасения, вероятно, будет разумным не предоставлять никакой доступ к этим данным.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="rules-update.html" title="41.4. Правила для INSERT, UPDATE и DELETE">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="rules.html" title="Глава 41. Система правил">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="rules-status.html" title="41.6. Правила и статус команд">След.</a></td></tr><tr><td width="40%" align="left" valign="top">41.4. Правила для <code class="command">INSERT</code>, <code class="command">UPDATE</code> и <code class="command">DELETE</code> </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 41.6. Правила и статус команд</td></tr></table></div></body></html>