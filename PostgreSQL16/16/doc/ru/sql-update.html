<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>UPDATE</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sql-unlisten.html" title="UNLISTEN" /><link rel="next" href="sql-vacuum.html" title="VACUUM" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">UPDATE</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-unlisten.html" title="UNLISTEN">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><th width="60%" align="center">Команды SQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-vacuum.html" title="VACUUM">След.</a></td></tr></table><hr /></div><div class="refentry" id="SQL-UPDATE"><div class="titlepage"></div><a id="id-1.9.3.183.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">UPDATE</span></h2><p>UPDATE — изменить строки таблицы</p></div><div class="refsynopsisdiv"><h2>Синтаксис</h2><pre class="synopsis">[ WITH [ RECURSIVE ] <em class="replaceable"><code>запрос_WITH</code></em> [, ...] ]
UPDATE [ ONLY ] <em class="replaceable"><code>имя_таблицы</code></em> [ * ] [ [ AS ] <em class="replaceable"><code>псевдоним</code></em> ]
    SET { <em class="replaceable"><code>имя_столбца</code></em> = { <em class="replaceable"><code>выражение</code></em> | DEFAULT } |
          ( <em class="replaceable"><code>имя_столбца</code></em> [, ...] ) = [ ROW ] ( { <em class="replaceable"><code>выражение</code></em> | DEFAULT } [, ...] ) |
          ( <em class="replaceable"><code>имя_столбца</code></em> [, ...] ) = ( <em class="replaceable"><code>вложенный_SELECT</code></em> )
        } [, ...]
    [ FROM <em class="replaceable"><code>элемент_FROM</code></em> [, ...] ]
    [ WHERE <em class="replaceable"><code>условие</code></em> | WHERE CURRENT OF <em class="replaceable"><code>имя_курсора</code></em> ]
    [ RETURNING * | <em class="replaceable"><code>выражение_результата</code></em> [ [ AS ] <em class="replaceable"><code>имя_результата</code></em> ] [, ...] ]</pre></div><div class="refsect1" id="id-1.9.3.183.5"><h2>Описание</h2><p><code class="command">UPDATE</code> изменяет значения указанных столбцов во всех строках, удовлетворяющих условию. В предложении <code class="literal">SET</code> должны указываться только те столбцы, которые будут изменены; столбцы, не изменяемые явно, сохраняют свои предыдущие значения.</p><p>Изменить строки в таблице, используя информацию из других таблиц в базе данных, можно двумя способами: применяя вложенные запросы или указав дополнительные таблицы в предложении <code class="literal">FROM</code>. Выбор предпочитаемого варианта зависит от конкретных обстоятельств.</p><p>Предложение <code class="literal">RETURNING</code> указывает, что команда <code class="command">UPDATE</code> должна вычислить и возвратить значения для каждой фактически изменённой строки. Вычислить в нём можно любое выражение со столбцами целевой таблицы и/или столбцами других таблиц, упомянутых во <code class="literal">FROM</code>. При этом в выражении будут использоваться новые (изменённые) значения столбцов таблицы. Список <code class="literal">RETURNING</code> имеет тот же синтаксис, что и список результатов <code class="command">SELECT</code>.</p><p>Для выполнения этой команды необходимо иметь право <code class="literal">UPDATE</code> для таблицы, или как минимум для столбцов, перечисленных в списке изменяемых. Также необходимо иметь право <code class="literal">SELECT</code> для всех столбцов, значения которых считываются в <em class="replaceable"><code>выражениях</code></em> или <em class="replaceable"><code>условии</code></em>.</p></div><div class="refsect1" id="id-1.9.3.183.6"><h2>Параметры</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>запрос_WITH</code></em></span></dt><dd><p>Предложение <code class="literal">WITH</code> позволяет задать один или несколько подзапросов, на которые затем можно ссылаться по имени в запросе <code class="command">UPDATE</code>. Подробнее об этом см. <a class="xref" href="queries-with.html" title="7.8. Запросы WITH (Общие табличные выражения)">Раздел 7.8</a> и <a class="xref" href="sql-select.html" title="SELECT"><span class="refentrytitle">SELECT</span></a>.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_таблицы</code></em></span></dt><dd><p>Имя таблицы (возможно, дополненное схемой), строки которой будут изменены. Если перед именем таблицы добавлено <code class="literal">ONLY</code>, соответствующие строки изменяются только в указанной таблице. Без <code class="literal">ONLY</code> строки будут также изменены во всех таблицах, унаследованных от указанной. При желании, после имени таблицы можно указать <code class="literal">*</code>, чтобы явно обозначить, что операция затрагивает все дочерние таблицы.</p></dd><dt><span class="term"><em class="replaceable"><code>псевдоним</code></em></span></dt><dd><p>Альтернативное имя целевой таблицы. Когда указывается это имя, оно полностью скрывает фактическое имя таблицы. Например, в запросе <code class="literal">UPDATE foo AS f</code> дополнительные компоненты оператора <code class="command">UPDATE</code> должны обращаться к целевой таблице по имени <code class="literal">f</code>, а не <code class="literal">foo</code>.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_столбца</code></em></span></dt><dd><p>Имя столбца в таблице <em class="replaceable"><code>имя_таблицы</code></em>. Имя столбца при необходимости может быть дополнено именем вложенного поля или индексом массива. Имя таблицы добавлять к имени целевого столбца не нужно — например, запись <code class="literal">UPDATE table_name SET table_name.col = 1</code> ошибочна.</p></dd><dt><span class="term"><em class="replaceable"><code>выражение</code></em></span></dt><dd><p>Выражение, результат которого присваивается столбцу. В этом выражении можно использовать предыдущие значения этого и других столбцов таблицы.</p></dd><dt><span class="term"><code class="literal">DEFAULT</code></span></dt><dd><p>Присвоить столбцу значение по умолчанию (это может быть NULL, если для столбца не определено некоторое выражение по умолчанию). Столбец идентификации при этом получает значение, выданное соответствующей последовательностью. Для генерируемого столбца это указание допускается, но не меняет обычное поведение, то есть значение столбца вычисляется генерирующим выражением.</p></dd><dt><span class="term"><em class="replaceable"><code>вложенный_SELECT</code></em></span></dt><dd><p>Подзапрос <code class="literal">SELECT</code>, выдающий столько выходных столбцов, сколько перечислено в предшествующем ему списке столбцов в скобках. При выполнении этого подзапроса должна быть получена максимум одна строка. Если он выдаёт одну строку, значения столбцов в нём присваиваются целевым столбцам; если же он не возвращает строку, целевым столбцам присваивается NULL. Этот подзапрос может обращаться к предыдущим значениям текущей изменяемой строки в таблице.</p></dd><dt><span class="term"><em class="replaceable"><code>элемент_FROM</code></em></span></dt><dd><p>Табличное выражение, позволяющее обращаться в условии <code class="literal">WHERE</code> и выражениях новых данных к столбцам других таблиц. В нём используется тот же синтаксис, что и в предложении <a class="link" href="sql-select.html#SQL-FROM" title="Предложение FROM"><code class="literal">FROM</code></a> оператора <code class="command">SELECT</code>; например, вы можете определить псевдоним для таблицы. Имя целевой таблицы повторять в предложении <code class="literal">FROM</code> нужно, только если вы хотите определить замкнутое соединение (в этом случае для данного имени должен определяться псевдоним).</p></dd><dt><span class="term"><em class="replaceable"><code>условие</code></em></span></dt><dd><p>Выражение, возвращающее значение типа <code class="type">boolean</code>. Изменены будут только те стоки, для которых это выражение возвращает <code class="literal">true</code>.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_курсора</code></em></span></dt><dd><p>Имя курсора, который будет использоваться в условии <code class="literal">WHERE CURRENT OF</code>. С таким условием будет изменена строка, выбранная из этого курсора последней. Курсор должен образовываться запросом, не применяющим группировку, к целевой таблице команды <code class="command">UPDATE</code>. Заметьте, что <code class="literal">WHERE CURRENT OF</code> нельзя задать вместе с логическим условием. За дополнительными сведениями об использовании курсоров с <code class="literal">WHERE CURRENT OF</code> обратитесь к <a class="xref" href="sql-declare.html" title="DECLARE"><span class="refentrytitle">DECLARE</span></a>.</p></dd><dt><span class="term"><em class="replaceable"><code>выражение_результата</code></em></span></dt><dd><p>Выражение, которое будет вычисляться и возвращаться командой <code class="command">UPDATE</code> после изменения каждой строки. В этом выражении можно использовать имена любых столбцов таблицы <em class="replaceable"><code>имя_таблицы</code></em> или таблиц, перечисленных в списке <code class="literal">FROM</code>. Чтобы получить все столбцы, достаточно написать <code class="literal">*</code>.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_результата</code></em></span></dt><dd><p>Имя, назначаемое возвращаемому столбцу.</p></dd></dl></div></div><div class="refsect1" id="id-1.9.3.183.7"><h2>Выводимая информация</h2><p>В случае успешного завершения, <code class="command">UPDATE</code> возвращает метку команды в виде </p><pre class="screen">
UPDATE <em class="replaceable"><code>число</code></em>
</pre><p> Здесь <em class="replaceable"><code>число</code></em> обозначает количество изменённых строк, включая те подлежащие изменению строки, значения в которых не были изменены. Заметьте, что это число может быть меньше количества строк, удовлетворяющих <em class="replaceable"><code>условию</code></em>, когда изменения отменяются триггером <code class="literal">BEFORE UPDATE</code>. Если <em class="replaceable"><code>число</code></em> равно 0, данный запрос не изменил ни одной строки (это не считается ошибкой).</p><p>Если команда <code class="command">UPDATE</code> содержит предложение <code class="literal">RETURNING</code>, её результат будет похож на результат оператора <code class="command">SELECT</code> (с теми же столбцами и значениями, что содержатся в списке <code class="literal">RETURNING</code>), полученный для строк, изменённых этой командой.</p></div><div class="refsect1" id="id-1.9.3.183.8"><h2>Замечания</h2><p>Когда присутствует предложение <code class="literal">FROM</code>, целевая таблица по сути соединяется с таблицами, перечисленными в <em class="replaceable"><code>элементе_FROM</code></em>, и каждая выходная строка соединения представляет операцию изменения для целевой таблицы. Применяя предложение <code class="literal">FROM</code>, необходимо обеспечить, чтобы соединение выдавало максимум одну выходную строку для каждой строки, которую нужно изменить. Другими словами, целевая строка не должна соединяться с более чем одной строкой из других таблиц. Если это условие нарушается, только одна из строк соединения будет использоваться для изменения целевой строки, но какая именно, предсказать нельзя.</p><p>Из-за этой неопределённости надёжнее ссылаться на другие таблицы только в подзапросах, хотя такие запросы часто хуже читаются и работают медленнее, чем соединение.</p><p>В секционированной таблице строка при изменении может перестать удовлетворять ограничению содержащей её секции. При этом если есть другая секция в дереве секционирования, ограничению которой эта строка удовлетворяет, то она переносится в данную секцию. Если такой секции нет, происходит ошибка. За кулисами перемещение строки выполняется посредством операций <code class="command">DELETE</code> и <code class="command">INSERT</code>.</p><p>Существует возможность того, что при выполнении другой параллельной операции <code class="command">UPDATE</code> или <code class="command">DELETE</code> с перемещаемой строкой возникнет ошибка сериализации. Например, предположим, что в сеансе 1 выполняется <code class="command">UPDATE</code> для ключа секционирования, а тем временем в параллельном сеансе 2, в котором эта строка видима, выполняется операция <code class="command">UPDATE</code> или <code class="command">DELETE</code> с этой строкой. В этом случае <code class="command">UPDATE</code>/<code class="command">DELETE</code> в сеансе 2 заметит перемещение строки и выдаст ошибку сериализации (которая всегда представляется кодом SQLSTATE '40001'). Получив такую ошибку, приложения могут попытаться повторить транзакцию. В обычном случае, когда таблица не секционирована или строка не перемещается, в сеансе 2 видна изменённая строка, и операция <code class="command">UPDATE</code>/<code class="command">DELETE</code> выполняется с новой версией строки.</p><p>Заметьте, что строки могут перемещаться из локальных секций в секцию в сторонней таблице (если обёртка сторонних данных поддерживает перенаправление кортежей), но не из секции в сторонней таблице в другую секцию.</p><p>Попытка переместить строку из одной секции в другую завершится неудачей, если обнаружится, что внешний ключ напрямую ссылается на предка исходной секции, а в <code class="command">UPDATE</code> фигурирует не этот предок.</p></div><div class="refsect1" id="id-1.9.3.183.9"><h2>Примеры</h2><p>Изменение слова <code class="literal">Drama</code> на <code class="literal">Dramatic</code> в столбце <code class="structfield">kind</code> таблицы <code class="structname">films</code>: </p><pre class="programlisting">UPDATE films SET kind = 'Dramatic' WHERE kind = 'Drama';</pre><p>Изменение значений температуры и сброс уровня осадков к значению по умолчанию в одной строке таблицы <code class="structname">weather</code>: </p><pre class="programlisting">UPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT
  WHERE city = 'San Francisco' AND date = '2003-07-03';</pre><p>Выполнение той же операции с получением изменённых записей: </p><pre class="programlisting">UPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT
  WHERE city = 'San Francisco' AND date = '2003-07-03'
  RETURNING temp_lo, temp_hi, prcp;</pre><p>Такое же изменение с применением альтернативного синтаксиса со списком столбцов: </p><pre class="programlisting">UPDATE weather SET (temp_lo, temp_hi, prcp) = (temp_lo+1, temp_lo+15, DEFAULT)
  WHERE city = 'San Francisco' AND date = '2003-07-03';</pre><p>Увеличение счётчика продаж для менеджера, занимающегося компанией Acme Corporation, с применением предложения <code class="literal">FROM</code>: </p><pre class="programlisting">UPDATE employees SET sales_count = sales_count + 1 FROM accounts
  WHERE accounts.name = 'Acme Corporation'
  AND employees.id = accounts.sales_person;</pre><p>Выполнение той же операции, с вложенным запросом в предложении <code class="literal">WHERE</code>: </p><pre class="programlisting">UPDATE employees SET sales_count = sales_count + 1 WHERE id =
  (SELECT sales_person FROM accounts WHERE name = 'Acme Corporation');</pre><p>Изменение имени контакта в таблице счетов (это должно быть имя назначенного менеджера по продажам): </p><pre class="programlisting">UPDATE accounts SET (contact_first_name, contact_last_name) =
    (SELECT first_name, last_name FROM employees
     WHERE employees.id = accounts.sales_person);</pre><p> Подобный результат можно получить, применив соединение: </p><pre class="programlisting">UPDATE accounts SET contact_first_name = first_name,
                    contact_last_name = last_name
  FROM employees WHERE employees.id = accounts.sales_person;</pre><p> Однако если <code class="structname">employees</code>.<code class="structfield">id</code> — не уникальный ключ, второй запрос может давать непредсказуемые результаты, тогда как первый запрос гарантированно выдаст ошибку, если найдётся несколько записей с одним <code class="structfield">id</code>. Кроме того, если соответствующая запись <code class="structname">accounts</code>.<code class="structfield">sales_person</code> не найдётся, первый запрос запишет в поля имени NULL, а второй вовсе не изменит строку.</p><p>Обновление статистики в сводной таблице в соответствии с текущими данными: </p><pre class="programlisting">UPDATE summary s SET (sum_x, sum_y, avg_x, avg_y) =
    (SELECT sum(x), sum(y), avg(x), avg(y) FROM data d
     WHERE d.group_id = s.group_id);</pre><p>Попытка добавить новый продукт вместе с количеством. Если такая запись уже существует, вместо этого увеличить количество данного продукта в существующей записи. Чтобы реализовать этот подход, не откатывая всю транзакцию, можно использовать точки сохранения: </p><pre class="programlisting">BEGIN;
-- другие операции
SAVEPOINT sp1;
INSERT INTO wines VALUES('Chateau Lafite 2003', '24');
-- Предполагая, что здесь возникает ошибка из-за нарушения уникальности ключа,
-- мы выполняем следующие команды:
ROLLBACK TO sp1;
UPDATE wines SET stock = stock + 24 WHERE winename = 'Chateau Lafite 2003';
-- Продолжение других операций и в завершение...
COMMIT;</pre><p>Изменение столбца <code class="structfield">kind</code> таблицы <code class="structname">films</code> в строке, на которой в данный момент находится курсор <code class="literal">c_films</code>: </p><pre class="programlisting">UPDATE films SET kind = 'Dramatic' WHERE CURRENT OF c_films;</pre></div><div class="refsect1" id="id-1.9.3.183.10"><h2>Совместимость</h2><p>Эта команда соответствует стандарту <acronym class="acronym">SQL</acronym>, за исключением предложений <code class="literal">FROM</code> и <code class="literal">RETURNING</code>, которые являются расширениями <span class="productname">PostgreSQL</span>, как и возможность применять <code class="literal">WITH</code> с <code class="command">UPDATE</code>.</p><p>В некоторых других СУБД также поддерживается дополнительное предложение <code class="literal">FROM</code>, но предполагается, что целевая таблица должна ещё раз упоминаться в этом предложении. <span class="productname">PostgreSQL</span> воспринимает предложение <code class="literal">FROM</code> не так, поэтому будьте внимательны, портируя приложения, которые используют это расширение языка.</p><p>Согласно стандарту, исходным значением для вложенного списка имён столбцов в скобках может быть любое выражение, выдающее строку с нужным количеством столбцов. <span class="productname">PostgreSQL</span> принимает в качестве этого значения только <a class="link" href="sql-expressions.html#SQL-SYNTAX-ROW-CONSTRUCTORS" title="4.2.13. Конструкторы табличных строк">конструктор строки</a> или вложенный <code class="literal">SELECT</code>. Изменяемое значение отдельного столбца можно обозначать словом <code class="literal">DEFAULT</code> в конструкторе строки, но не внутри вложенного <code class="literal">SELECT</code>.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-unlisten.html" title="UNLISTEN">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-vacuum.html" title="VACUUM">След.</a></td></tr><tr><td width="40%" align="left" valign="top">UNLISTEN </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> VACUUM</td></tr></table></div></body></html>