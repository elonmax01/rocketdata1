<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>PREPARE</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sql-notify.html" title="NOTIFY" /><link rel="next" href="sql-prepare-transaction.html" title="PREPARE TRANSACTION" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">PREPARE</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-notify.html" title="NOTIFY">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><th width="60%" align="center">Команды SQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-prepare-transaction.html" title="PREPARE TRANSACTION">След.</a></td></tr></table><hr /></div><div class="refentry" id="SQL-PREPARE"><div class="titlepage"></div><a id="id-1.9.3.159.1" class="indexterm"></a><a id="id-1.9.3.159.2" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">PREPARE</span></h2><p>PREPARE — подготовить оператор к выполнению</p></div><div class="refsynopsisdiv"><h2>Синтаксис</h2><pre class="synopsis">PREPARE <em class="replaceable"><code>имя</code></em> [ ( <em class="replaceable"><code>тип_данных</code></em> [, ...] ) ] AS <em class="replaceable"><code>оператор</code></em></pre></div><div class="refsect1" id="id-1.9.3.159.6"><h2>Описание</h2><p><code class="command">PREPARE</code> создаёт подготовленный оператор. Подготовленный оператор представляет собой объект на стороне сервера, позволяющий оптимизировать производительность приложений. Когда выполняется <code class="command">PREPARE</code>, указанный оператор разбирается, анализируется и переписывается. При последующем выполнении команды <code class="command">EXECUTE</code> подготовленный оператор планируется и исполняется. Такое разделение труда исключает повторный разбор запроса, при этом позволяет выбрать наилучший план выполнения в зависимости от определённых значений параметров.</p><p>Подготовленные операторы могут принимать параметры — значения, которые подставляются в оператор, когда он собственно выполняется. При создании подготовленного оператора к этим параметрам можно обращаться по порядковому номеру, используя запись <code class="literal">$1</code>, <code class="literal">$2</code> и т. д. Дополнительно можно указать список соответствующих типов данных параметров. Если тип данных параметра не указан или объявлен как <code class="literal">unknown</code> (неизвестный), тип выводится из контекста при первом обращении к этому параметру (если это возможно). При выполнении оператора фактические значения параметров передаются команде <code class="command">EXECUTE</code>. За подробностями обратитесь к <a class="xref" href="sql-execute.html" title="EXECUTE"><span class="refentrytitle">EXECUTE</span></a>.</p><p>Подготовленные операторы существуют только в рамках текущего сеанса работы с БД. Когда сеанс завершается, система забывает подготовленный оператор, так что его надо будет создать снова, чтобы использовать дальше. Это также означает, что один подготовленный оператор не может использоваться одновременно несколькими клиентами базы данных; но каждый клиент может создать собственный подготовленный оператор и использовать его. Освободить подготовленный оператор можно вручную, выполнив команду <a class="link" href="sql-deallocate.html" title="DEALLOCATE"><code class="command">DEALLOCATE</code></a>.</p><p>Подготовленные операторы потенциально дают наибольший выигрыш в производительности, когда в одном сеансе выполняется большое число однотипных операторов. Отличие в производительности особенно значительно, если операторы достаточно сложны для планирования или перезаписи, например, когда в запросе объединяется множество таблиц или необходимо применить несколько правил. Если оператор относительно прост в этом плане, но сложен для выполнения, выигрыш от использования подготовленных операторов будет менее заметным.</p></div><div class="refsect1" id="id-1.9.3.159.7"><h2>Параметры</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>имя</code></em></span></dt><dd><p>Произвольное имя, назначаемое данному подготовленному оператору. Оно должно быть уникальным в рамках одного сеанса; это имя затем используется для выполнения или освобождения ранее подготовленного оператора.</p></dd><dt><span class="term"><em class="replaceable"><code>тип_данных</code></em></span></dt><dd><p>Тип данных параметра подготовленного оператора. Если тип данных конкретного параметра не задан или задан как <code class="literal">unknown</code>, он будет выводиться из контекста при первом обращении к этому параметру. Для обращения к параметрам в самом подготовленном операторе используется запись <code class="literal">$1</code>, <code class="literal">$2</code> и т. д.</p></dd><dt><span class="term"><em class="replaceable"><code>оператор</code></em></span></dt><dd><p>Любой оператор <code class="command">SELECT</code>, <code class="command">INSERT</code>, <code class="command">UPDATE</code>, <code class="command">DELETE</code>, <code class="command">MERGE</code> или <code class="command">VALUES</code>.</p></dd></dl></div></div><div class="refsect1" id="SQL-PREPARE-NOTES"><h2>Замечания</h2><p>Подготовленный оператор может выполняться с использованием либо <em class="firstterm">общего плана</em>, либо <em class="firstterm">специализированного</em>. Общий план не меняется при последующих выполнениях, тогда как специализированный план строится для определённого выполнения с учётом значений параметров, переданных при данном вызове. Использование общего плана снижает издержки планирования, но в ряде случаев специализированный план будет выполняться гораздо эффективнее, так как планировщик может подстроиться под значения параметров. (Разумеется, если у подготовленного оператора нет параметров, специализированный план не имеет смысла, поэтому всегда используется общий план.)</p><p>По умолчанию (то есть когда <a class="xref" href="runtime-config-query.html#GUC-PLAN-CACHE-MODE">plan_cache_mode</a> имеет значение <code class="literal">auto</code>), сервер автоматически выбирает, использовать ли для подготовленного оператора с параметрами общий или специализированный план. На данный момент это происходит по следующему принципу — первые пять выполнений производятся со специализированными планами и вычисляется средняя стоимость этих планов. Затем строится общий план и его примерная стоимость сравнивается со средней стоимостью специализированных. При последующих выполнениях общий план будет использоваться, если его стоимость, по сравнению со стоимостью специализированных, не настолько велика, чтобы оправдать повторное планирование.</p><p>Эту логику можно переопределить, чтобы выбирались только общие или только специализированные планы, установив для параметра <code class="varname">plan_cache_mode</code> значение <code class="literal">force_generic_plan</code> или <code class="literal">force_custom_plan</code>, соответственно. Это полезно в первую очередь тогда, когда оценка стоимости общего плана по какой-то причине оказывается заниженной, и он выбирается даже когда фактически его использование обходится гораздо дороже, чем использование специализированных планов.</p><p>Узнать, какой план выполнения выбирает <span class="productname">PostgreSQL</span> для подготовленного оператора, можно, воспользовавшись командой <a class="link" href="sql-explain.html" title="EXPLAIN"><code class="command">EXPLAIN</code></a>. Например: </p><pre class="programlisting">EXPLAIN EXECUTE <em class="replaceable"><code>имя</code></em>(<em class="replaceable"><code>значения_параметров</code></em>);</pre><p> Если применяется общий план, он будет содержать символы параметров <code class="literal">$<em class="replaceable"><code>n</code></em></code>, тогда как в специализированном плане будут подставлены фактические значения параметров.</p><p>Более подробно о планировании запросов и статистике, которую собирает <span class="productname">PostgreSQL</span> для этих целей, можно узнать в документации <a class="xref" href="sql-analyze.html" title="ANALYZE"><span class="refentrytitle">ANALYZE</span></a>.</p><p>Хотя основной смысл подготовленных операторов в том, чтобы избежать многократного разбора и планирования оператора, <span class="productname">PostgreSQL</span> будет принудительно заново анализировать и планировать выполнение оператора всякий раз, когда объекты базы данных, задействованные в операторе, подвергаются изменениям определения (DDL) или в планировщике меняется их статистика со времени предыдущего использования подготовленного оператора. Кроме того, если от одного использования оператора к другому меняется значение <a class="xref" href="runtime-config-client.html#GUC-SEARCH-PATH">search_path</a>, оператор будет так же разобран заново с новым <code class="varname">search_path</code>. (Последнее поведение появилось в <span class="productname">PostgreSQL</span> 9.3.) С этими правилами использование подготовленного оператора по сути почти не отличается от выполнения одного и того же запроса снова и снова, но даёт выигрыш по скорости (если определения объектов не меняются), особенно если оптимальный план от раза к разу не меняется. Однако различия всё же могут проявиться — например, когда оператор обращается к таблице по неполному имени, а затем в схеме, стоящей в пути <code class="varname">search_path</code> раньше, создаётся другая таблица с таким же именем, автоматический пересмотр запроса не происходит, так как никакой объект в определении оператора не изменился. Однако если автоматический пересмотр произойдёт в результате других изменений, при последующем выполнении запроса будет задействована новая таблица.</p><p>Получить список всех доступных в сеансе подготовленных операторов можно, обратившись к системному представлению <a class="link" href="view-pg-prepared-statements.html" title="54.15. pg_prepared_statements"><code class="structname">pg_prepared_statements</code></a>.</p></div><div class="refsect1" id="SQL-PREPARE-EXAMPLES"><h2>Примеры</h2><p>Создание подготовленного оператора для команды <code class="command">INSERT</code>, который затем выполняется: </p><pre class="programlisting">PREPARE fooplan (int, text, bool, numeric) AS
    INSERT INTO foo VALUES($1, $2, $3, $4);
EXECUTE fooplan(1, 'Hunter Valley', 't', 200.00);</pre><p>Создание подготовленного оператора для команды <code class="command">SELECT</code>, который затем выполняется: </p><pre class="programlisting">PREPARE usrrptplan (int) AS
    SELECT * FROM users u, logs l WHERE u.usrid=$1 AND u.usrid=l.usrid
    AND l.date = $2;
EXECUTE usrrptplan(1, current_date);</pre><p> В этом примере тип данных второго параметра не указывается, так что он выводится из контекста, в котором используется <code class="literal">$2</code>.</p></div><div class="refsect1" id="id-1.9.3.159.10"><h2>Совместимость</h2><p>В стандарте SQL есть оператор <code class="command">PREPARE</code>, но он предназначен только для применения во встраиваемом SQL. Эта версия оператора <code class="command">PREPARE</code> имеет также несколько другой синтаксис.</p></div><div class="refsect1" id="id-1.9.3.159.11"><h2>См. также</h2><span class="simplelist"><a class="xref" href="sql-deallocate.html" title="DEALLOCATE"><span class="refentrytitle">DEALLOCATE</span></a>, <a class="xref" href="sql-execute.html" title="EXECUTE"><span class="refentrytitle">EXECUTE</span></a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-notify.html" title="NOTIFY">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-prepare-transaction.html" title="PREPARE TRANSACTION">След.</a></td></tr><tr><td width="40%" align="left" valign="top">NOTIFY </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> PREPARE TRANSACTION</td></tr></table></div></body></html>