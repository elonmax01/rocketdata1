<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>34.9. Асинхронное уведомление</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="libpq-fastpath.html" title="34.8. Интерфейс быстрого пути" /><link rel="next" href="libpq-copy.html" title="34.10. Функции, связанные с командой COPY" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">34.9. Асинхронное уведомление</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="libpq-fastpath.html" title="34.8. Интерфейс быстрого пути">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="libpq.html" title="Глава 34. libpq — библиотека для языка C">Наверх</a></td><th width="60%" align="center">Глава 34. <span class="application">libpq</span> — библиотека для языка C</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="libpq-copy.html" title="34.10. Функции, связанные с командой COPY">След.</a></td></tr></table><hr /></div><div class="sect1" id="LIBPQ-NOTIFY"><div class="titlepage"><div><div><h2 class="title" style="clear: both">34.9. Асинхронное уведомление <a href="#LIBPQ-NOTIFY" class="id_link">#</a></h2></div></div></div><a id="id-1.7.3.16.2" class="indexterm"></a><p><span class="productname">PostgreSQL</span> предлагает асинхронное уведомление посредством команд <code class="command">LISTEN</code> и <code class="command">NOTIFY</code>. Клиентский сеанс работы регистрирует свою заинтересованность в конкретном канале уведомлений с помощью команды <code class="command">LISTEN</code> (и может остановить прослушивание с помощью команды <code class="command">UNLISTEN</code>). Все сеансы, прослушивающие конкретный канал, будут уведомляться в асинхронном режиме, когда в рамках любого сеанса команда <code class="command">NOTIFY</code> выполняется с параметром, указывающим имя этого канала. Для передачи дополнительных данных прослушивающим сеансам может использоваться строка <span class="quote">«<span class="quote">payload</span>»</span>.</p><p>Приложения, использующие <span class="application">libpq</span>, отправляют серверу команды <code class="command">LISTEN</code>, <code class="command">UNLISTEN</code> и <code class="command">NOTIFY</code> как обычные SQL-команды. Поступление сообщений от команды <code class="command">NOTIFY</code> можно впоследствии отследить с помощью функции <code class="function" id="LIBPQ-PQNOTIFIES">PQnotifies</code>.<a id="id-1.7.3.16.4.7" class="indexterm"></a></p><p>Функция <code class="function">PQnotifies</code> возвращает следующее уведомление из списка необработанных уведомительных сообщений, полученных от сервера. Она возвращает нулевой указатель, если нет уведомлений, ожидающих обработки. Как только уведомление возвращено из функции <code class="function">PQnotifies</code>, оно считается обработанным и будет удалено из списка уведомлений. </p><pre class="synopsis">
PGnotify *PQnotifies(PGconn *conn);

typedef struct pgNotify
{
    char *relname;              /* имя канала уведомлений */
    int  be_pid;                /* ID серверного процесса, посылающего уведомление */
    char *extra;                /* строка сообщения в уведомлении */
} PGnotify;
</pre><p> После обработки объекта <code class="structname">PGnotify</code>, возвращённого функцией <code class="function">PQnotifies</code>, обязательно освободите память, занимаемую им, с помощью функции  <a class="xref" href="libpq-misc.html#LIBPQ-PQFREEMEM"><code class="function">PQfreemem</code></a>. Достаточно освободить указатель на <code class="structname">PGnotify</code>; поля <code class="structfield">relname</code> и <code class="structfield">extra</code> не представляют отдельных областей памяти. (Имена этих полей являются таковыми по историческим причинам; в частности, имена каналов не обязаны иметь ничего общего с именами реляционных отношений.)</p><p><a class="xref" href="libpq-example.html#LIBPQ-EXAMPLE-2" title="Пример 34.2. Вторая программа, демонстрирующая использование libpq">Пример 34.2</a> представляет пример программы, иллюстрирующей использование асинхронного уведомления.</p><p>Функция <code class="function">PQnotifies</code> в действительности не читает данные с сервера; она просто возвращает сообщения, предварительно собранные другой функцией библиотеки <span class="application">libpq</span>. В очень старых выпусках <span class="application">libpq</span> обеспечить своевременное получения сообщений от команды <code class="command">NOTIFY</code> можно было только одним способом — постоянно отправлять команды, пусть даже пустые, а затем проверять <code class="function">PQnotifies</code> после каждого вызова <a class="xref" href="libpq-exec.html#LIBPQ-PQEXEC"><code class="function">PQexec</code></a>. Хотя этот метод всё ещё работает, он считается устаревшим ввиду неэффективного использования процессора.</p><p>Более удачным способом проверки наличия сообщений от команды <code class="command">NOTIFY</code>, когда у вас нет полезных команд для выполнения, является вызов функции <a class="xref" href="libpq-async.html#LIBPQ-PQCONSUMEINPUT"><code class="function">PQconsumeInput</code>
     </a> с последующей проверкой <code class="function">PQnotifies</code>. Вы можете использовать <code class="function">select()</code>, чтобы подождать прибытия данных с сервера, не занимая тем самым ресурсы <acronym class="acronym">CPU</acronym> в отсутствие задач для выполнения. (Получить номер дескриптора для использования с <code class="function">select()</code> можно с помощью функции <a class="xref" href="libpq-status.html#LIBPQ-PQSOCKET"><code class="function">PQsocket</code></a>.) Заметьте, что это будет работать независимо от того, отправляете ли вы команды, используя <a class="xref" href="libpq-async.html#LIBPQ-PQSENDQUERY"><code class="function">PQsendQuery</code></a>/<a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a>, или просто вызываете <a class="xref" href="libpq-exec.html#LIBPQ-PQEXEC"><code class="function">PQexec</code></a>. Однако важно не забывать проверять <code class="function">PQnotifies</code> после каждого вызова <a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a> или <a class="xref" href="libpq-exec.html#LIBPQ-PQEXEC"><code class="function">PQexec</code></a>, чтобы увидеть, не поступили ли какие-либо уведомления в процессе обработки команды.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="libpq-fastpath.html" title="34.8. Интерфейс быстрого пути">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="libpq.html" title="Глава 34. libpq — библиотека для языка C">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="libpq-copy.html" title="34.10. Функции, связанные с командой COPY">След.</a></td></tr><tr><td width="40%" align="left" valign="top">34.8. Интерфейс быстрого пути </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 34.10. Функции, связанные с командой <code class="command">COPY</code></td></tr></table></div></body></html>