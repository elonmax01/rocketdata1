<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>64.2. Функции для индексных методов доступа</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="index-api.html" title="64.1. Базовая структура API для индексов" /><link rel="next" href="index-scanning.html" title="64.3. Сканирование индекса" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">64.2. Функции для индексных методов доступа</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="index-api.html" title="64.1. Базовая структура API для индексов">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="indexam.html" title="Глава 64. Определение интерфейса для индексных методов доступа">Наверх</a></td><th width="60%" align="center">Глава 64. Определение интерфейса для индексных методов доступа</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="index-scanning.html" title="64.3. Сканирование индекса">След.</a></td></tr></table><hr /></div><div class="sect1" id="INDEX-FUNCTIONS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">64.2. Функции для индексных методов доступа <a href="#INDEX-FUNCTIONS" class="id_link">#</a></h2></div></div></div><p>Индексный метод доступа должен определить в <code class="structname">IndexAmRoutine</code> следующие функции построения и обслуживания индексов:</p><pre class="programlisting">IndexBuildResult *
ambuild (Relation heapRelation,
         Relation indexRelation,
         IndexInfo *indexInfo);</pre><p> Строит новый индекс. Отношение индекса уже физически создано, но пока пусто. Оно должно быть наполнено фиксированными данными, которые требуются методу доступа, и записями для всех кортежей, уже существующих в таблице. Обычно функция <code class="function">ambuild</code> вызывает <code class="function">table_index_build_scan()</code> для поиска в таблице существующих кортежей и для вычисления ключей, которые должны вставляться в этот индекс. Эта функция должна возвращать структуру, выделенную вызовом palloc и содержащую статистику нового индекса.</p><pre class="programlisting">void
ambuildempty (Relation indexRelation);</pre><p> Создаёт пустой индекс и записывает его в слой инициализации (<code class="symbol">INIT_FORKNUM</code>) данного отношения. Этот метод вызывается только для нежурналируемых индексов; пустой индекс, записанный в слой инициализации, будет копироваться в основной слой отношения при каждом перезапуске сервера.</p><pre class="programlisting">bool
aminsert (Relation indexRelation,
          Datum *values,
          bool *isnull,
          ItemPointer heap_tid,
          Relation heapRelation,
          IndexUniqueCheck checkUnique,
          bool indexUnchanged,
          IndexInfo *indexInfo);</pre><p> Вставляет новый кортеж в существующий индекс. В массивах <code class="literal">values</code> и <code class="literal">isnull</code> передаются значения ключа, которые должны быть проиндексированы, а в <code class="literal">heap_tid</code> — идентификатор индексируемого кортежа (TID). Если метод доступа поддерживает уникальные индексы (флаг <code class="structfield">amcanunique</code> установлен), параметр <code class="literal">checkUnique</code> указывает, какая проверка уникальности должна выполняться. Это зависит от того, является ли ограничение уникальности откладываемым; за подробностями обратитесь к <a class="xref" href="index-unique-checks.html" title="64.5. Проверки уникальности в индексе">Разделу 64.5</a>. Обычно параметр <code class="literal">heapRelation</code> нужен методу доступа только для проверки уникальности (так как он должен обратиться к основным данным, чтобы убедиться в актуальности кортежа).</p><p>Булево значение <code class="literal">indexUnchanged</code> даёт <span class="quote">«<span class="quote">подсказку</span>»</span> о природе индексируемого кортежа. Когда это значение — true, кортеж является дубликатом некоторого существующего кортежа в индексе. Новый кортеж является логически неизменённым, созданным для новой версии MVCC. Такие кортежи появляются, когда выполняется операция <code class="command">UPDATE</code>, которая не меняет никакие столбцы, охватываемые индексом, но тем не менее требует добавления новой версии кортежа в индекс. Опираясь на эту <span class="quote">«<span class="quote">подсказку</span>»</span>, индексный метод может принять решение о выполнении восходящего удаления индексных кортежей в частях индекса, где скапливается много версий одной и той же логической строки. Заметьте, что изменение неключевого столбца не влияет на значение <code class="literal">indexUnchanged</code>. В коде ядра определяется значение <code class="literal">indexUnchanged</code> каждого кортежа при использовании подхода с низкими издержками, который допускает как ложные положительные, так и ложные отрицательные результаты. Индексные МД не должны рассматривать <code class="literal">indexUnchanged</code> как авторитетный источник информации о видимости кортежа или версионировании.</p><p>Возвращаемый функцией булев результат имеет значение, только когда параметр <code class="literal">checkUnique</code> равен <code class="literal">UNIQUE_CHECK_PARTIAL</code>. В этом случае результат true означает, что новая запись признана уникальной, тогда как false означает, что она может быть неуникальной (и требуется назначить отложенную проверку уникальности). В других случаях рекомендуется возвращать постоянный результат false.</p><p>Некоторые индексы могут индексировать не все кортежи. Если кортеж не будет индексирован, <code class="function">aminsert</code> должна просто завершиться, не делая ничего.</p><p>Если индексный МД хочет кешировать данные между операциями добавления в индекс в одном операторе SQL, он может выделить память в <code class="literal">indexInfo-&gt;ii_Context</code> и сохранить указатель на эти данные в поле <code class="literal">indexInfo-&gt;ii_AmCache</code> (которое изначально равно NULL).</p><pre class="programlisting">IndexBulkDeleteResult *
ambulkdelete (IndexVacuumInfo *info,
              IndexBulkDeleteResult *stats,
              IndexBulkDeleteCallback callback,
              void *callback_state);</pre><p> Удаляет кортеж(и) из индекса. Это операция <span class="quote">«<span class="quote">массового удаления</span>»</span>, которая предположительно будет реализована путём сканирования всего индекса и проверки для каждой записи, должна ли она удаляться. Переданная функция <code class="literal">callback</code> должна вызываться в стиле <code class="literal">callback(<em class="replaceable"><code>TID</code></em>, callback_state)</code> с результатом bool, который говорит, должна ли удаляться запись индекса, на которую указывает передаваемый TID. Возвращать эта функция должна NULL или структуру, выделенную вызовом palloc и содержащую статистику результата удаления. NULL можно вернуть, если никакая информация не должна передаваться в <code class="function">amvacuumcleanup</code>.</p><p>Из-за ограничения <code class="varname">maintenance_work_mem</code> процедура <code class="function">ambulkdelete</code> может вызываться несколько раз, когда удалению подлежит большое количество кортежей. В аргументе <code class="literal">stats</code> передаётся результат предыдущего вызова для данного индекса (при первом вызове в ходе операции <code class="command">VACUUM</code> он содержит NULL). Это позволяет методу доступа накапливать статистику в процессе всей операции. Обычно <code class="function">ambulkdelete</code> модифицирует и возвращает одну и ту же структуру, если в <code class="literal">stats</code> передаётся не NULL.</p><pre class="programlisting">IndexBulkDeleteResult *
amvacuumcleanup (IndexVacuumInfo *info,
                 IndexBulkDeleteResult *stats);</pre><p> Провести уборку после операции <code class="command">VACUUM</code> (до этого <code class="function">ambulkdelete</code> могла вызываться несколько или ноль раз). От этой функции не требуется ничего, кроме как выдать статистику по индексу, но она может произвести массовую уборку, например, высвободить пустые страницы индекса. В <code class="literal">stats</code> ей передаётся структура, возвращённая при последнем вызове <code class="function">ambulkdelete</code>, либо NULL, если <code class="function">ambulkdelete</code> не вызывалась, так как никакие кортежи удалять не требовалось. Эта функция должна возвращать NULL или структуру, выделенную вызовом palloc. Содержащаяся в этой структуре статистика будет отражена в записи в <code class="structname">pg_class</code> и попадёт в вывод команды <code class="command">VACUUM</code>, если она выполнялась с указанием <code class="literal">VERBOSE</code>. NULL может возвращаться, если индекс вовсе не изменился в процессе операции <code class="command">VACUUM</code>, но в противном случае должна возвращаться корректная статистика.</p><p><code class="function">amvacuumcleanup</code> также вызывается в конце операции <code class="command">ANALYZE</code>. В этом случае <code class="literal">stats</code> всегда NULL и любое возвращаемое значение игнорируется. Этот вариант вызова можно распознать, проверив поле <code class="literal">info-&gt;analyze_only</code>. При таком вызове методу доступа рекомендуется ничего не делать, кроме как провести уборку после добавления данных, и только в рабочем процессе автоочистки.</p><pre class="programlisting">bool
amcanreturn (Relation indexRelation, int attno);</pre><p> Проверяет, поддерживается ли <a class="link" href="indexes-index-only-scans.html" title="11.9. Сканирование только индекса и покрывающие индексы"><em class="firstterm">сканирование только индекса</em></a> для заданного столбца, когда из индекса можно получить исходное значение столбца. Атрибуты нумеруются с 1, то есть для первого столбца attno равен 1. Возвращает true, если такое сканирование поддерживается, а иначе — false. Эта функция должна всегда возвращать true для неключевых столбцов (если таковые поддерживаются), так как неключевые столбцы, значения которые нельзя извлечь, не имеют смысла. Если индексный метод доступа в принципе не поддерживает сканирование только индекса, в поле <code class="structfield">amcanreturn</code> его структуры <code class="structname">IndexAmRoutine</code> можно записать NULL.</p><pre class="programlisting">void
amcostestimate (PlannerInfo *root,
                IndexPath *path,
                double loop_count,
                Cost *indexStartupCost,
                Cost *indexTotalCost,
                Selectivity *indexSelectivity,
                double *indexCorrelation,
                double *indexPages);</pre><p> Рассчитывает примерную стоимость сканирования индекса. Эта функция полностью описывается ниже в <a class="xref" href="index-cost-estimation.html" title="64.6. Функции оценки стоимости индекса">Разделе 64.6</a>.</p><pre class="programlisting">bytea *
amoptions (ArrayType *reloptions,
           bool validate);</pre><p> Разбирает и проверяет массив параметров для индекса. Эта функция вызывается, только когда для индекса задан отличный от NULL массив reloptions. Массив <em class="parameter"><code>reloptions</code></em> состоит из элементов типа <code class="type">text</code>, содержащих записи вида <em class="replaceable"><code>имя</code></em><code class="literal">=</code><em class="replaceable"><code>значение</code></em>. Данная функция должна получить значение типа <code class="type">bytea</code>, которое будет скопировано в поле <code class="structfield">rd_options</code> записи индекса в relcache. Содержимое этого значения <code class="type">bytea</code> определяется самим методом доступа; большинство стандартных методов доступа помещают в него структуру <code class="structname">StdRdOptions</code>. Когда параметр <em class="parameter"><code>validate</code></em> равен true, эта функция должна выдать подходящее сообщение об ошибке, если какие-либо параметры нераспознаны или имеют недопустимые значения; если же <em class="parameter"><code>validate</code></em> равен false, некорректные записи должны просто игнорироваться. (В <em class="parameter"><code>validate</code></em> передаётся false, когда параметры уже загружены в <code class="structname">pg_catalog</code>; при этом неверная запись может быть обнаружена, только если в методе доступа поменялись правила обработки параметров, и в этом случае стоит просто игнорировать такие записи.) NULL можно вернуть, когда нужно получить поведение по умолчанию.</p><pre class="programlisting">bool
amproperty (Oid index_oid, int attno,
            IndexAMProperty prop, const char *propname,
            bool *res, bool *isnull);</pre><p> Процедура <code class="function">amproperty</code> позволяет индексным методам доступа переопределять стандартное поведение функции <code class="function">pg_index_column_has_property</code> и связанных с ней. Если метод доступа не проявляет никаких особенностей при запросе свойств индексов, поле <code class="structfield">amproperty</code> в структуре <code class="structname">IndexAmRoutine</code> может содержать NULL. В противном случае процедура <code class="function">amproperty</code> будет вызываться с нулевыми параметрами <em class="parameter"><code>index_oid</code></em> и <em class="parameter"><code>attno</code></em> при вызове <code class="function">pg_indexam_has_property</code>, либо с корректным <em class="parameter"><code>index_oid</code></em> и нулевым <em class="parameter"><code>attno</code></em> при вызове <code class="function">pg_index_has_property</code>, либо с корректным <em class="parameter"><code>index_oid</code></em> и положительным <em class="parameter"><code>attno</code></em> при вызове <code class="function">pg_index_column_has_property</code>. В <em class="parameter"><code>prop</code></em> передаётся значение перечисления, указывающее на проверяемое значение, а в <em class="parameter"><code>propname</code></em> — строка с именем свойства. Если код ядра не распознаёт имя свойства, в <em class="parameter"><code>prop</code></em> передаётся <code class="literal">AMPROP_UNKNOWN</code>. Методы доступа могут воспринимать нестандартные имена свойств, проверяя <em class="parameter"><code>propname</code></em> на совпадение (для согласованности с кодом ядра используйте для проверки <code class="function">pg_strcasecmp</code>); для имён, известных коду ядра, лучше проверять <em class="parameter"><code>prop</code></em>. Если процедура <code class="structfield">amproperty</code> возвращает <code class="literal">true</code>, это значит, что она установила результат проверки свойства: она должна задать в <code class="literal">*res</code> возвращаемое логическое значение или установить в <code class="literal">*isnull</code> значение <code class="literal">true</code>, чтобы возвратить NULL. (Перед вызовом обе упомянутые переменные инициализируются значением <code class="literal">false</code>.) Если <code class="structfield">amproperty</code> возвращает <code class="literal">false</code>, код ядра переключается на обычную логику определения результата проверки свойства.</p><p>Методы доступа, поддерживающие операторы упорядочивания, должны реализовывать проверку свойства <code class="literal">AMPROP_DISTANCE_ORDERABLE</code>, так как код ядра не знает, как это сделать и возвращает NULL. Также может быть полезно реализовать проверку <code class="literal">AMPROP_RETURNABLE</code>, если это можно сделать проще, чем обращаясь к индексу и вызывая <code class="function">amcanreturn</code> (что делает код ядра по умолчанию). Для всех остальных стандартных свойств поведение ядра по умолчанию можно считать удовлетворительным.</p><pre class="programlisting">char *
ambuildphasename (int64 phasenum);</pre><p> Возвращает текстовое название переданной фазы построения индекса. Номера фаз передаются в процессе построения индекса функции <code class="function">pgstat_progress_update_param</code>. Названия фаз показываются в представлении <code class="structname">pg_stat_progress_create_index</code>.</p><pre class="programlisting">bool
amvalidate (Oid opclassoid);</pre><p> Проверяет записи в каталоге для заданного класса операторов, насколько это может сделать метод доступа. Например, это может включать проверку, все ли необходимые опорные функции реализованы. Функция <code class="function">amvalidate</code> должна вернуть false, если класс операторов непригоден к использованию. Сообщения о проблеме следует выдать через <code class="function">ereport</code>, как правило, на уровне <code class="literal">INFO</code>.</p><pre class="programlisting">void
amadjustmembers (Oid opfamilyoid,
                 Oid opclassoid,
                 List *operators,
                 List *functions);</pre><p> Проверяет предложенные новые операторы и функции-члены семейства операторов, насколько метод доступа позволяет это сделать, и задаёт виды их зависимостей, если подразумеваемые по умолчанию неудовлетворительны. Эта функция вызывается во время выполнения команд <code class="command">CREATE OPERATOR CLASS</code> и <code class="command">ALTER OPERATOR FAMILY ADD</code>; в последнем случае значение <em class="parameter"><code>opclassoid</code></em> равно <code class="literal">InvalidOid</code>. В аргументах типа <code class="type">List</code> передаются списки элементов структуры <code class="structname">OpFamilyMember</code>, определённой в <code class="filename">amapi.h</code>. Проверки, выполняемые данной функцией, обычно являются подмножеством проверок, выполняемых <code class="function">amvalidate</code>, поскольку предполагается, что <code class="function">amadjustmembers</code> не видит полный набор членов. Например, в этой функции будет разумным проверить сигнатуры опорной функции, но не проверять, предоставляются ли все необходимые опорные функции. О любых проблемах можно сообщить, выдав ошибку. Связанные с зависимостями поля структуры <code class="structname">OpFamilyMember</code> инициализируются кодом ядра — если выполняется <code class="command">CREATE OPERATOR CLASS</code>, создаются жёсткие зависимости от класса операторов, а если выполняется <code class="command">ALTER OPERATOR FAMILY ADD</code> — мягкие зависимости от семейства операторов. Функция <code class="function">amadjustmembers</code> может скорректировать эти поля, если более уместно другое поведение. Например, GIN, GiST и SP-GiST всегда устанавливают для операторов-членов мягкую зависимость от семейства операторов, поскольку в этих типах индексов связь между оператором и классом оператора относительно слаба; поэтому есть смысл разрешить свободное добавление и удаление членов операторов. Для необязательных опорных функций обычно также устанавливаются мягкие зависимости, чтобы при необходимости их можно было удалить.</p><p>Цель индекса, конечно, в том, чтобы поддерживать поиск кортежей, соответствующих индексируемому условию <code class="literal">WHERE</code>, по <em class="firstterm">ограничению</em> или <em class="firstterm">ключу поиска</em>. Сканирование индекса описывается более полно ниже, в <a class="xref" href="index-scanning.html" title="64.3. Сканирование индекса">Разделе 64.3</a>. Индексный метод доступа может поддерживать <span class="quote">«<span class="quote">простое</span>»</span> сканирование, сканирование по <span class="quote">«<span class="quote">битовой карте</span>»</span> или и то, и другое. Метод доступа должен или может реализовывать следующие функции, связанные со сканированием:</p><pre class="programlisting">IndexScanDesc
ambeginscan (Relation indexRelation,
             int nkeys,
             int norderbys);</pre><p> Подготавливает метод к сканированию индекса. В параметрах <code class="literal">nkeys</code> и <code class="literal">norderbys</code> задаётся количество операторов условия и сортировки, которые будут задействованы при сканировании; это может быть полезно для выделения памяти. Заметьте, что фактические значения ключей сканирования в этот момент ещё не предоставляются. В результате функция должна выдать структуру, выделенную средствами palloc. В связи с особенностями реализации, метод доступа <span class="emphasis"><em>должен</em></span> создать эту структуру, вызвав <code class="function">RelationGetIndexScan()</code>. В большинстве случаев все действия <code class="function">ambeginscan</code> сводятся только к выполнению этого вызова и, возможно, получению блокировок; всё самое интересное при запуске сканирования индекса происходит в <code class="function">amrescan</code>.</p><pre class="programlisting">void
amrescan (IndexScanDesc scan,
          ScanKey keys,
          int nkeys,
          ScanKey orderbys,
          int norderbys);</pre><p> Запускает или перезапускает сканирование индекса, возможно, с новыми ключами сканирования. (Для перезапуска сканирования с ранее переданными ключами в <code class="literal">keys</code> и/или <code class="literal">orderbys</code> передаётся NULL.) Заметьте, что количество ключей или операторов сортировки не может превышать значения, поступившие в <code class="function">ambeginscan</code>. На практике возможность перезапуска используется, когда в соединении со вложенным циклом выбирается новый внешний кортеж, так что требуется сравнение с новым ключом, но структура ключей сканирования не меняется.</p><pre class="programlisting">bool
amgettuple (IndexScanDesc scan,
            ScanDirection direction);</pre><p> Выбирает следующий кортеж в ходе данного сканирования, с передвижением по индексу в заданном направлении (вперёд или назад). Возвращает true, если кортеж был получен, или false, если подходящих кортежей не осталось. В случае успеха в структуре <code class="literal">scan</code> сохраняется TID кортежа. Заметьте, что под <span class="quote">«<span class="quote">успехом</span>»</span> здесь подразумевается только, что индекс содержит запись, соответствующую ключам сканирования, а не то, что данный кортеж обязательно существует в данных или оказывается видимым в снимке вызывающего субъекта. При положительном результате <code class="function">amgettuple</code> должна также установить для свойства <code class="literal">scan-&gt;xs_recheck</code> значение true или false. Значение false будет означать, что запись индекса точно соответствует ключам сканирования, а true — что есть сомнение в этом, так что условия, представленные ключами сканирования, необходимо ещё раз перепроверить для фактического кортежа, когда он будет получен. Это свойство введено для поддержки <span class="quote">«<span class="quote">неточных</span>»</span> операторов индексов. Заметьте, что такая перепроверка касается только условий сканирования; предикат частичного индекса (если он имеется) никогда не перепроверяется кодом, вызывающим <code class="function">amgettuple</code>.</p><p>Если индекс поддерживает <a class="link" href="indexes-index-only-scans.html" title="11.9. Сканирование только индекса и покрывающие индексы">сканирование только индекса</a> (то есть <code class="function">amcanreturn</code> выдаёт true для каких-либо его столбцов), то в случае успеха метод доступа должен также проверить флаг <code class="literal">scan-&gt;xs_want_itup</code> и, если он установлен, должен вернуть исходные индексированные данные для этой записи индекса. В столбцах, для которых <code class="function">amcanreturn</code> выдаёт false, можно вернуть null. Данные могут возвращаться посредством указателя на <code class="structname">IndexTuple</code>, сохранённого в <code class="literal">scan-&gt;xs_itup</code>, с дескриптором <code class="literal">scan-&gt;xs_itupdesc</code>; либо посредством указателя на <code class="structname">HeapTuple</code>, сохранённого в <code class="literal">scan-&gt;xs_hitup</code>, с дескриптором кортежа <code class="literal">scan-&gt;xs_hitupdesc</code>. (Второй вариант должен использоваться при восстановлении данных, которые могут не уместиться в <code class="structname">IndexTuple</code>.) В любом случае за управление целевой областью данных, определяемой этим указателем, отвечает метод доступа. Данные должны оставаться актуальными как минимум до следующего вызова <code class="function">amgettuple</code>, <code class="function">amrescan</code> или <code class="function">amendscan</code> в процессе сканирования.</p><p>Функция <code class="function">amgettuple</code> должна быть реализована, только если метод доступа поддерживает <span class="quote">«<span class="quote">простое</span>»</span> сканирование индекса. В противном случае поле <code class="structfield">amgettuple</code> в структуре <code class="structname">IndexAmRoutine</code> должно содержать NULL.</p><pre class="programlisting">int64
amgetbitmap (IndexScanDesc scan,
             TIDBitmap *tbm);</pre><p> Выбирает все кортежи для данного сканирования и добавляет их в передаваемую вызывающим кодом структуру <code class="type">TIDBitmap</code> (то есть, получает логическое объединение множества TID выбранных кортежей с множеством, уже записанным в битовой карте). Возвращает эта функция число полученных кортежей (это может быть только приблизительная оценка; например, некоторые методы доступа не учитывают повторяющиеся значения). Добавляя идентификаторы кортежей в битовую карту, <code class="function">amgetbitmap</code> может обозначить, что для этих кортежей нужно перепроверить условия сканирования. Для этого так же, как и в <code class="function">amgettuple</code>, устанавливается выходной параметр <code class="literal">xs_recheck</code>. Замечание: в текущей реализации эта возможность увязывается с возможностью неточного хранения самих битовых карт, таким образом вызывающий код перепроверяет для отмеченных кортежей и условия сканирования, и предикат частичного индекса (если он имеется). Однако так может быть не всегда. Функции <code class="function">amgetbitmap</code> и <code class="function">amgettuple</code> не могут использоваться в одном сканировании индекса; есть и другие ограничения в применении <code class="function">amgetbitmap</code>, описанные в <a class="xref" href="index-scanning.html" title="64.3. Сканирование индекса">Разделе 64.3</a>.</p><p>Функция <code class="function">amgetbitmap</code> должна быть реализована, только если метод доступа поддерживает сканирование индекса <span class="quote">«<span class="quote">по битовой карте</span>»</span>. В противном случае поле <code class="structfield">amgetbitmap</code> в структуре <code class="structname">IndexAmRoutine</code> должно содержать NULL.</p><pre class="programlisting">void
amendscan (IndexScanDesc scan);</pre><p> Завершает сканирование и освобождает ресурсы. Саму структуру <code class="literal">scan</code> освобождать не следует, но любые блокировки или закрепления объектов, установленные внутри метода доступа, должны быть сняты.</p><pre class="programlisting">void
ammarkpos (IndexScanDesc scan);</pre><p> Помечает текущую позицию сканирования. Метод доступа должен поддерживать сохранение только одной позиции в процессе сканирования.</p><p>Функция <code class="function">ammarkpos</code> должна быть реализована, только если метод доступа поддерживает сканирование по порядку. Если это не так, в поле <code class="structfield">ammarkpos</code> в структуре <code class="structname">IndexAmRoutine</code> можно записать NULL.</p><pre class="programlisting">void
amrestrpos (IndexScanDesc scan);</pre><p> Восстанавливает позицию сканирования, отмеченную последней.</p><p>Функция <code class="function">amrestrpos</code> должна быть реализована, только если метод доступа поддерживает сканирование по порядку. Если это не так, в поле <code class="structfield">amrestrpos</code> в структуре <code class="structname">IndexAmRoutine</code> можно записать NULL.</p><p>Помимо обычного сканирования некоторые типы индексов могут поддерживать <em class="firstterm">параллельное сканирование индекса</em>, что позволяет осуществлять совместное сканирование индекса нескольким обслуживающим процессам. Для этого метод доступа должен организовать работу так, чтобы каждый из взаимодействующих процессов возвращал подмножество кортежей, которое бы возвращалось при обычном, не параллельном сканировании, и таким образом, чтобы объединение этих подмножеств совпадало с множеством кортежей, возвращаемых при обычном сканировании. Более того, чтобы не требовалась глобальная сортировка кортежей, возвращаемых при параллельном сканировании, порядок кортежей в подмножествах, выдаваемых всеми взаимодействующими процессами, должен соответствовать запрошенному. Для поддержки параллельного сканирования по индексу должны быть реализованы следующие функции:</p><pre class="programlisting">Size
amestimateparallelscan (void);</pre><p> Рассчитывает и возвращает объём (в байтах) в динамической разделяемой памяти, который может потребоваться для осуществления параллельного сканирования. (Этот объём дополняет, а не заменяет объём памяти, затребованный для данных, независимо от МД, в <code class="structname">ParallelIndexScanDescData</code>.)</p><p>Эту функцию можно не реализовывать для методов доступа, которые не поддерживают параллельное сканирование, или для которых объём дополнительно требующейся памяти равен нулю.</p><pre class="programlisting">void
aminitparallelscan (void *target);</pre><p> Эта функция будет вызываться для инициализации области динамической разделяемой памяти в начале параллельного сканирования. Параметр <em class="parameter"><code>target</code></em> будет указывать на область объёма, не меньшего, чем возвратила функция <code class="function">amestimateparallelscan</code>, и данная функция может хранить в этой области любые нужные ей данные.</p><p>Эту функцию можно не реализовывать для методов доступа, которые не поддерживают параллельное сканирование, или когда выделенная область в разделяемой памяти не требует инициализации.</p><pre class="programlisting">void
amparallelrescan (IndexScanDesc scan);</pre><p> Эта функция, если её реализовать, будет вызываться перед перезапуском параллельного сканирования индекса. Она должна сбросить всё разделяемое состояние, установленное функцией <code class="function">aminitparallelscan</code>, с тем, чтобы такое сканирование перезапустилось с начала.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="index-api.html" title="64.1. Базовая структура API для индексов">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="indexam.html" title="Глава 64. Определение интерфейса для индексных методов доступа">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="index-scanning.html" title="64.3. Сканирование индекса">След.</a></td></tr><tr><td width="40%" align="left" valign="top">64.1. Базовая структура API для индексов </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 64.3. Сканирование индекса</td></tr></table></div></body></html>