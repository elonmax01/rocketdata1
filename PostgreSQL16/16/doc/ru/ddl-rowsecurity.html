<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>5.8. Политики защиты строк</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="ddl-priv.html" title="5.7. Права" /><link rel="next" href="ddl-schemas.html" title="5.9. Схемы" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">5.8. Политики защиты строк</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="ddl-priv.html" title="5.7. Права">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="ddl.html" title="Глава 5. Определение данных">Наверх</a></td><th width="60%" align="center">Глава 5. Определение данных</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="ddl-schemas.html" title="5.9. Схемы">След.</a></td></tr></table><hr /></div><div class="sect1" id="DDL-ROWSECURITY"><div class="titlepage"><div><div><h2 class="title" style="clear: both">5.8. Политики защиты строк <a href="#DDL-ROWSECURITY" class="id_link">#</a></h2></div></div></div><a id="id-1.5.4.10.2" class="indexterm"></a><a id="id-1.5.4.10.3" class="indexterm"></a><p>В дополнение к стандартной <a class="link" href="ddl-priv.html" title="5.7. Права">системе прав</a> SQL, управляемой командой <a class="xref" href="sql-grant.html" title="GRANT"><span class="refentrytitle">GRANT</span></a>, на уровне таблиц можно определить <em class="firstterm">политики защиты строк</em>, ограничивающие для пользователей наборы строк, которые могут быть возвращены обычными запросами или добавлены, изменены и удалены командами, изменяющими данные. Это называется также <em class="firstterm">защитой на уровне строк</em> (RLS, Row-Level Security). По умолчанию таблицы не имеют политик, так что если система прав SQL разрешает пользователю доступ к таблице, все строки в ней одинаково доступны для чтения или изменения.</p><p>Когда для таблицы включается защита строк (с помощью команды <a class="link" href="sql-altertable.html" title="ALTER TABLE">ALTER TABLE ... ENABLE ROW LEVEL SECURITY</a>), все обычные запросы к таблице на выборку или модификацию строк должны разрешаться политикой защиты строк. (Однако на владельца таблицы такие политики обычно не действуют.) Если политика для таблицы не определена, применяется политика запрета по умолчанию, так что никакие строки в этой таблице нельзя увидеть или модифицировать. На операции с таблицей в целом, такие как <code class="command">TRUNCATE</code> и <code class="literal">REFERENCES</code>, защита строк не распространяется.</p><p>Политики защиты строк могут применяться к определённым командам и/или ролям. Политику можно определить как применяемую к командам <code class="literal">ALL</code> (всем), либо <code class="literal">SELECT</code>, <code class="literal">INSERT</code>, <code class="literal">UPDATE</code> и <code class="literal">DELETE</code>. Кроме того, политику можно связать с несколькими ролями, при этом действуют обычные правила членства и наследования.</p><p>Чтобы определить, какие строки будут видимыми или могут изменяться в таблице, для политики задаётся выражение, возвращающее логический результат. Это выражение будет вычисляться для каждой строки перед другими условиями или функциями, поступающими из запроса пользователя. (Единственным исключением из этого правила являются <code class="literal">герметичные</code> функции, которые гарантированно не допускают утечки информации; оптимизатор может решить выполнить эти функции до проверок защиты строк.) Строки, для которых это выражение возвращает не <code class="literal">true</code>, обрабатываться не будут. Чтобы независимо управлять набором строк, которые можно видеть, и набором строк, которые можно модифицировать, в политике можно задать отдельные выражения. Выражения политик обрабатываются в составе запроса с правами исполняющего его пользователя, но для обращения к данным, недоступным этому пользователю, в этих выражениях могут применяться функции, определяющие контекст безопасности.</p><p>Суперпользователи и роли с атрибутом <code class="literal">BYPASSRLS</code> всегда обращаются к таблице, минуя систему защиты строк. На владельца таблицы защита строк тоже не действует, хотя он может включить её для себя принудительно, выполнив команду <a class="link" href="sql-altertable.html" title="ALTER TABLE">ALTER TABLE ... FORCE ROW LEVEL SECURITY</a>.</p><p>Неотъемлемое право включать или отключать защиту строк, а также определять политики для таблицы, имеет только её владелец.</p><p>Для создания политик предназначена команда <a class="xref" href="sql-createpolicy.html" title="CREATE POLICY"><span class="refentrytitle">CREATE POLICY</span></a>, для изменения — <a class="xref" href="sql-alterpolicy.html" title="ALTER POLICY"><span class="refentrytitle">ALTER POLICY</span></a>, а для удаления — <a class="xref" href="sql-droppolicy.html" title="DROP POLICY"><span class="refentrytitle">DROP POLICY</span></a>. Чтобы включить или отключить защиту строк для определённой таблицы, воспользуйтесь командой <a class="xref" href="sql-altertable.html" title="ALTER TABLE"><span class="refentrytitle">ALTER TABLE</span></a>.</p><p>Каждой политике назначается имя, при этом для одной таблицы можно определить несколько политик. Так как политики привязаны к таблицам, каждая политика для таблицы должна иметь уникальное имя. В разных таблицах политики могут иметь одинаковые имена.</p><p>Когда к определённому запросу применяются несколько политик, они объединяются либо логическим сложением (если политики разрешительные (по умолчанию)), либо умножением (если политики ограничительные). Это подобно тому, как некоторая роль получает права всех ролей, в которые она включена. Разрешительные и ограничительные политики рассматриваются ниже.</p><p>В качестве простого примера, создать политику для отношения <code class="literal">account</code>, позволяющую только членам роли <code class="literal">managers</code> обращаться к строкам отношения и при этом только к своим, можно так:</p><pre class="programlisting">CREATE TABLE accounts (manager text, company text, contact_email text);

ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;

CREATE POLICY account_managers ON accounts TO managers
    USING (manager = current_user);</pre><p>Эта политика неявно подразумевает и предложение <code class="literal">WITH CHECK</code>, идентичное предложению <code class="literal">USING</code>, поэтому указанное ограничение применяется и к строкам, выбираемым командой (так что один менеджер не может выполнить <code class="command">SELECT</code>, <code class="command">UPDATE</code> или <code class="command">DELETE</code> для существующих строк, принадлежащих другому), и к строкам, изменяемым командой (так что командами <code class="command">INSERT</code> и <code class="command">UPDATE</code> нельзя создать строки, принадлежащие другому менеджеру).</p><p>Если роль не задана, либо задано специальное имя пользователя <code class="literal">PUBLIC</code>, политика применяется ко всем пользователям в данной системе. Чтобы все пользователи могли обратиться только к собственной строке в таблице <code class="literal">users</code>, можно применить простую политику:</p><pre class="programlisting">CREATE POLICY user_policy ON users
    USING (user_name = current_user);</pre><p>Это работает подобно предыдущему примеру.</p><p>Чтобы определить для строк, добавляемых в таблицу, отдельную политику, отличную от политики, ограничивающей видимые строки, можно скомбинировать несколько политик. Следующая пара политик позволит всем пользователям видеть все строки в таблице <code class="literal">users</code>, но изменять только свою собственную:</p><pre class="programlisting">CREATE POLICY user_sel_policy ON users
    FOR SELECT
    USING (true);
CREATE POLICY user_mod_policy ON users
    USING (user_name = current_user);</pre><p>Для команды <code class="command">SELECT</code> эти две политики объединяются операцией <code class="literal">OR</code>, так что в итоге это позволяет выбирать все строки. Для команд других типов применяется только вторая политика, и эффект тот же, что и раньше.</p><p>Защиту строк можно отключить так же командой <code class="command">ALTER TABLE</code>. При отключении защиты, политики, определённые для таблицы, не удаляются, а просто игнорируются. В результате в таблице будут видны и могут модифицироваться все строки, с учётом ограничений стандартной системы прав SQL.</p><p>Ниже показан развёрнутый пример того, как этот механизм защиты можно применять в производственной среде. Таблица <code class="literal">passwd</code> имитирует файл паролей в Unix:</p><pre class="programlisting">-- Простой пример на базе файла passwd
CREATE TABLE passwd (
  user_name              text UNIQUE NOT NULL,
  pwhash                text,
  uid                   int  PRIMARY KEY,
  gid                   int  NOT NULL,
  real_name             text NOT NULL,
  home_phone            text,
  extra_info            text,
  home_dir              text NOT NULL,
  shell                 text NOT NULL
);

CREATE ROLE admin;  -- Администратор
CREATE ROLE bob;    -- Обычный пользователь
CREATE ROLE alice;  -- Обычный пользователь

-- Наполнение таблицы
INSERT INTO passwd VALUES
  ('admin','xxx',0,0,'Admin','111-222-3333',null,'/root','/bin/dash');
INSERT INTO passwd VALUES
  ('bob','xxx',1,1,'Bob','123-456-7890',null,'/home/bob','/bin/zsh');
INSERT INTO passwd VALUES
  ('alice','xxx',2,1,'Alice','098-765-4321',null,'/home/alice','/bin/zsh');

-- Необходимо включить для этой таблицы защиту на уровне строк
ALTER TABLE passwd ENABLE ROW LEVEL SECURITY;

-- Создание политик
-- Администратор может видеть и добавлять любые строки
CREATE POLICY admin_all ON passwd TO admin USING (true) WITH CHECK (true);
-- Обычные пользователи могут видеть все строки
CREATE POLICY all_view ON passwd FOR SELECT USING (true);
-- Обычные пользователи могут изменять собственные данные, но
-- не могут задать произвольную оболочку входа
CREATE POLICY user_mod ON passwd FOR UPDATE
  USING (current_user = user_name)
  WITH CHECK (
    current_user = user_name AND
    shell IN ('/bin/bash','/bin/sh','/bin/dash','/bin/zsh','/bin/tcsh')
  );

-- Администраторы получают все обычные права
GRANT SELECT, INSERT, UPDATE, DELETE ON passwd TO admin;
-- Пользователям разрешается чтение только общедоступных столбцов
GRANT SELECT
  (user_name, uid, gid, real_name, home_phone, extra_info, home_dir, shell)
  ON passwd TO public;
-- Пользователям разрешается изменение определённых столбцов
GRANT UPDATE
  (pwhash, real_name, home_phone, extra_info, shell)
  ON passwd TO public;</pre><p>Как и любые средства защиты, важно проверить политики, и убедиться в том, что они работают ожидаемым образом. Применительно к предыдущему примеру, эти команды показывают, что система разрешений работает корректно.</p><pre class="programlisting">-- Администратор может видеть все строки и поля
postgres=&gt; set role admin;
SET
postgres=&gt; table passwd;
 user_name | pwhash | uid | gid | real_name |  home_phone  | extra_info | home_dir    |   shell
-----------+--------+-----+-----+-----------+--------------+------------+-------------+-----------
 admin     | xxx    |   0 |   0 | Admin     | 111-222-3333 |            | /root       | /bin/dash
 bob       | xxx    |   1 |   1 | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh
 alice     | xxx    |   2 |   1 | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh
(3 rows)

-- Проверим, что может делать Алиса
postgres=&gt; set role alice;
SET
postgres=&gt; table passwd;
ERROR:  permission denied for table passwd
postgres=&gt; select user_name,real_name,home_phone,extra_info,home_dir,shell from passwd;
 user_name | real_name |  home_phone  | extra_info | home_dir    |   shell
-----------+-----------+--------------+------------+-------------+-----------
 admin     | Admin     | 111-222-3333 |            | /root       | /bin/dash
 bob       | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh
 alice     | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh
(3 rows)

postgres=&gt; update passwd set user_name = 'joe';
ERROR:  permission denied for table passwd
-- Алиса может изменить своё имя (поле real_name), но не имя кого-либо другого
postgres=&gt; update passwd set real_name = 'Alice Doe';
UPDATE 1
postgres=&gt; update passwd set real_name = 'John Doe' where user_name = 'admin';
UPDATE 0
postgres=&gt; update passwd set shell = '/bin/xx';
ERROR:  new row violates WITH CHECK OPTION for "passwd"
postgres=&gt; delete from passwd;
ERROR:  permission denied for table passwd
postgres=&gt; insert into passwd (user_name) values ('xxx');
ERROR:  permission denied for table passwd
-- Алиса может изменить собственный пароль; попытки поменять другие пароли RLS просто игнорирует
postgres=&gt; update passwd set pwhash = 'abc';
UPDATE 1</pre><p>Все политики, создаваемые до этого, были разрешительными, что значит, что при применении нескольких политик они объединялись логическим оператором <span class="quote">«<span class="quote">ИЛИ</span>»</span>. Хотя можно создать такие разрешительные политики, которые будут только разрешать доступ к строкам при определённых условиях, может быть проще скомбинировать разрешительные политики с ограничительными (которым должны удовлетворять записи и которые объединяются логическим оператором <span class="quote">«<span class="quote">И</span>»</span>). В развитие предыдущего примера мы добавим ограничительную политику, разрешающую администратору, подключённому через локальный сокет Unix, обращаться к записям таблицы <code class="literal">passwd</code>:</p><pre class="programlisting">CREATE POLICY admin_local_only ON passwd AS RESTRICTIVE TO admin
    USING (pg_catalog.inet_client_addr() IS NULL);</pre><p>Затем мы можем убедиться, что администратор, подключённый по сети, не увидит никаких записей, благодаря этой ограничительной политике:</p><pre class="programlisting">=&gt; SELECT current_user;
 current_user
--------------
 admin
(1 row)

=&gt; select inet_client_addr();
 inet_client_addr
------------------
 127.0.0.1
(1 row)

=&gt; TABLE passwd;
 user_name | pwhash | uid | gid | real_name | home_phone | extra_info | home_dir | shell
-----------+--------+-----+-----+-----------+------------+------------+----------+-------
(0 rows)

=&gt; UPDATE passwd set pwhash = NULL;
UPDATE 0</pre><p>На проверки ссылочной целостности, например, на ограничения уникальности и внешние ключи, защита строк никогда не распространяется, чтобы не нарушалась целостность данных. Поэтому организацию и политики защиты на уровне строк необходимо тщательно прорабатывать, чтобы не возникли <span class="quote">«<span class="quote">скрытые каналы</span>»</span> утечки информации через эти проверки.</p><p>В некоторых случаях важно, чтобы защита на уровне строк, наоборот, не действовала. Например, резервное копирование может оказаться провальным, если механизм защиты на уровне строк молча не даст скопировать какие-либо строки. В таком случае вы можете установить для параметра конфигурации <a class="xref" href="runtime-config-client.html#GUC-ROW-SECURITY">row_security</a> значение <code class="literal">off</code>. Это само по себе не отключит защиту строк; при этом просто будет выдана ошибка, если результаты запроса отфильтруются политикой, с тем чтобы можно было изучить причину ошибки и устранить её.</p><p>В приведённых выше примерах выражения политики учитывали только текущие значения в запрашиваемой или изменяемой строке. Это самый простой и наиболее эффективный по скорости вариант; по возможности реализацию защиты строк следует проектировать именно так. Если же для принятия решения о доступе необходимо обращаться к другим строкам или другим таблицам, это можно осуществить, применяя в выражениях политик вложенные <code class="command">SELECT</code> или функции, содержащие <code class="command">SELECT</code>. Однако учтите, что при такой реализации возможны условия гонки, что чревато утечкой информации, если не принять меры предосторожности. Например, рассмотрим следующую конструкцию таблиц:</p><pre class="programlisting">-- определение групп привилегий
CREATE TABLE groups (group_id int PRIMARY KEY,
                     group_name text NOT NULL);

INSERT INTO groups VALUES
  (1, 'low'),
  (2, 'medium'),
  (5, 'high');

GRANT ALL ON groups TO alice;  -- alice является администратором
GRANT SELECT ON groups TO public;

-- определение уровней привилегий для пользователей
CREATE TABLE users (user_name text PRIMARY KEY,
                    group_id int NOT NULL REFERENCES groups);

INSERT INTO users VALUES
  ('alice', 5),
  ('bob', 2),
  ('mallory', 2);

GRANT ALL ON users TO alice;
GRANT SELECT ON users TO public;

-- таблица, содержащая защищаемую информацию
CREATE TABLE information (info text,
                          group_id int NOT NULL REFERENCES groups);

INSERT INTO information VALUES
  ('barely secret', 1),
  ('slightly secret', 2),
  ('very secret', 5);

ALTER TABLE information ENABLE ROW LEVEL SECURITY;

-- строка должна быть доступна для чтения/изменения пользователям с group_id,
-- большим или равным group_id данной строки
CREATE POLICY fp_s ON information FOR SELECT
  USING (group_id &lt;= (SELECT group_id FROM users WHERE user_name = current_user));
CREATE POLICY fp_u ON information FOR UPDATE
  USING (group_id &lt;= (SELECT group_id FROM users WHERE user_name = current_user));

-- мы защищаем таблицу с информацией, полагаясь только на RLS
GRANT ALL ON information TO public;</pre><p>Теперь предположим, что Алиса (роль <code class="literal">alice</code>) желает записать <span class="quote">«<span class="quote">слегка секретную</span>»</span> информацию, но при этом не хочет давать <code class="literal">mallory</code> доступ к ней. Она делает следующее:</p><pre class="programlisting">BEGIN;
UPDATE users SET group_id = 1 WHERE user_name = 'mallory';
UPDATE information SET info = 'secret from mallory' WHERE group_id = 2;
COMMIT;</pre><p>На первый взгляд всё нормально; <code class="literal">mallory</code> ни при каких условиях не должна увидеть строку <span class="quote">«<span class="quote">secret from mallory</span>»</span>. Однако здесь возможно условие гонки. Если Мэллори (роль <code class="literal">mallory</code>) параллельно выполняет, скажем: </p><pre class="programlisting">SELECT * FROM information WHERE group_id = 2 FOR UPDATE;</pre><p> и её транзакция в режиме <code class="literal">READ COMMITTED</code>, она сможет увидеть <span class="quote">«<span class="quote">secret from mallory</span>»</span>. Это произойдёт, если её транзакция дойдёт до строки <code class="structname">information</code> сразу после того, как эту строку изменит Алиса (роль <code class="literal">alice</code>). Она заблокируется, ожидая фиксирования транзакции Алисы, а затем прочитает изменённое содержимое строки благодаря предложению <code class="literal">FOR UPDATE</code>. Однако при этом изменённое содержимое <code class="structname">users</code> <span class="emphasis"><em>не</em></span> будет прочитано неявным запросом <code class="command">SELECT</code>, так как этот вложенный <code class="command">SELECT</code> выполняется без указания <code class="literal">FOR UPDATE</code>; вместо этого строка <code class="structname">users</code> читается из снимка, полученного в начале запроса. Таким образом, выражение политики проверяет старое значение уровня привилегий пользователя <code class="literal">mallory</code> и позволяет ей видеть изменённую строку.</p><p>Обойти эту проблему можно несколькими способами. Первое простое решение заключается в использовании <code class="literal">SELECT ... FOR SHARE</code> во вложенных запросах <code class="command">SELECT</code> в политиках защиты строк. Однако для этого потребуется давать затронутым пользователям право <code class="literal">UPDATE</code> в целевой таблице (здесь <code class="structname">users</code>), что может быть нежелательно. (Хотя можно применить ещё одну политику защиты строк, чтобы они не могли практически воспользоваться этим правилом; либо поместить вложенный <code class="command">SELECT</code> в функцию, определяющую контекст безопасности.) Кроме этого, активное использование блокировок строк в целевой таблице может повлечь проблемы с производительностью, особенно при частых изменениях. Другое решение, практичное, если целевая таблица изменяется нечасто, заключается в блокировке целевой таблицы в режиме <code class="literal">ACCESS EXCLUSIVE</code> при изменении, чтобы никакие параллельные транзакции не видели старые значения строк. Либо можно просто дождаться завершения всех параллельных транзакций после изменения в целевой таблице, прежде чем вносить изменения, рассчитанные на новые условия безопасности.</p><p>За дополнительными подробностями обратитесь к <a class="xref" href="sql-createpolicy.html" title="CREATE POLICY"><span class="refentrytitle">CREATE POLICY</span></a> и <a class="xref" href="sql-altertable.html" title="ALTER TABLE"><span class="refentrytitle">ALTER TABLE</span></a>.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ddl-priv.html" title="5.7. Права">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="ddl.html" title="Глава 5. Определение данных">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="ddl-schemas.html" title="5.9. Схемы">След.</a></td></tr><tr><td width="40%" align="left" valign="top">5.7. Права </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 5.9. Схемы</td></tr></table></div></body></html>