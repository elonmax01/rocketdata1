<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>COPY</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sql-commit-prepared.html" title="COMMIT PREPARED" /><link rel="next" href="sql-create-access-method.html" title="CREATE ACCESS METHOD" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">COPY</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-commit-prepared.html" title="COMMIT PREPARED">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><th width="60%" align="center">Команды SQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-create-access-method.html" title="CREATE ACCESS METHOD">След.</a></td></tr></table><hr /></div><div class="refentry" id="SQL-COPY"><div class="titlepage"></div><a id="id-1.9.3.55.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">COPY</span></h2><p>COPY — копировать данные между файлом и таблицей</p></div><div class="refsynopsisdiv"><h2>Синтаксис</h2><pre class="synopsis">COPY <em class="replaceable"><code>имя_таблицы</code></em> [ ( <em class="replaceable"><code>имя_столбца</code></em> [, ...] ) ]
    FROM { '<em class="replaceable"><code>имя_файла</code></em>' | PROGRAM '<em class="replaceable"><code>команда</code></em>' | STDIN }
    [ [ WITH ] ( <em class="replaceable"><code>параметр</code></em> [, ...] ) ]
    [ WHERE <em class="replaceable"><code>условие</code></em> ]

COPY { <em class="replaceable"><code>имя_таблицы</code></em> [ ( <em class="replaceable"><code>имя_столбца</code></em> [, ...] ) ] | ( <em class="replaceable"><code>запрос</code></em> ) }
    TO { '<em class="replaceable"><code>имя_файла</code></em>' | PROGRAM '<em class="replaceable"><code>команда</code></em>' | STDOUT }
    [ [ WITH ] ( <em class="replaceable"><code>параметр</code></em> [, ...] ) ]

<span class="phrase">Здесь допускается <em class="replaceable"><code>параметр</code></em>:</span>

    FORMAT <em class="replaceable"><code>имя_формата</code></em>
    FREEZE [ <em class="replaceable"><code>boolean</code></em> ]
    DELIMITER '<em class="replaceable"><code>символ_разделитель</code></em>'
    NULL '<em class="replaceable"><code>маркер_NULL</code></em>'
    DEFAULT '<em class="replaceable"><code>строка_по_умолчанию</code></em>'
    HEADER [ <em class="replaceable"><code>boolean</code></em> | MATCH ]
    QUOTE '<em class="replaceable"><code>символ_кавычек</code></em>'
    ESCAPE '<em class="replaceable"><code>символ_экранирования</code></em>'
    FORCE_QUOTE { ( <em class="replaceable"><code>имя_столбца</code></em> [, ...] ) | * }
    FORCE_NOT_NULL ( <em class="replaceable"><code>имя_столбца</code></em> [, ...] )
    FORCE_NULL ( <em class="replaceable"><code>имя_столбца</code></em> [, ...] )
    ENCODING '<em class="replaceable"><code>имя_кодировки</code></em>'</pre></div><div class="refsect1" id="id-1.9.3.55.5"><h2>Описание</h2><p><code class="command">COPY</code> перемещает данные между таблицами <span class="productname">PostgreSQL</span> и обычными файлами в файловой системе. <code class="command">COPY TO</code> копирует содержимое таблицы <span class="emphasis"><em>в</em></span> файл, а <code class="command">COPY FROM</code> — <span class="emphasis"><em>из</em></span> файла в таблицу (добавляет данные к тем, что уже содержались в таблице). <code class="command">COPY TO</code> может также скопировать результаты запроса <code class="command">SELECT</code>.</p><p>Если указывается список столбцов, <code class="command">COPY TO</code> копирует в файл только данные указанных столбцов, а <code class="command">COPY FROM</code> вставляет каждое поле из файла в соответствующий ему по порядку столбец из указанного списка. В случае отсутствия в этом списке каких-либо столбцов таблицы при <code class="command">COPY FROM</code> они получают значения по умолчанию.</p><p><code class="command">COPY</code> с именем файла указывает серверу <span class="productname">PostgreSQL</span> читать или записывать непосредственно этот файл. Заданный файл должен быть доступен пользователю <span class="productname">PostgreSQL</span> (тому пользователю, от имени которого работает сервер), и путь к файлу должен задаваться с точки зрения сервера. Когда указывается параметр <code class="literal">PROGRAM</code>, сервер выполняет заданную команду и читает данные из стандартного вывода программы, либо записывает их в стандартный ввод. Команда должна определяться с точки зрения сервера и быть доступной для исполнения пользователю <span class="productname">PostgreSQL</span>. Когда указывается <code class="literal">STDIN</code> или <code class="literal">STDOUT</code>, данные передаются через соединение клиента с сервером.</p><p>Каждый процесс, выполняющий операцию <code class="command">COPY</code>, будет выдавать информацию о ходе её выполнения, отображаемую в представлении <code class="structname">pg_stat_progress_copy</code>. За подробностями обратитесь к <a class="xref" href="progress-reporting.html#COPY-PROGRESS-REPORTING" title="28.4.3. Отслеживание выполнения COPY">Подразделу 28.4.3</a>.</p></div><div class="refsect1" id="id-1.9.3.55.6"><h2>Параметры</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>имя_таблицы</code></em></span></dt><dd><p>Имя существующей таблицы (возможно, дополненное схемой).</p></dd><dt><span class="term"><em class="replaceable"><code>имя_столбца</code></em></span></dt><dd><p>Необязательный список столбцов, данные которых будут копироваться. Если этот список отсутствует, копируются все столбцы таблицы, за исключением генерируемых.</p></dd><dt><span class="term"><em class="replaceable"><code>запрос</code></em></span></dt><dd><p>Команда <a class="link" href="sql-select.html" title="SELECT"><code class="command">SELECT</code></a>, <a class="link" href="sql-values.html" title="VALUES"><code class="command">VALUES</code></a>, <a class="link" href="sql-insert.html" title="INSERT"><code class="command">INSERT</code></a>, <a class="link" href="sql-update.html" title="UPDATE"><code class="command">UPDATE</code></a> или <a class="link" href="sql-delete.html" title="DELETE"><code class="command">DELETE</code></a>, результаты которой будут скопированы. Заметьте, что запрос должен заключаться в скобки.</p><p>Для запросов <code class="command">INSERT</code>, <code class="command">UPDATE</code> и <code class="command">DELETE</code> должно задаваться предложение <code class="literal">RETURNING</code> и в целевом отношении не должно быть условного правила, правила <code class="literal">ALSO</code> или правила <code class="literal">INSTEAD</code>, разворачивающегося в несколько операторов.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_файла</code></em></span></dt><dd><p>Путь входного или выходного файла. Путь входного файла может быть абсолютным или относительным, но путь выходного должен быть только абсолютным. Пользователям Windows следует использовать формат <code class="literal">E''</code> и продублировать каждую обратную черту в пути файла.</p></dd><dt><span class="term"><code class="literal">PROGRAM</code></span></dt><dd><p>Выполняемая команда. <code class="command">COPY FROM</code> читает стандартный вывод команды, а <code class="command">COPY TO</code> записывает в её стандартный ввод.</p><p>Заметьте, что команда запускается через командную оболочку, так что если требуется передать какие-либо аргументы, поступающие из недоверенного источника, необходимо аккуратно избавиться от всех спецсимволов, имеющих особое значение в оболочке, либо экранировать их. По соображениям безопасности лучше ограничиться фиксированной строкой команды или как минимум не позволять пользователям вводить в неё произвольное содержимое.</p></dd><dt><span class="term"><code class="literal">STDIN</code></span></dt><dd><p>Указывает, что данные будут поступать из клиентского приложения.</p></dd><dt><span class="term"><code class="literal">STDOUT</code></span></dt><dd><p>Указывает, что данные будут выдаваться клиентскому приложению.</p></dd><dt><span class="term"><em class="replaceable"><code>boolean</code></em></span></dt><dd><p>Включает или отключает заданный параметр. Для включения параметра можно написать <code class="literal">TRUE</code>, <code class="literal">ON</code> или <code class="literal">1</code>, а для отключения — <code class="literal">FALSE</code>, <code class="literal">OFF</code> или <code class="literal">0</code>. Значение <em class="replaceable"><code>boolean</code></em> можно опустить, в этом случае подразумевается <code class="literal">TRUE</code>.</p></dd><dt><span class="term"><code class="literal">FORMAT</code></span></dt><dd><p>Выбирает формат чтения или записи данных: <code class="literal">text</code> (текстовый), <code class="literal">csv</code> (значения, разделённые запятыми, Comma Separated Values) или <code class="literal">binary</code> (двоичный). По умолчанию выбирается формат <code class="literal">text</code>.</p></dd><dt><span class="term"><code class="literal">FREEZE</code></span></dt><dd><p>Запросы копируют данные с уже замороженными строками, как после выполнения команды <code class="command">VACUUM FREEZE</code>. Это позволяет увеличить производительность при начальном добавлении данных. Строки будут замораживаться, только если загружаемая таблица была создана или опустошена в текущей подтранзакции, с ней не связаны открытые курсоры и в данной транзакции нет других снимков. Выполнять <code class="command">COPY FREEZE</code> с секционированной таблицей в настоящее время нельзя.</p><p>Заметьте, что все другие сеансы будут немедленно видеть данные, как только они будут успешно загружены. Это нарушает принятые правила видимости MVCC, так что пользователи должны понимать, какие проблемы это может вызвать.</p></dd><dt><span class="term"><code class="literal">DELIMITER</code></span></dt><dd><p>Задаёт символ, разделяющий столбцы в строках файла. По умолчанию это символ табуляции в текстовом формате и запятая в формате <code class="literal">CSV</code>. Задаваемый символ должен быть однобайтовым. Для формата <code class="literal">binary</code> этот параметр не допускается.</p></dd><dt><span class="term"><code class="literal">NULL</code></span></dt><dd><p>Определяет строку, задающую значение NULL. По умолчанию в текстовом формате это <code class="literal">\N</code> (обратная косая черта и N), а в формате <code class="literal">CSV</code> — пустая строка без кавычек. Пустую строку можно использовать и в текстовом формате, если не требуется различать пустые строки и NULL. Для формата <code class="literal">binary</code> этот параметр не допускается.</p><div class="note"><h3 class="title">Примечание</h3><p>При выполнении <code class="command">COPY FROM</code> любые значения, совпадающие с этой строкой, сохраняются как значение NULL, так что при переносе данных важно убедиться в том, что это та же строка, что применялась в <code class="command">COPY TO</code>.</p></div></dd><dt><span class="term"><code class="literal">DEFAULT</code></span></dt><dd><p>Задаёт строку, представляющую значение по умолчанию. Каждый раз, когда указанная строка встречается во входном файле, вычисляется значение по умолчанию для соответствующего столбца. Этот параметр допускается только в команде <code class="command">COPY FROM</code> и только не для формата <code class="literal">binary</code>.</p></dd><dt><span class="term"><code class="literal">HEADER</code></span></dt><dd><p>Указывает, что файл содержит строку заголовка с именами каждого столбца в файле. При выводе первая строка будет содержать имена столбцов из таблицы. При вводе первая строка отбрасывается, если для этого параметра установлено значение <code class="literal">true</code> (или равнозначное логическое значение). Если для этого параметра установлено значение <code class="literal">MATCH</code>, имена столбцов (и их количество) в строке заголовка должны совпадать с фактическими именами столбцов таблицы по порядку, иначе возникнет ошибка. Этот параметр не допускается при использовании формата <code class="literal">binary</code>. Параметр <code class="literal">MATCH</code> действителен только для команд <code class="command">COPY FROM</code>.</p></dd><dt><span class="term"><code class="literal">QUOTE</code></span></dt><dd><p>Указывает символ кавычек, используемый для заключения данных в кавычки. По умолчанию это символ двойных кавычек. Задаваемый символ должен быть однобайтовым. Этот параметр поддерживается только для формата <code class="literal">CSV</code>.</p></dd><dt><span class="term"><code class="literal">ESCAPE</code></span></dt><dd><p>Задаёт символ, который будет выводиться перед символом данных, совпавшим со значением <code class="literal">QUOTE</code>. По умолчанию это тот же символ, что и <code class="literal">QUOTE</code> (то есть, при появлении в данных кавычек, они дублируются). Задаваемый символ должен быть однобайтовым. Этот параметр допускается только для режима <code class="literal">CSV</code>.</p></dd><dt><span class="term"><code class="literal">FORCE_QUOTE</code></span></dt><dd><p>Принудительно заключает в кавычки все значения не <code class="literal">NULL</code> в указанных столбцах. Выводимое значение <code class="literal">NULL</code> никогда не заключается в кавычки. Если указано <code class="literal">*</code>, в кавычки будут заключаться значения не <code class="literal">NULL</code> во всех столбцах. Этот параметр принимает только команда <code class="command">COPY TO</code> и только для формата <code class="literal">CSV</code>.</p></dd><dt><span class="term"><code class="literal">FORCE_NOT_NULL</code></span></dt><dd><p>Не сопоставлять значения в указанных столбцах с маркером NULL. По умолчанию, когда маркер пуст, это означает, что пустые значения будут считаны как строки нулевой длины, а не NULL, даже когда они не заключены в кавычки. Этот параметр допускается только в команде <code class="command">COPY FROM</code> и только для формата <code class="literal">CSV</code>.</p></dd><dt><span class="term"><code class="literal">FORCE_NULL</code></span></dt><dd><p>Сопоставлять значения в указанных столбцах с маркером NULL, даже если они заключены в кавычки, и в случае совпадения устанавливать значение <code class="literal">NULL</code>. По умолчанию, когда этот маркер пуст, пустая строка в кавычках будет преобразовываться в NULL. Этот параметр допускается только в команде <code class="command">COPY FROM</code> и только для формата <code class="literal">CSV</code>.</p></dd><dt><span class="term"><code class="literal">ENCODING</code></span></dt><dd><p>Указывает, что файл имеет кодировку <em class="replaceable"><code>имя_кодировки</code></em>. Если этот параметр опущен, выбирается текущая кодировка клиента. Подробнее об этом говорится ниже, в примечаниях.</p></dd><dt><span class="term"><code class="literal">WHERE</code></span></dt><dd><p>Необязательное предложение <code class="literal">WHERE</code> имеет общую форму </p><pre class="synopsis">
WHERE <em class="replaceable"><code>условие</code></em>
</pre><p>, где <em class="replaceable"><code>условие</code></em> — любое выражение, выдающее результат типа <code class="type">boolean</code>. Строки, не удовлетворяющие этому условию, добавляться в таблицу не будут. Строка удовлетворяет условию, если оно возвращает true при подстановке вместо ссылок на переменные фактических значений из этой строки.</p><p>В настоящее время выражения <code class="literal">WHERE</code> не могут включать подзапросы, а при вычислении выражений не видны изменения, которые вносит сама команда <code class="command">COPY</code> (это играет роль, когда в них вызываются функции с характеристикой <code class="literal">VOLATILE</code>).</p></dd></dl></div></div><div class="refsect1" id="id-1.9.3.55.7"><h2>Выводимая информация</h2><p>В случае успешного завершения, <code class="command">COPY</code> возвращает метку команды в виде </p><pre class="screen">
COPY <em class="replaceable"><code>число</code></em>
</pre><p> Здесь <em class="replaceable"><code>число</code></em> — количество скопированных записей.</p><div class="note"><h3 class="title">Примечание</h3><p><span class="application">psql</span> выводит эту метку, только если выполнялась не команда <code class="literal">COPY ... TO STDOUT</code> или её аналог в <span class="application">psql</span>, метакоманда <code class="literal">\copy ... to stdout</code>. Это сделано для того, чтобы метка команды не смешалась с данными, выведенными перед ней.</p></div></div><div class="refsect1" id="id-1.9.3.55.8"><h2>Замечания</h2><p>Команду <code class="command">COPY TO</code> можно использовать только с простыми таблицами, не представлениями, и при этом она не копирует строки из дочерних таблиц или секций. То есть, <code class="literal">COPY <em class="replaceable"><code>таблица</code></em> TO</code> копирует те же строки, что выдаёт запрос <code class="literal">SELECT * FROM ONLY <em class="replaceable"><code>таблица</code></em></code>. Для выгрузки всех строк представления или таблицы с учётом иерархии наследования или секционирования можно применить <code class="literal">COPY (SELECT * FROM <em class="replaceable"><code>таблица</code></em>) TO ...</code>.</p><p><code class="command">COPY FROM</code> можно применять с обычными, сторонними и секционированными таблицами или представлениями, в которых установлены триггеры <code class="literal">INSTEAD OF INSERT</code>.</p><p>В таблице, данные которой читает команда <code class="command">COPY TO</code>, требуется иметь право на выборку данных, а в таблице, куда вставляет значения <code class="command">COPY FROM</code>, требуется право на добавление. При этом, если в команде перечисляются избранные столбцы, достаточно иметь права только для них.</p><p>Если для таблицы включена защита на уровне строк, соответствующие политики <code class="command">SELECT</code> будут применяться и к операторам <code class="literal">COPY <em class="replaceable"><code>таблица</code></em> TO</code>. Операторы <code class="command">COPY FROM</code> для таблиц с защитой строк в настоящее время не поддерживаются. Вместо них следует использовать равнозначные операторы <code class="command">INSERT</code>.</p><p>Файлы, указанные в команде <code class="command">COPY</code>, читаются или записываются непосредственно сервером, не клиентским приложением. Поэтому они должны располагаться на сервере или быть доступными серверу, а не клиенту. Они должны быть доступны на чтение или запись пользователю <span class="productname">PostgreSQL</span> (пользователю, от имени которого работает сервер), не клиенту. Аналогично, команда, указанная параметром <code class="literal">PROGRAM</code>, выполняется непосредственно сервером, а не клиентским приложением, и должна быть доступна на выполнение пользователю <span class="productname">PostgreSQL</span>. Выполнять <code class="command">COPY</code> с указанием файла или внешней команды разрешено только суперпользователям базы данных или членам ролей <code class="literal">pg_read_server_files</code>, <code class="literal">pg_write_server_files</code> или <code class="literal">pg_execute_server_program</code>, так как это позволяет читать/записывать любые файлы и запускать любые программы, к которым имеет доступ сервер.</p><p>Не путайте команду <code class="command">COPY</code> с реализованной в <span class="application">psql</span> метакомандой <code class="command"><a class="link" href="app-psql.html#APP-PSQL-META-COMMANDS-COPY">\copy</a></code>. Метакоманда <code class="command">\copy</code> вызывает <code class="command">COPY FROM STDIN</code> или <code class="command">COPY TO STDOUT</code>, а затем работает с данными в файле, доступном клиенту <span class="application">psql</span>. Таким образом, когда применяется команда <code class="command">\copy</code>, доступность файла и права доступа зависят от клиента, а не от сервера.</p><p>Путь файла, указываемый в <code class="command">COPY</code>, рекомендуется всегда задавать как абсолютный, а не относительный. Это обязательное условие для команды <code class="command">COPY TO</code>, но <code class="command">COPY FROM</code> позволяет прочитать файл, заданный и относительным путём. Такой путь будет интерпретироваться относительно рабочего каталога серверного процесса (обычно это каталог данных кластера), а не рабочего каталога клиента.</p><p>Выполнение команды в <code class="literal">PROGRAM</code> может быть ограничено и другими работающими в ОС механизмами контроля доступа, например SELinux.</p><p><code class="command">COPY FROM</code> вызывает все триггеры и обрабатывает все ограничения-проверки в целевой таблице. Однако правила при загрузке данных не вызываются.</p><p>Для столбцов идентификации команда <code class="command">COPY FROM</code> всегда переносит значения, содержащиеся во входных данных, как команда <code class="command">INSERT</code> с указанием <code class="literal">OVERRIDING SYSTEM VALUE</code>.</p><p>При вводе и выводе данных <code class="command">COPY</code> учитывается <code class="varname">DateStyle</code>. Для обеспечения переносимости на другие инсталляции <span class="productname">PostgreSQL</span>, в которых могут использоваться нестандартные значения <code class="varname">DateStyle</code>, значение <code class="varname">DateStyle</code> следует установить равным <code class="literal">ISO</code> до вызова <code class="command">COPY TO</code>. Также рекомендуется не выгружать данные с <code class="varname">IntervalStyle</code> равным <code class="literal">sql_standard</code>, так как сервер с другим значением <code class="varname">IntervalStyle</code> может неправильно воспринимать отрицательные интервалы в таких данных.</p><p>Входные данные интерпретируются согласно кодировке, заданной параметром <code class="literal">ENCODING</code>, или текущей кодировке клиента, а выходные кодируются в кодировке <code class="literal">ENCODING</code> или текущей кодировке клиента, даже если данные не проходят через клиента, а считываются или записываются в файл непосредственно сервером.</p><p><code class="command">COPY</code> прекращает операцию при первой ошибке. Это не должно приводить к проблемам в случае с <code class="command">COPY TO</code>, но после <code class="command">COPY FROM</code> в целевой таблице остаются ранее полученные строки. Эти строки не будут видимыми и доступными, но будут занимать место на диске. Если сбой происходит при копировании большого объёма данных, это может приводить к значительным потерям дискового пространства. При желании вернуть потерянный объём, это можно сделать с помощью команды <code class="command">VACUUM</code>.</p><p><code class="literal">FORCE_NULL</code> и <code class="literal">FORCE_NOT_NULL</code> можно применить одновременно к одному столбцу. В результате NULL-значения в кавычках будут преобразованы в NULL, а NULL-значения без кавычек — в пустые строки.</p></div><div class="refsect1" id="id-1.9.3.55.9"><h2>Форматы файлов</h2><div class="refsect2" id="id-1.9.3.55.9.2"><h3>Текстовый формат</h3><p>Когда применяется формат text, читаемые или записываемые данные представляют собой текстовый файл, строка в котором соответствует строке таблицы. Столбцы в строке разделяются символом-разделителем. Значения самих столбцов — текстовые строки, выдаваемые функцией вывода, либо воспринимаемые функцией ввода, соответствующей типу данных столбца. Заданный маркер NULL выводится и считывается вместо столбцов со значением NULL. <code class="command">COPY FROM</code> выдаёт ошибку, если в любой из строк во входном файле оказывается больше или меньше столбцов, чем ожидается.</p><p>Конец данных может обозначаться одной строкой, содержащей только обратную косую и точку (<code class="literal">\.</code>). Маркер конца данных не требуется при чтении из файла, так как его роль вполне выполняет конец файла; он необходим только при передаче данных в/из клиентского приложения по протоколу обмена до версии 3.0.</p><p>Символы обратной косой черты (<code class="literal">\</code>) в данных <code class="command">COPY</code> позволяют экранировать символы данных, которые без них считались бы разделителями строк или столбцов. В частности, предваряться обратной косой <span class="emphasis"><em>должны</em></span> следующие символы, когда они оказываются в значении столбца: сама обратная косая черта, перевод строки, возврат каретки и текущий разделитель.</p><p>Маркер NULL передаётся команде <code class="command">COPY TO</code> как есть, без добавления обратной косой; <code class="command">COPY FROM</code>, со своей стороны, ищет во вводимых данных маркеры NULL до удаления обратных косых. Таким образом, маркер NULL, например такой как <code class="literal">\N</code>, отличается от значения <code class="literal">\N</code> в данных (оно должно представляться в виде <code class="literal">\\N</code>).</p><p>Команда <code class="command">COPY FROM</code> распознаёт следующие спецпоследовательности: </p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Последовательность</th><th>Представляет</th></tr></thead><tbody><tr><td><code class="literal">\b</code></td><td>Забой (ASCII 8)</td></tr><tr><td><code class="literal">\f</code></td><td>Подача формы (ASCII 12)</td></tr><tr><td><code class="literal">\n</code></td><td>Новая строка (ASCII 10)</td></tr><tr><td><code class="literal">\r</code></td><td>Возврат каретки (ASCII 13)</td></tr><tr><td><code class="literal">\t</code></td><td>Табуляция (ASCII 9)</td></tr><tr><td><code class="literal">\v</code></td><td>Вертикальная табуляция (ASCII 11)</td></tr><tr><td><code class="literal">\</code><em class="replaceable"><code>цифры</code></em></td><td>Обратная косая с последующими 1–3 восьмеричными цифрами представляет байт с заданным числовым кодом</td></tr><tr><td><code class="literal">\x</code><em class="replaceable"><code>цифры</code></em></td><td>Обратная косая с последующим <code class="literal">x</code> и 1-2 шестнадцатеричными цифрами представляет байт с заданным числовым кодом</td></tr></tbody></table></div><p> В настоящее время <code class="command">COPY TO</code> никогда не выводит спецпоследовательности с восьмеричными или шестнадцатеричными кодами, однако выводит другие вышеперечисленные спецпоследовательности вместо управляющих символов.</p><p>Любой другой символ после обратной косой, отсутствующий в приведённой выше таблице, будет представлять себя. Однако опасайтесь излишнего добавления обратных косых, так как это может привести к случайному образованию строки, обозначающей маркер конца данных (<code class="literal">\.</code>) или маркер NULL (<code class="literal">\N</code> по умолчанию). Эти строки будут восприняты прежде, чем обработаются спецпоследовательности с обратной косой.</p><p>В приложениях, генерирующих данные для <code class="command">COPY</code>, настоятельно рекомендуется преобразовать символы новой строки и возврата каретки в последовательности <code class="literal">\n</code> и <code class="literal">\r</code>, соответственно. В настоящее время можно представить возврат каретки в данных как обратная косая и возврат каретки, а перевод строки как обратная косая и перевод строки, однако это может не поддерживаться в будущих версиях. Такие символы также подвержены искажениям, если файл с выводом <code class="command">COPY</code> переносится между разными системами (например, с Unix в Windows и наоборот).</p><p>Все последовательности с обратной косой чертой обрабатываются после преобразования кодировки. Байты, заданные в таких последовательностях восьмеричными или шестнадцатеричными цифрами, должны представлять допустимые символы в кодировке базы данных.</p><p><code class="command">COPY TO</code> завершает каждую строку символом новой строки в стиле Unix (<span class="quote">«<span class="quote"><code class="literal">\n</code></span>»</span>). Серверы, работающие в Microsoft Windows, вместо этого выводят символы возврат каретки/новая строка (<span class="quote">«<span class="quote"><code class="literal">\r\n</code></span>»</span>), но только при выводе <code class="command">COPY</code> в файл на сервере; для согласованности на разных платформах, <code class="command">COPY TO STDOUT</code> всегда передаёт <span class="quote">«<span class="quote"><code class="literal">\n</code></span>»</span>, вне зависимости от платформы сервера. <code class="command">COPY FROM</code> может воспринимать строки, завершающиеся символами новая строка, перевод каретки, либо возврат каретки+новая строка. Чтобы уменьшить риск ошибки из-за неэкранированных символов новой строки и возврата каретки, которые должны были быть данными, <code class="command">COPY FROM</code> сигнализирует о проблеме, если концы строк во входных данных различаются.</p></div><div class="refsect2" id="id-1.9.3.55.9.3"><h3>Формат CSV</h3><p>Этот формат применяется для импорта и экспорта данных в виде списка значений, разделённых запятыми (<code class="literal">CSV</code>), с которым могут работать многие другие программы, например электронные таблицы. Вместо правил экранирования значений, введённых в <span class="productname">PostgreSQL</span> для текстового формата, этот формат использует стандартный механизм экранирования <code class="literal">CSV</code>.</p><p>Значения в каждой записи разделяются символами <code class="literal">DELIMITER</code>. Если значение содержит символ разделителя, символ <code class="literal">QUOTE</code>, маркер <code class="literal">NULL</code>, символ возврата каретки или перевода строки, то всё значение дополнятся спереди и сзади символами <code class="literal">QUOTE</code>, а любое вхождение символа <code class="literal">QUOTE</code> или спецсимвола (<code class="literal">ESCAPE</code>) в данных предваряется спецсимволом. С указанием <code class="literal">FORCE_QUOTE</code> в кавычки будут принудительно заключаться любые значения не <code class="literal">NULL</code> в указанных столбцах.</p><p>В формате <code class="literal">CSV</code> отсутствует стандартный способ отличить значение <code class="literal">NULL</code> от пустой строки. В <span class="productname">PostgreSQL</span> команда <code class="command">COPY</code> решает это с помощью кавычек. Значение <code class="literal">NULL</code> выводится в виде строки, задаваемой параметром <code class="literal">NULL</code>, и не заключается в кавычки, тогда как значение не <code class="literal">NULL</code>, со строкой, задаваемой параметром <code class="literal">NULL</code>, заключается. Например, с параметрами по умолчанию <code class="literal">NULL</code> записывается в виде пустой строки без кавычек, тогда как пустая строка записывается в двойных кавычках (<code class="literal">""</code>). При чтении значений действуют похожие правила. Указание <code class="literal">FORCE_NOT_NULL</code> позволяет избежать сравнений на <code class="literal">NULL</code> во входных данных в заданных столбцах, а <code class="literal">FORCE_NULL</code> — преобразовывать в <code class="literal">NULL</code> маркеры NULL, даже заключённые в кавычки.</p><p>Так как обратная косая черта не является спецсимволом в формате <code class="literal">CSV</code>, маркер конца данных <code class="literal">\.</code> может быть и значением данных. Во избежание ошибок интерпретации данные <code class="literal">\.</code>, выводимые в виде единственного элемента строки, автоматически заключаются в кавычки при выводе, а при вводе этот маркер, заключённый в кавычки, не воспринимается как маркер конца данных. При загрузке файла, созданного другой программой, в котором в единственном столбце без кавычек оказалось значение <code class="literal">\.</code>, потребуется дополнительно заключить это значение в кавычки.</p><div class="note"><h3 class="title">Примечание</h3><p>В формате <code class="literal">CSV</code> все символы являются значимыми. Заключённое в кавычки значение, дополненное пробелами или любыми другими символами, кроме <code class="literal">DELIMITER</code>, будет включать и эти символы. Это может приводить к ошибкам при импорте данных из системы, дополняющей строки <code class="literal">CSV</code> пробельными символами до некоторой фиксированной ширины. В случае возникновения такой проблемы необходимо обработать файл <code class="literal">CSV</code> и удалить из него замыкающие пробельные символы, прежде чем загружать данные из него в <span class="productname">PostgreSQL</span>.</p></div><div class="note"><h3 class="title">Примечание</h3><p>Обработчик формата <code class="literal">CSV</code> воспринимает и генерирует файлы <code class="literal">CSV</code> со значениями в кавычках, которые могут содержать символы возврата каретки и перевода строки. Таким образом, число строк в этих файлах не строго равно числу строк в таблице, как в файлах текстового формата.</p></div><div class="note"><h3 class="title">Примечание</h3><p>Многие программы генерируют странные и иногда неприемлемые файлы <code class="literal">CSV</code>, так что этот формат используется скорее по соглашению, чем по стандарту. Поэтому вам могут встретиться файлы, которые невозможно импортировать, используя этот механизм, а <code class="command">COPY</code> может сформировать такие файлы, что их не смогут обработать другие программы.</p></div></div><div class="refsect2" id="id-1.9.3.55.9.4"><h3>Двоичный формат</h3><p>При выборе формата <code class="literal">binary</code> все данные сохраняются/считываются в двоичном, а не текстовом виде. Иногда этот формат обрабатывается быстрее, чем текстовый и <code class="literal">CSV</code>, но он может оказаться непереносимым между разными машинными архитектурами и версиями <span class="productname">PostgreSQL</span>. Кроме того, двоичный формат сильно зависит от типов данных; например, он не позволяет вывести данные из столбца <code class="type">smallint</code>, а затем прочитать их в столбец <code class="type">integer</code>, хотя с текстовым форматом это вполне возможно.</p><p>Формат <code class="literal">binary</code> включает заголовок файла, ноль или более записей, содержащих данные строк, и окончание файла. Для заголовков и данных принят сетевой порядок байт.</p><div class="note"><h3 class="title">Примечание</h3><p>В <span class="productname">PostgreSQL</span> до версии 7.4 использовался другой двоичный формат.</p></div><div class="refsect3" id="id-1.9.3.55.9.4.5"><h4>Заголовок файла</h4><p>Заголовок файла содержит 15 байт фиксированных полей, за которыми следует область расширения заголовка переменной длины. Фиксированные поля: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Сигнатура</span></dt><dd><p>Последовательность из 11 байт <code class="literal">PGCOPY\n\377\r\n\0</code> — заметьте, что нулевой байт является обязательной частью сигнатуры. (Эта сигнатура позволяет легко выявить файлы, испорченные при передаче, не сохраняющей все 8 бит данных. Она изменится при прохождении через фильтры, меняющие концы строк, отбрасывающие нулевые байты или старшие биты, либо добавляющие чётность.)</p></dd><dt><span class="term">Поле флагов</span></dt><dd><p>Маска из 32 бит, обозначающая важные аспекты формата файла. Биты нумеруются от 0 (<acronym class="acronym">LSB</acronym>) до 31 (<acronym class="acronym">MSB</acronym>). Учтите, что это поле хранится в сетевом порядке байт (наиболее значащий байт первый), как и все целочисленные поля в этом формате. Биты 16–31 зарезервированы для обозначения критичных особенностей формата; обработчик должен прервать чтение, встретив любой неожиданный бит в этом диапазоне. Биты 0–15 зарезервированы для обозначения особенностей, связанных с обратной совместимостью; обработчик может просто игнорировать любые неожиданные биты в этом диапазоне. В настоящее время определён только один битовый флаг, остальные должны быть равны 0: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Бит 16</span></dt><dd><p>При 1 в данные включается OID, при 0 — не включается. Системные столбцы oid в <span class="productname">PostgreSQL</span> больше не поддерживаются, но этот индикатор всё ещё сохраняется.</p></dd></dl></div></dd><dt><span class="term">Длина области расширения заголовка</span></dt><dd><p>Целое 32-битное число, определяющее длину в байтах остального заголовка, не включая само это значение. В настоящее время содержит 0, и сразу за ним следует первая запись. При будущих изменениях формата в заголовок могут быть добавлены дополнительные данные. Обработчик должен просто пропускать все расширенные данные заголовка, о которых ему ничего не известно.</p></dd></dl></div><p>Область расширения заголовка предусмотрена для размещения последовательности самоопределяемых блоков. Поле флагов не должно содержать указаний о том, что содержится в области расширения. Точное содержимое области расширения может быть определено в будущих версиях.</p><p>При таком подходе возможно как обратно-совместимое дополнение заголовка (добавить блоки расширения заголовка или установить младшие биты флагов), так и не обратно-совместимое (установить старшие биты флагов, сигнализирующие о подобном изменении, и добавить вспомогательные данные в область расширения, если это потребуется).</p></div><div class="refsect3" id="id-1.9.3.55.9.4.6"><h4>Записи</h4><p>Каждая запись начинается с 16-битного целого числа, определяющего количество полей в записи. (В настоящее время во всех записях должно быть одинаковое число полей, но так может быть не всегда.) Затем, для каждого поля в записи указывается 32-битная длина поля, за которой следует это количество байт с данными поля. (Значение длины не включает свой размер, и может быть равно нулю.) В качестве особого варианта, -1 обозначает, что в поле содержится NULL. В случае с NULL за длиной не следуют байты данных.</p><p>Выравнивание или какие-либо дополнительные данные между полями не вставляются.</p><p>В настоящее время предполагается, что все значения данных в файле двоичного формата содержатся в двоичном формате (формате под кодом 1). Возможно, в будущем расширении в заголовок будет добавлено поле, позволяющее задавать другие коды форматов для разных столбцов.</p><p>Чтобы определить подходящий двоичный формат для фактических данных, обратитесь к исходному коду <span class="productname">PostgreSQL</span>, в частности, к функциям <code class="function">*send</code> и <code class="function">*recv</code> для типов данных каждого столбца (обычно эти функции находятся в каталоге <code class="filename">src/backend/utils/adt/</code> в дереве исходного кода).</p><p>Если в файл включается OID, поле OID следует немедленно за числом, определяющим количество полей. Это поле не отличается от других ничем, кроме того, что оно не учитывается в количестве полей. Заметьте, что в текущих версиях <span class="productname">PostgreSQL</span> системные столбцы oid не поддерживаются.</p></div><div class="refsect3" id="id-1.9.3.55.9.4.7"><h4>Окончание файла</h4><p>Окончание файла состоит из 16-битного целого, содержащего -1. Это позволяет легко отличить его от счётчика полей в записи.</p><p>Обработчик, читающий файл, должен выдать ошибку, если число полей в записи не равно -1 или ожидаемому числу столбцов. Это обеспечивает дополнительную проверку синхронизации данных.</p></div></div></div><div class="refsect1" id="id-1.9.3.55.10"><h2>Примеры</h2><p>В следующем примере таблица передаётся клиенту с разделителем полей «вертикальная черта» (<code class="literal">|</code>): </p><pre class="programlisting">COPY country TO STDOUT (DELIMITER '|');</pre><p>Копирование данных из файла в таблицу <code class="literal">country</code>: </p><pre class="programlisting">COPY country FROM '/usr1/proj/bray/sql/country_data';</pre><p>Копирование в файл только данных стран, название которых начинается с 'A': </p><pre class="programlisting">COPY (SELECT * FROM country WHERE country_name LIKE 'A%') TO '/usr1/proj/bray/sql/a_list_countries.copy';</pre><p>Для копирования данных в сжатый файл можно направить вывод через внешнюю программу сжатия: </p><pre class="programlisting">COPY country TO PROGRAM 'gzip &gt; /usr1/proj/bray/sql/country_data.gz';</pre><p>Пример данных, подходящих для копирования в таблицу из <code class="literal">STDIN</code>: </p><pre class="programlisting">AF      AFGHANISTAN
AL      ALBANIA
DZ      ALGERIA
ZM      ZAMBIA
ZW      ZIMBABWE</pre><p> Примечание: пробелы в каждой строке на самом деле обозначают символы табуляции.</p><p>Ниже приведены те же данные, но выведенные в двоичном формате. Данные показаны после обработки Unix-утилитой <code class="command">od -c</code>. Таблица содержит три столбца; первый имеет тип <code class="type">char(2)</code>, второй — <code class="type">text</code>, а третий — <code class="type">integer</code>. Последний столбец во всех строках содержит NULL. </p><pre class="programlisting">0000000   P   G   C   O   P   Y  \n 377  \r  \n  \0  \0  \0  \0  \0  \0
0000020  \0  \0  \0  \0 003  \0  \0  \0 002   A   F  \0  \0  \0 013   A
0000040   F   G   H   A   N   I   S   T   A   N 377 377 377 377  \0 003
0000060  \0  \0  \0 002   A   L  \0  \0  \0 007   A   L   B   A   N   I
0000100   A 377 377 377 377  \0 003  \0  \0  \0 002   D   Z  \0  \0  \0
0000120 007   A   L   G   E   R   I   A 377 377 377 377  \0 003  \0  \0
0000140  \0 002   Z   M  \0  \0  \0 006   Z   A   M   B   I   A 377 377
0000160 377 377  \0 003  \0  \0  \0 002   Z   W  \0  \0  \0  \b   Z   I
0000200   M   B   A   B   W   E 377 377 377 377 377 377</pre></div><div class="refsect1" id="id-1.9.3.55.11"><h2>Совместимость</h2><p>Оператор <code class="command">COPY</code> отсутствует в стандарте SQL.</p><p>До версии <span class="productname">PostgreSQL</span> 9.0 использовался и по-прежнему поддерживается следующий синтаксис: </p><pre class="synopsis">
COPY <em class="replaceable"><code>имя_таблицы</code></em> [ ( <em class="replaceable"><code>имя_столбца</code></em> [, ...] ) ]
    FROM { '<em class="replaceable"><code>имя_файла</code></em>' | STDIN }
    [ [ WITH ]
          [ BINARY ]
          [ DELIMITER [ AS ] '<em class="replaceable"><code>символ_разделитель</code></em>' ]
          [ NULL [ AS ] '<em class="replaceable"><code>маркер_NULL</code></em>' ]
          [ CSV [ HEADER ]
                [ QUOTE [ AS ] '<em class="replaceable"><code>символ_кавычек</code></em>' ]
                [ ESCAPE [ AS ] '<em class="replaceable"><code>символ_экранирования</code></em>' ]
                [ FORCE NOT NULL <em class="replaceable"><code>имя_столбца</code></em> [, ...] ] ] ]

COPY { <em class="replaceable"><code>имя_таблицы</code></em> [ ( <em class="replaceable"><code>имя_столбца</code></em> [, ...] ) ] | ( <em class="replaceable"><code>запрос</code></em> ) }
    TO { '<em class="replaceable"><code>имя_файла</code></em>' | STDOUT }
    [ [ WITH ]
          [ BINARY ]
          [ DELIMITER [ AS ] '<em class="replaceable"><code>символ_разделитель</code></em>' ]
          [ NULL [ AS ] '<em class="replaceable"><code>маркер_NULL</code></em>' ]
          [ CSV [ HEADER ]
                [ QUOTE [ AS ] '<em class="replaceable"><code>символ_кавычек</code></em>' ]
                [ ESCAPE [ AS ] '<em class="replaceable"><code>символ_экранирования</code></em>' ]
                [ FORCE QUOTE { <em class="replaceable"><code>имя_столбца</code></em> [, ...] | * } ] ] ]
</pre><p> Заметьте, что в этом синтаксисе ключевые слова <code class="literal">BINARY</code> и <code class="literal">CSV</code> обрабатываются как независимые, а не как аргументы параметра <code class="literal">FORMAT</code>.</p><p>До версии <span class="productname">PostgreSQL</span> 7.3 использовался и по-прежнему поддерживается следующий синтаксис: </p><pre class="synopsis">
COPY [ BINARY ] <em class="replaceable"><code>имя_таблицы</code></em>
    FROM { '<em class="replaceable"><code>имя_файла</code></em>' | STDIN }
    [ [USING] DELIMITERS '<em class="replaceable"><code>символ_разделитель</code></em>' ]
    [ WITH NULL AS '<em class="replaceable"><code>маркер_NULL</code></em>' ]

COPY [ BINARY ] <em class="replaceable"><code>имя_таблицы</code></em>
    TO { '<em class="replaceable"><code>имя_файла</code></em>' | STDOUT }
    [ [USING] DELIMITERS '<em class="replaceable"><code>символ_разделитель</code></em>' ]
    [ WITH NULL AS '<em class="replaceable"><code>маркер_NULL</code></em>' ]
</pre></div><div class="refsect1" id="id-1.9.3.55.12"><h2>См. также</h2><span class="simplelist"><a class="xref" href="progress-reporting.html#COPY-PROGRESS-REPORTING" title="28.4.3. Отслеживание выполнения COPY">Подраздел 28.4.3</a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-commit-prepared.html" title="COMMIT PREPARED">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-create-access-method.html" title="CREATE ACCESS METHOD">След.</a></td></tr><tr><td width="40%" align="left" valign="top">COMMIT PREPARED </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> CREATE ACCESS METHOD</td></tr></table></div></body></html>