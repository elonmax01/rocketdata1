<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CREATE FUNCTION</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sql-createforeigntable.html" title="CREATE FOREIGN TABLE" /><link rel="next" href="sql-creategroup.html" title="CREATE GROUP" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">CREATE FUNCTION</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-createforeigntable.html" title="CREATE FOREIGN TABLE">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><th width="60%" align="center">Команды SQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-creategroup.html" title="CREATE GROUP">След.</a></td></tr></table><hr /></div><div class="refentry" id="SQL-CREATEFUNCTION"><div class="titlepage"></div><a id="id-1.9.3.67.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">CREATE FUNCTION</span></h2><p>CREATE FUNCTION — создать функцию</p></div><div class="refsynopsisdiv"><h2>Синтаксис</h2><pre class="synopsis">CREATE [ OR REPLACE ] FUNCTION
    <em class="replaceable"><code>имя</code></em> ( [ [ <em class="replaceable"><code>режим_аргумента</code></em> ] [ <em class="replaceable"><code>имя_аргумента</code></em> ] <em class="replaceable"><code>тип_аргумента</code></em> [ { DEFAULT | = } <em class="replaceable"><code>выражение_по_умолчанию</code></em> ] [, ...] ] )
    [ RETURNS <em class="replaceable"><code>тип_результата</code></em>
      | RETURNS TABLE ( <em class="replaceable"><code>имя_столбца</code></em> <em class="replaceable"><code>тип_столбца</code></em> [, ...] ) ]
  { LANGUAGE <em class="replaceable"><code>имя_языка</code></em>
    | TRANSFORM { FOR TYPE <em class="replaceable"><code>имя_типа</code></em> } [, ... ]
    | WINDOW
    | { IMMUTABLE | STABLE | VOLATILE }
    | [ NOT ] LEAKPROOF
    | { CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT }
    | { [ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER }
    | PARALLEL { UNSAFE | RESTRICTED | SAFE }
    | COST <em class="replaceable"><code>стоимость_выполнения</code></em>
    | ROWS <em class="replaceable"><code>строк_в_результате</code></em>
    | SUPPORT <em class="replaceable"><code>вспомогательная_функция</code></em>
    | SET <em class="replaceable"><code>параметр_конфигурации</code></em> { TO <em class="replaceable"><code>значение</code></em> | = <em class="replaceable"><code>значение</code></em> | FROM CURRENT }
    | AS '<em class="replaceable"><code>определение</code></em>'
    | AS '<em class="replaceable"><code>объектный_файл</code></em>', '<em class="replaceable"><code>объектный_символ</code></em>'
    | <em class="replaceable"><code>тело_sql</code></em>
  } ...</pre></div><div class="refsect1" id="SQL-CREATEFUNCTION-DESCRIPTION"><h2>Описание</h2><p>Команда <code class="command">CREATE FUNCTION</code> определяет новую функцию. <code class="command">CREATE OR REPLACE FUNCTION</code> создаёт новую функцию, либо заменяет определение уже существующей. Чтобы определить функцию, необходимо иметь право <code class="literal">USAGE</code> для соответствующего языка.</p><p>Если указано имя схемы, функция создаётся в заданной схеме, в противном случае — в текущей. Имя новой функции должно отличаться от имён существующих функций или процедур с такими же типами аргументов в этой схеме. Однако функции и процедуры с аргументами разных типов могут иметь одно имя (это называется <em class="firstterm">перегрузкой</em>).</p><p>Чтобы заменить текущее определение существующей функции, используйте команду <code class="command">CREATE OR REPLACE FUNCTION</code>. Но учтите, что она не позволяет изменить имя или аргументы функции (если попытаться сделать это, на самом деле будет создана новая, независимая функция). Кроме того, <code class="command">CREATE OR REPLACE FUNCTION</code> не позволит изменить тип результата существующей функции. Чтобы сделать это, придётся удалить функцию и создать её заново. (Это означает, что если функция имеет выходные параметры (<code class="literal">OUT</code>), то изменить типы параметров <code class="literal">OUT</code> можно, только удалив функцию.)</p><p>Когда команда <code class="command">CREATE OR REPLACE FUNCTION</code> заменяет существующую функцию, владелец и права доступа к этой функции не меняются. Все другие свойства функции получают значения, задаваемые командой явно или по умолчанию. Чтобы заменить функцию, необходимо быть её владельцем (или быть членом роли-владельца).</p><p>Если вы удалите и затем вновь создадите функцию, новая функция станет другой сущностью, отличной от старой; вам потребуется так же удалить существующие правила, представления, триггеры и т. п., ссылающиеся на старую функцию. Поэтому, чтобы изменить определение функции, сохраняя ссылающиеся на неё объекты, следует использовать <code class="command">CREATE OR REPLACE FUNCTION</code>. Кроме того, многие дополнительные свойства существующей функции можно изменить с помощью <code class="command">ALTER FUNCTION</code>.</p><p>Владельцем функции становится создавший её пользователь.</p><p>Чтобы создать функцию, необходимо иметь право <code class="literal">USAGE</code> для типов её аргументов и возвращаемого типа.</p><p>За дополнительной информацией о разработке функций обратитесь к <a class="xref" href="xfunc.html" title="38.3. Пользовательские функции">Разделу 38.3</a>.</p></div><div class="refsect1" id="id-1.9.3.67.6"><h2>Параметры</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>имя</code></em></span></dt><dd><p>Имя создаваемой функции (возможно, дополненное схемой).</p></dd><dt><span class="term"><em class="replaceable"><code>режим_аргумента</code></em></span></dt><dd><p>Режим аргумента: <code class="literal">IN</code> (входной), <code class="literal">OUT</code> (выходной), <code class="literal">INOUT</code> (входной и выходной) или <code class="literal">VARIADIC</code> (переменный). По умолчанию подразумевается <code class="literal">IN</code>. За единственным аргументом <code class="literal">VARIADIC</code> могут следовать только аргументы <code class="literal">OUT</code>. Кроме того, аргументы <code class="literal">OUT</code> и <code class="literal">INOUT</code> нельзя использовать с предложением <code class="literal">RETURNS TABLE</code>.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_аргумента</code></em></span></dt><dd><p>Имя аргумента. Некоторые языки (включая SQL и PL/pgSQL) позволяют использовать это имя в теле функции. Для других языков это имя служит просто дополнительным описанием, если говорить о самой функции; однако вы можете указывать имена аргументов при вызове функции для улучшения читаемости (см. <a class="xref" href="sql-syntax-calling-funcs.html" title="4.3. Вызов функций">Раздел 4.3</a>). Имя выходного аргумента в любом случае имеет значение, так как оно определяет имя столбца в типе результата. (Если вы опустите имя выходного аргумента, система выберет для него имя по умолчанию.)</p></dd><dt><span class="term"><em class="replaceable"><code>тип_аргумента</code></em></span></dt><dd><p>Тип данных аргумента функции (возможно, дополненный схемой), при наличии аргументов. Тип аргументов может быть базовым, составным или доменным, либо это может быть ссылка на столбец таблицы.</p><p>В зависимости от языка реализации также может допускаться указание <span class="quote">«<span class="quote">псевдотипов</span>»</span>, например, <code class="type">cstring</code>. Псевдотипы показывают, что фактический тип аргумента либо определён не полностью, либо существует вне множества обычных типов SQL.</p><p>Ссылка на тип столбца записывается в виде <code class="literal"><em class="replaceable"><code>имя_таблицы</code></em>.<em class="replaceable"><code>имя_столбца</code></em>%TYPE</code>. Иногда такое указание бывает полезно, так как позволяет создать функцию, независящую от изменений в определении таблицы.</p></dd><dt><span class="term"><em class="replaceable"><code>выражение_по_умолчанию</code></em></span></dt><dd><p>Выражение, используемое для вычисления значения по умолчанию, если параметр не задан явно. Результат выражения должен сводиться к типу соответствующего параметра. Значения по умолчанию могут иметь только входные параметры (включая <code class="literal">INOUT</code>). Для всех входных параметров, следующих за параметром с определённым значением по умолчанию, также должны быть определены значения по умолчанию.</p></dd><dt><span class="term"><em class="replaceable"><code>тип_результата</code></em></span></dt><dd><p>Тип возвращаемых данных (возможно, дополненный схемой). Это может быть базовый, составной или доменный тип, либо ссылка на тип столбца таблицы. В зависимости от языка реализации здесь также могут допускаться <span class="quote">«<span class="quote">псевдотипы</span>»</span>, например <code class="type">cstring</code>. Если функция не должна возвращать значение, в качестве типа результата указывается <code class="type">void</code>.</p><p>В случае наличия параметров <code class="literal">OUT</code> или <code class="literal">INOUT</code>, предложение <code class="literal">RETURNS</code> можно опустить. Если оно присутствует, оно должно согласовываться с типом результата, выводимым из выходных параметров: в качестве возвращаемого типа указывается <code class="literal">RECORD</code>, если выходных параметров несколько, либо тип единственного выходного параметра.</p><p>Указание <code class="literal">SETOF</code> показывает, что функция возвращает множество, а не единственный элемент.</p><p>Ссылка на тип столбца записывается в виде <code class="literal"><em class="replaceable"><code>имя_таблицы</code></em>.<em class="replaceable"><code>имя_столбца</code></em>%TYPE</code>.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_столбца</code></em></span></dt><dd><p>Имя выходного столбца в записи <code class="literal">RETURNS TABLE</code>. По сути это ещё один способ объявить именованный выходной параметр (<code class="literal">OUT</code>), но <code class="literal">RETURNS TABLE</code> также подразумевает и <code class="literal">RETURNS SETOF</code>.</p></dd><dt><span class="term"><em class="replaceable"><code>тип_столбца</code></em></span></dt><dd><p>Тип данных выходного столбца в записи <code class="literal">RETURNS TABLE</code>.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_языка</code></em></span></dt><dd><p>Имя языка, на котором реализована функция. Это может быть <code class="literal">sql</code>, <code class="literal">c</code>, <code class="literal">internal</code>, либо имя процедурного языка, определённого пользователем, например, <code class="literal">plpgsql</code>. Если присутствует <em class="replaceable"><code>тело_sql</code></em>, подразумевается язык <code class="literal">sql</code>. Вариант написания этого имени в апострофах считается устаревшим и требует точного совпадения регистра.</p></dd><dt><span class="term"><code class="literal">TRANSFORM { FOR TYPE <em class="replaceable"><code>имя_типа</code></em> } [, ... ] }</code></span></dt><dd><p>Устанавливает список трансформаций, которые должны применяться при вызове функции. Трансформации выполняют преобразования между типами SQL и типами данных, специфичными для языков; см. <a class="xref" href="sql-createtransform.html" title="CREATE TRANSFORM"><span class="refentrytitle">CREATE TRANSFORM</span></a>. Преобразования встроенных типов обычно жёстко предопределены в реализациях процедурных языков, так что их здесь указывать не нужно. Если реализация процедурного языка не может обработать тип и трансформация для него отсутствует, будет выполнено преобразование типов по умолчанию, но это зависит от реализации.</p></dd><dt><span class="term"><code class="literal">WINDOW</code></span></dt><dd><p>Указание <code class="literal">WINDOW</code> показывает, что создаётся не простая, а <em class="firstterm">оконная функция</em>. В настоящее время это имеет смысл только для функций, написанных на C. Атрибут <code class="literal">WINDOW</code> нельзя изменить, модифицируя впоследствии определение функции.</p></dd><dt><span class="term"><code class="literal">IMMUTABLE</code><br /></span><span class="term"><code class="literal">STABLE</code><br /></span><span class="term"><code class="literal">VOLATILE</code></span></dt><dd><p>Эти атрибуты информируют оптимизатор запросов о поведении функции. Одновременно можно указать не более одного атрибута. Если никакой атрибут не задан, по умолчанию подразумевается <code class="literal">VOLATILE</code>.</p><p>Характеристика <code class="literal">IMMUTABLE</code> (постоянная) показывает, что функция не может модифицировать базу данных и всегда возвращает один и тот же результат при определённых значениях аргументов; то есть, она не обращается к базе данных и не использует информацию, не переданную ей явно в списке аргументов. Если функция имеет такую характеристику, любой её вызов с аргументами-константами можно немедленно заменить значением функции.</p><p>Характеристика <code class="literal">STABLE</code> (стабильная) показывает, что функция не может модифицировать базу данных и в рамках одного сканирования таблицы она всегда возвращает один и тот же результат для определённых значений аргументов, но этот результат может быть разным в разных операторах SQL. Это подходящий выбор для функций, результаты которых зависят от содержимого базы данных и настраиваемых параметров (например, текущего часового пояса). (Но этот вариант не подходит для триггеров <code class="literal">AFTER</code>, желающих прочитать строки, изменённые текущей командой.) Также заметьте, что функции семейства <code class="function">current_timestamp</code> также считаются стабильными, так как их результаты не меняются внутри транзакции.</p><p>Характеристика <code class="literal">VOLATILE</code> (изменчивая) показывает, что результат функции может меняться даже в рамках одного сканирования таблицы, так что её вызовы нельзя оптимизировать. Изменчивы в этом смысле относительно немногие функции баз данных, например: <code class="literal">random()</code>, <code class="literal">currval()</code> и <code class="literal">timeofday()</code>. Но заметьте, что любая функция с побочными эффектами должна быть классифицирована как изменчивая, даже если её результат вполне предсказуем, чтобы её вызовы не были соптимизированы; пример такой функции: <code class="literal">setval()</code>.</p><p>За дополнительными подробностями обратитесь к <a class="xref" href="xfunc-volatility.html" title="38.7. Категории изменчивости функций">Разделу 38.7</a>.</p></dd><dt><span class="term"><code class="literal">LEAKPROOF</code></span></dt><dd><p>Характеристика <code class="literal">LEAKPROOF</code> (герметичная) показывает, что функция не имеет побочных эффектов. Она не раскрывает информацию о своих аргументах, кроме как возвращая результат. Например, функция, которая выдаёт сообщение об ошибке с некоторыми, но не всеми значениями аргументов, либо выводит значения аргументов в сообщении об ошибке, не является герметичной. Это влияет на то, как система выполняет запросы к представлениям, созданным с барьером безопасности (с указанием <code class="literal">security_barrier</code>), или к таблицам с включённой защитой строк. Во избежание неконтролируемой утечки данных система будет проверять условия из политик защиты и определений представлений с барьерами безопасности перед любыми условиями, которые задаёт пользователь в самом запросе и в которых задействуются негерметичные функции. Функции и операторы, помеченные как герметичные, считаются доверенными и могут выполняться перед условиями из политик защиты и представлений с барьерами безопасности. При этом функции, которые не имеют аргументов или которым не передаются никакие аргументы из представления с барьером безопасности или таблицы, не требуется помечать как герметичные, чтобы они выполнялись до условий, связанных с безопасностью. См. <a class="xref" href="sql-createview.html" title="CREATE VIEW"><span class="refentrytitle">CREATE VIEW</span></a> и <a class="xref" href="rules-privileges.html" title="41.5. Правила и права">Раздел 41.5</a>. Это свойство может установить только суперпользователь.</p></dd><dt><span class="term"><code class="literal">CALLED ON NULL INPUT</code><br /></span><span class="term"><code class="literal">RETURNS NULL ON NULL INPUT</code><br /></span><span class="term"><code class="literal">STRICT</code></span></dt><dd><p><code class="literal">CALLED ON NULL INPUT</code> (по умолчанию) показывает, что функция будет вызвана как обычно, если среди её аргументов оказываются значения NULL. В этом случае ответственность за проверку значений NULL и соответствующую их обработку ложится на разработчика функции.</p><p>Указание <code class="literal">RETURNS NULL ON NULL INPUT</code> или <code class="literal">STRICT</code> показывает, что функция всегда возвращает NULL, получив NULL в одном из аргументов. Такая функция не будет вызываться с аргументами NULL, вместо этого автоматически будет полагаться результат NULL.</p></dd><dt><span class="term"><code class="literal">[<span class="optional">EXTERNAL</span>] SECURITY INVOKER</code><br /></span><span class="term"><code class="literal">[<span class="optional">EXTERNAL</span>] SECURITY DEFINER</code></span></dt><dd><p>Характеристика <code class="literal">SECURITY INVOKER</code> (безопасность вызывающего) показывает, что функция будет выполняться с правами пользователя, вызвавшего её. Этот вариант подразумевается по умолчанию. Вариант <code class="literal">SECURITY DEFINER</code> (безопасность определившего) показывает, что функция выполняется с правами пользователя, владеющего ей. Дополнительную информацию о безопасном создании функций с характеристикой <code class="literal">SECURITY DEFINER</code> <a class="link" href="sql-createfunction.html#SQL-CREATEFUNCTION-SECURITY" title="Разработка защищённых функций SECURITY DEFINER">см. ниже</a>.</p><p>Ключевое слово <code class="literal">EXTERNAL</code> (внешняя) допускается для соответствия стандарту SQL, но является необязательным, так как, в отличие от SQL, эта характеристика распространяется на все функции, а не только внешние.</p></dd><dt><span class="term"><code class="literal">PARALLEL</code></span></dt><dd><p>Указание <code class="literal">PARALLEL UNSAFE</code> означает, что эту функцию нельзя выполнять в параллельном режиме и присутствие такой функции в операторе SQL приводит к выбору последовательного плана выполнения. Это характеристика функции по умолчанию. Указание <code class="literal">PARALLEL RESTRICTED</code> означает, что функцию можно выполнять в параллельном режиме, но только в ведущем процессе группы. <code class="literal">PARALLEL SAFE</code> показывает, что функция безопасна для выполнения в параллельном режиме без ограничений.</p><p>Функции должны помечаться как небезопасные для параллельного выполнения, если они изменяют состояние базы данных, вносят изменения в транзакции, например, используя подтранзакции, обращаются к последовательностям или пытаются сохранять параметры (например, используя <code class="literal">setval</code>). Ограниченно параллельными должны помечаться функции, которые обращаются к временным таблицам, состоянию клиентского подключения, курсорам, подготовленным операторам или разнообразному состоянию обслуживающего процесса, которое система не может синхронизировать в параллельном режиме (например, <code class="literal">setseed</code> может выполнять только ведущий процесс группы, так как изменения, внесённые другим процессом, не передаются ведущему). Вообще, если функция помечена как безопасная, тогда как она является ограниченной или небезопасной, либо если она помечена как ограниченно безопасная, не являясь безопасной, при попытке вызвать её в параллельном запросе она может выдавать ошибки или неверные результаты. Функции на языке C при неправильной пометке теоретически могут проявлять полностью неопределённое поведение, так как система никак не может защититься от произвольного кода на C, но чаще все они будут вести себя не хуже, чем любая другая функция. В случае сомнений функцию следует помечать как небезопасную (<code class="literal">UNSAFE</code>), что и имеет место по умолчанию.</p></dd><dt><span class="term"><code class="literal">COST</code> <em class="replaceable"><code>стоимость_выполнения</code></em></span></dt><dd><p>Положительное число, задающее примерную стоимость выполнения функции, в единицах <a class="xref" href="runtime-config-query.html#GUC-CPU-OPERATOR-COST">cpu_operator_cost</a>. Если функция возвращает множество, это число задаёт стоимость для одной строки. Если стоимость не указана, для функций на C и внутренних функций она считается равной 1 единице, а для функций на всех других языках — 100 единицам. При больших значениях планировщик будет стараться не вызывать эту функцию чаще, чем это необходимо.</p></dd><dt><span class="term"><code class="literal">ROWS</code> <em class="replaceable"><code>строк_в_результате</code></em></span></dt><dd><p>Положительное число, задающее примерное число строк, которое будет ожидать планировщик на выходе этой функции. Это указание допустимо, только если функция объявлена как возвращающая множество. Предполагаемое по умолчанию значение — 1000 строк.</p></dd><dt><span class="term"><code class="literal">SUPPORT</code> <em class="replaceable"><code>вспомогательная_функция</code></em></span></dt><dd><p>Имя (возможно, дополненное схемой) <em class="firstterm">вспомогательной функции для планировщика</em>, которая будет использоваться этой функцией. За подробностями обратитесь к <a class="xref" href="xfunc-optimization.html" title="38.11. Информация для оптимизации функций">Разделу 38.11</a>. Для использования этого указания нужно быть суперпользователем.</p></dd><dt><span class="term"><em class="replaceable"><code>параметр_конфигурации</code></em><br /></span><span class="term"><em class="replaceable"><code>значение</code></em></span></dt><dd><p>Предложение <code class="literal">SET</code> определяет, что при вызове функции указанный параметр конфигурации должен принять заданное значение, а затем восстановить своё предыдущее значение при завершении функции. Предложение <code class="literal">SET FROM CURRENT</code> сохраняет в качестве значения, которое будет применено при входе в функцию, значение, действующее в момент выполнения <code class="command">CREATE FUNCTION</code>.</p><p>Если в определение функции добавлено <code class="literal">SET</code>, то действие команды <code class="command">SET LOCAL</code>, выполняемой внутри функции для того же параметра, ограничивается телом функции: предыдущее значение параметра так же будет восстановлено при завершении функции. Однако обычная команда <code class="command">SET</code> (без <code class="literal">LOCAL</code>) переопределяет предложение <code class="literal">SET</code>, как и предыдущую команду <code class="command">SET LOCAL</code>: действие такой команды будет сохранено и после завершения функции, если только не произойдёт откат транзакции.</p><p>За подробными сведениями об именах и значениях параметров обратитесь к <a class="xref" href="sql-set.html" title="SET"><span class="refentrytitle">SET</span></a> и <a class="xref" href="runtime-config.html" title="Глава 20. Настройка сервера">Главе 20</a>.</p></dd><dt><span class="term"><em class="replaceable"><code>определение</code></em></span></dt><dd><p>Строковая константа, определяющая реализацию функции; её значение зависит от языка. Это может быть имя внутренней функции, путь к объектному файлу, команда SQL или код функции на процедурном языке.</p><p>Часто бывает полезно заключать определение функции в доллары (см. <a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-DOLLAR-QUOTING" title="4.1.2.4. Строковые константы, заключённые в доллары">Подраздел 4.1.2.4</a>), а не в традиционные апострофы. Если не использовать доллары, все апострофы и обратные косые черты в определении функции придётся экранировать, дублируя их.</p></dd><dt><span class="term"><code class="literal"><em class="replaceable"><code>объектный_файл</code></em>, <em class="replaceable"><code>объектный_символ</code></em></code></span></dt><dd><p>Эта форма предложения <code class="literal">AS</code> применяется для динамически загружаемых функций на языке C, когда имя функции в коде C не совпадает с именем функции в SQL. Строка <em class="replaceable"><code>объектный_файл</code></em> задаёт имя файла разделяемой библиотеки, содержащей скомпилированную функцию на C, и воспринимается как параметр команды <a class="link" href="sql-load.html" title="LOAD"><code class="command">LOAD</code></a>. Строка <em class="replaceable"><code>объектный_символ</code></em> задаёт символ скомпонованной функции, то есть имя функции в исходном коде на языке C. Если объектный символ опущен, предполагается, что он совпадает с именем определяемой SQL-функции. В C имена всех функций должны быть различными, поэтому перегружаемым функциям, реализованным на C, нужно давать разные имена (например, включать в имена C обозначения типов аргументов).</p><p>Если повторные вызовы <code class="command">CREATE FUNCTION</code> ссылаются на один и тот же объектный файл, он загружается в рамках сеанса только один раз. Чтобы выгрузить и загрузить этот файл снова (например, в процессе разработки), начните новый сеанс.</p></dd><dt><span class="term"><em class="replaceable"><code>тело_sql</code></em></span></dt><dd><p>Тело функции в стиле <code class="literal">LANGUAGE SQL</code>. Это может были один оператор </p><pre class="programlisting">RETURN <em class="replaceable"><code>выражение</code></em></pre><p> или блок операторов </p><pre class="programlisting">BEGIN ATOMIC
  <em class="replaceable"><code>оператор</code></em>;
  <em class="replaceable"><code>оператор</code></em>;
  ...
  <em class="replaceable"><code>оператор</code></em>;
END</pre><p>Оно определяется подобно телу, задаваемому строковой константой (см. <em class="replaceable"><code>определение</code></em> выше), но есть и некоторые различия. Эта форма работает только с функциями в стиле <code class="literal">LANGUAGE SQL</code>, тогда как форма со строковой константой поддерживается для всех языков. Она разбирается во время определения функции, тогда как форма со строковой константой — во время выполнения; как следствие, эта форма не поддерживает полиморфные типы аргументов и другие конструкции, которые нельзя обработать во время определения функции. С данной формой отслеживаются зависимости функции от объектов, используемых в её теле, так что команда <code class="literal">DROP ... CASCADE</code> выполнится корректно, тогда как в случае определения тела в строковой константе после такого удаления могут остаться неполноценные функции. Наконец, данная форма в большей степени соответствует стандарту SQL и совместима с другими реализациями SQL.</p></dd></dl></div></div><div class="refsect1" id="SQL-CREATEFUNCTION-OVERLOADING"><h2>Перегрузка</h2><p><span class="productname">PostgreSQL</span> допускает <em class="firstterm">перегрузку</em> функций; то есть, позволяет использовать одно имя для нескольких различных функций, если у них различаются типы входных аргументов. Независимо от того, используете вы эту возможность или нет, она требует предосторожности при вызове функций в базах данных, где одни пользователи не доверяют другим; см. <a class="xref" href="typeconv-func.html" title="10.3. Функции">Раздел 10.3</a>.</p><p>Две функции считаются совпадающими, если они имеют одинаковые имена и типы <span class="emphasis"><em>входных</em></span> аргументов, параметры <code class="literal">OUT</code> игнорируются. Таким образом, например, эти объявления вызовут конфликт: </p><pre class="programlisting">CREATE FUNCTION foo(int) ...
CREATE FUNCTION foo(int, out text) ...</pre><p>Функции, имеющие разные типы аргументов, не будут считаться конфликтующими в момент создания, но предоставленные для них значения по умолчанию могут вызвать конфликт в момент использования. Например, рассмотрите следующие определения: </p><pre class="programlisting">CREATE FUNCTION foo(int) ...
CREATE FUNCTION foo(int, int default 42) ...</pre><p> Вызов <code class="literal">foo(10)</code> завершится ошибкой из-за неоднозначности в выборе вызываемой функции.</p></div><div class="refsect1" id="SQL-CREATEFUNCTION-NOTES"><h2>Замечания</h2><p>В объявлении аргументов функции и возвращаемого значения допускается полный синтаксис описания типа <acronym class="acronym">SQL</acronym>. Однако модификаторы типа в скобках (например, поле точности для типа <code class="type">numeric</code>) команда <code class="command">CREATE FUNCTION</code> не учитывает. Так что, например, <code class="literal">CREATE FUNCTION foo (varchar(10)) ...</code> создаст такую же функцию, что и <code class="literal">CREATE FUNCTION foo (varchar) ...</code>.</p><p>При замене существующей функции с помощью <code class="command">CREATE OR REPLACE FUNCTION</code> есть ограничения на изменения имён параметров. В частности, нельзя изменить имя, уже назначенное любому входному параметру (хотя можно добавить имена ранее безымянным параметрам). Также, если у функции более одного выходного параметра, нельзя изменять имена выходных параметров, так как это приведёт к изменению имён столбцов анонимного составного типа, описывающего результат функции. Эти ограничения позволяют гарантировать, что существующие вызовы функции не перестанут работать после её замены.</p><p>Если функция объявлена как <code class="literal">STRICT</code> с аргументом <code class="literal">VARIADIC</code>, при оценивании строгости проверяется, что весь переменный массив <span class="emphasis"><em>в целом</em></span> не NULL. Если же в этом массиве содержатся элементы NULL, функция будет вызываться.</p></div><div class="refsect1" id="SQL-CREATEFUNCTION-EXAMPLES"><h2>Примеры</h2><p>SQL-функция, складывающая два целых числа: </p><pre class="programlisting">CREATE FUNCTION add(integer, integer) RETURNS integer
    AS 'select $1 + $2;'
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;</pre><p> Аналогичная функция, определённая в стиле, соответствующем стандарту SQL, с именами аргументов и без обрамляющих тело кавычек: </p><pre class="programlisting">CREATE FUNCTION add(a integer, b integer) RETURNS integer
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT
    RETURN a + b;</pre><p>Функция увеличения целого числа на 1, использующая именованный аргумент, на языке <span class="application">PL/pgSQL</span>: </p><pre class="programlisting">CREATE OR REPLACE FUNCTION increment(i integer) RETURNS integer AS $$
        BEGIN
                RETURN i + 1;
        END;
$$ LANGUAGE plpgsql;</pre><p>Функция, возвращающая запись с несколькими выходными параметрами: </p><pre class="programlisting">CREATE FUNCTION dup(in int, out f1 int, out f2 text)
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);</pre><p> То же самое можно сделать более развёрнуто, явно объявив составной тип: </p><pre class="programlisting">CREATE TYPE dup_result AS (f1 int, f2 text);

CREATE FUNCTION dup(int) RETURNS dup_result
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);</pre><p> Ещё один способ вернуть несколько столбцов — применить функцию <code class="literal">TABLE</code>: </p><pre class="programlisting">CREATE FUNCTION dup(int) RETURNS TABLE(f1 int, f2 text)
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);</pre><p> Однако пример с <code class="literal">TABLE</code> отличается от предыдущих, так как в нём функция на самом деле возвращает не одну, а <span class="emphasis"><em>набор</em></span> записей.</p></div><div class="refsect1" id="SQL-CREATEFUNCTION-SECURITY"><h2>Разработка защищённых функций <code class="literal">SECURITY DEFINER</code></h2><a id="id-1.9.3.67.10.2" class="indexterm"></a><a id="id-1.9.3.67.10.3" class="indexterm"></a><p>Так как функция <code class="literal">SECURITY DEFINER</code> выполняется с правами пользователя, владеющего ей, необходимо позаботиться о том, чтобы её нельзя было использовать не по назначению. В целях безопасности в пути <a class="xref" href="runtime-config-client.html#GUC-SEARCH-PATH">search_path</a> следует исключить любые схемы, доступные на запись недоверенным пользователям. Это не позволит злонамеренным пользователям создать свои объекты (например, таблицы, функции и операторы), которые замаскируют объекты, используемые функцией. Особенно важно в этом отношении исключить схему временных таблиц, которая по умолчанию просматривается первой, а право записи в неё по умолчанию имеют все. Соответствующую защиту можно организовать, поместив временную схему в конец списка поиска. Для этого следует сделать <code class="literal">pg_temp</code><a id="id-1.9.3.67.10.4.4" class="indexterm"></a> последней записью в <code class="varname">search_path</code>. Безопасное использование демонстрирует следующая функция: </p><pre class="programlisting">CREATE FUNCTION check_password(uname TEXT, pass TEXT)
RETURNS BOOLEAN AS $$
DECLARE passed BOOLEAN;
BEGIN
        SELECT  (pwd = $2) INTO passed
        FROM    pwds
        WHERE   username = $1;

        RETURN passed;
END;
$$  LANGUAGE plpgsql
    SECURITY DEFINER
    -- Установить безопасный путь поиска: сначала доверенная схема(ы), затем 'pg_temp'.
    SET search_path = admin, pg_temp;</pre><p> Эта функция должна обращаться к таблице <code class="literal">admin.pwds</code>, но без предложения <code class="literal">SET</code> или с предложением <code class="literal">SET</code>, включающим только <code class="literal">admin</code>, её можно «обмануть», создав временную таблицу <code class="literal">pwds</code>.</p><p>Если функция, определяющая контекст безопасности, должна создавать роли, и она вызывается не от имени суперпользователя, необходимо задать для параметра <code class="varname">createrole_self_grant</code> непустое значение, добавив предложение <code class="literal">SET</code>.</p><p>Также следует помнить о том, что по умолчанию право выполнения для создаваемых функций имеет роль <code class="literal">PUBLIC</code> (за подробностями обратитесь к <a class="xref" href="ddl-priv.html" title="5.7. Права">Разделу 5.7</a>). Однако часто требуется разрешить доступ к функциям, работающим в контексте определившего, только некоторым пользователям. Для этого необходимо отозвать стандартные права <code class="literal">PUBLIC</code> и затем дать права на выполнение индивидуально. Чтобы не образовалось окно, в котором новая функция будет доступна всем, создайте её и назначьте права в одной транзакции. Например, так:</p><pre class="programlisting">BEGIN;
CREATE FUNCTION check_password(uname TEXT, pass TEXT) ... SECURITY DEFINER;
REVOKE ALL ON FUNCTION check_password(uname TEXT, pass TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION check_password(uname TEXT, pass TEXT) TO admins;
COMMIT;</pre></div><div class="refsect1" id="SQL-CREATEFUNCTION-COMPAT"><h2>Совместимость</h2><p>Команда <code class="command">CREATE FUNCTION</code> определена в стандарте SQL. Её реализация в <span class="productname">PostgreSQL</span> может использоваться совместимым образом, но дополнена множеством расширений. И напротив, в стандарте SQL определён ряд дополнительных вещей, не реализованных в <span class="productname">PostgreSQL</span>.</p><p>Обратите внимание на важные замечания о совместимости: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Указание <code class="literal">OR REPLACE</code> является расширением PostgreSQL.</p></li><li class="listitem"><p>Для совместимости с другими СУБД <em class="replaceable"><code>режим_аргумента</code></em> можно записать после <em class="replaceable"><code>имя_аргумента</code></em> или перед ним, но стандарту соответствует только первый вариант.</p></li><li class="listitem"><p>Для определения значений по умолчанию для параметров стандарт SQL поддерживает только синтаксис с ключевым словом <code class="literal">DEFAULT</code>. Синтаксис со знаком <code class="literal">=</code> используется в T-SQL и Firebird.</p></li><li class="listitem"><p>Указание <code class="literal">SETOF</code> является расширением PostgreSQL.</p></li><li class="listitem"><p>В стандарте определён только один язык — <code class="literal">SQL</code>.</p></li><li class="listitem"><p>Все атрибуты, кроме <code class="literal">CALLED ON NULL INPUT</code> и <code class="literal">RETURNS NULL ON NULL INPUT</code>, относятся к расширением стандарта.</p></li><li class="listitem"><p>Тело функции в стиле <code class="literal">LANGUAGE SQL</code>, согласно стандарту SQL, может определяться только в форме, задающей <em class="replaceable"><code>тело_sql</code></em>.</p></li></ul></div><p>Простые функции в стиле <code class="literal">LANGUAGE SQL</code> можно определить так, чтобы их определение соответствовало стандарту и было совместимым с другими реализациями. Более сложные функции, использующие расширенные возможности, атрибуты оптимизации, или написанные на других языках, по понятным причинам должны определяться в специальном синтаксисе PostgreSQL.</p></div><div class="refsect1" id="id-1.9.3.67.12"><h2>См. также</h2><span class="simplelist"><a class="xref" href="sql-alterfunction.html" title="ALTER FUNCTION"><span class="refentrytitle">ALTER FUNCTION</span></a>, <a class="xref" href="sql-dropfunction.html" title="DROP FUNCTION"><span class="refentrytitle">DROP FUNCTION</span></a>, <a class="xref" href="sql-grant.html" title="GRANT"><span class="refentrytitle">GRANT</span></a>, <a class="xref" href="sql-load.html" title="LOAD"><span class="refentrytitle">LOAD</span></a>, <a class="xref" href="sql-revoke.html" title="REVOKE"><span class="refentrytitle">REVOKE</span></a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-createforeigntable.html" title="CREATE FOREIGN TABLE">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-creategroup.html" title="CREATE GROUP">След.</a></td></tr><tr><td width="40%" align="left" valign="top">CREATE FOREIGN TABLE </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> CREATE GROUP</td></tr></table></div></body></html>