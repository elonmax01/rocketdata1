<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>F.10. citext — тип данных для строк, нечувствительных к регистру</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="btree-gist.html" title="F.9. btree_gist — классы операторов GiST с поведением B-дерева" /><link rel="next" href="cube.html" title="F.11. cube — тип данных для представления многомерных кубов" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">F.10. citext — тип данных для строк, нечувствительных к регистру</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="btree-gist.html" title="F.9. btree_gist — классы операторов GiST с поведением B-дерева">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="contrib.html" title="Приложение F. Дополнительно поставляемые модули и расширения">Наверх</a></td><th width="60%" align="center">Приложение F. Дополнительно поставляемые модули и расширения</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="cube.html" title="F.11. cube — тип данных для представления многомерных кубов">След.</a></td></tr></table><hr /></div><div class="sect1" id="CITEXT"><div class="titlepage"><div><div><h2 class="title" style="clear: both">F.10. citext — тип данных для строк, нечувствительных к регистру <a href="#CITEXT" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="citext.html#CITEXT-RATIONALE">F.10.1. Обоснование</a></span></dt><dt><span class="sect2"><a href="citext.html#CITEXT-HOW-TO-USE-IT">F.10.2. Как его использовать</a></span></dt><dt><span class="sect2"><a href="citext.html#CITEXT-STRING-COMPARISON-BEHAVIOR">F.10.3. Поведение при сравнении строк</a></span></dt><dt><span class="sect2"><a href="citext.html#CITEXT-LIMITATIONS">F.10.4. Ограничения</a></span></dt><dt><span class="sect2"><a href="citext.html#CITEXT-AUTHOR">F.10.5. Автор</a></span></dt></dl></div><a id="id-1.11.7.20.2" class="indexterm"></a><p>Модуль <code class="filename">citext</code> предоставляет тип данных для строк, нечувствительных к регистру, <code class="type">citext</code>. По сути он сравнивает значения, вызывая внутри себя функцию <code class="function">lower</code>. В остальном он почти не отличается от типа <code class="type">text</code>.</p><div class="tip"><h3 class="title">Подсказка</h3><p>Вместо этого модуля имеет смысл использовать <em class="firstterm">недетерминированные правила сортировки</em> (см. <a class="xref" href="collation.html#COLLATION-NONDETERMINISTIC" title="24.2.2.4. Недетерминированные правила сортировки">Подраздел 24.2.2.4</a>). Они позволяют осуществлять сравнение без учёта регистра, без учёта ударения и другие варианты сравнений, при этом более корректно обрабатывая особые случаи Unicode.</p></div><p>Данный модуль считается <span class="quote">«<span class="quote">доверенным</span>»</span>, то есть его могут устанавливать обычные пользователи, имеющие право <code class="literal">CREATE</code> в текущей базе данных.</p><div class="sect2" id="CITEXT-RATIONALE"><div class="titlepage"><div><div><h3 class="title">F.10.1. Обоснование <a href="#CITEXT-RATIONALE" class="id_link">#</a></h3></div></div></div><p>Стандартный способ выполнить сравнение строк без учёта регистра в <span class="productname">PostgreSQL</span> заключается в использовании функции <code class="function">lower</code> при сравнении значений, например </p><pre class="programlisting">SELECT * FROM tab WHERE lower(col) = LOWER(?);</pre><p>Этот подход работает довольно хорошо, но имеет ряд недостатков:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Операторы SQL становятся громоздкими, и нужно не забывать всегда обрабатывать функцией <code class="function">lower</code> и столбец, и значение.</p></li><li class="listitem"><p>Индекс не будет использоваться, если только дополнительно не создать функциональный индекс с функцией <code class="function">lower</code>.</p></li><li class="listitem"><p>Если вы объявляете столбец как <code class="literal">UNIQUE</code> или <code class="literal">PRIMARY KEY</code>, неявно создаваемый индекс будет чувствительным к регистру. Поэтому он бесполезен для регистронезависимого поиска, так же как он не будет обеспечивать уникальность без учёта регистра.</p></li></ul></div><p>Тип данных <code class="type">citext</code> позволяет исключить вызовы <code class="function">lower</code> в SQL-запросах и позволяет сделать первичный ключ регистронезависимым. Тип <code class="type">citext</code> учитывает локаль, так же, как и тип <code class="type">text</code>, что означает, что сравнение символов в верхнем и нижнем регистре зависит от правил <code class="literal">LC_CTYPE</code> для базы данных. Это поведение, опять же, не отличается от вызовов <code class="function">lower</code> в запросах. Но так как оно реализуется прозрачно типом данных, в самих запросах дополнительно не нужно ничего делать.</p></div><div class="sect2" id="CITEXT-HOW-TO-USE-IT"><div class="titlepage"><div><div><h3 class="title">F.10.2. Как его использовать <a href="#CITEXT-HOW-TO-USE-IT" class="id_link">#</a></h3></div></div></div><p>Простой пример использования: </p><pre class="programlisting">CREATE TABLE users (
    nick CITEXT PRIMARY KEY,
    pass TEXT   NOT NULL
);

INSERT INTO users VALUES ( 'larry',  sha256(random()::text::bytea) );
INSERT INTO users VALUES ( 'Tom',    sha256(random()::text::bytea) );
INSERT INTO users VALUES ( 'Damian', sha256(random()::text::bytea) );
INSERT INTO users VALUES ( 'NEAL',   sha256(random()::text::bytea) );
INSERT INTO users VALUES ( 'Bjørn',  sha256(random()::text::bytea) );

SELECT * FROM users WHERE nick = 'Larry';</pre><p> Оператор <code class="command">SELECT</code> вернёт один кортеж, несмотря на то, что в столбец <code class="structfield">nick</code> записано значение <code class="literal">larry</code>, а в запросе фигурирует <code class="literal">Larry</code>.</p></div><div class="sect2" id="CITEXT-STRING-COMPARISON-BEHAVIOR"><div class="titlepage"><div><div><h3 class="title">F.10.3. Поведение при сравнении строк <a href="#CITEXT-STRING-COMPARISON-BEHAVIOR" class="id_link">#</a></h3></div></div></div><p>Модуль <code class="type">citext</code> выполняет сравнения, приводя каждую строку к нижнему регистру (как если бы вызывалась функция <code class="function">lower</code>) и затем производя сравнения как обычно. Так, например, две строки будут считаться равными, если функция <code class="function">lower</code>, обработав их, выдаст одинаковые результаты.</p><p>Чтобы имитировать правило сортировки без учёта регистра в максимально возможной степени, этот модуль предоставляет специальные, ориентированные на <code class="type">citext</code>, операторы и функции для обработки строки. Так, например, операторы регулярных выражений <code class="literal">~</code> и <code class="literal">~*</code> действуют в том же ключе, когда применяются к типу <code class="type">citext</code>: оба они не учитывают регистр. Это же распространяется на операторы <code class="literal">!~</code> и <code class="literal">!~*</code>, а также операторы <code class="literal">LIKE</code> <code class="literal">~~</code>, <code class="literal">~~*</code>, <code class="literal">!~~</code> и <code class="literal">!~~*</code>. Если же вы хотите, чтобы эти операторы учитывали регистр, вы можете привести их аргументы к типу <code class="type">text</code>.</p><p>Подобным образом, все следующие функции выполняют сопоставления без учёта регистра, если их аргументы имеют тип <code class="type">citext</code>:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
      <code class="function">regexp_match()</code>
    </p></li><li class="listitem"><p>
      <code class="function">regexp_matches()</code>
    </p></li><li class="listitem"><p>
      <code class="function">regexp_replace()</code>
    </p></li><li class="listitem"><p>
      <code class="function">regexp_split_to_array()</code>
    </p></li><li class="listitem"><p>
      <code class="function">regexp_split_to_table()</code>
    </p></li><li class="listitem"><p>
      <code class="function">replace()</code>
    </p></li><li class="listitem"><p>
      <code class="function">split_part()</code>
    </p></li><li class="listitem"><p>
      <code class="function">strpos()</code>
    </p></li><li class="listitem"><p>
      <code class="function">translate()</code>
    </p></li></ul></div><p>Для функций с регулярными выражениями, если вам нужно регистрозависимое сопоставление, вы можете добавить флаг <span class="quote">«<span class="quote">c</span>»</span>, чтобы принудительно включить этот режим. Чтобы получить регистрозависимое поведение без этого флага, вы должны привести аргумент к типу <code class="type">text</code>, прежде чем вызывать эту функцию.</p></div><div class="sect2" id="CITEXT-LIMITATIONS"><div class="titlepage"><div><div><h3 class="title">F.10.4. Ограничения <a href="#CITEXT-LIMITATIONS" class="id_link">#</a></h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Смена регистра символов в <code class="type">citext</code> зависит от параметра <code class="literal">LC_CTYPE</code> вашей базы данных. Таким образом, как будут сравниваться значения, определяется при создании базы данных. На самом деле, по определениям стандарта Unicode, это сравнение не будет истинно регистронезависимым. По сути это означает, что если вас устраивает установленное правило сортировки, вас должны устраивать и сравнения <code class="type">citext</code>. Но если в вашей базе данных хранятся строки на разных языках, пользователи одного языка могут получать неожиданные результаты запросов, если правило сортировки предназначено для другого языка.</p></li><li class="listitem"><p>Начиная с <span class="productname">PostgreSQL</span> версии 9.1, вы можете добавлять указание <code class="literal">COLLATE</code> к значениям данных или столбцам <code class="type">citext</code>. В настоящее время операторы <code class="type">citext</code> принимают во внимание такое явное указание <code class="literal">COLLATE</code>, сравнивая строки в нижнем регистре, но изначальное приведение в нижний регистр всегда выполняется согласно параметру <code class="literal">LC_CTYPE</code> базы данных (как если бы указывалось <code class="literal">COLLATE "default"</code>). Это может быть изменено в будущем, чтобы на обоих этапах учитывалось указание <code class="literal">COLLATE</code> во входных данных.</p></li><li class="listitem"><p>Тип <code class="type">citext</code> не так эффективен, как <code class="type">text</code>, так как функции операторов и функции сравнения для B-дерева должны делать копии данных и переводить их в нижний регистр для сравнения. Кроме того, с типом <code class="type">text</code> возможно исключение дубликатов в B-дереве. Тем не менее с <code class="type">citext</code> регистронезависимое сравнение реализуется эффективнее, чем с применением <code class="function">lower</code>.</p></li><li class="listitem"><p>Тип <code class="type">citext</code> малополезен в ситуациях, когда вам нужно сравнивать данные без учёта регистра в одних контекстах, и с учётом регистра — в других. Обычно в таких случаях используют <code class="type">text</code> и вручную применяют функцию <code class="function">lower</code>, когда нужно выполнить сравнение без учёта регистра; это прекрасно работает, если регистронезависимое сравнение требуется выполнять относительно редко. Если же почти всегда сравнение должно быть регистронезависимым и только иногда регистрозависимым, имеет смысл сохранить данные в столбце типа <code class="type">citext</code>, и явно приводить их к типу <code class="type">text</code> для регистрозависимого сравнения. В любом случае, чтобы оба варианта поиска были быстрыми, вам потребуются два индекса.</p></li><li class="listitem"><p>Схема, содержащая операторы <code class="type">citext</code>, должна находиться в текущем пути <code class="varname">search_path</code> (обычно это схема <code class="literal">public</code>); в противном случае будут вызываться регистрозависимые операторы для типа <code class="type">text</code>.</p></li><li class="listitem"><p>Подход с переводом строк в нижний регистр для сравнения не работает в некоторых особых случаях Unicode, например когда одной букве в верхнем регистре соответствуют две буквы в нижнем регистре. Поэтому в Unicode различаются понятия <em class="firstterm">преобразование регистра</em> (case mapping) и <em class="firstterm">выравнивание регистра</em> (case folding). Чтобы сравнение производилось корректно и в этих случаях, используйте вместо <code class="type">citext</code> недетерминированные правила сортировки.</p></li></ul></div></div><div class="sect2" id="CITEXT-AUTHOR"><div class="titlepage"><div><div><h3 class="title">F.10.5. Автор <a href="#CITEXT-AUTHOR" class="id_link">#</a></h3></div></div></div><p>Дэвид Е. Уилер <code class="email">&lt;<a class="email" href="mailto:david@kineticode.com">david@kineticode.com</a>&gt;</code></p><p>Разработку вдохновил оригинальный модуль <code class="type">citext</code> Дональда Фрейзера.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="btree-gist.html" title="F.9. btree_gist — классы операторов GiST с поведением B-дерева">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="contrib.html" title="Приложение F. Дополнительно поставляемые модули и расширения">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="cube.html" title="F.11. cube — тип данных для представления многомерных кубов">След.</a></td></tr><tr><td width="40%" align="left" valign="top">F.9. btree_gist — классы операторов GiST с поведением B-дерева </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> F.11. cube — тип данных для представления многомерных кубов</td></tr></table></div></body></html>