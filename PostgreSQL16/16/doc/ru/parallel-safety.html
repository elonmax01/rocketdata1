<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>15.4. Безопасность распараллеливания</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="parallel-plans.html" title="15.3. Параллельные планы" /><link rel="next" href="admin.html" title="Часть III. Администрирование сервера" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">15.4. Безопасность распараллеливания</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="parallel-plans.html" title="15.3. Параллельные планы">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="parallel-query.html" title="Глава 15. Параллельный запрос">Наверх</a></td><th width="60%" align="center">Глава 15. Параллельный запрос</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="admin.html" title="Часть III. Администрирование сервера">След.</a></td></tr></table><hr /></div><div class="sect1" id="PARALLEL-SAFETY"><div class="titlepage"><div><div><h2 class="title" style="clear: both">15.4. Безопасность распараллеливания <a href="#PARALLEL-SAFETY" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="parallel-safety.html#PARALLEL-LABELING">15.4.1. Пометки параллельности для функций и агрегатов</a></span></dt></dl></div><p>Планировщик классифицирует операции, вовлечённые в выполнение запроса, как либо <em class="firstterm">безопасные для распараллеливания</em>, либо <em class="firstterm">ограниченно распараллеливаемые</em>, либо <em class="firstterm">небезопасные для распараллеливания</em>. Безопасной для распараллеливания операцией считается такая, которая не мешает параллельному выполнению запроса. Ограниченно распараллеливаемой операцией считается такая, которая не может выполняться в параллельном рабочем процессе, но может выполняться в ведущем процессе, когда запрос выполняется параллельно. Таким образом, ограниченно параллельные операции никогда не могут оказаться ниже узла <code class="literal">Gather</code> или <code class="literal">Gather Merge</code>, но могут встречаться в других местах плана, содержащего такой узел. Небезопасные для распараллеливания операции не могут выполняться в параллельных запросах, даже в ведущем процессе. Когда запрос содержит что-либо небезопасное для распараллеливания, параллельное выполнение для такого запроса полностью исключается.</p><p>Ограниченно распараллеливаемыми всегда считаются следующие операции:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Сканирование общих табличных выражений (CTE).</p></li><li class="listitem"><p>Сканирование временных таблиц.</p></li><li class="listitem"><p>Сканирование сторонних таблиц, если только обёртка сторонних данных не предоставляет функцию <code class="literal">IsForeignScanParallelSafe</code>, которая допускает распараллеливание.</p></li><li class="listitem"><p>Узлы плана, к которым присоединён узел <code class="literal">InitPlan</code>.</p></li><li class="listitem"><p>Узлы плана, которые ссылаются на связанный <code class="literal">SubPlan</code>.</p></li></ul></div><div class="sect2" id="PARALLEL-LABELING"><div class="titlepage"><div><div><h3 class="title">15.4.1. Пометки параллельности для функций и агрегатов <a href="#PARALLEL-LABELING" class="id_link">#</a></h3></div></div></div><p>Планировщик не может автоматически определить, является ли пользовательская обычная или агрегатная функция безопасной для распараллеливания, так как это потребовало бы предсказания действия каждой операции, которую могла бы выполнять функция. В общем случае это равнозначно решению проблемы остановки, а значит, невозможно. Даже для простых функций, где это в принципе возможно, мы не пытаемся это делать, так как это будет слишком дорогой и потенциально неточной процедурой. Вместо этого, все определяемые пользователем функции полагаются небезопасными для распараллеливания, если явно не отмечено обратное. Когда используется <a class="xref" href="sql-createfunction.html" title="CREATE FUNCTION"><span class="refentrytitle">CREATE FUNCTION</span></a> или <a class="xref" href="sql-alterfunction.html" title="ALTER FUNCTION"><span class="refentrytitle">ALTER FUNCTION</span></a>, функции можно назначить отметку <code class="literal">PARALLEL SAFE</code>, <code class="literal">PARALLEL RESTRICTED</code> или <code class="literal">PARALLEL UNSAFE</code>, отражающую её характер. В команде <a class="xref" href="sql-createaggregate.html" title="CREATE AGGREGATE"><span class="refentrytitle">CREATE AGGREGATE</span></a> для параметра <code class="literal">PARALLEL</code> можно задать <code class="literal">SAFE</code>, <code class="literal">RESTRICTED</code> или <code class="literal">UNSAFE</code> в виде соответствующего значения.</p><p>Обычные и агрегатные функции должны помечаться небезопасными для распараллеливания (<code class="literal">PARALLEL UNSAFE</code>), если они пишут в базу данных, обращаются к последовательностям, изменяют состояние транзакции, даже временно (как, например, функция PL/pgSQL, устанавливающая блок <code class="literal">EXCEPTION</code> для перехвата ошибок), либо производят постоянные изменения параметров. Подобным образом, функции должны помечаться как ограниченно распараллеливаемые (<code class="literal">PARALLEL RESTRICTED</code>), если они обращаются к временным таблицам, состоянию клиентского подключения, курсорам, подготовленным операторам или разнообразному локальному состоянию обслуживающего процесса, которое система не может синхронизировать между рабочими процессами. Например, по этой причине ограниченно параллельными являются функции <code class="literal">setseed</code> и <code class="literal">random</code>.</p><p>В целом, если функция помечена как безопасная, когда на самом деле она небезопасна или ограниченно безопасна, или если она помечена как ограниченно безопасная, когда на самом деле она небезопасная, такая функция может выдавать ошибки или возвращать неправильные ответы при использовании в параллельном запросе. Функции на языке C могут теоретически проявлять полностью неопределённое появление при некорректной пометке, так как система никаким образом не может защитить себя от произвольного кода C, но чаще всего результат будет не хуже, чем с любой другой функцией. В случае сомнений, вероятно, лучше всего будет помечать функции как небезопасные (<code class="literal">UNSAFE</code>).</p><p>Если функция, выполняемая в параллельном рабочем процессе, затребует блокировки, которыми не владеет ведущий, например, обращаясь к таблице, не упомянутой в запросе, эти блокировки будут освобождены по завершении процесса, а не в конце транзакции. Если вы разрабатываете функцию с таким поведением, и эта особенность выполнения оказывается критичной, пометьте такую функцию как <code class="literal">PARALLEL RESTRICTED</code>, чтобы она выполнялась только в ведущем процессе.</p><p>Заметьте, что планировщик запросов не рассматривает возможность отложенного выполнения ограниченно распараллеливаемых обычных или агрегатных функций, задействованных в запросе, для получения лучшего плана. Поэтому, например, если предложение <code class="literal">WHERE</code>, применяемое к конкретной таблице, является ограниченно параллельным, планировщик запросов исключит возможность сканирования этой таблицы в параллельной части плана. В некоторых случаях возможно (и, вероятно, более эффективно) включить сканирование этой таблицы в параллельную часть запроса и отложить вычисление предложения <code class="literal">WHERE</code>, чтобы оно происходило над узлом <code class="literal">Gather</code>, но планировщик этого не делает.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="parallel-plans.html" title="15.3. Параллельные планы">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="parallel-query.html" title="Глава 15. Параллельный запрос">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="admin.html" title="Часть III. Администрирование сервера">След.</a></td></tr><tr><td width="40%" align="left" valign="top">15.3. Параллельные планы </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> Часть III. Администрирование сервера</td></tr></table></div></body></html>