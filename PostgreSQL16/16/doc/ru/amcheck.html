<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>F.2. amcheck — модуль с инструментами, проверяющими целостность таблиц и индексов</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="adminpack.html" title="F.1. adminpack — набор инструментов поддержки pgAdmin" /><link rel="next" href="auth-delay.html" title="F.3. auth_delay — задержка при ошибке аутентификации" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">F.2. amcheck — модуль с инструментами, проверяющими целостность таблиц и индексов</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="adminpack.html" title="F.1. adminpack — набор инструментов поддержки pgAdmin">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="contrib.html" title="Приложение F. Дополнительно поставляемые модули и расширения">Наверх</a></td><th width="60%" align="center">Приложение F. Дополнительно поставляемые модули и расширения</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="auth-delay.html" title="F.3. auth_delay — задержка при ошибке аутентификации">След.</a></td></tr></table><hr /></div><div class="sect1" id="AMCHECK"><div class="titlepage"><div><div><h2 class="title" style="clear: both">F.2. amcheck — модуль с инструментами, проверяющими целостность таблиц и индексов <a href="#AMCHECK" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="amcheck.html#AMCHECK-FUNCTIONS">F.2.1. Функции</a></span></dt><dt><span class="sect2"><a href="amcheck.html#AMCHECK-OPTIONAL-HEAPALLINDEXED-VERIFICATION">F.2.2. Дополнительная проверка <em class="parameter"><code>heapallindexed</code></em></a></span></dt><dt><span class="sect2"><a href="amcheck.html#AMCHECK-USING-AMCHECK-EFFECTIVELY">F.2.3. Эффективное использование <code class="filename">amcheck</code></a></span></dt><dt><span class="sect2"><a href="amcheck.html#AMCHECK-REPAIRING-CORRUPTION">F.2.4. Исправление повреждений</a></span></dt></dl></div><a id="id-1.11.7.12.2" class="indexterm"></a><p>Модуль <code class="filename">amcheck</code> предоставляет функции, позволяющие проверять логическую целостность структуры отношений.</p><p>Функции проверки B-дерева контролируют различные <span class="emphasis"><em>инварианты</em></span> в структуре представления определённых отношений. Правильность работы функций методов доступа, стоящих за сканированием индекса и другими важными операциями, зависит от всегда соблюдаемых инвариантов. Например, определённые функции проверяют, помимо остальных вещей, что все страницы B-дерева содержат элементы в <span class="quote">«<span class="quote">логическом</span>»</span> порядке (например, индекс-B-дерево, построенный по столбцу <code class="type">text</code>, должен содержать кортежи, упорядоченные в лексическом порядке с учётом правила сортировки). Если этот конкретный инвариант каким-то образом нарушается, следует ожидать, что бинарный поиск на затронутой странице введёт в заблуждение процедуру сканирования индекса, что приведёт к неверным результатам запросов SQL. Если нарушения структуры не обнаруживаются, эти функции отрабатывают без ошибок.</p><p>Проверка выполняется теми же процедурами, что используются при сканировании индекса, и это может быть код пользовательского класса операторов. Например, проверка индекса-B-дерева задействует сравнения, выполняемые одной или несколькими опорными функциями B-дерева под номером 1. Подробнее опорные функции класса операторов описываются в <a class="xref" href="xindex.html#XINDEX-SUPPORT" title="38.16.3. Опорные процедуры метода индекса">Подразделе 38.16.3</a>.</p><p>В отличие от функций проверки B-дерева, которые сообщают о повреждениях, выдавая ошибки, функция проверки кучи <code class="function">verify_heapam</code> проверяет таблицу и пытается вернуть набор строк: по одной строке на каждое обнаруженное повреждение. Тем не менее, если будут повреждены средства, которые использует функция <code class="function">verify_heapam</code>, она не сможет продолжить работу и выдаст ошибку.</p><p>Права на выполнение функций <code class="filename">amcheck</code> можно выдать и не суперпользователю, но перед этим следует тщательно учесть аспекты безопасности и конфиденциальности данных. Хотя эти функции прежде всего выдают информацию о структуре данных и характере найденных повреждений, а не выводят собственно повреждённые данные, если злоумышленник сможет выполнять эти функции, а особенно если ему также удастся вызвать повреждение данных, он сможет узнать что-то о самих данных из полученной информации.</p><div class="sect2" id="AMCHECK-FUNCTIONS"><div class="titlepage"><div><div><h3 class="title">F.2.1. Функции <a href="#AMCHECK-FUNCTIONS" class="id_link">#</a></h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">
     <code class="function">bt_index_check(index regclass, heapallindexed boolean) returns void</code>
     <a id="id-1.11.7.12.8.2.1.1.2" class="indexterm"></a>
    </span></dt><dd><p><code class="function">bt_index_check</code> проверяет, соблюдаются ли в целевом индексе-B-дереве различные инварианты. Пример использования: </p><pre class="screen">
test=# SELECT bt_index_check(index =&gt; c.oid, heapallindexed =&gt; i.indisunique),
               c.relname,
               c.relpages
FROM pg_index i
JOIN pg_opclass op ON i.indclass[0] = op.oid
JOIN pg_am am ON op.opcmethod = am.oid
JOIN pg_class c ON i.indexrelid = c.oid
JOIN pg_namespace n ON c.relnamespace = n.oid
WHERE am.amname = 'btree' AND n.nspname = 'pg_catalog'
-- Не проверять временные таблицы (они могут относиться к другим сеансам):
AND c.relpersistence != 't'
-- Функция может выдать ошибку без этих условий:
AND c.relkind = 'i' AND i.indisready AND i.indisvalid
ORDER BY c.relpages DESC LIMIT 10;
 bt_index_check |             relname             | relpages
----------------+---------------------------------+----------
                | pg_depend_reference_index       |       43
                | pg_depend_depender_index        |       40
                | pg_proc_proname_args_nsp_index  |       31
                | pg_description_o_c_o_index      |       21
                | pg_attribute_relid_attnam_index |       14
                | pg_proc_oid_index               |       10
                | pg_attribute_relid_attnum_index |        9
                | pg_amproc_fam_proc_index        |        5
                | pg_amop_opr_fam_index           |        5
                | pg_amop_fam_strat_index         |        5
(10 rows)
</pre><p> Этот пример демонстрирует сеанс проверки 10 самых больших индексов системных каталогов в базе данных <span class="quote">«<span class="quote">test</span>»</span>. Проверка всех кортежей кучи на предмет наличия соответствующих кортежей индекса запрашивается только для тех из этих индексов, которые являются уникальными. Так как ошибки не было, все проверенные индексы представляются логически целостными. Естественно, этот запрос можно легко изменить, чтобы функция <code class="function">bt_index_check</code> вызывалась для всех индексов в базе, которые поддерживают эту проверку.</p><p>Функция <code class="function">bt_index_check</code> запрашивает блокировку <code class="literal">AccessShareLock</code> для целевого индекса и отношения, которому он принадлежит. Это тот же режим блокировки, что запрашивается для отношений обычными операторами <code class="literal">SELECT</code>. <code class="function">bt_index_check</code> не проверяет инварианты, существующие в иерархии потомок/родитель, но проверяет представление всех кортежей кучи в индексе в виде индексных кортежей, когда параметр <em class="parameter"><code>heapallindexed</code></em> равен <code class="literal">true</code>. Когда в работающей производственной среде требуется регулярная лёгкая проверка на наличие нарушений, использование <code class="function">bt_index_check</code> часто будет подходящим компромиссом между полнотой проверки и минимизацией влияния на производительность и доступность приложения.</p></dd><dt><span class="term">
     <code class="function">bt_index_parent_check(index regclass, heapallindexed boolean, rootdescend boolean) returns void</code>
     <a id="id-1.11.7.12.8.2.2.1.2" class="indexterm"></a>
    </span></dt><dd><p>Функция <code class="function">bt_index_parent_check</code> проверяет, соблюдаются ли в целевом объекте, индексе-B-дереве, различные инварианты. Кроме того, если аргумент <em class="parameter"><code>heapallindexed</code></em> равен <code class="literal">true</code>, эта функция проверяет наличие в индексе всех кортежей из кучи, которые должны в него попасть. Когда необязательный параметр <em class="parameter"><code>rootdescend</code></em> равен <code class="literal">true</code>, при проверке для каждого кортежа на уровне листьев производится ещё один поиск, начиная с корневой страницы. Проверки, которые может производить <code class="function">bt_index_parent_check</code>, включают в себя все проверки, выполняемые функцией <code class="function">bt_index_check</code>. Функцию <code class="function">bt_index_parent_check</code> можно считать более полноценным вариантом <code class="function">bt_index_check</code>: в отличие от <code class="function">bt_index_check</code>, <code class="function">bt_index_parent_check</code> проверяет ещё и инварианты, существующие в иерархии родитель/потомок, в том числе отсутствие потерянных связей в структуре индекса. <code class="function">bt_index_parent_check</code> следует общему соглашению и выдаёт ошибку в случае обнаружения логической несогласованности или другой проблемы.</p><p>Функция <code class="function">bt_index_parent_check</code> запрашивает в целевом индексе блокировку <code class="literal">ShareLock</code> (также <code class="literal">ShareLock</code> запрашивается и в основном отношении). Эти блокировки предотвращают одновременное изменение данных командами <code class="command">INSERT</code>, <code class="command">UPDATE</code> и <code class="command">DELETE</code>. Эти блокировки также препятствуют одновременной обработке нижележащего отношения командой <code class="command">VACUUM</code> и другими вспомогательными командами. Заметьте, что эта функция удерживает блокировки только во время выполнения, а не на протяжении всей транзакции.</p><p>Дополнительные проверки, проводимые функцией <code class="function">bt_index_parent_check</code>, более ориентированы на выявление различных патологических случаев. В том числе это может быть неправильно реализованный класс операторов B-дерева, используемый проверяемым индексом, или, гипотетически, неизвестные ошибки в нижележащем коде метода доступа индекса-B-дерева. Заметьте, что функцию <code class="function">bt_index_parent_check</code> нельзя применять, когда включён режим горячего резерва (то есть на физических репликах в режиме «только чтение»), в отличие от <code class="function">bt_index_check</code>.</p></dd></dl></div><div class="tip"><h3 class="title">Подсказка</h3><p>Функции <code class="function">bt_index_check</code> и <code class="function">bt_index_parent_check</code> выводят отладочные сообщения о процессе проверки на уровнях важности <code class="literal">DEBUG1</code> и <code class="literal">DEBUG2</code>. Эти сообщения содержат подробные сведения о проверке, которые могут представлять интерес для разработчиков <span class="productname">PostgreSQL</span>. Они могут быть полезны и для опытных пользователей в качестве дополнительного контекста в случае обнаружения несогласованности. Чтобы получать сообщения о процессе проверки с подходящим уровнем детализации, выполните до запуска проверяющего запроса в интерактивном <span class="application">psql</span>: </p><pre class="programlisting">SET client_min_messages = DEBUG1;</pre></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">
     <code class="function">verify_heapam(relation regclass, on_error_stop boolean, check_toast boolean, skip text, startblock bigint, endblock bigint, blkno OUT bigint, offnum OUT integer, attnum OUT integer, msg OUT text) returns setof record</code>
    </span></dt><dd><p>Проверяет таблицу, последовательность или материализованное представление на наличие структурных повреждений (когда страницы отношения содержат данные в неправильном формате) и логических повреждений (когда структура страниц не повреждена, но и не соответствует остальной части кластера).</p><p>В качестве необязательных аргументов принимаются:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">on_error_stop</code></span></dt><dd><p>Если true, проверка на наличие повреждений останавливается в конце первого блока, в котором обнаружены какие-либо повреждения.</p><p>По умолчанию false.</p></dd><dt><span class="term"><code class="literal">check_toast</code></span></dt><dd><p>Если true, поля TOAST проверяются по TOAST-таблице целевого отношения.</p><p>Эта проверка может быть длительной. Кроме того, если TOAST-таблица или её индекс повреждены, проверка TOAST-полей потенциально может привести к сбою в работе сервера, хотя во многих случаях это просто вызовет ошибку.</p><p>По умолчанию false.</p></dd><dt><span class="term"><code class="literal">skip</code></span></dt><dd><p>Если указано значение, отличное от <code class="literal">none</code>, проверка на наличие повреждений пропускает блоки, которые помечены как полностью видимые или полностью замороженные, в зависимости от указанного значения. Допустимые варианты: <code class="literal">all-visible</code>, <code class="literal">all-frozen</code> и <code class="literal">none</code>.</p><p>По умолчанию <code class="literal">none</code>.</p></dd><dt><span class="term"><code class="literal">startblock</code></span></dt><dd><p>Если этот параметр задан, проверка на наличие повреждений начинается с указанного блока и пропускает все предыдущие блоки. Если в <em class="parameter"><code>startblock</code></em> указано значение вне диапазона блоков целевой таблицы, выдаётся ошибка.</p><p>По умолчанию проверка начинается с первого блока.</p></dd><dt><span class="term"><code class="literal">endblock</code></span></dt><dd><p>Если этот параметр задан, проверка на наличие повреждений заканчивается на указанном блоке и пропускает все оставшиеся блоки. Если в <em class="parameter"><code>endblock</code></em> указано значение вне диапазона блоков целевой таблицы, выдаётся ошибка.</p><p>По умолчанию проверяются все блоки.</p></dd></dl></div><p>Для каждого обнаруженного повреждения <code class="function">verify_heapam</code> возвращает строку со следующими столбцами:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">blkno</code></span></dt><dd><p>Номер блока, содержащего повреждённую страницу.</p></dd><dt><span class="term"><code class="literal">offnum</code></span></dt><dd><p>Номер смещения повреждённого кортежа.</p></dd><dt><span class="term"><code class="literal">attnum</code></span></dt><dd><p>Номер атрибута повреждённого столбца в кортеже, если повреждён именно столбец, а не весь кортеж.</p></dd><dt><span class="term"><code class="literal">msg</code></span></dt><dd><p>Сообщение с описанием выявленной ошибки.</p></dd></dl></div></dd></dl></div></div><div class="sect2" id="AMCHECK-OPTIONAL-HEAPALLINDEXED-VERIFICATION"><div class="titlepage"><div><div><h3 class="title">F.2.2. Дополнительная проверка <em class="parameter"><code>heapallindexed</code></em> <a href="#AMCHECK-OPTIONAL-HEAPALLINDEXED-VERIFICATION" class="id_link">#</a></h3></div></div></div><p>Когда аргумент <em class="parameter"><code>heapallindexed</code></em> функций проверки B-дерева равен <code class="literal">true</code>, для таблицы, связанной с отношением целевого индекса, добавляется дополнительная фаза проверки. Она включает <span class="quote">«<span class="quote">фиктивную</span>»</span> операцию <code class="command">CREATE INDEX</code>, которая проверяет присутствие всех гипотетических новых индексных кортежей по временной сводной структуре в памяти (она создаётся при необходимости на первом этапе проверки). Сводная структура <span class="quote">«<span class="quote">помечает</span>»</span> каждый кортеж, который находится в целевом индексе. На высоком уровне идея проверки <em class="parameter"><code>heapallindexed</code></em> состоит в том, чтобы убедиться, что новый индекс, равнозначный целевому, содержит только те записи, которые можно найти в существующей структуре.</p><p>С дополнительным этапом <em class="parameter"><code>heapallindexed</code></em> связаны значительные издержки: проверка обычно будет выполняться в несколько раз дольше. Однако никакие новые блокировки уровня отношения при проверке <em class="parameter"><code>heapallindexed</code></em> не запрашиваются.</p><p>Сводная структура ограничивается по объёму значением <code class="varname">maintenance_work_mem</code>. Для выявления несогласованности в представленных в индексе кортежах с вероятностью упущений в пределах 2% требуется приблизительно 2 байта памяти на кортеж. По мере уменьшения объёма памяти в пересчёте на кортеж этот процент медленно растёт. Этот подход значительно ограничивает издержки такой проверки, и при этом лишь немного уменьшается вероятность выявления проблемы, особенно в инсталляциях, где эта проверка включена в процедуру регулярного обслуживания. Даже если единичное отсутствие или повреждение кортежа упущено, есть все шансы выявить его при очередной проверке.</p></div><div class="sect2" id="AMCHECK-USING-AMCHECK-EFFECTIVELY"><div class="titlepage"><div><div><h3 class="title">F.2.3. Эффективное использование <code class="filename">amcheck</code> <a href="#AMCHECK-USING-AMCHECK-EFFECTIVELY" class="id_link">#</a></h3></div></div></div><p>Модуль <code class="filename">amcheck</code> может быть полезен для выявления различных типов проблем, которые могут остаться незамеченными при включении <a class="link" href="app-initdb.html#APP-INITDB-DATA-CHECKSUMS">контрольных сумм страниц данных</a>. В частности это: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Структурные несоответствия, возникающие при некорректной реализации класса операторов.</p><p>В том числе это проблемы, возникающие при изменении правил сравнения в операционной системе. Сравнения данных сортируемого типа, например <code class="type">text</code>, должны быть постоянными (как и все сравнения, применяемые при сканировании индекса-B-дерева), что подразумевает неизменность правил сортировки в операционной системе. Проблемы могут возникать при обновлениях правил в операционной системе, хотя такие случаи редки. Чаще проявляются несоответствия порядка сортировки между ведущим и ведомым сервером, например, из-за различий <span class="emphasis"><em>основных</em></span> версий используемых операционных систем. Возникающие расхождения обычно наблюдаются только на ведомых серверах, так что и выявить их обычно можно только на них.</p><p>Когда возникает подобная проблема, она может затрагивать не абсолютно все индексы, построенные с порочным правилом сортировки, просто потому что <span class="emphasis"><em>индексированные</em></span> значения могут иметь тот же абсолютный порядок, независящий от различий поведения. За дополнительными сведениями об использовании в <span class="productname">PostgreSQL</span> правил сортировки и локалей операционной системы обратитесь к <a class="xref" href="locale.html" title="24.1. Поддержка языковых стандартов">Разделу 24.1</a> и <a class="xref" href="collation.html" title="24.2. Поддержка правил сортировки">Разделу 24.2</a>.</p></li><li class="listitem"><p>Несоответствия структуры между индексами и проиндексированными отношениями в куче (когда выполняется проверка <em class="parameter"><code>heapallindexed</code></em>).</p><p>Во время обычных операций перекрёстная проверка индексов по отношениям в куче не производится. Симптомы повреждения данных в куче могут быть неочевидными.</p></li><li class="listitem"><p>Повреждения, вызванные гипотетическими неизвестными ошибками в нижележащем коде методов доступа, коде сортировки и управления транзакциями <span class="productname">PostgreSQL</span>.</p><p>Автоматическая проверка структурной целостности индексов играет важную роль в общем тестировании новых или предлагаемых возможностей <span class="productname">PostgreSQL</span>, с которыми может возникнуть логическая несогласованность. Такую же роль играет проверка структуры таблицы и связанной информации о видимости и состоянии транзакций. И поэтому одна из очевидных стратегий тестирования — регулярно вызывать функции <code class="filename">amcheck</code> при проведении стандартных регрессионных тестов. Подробнее о выполнении тестов можно узнать в <a class="xref" href="regress-run.html" title="33.1. Выполнение тестов">Разделе 33.1</a>.</p></li><li class="listitem"><p>Ошибки в файловой системе или подсистеме хранения, когда просто не включены контрольные суммы.</p><p>Заметьте, что <code class="filename">amcheck</code> рассматривает страницу в том виде, как она представлена в некотором буфере разделяемой памяти к моменту проверки, если при обращению к нужному блоку он уже находится в разделяемом буфере. Вследствие этого, <code class="filename">amcheck</code> не обязательно видит данные, находящиеся в файловой системе в момент проверки. Заметьте, что когда контрольные суммы включены, <code class="filename">amcheck</code> может выдать ошибку из-за несоответствия контрольных сумм, если в буфер будет считываться испорченный блок.</p></li><li class="listitem"><p>Повреждения, вызванные дефектными чипами ОЗУ или вообще подсистемой памяти.</p><p><span class="productname">PostgreSQL</span> не защищает от ошибок памяти; предполагается, что в эксплуатируемом вами сервере установлена память с ECC (Error Correcting Codes, Коды исправления ошибок) или лучшая защита. Однако память ECC обычно защищает только от ошибок в одном бите и не следует считать её <span class="emphasis"><em>абсолютной</em></span> защитой от сбоев, приводящих к повреждению памяти.</p><p>Когда выполняется проверка <em class="parameter"><code>heapallindexed</code></em>, в целом значительно увеличивается шанс выявления ошибок в отдельных битах, так как она тестирует точное двоичное равенство и сверяет проиндексированные атрибуты с кучей.</p></li></ul></div><p>Причиной повреждения структуры данных может стать неисправность оборудования или же перезапись или изменение файлов отношения сторонним ПО. Этот вид повреждения также можно обнаружить с помощью <a class="link" href="checksums.html" title="30.2. Контрольные суммы данных">контрольных сумм страниц данных</a>.</p><p>Даже если страницы отношений имеют правильный формат, их внутренняя структура не повреждена и данные соответствуют контрольной сумме, это не гарантирует отсутствие логических повреждений. Повреждения такого типа невозможно обнаружить с помощью контрольных сумм. Примеры: значения TOAST в основной таблице, для которых нет соответствующей записи в таблице TOAST; кортежи в основной таблице с идентификатором транзакции, который старше, чем самый старый действительный идентификатор транзакции в базе данных или кластере.</p><p>В производственных системах выявляются разнообразные причины логических повреждений: ошибки в серверном ПО <span class="productname">PostgreSQL</span>, неисправные и непродуманные инструменты резервного копирования и восстановления, ошибки пользователей.</p><p>Повреждение отношений особенно опасно в работающей производственной среде, то есть в той среде, где высокий риск совсем нежелателен. Поэтому для диагностики повреждения данных без излишнего риска была разработана функция <code class="function">verify_heapam</code>. Она не может обеспечить защиту от всех сбоев сервера, так как даже выполнение вызывающего запроса может быть небезопасным на сильно повреждённой системе. Если сами каталоги повреждены, то вероятны проблемы с доступом к <a class="link" href="catalogs-overview.html" title="53.1. Обзор">таблицам</a>.</p><p>Вообще говоря, <code class="filename">amcheck</code> может доказать только наличие повреждений, но не доказать их отсутствие.</p></div><div class="sect2" id="AMCHECK-REPAIRING-CORRUPTION"><div class="titlepage"><div><div><h3 class="title">F.2.4. Исправление повреждений <a href="#AMCHECK-REPAIRING-CORRUPTION" class="id_link">#</a></h3></div></div></div><p>Когда <code class="filename">amcheck</code> сигнализирует о повреждении данных, ложные срабатывания практически исключены. <code class="filename">amcheck</code> считает ошибочными ситуации, которые никогда не должны наблюдаться по определению, поэтому ошибки <code class="filename">amcheck</code>, как правило, требуют тщательного анализа.</p><p>Общего метода устранения проблем, которые может выявить <code class="filename">amcheck</code>, не существует. Начать нужно с поиска корня проблемы, приводящей к нарушению инварианта. Полезную роль в диагностике повреждений, которые выявляет <code class="filename">amcheck</code>, может сыграть <a class="xref" href="pageinspect.html" title="F.25. pageinspect — низкоуровневое исследование страниц баз данных">pageinspect</a>. Одна лишь команда <code class="command">REINDEX</code> может быть неэффективна, когда потребуется исправить повреждения.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="adminpack.html" title="F.1. adminpack — набор инструментов поддержки pgAdmin">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="contrib.html" title="Приложение F. Дополнительно поставляемые модули и расширения">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="auth-delay.html" title="F.3. auth_delay — задержка при ошибке аутентификации">След.</a></td></tr><tr><td width="40%" align="left" valign="top">F.1. adminpack — набор инструментов поддержки pgAdmin </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> F.3. auth_delay — задержка при ошибке аутентификации</td></tr></table></div></body></html>