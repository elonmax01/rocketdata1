<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>7.5. Сортировка строк (ORDER BY)</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="queries-union.html" title="7.4. Сочетание запросов (UNION, INTERSECT, EXCEPT)" /><link rel="next" href="queries-limit.html" title="7.6. LIMIT и OFFSET" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">7.5. Сортировка строк (<code class="literal">ORDER BY</code>)</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="queries-union.html" title="7.4. Сочетание запросов (UNION, INTERSECT, EXCEPT)">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="queries.html" title="Глава 7. Запросы">Наверх</a></td><th width="60%" align="center">Глава 7. Запросы</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="queries-limit.html" title="7.6. LIMIT и OFFSET">След.</a></td></tr></table><hr /></div><div class="sect1" id="QUERIES-ORDER"><div class="titlepage"><div><div><h2 class="title" style="clear: both">7.5. Сортировка строк (<code class="literal">ORDER BY</code>) <a href="#QUERIES-ORDER" class="id_link">#</a></h2></div></div></div><a id="id-1.5.6.9.2" class="indexterm"></a><a id="id-1.5.6.9.3" class="indexterm"></a><p>После того как запрос выдал таблицу результатов (после обработки списка выборки), её можно отсортировать. Если сортировка не задана, строки возвращаются в неопределённом порядке. Фактический порядок строк в этом случае будет зависеть от плана соединения и сканирования, а также от порядка данных на диске, поэтому полагаться на него нельзя. Определённый порядок выводимых строк гарантируется, только если этап сортировки задан явно.</p><p>Порядок сортировки определяет предложение <code class="literal">ORDER BY</code>: </p><pre class="synopsis">
SELECT <em class="replaceable"><code>список_выборки</code></em>
    FROM <em class="replaceable"><code>табличное_выражение</code></em>
    ORDER BY <em class="replaceable"><code>выражение_сортировки1</code></em> [<span class="optional">ASC | DESC</span>] [<span class="optional">NULLS { FIRST | LAST }</span>]
             [<span class="optional">, <em class="replaceable"><code>выражение_сортировки2</code></em> [<span class="optional">ASC | DESC</span>] [<span class="optional">NULLS { FIRST | LAST }</span>] ...</span>]
</pre><p> Выражениями сортировки могут быть любые выражения, допустимые в списке выборки запроса. Например: </p><pre class="programlisting">SELECT a, b FROM table1 ORDER BY a + b, c;</pre><p> Когда указывается несколько выражений, последующие значения позволяют отсортировать строки, в которых совпали все предыдущие значения. Каждое выражение можно дополнить ключевыми словами <code class="literal">ASC</code> или <code class="literal">DESC</code>, которые выбирают сортировку соответственно по возрастанию или убыванию. По умолчанию принят порядок по возрастанию (<code class="literal">ASC</code>). При сортировке по возрастанию сначала идут меньшие значения, где понятие <span class="quote">«<span class="quote">меньше</span>»</span> определяется оператором <code class="literal">&lt;</code>. Подобным образом, сортировка по возрастанию определяется оператором <code class="literal">&gt;</code>. <a href="#ftn.id-1.5.6.9.5.10" class="footnote"><sup class="footnote" id="id-1.5.6.9.5.10">[6]</sup></a></p><p>Для определения места значений NULL можно использовать указания <code class="literal">NULLS FIRST</code> и <code class="literal">NULLS LAST</code>, которые помещают значения NULL соответственно до или после значений не NULL. По умолчанию значения NULL считаются больше любых других, то есть подразумевается <code class="literal">NULLS FIRST</code> для порядка <code class="literal">DESC</code> и <code class="literal">NULLS LAST</code> в противном случае.</p><p>Заметьте, что порядки сортировки определяются независимо для каждого столбца. Например, <code class="literal">ORDER BY x, y DESC</code> означает <code class="literal">ORDER BY x ASC, y DESC</code>, и это не то же самое, что <code class="literal">ORDER BY x DESC, y DESC</code>.</p><p>Здесь <em class="replaceable"><code>выражение_сортировки</code></em> может быть меткой столбца или номером выводимого столбца, как в данном примере: </p><pre class="programlisting">SELECT a + b AS sum, c FROM table1 ORDER BY sum;
SELECT a, max(b) FROM table1 GROUP BY a ORDER BY 1;</pre><p>Оба эти запроса сортируют результат по первому столбцу. Заметьте, что имя выводимого столбца должно оставаться само по себе, его нельзя использовать в выражении. Например, это <span class="emphasis"><em>ошибка</em></span>: </p><pre class="programlisting">SELECT a + b AS sum, c FROM table1 ORDER BY sum + c;          -- неправильно</pre><p> Это ограничение позволяет уменьшить неоднозначность. Тем не менее неоднозначность возможна, когда в <code class="literal">ORDER BY</code> указано простое имя, но оно соответствует и имени выходного столбца, и столбцу из табличного выражения. В этом случае используется выходной столбец. Эта ситуация может возникнуть, только когда с помощью <code class="literal">AS</code> выходному столбцу назначается то же имя, что имеет столбец в другой таблице.</p><p><code class="literal">ORDER BY</code> можно применить к результату комбинации <code class="literal">UNION</code>, <code class="literal">INTERSECT</code> и <code class="literal">EXCEPT</code>, но в этом случае возможна сортировка только по номерам или именам столбцов, но не по выражениям.</p><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.id-1.5.6.9.5.10" class="footnote"><p><a href="#id-1.5.6.9.5.10" class="para"><sup class="para">[6] </sup></a>На деле <span class="productname">PostgreSQL</span> определяет порядок сортировки для <code class="literal">ASC</code> и <code class="literal">DESC</code> по <em class="firstterm">классу оператора B-дерева по умолчанию</em> для типа данных выражения. Обычно типы данных создаются так, что этому порядку соответствуют операторы <code class="literal">&lt;</code> и <code class="literal">&gt;</code>, но возможно разработать собственный тип данных, который будет вести себя по-другому.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="queries-union.html" title="7.4. Сочетание запросов (UNION, INTERSECT, EXCEPT)">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="queries.html" title="Глава 7. Запросы">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="queries-limit.html" title="7.6. LIMIT и OFFSET">След.</a></td></tr><tr><td width="40%" align="left" valign="top">7.4. Сочетание запросов (<code class="literal">UNION</code>, <code class="literal">INTERSECT</code>, <code class="literal">EXCEPT</code>) </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 7.6. <code class="literal">LIMIT</code> и <code class="literal">OFFSET</code></td></tr></table></div></body></html>