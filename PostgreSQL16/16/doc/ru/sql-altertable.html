<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>ALTER TABLE</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sql-altersystem.html" title="ALTER SYSTEM" /><link rel="next" href="sql-altertablespace.html" title="ALTER TABLESPACE" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">ALTER TABLE</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-altersystem.html" title="ALTER SYSTEM">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><th width="60%" align="center">Команды SQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-altertablespace.html" title="ALTER TABLESPACE">След.</a></td></tr></table><hr /></div><div class="refentry" id="SQL-ALTERTABLE"><div class="titlepage"></div><a id="id-1.9.3.35.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">ALTER TABLE</span></h2><p>ALTER TABLE — изменить определение таблицы</p></div><div class="refsynopsisdiv"><h2>Синтаксис</h2><pre class="synopsis">ALTER TABLE [ IF EXISTS ] [ ONLY ] <em class="replaceable"><code>имя</code></em> [ * ]
    <em class="replaceable"><code>действие</code></em> [, ... ]
ALTER TABLE [ IF EXISTS ] [ ONLY ] <em class="replaceable"><code>имя</code></em> [ * ]
    RENAME [ COLUMN ] <em class="replaceable"><code>имя_столбца</code></em> TO <em class="replaceable"><code>новое_имя_столбца</code></em>
ALTER TABLE [ IF EXISTS ] [ ONLY ] <em class="replaceable"><code>имя</code></em> [ * ]
    RENAME CONSTRAINT <em class="replaceable"><code>имя_ограничения</code></em> TO <em class="replaceable"><code>имя_нового_ограничения</code></em>
ALTER TABLE [ IF EXISTS ] <em class="replaceable"><code>имя</code></em>
    RENAME TO <em class="replaceable"><code>новое_имя</code></em>
ALTER TABLE [ IF EXISTS ] <em class="replaceable"><code>имя</code></em>
    SET SCHEMA <em class="replaceable"><code>новая_схема</code></em>
ALTER TABLE ALL IN TABLESPACE <em class="replaceable"><code>имя</code></em> [ OWNED BY <em class="replaceable"><code>имя_роли</code></em> [, ... ] ]
    SET TABLESPACE <em class="replaceable"><code>новое_табл_пространство</code></em> [ NOWAIT ]
ALTER TABLE [ IF EXISTS ] <em class="replaceable"><code>имя</code></em>
    ATTACH PARTITION <em class="replaceable"><code>имя_секции</code></em> { FOR VALUES <em class="replaceable"><code>указание_границ_секции</code></em> | DEFAULT }
ALTER TABLE [ IF EXISTS ] <em class="replaceable"><code>имя</code></em>
    DETACH PARTITION <em class="replaceable"><code>имя_секции</code></em> [ CONCURRENTLY | FINALIZE ]

<span class="phrase">Где <em class="replaceable"><code>действие</code></em> может быть следующим:</span>

    ADD [ COLUMN ] [ IF NOT EXISTS ] <em class="replaceable"><code>имя_столбца</code></em> <em class="replaceable"><code>тип_данных</code></em> [ COLLATE <em class="replaceable"><code>правило_сортировки</code></em> ] [ <em class="replaceable"><code>ограничение_столбца</code></em> [ ... ] ]
    DROP [ COLUMN ] [ IF EXISTS ] <em class="replaceable"><code>имя_столбца</code></em> [ RESTRICT | CASCADE ]
    ALTER [ COLUMN ] <em class="replaceable"><code>имя_столбца</code></em> [ SET DATA ] TYPE <em class="replaceable"><code>тип_данных</code></em> [ COLLATE <em class="replaceable"><code>правило_сортировки</code></em> ] [ USING <em class="replaceable"><code>выражение</code></em> ]
    ALTER [ COLUMN ] <em class="replaceable"><code>имя_столбца</code></em> SET DEFAULT <em class="replaceable"><code>выражение</code></em>
    ALTER [ COLUMN ] <em class="replaceable"><code>имя_столбца</code></em> DROP DEFAULT
    ALTER [ COLUMN ] <em class="replaceable"><code>имя_столбца</code></em> { SET | DROP } NOT NULL
    ALTER [ COLUMN ] <em class="replaceable"><code>имя_столбца</code></em> DROP EXPRESSION [ IF EXISTS ]
    ALTER [ COLUMN ] <em class="replaceable"><code>имя_столбца</code></em> ADD GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <em class="replaceable"><code>параметры_последовательности</code></em> ) ]
    ALTER [ COLUMN ] <em class="replaceable"><code>имя_столбца</code></em> { SET GENERATED { ALWAYS | BY DEFAULT } | SET <em class="replaceable"><code>параметр_последовательности</code></em> | RESTART [ [ WITH ] <em class="replaceable"><code>перезапуск</code></em> ] } [...]
    ALTER [ COLUMN ] <em class="replaceable"><code>имя_столбца</code></em> DROP IDENTITY [ IF EXISTS ]
    ALTER [ COLUMN ] <em class="replaceable"><code>имя_столбца</code></em> SET STATISTICS <em class="replaceable"><code>integer</code></em>
    ALTER [ COLUMN ] <em class="replaceable"><code>имя_столбца</code></em> SET ( <em class="replaceable"><code>атрибут</code></em> = <em class="replaceable"><code>значение</code></em> [, ... ] )
    ALTER [ COLUMN ] <em class="replaceable"><code>имя_столбца</code></em> RESET ( <em class="replaceable"><code>атрибут</code></em> [, ... ] )
    ALTER [ COLUMN ] <em class="replaceable"><code>имя_столбца</code></em> SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN | DEFAULT }
    ALTER [ COLUMN ] <em class="replaceable"><code>имя_столбца</code></em> SET COMPRESSION <em class="replaceable"><code>метод_сжатия</code></em>
    ADD <em class="replaceable"><code>ограничение_таблицы</code></em> [ NOT VALID ]
    ADD <em class="replaceable"><code>ограничение_таблицы_по_индексу</code></em>
    ALTER CONSTRAINT <em class="replaceable"><code>имя_ограничения</code></em> [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
    VALIDATE CONSTRAINT <em class="replaceable"><code>имя_ограничения</code></em>
    DROP CONSTRAINT [ IF EXISTS ]  <em class="replaceable"><code>имя_ограничения</code></em> [ RESTRICT | CASCADE ]
    DISABLE TRIGGER [ <em class="replaceable"><code>имя_триггера</code></em> | ALL | USER ]
    ENABLE TRIGGER [ <em class="replaceable"><code>имя_триггера</code></em> | ALL | USER ]
    ENABLE REPLICA TRIGGER <em class="replaceable"><code>имя_триггера</code></em>
    ENABLE ALWAYS TRIGGER <em class="replaceable"><code>имя_триггера</code></em>
    DISABLE RULE <em class="replaceable"><code>имя_правила_перезаписи</code></em>
    ENABLE RULE <em class="replaceable"><code>имя_правила_перезаписи</code></em>
    ENABLE REPLICA RULE <em class="replaceable"><code>имя_правила_перезаписи</code></em>
    ENABLE ALWAYS RULE <em class="replaceable"><code>имя_правила_перезаписи</code></em>
    DISABLE ROW LEVEL SECURITY
    ENABLE ROW LEVEL SECURITY
    FORCE ROW LEVEL SECURITY
    NO FORCE ROW LEVEL SECURITY
    CLUSTER ON <em class="replaceable"><code>имя_индекса</code></em>
    SET WITHOUT CLUSTER
    SET WITHOUT OIDS
    SET ACCESS METHOD <em class="replaceable"><code>новый_метод_доступа</code></em>
    SET TABLESPACE <em class="replaceable"><code>новое_табл_пространство</code></em>
    SET { LOGGED | UNLOGGED }
    SET ( <em class="replaceable"><code>параметр_хранения</code></em> [= <em class="replaceable"><code>значение</code></em>] [, ... ] )
    RESET ( <em class="replaceable"><code>параметр_хранения</code></em> [, ... ] )
    INHERIT <em class="replaceable"><code>таблица_родитель</code></em>
    NO INHERIT <em class="replaceable"><code>таблица_родитель</code></em>
    OF <em class="replaceable"><code>имя_типа</code></em>
    NOT OF
    OWNER TO { <em class="replaceable"><code>новый_владелец</code></em> | CURRENT_ROLE | CURRENT_USER | SESSION_USER }
    REPLICA IDENTITY { DEFAULT | USING INDEX <em class="replaceable"><code>имя_индекса</code></em> | FULL | NOTHING }

<span class="phrase">и <em class="replaceable"><code>указание_границ_секции</code></em>:</span>

IN ( <em class="replaceable"><code>выражение_границ_секции</code></em> [, ...] ) |
FROM ( { <em class="replaceable"><code>выражение_границ_секции</code></em> | MINVALUE | MAXVALUE } [, ...] )
  TO ( { <em class="replaceable"><code>выражение_границ_секции</code></em> | MINVALUE | MAXVALUE } [, ...] ) |
WITH ( MODULUS <em class="replaceable"><code>числовая_константа</code></em>, REMAINDER <em class="replaceable"><code>числовая_константа</code></em> )

<span class="phrase">и <em class="replaceable"><code>ограничение_столбца</code></em>:</span>

[ CONSTRAINT <em class="replaceable"><code>имя_ограничения</code></em> ]
{ NOT NULL |
  NULL |
  CHECK ( <em class="replaceable"><code>выражение</code></em> ) [ NO INHERIT ] |
  DEFAULT <em class="replaceable"><code>выражение_по_умолчанию</code></em> |
  GENERATED ALWAYS AS ( <em class="replaceable"><code>генерирующее_выражение</code></em> ) STORED |
  GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <em class="replaceable"><code>параметры_последовательности</code></em> ) ] |
  UNIQUE [ NULLS [ NOT ] DISTINCT ] <em class="replaceable"><code>параметры_индекса</code></em> |
  PRIMARY KEY <em class="replaceable"><code>параметры_индекса</code></em> |
  REFERENCES <em class="replaceable"><code>целевая_таблица</code></em> [ ( <em class="replaceable"><code>целевой_столбец</code></em> ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
    [ ON DELETE <em class="replaceable"><code>ссылочное_действие</code></em> ] [ ON UPDATE <em class="replaceable"><code>ссылочное_действие</code></em> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<span class="phrase">и <em class="replaceable"><code>ограничение_таблицы</code></em>:</span>

[ CONSTRAINT <em class="replaceable"><code>имя_ограничения</code></em> ]
{ CHECK ( <em class="replaceable"><code>выражение</code></em> ) [ NO INHERIT ] |
  UNIQUE [ NULLS [ NOT ] DISTINCT ] ( <em class="replaceable"><code>имя_столбца</code></em> [, ... ] ) <em class="replaceable"><code>параметры_индекса</code></em> |
  PRIMARY KEY ( <em class="replaceable"><code>имя_столбца</code></em> [, ... ] ) <em class="replaceable"><code>параметры_индекса</code></em> |
  EXCLUDE [ USING <em class="replaceable"><code>индексный_метод</code></em> ] ( <em class="replaceable"><code>элемент_исключения</code></em> WITH <em class="replaceable"><code>оператор</code></em> [, ... ] ) <em class="replaceable"><code>параметры_индекса</code></em> [ WHERE ( <em class="replaceable"><code>предикат</code></em> ) ] |
  FOREIGN KEY ( <em class="replaceable"><code>имя_столбца</code></em> [, ... ] ) REFERENCES <em class="replaceable"><code>целевая_таблица</code></em> [ ( <em class="replaceable"><code>целевой_столбец</code></em> [, ... ] ) ]
    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE <em class="replaceable"><code>ссылочное_действие</code></em> ] [ ON UPDATE <em class="replaceable"><code>ссылочное_действие</code></em> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<span class="phrase">и <em class="replaceable"><code>ограничение_таблицы_по_индексу</code></em>:</span>

    [ CONSTRAINT <em class="replaceable"><code>имя_ограничения</code></em> ]
    { UNIQUE | PRIMARY KEY } USING INDEX <em class="replaceable"><code>имя_индекса</code></em>
    [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<span class="phrase"><em class="replaceable"><code>параметры_индекса</code></em> в ограничениях <code class="literal">UNIQUE</code>, <code class="literal">PRIMARY KEY</code> и <code class="literal">EXCLUDE</code>:</span>

[ INCLUDE ( <em class="replaceable"><code>имя_столбца</code></em> [, ... ] ) ]
[ WITH ( <em class="replaceable"><code>параметр_хранения</code></em> [= <em class="replaceable"><code>значение</code></em>] [, ... ] ) ]
[ USING INDEX TABLESPACE <em class="replaceable"><code>табл_пространство</code></em> ]

<span class="phrase"><em class="replaceable"><code>элемент_исключения</code></em> в ограничении <code class="literal">EXCLUDE</code>:</span>

{ <em class="replaceable"><code>имя_столбца</code></em> | ( <em class="replaceable"><code>выражение</code></em> ) } [ COLLATE <em class="replaceable"><code>правило_сортировки</code></em> ] [ <em class="replaceable"><code>класс_операторов</code></em> [ ( <em class="replaceable"><code>параметр_класса_оп</code></em> = <em class="replaceable"><code>значение</code></em> [, ... ] ) ] ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]

<span class="phrase"><em class="replaceable"><code>ссылочное_действие</code></em> в ограничении <code class="literal">FOREIGN KEY</code>/<code class="literal">REFERENCES</code>:</span>

{ NO ACTION | RESTRICT | CASCADE | SET NULL [ ( <em class="replaceable"><code>имя_столбца</code></em> [, ... ] ) ] | SET DEFAULT [ ( <em class="replaceable"><code>имя_столбца</code></em> [, ... ] ) ] }</pre></div><div class="refsect1" id="id-1.9.3.35.5"><h2>Описание</h2><p><code class="command">ALTER TABLE</code> меняет определение существующей таблицы. Несколько её разновидностей описаны ниже. Заметьте, что для разных разновидностей могут требоваться разные уровни блокировок. Если явно не отмечено другое, запрашивается блокировка <code class="literal">ACCESS EXCLUSIVE</code>. При указании нескольких подкоманд будет запрашиваться самая сильная блокировка из требуемых ими. </p><div class="variablelist"><dl class="variablelist"><dt id="SQL-ALTERTABLE-DESC-ADD-COLUMN"><span class="term"><code class="literal">ADD COLUMN [ IF NOT EXISTS ]</code></span> <a href="#SQL-ALTERTABLE-DESC-ADD-COLUMN" class="id_link">#</a></dt><dd><p>Эта форма добавляет в таблицу новый столбец, с тем же синтаксисом, что и <a class="link" href="sql-createtable.html" title="CREATE TABLE"><code class="command">CREATE TABLE</code></a>. Если указано <code class="literal">IF NOT EXISTS</code> и столбец с таким именем уже существует, это не будет ошибкой.</p></dd><dt id="SQL-ALTERTABLE-DESC-DROP-COLUMN"><span class="term"><code class="literal">DROP COLUMN [ IF EXISTS ]</code></span> <a href="#SQL-ALTERTABLE-DESC-DROP-COLUMN" class="id_link">#</a></dt><dd><p>Эта форма удаляет столбец из таблицы. При этом автоматически будут удалены индексы и ограничения таблицы, связанные с этим столбцом. Также будет удалена многовариантная статистика, охватывающая удаляемый столбец, если после его удаления в статистике останутся данные только одного столбца. Если от этого столбца зависят какие либо объекты вне этой таблицы, например, внешние ключи или представления, чтобы удалить их, необходимо добавить указание <code class="literal">CASCADE</code>. Если в команде указано <code class="literal">IF EXISTS</code> и этот столбец не существует, это не считается ошибкой, вместо этого просто выдаётся замечание.</p></dd><dt id="SQL-ALTERTABLE-DESC-SET-DATA-TYPE"><span class="term"><code class="literal">SET DATA TYPE</code></span> <a href="#SQL-ALTERTABLE-DESC-SET-DATA-TYPE" class="id_link">#</a></dt><dd><p>Эта форма меняет тип столбца таблицы. Индексы и простые табличные ограничения, включающие этот столбец, будут автоматически преобразованы для использования нового типа столбца, для чего будет заново разобрано определяющее их выражение. Необязательное предложение <code class="literal">COLLATE</code> задаёт правило сортировки для нового столбца; если оно опущено, выбирается правило сортировки по умолчанию для нового типа. Необязательное предложение <code class="literal">USING</code> определяет, как новое значение столбца будет получено из старого; если оно отсутствует, выполняется приведение типа по умолчанию, как обычное присваивание значения старого типа новому. Предложение <code class="literal">USING</code> становится обязательным, если неявное приведение или присваивание с приведением старого типа к новому не определено.</p><p>При изменении типа столбца статистика столбца удаляется, поэтому после этой операции для таблицы рекомендуется выполнить <a class="link" href="sql-analyze.html" title="ANALYZE"><code class="command">ANALYZE</code></a>.</p></dd><dt id="SQL-ALTERTABLE-DESC-SET-DROP-DEFAULT"><span class="term"><code class="literal">SET</code>/<code class="literal">DROP DEFAULT</code></span> <a href="#SQL-ALTERTABLE-DESC-SET-DROP-DEFAULT" class="id_link">#</a></dt><dd><p>Эти формы задают или удаляют значение по умолчанию для столбца (удаление равносильно указанию NULL в качестве значения по умолчанию). Новые значения по умолчанию применяются только при последующих командах <code class="command">INSERT</code> или <code class="command">UPDATE</code>; их изменения не отражаются в строках, уже существующих в таблице.</p></dd><dt id="SQL-ALTERTABLE-DESC-SET-DROP-NOT-NULL"><span class="term"><code class="literal">SET</code>/<code class="literal">DROP NOT NULL</code></span> <a href="#SQL-ALTERTABLE-DESC-SET-DROP-NOT-NULL" class="id_link">#</a></dt><dd><p>Эти формы определяют, будет ли столбец принимать значения NULL или нет.</p><p>Указание <code class="literal">SET NOT NULL</code> можно применить к столбцу, только если ни одна из записей таблицы не содержит в этом столбце значение <code class="literal">NULL</code>. Обычно эта проверка производится в момент выполнения <code class="literal">ALTER TABLE</code> и требует сканирования всей таблицы; однако в случае наличия ограничений <code class="literal">CHECK</code>, гарантирующих отсутствие <code class="literal">NULL</code>, сканирование таблицы пропускается.</p><p>Если данная таблица является секцией, операцию <code class="literal">DROP NOT NULL</code> нельзя выполнить для столбца, если он определён с характеристикой <code class="literal">NOT NULL</code> в родительской таблице. Чтобы удалить ограничение <code class="literal">NOT NULL</code> из всех секций, выполните <code class="literal">DROP NOT NULL</code> для родительской таблицы. Даже если ограничение <code class="literal">NOT NULL</code> в родительской таблице отсутствует, при желании такое ограничение может быть добавлено в отдельные секции. Другими словами, потомки могут запрещать значения NULL, даже если родитель их допускает, но не наоборот.</p></dd><dt id="SQL-ALTERTABLE-DESC-DROP-EXPRESSION"><span class="term"><code class="literal">DROP EXPRESSION [ IF EXISTS ]</code></span> <a href="#SQL-ALTERTABLE-DESC-DROP-EXPRESSION" class="id_link">#</a></dt><dd><p>Эта форма преобразует хранимый генерируемый столбец в обычный. Существующие данные в столбцах сохраняются, но будущие изменения будут вноситься не генерирующим выражением.</p><p>Если указано <code class="literal">DROP EXPRESSION IF EXISTS</code> и заданный столбец не является хранимым генерируемым столбцом, это не считается ошибкой. В этом случае выдаётся только замечание.</p></dd><dt id="SQL-ALTERTABLE-DESC-GENERATED-IDENTITY"><span class="term"><code class="literal">ADD GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY</code><br /></span><span class="term"><code class="literal">SET GENERATED { ALWAYS | BY DEFAULT }</code><br /></span><span class="term"><code class="literal">DROP IDENTITY [ IF EXISTS ]</code></span> <a href="#SQL-ALTERTABLE-DESC-GENERATED-IDENTITY" class="id_link">#</a></dt><dd><p>Это формы меняют для столбца свойство идентификации или меняют характеристику генерирования для существующего столбца идентификации. За подробностями обратитесь к описанию <a class="link" href="sql-createtable.html" title="CREATE TABLE"><code class="command">CREATE TABLE</code></a>. Как и <code class="literal">SET DEFAULT</code>, эти формы влияют на поведение только последующих команд <code class="command">INSERT</code> и <code class="command">UPDATE</code>; их действие не отражаются в строках, уже существующих в таблице.</p><p>Если указано <code class="literal">DROP IDENTITY IF EXISTS</code> и заданный столбец не является столбцом идентификации, это не считается ошибкой. В этом случае выдаётся только замечание.</p></dd><dt id="SQL-ALTERTABLE-DESC-SET-SEQUENCE-OPTION"><span class="term"><code class="literal">SET <em class="replaceable"><code>параметр_последовательности</code></em></code><br /></span><span class="term"><code class="literal">RESTART</code></span> <a href="#SQL-ALTERTABLE-DESC-SET-SEQUENCE-OPTION" class="id_link">#</a></dt><dd><p>Эти формы меняют нижележащую последовательность ранее созданного столбца идентификации. Здесь <em class="replaceable"><code>параметр_последовательности</code></em> — это параметр, поддерживаемый командой <a class="link" href="sql-altersequence.html" title="ALTER SEQUENCE"><code class="command">ALTER SEQUENCE</code></a>, например <code class="literal">INCREMENT BY</code>.</p></dd><dt id="SQL-ALTERTABLE-DESC-SET-STATISTICS"><span class="term"><code class="literal">SET STATISTICS</code></span> <a href="#SQL-ALTERTABLE-DESC-SET-STATISTICS" class="id_link">#</a></dt><dd><p>Эта форма задаёт ориентир сбора статистики по столбцу для последующих операций <a class="link" href="sql-analyze.html" title="ANALYZE"><code class="command">ANALYZE</code></a>. Диапазон допустимых значений ориентира: 0..10000; при -1 применяется системное значение по умолчанию (<a class="xref" href="runtime-config-query.html#GUC-DEFAULT-STATISTICS-TARGET">default_statistics_target</a>). За дополнительными сведениями об использовании статистики планировщиком запросов <span class="productname">PostgreSQL</span> обратитесь к <a class="xref" href="planner-stats.html" title="14.2. Статистика, используемая планировщиком">Разделу 14.2</a>.</p><p><code class="literal">SET STATISTICS</code> запрашивает блокировку <code class="literal">SHARE UPDATE EXCLUSIVE</code>.</p></dd><dt id="SQL-ALTERTABLE-DESC-SET-ATTRIBUTE-OPTION"><span class="term"><code class="literal">SET ( <em class="replaceable"><code>атрибут</code></em> = <em class="replaceable"><code>значение</code></em> [, ... ] )</code><br /></span><span class="term"><code class="literal">RESET ( <em class="replaceable"><code>атрибут</code></em> [, ... ] )</code></span> <a href="#SQL-ALTERTABLE-DESC-SET-ATTRIBUTE-OPTION" class="id_link">#</a></dt><dd><p>Эта форма устанавливает или сбрасывает параметры атрибутов. В настоящее время единственными параметрами атрибутов являются <code class="literal">n_distinct</code> и <code class="literal">n_distinct_inherited</code>, которые переопределяют оценку кол-ва_различных_значений, производимую последующими операциями <a class="link" href="sql-analyze.html" title="ANALYZE"><code class="command">ANALYZE</code></a>. Атрибут <code class="literal">n_distinct</code> влияет на расчёт статистики по самой таблице, а <code class="literal">n_distinct_inherited</code> — на статистику по таблице и её потомкам. Если заданное значение положительно, <code class="command">ANALYZE</code> будет считать, что столбец содержит именно это количество различных значений не NULL. Если заданное значение отрицательно (оно должно быть больше или равно -1), <code class="command">ANALYZE</code> будет считать, что количество различных значений не NULL в столбце линейно зависит от размера таблицы; точное число будет получено умножением примерного размера таблицы на абсолютное значение параметра. Например, при -1 будет предполагаться, что различны все значения в столбце, а при -0,5 — что в среднем каждое значение повторяется дважды. Это может быть полезно, когда размер таблицы меняется со временем, так как умножение на число строк в таблице производится только во время планирования запроса. С 0 количество различных значений оценивается как обычно. За дополнительными сведениями об использовании статистики планировщиком запросов <span class="productname">PostgreSQL</span> обратитесь к <a class="xref" href="planner-stats.html" title="14.2. Статистика, используемая планировщиком">Разделу 14.2</a>.</p><p>Для изменения параметров атрибутов запрашивается блокировка <code class="literal">SHARE UPDATE EXCLUSIVE</code>.</p></dd><dt id="SQL-ALTERTABLE-DESC-SET-STORAGE"><span class="term">
     <code class="literal">SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN | DEFAULT }</code>
     <a id="id-1.9.3.35.5.2.3.11.1.2" class="indexterm"></a>
    </span> <a href="#SQL-ALTERTABLE-DESC-SET-STORAGE" class="id_link">#</a></dt><dd><p>Эта форма устанавливает режим хранения столбца. Она определяет, хранятся ли данные внутри таблицы или в отдельной таблице <acronym class="acronym">TOAST</acronym>, а также, сжимаются ли они. Режим <code class="literal">PLAIN</code> должен применяться для значений фиксированной длины, таких как <code class="type">integer</code>; это вариант хранения внутри, без сжатия. Режим <code class="literal">MAIN</code> применяется для хранения внутри, но сжатых данных, <code class="literal">EXTERNAL</code> — для внешнего хранения несжатых данных, а <code class="literal">EXTENDED</code> — для внешнего хранения сжатых данных. <code class="literal">EXTENDED</code> используется по умолчанию для большинства типов данных, поддерживающих хранилище не <code class="literal">PLAIN</code>. Применение <code class="literal">EXTERNAL</code> позволяет ускорить операции с подстроками на очень больших значениях <code class="type">text</code> и <code class="type">bytea</code>, за счёт проигрыша в объёме хранилища. Заметьте, что предложение <code class="literal">SET STORAGE</code> само по себе не меняет ничего в таблице, оно только задаёт стратегию, которая будет реализована при будущих изменениях в таблице. За дополнительными сведениями обратитесь к <a class="xref" href="storage-toast.html" title="73.2. TOAST">Разделу 73.2</a>.</p></dd><dt id="SQL-ALTERTABLE-DESC-SET-COMPRESSION"><span class="term">
     <code class="literal">SET COMPRESSION <em class="replaceable"><code>метод_сжатия</code></em></code>
    </span> <a href="#SQL-ALTERTABLE-DESC-SET-COMPRESSION" class="id_link">#</a></dt><dd><p>Эта форма задаёт метод сжатия для столбца, определяющий, как будут сжиматься значения, помещаемые в этот столбец в будущем (если режим хранения вообще допускает сжатие). При изменении этого метода перезапись таблицы не производится, поэтому уже существующие в таблице данные могут оставаться сжатыми другими методами. Если таблица восстанавливается средством <span class="application">pg_restore</span>, все значения перезаписываются с применением заданного метода сжатия. Если же данные вставляются из другого отношения (например, командой <code class="command">INSERT ... SELECT</code>), значения из исходной таблицы не обязательно будут распаковываться, так что ранее сжатые данные могут сохраниться с прежним методом сжатия, они не будут пережиматься методом, установленным для целевого столбца. Поддерживаемые методы сжатия: <code class="literal">pglz</code> и <code class="literal">lz4</code>. (<code class="literal">lz4</code> поддерживается, только если <span class="productname">PostgreSQL</span> был собран с ключом <code class="option">--with-lz4</code>.) Кроме того, <em class="replaceable"><code>метод_сжатия</code></em> может принимать значение <code class="literal">default</code>, с которым применяемый метод сжатия определяется текущим значением параметра <a class="xref" href="runtime-config-client.html#GUC-DEFAULT-TOAST-COMPRESSION">default_toast_compression</a> во время добавления данных.</p></dd><dt id="SQL-ALTERTABLE-DESC-ADD-TABLE-CONSTRAINT"><span class="term"><code class="literal">ADD <em class="replaceable"><code>ограничение_таблицы</code></em> [ NOT VALID ]</code></span> <a href="#SQL-ALTERTABLE-DESC-ADD-TABLE-CONSTRAINT" class="id_link">#</a></dt><dd><p>Эта форма добавляет в таблицу новое ограничение, принимая тот же синтаксис описания ограничения, что и <a class="link" href="sql-createtable.html" title="CREATE TABLE"><code class="command">CREATE TABLE</code></a>, а также дополнительное указание <code class="literal">NOT VALID</code>, которое в настоящее время поддерживается только для ограничений внешнего ключа и ограничений-проверок.</p><p>Обычно эта форма влечёт сканирование всей таблицы для проверки, что все существующие строки в таблице удовлетворяют новому ограничению. Но если используется указание <code class="literal">NOT VALID</code>, эта потенциально длительная проверка пропускается. Тем не менее это ограничение будет действовать при последующих добавлениях или изменениях данных (то есть эти операции не будут выполнены, если новая строка нарушит условие ограничения-проверки, либо при наличии внешнего ключа в главной таблице не найдётся соответствующая строка). Но база данных не будет считать, что ограничение выполняется для всех строк таблицы, пока оно не будет проверено с применением указания <code class="literal">VALIDATE CONSTRAINT</code>. Дополнительную информацию об использовании указания <code class="literal">NOT VALID</code> вы найдете ниже, в разделе <a class="xref" href="sql-altertable.html#SQL-ALTERTABLE-NOTES" title="Замечания">Замечания</a>.</p><p>Хотя почти все разновидности <code class="literal">ADD <em class="replaceable"><code>ограничение_таблицы</code></em></code> требуют блокировку <code class="literal">ACCESS EXCLUSIVE</code>, для указания <code class="literal">ADD FOREIGN KEY</code> требуется только блокировка <code class="literal">SHARE ROW EXCLUSIVE</code>. Заметьте, что <code class="literal">ADD FOREIGN KEY</code> запрашивает такую блокировку как в таблице, в которой добавляется это ограничение, так и в таблице, на которую это ограничение ссылается.</p><p>С ограничениями уникальности и первичного ключа, добавляемыми в секционированные таблицы, связаны дополнительные требования; см. описание <a class="link" href="sql-createtable.html" title="CREATE TABLE"><code class="command">CREATE TABLE</code></a>. Кроме того, в настоящее время ограничения внешнего ключа для секционированных таблиц не могут объявляться как непроверенные (<code class="literal">NOT VALID</code>).</p></dd><dt id="SQL-ALTERTABLE-DESC-ADD-TABLE-CONSTRAINT-USING-INDEX"><span class="term"><code class="literal">ADD <em class="replaceable"><code>ограничение_таблицы_по_индексу</code></em></code></span> <a href="#SQL-ALTERTABLE-DESC-ADD-TABLE-CONSTRAINT-USING-INDEX" class="id_link">#</a></dt><dd><p>Эта форма добавляет в таблицу новое ограничение <code class="literal">PRIMARY KEY</code> или <code class="literal">UNIQUE</code> на базе существующего уникального индекса. В это ограничение будут включены все столбцы данного индекса.</p><p>Индекс не может быть частичным и включать столбцы-выражения. Кроме того, это должен быть индекс-B-дерево с порядком сортировки по умолчанию. С такими ограничениями добавляемые индексы не будут ничем отличаться от индексов, создаваемых обычными командами <code class="literal">ADD PRIMARY KEY</code> и <code class="literal">ADD UNIQUE</code>.</p><p>В случае с указанием <code class="literal">PRIMARY KEY</code>, если столбцы индекса ещё не помечены <code class="literal">NOT NULL</code>, данная команда попытается выполнить <code class="literal">ALTER COLUMN SET NOT NULL</code> для каждого столбца. При этом потребуется произвести полное сканирование таблицы, чтобы убедиться, что столбец(ы) не содержит NULL. Во всех остальных случаях это быстрая операция.</p><p>Если задано имя ограничения, индекс будет переименован и получит заданное имя. В противном случае именем ограничения станет имя индекса.</p><p>После выполнения этой команды индекс становится <span class="quote">«<span class="quote">принадлежащим</span>»</span> ограничению, так же, как если бы он был создан обычной командой <code class="literal">ADD PRIMARY KEY</code> или <code class="literal">ADD UNIQUE</code>. Это значит, в частности, что при удалении ограничения индекс будет удалён вместе с ним.</p><p>Эта форма с секционированными таблицами в настоящее время не поддерживается.</p><div class="note"><h3 class="title">Примечание</h3><p>Добавление ограничения на базе существующего индекса бывает полезно в ситуациях, когда новое ограничение требуется добавить, не блокируя изменения в таблице на долгое время. Для этого можно создать индекс командой <code class="command">CREATE INDEX CONCURRENTLY</code>, а затем задействовать его как полноценное ограничение, используя эту запись. См. следующий пример.</p></div></dd><dt id="SQL-ALTERTABLE-DESC-ALTER-CONSTRAINT"><span class="term"><code class="literal">ALTER CONSTRAINT</code></span> <a href="#SQL-ALTERTABLE-DESC-ALTER-CONSTRAINT" class="id_link">#</a></dt><dd><p>Эта форма меняет атрибуты созданного ранее ограничения. В настоящее время изменять можно только ограничения внешнего ключа.</p></dd><dt id="SQL-ALTERTABLE-DESC-VALIDATE-CONSTRAINT"><span class="term"><code class="literal">VALIDATE CONSTRAINT</code></span> <a href="#SQL-ALTERTABLE-DESC-VALIDATE-CONSTRAINT" class="id_link">#</a></dt><dd><p>Эта форма проверяет ограничение внешнего ключа или ограничение-проверку, созданное ранее с указанием <code class="literal">NOT VALID</code>, сканируя всю таблицу с целью убедиться, что ограничению удовлетворяют все строки. Если ограничение уже помечено как проверенное, ничего не происходит. (В чём польза этой команды, вы можете узнать в разделе <a class="xref" href="sql-altertable.html#SQL-ALTERTABLE-NOTES" title="Замечания">Замечания</a>.)</p><p>Эта команда запрашивает блокировку <code class="literal">SHARE UPDATE EXCLUSIVE</code>.</p></dd><dt id="SQL-ALTERTABLE-DESC-DROP-CONSTRAINT"><span class="term"><code class="literal">DROP CONSTRAINT [ IF EXISTS ]</code></span> <a href="#SQL-ALTERTABLE-DESC-DROP-CONSTRAINT" class="id_link">#</a></dt><dd><p>Эта форма удаляет указанное ограничение таблицы, вместе с нижележащим индексом, если таковой имеется. Если указано <code class="literal">IF EXISTS</code> и заданное ограничение не существует, это не считается ошибкой. В этом случае выдаётся только замечание.</p></dd><dt id="SQL-ALTERTABLE-DESC-DISABLE-ENABLE-TRIGGER"><span class="term"><code class="literal">DISABLE</code>/<code class="literal">ENABLE [ REPLICA | ALWAYS ] TRIGGER</code></span> <a href="#SQL-ALTERTABLE-DESC-DISABLE-ENABLE-TRIGGER" class="id_link">#</a></dt><dd><p>Эти формы настраивают срабатывание триггера(ов), принадлежащего таблице. Отключённый триггер сохраняется в системе, но не выполняется, когда происходит вызывающее его событие. (Для отложенных триггеров состояние включения проверяется при возникновении события, а не когда фактически вызывается функция триггера.) Эта команда может отключить или включить один триггер по имени, либо все триггеры таблицы, либо только пользовательские триггеры (кроме сгенерированных внутрисистемных триггеров ограничений, например, триггеров, реализующих ограничения внешнего ключа или отложенные ограничения уникальности и ограничения-исключения). Для отключения или включения сгенерированных внутрисистемных триггеров ограничений требуются права суперпользователя; отключать их следует с осторожностью, так как очевидно, что невозможно гарантировать целостность ограничений, если триггеры не работают.</p><p>На механизм срабатывания триггеров также влияет конфигурационная переменная <a class="xref" href="runtime-config-client.html#GUC-SESSION-REPLICATION-ROLE">session_replication_role</a>. Включённые без дополнительных указаний (по умолчанию) триггеры будут срабатывать, когда роль репликации — <span class="quote">«<span class="quote">origin</span>»</span> (по умолчанию) или <span class="quote">«<span class="quote">local</span>»</span>. Триггеры, включённые указанием <code class="literal">ENABLE REPLICA</code>, будут срабатывать, только если текущий режим сеанса — <span class="quote">«<span class="quote">replica</span>»</span>, а триггеры, включённые указанием <code class="literal">ENABLE ALWAYS</code>, будут срабатывать независимо от текущего режима репликации.</p><p>Эффект этого механизма состоит в том, что в конфигурации по умолчанию триггеры не срабатывают в репликах. Это полезно, потому что если триггер используется в исходной базе для распределения данных по таблицам, система репликации будет реплицировать и распределённые таким образом данные, поэтому триггер не должен срабатывать в реплике второй раз, так как иначе будет иметь место дублирование. Однако если триггер используется для других целей, например, выдаёт уведомления, может иметь смысл установить для него свойство <code class="literal">ENABLE ALWAYS</code>, чтобы он также срабатывал в репликах.</p><p>Когда эта команда применяется к секционированной таблице, состояния соответствующих «клонированных» триггеров в секциях также изменяются, если не указано <code class="literal">ONLY</code>.</p><p>Эта команда запрашивает блокировку <code class="literal">SHARE ROW EXCLUSIVE</code>.</p></dd><dt id="SQL-ALTERTABLE-DESC-DISABLE-ENABLE-RULE"><span class="term"><code class="literal">DISABLE</code>/<code class="literal">ENABLE [ REPLICA | ALWAYS ] RULE</code></span> <a href="#SQL-ALTERTABLE-DESC-DISABLE-ENABLE-RULE" class="id_link">#</a></dt><dd><p>Эти формы настраивают срабатывание правил перезаписи, относящихся к таблице. Отключённое правило сохраняется в системе, но не применяется во время переписывания запроса. По сути эти операции подобны операциям включения/отключения триггеров. Однако это не распространяется на правила <code class="literal">ON SELECT</code> — они применяются всегда, чтобы представления продолжали работать, даже в сеансах, исполняющих не основную роль репликации.</p><p>На механизм срабатывания правил также оказывает влияние конфигурационная переменная <a class="xref" href="runtime-config-client.html#GUC-SESSION-REPLICATION-ROLE">session_replication_role</a>, подобное тому, что описано выше применительно к триггерам.</p></dd><dt id="SQL-ALTERTABLE-DESC-DISABLE-ENABLE-ROW-LEVEL-SECURITY"><span class="term"><code class="literal">DISABLE</code>/<code class="literal">ENABLE ROW LEVEL SECURITY</code></span> <a href="#SQL-ALTERTABLE-DESC-DISABLE-ENABLE-ROW-LEVEL-SECURITY" class="id_link">#</a></dt><dd><p>Эти формы управляют применением относящихся к таблице политик защиты строк. Если защита включается, но политики для таблицы не определены, применяется политика запрета доступа по умолчанию. Заметьте, что политики могут быть определены для таблицы, даже если защита на уровне строк отключена. В этом случае политики <span class="emphasis"><em>не</em></span> применяются и их ограничения игнорируются. См. также описание <a class="link" href="sql-createpolicy.html" title="CREATE POLICY"><code class="command">CREATE POLICY</code></a>.</p></dd><dt id="SQL-ALTERTABLE-DESC-FORCE-ROW-LEVEL-SECURITY"><span class="term"><code class="literal">NO FORCE</code>/<code class="literal">FORCE ROW LEVEL SECURITY</code></span> <a href="#SQL-ALTERTABLE-DESC-FORCE-ROW-LEVEL-SECURITY" class="id_link">#</a></dt><dd><p>Эти формы управляют применением относящихся к таблице политик защиты строк, когда пользователь является её владельцем. Если это поведение включается, политики защиты на уровне строк будут действовать и на владельца таблицы. Если оно отключено (по умолчанию), защита на уровне строк не будет действовать на пользователя, являющегося владельцем таблицы. См. также описание <a class="link" href="sql-createpolicy.html" title="CREATE POLICY"><code class="command">CREATE POLICY</code></a>.</p></dd><dt id="SQL-ALTERTABLE-DESC-CLUSTER-ON"><span class="term"><code class="literal">CLUSTER ON</code></span> <a href="#SQL-ALTERTABLE-DESC-CLUSTER-ON" class="id_link">#</a></dt><dd><p>Эта форма выбирает индекс по умолчанию для последующих операций <a class="link" href="sql-cluster.html" title="CLUSTER"><code class="command">CLUSTER</code></a>. Собственно кластеризация таблицы при этом не выполняется.</p><p>Для изменения параметров кластеризации запрашивается блокировка <code class="literal">SHARE UPDATE EXCLUSIVE</code>.</p></dd><dt id="SQL-ALTERTABLE-DESC-SET-WITHOUT-CLUSTER"><span class="term"><code class="literal">SET WITHOUT CLUSTER</code></span> <a href="#SQL-ALTERTABLE-DESC-SET-WITHOUT-CLUSTER" class="id_link">#</a></dt><dd><p>Эта форма удаляет последнее заданное указание индекса для <a class="link" href="sql-cluster.html" title="CLUSTER"><code class="command">CLUSTER</code></a>. Её действие отразится на будущих операциях кластеризации, для которых не будет задан индекс.</p><p>Для изменения параметров кластеризации запрашивается блокировка <code class="literal">SHARE UPDATE EXCLUSIVE</code>.</p></dd><dt id="SQL-ALTERTABLE-DESC-SET-WITHOUT-OIDS"><span class="term"><code class="literal">SET WITHOUT OIDS</code></span> <a href="#SQL-ALTERTABLE-DESC-SET-WITHOUT-OIDS" class="id_link">#</a></dt><dd><p>Обеспечивающий обратную совместимость синтаксис удаления системного столбца <code class="literal">oid</code>. Так как добавить системные столбцы <code class="literal">oid</code> теперь невозможно, это указание фактически не действует.</p></dd><dt id="SQL-ALTERTABLE-DESC-SET-ACCESS-METHOD"><span class="term"><code class="literal">SET ACCESS METHOD</code></span> <a href="#SQL-ALTERTABLE-DESC-SET-ACCESS-METHOD" class="id_link">#</a></dt><dd><p>Эта форма изменяет метод доступа к таблице, переписывая её. За подробным описанием обратитесь к <a class="xref" href="tableam.html" title="Глава 63. Определение интерфейса для табличных методов доступа">Главе 63</a>.</p></dd><dt id="SQL-ALTERTABLE-DESC-SET-TABLESPACE"><span class="term"><code class="literal">SET TABLESPACE</code></span> <a href="#SQL-ALTERTABLE-DESC-SET-TABLESPACE" class="id_link">#</a></dt><dd><p>Эта форма меняет табличное пространство таблицы на заданное и перемещает файлы данных, связанные с таблицей, в новое пространство. Индексы таблицы, если они имеются, не перемещаются; однако их можно переместить отдельно дополнительными командами <code class="literal">SET TABLESPACE</code>. В секционированной таблице при этом ничего не перемещается, но секции, созданные впоследствии с указанием <code class="command">CREATE TABLE PARTITION OF</code>, будут использовать это табличное пространство (если только оно не будет переопределено предложением <code class="literal">TABLESPACE</code>).</p><p>Форма <code class="literal">ALL IN TABLESPACE</code> позволяет перенести в другое табличное пространство все таблицы текущей базы данных в текущем пространстве, при этом она сначала блокирует все таблицы, а затем переносит каждую из них. Эта форма также поддерживает предложение <code class="literal">OWNED BY</code>, с которым перемещаются только таблицы указанных владельцев. C указанием <code class="literal">NOWAIT</code> команда завершается ошибкой, если не может получить все требуемые блокировки немедленно. Заметьте, что системные каталоги эта форма не перемещает; если требуется переместить их, следует использовать <code class="command">ALTER DATABASE</code> или явные вызовы <code class="command">ALTER TABLE</code>. Отношения <code class="literal">information_schema</code> не считаются частью системных каталогов и подлежат перемещению. См. также описание <a class="link" href="sql-createtablespace.html" title="CREATE TABLESPACE"><code class="command">CREATE TABLESPACE</code></a>.</p></dd><dt id="SQL-ALTERTABLE-DESC-SET-LOGGED-UNLOGGED"><span class="term"><code class="literal">SET { LOGGED | UNLOGGED }</code></span> <a href="#SQL-ALTERTABLE-DESC-SET-LOGGED-UNLOGGED" class="id_link">#</a></dt><dd><p>Эта форма меняет характеристику журналирования таблицы, делает таблицу журналируемой/нежурналируемой, соответственно (см. <a class="xref" href="sql-createtable.html#SQL-CREATETABLE-UNLOGGED"><code class="literal">UNLOGGED</code></a>). К временной таблице она неприменима.</p><p>При этом также меняется режим журналирования всех последовательностей, связанных с таблицей (с её столбцами идентификаторов или столбцами serial). Однако режим журналирования таких последовательностей можно изменить и отдельно.</p></dd><dt id="SQL-ALTERTABLE-DESC-SET-STORAGE-PARAMETER"><span class="term"><code class="literal">SET ( <em class="replaceable"><code>параметр_хранения</code></em> [= <em class="replaceable"><code>значение</code></em>] [, ... ] )</code></span> <a href="#SQL-ALTERTABLE-DESC-SET-STORAGE-PARAMETER" class="id_link">#</a></dt><dd><p>Эта форма меняет один или несколько параметров хранения таблицы. Подробнее допустимые параметры рассмотрены в разделе <a class="xref" href="sql-createtable.html#SQL-CREATETABLE-STORAGE-PARAMETERS" title="Параметры хранения">Параметры хранения</a> описания <a class="link" href="sql-createtable.html" title="CREATE TABLE"><code class="command">CREATE TABLE</code></a>. Заметьте, что эта команда не меняет содержимое таблицы немедленно; в зависимости от параметра может потребоваться перезаписать таблицы, чтобы получить желаемый эффект. Это можно сделать с помощью команд <a class="link" href="sql-vacuum.html" title="VACUUM"><code class="command">VACUUM FULL</code></a>, <a class="link" href="sql-cluster.html" title="CLUSTER"><code class="command">CLUSTER</code></a> или одной из форм <code class="command">ALTER TABLE</code>, принудительно перезаписывающих таблицу. Изменения параметров, связанных с планировщиком, вступают в силу при следующей блокировке таблицы, так что в текущих запросах они не проявляются.</p><p>Данная форма затребует блокировку <code class="literal">SHARE UPDATE EXCLUSIVE</code> для изменения параметров хранения, связанных с фактором заполнения, TOAST и автоочисткой, а также параметра планировщика <code class="varname">parallel_workers</code>.</p></dd><dt id="SQL-ALTERTABLE-DESC-RESET-STORAGE-PARAMETER"><span class="term"><code class="literal">RESET ( <em class="replaceable"><code>параметр_хранения</code></em> [, ... ] )</code></span> <a href="#SQL-ALTERTABLE-DESC-RESET-STORAGE-PARAMETER" class="id_link">#</a></dt><dd><p>Эта форма сбрасывает один или несколько параметров хранения к значениям по умолчанию. Как и с <code class="literal">SET</code>, для полного обновления таблицы может потребоваться перезаписать таблицу.</p></dd><dt id="SQL-ALTERTABLE-DESC-INHERIT"><span class="term"><code class="literal">INHERIT <em class="replaceable"><code>таблица_родитель</code></em></code></span> <a href="#SQL-ALTERTABLE-DESC-INHERIT" class="id_link">#</a></dt><dd><p>Эта форма назначает целевую таблицу потомком заданной родительской таблицы. Впоследствии запросы к родительской таблице будут включать записи и целевой таблицы. Чтобы таблица могла стать потомком, она должна содержать те же столбцы, что и родительская (хотя она может включать и дополнительные столбцы). Столбцы должны иметь одинаковые типы данных и, если в родительской таблице какие-то из них имеют ограничение <code class="literal">NOT NULL</code>, они должны иметь ограничение <code class="literal">NOT NULL</code> и в таблице-потомке.</p><p>Также в таблице-потомке должны присутствовать все ограничения <code class="literal">CHECK</code> родительской таблицы, за исключением ненаследуемых (то есть созданных командой <code class="literal">ALTER TABLE ... ADD CONSTRAINT ... NO INHERIT</code>), которые игнорируются; при этом все соответствующие ограничения в таблице-потомке не должны быть ненаследуемыми. В настоящее время ограничения <code class="literal">UNIQUE</code>, <code class="literal">PRIMARY KEY</code> и <code class="literal">FOREIGN KEY</code> не учитываются, но в будущем это может измениться.</p></dd><dt id="SQL-ALTERTABLE-DESC-NO-INHERIT"><span class="term"><code class="literal">NO INHERIT <em class="replaceable"><code>таблица_родитель</code></em></code></span> <a href="#SQL-ALTERTABLE-DESC-NO-INHERIT" class="id_link">#</a></dt><dd><p>Эта форма удаляет целевую таблицу из списка потомков указанной родительской таблицы. Результаты запросов к родительской таблице после этого не будут включать записи, взятые из целевой таблицы.</p></dd><dt id="SQL-ALTERTABLE-DESC-OF"><span class="term"><code class="literal">OF <em class="replaceable"><code>имя_типа</code></em></code></span> <a href="#SQL-ALTERTABLE-DESC-OF" class="id_link">#</a></dt><dd><p>Эта форма связывает таблицу с составным типом, как если бы она была сформирована командой <code class="command">CREATE TABLE OF</code>. При этом список имён и типов столбцов должен точно соответствовать тому, что образует составной тип. Кроме того, таблица не должна быть потомком какой-либо другой таблицы. Эти ограничения гарантируют, что команда <code class="command">CREATE TABLE OF</code> позволит создать таблицу с таким же определением.</p></dd><dt id="SQL-ALTERTABLE-DESC-NOT-OF"><span class="term"><code class="literal">NOT OF</code></span> <a href="#SQL-ALTERTABLE-DESC-NOT-OF" class="id_link">#</a></dt><dd><p>Эта форма разрывает связь типизированной таблицы с её типом.</p></dd><dt id="SQL-ALTERTABLE-DESC-OWNER-TO"><span class="term"><code class="literal">OWNER TO</code></span> <a href="#SQL-ALTERTABLE-DESC-OWNER-TO" class="id_link">#</a></dt><dd><p>Эта форма меняет владельца таблицы, последовательности, представления, материализованного представления или сторонней таблицы на заданного пользователя.</p></dd><dt id="SQL-ALTERTABLE-REPLICA-IDENTITY"><span class="term"><code class="literal">REPLICA IDENTITY</code></span> <a href="#SQL-ALTERTABLE-REPLICA-IDENTITY" class="id_link">#</a></dt><dd><p>Эта форма меняет информацию, записываемую в журнал предзаписи для идентификации изменяемых или удаляемых строк. В большинстве случаев старое значение в каждом столбце записывается, только если оно отличается от нового, но значение, хранящееся отдельно, записывается всегда, даже если оно не изменилось. Данный параметр действует только при использовании логической репликации. </p><div class="variablelist"><dl class="variablelist"><dt id="SQL-ALTERTABLE-REPLICA-IDENTITY-DEFAULT"><span class="term"><code class="literal">DEFAULT</code></span> <a href="#SQL-ALTERTABLE-REPLICA-IDENTITY-DEFAULT" class="id_link">#</a></dt><dd><p>Записываются старые значения столбцов первичного ключа, если он есть. Это режим по умолчанию для несистемных таблиц.</p></dd><dt id="SQL-ALTERTABLE-REPLICA-IDENTITY-USING-INDEX"><span class="term"><code class="literal">USING INDEX <em class="replaceable"><code>имя_индекса</code></em></code></span> <a href="#SQL-ALTERTABLE-REPLICA-IDENTITY-USING-INDEX" class="id_link">#</a></dt><dd><p>Записываются старые значения столбцов, составляющих заданный индекс, который должен быть уникальным, не частичным, не отложенным и включать только столбцы, помеченные <code class="literal">NOT NULL</code>. Если этот индекс удалён, поведение будет таким же, как в режиме <code class="literal">NOTHING</code>.</p></dd><dt id="SQL-ALTERTABLE-REPLICA-IDENTITY-FULL"><span class="term"><code class="literal">FULL</code></span> <a href="#SQL-ALTERTABLE-REPLICA-IDENTITY-FULL" class="id_link">#</a></dt><dd><p>Записываются старые значения всех столбцов в строке.</p></dd><dt id="SQL-ALTERTABLE-REPLICA-IDENTITY-NOTHING"><span class="term"><code class="literal">NOTHING</code></span> <a href="#SQL-ALTERTABLE-REPLICA-IDENTITY-NOTHING" class="id_link">#</a></dt><dd><p>Информация о старой строке не записывается. Это режим по умолчанию для системных таблиц.</p></dd></dl></div></dd><dt id="SQL-ALTERTABLE-DESC-RENAME"><span class="term"><code class="literal">RENAME</code></span> <a href="#SQL-ALTERTABLE-DESC-RENAME" class="id_link">#</a></dt><dd><p>Формы <code class="literal">RENAME</code> меняют имя таблицы (или индекса, последовательности, представления, материализованного представления или сторонней таблицы), имя отдельного столбца таблицы или имя ограничения таблицы. При переименовании ограничения, у которого имеется нижележащий индекс, этот индекс также переименовывается. На хранимые данные это не влияет.</p></dd><dt id="SQL-ALTERTABLE-DESC-SET-SCHEMA"><span class="term"><code class="literal">SET SCHEMA</code></span> <a href="#SQL-ALTERTABLE-DESC-SET-SCHEMA" class="id_link">#</a></dt><dd><p>Эта форма перемещает таблицу в другую схему. Вместе с таблицей перемещаются связанные с ней индексы и ограничения, а также последовательности, принадлежащие столбцам таблицы.</p></dd><dt id="SQL-ALTERTABLE-ATTACH-PARTITION"><span class="term"><code class="literal">ATTACH PARTITION <em class="replaceable"><code>имя_секции</code></em> { FOR VALUES <em class="replaceable"><code>указание_границ_секции</code></em> | DEFAULT }</code></span> <a href="#SQL-ALTERTABLE-ATTACH-PARTITION" class="id_link">#</a></dt><dd><p>Эта форма присоединяет существующую таблицу (которая тоже может быть секционированной) в качестве секции к целевой таблице. С указанием <code class="literal">FOR VALUES</code> таблица станет секцией для определённых значений, а с указанием <code class="literal">DEFAULT</code> — секцией по умолчанию. Для каждого индекса в целевой таблице будет создан соответствующий индекс в присоединяемой таблице; или, если равнозначный индекс уже существует, он будет присоединён к индексу целевой таблицы, как при выполнении команды <code class="command">ALTER INDEX ATTACH PARTITION</code>. Заметьте, что если существующая таблица является сторонней, в настоящее время её нельзя присоединить в качестве секции к целевой таблице, в которой имеются уникальные индексы (<code class="literal">UNIQUE</code>). (См. также <a class="xref" href="sql-createforeigntable.html" title="CREATE FOREIGN TABLE"><span class="refentrytitle">CREATE FOREIGN TABLE</span></a>.) Также для каждого существующего в целевой таблице пользовательского триггера уровня строк будет создан такой же триггер в присоединяемой таблице.</p><p>Для секции, добавляемой с <code class="literal">FOR VALUES</code>, используется то же <em class="replaceable"><code>указание_границ_секции</code></em>, что и в <a class="link" href="sql-createtable.html" title="CREATE TABLE"><code class="command">CREATE TABLE</code></a>. Это указание должно соответствовать стратегии секционирования и ключу разбиения целевой таблицы. Присоединяемая таблица должна иметь те же столбцы, что и целевая, и никаких других; более того, должны совпадать и типы столбцов. Кроме того, в ней должны быть те же ограничения <code class="literal">NOT NULL</code> и <code class="literal">CHECK</code>, что и в целевой таблице. Ограничения <code class="literal">FOREIGN KEY</code> в настоящее время не учитываются. Если какое-либо из ограничений <code class="literal">CHECK</code> присоединяемой таблицы помечено как <code class="literal">NO INHERIT</code>, команда выдаст ошибку; такие ограничения нужно будет пересоздать без предложения <code class="literal">NO INHERIT</code>.</p><p>Если новая секция является обычной таблицей, чтобы убедиться, что ни одна строка в таблице не нарушает ограничение секции, производится полное сканирование таблицы. Такого сканирования можно избежать, добавив перед выполнением этой команды в таблицу действующее ограничение <code class="literal">CHECK</code>, допускающее только такие строки, которые удовлетворяют задаваемому ограничению секции. Наличие этого ограничения позволит определить, что таблицу не нужно сканировать для проверки ограничения секции. Однако это не будет работать, если какие-либо ключи разбиения являются выражениями и секция не принимает значения <code class="literal">NULL</code>. При присоединении секции по списку, не принимающей значения <code class="literal">NULL</code>, также добавьте ограничение <code class="literal">NOT NULL</code> в столбец ключа разбиения, если это не выражение.</p><p>Если новая секция является сторонней таблицей, никакая проверка, удовлетворяют ли все строки сторонней таблицы ограничению секции, не выполняется. (Обсуждение ограничений сторонней таблицы вы можете найти в <a class="xref" href="sql-createforeigntable.html" title="CREATE FOREIGN TABLE"><span class="refentrytitle">CREATE FOREIGN TABLE</span></a>.)</p><p>Когда у таблицы есть секция по умолчанию, у данной секции при добавлении новой меняется ограничение секции. Секция по умолчанию не может содержать строки, которые должны быть перенесены в новую секцию, поэтому она будет просканирована и проверена на предмет их отсутствия. Этого сканирования, как и сканирования новой секции, можно избежать, если определить подходящее ограничение <code class="literal">CHECK</code>. Кроме того, сканирование этой секции, как и новой, всегда пропускается, когда данная секция является сторонней таблицей.</p><p>Для присоединения секции затребуется блокировка <code class="literal">SHARE UPDATE EXCLUSIVE</code> в родительской таблице, помимо блокировок <code class="literal">ACCESS EXCLUSIVE</code> в присоединяемых таблицах и секции по умолчанию (при наличии).</p><p>Подобные блокировки также должны устанавливаться во всех вложенных секциях, если присоединяемая таблица либо секция по умолчанию в свою очередь является секционированной таблицей. Блокировки вложенных секций можно избежать, добавив ограничение <code class="literal">CHECK</code>, как это описано в <a class="xref" href="ddl-partitioning.html#DDL-PARTITIONING-DECLARATIVE-MAINTENANCE" title="5.11.2.2. Обслуживание секций">Подразделе 5.11.2.2</a>.</p></dd><dt id="SQL-ALTERTABLE-DETACH-PARTITION"><span class="term"><code class="literal">DETACH PARTITION <em class="replaceable"><code>имя_секции</code></em> [ CONCURRENTLY | FINALIZE ]</code></span> <a href="#SQL-ALTERTABLE-DETACH-PARTITION" class="id_link">#</a></dt><dd><p>Эта форма отсоединяет заданную секцию от целевой таблицы. Отсоединяемая секция продолжит существовать как отдельная таблица, но более не будет иметь никаких связей с таблицей, от которой была отсоединена. Все индексы, которые были присоединены к индексам целевой таблицы, отсоединяются, а триггеры, созданные как копии существующих в целевой таблице, удаляются. Таблицы, ссылающиеся на секционированную таблицу через внешние ключи, блокируются в режиме <code class="literal">SHARE</code>.</p><p>С указанием <code class="literal">CONCURRENTLY</code> эта операция выполняется с пониженным уровнем блокировок во избежание блокирования других сеансов, которые могут обращаться к данной секционированной таблице. В этом режиме отсоединение производится в двух транзакциях. В первой транзакции в родительской таблице и заданной секции устанавливается блокировка <code class="literal">SHARE UPDATE EXCLUSIVE</code>, а секция помечается как отсоединяемая, после чего транзакция фиксируется; затем должны завершиться все остальные транзакции, использующие секционированную таблицу. Когда все они завершаются, вторая транзакция получает блокировку <code class="literal">SHARE UPDATE EXCLUSIVE</code> для секционированной таблицы и <code class="literal">ACCESS EXCLUSIVE</code> для отсоединяемой секции, после чего процесс отсоединения заканчивается. В секцию добавляется ограничение <code class="literal">CHECK</code>, повторяющее ограничение секции. Указание <code class="literal">CONCURRENTLY</code> нельзя использовать в блоке транзакции, а также оно не допускается, если секционированная таблица содержит секцию по умолчанию.</p><p>Указание <code class="literal">FINALIZE</code> позволяет завершить операцию <code class="literal">DETACH CONCURRENTLY</code>, прерванную или отменённую ранее. В один момент времени в состоянии отсоединения от некоторой секционированной таблицы может находиться не более одной секции.</p></dd></dl></div><p>Все виды ALTER TABLE, действующие на одну таблицу, кроме <code class="literal">RENAME</code>, <code class="literal">SET SCHEMA</code>, <code class="literal">ATTACH PARTITION</code> и <code class="literal">DETACH PARTITION</code> можно объединить в список множественных изменений и применить вместе. Например, можно добавить несколько столбцов и/или изменить тип столбцов в одной команде. Это особенно полезно для больших таблиц, так как вся таблица обрабатывается за один проход.</p><p>Выполнить <code class="command">ALTER TABLE</code> может только владелец соответствующей таблицы. Чтобы сменить схему или табличное пространство таблицы, необходимо также иметь право <code class="literal">CREATE</code> в новой схеме или табличном пространстве. Чтобы сделать таблицу потомком другой таблицы, нужно быть владельцем и родительской таблицы. Также, чтобы подсоединить таблицу к другой в качестве секции, необходимо быть владельцем подсоединяемой таблицы. Чтобы сменить владельца, необходимо иметь право <code class="literal">SET ROLE</code> для новой роли-владельца, а эта роль должна иметь право <code class="literal">CREATE</code> в схеме таблицы. (С такими ограничениями при смене владельца не происходит ничего такого, что нельзя было бы сделать, имея право удалить и вновь создать таблицу. Однако суперпользователь может сменить владельца таблицы в любом случае.) Чтобы добавить столбец, сменить тип столбца или применить предложение <code class="literal">OF</code>, необходимо также иметь право <code class="literal">USAGE</code> для соответствующего типа данных.</p></div><div class="refsect1" id="id-1.9.3.35.6"><h2>Параметры</h2><div class="variablelist"><dl class="variablelist"><dt id="SQL-ALTERTABLE-PARMS-IF-EXISTS"><span class="term"><code class="literal">IF EXISTS</code></span> <a href="#SQL-ALTERTABLE-PARMS-IF-EXISTS" class="id_link">#</a></dt><dd><p>Не считать ошибкой, если таблица не существует. В этом случае будет выдано замечание.</p></dd><dt id="SQL-ALTERTABLE-PARMS-NAME"><span class="term"><em class="replaceable"><code>имя</code></em></span> <a href="#SQL-ALTERTABLE-PARMS-NAME" class="id_link">#</a></dt><dd><p>Имя (возможно, дополненное схемой) существующей таблицы, подлежащей изменению. Если перед именем таблицы указано <code class="literal">ONLY</code>, изменяется только заданная таблица. Без <code class="literal">ONLY</code> изменяется и заданная таблица, и все её потомки (если таковые есть). После имени таблицы можно также добавить необязательное указание <code class="literal">*</code>, чтобы явно обозначить, что изменению подлежат все дочерние таблицы.</p></dd><dt id="SQL-ALTERTABLE-PARMS-COLUMN-NAME"><span class="term"><em class="replaceable"><code>имя_столбца</code></em></span> <a href="#SQL-ALTERTABLE-PARMS-COLUMN-NAME" class="id_link">#</a></dt><dd><p>Имя нового или существующего столбца.</p></dd><dt id="SQL-ALTERTABLE-PARMS-NEW-COLUMN-NAME"><span class="term"><em class="replaceable"><code>новое_имя_столбца</code></em></span> <a href="#SQL-ALTERTABLE-PARMS-NEW-COLUMN-NAME" class="id_link">#</a></dt><dd><p>Новое имя существующего столбца.</p></dd><dt id="SQL-ALTERTABLE-PARMS-NEW-NAME"><span class="term"><em class="replaceable"><code>новое_имя</code></em></span> <a href="#SQL-ALTERTABLE-PARMS-NEW-NAME" class="id_link">#</a></dt><dd><p>Новое имя таблицы.</p></dd><dt id="SQL-ALTERTABLE-PARMS-DATA-TYPE"><span class="term"><em class="replaceable"><code>тип_данных</code></em></span> <a href="#SQL-ALTERTABLE-PARMS-DATA-TYPE" class="id_link">#</a></dt><dd><p>Тип данных нового столбца или новый тип данных существующего столбца.</p></dd><dt id="SQL-ALTERTABLE-PARMS-TABLE-CONSTRAINT"><span class="term"><em class="replaceable"><code>ограничение_таблицы</code></em></span> <a href="#SQL-ALTERTABLE-PARMS-TABLE-CONSTRAINT" class="id_link">#</a></dt><dd><p>Новое ограничение таблицы.</p></dd><dt id="SQL-ALTERTABLE-PARMS-CONSTRAINT-NAME"><span class="term"><em class="replaceable"><code>имя_ограничения</code></em></span> <a href="#SQL-ALTERTABLE-PARMS-CONSTRAINT-NAME" class="id_link">#</a></dt><dd><p>Имя нового или существующего ограничения.</p></dd><dt id="SQL-ALTERTABLE-PARMS-CASCADE"><span class="term"><code class="literal">CASCADE</code></span> <a href="#SQL-ALTERTABLE-PARMS-CASCADE" class="id_link">#</a></dt><dd><p>Автоматически удалять объекты, зависящие от удаляемого столбца или ограничения (например, представления, содержащие этот столбец), и, в свою очередь, все зависящие от них объекты (см. <a class="xref" href="ddl-depend.html" title="5.14. Отслеживание зависимостей">Раздел 5.14</a>).</p></dd><dt id="SQL-ALTERTABLE-PARMS-RESTRICT"><span class="term"><code class="literal">RESTRICT</code></span> <a href="#SQL-ALTERTABLE-PARMS-RESTRICT" class="id_link">#</a></dt><dd><p>Отказать в удалении столбца или ограничения, если существуют зависящие от них объекты. Это поведение по умолчанию.</p></dd><dt id="SQL-ALTERTABLE-PARMS-TRIGGER-NAME"><span class="term"><em class="replaceable"><code>имя_триггера</code></em></span> <a href="#SQL-ALTERTABLE-PARMS-TRIGGER-NAME" class="id_link">#</a></dt><dd><p>Имя включаемого или отключаемого триггера.</p></dd><dt id="SQL-ALTERTABLE-PARMS-ALL"><span class="term"><code class="literal">ALL</code></span> <a href="#SQL-ALTERTABLE-PARMS-ALL" class="id_link">#</a></dt><dd><p>Отключить или включить все триггеры, принадлежащие таблице. (Для этого требуются права суперпользователя, если в числе этих триггеров оказываются сгенерированные внутрисистемные триггеры исключений, например те, что реализуют ограничения внешнего ключа или отложенные ограничения уникальности и исключений.)</p></dd><dt id="SQL-ALTERTABLE-PARMS-USER"><span class="term"><code class="literal">USER</code></span> <a href="#SQL-ALTERTABLE-PARMS-USER" class="id_link">#</a></dt><dd><p>Отключить или включить все триггеры, принадлежащие таблице, за исключением сгенерированных внутрисистемных триггеров исключений, например, тех, что реализуют ограничения внешнего ключа или отложенные ограничения уникальности и исключений.</p></dd><dt id="SQL-ALTERTABLE-PARMS-INDEX-NAME"><span class="term"><em class="replaceable"><code>имя_индекса</code></em></span> <a href="#SQL-ALTERTABLE-PARMS-INDEX-NAME" class="id_link">#</a></dt><dd><p>Имя существующего индекса.</p></dd><dt id="SQL-ALTERTABLE-PARMS-STORAGE-PARAMETER"><span class="term"><em class="replaceable"><code>параметр_хранения</code></em></span> <a href="#SQL-ALTERTABLE-PARMS-STORAGE-PARAMETER" class="id_link">#</a></dt><dd><p>Имя параметра хранения таблицы</p></dd><dt id="SQL-ALTERTABLE-PARMS-VALUE"><span class="term"><em class="replaceable"><code>значение</code></em></span> <a href="#SQL-ALTERTABLE-PARMS-VALUE" class="id_link">#</a></dt><dd><p>Новое значение параметра хранения таблицы. Это может быть число или строка, в зависимости от параметра.</p></dd><dt id="SQL-ALTERTABLE-PARMS-PARENT-TABLE"><span class="term"><em class="replaceable"><code>таблица_родитель</code></em></span> <a href="#SQL-ALTERTABLE-PARMS-PARENT-TABLE" class="id_link">#</a></dt><dd><p>Родительская таблица, с которой будет установлена или разорвана связь данной таблицы.</p></dd><dt id="SQL-ALTERTABLE-PARMS-NEW-OWNER"><span class="term"><em class="replaceable"><code>новый_владелец</code></em></span> <a href="#SQL-ALTERTABLE-PARMS-NEW-OWNER" class="id_link">#</a></dt><dd><p>Имя пользователя, назначаемого новым владельцем таблицы.</p></dd><dt id="SQL-ALTERTABLE-PARMS-NEW-ACCESS-METHOD"><span class="term"><em class="replaceable"><code>новый_метод_доступа</code></em></span> <a href="#SQL-ALTERTABLE-PARMS-NEW-ACCESS-METHOD" class="id_link">#</a></dt><dd><p>Имя метода доступа, который будет использоваться для таблицы после её преобразования.</p></dd><dt id="SQL-ALTERTABLE-PARMS-NEW-TABLESPACE"><span class="term"><em class="replaceable"><code>новое_табл_пространство</code></em></span> <a href="#SQL-ALTERTABLE-PARMS-NEW-TABLESPACE" class="id_link">#</a></dt><dd><p>Имя табличного пространства, в которое будет перемещена таблица.</p></dd><dt id="SQL-ALTERTABLE-PARMS-NEW-SCHEMA"><span class="term"><em class="replaceable"><code>новая_схема</code></em></span> <a href="#SQL-ALTERTABLE-PARMS-NEW-SCHEMA" class="id_link">#</a></dt><dd><p>Имя схемы, в которую будет перемещена таблица.</p></dd><dt id="SQL-ALTERTABLE-PARMS-PARTITION-NAME"><span class="term"><em class="replaceable"><code>имя_секции</code></em></span> <a href="#SQL-ALTERTABLE-PARMS-PARTITION-NAME" class="id_link">#</a></dt><dd><p>Имя таблицы, присоединяемой в качестве новой секции, или наоборот, отсоединяемой от данной таблицы.</p></dd><dt id="SQL-ALTERTABLE-PARMS-PARTITION-BOUND-SPEC"><span class="term"><em class="replaceable"><code>указание_границ_секции</code></em></span> <a href="#SQL-ALTERTABLE-PARMS-PARTITION-BOUND-SPEC" class="id_link">#</a></dt><dd><p>Указание границ для новой секции. Подробнее синтаксис этого указания рассматривается в описании <a class="xref" href="sql-createtable.html" title="CREATE TABLE"><span class="refentrytitle">CREATE TABLE</span></a>.</p></dd></dl></div></div><div class="refsect1" id="SQL-ALTERTABLE-NOTES"><h2>Замечания</h2><p>Ключевое слово <code class="literal">COLUMN</code> не несёт смысловой нагрузки и может быть опущено.</p><p>Когда конструкция <code class="literal">ADD COLUMN</code> добавляет столбец и для него задано неизменчивое выражение <code class="literal">DEFAULT</code>, значение по умолчанию вычисляется во время выполнения оператора и сохраняется в метаданных таблицы. Это значение затем будет использовано в качестве содержимого столбца для всех существующих строк. Если указание <code class="literal">DEFAULT</code> отсутствует, столбец будет содержать NULL. В обоих случаях перезапись таблицы не требуется.</p><p>Добавление столбца с изменчивым выражением <code class="literal">DEFAULT</code> или изменение типа существующего столбца влечёт за собой перезапись всей таблицы и её индексов. Но возможно исключение при смене типа существующего столбца: если предложение <code class="literal">USING</code> не меняет содержимое столбца и старый тип двоично приводится к новому или является неограниченным доменом поверх нового типа, то перезапись таблицы не требуется. Тем не менее, индексы нужно перестраивать в любом случае, кроме случаев, когда система может определить, что новый индекс будет логически эквивалентен существующему. Например, когда меняется правило сортировки для столбца, индекс требуется перестроить всегда, так как новый порядок сортировки может быть другим. Однако если правило сортировки не меняется, тип столбца можно поменять с <code class="type">text</code> на <code class="type">varchar</code> (или наоборот) без перестроения индексов, так как эти типы данных сортируются одинаково. Перестроение больших таблиц и/или их индексов может быть весьма длительной процедурой, которая при этом временно требует вдвое больше места на диске.</p><p>Добавление ограничений <code class="literal">CHECK</code> или <code class="literal">NOT NULL</code> влечёт за собой необходимость просканировать таблицу, чтобы проверить, что все существующие строки удовлетворяют ограничению, но перезаписывать таблицу при этом не требуется.</p><p>Подобным образом, при присоединении новой секции может производиться её сканирование для проверки, соответствуют ли существующие строки ограничению секции.</p><p>Возможность объединения множества изменений в одну команду <code class="command">ALTER TABLE</code> полезна в основном тем, что позволяет совместить сканирования и перезаписи таблицы, требуемые этим операциям, и выполнить их за один проход.</p><p>Сканирование большой таблицы для проверки нового внешнего ключа или ограничения-проверки может занять длительное время и будет препятствовать внесению других изменений до фиксирования команды <code class="command">ALTER TABLE ADD CONSTRAINT</code>. Основное предназначение указания <code class="literal">NOT VALID</code> при добавлении ограничения состоит в уменьшении влияния этой операции на параллельные изменения данных. С указанием <code class="literal">NOT VALID</code> команда <code class="command">ADD CONSTRAINT</code> не сканирует таблицу и может быть зафиксирована немедленно. После этого можно выполнить команду <code class="literal">VALIDATE CONSTRAINT</code>, которая проверит все существующие строки на соответствие ограничению. Эта команда не будет препятствовать параллельным изменениям, так как ей известно, что в других транзакциях для добавляемых или изменяемых строк ограничение уже будет действовать; проверить нужно только уже существующие строки. Таким образом, для этой проверки в таблице затребуется только блокировка <code class="literal">SHARE UPDATE EXCLUSIVE</code>. (Если ограничение является внешним ключом, то в целевой таблице этого ключа также затребуется блокировка <code class="literal">ROW SHARE</code>.) Помимо оптимизации параллельной работы, указание <code class="literal">NOT VALID</code> и предложение <code class="literal">VALIDATE CONSTRAINT</code> полезно в случаях, когда заведомо известно, что в таблице есть строки, нарушающие ограничения. После создания ограничения добавить новые недопустимые строки будет невозможно, а все существующие проблемы могут разрешаться в удобное время, пока <code class="literal">VALIDATE CONSTRAINT</code> не выполнится успешно.</p><p>Форма <code class="literal">DROP COLUMN</code> не удаляет столбец физически, а просто делает его невидимым для операций SQL. При последующих операциях добавления или изменения в этот столбец будет записываться значение NULL. Таким образом, удаление столбца выполняется быстро, но при этом размер таблицы на диске не уменьшается, так как пространство, занимаемое удалённым столбцом, не высвобождается. Это пространство будет освобождено со временем, по мере изменения существующих строк.</p><p>Чтобы принудительно высвободить пространство, занимаемое столбцом, который был удалён, можно выполнить одну из форм <code class="command">ALTER TABLE</code>, производящих перезапись всей таблицы. В результате все строки будут воссозданы так, что в удалённом столбце будет содержаться NULL.</p><p>Перезаписывающие формы <code class="command">ALTER TABLE</code> небезопасны с точки зрения MVCC. После перезаписи таблица будет выглядеть пустой для параллельных транзакций, если они работают со снимком, полученным до момента перезаписи. За подробностями обратитесь к <a class="xref" href="mvcc-caveats.html" title="13.6. Ограничения">Разделу 13.6</a>.</p><p>В указании <code class="literal">USING</code> предложения <code class="literal">SET DATA TYPE</code> на самом деле можно записать выражение со старыми значениями строки; то есть, оно может ссылаться как на преобразуемые столбцы, так и на другие. Это позволяет записывать в <code class="literal">SET DATA TYPE</code> очень общие преобразования данных. Ввиду такой гибкости, выражение <code class="literal">USING</code> не применяется к значению по умолчанию данного столбца (если таковое есть); результат может быть не константным выражением, что требуется для значения по умолчанию. Это означает, что в случае отсутствия явного приведения или присваивания старого типа новому, <code class="literal">SET DATA TYPE</code> может не справиться с преобразованием значения по умолчанию, несмотря на то, что применяется предложение <code class="literal">USING</code>. В этих случаях нужно удалить значение по умолчанию с помощью <code class="literal">DROP DEFAULT</code>, выполнить <code class="literal">ALTER TYPE</code>, а затем с помощью <code class="literal">SET DEFAULT</code> задать новое подходящее значение по умолчанию. Подобные соображения применимы и в отношении индексов и ограничений с этим столбцом.</p><p>Если у таблицы имеются дочерние таблицы, то добавлять, переименовывать столбцы или менять их тип в родительской таблице, не повторяя ту же операцию в дочерних таблицах, нельзя. Это правило гарантирует, что столбцы в дочерних таблицах всегда соответствуют родительской. Подобным образом, нельзя переименовать ограничение <code class="literal">CHECK</code> в родительской таблице, не переименовывая его во всех дочерних таблицах, что тоже гарантирует соответствие всех ограничений <code class="literal">CHECK</code>. (Однако это не касается ограничений, построенных на индексах.) И так как выборка из родительской таблицы влечёт за собой выборку из всех потомков, ограничение родителя не может быть помечено как действующее, если оно также не является действующим в потомках. Во всех этих случаях команда <code class="command">ALTER TABLE ONLY</code> не будет выполнена.</p><p>Рекурсивная операция <code class="literal">DROP COLUMN</code> удалит столбец из дочерней таблицы, только если этот столбец не наследуется от каких-то других родителей и никогда не был определён в дочерней таблице независимо. Нерекурсивная операция <code class="literal">DROP COLUMN</code> (т. е., <code class="command">ALTER TABLE ONLY ... DROP COLUMN</code>) никогда не удаляет унаследованные столбцы; вместо этого она помечает их как независимо определённые, а не наследуемые. С секционированной таблицей нерекурсивная команда <code class="literal">DROP COLUMN</code> выдаст ошибку, так как все секции таблицы должны содержать те же столбцы, что и главная таблица.</p><p>Действия для столбцов идентификации (<code class="literal">ADD GENERATED</code>, <code class="literal">SET</code> и т. д., <code class="literal">DROP IDENTITY</code>), а также действия <code class="literal">CLUSTER</code>, <code class="literal">OWNER</code> и <code class="literal">TABLESPACE</code>, никогда не распространяются рекурсивно на дочерние таблицы; то есть они всегда выполняются так, как будто указано <code class="literal">ONLY</code>. Действия, влияющие на состояния триггеров, распространяются рекурсивно на секции секционированных таблиц (если не указано <code class="literal">ONLY</code>), но не на потомков в традиционной иерархии наследования. Операция добавления ограничения выполняется рекурсивно только для ограничений <code class="literal">CHECK</code>, не помеченных как <code class="literal">NO INHERIT</code>.</p><p>Какие-либо изменения таблиц системного каталога не допускаются.</p><p>За более подробным описанием допустимых параметров обратитесь к <a class="xref" href="sql-createtable.html" title="CREATE TABLE"><span class="refentrytitle">CREATE TABLE</span></a>. Дополнительно о наследовании можно узнать в <a class="xref" href="ddl.html" title="Глава 5. Определение данных">Главе 5</a>.</p></div><div class="refsect1" id="id-1.9.3.35.8"><h2>Примеры</h2><p>Добавление в таблицу столбца типа <code class="type">varchar</code>: </p><pre class="programlisting">ALTER TABLE distributors ADD COLUMN address varchar(30);</pre><p> При этом во всех существующих строках таблицы новый столбец получит значение null.</p><p>Добавление столбца со значением по умолчанию (отличным от NULL): </p><pre class="programlisting">ALTER TABLE measurements
  ADD COLUMN mtime timestamp with time zone DEFAULT now();</pre><p> В существующих строках новый столбец будет содержать текущее время, а в добавляемых впоследствии строках — время их добавления.</p><p>Добавление столбца и заполнение его значением, отличным от значения по умолчанию, которое будет использоваться в дальнейшем: </p><pre class="programlisting">ALTER TABLE transactions
  ADD COLUMN status varchar(30) DEFAULT 'old',
  ALTER COLUMN status SET default 'current';</pre><p> Существующие строки будут заполнены значением <code class="literal">old</code>, но для последующих команд значением по умолчанию будет <code class="literal">current</code>. Результат этих двух указаний в одной команде будет таким же, как и при выполнении их в отдельных командах <code class="command">ALTER TABLE</code>.</p><p>Удаление столбца из таблицы: </p><pre class="programlisting">ALTER TABLE distributors DROP COLUMN address RESTRICT;</pre><p>Изменение типов двух существующих столбцов в одной операции: </p><pre class="programlisting">ALTER TABLE distributors
    ALTER COLUMN address TYPE varchar(80),
    ALTER COLUMN name TYPE varchar(100);</pre><p>Смена типа целочисленного столбца, содержащего время в стиле Unix, на тип <code class="type">timestamp with time zone</code> с применением предложения <code class="literal">USING</code>: </p><pre class="programlisting">ALTER TABLE foo
    ALTER COLUMN foo_timestamp SET DATA TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second';</pre><p>То же самое, но в случае, когда у столбца есть значение по умолчанию, не приводимое автоматически к новому типу данных: </p><pre class="programlisting">ALTER TABLE foo
    ALTER COLUMN foo_timestamp DROP DEFAULT,
    ALTER COLUMN foo_timestamp TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second',
    ALTER COLUMN foo_timestamp SET DEFAULT now();</pre><p>Переименование существующего столбца: </p><pre class="programlisting">ALTER TABLE distributors RENAME COLUMN address TO city;</pre><p>Переименование существующей таблицы: </p><pre class="programlisting">ALTER TABLE distributors RENAME TO suppliers;</pre><p>Переименование существующего ограничения: </p><pre class="programlisting">ALTER TABLE distributors RENAME CONSTRAINT zipchk TO zip_check;</pre><p>Добавление в столбец ограничения NOT NULL: </p><pre class="programlisting">ALTER TABLE distributors ALTER COLUMN street SET NOT NULL;</pre><p> Удаление ограничения NOT NULL из столбца: </p><pre class="programlisting">ALTER TABLE distributors ALTER COLUMN street DROP NOT NULL;</pre><p>Добавление ограничения-проверки в таблицу и все её потомки: </p><pre class="programlisting">ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5);</pre><p>Добавление ограничения-проверки только в таблицу, но не в её потомки: </p><pre class="programlisting">ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5) NO INHERIT;</pre><p> (Данное ограничение-проверка не будет наследоваться и будущими потомками тоже.)</p><p>Удаление ограничения-проверки из таблицы и из всех её потомков: </p><pre class="programlisting">ALTER TABLE distributors DROP CONSTRAINT zipchk;</pre><p>Удаление ограничения-проверки только из самой таблицы: </p><pre class="programlisting">ALTER TABLE ONLY distributors DROP CONSTRAINT zipchk;</pre><p> (Ограничение-проверка остаётся во всех дочерних таблицах.)</p><p>Добавление в таблицу ограничения внешнего ключа: </p><pre class="programlisting">ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address);</pre><p>Добавление в таблицу ограничения внешнего ключа с наименьшим влиянием на работу других: </p><pre class="programlisting">ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address) NOT VALID;
ALTER TABLE distributors VALIDATE CONSTRAINT distfk;</pre><p>Добавление в таблицу ограничения уникальности (по нескольким столбцам): </p><pre class="programlisting">ALTER TABLE distributors ADD CONSTRAINT dist_id_zipcode_key UNIQUE (dist_id, zipcode);</pre><p>Добавление в таблицу первичного ключа с автоматическим именем (учтите, что в таблице может быть только один первичный ключ): </p><pre class="programlisting">ALTER TABLE distributors ADD PRIMARY KEY (dist_id);</pre><p>Перемещение таблицы в другое табличное пространство: </p><pre class="programlisting">ALTER TABLE distributors SET TABLESPACE fasttablespace;</pre><p>Перемещение таблицы в другую схему: </p><pre class="programlisting">ALTER TABLE myschema.distributors SET SCHEMA yourschema;</pre><p>Пересоздание ограничения первичного ключа без блокировки изменений в процессе перестроения индекса: </p><pre class="programlisting">CREATE UNIQUE INDEX CONCURRENTLY dist_id_temp_idx ON distributors (dist_id);
ALTER TABLE distributors DROP CONSTRAINT distributors_pkey,
    ADD CONSTRAINT distributors_pkey PRIMARY KEY USING INDEX dist_id_temp_idx;</pre><p>Присоединение секции к таблице, разбиваемой по диапазонам: </p><pre class="programlisting">ALTER TABLE measurement
    ATTACH PARTITION measurement_y2016m07 FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');</pre><p>Присоединение секции к таблице, разбиваемой по списку: </p><pre class="programlisting">ALTER TABLE cities
    ATTACH PARTITION cities_ab FOR VALUES IN ('a', 'b');</pre><p>Присоединение секции к таблице, разбиваемой по хешу: </p><pre class="programlisting">ALTER TABLE orders
    ATTACH PARTITION orders_p4 FOR VALUES WITH (MODULUS 4, REMAINDER 3);</pre><p>Присоединение секции по умолчанию к секционированной таблице: </p><pre class="programlisting">ALTER TABLE cities
    ATTACH PARTITION cities_partdef DEFAULT;</pre><p>Удаление секции из секционированной таблицы: </p><pre class="programlisting">ALTER TABLE measurement
    DETACH PARTITION measurement_y2015m12;</pre></div><div class="refsect1" id="id-1.9.3.35.9"><h2>Совместимость</h2><p>Формы <code class="literal">ADD</code> (без <code class="literal">USING INDEX</code>), <code class="literal">DROP [COLUMN]</code>, <code class="literal">DROP IDENTITY</code>, <code class="literal">RESTART</code>, <code class="literal">SET DEFAULT</code>, <code class="literal">SET DATA TYPE</code> (без <code class="literal">USING</code>), <code class="literal">SET GENERATED</code> и <code class="literal">SET <em class="replaceable"><code>параметр_последовательности</code></em></code> соответствуют стандарту SQL. Другие формы являются расширениями стандарта SQL, реализованными в <span class="productname">PostgreSQL</span>. Кроме того, расширением является возможность указать в одной команде <code class="command">ALTER TABLE</code> несколько операций изменения.</p><p><code class="command">ALTER TABLE DROP COLUMN</code> позволяет удалить единственный столбец таблицы и оставить таблицу без столбцов. Это является расширением стандарта SQL, который не допускает существование таблиц с нулём столбцов.</p></div><div class="refsect1" id="id-1.9.3.35.10"><h2>См. также</h2><span class="simplelist"><a class="xref" href="sql-createtable.html" title="CREATE TABLE"><span class="refentrytitle">CREATE TABLE</span></a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-altersystem.html" title="ALTER SYSTEM">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-altertablespace.html" title="ALTER TABLESPACE">След.</a></td></tr><tr><td width="40%" align="left" valign="top">ALTER SYSTEM </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> ALTER TABLESPACE</td></tr></table></div></body></html>