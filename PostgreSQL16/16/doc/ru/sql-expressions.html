<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>4.2. Выражения значения</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sql-syntax-lexical.html" title="4.1. Лексическая структура" /><link rel="next" href="sql-syntax-calling-funcs.html" title="4.3. Вызов функций" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">4.2. Выражения значения</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-syntax-lexical.html" title="4.1. Лексическая структура">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-syntax.html" title="Глава 4. Синтаксис SQL">Наверх</a></td><th width="60%" align="center">Глава 4. Синтаксис SQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-syntax-calling-funcs.html" title="4.3. Вызов функций">След.</a></td></tr></table><hr /></div><div class="sect1" id="SQL-EXPRESSIONS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">4.2. Выражения значения <a href="#SQL-EXPRESSIONS" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="sql-expressions.html#SQL-EXPRESSIONS-COLUMN-REFS">4.2.1. Ссылки на столбцы</a></span></dt><dt><span class="sect2"><a href="sql-expressions.html#SQL-EXPRESSIONS-PARAMETERS-POSITIONAL">4.2.2. Позиционные параметры</a></span></dt><dt><span class="sect2"><a href="sql-expressions.html#SQL-EXPRESSIONS-SUBSCRIPTS">4.2.3. Индексы элементов</a></span></dt><dt><span class="sect2"><a href="sql-expressions.html#FIELD-SELECTION">4.2.4. Выбор поля</a></span></dt><dt><span class="sect2"><a href="sql-expressions.html#SQL-EXPRESSIONS-OPERATOR-CALLS">4.2.5. Применение оператора</a></span></dt><dt><span class="sect2"><a href="sql-expressions.html#SQL-EXPRESSIONS-FUNCTION-CALLS">4.2.6. Вызовы функций</a></span></dt><dt><span class="sect2"><a href="sql-expressions.html#SYNTAX-AGGREGATES">4.2.7. Агрегатные выражения</a></span></dt><dt><span class="sect2"><a href="sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS">4.2.8. Вызовы оконных функций</a></span></dt><dt><span class="sect2"><a href="sql-expressions.html#SQL-SYNTAX-TYPE-CASTS">4.2.9. Приведения типов</a></span></dt><dt><span class="sect2"><a href="sql-expressions.html#SQL-SYNTAX-COLLATE-EXPRS">4.2.10. Применение правил сортировки</a></span></dt><dt><span class="sect2"><a href="sql-expressions.html#SQL-SYNTAX-SCALAR-SUBQUERIES">4.2.11. Скалярные подзапросы</a></span></dt><dt><span class="sect2"><a href="sql-expressions.html#SQL-SYNTAX-ARRAY-CONSTRUCTORS">4.2.12. Конструкторы массивов</a></span></dt><dt><span class="sect2"><a href="sql-expressions.html#SQL-SYNTAX-ROW-CONSTRUCTORS">4.2.13. Конструкторы табличных строк</a></span></dt><dt><span class="sect2"><a href="sql-expressions.html#SYNTAX-EXPRESS-EVAL">4.2.14. Правила вычисления выражений</a></span></dt></dl></div><a id="id-1.5.3.6.2" class="indexterm"></a><a id="id-1.5.3.6.3" class="indexterm"></a><a id="id-1.5.3.6.4" class="indexterm"></a><p>Выражения значения применяются в самых разных контекстах, например в списке результатов команды <code class="command">SELECT</code>, в значениях столбцов в <code class="command">INSERT</code> или <code class="command">UPDATE</code> или в условиях поиска во многих командах. Результат такого выражения иногда называют <em class="firstterm">скаляром</em>, чтобы отличить его от результата табличного выражения (который представляет собой таблицу). А сами выражения значения часто называют <em class="firstterm">скалярными</em> (или просто <em class="firstterm">выражениями</em>). Синтаксис таких выражений позволяет вычислять значения из примитивных частей, используя арифметические, логические и другие операции.</p><p>Выражениями значения являются: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Константа или непосредственное значение</p></li><li class="listitem"><p>Ссылка на столбец</p></li><li class="listitem"><p>Ссылка на позиционный параметр в теле определения функции или подготовленного оператора</p></li><li class="listitem"><p>Выражение с индексом</p></li><li class="listitem"><p>Выражение выбора поля</p></li><li class="listitem"><p>Применение оператора</p></li><li class="listitem"><p>Вызов функции</p></li><li class="listitem"><p>Агрегатное выражение</p></li><li class="listitem"><p>Вызов оконной функции</p></li><li class="listitem"><p>Приведение типов</p></li><li class="listitem"><p>Применение правил сортировки</p></li><li class="listitem"><p>Скалярный подзапрос</p></li><li class="listitem"><p>Конструктор массива</p></li><li class="listitem"><p>Конструктор табличной строки</p></li><li class="listitem"><p>Кроме того, выражением значения являются скобки (предназначенные для группировки подвыражений и переопределения приоритета <a id="id-1.5.3.6.6.1.15.1.1" class="indexterm"></a>)</p></li></ul></div><p>В дополнение к этому списку есть ещё несколько конструкций, которые можно классифицировать как выражения, хотя они не соответствуют общим синтаксическим правилам. Они обычно имеют вид функции или оператора и будут рассмотрены в соответствующем разделе <a class="xref" href="functions.html" title="Глава 9. Функции и операторы">Главы 9</a>. Пример такой конструкции — предложение <code class="literal">IS NULL</code>.</p><p>Мы уже обсудили константы в <a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-CONSTANTS" title="4.1.2. Константы">Подразделе 4.1.2</a>. В следующих разделах рассматриваются остальные варианты.</p><div class="sect2" id="SQL-EXPRESSIONS-COLUMN-REFS"><div class="titlepage"><div><div><h3 class="title">4.2.1. Ссылки на столбцы <a href="#SQL-EXPRESSIONS-COLUMN-REFS" class="id_link">#</a></h3></div></div></div><a id="id-1.5.3.6.9.2" class="indexterm"></a><p>Ссылку на столбец можно записать в форме: </p><pre class="synopsis">
<em class="replaceable"><code>отношение</code></em>.<em class="replaceable"><code>имя_столбца</code></em>
</pre><p>Здесь <em class="replaceable"><code>отношение</code></em> — имя таблицы (возможно, полное, с именем схемы) или её псевдоним, определённый в предложении <code class="literal">FROM</code>. Это имя и разделяющую точку можно опустить, если имя столбца уникально среди всех таблиц, задействованных в текущем запросе. (См. также <a class="xref" href="queries.html" title="Глава 7. Запросы">Главу 7</a>.)</p></div><div class="sect2" id="SQL-EXPRESSIONS-PARAMETERS-POSITIONAL"><div class="titlepage"><div><div><h3 class="title">4.2.2. Позиционные параметры <a href="#SQL-EXPRESSIONS-PARAMETERS-POSITIONAL" class="id_link">#</a></h3></div></div></div><a id="id-1.5.3.6.10.2" class="indexterm"></a><a id="id-1.5.3.6.10.3" class="indexterm"></a><p>Ссылка на позиционный параметр применяется для обращения к значению, переданному в SQL-оператор извне. Параметры используются в определениях SQL-функций и подготовленных операторов. Некоторые клиентские библиотеки также поддерживают передачу значений данных отдельно от самой SQL-команды, и в этом случае параметры позволяют ссылаться на такие значения. Ссылка на параметр записывается в следующей форме: </p><pre class="synopsis">
$<em class="replaceable"><code>число</code></em>
</pre><p>Например, рассмотрим следующее определение функции <code class="function">dept</code>: </p><pre class="programlisting">CREATE FUNCTION dept(text) RETURNS dept
    AS $$ SELECT * FROM dept WHERE name = $1 $$
    LANGUAGE SQL;</pre><p> Здесь <code class="literal">$1</code> всегда будет ссылаться на значение первого аргумента функции.</p></div><div class="sect2" id="SQL-EXPRESSIONS-SUBSCRIPTS"><div class="titlepage"><div><div><h3 class="title">4.2.3. Индексы элементов <a href="#SQL-EXPRESSIONS-SUBSCRIPTS" class="id_link">#</a></h3></div></div></div><a id="id-1.5.3.6.11.2" class="indexterm"></a><p>Если в выражении вы имеете дело с массивом, то можно извлечь определённый его элемент, написав: </p><pre class="synopsis">
<em class="replaceable"><code>выражение</code></em>[<em class="replaceable"><code>индекс</code></em>]
</pre><p> или несколько соседних элементов (<span class="quote">«<span class="quote">срез массива</span>»</span>): </p><pre class="synopsis">
<em class="replaceable"><code>выражение</code></em>[<em class="replaceable"><code>нижний_индекс</code></em>:<em class="replaceable"><code>верхний_индекс</code></em>]
</pre><p> (Здесь квадратные скобки <code class="literal">[ ]</code> должны присутствовать буквально.) Каждый <em class="replaceable"><code>индекс</code></em> сам по себе является выражением, результат которого округляется к ближайшему целому.</p><p>В общем случае <em class="replaceable"><code>выражение</code></em> массива должно заключаться в круглые скобки, но их можно опустить, когда выражение с индексом — это просто ссылка на столбец или позиционный параметр. Кроме того, можно соединить несколько индексов, если исходный массив многомерный. Например: </p><pre class="programlisting">моя_таблица.столбец_массив[4]
моя_таблица.столбец_массив_2d[17][34]
$1[10:42]
(функция_массив(a,b))[42]</pre><p> В последней строке круглые скобки необходимы. Подробнее массивы рассматриваются в <a class="xref" href="arrays.html" title="8.15. Массивы">Разделе 8.15</a>.</p></div><div class="sect2" id="FIELD-SELECTION"><div class="titlepage"><div><div><h3 class="title">4.2.4. Выбор поля <a href="#FIELD-SELECTION" class="id_link">#</a></h3></div></div></div><a id="id-1.5.3.6.12.2" class="indexterm"></a><p>Если результат выражения — значение составного типа (строка таблицы), тогда определённое поле этой строки можно извлечь, написав:</p><pre class="synopsis">
<em class="replaceable"><code>выражение</code></em>.<em class="replaceable"><code>имя_поля</code></em>
</pre><p>В общем случае <em class="replaceable"><code>выражение</code></em> такого типа должно заключаться в круглые скобки, но их можно опустить, когда это ссылка на таблицу или позиционный параметр. Например: </p><pre class="programlisting">моя_таблица.столбец
$1.столбец
(функция_кортеж(a,b)).стол3</pre><p> (Таким образом, полная ссылка на столбец — это просто частный случай выбора поля.) Важный особый случай здесь — извлечение поля из столбца составного типа: </p><pre class="programlisting">(составной_столбец).поле
(моя_таблица.составной_столбец).поле</pre><p> Здесь скобки нужны, чтобы показать, что <code class="structfield">составной_столбец</code> — это имя столбца, а не таблицы, и что <code class="structname">моя_таблица</code> — имя таблицы, а не схемы.</p><p>Вы можете запросить все поля составного значения, написав <code class="literal">.*</code>: </p><pre class="programlisting">(составной_столбец).*</pre><p> Эта запись действует по-разному в зависимости от контекста; подробнее об этом говорится в <a class="xref" href="rowtypes.html#ROWTYPES-USAGE" title="8.16.5. Использование составных типов в запросах">Подразделе 8.16.5</a>.</p></div><div class="sect2" id="SQL-EXPRESSIONS-OPERATOR-CALLS"><div class="titlepage"><div><div><h3 class="title">4.2.5. Применение оператора <a href="#SQL-EXPRESSIONS-OPERATOR-CALLS" class="id_link">#</a></h3></div></div></div><a id="id-1.5.3.6.13.2" class="indexterm"></a><p>Существуют два возможных синтаксиса применения операторов: </p><table border="0" summary="Simple list" class="simplelist"><tr><td><em class="replaceable"><code>выражение</code></em> <em class="replaceable"><code>оператор</code></em> <em class="replaceable"><code>выражение</code></em> (бинарный инфиксный оператор)</td></tr><tr><td><em class="replaceable"><code>оператор</code></em> <em class="replaceable"><code>выражение</code></em> (унарный префиксный оператор)</td></tr></table><p>где <em class="replaceable"><code>оператор</code></em> соответствует синтаксическим правилам, описанным в <a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-OPERATORS" title="4.1.3. Операторы">Подразделе 4.1.3</a>, либо это одно из ключевых слов <code class="token">AND</code>, <code class="token">OR</code> и <code class="token">NOT</code>, либо полное имя оператора в форме: </p><pre class="synopsis">
<code class="literal">OPERATOR(</code><em class="replaceable"><code>схема</code></em><code class="literal">.</code><em class="replaceable"><code>имя_оператора</code></em><code class="literal">)</code>
</pre><p> Существование конкретных операторов и их тип (унарный или бинарный) зависит от того, как и какие операторы определены системой и пользователем. Встроенные операторы описаны в <a class="xref" href="functions.html" title="Глава 9. Функции и операторы">Главе 9</a>.</p></div><div class="sect2" id="SQL-EXPRESSIONS-FUNCTION-CALLS"><div class="titlepage"><div><div><h3 class="title">4.2.6. Вызовы функций <a href="#SQL-EXPRESSIONS-FUNCTION-CALLS" class="id_link">#</a></h3></div></div></div><a id="id-1.5.3.6.14.2" class="indexterm"></a><p>Вызов функции записывается просто как имя функции (возможно, дополненное именем схемы) и список аргументов в скобках: </p><pre class="synopsis">
<em class="replaceable"><code>имя_функции</code></em> ([<span class="optional"><em class="replaceable"><code>выражение</code></em> [<span class="optional">, <em class="replaceable"><code>выражение</code></em> ... </span>]</span>])
</pre><p>Например, так вычисляется квадратный корень из 2: </p><pre class="programlisting">sqrt(2)</pre><p>Список встроенных функций приведён в <a class="xref" href="functions.html" title="Глава 9. Функции и операторы">Главе 9</a>. Пользователь также может определить и другие функции.</p><p>Выполняя запросы в базе данных, где одни пользователи могут не доверять другим, в записи вызовов функций соблюдайте меры предосторожности, описанные в <a class="xref" href="typeconv-func.html" title="10.3. Функции">Разделе 10.3</a>.</p><p>Аргументам могут быть присвоены необязательные имена. Подробнее об этом см. <a class="xref" href="sql-syntax-calling-funcs.html" title="4.3. Вызов функций">Раздел 4.3</a>.</p><div class="note"><h3 class="title">Примечание</h3><p>Функцию, принимающую один аргумент составного типа, можно также вызывать, используя синтаксис выбора поля, и наоборот, выбор поля можно записать в функциональном стиле. То есть записи <code class="literal">col(table)</code> и <code class="literal">table.col</code> равносильны и взаимозаменяемы. Это поведение не оговорено стандартом SQL, но реализовано в <span class="productname">PostgreSQL</span>, так как это позволяет использовать функции для эмуляции <span class="quote">«<span class="quote">вычисляемых полей</span>»</span>. Подробнее это описано в <a class="xref" href="rowtypes.html#ROWTYPES-USAGE" title="8.16.5. Использование составных типов в запросах">Подразделе 8.16.5</a>.</p></div></div><div class="sect2" id="SYNTAX-AGGREGATES"><div class="titlepage"><div><div><h3 class="title">4.2.7. Агрегатные выражения <a href="#SYNTAX-AGGREGATES" class="id_link">#</a></h3></div></div></div><a id="id-1.5.3.6.15.2" class="indexterm"></a><a id="id-1.5.3.6.15.3" class="indexterm"></a><a id="id-1.5.3.6.15.4" class="indexterm"></a><a id="id-1.5.3.6.15.5" class="indexterm"></a><p><em class="firstterm">Агрегатное выражение</em> представляет собой применение агрегатной функции к строкам, выбранным запросом. Агрегатная функция сводит множество входных значений к одному выходному, как например, сумма или среднее. Агрегатное выражение может записываться следующим образом: </p><pre class="synopsis">
<em class="replaceable"><code>агрегатная_функция</code></em> (<em class="replaceable"><code>выражение</code></em> [ , ... ] [ <em class="replaceable"><code>предложение_order_by</code></em> ] ) [ FILTER ( WHERE <em class="replaceable"><code>условие_фильтра</code></em> ) ]
<em class="replaceable"><code>агрегатная_функция</code></em> (ALL <em class="replaceable"><code>выражение</code></em> [ , ... ] [ <em class="replaceable"><code>предложение_order_by</code></em> ] ) [ FILTER ( WHERE <em class="replaceable"><code>условие_фильтра</code></em> ) ]
<em class="replaceable"><code>агрегатная_функция</code></em> (DISTINCT <em class="replaceable"><code>выражение</code></em> [ , ... ] [ <em class="replaceable"><code>предложение_order_by</code></em> ] ) [ FILTER ( WHERE <em class="replaceable"><code>условие_фильтра</code></em> ) ]
<em class="replaceable"><code>агрегатная_функция</code></em> ( * ) [ FILTER ( WHERE <em class="replaceable"><code>условие_фильтра</code></em> ) ]
<em class="replaceable"><code>агрегатная_функция</code></em> ( [ <em class="replaceable"><code>выражение</code></em> [ , ... ] ] ) WITHIN GROUP ( <em class="replaceable"><code>предложение_order_by</code></em> ) [ FILTER ( WHERE <em class="replaceable"><code>условие_фильтра</code></em> ) ]
</pre><p> Здесь <em class="replaceable"><code>агрегатная_функция</code></em> — имя ранее определённой агрегатной функции (возможно, дополненное именем схемы), <em class="replaceable"><code>выражение</code></em> — любое выражение значения, не содержащее в себе агрегатного выражения или вызова оконной функции. Необязательные предложения <em class="replaceable"><code>предложение_order_by</code></em> и <em class="replaceable"><code>условие_фильтра</code></em> описываются ниже.</p><p>В первой форме агрегатного выражения агрегатная функция вызывается для каждой строки. Вторая форма эквивалентна первой, так как указание <code class="literal">ALL</code> подразумевается по умолчанию. В третьей форме агрегатная функция вызывается для всех различных значений выражения (или набора различных значений, для нескольких выражений), выделенных во входных данных. В четвёртой форме агрегатная функция вызывается для каждой строки, так как никакого конкретного значения не указано (обычно это имеет смысл только для функции <code class="function">count(*)</code>). В последней форме используются <em class="firstterm">сортирующие</em> агрегатные функции, которые будут описаны ниже.</p><p>Большинство агрегатных функций игнорируют значения NULL, так что строки, для которых выражения выдают одно или несколько значений NULL, отбрасываются. Это можно считать истинным для всех встроенных операторов, если явно не говорится об обратном.</p><p>Например, <code class="literal">count(*)</code> подсчитает общее количество строк, а <code class="literal">count(f1)</code> только количество строк, в которых <code class="literal">f1</code> не NULL (так как <code class="function">count</code> игнорирует NULL), а <code class="literal">count(distinct f1)</code> подсчитает число различных и отличных от NULL значений столбца <code class="literal">f1</code>.</p><p>Обычно строки данных передаются агрегатной функции в неопределённом порядке и во многих случаях это не имеет значения, например функция <code class="function">min</code> выдаёт один и тот же результат независимо от порядка поступающих данных. Однако некоторые агрегатные функции (такие как <code class="function">array_agg</code> и <code class="function">string_agg</code>) выдают результаты, зависящие от порядка данных. Для таких агрегатных функций можно добавить <em class="replaceable"><code>предложение_order_by</code></em> и задать нужный порядок. Это <em class="replaceable"><code>предложение_order_by</code></em> имеет тот же синтаксис, что и предложение <code class="literal">ORDER BY</code> на уровне запроса, как описано в <a class="xref" href="queries-order.html" title="7.5. Сортировка строк (ORDER BY)">Разделе 7.5</a>, за исключением того, что его выражения должны быть просто выражениями, а не именами результирующих столбцов или числами. Например: </p><pre class="programlisting">SELECT array_agg(a ORDER BY b DESC) FROM table;</pre><p>Заметьте, что при использовании агрегатных функций с несколькими аргументами, предложение <code class="literal">ORDER BY</code> идёт после всех аргументов. Например, надо писать так: </p><pre class="programlisting">SELECT string_agg(a, ',' ORDER BY a) FROM table;</pre><p> а не так: </p><pre class="programlisting">SELECT string_agg(a ORDER BY a, ',') FROM table;  -- неправильно</pre><p> Последний вариант синтаксически допустим, но он представляет собой вызов агрегатной функции одного аргумента с двумя ключами <code class="literal">ORDER BY</code> (при этом второй не имеет смысла, так как это константа).</p><p>Если <em class="replaceable"><code>предложение_order_by</code></em> дополнено указанием <code class="literal">DISTINCT</code>, тогда все выражения <code class="literal">ORDER BY</code> должны соответствовать обычным аргументам агрегатной функции; то есть вы не можете сортировать строки по выражению, не включённому в список <code class="literal">DISTINCT</code>.</p><div class="note"><h3 class="title">Примечание</h3><p>Возможность указывать и <code class="literal">DISTINCT</code>, и <code class="literal">ORDER BY</code> в агрегатной функции — это расширение <span class="productname">PostgreSQL</span>.</p></div><p>При добавлении <code class="literal">ORDER BY</code> в обычный список аргументов агрегатной функции, описанном до этого, выполняется сортировка входных строк для универсальных и статистических агрегатных функций, для которых сортировка необязательна. Но есть подмножество агрегатных функций, <em class="firstterm">сортирующие агрегатные функции</em>, для которых <em class="replaceable"><code>предложение_order</code></em> является <span class="emphasis"><em>обязательным</em></span>, обычно потому, что вычисление этой функции имеет смысл только при определённой сортировке входных строк. Типичными примерами сортирующих агрегатных функций являются вычисления ранга и процентиля. Для сортирующей агрегатной функции <em class="replaceable"><code>предложение_order_by</code></em> записывается внутри <code class="literal">WITHIN GROUP (...)</code>, что иллюстрирует последний пример, приведённый выше. Выражения в <em class="replaceable"><code>предложении_order_by</code></em> вычисляются однократно для каждой входной строки как аргументы обычной агрегатной функции, сортируются в соответствии с требованием <em class="replaceable"><code>предложения_order_by</code></em> и поступают в агрегатную функции как входящие аргументы. (Если же <em class="replaceable"><code>предложение_order_by</code></em> находится не в <code class="literal">WITHIN GROUP</code>, оно не передаётся как аргумент(ы) агрегатной функции.) Выражения-аргументы, предшествующие <code class="literal">WITHIN GROUP</code>, (если они есть), называются <em class="firstterm">непосредственными аргументами</em>, а выражения, указанные в <em class="replaceable"><code>предложении_order_by</code></em> — <em class="firstterm">агрегируемыми аргументами</em>. В отличие от аргументов обычной агрегатной функции, непосредственные аргументы вычисляются однократно для каждого вызова функции, а не для каждой строки. Это значит, что они могут содержать переменные, только если эти переменные сгруппированы в <code class="literal">GROUP BY</code>; это суть то же ограничение, что действовало бы, будь эти непосредственные аргументы вне агрегатного выражения. Непосредственные аргументы обычно используются, например, для указания значения процентиля, которое имеет смысл, только если это конкретное число для всего расчёта агрегатной функции. Список непосредственных аргументов может быть пуст; в этом случае запишите просто <code class="literal">()</code>, но не <code class="literal">(*)</code>. (На самом деле <span class="productname">PostgreSQL</span> примет обе записи, но только первая соответствует стандарту SQL.)</p><p><a id="id-1.5.3.6.15.15.1" class="indexterm"></a> Пример вызова сортирующей агрегатной функции: </p><pre class="programlisting">SELECT percentile_cont(0.5) WITHIN GROUP (ORDER BY income) FROM households;
 percentile_cont
-----------------
           50489</pre><p> она получает 50-ый процентиль, или медиану, значения столбца <code class="structfield">income</code> из таблицы <code class="structname">households</code>. В данном случае <code class="literal">0.5</code> — это непосредственный аргумент; если бы дробь процентиля менялась от строки к строке, это не имело бы смысла.</p><p>Если добавлено предложение <code class="literal">FILTER</code>, агрегатной функции подаются только те входные строки, для которых <em class="replaceable"><code>условие_фильтра</code></em> вычисляется как истинное; другие строки отбрасываются. Например: </p><pre class="programlisting">SELECT
    count(*) AS unfiltered,
    count(*) FILTER (WHERE i &lt; 5) AS filtered
FROM generate_series(1,10) AS s(i);
 unfiltered | filtered
------------+----------
         10 |        4
(1 row)</pre><p>Предопределённые агрегатные функции описаны в <a class="xref" href="functions-aggregate.html" title="9.21. Агрегатные функции">Разделе 9.21</a>. Пользователь также может определить другие агрегатные функции.</p><p>Агрегатное выражение может фигурировать только в списке результатов или в предложении <code class="literal">HAVING</code> команды <code class="command">SELECT</code>. Во всех остальных предложениях, например <code class="literal">WHERE</code>, они запрещены, так как эти предложения логически вычисляются до того, как формируются результаты агрегатных функций.</p><p>Когда агрегатное выражение используется в подзапросе (см. <a class="xref" href="sql-expressions.html#SQL-SYNTAX-SCALAR-SUBQUERIES" title="4.2.11. Скалярные подзапросы">Подраздел 4.2.11</a> и <a class="xref" href="functions-subquery.html" title="9.23. Выражения подзапросов">Раздел 9.23</a>), оно обычно вычисляется для всех строк подзапроса. Но если в аргументах (или в <em class="replaceable"><code>условии_filter</code></em>) агрегатной функции есть только переменные внешнего уровня, агрегатная функция относится к ближайшему внешнему уровню и вычисляется для всех строк соответствующего запроса. Такое агрегатное выражение в целом является внешней ссылкой для своего подзапроса и на каждом вычислении считается константой. При этом допустимое положение агрегатной функции ограничивается списком результатов и предложением <code class="literal">HAVING</code> на том уровне запросов, где она находится.</p></div><div class="sect2" id="SYNTAX-WINDOW-FUNCTIONS"><div class="titlepage"><div><div><h3 class="title">4.2.8. Вызовы оконных функций <a href="#SYNTAX-WINDOW-FUNCTIONS" class="id_link">#</a></h3></div></div></div><a id="id-1.5.3.6.16.2" class="indexterm"></a><a id="id-1.5.3.6.16.3" class="indexterm"></a><p><em class="firstterm">Вызов оконной функции</em> представляет собой применение функции, подобной агрегатной, к некоторому набору строк, выбранному запросом. В отличие от вызовов не оконных агрегатных функций, при этом не происходит группировка выбранных строк в одну — каждая строка остаётся отдельной в результате запроса. Однако оконная функция имеет доступ ко всем строкам, вошедшим в группу текущей строки согласно указанию группировки (списку <code class="literal">PARTITION BY</code>) в вызове оконной функции. Вызов оконной функции может иметь следующие формы: </p><pre class="synopsis">
<em class="replaceable"><code>имя_функции</code></em> ([<span class="optional"><em class="replaceable"><code>выражение</code></em> [<span class="optional">, <em class="replaceable"><code>выражение</code></em> ... </span>]</span>]) [ FILTER ( WHERE <em class="replaceable"><code>предложение_фильтра</code></em> ) ] OVER <em class="replaceable"><code>имя_окна</code></em>
<em class="replaceable"><code>имя_функции</code></em> ([<span class="optional"><em class="replaceable"><code>выражение</code></em> [<span class="optional">, <em class="replaceable"><code>выражение</code></em> ... </span>]</span>]) [ FILTER ( WHERE <em class="replaceable"><code>предложение_фильтра</code></em> ) ] OVER ( <em class="replaceable"><code>определение_окна</code></em> )
<em class="replaceable"><code>имя_функции</code></em> ( * ) [ FILTER ( WHERE <em class="replaceable"><code>предложение_фильтра</code></em> ) ] OVER <em class="replaceable"><code>имя_окна</code></em>
<em class="replaceable"><code>имя_функции</code></em> ( * ) [ FILTER ( WHERE <em class="replaceable"><code>предложение_фильтра</code></em> ) ] OVER ( <em class="replaceable"><code>определение_окна</code></em> )
</pre><p> Здесь <em class="replaceable"><code>определение_окна</code></em> записывается в виде </p><pre class="synopsis">
[ <em class="replaceable"><code>имя_существующего_окна</code></em> ]
[ PARTITION BY <em class="replaceable"><code>выражение</code></em> [, ...] ]
[ ORDER BY <em class="replaceable"><code>выражение</code></em> [ ASC | DESC | USING <em class="replaceable"><code>оператор</code></em> ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ <em class="replaceable"><code>определение_рамки</code></em> ]
</pre><p> Необязательное <em class="replaceable"><code>определение_рамки</code></em> может иметь вид: </p><pre class="synopsis">
{ RANGE | ROWS | GROUPS } <em class="replaceable"><code>начало_рамки</code></em> [ <em class="replaceable"><code>исключение_рамки</code></em> ]
{ RANGE | ROWS | GROUPS } BETWEEN <em class="replaceable"><code>начало_рамки</code></em> AND <em class="replaceable"><code>конец_рамки</code></em> [ <em class="replaceable"><code>исключение_рамки</code></em> ]
</pre><p> Здесь <em class="replaceable"><code>начало_рамки</code></em> и <em class="replaceable"><code>конец_рамки</code></em> задаются одним из следующих способов: </p><pre class="synopsis">
UNBOUNDED PRECEDING
<em class="replaceable"><code>смещение</code></em> PRECEDING
CURRENT ROW
<em class="replaceable"><code>смещение</code></em> FOLLOWING
UNBOUNDED FOLLOWING
</pre><p> и <em class="replaceable"><code>исключение_рамки</code></em> может быть следующим: </p><pre class="synopsis">
EXCLUDE CURRENT ROW
EXCLUDE GROUP
EXCLUDE TIES
EXCLUDE NO OTHERS
</pre><p>Здесь <em class="replaceable"><code>выражение</code></em> — это любое выражение значения, не содержащее вызовов оконных функций.</p><p><em class="replaceable"><code>имя_окна</code></em> — ссылка на именованное окно, определённое предложением <code class="literal">WINDOW</code> в данном запросе. Также возможно написать в скобках полное <em class="replaceable"><code>определение_окна</code></em>, используя тот же синтаксис определения именованного окна в предложении <code class="literal">WINDOW</code>; подробнее это описано в справке по <a class="xref" href="sql-select.html" title="SELECT"><span class="refentrytitle">SELECT</span></a>. Стоит отметить, что запись <code class="literal">OVER имя_окна</code> не полностью равнозначна <code class="literal">OVER (имя_окна ...)</code>; последний вариант подразумевает копирование и изменение определения окна и не будет допустимым, если определение этого окна включает определение рамки.</p><p>Указание <code class="literal">PARTITION BY</code> группирует строки запроса в <em class="firstterm">разделы</em>, которые затем обрабатываются оконной функцией независимо друг от друга. <code class="literal">PARTITION BY</code> работает подобно предложению <code class="literal">GROUP BY</code> на уровне запроса, за исключением того, что его аргументы всегда просто выражения, а не имена выходных столбцов или числа. Без <code class="literal">PARTITION BY</code> все строки, выдаваемые запросом, рассматриваются как один раздел. Указание <code class="literal">ORDER BY</code> определяет порядок, в котором оконная функция обрабатывает строки раздела. Оно так же подобно предложению <code class="literal">ORDER BY</code> на уровне запроса и так же не принимает имена выходных столбцов или числа. Без <code class="literal">ORDER BY</code> строки обрабатываются в неопределённом порядке.</p><p><em class="replaceable"><code>определение_рамки</code></em> задаёт набор строк, образующих <em class="firstterm">рамку окна</em>, которая представляет собой подмножество строк текущего раздела и используется для оконных функций, работающих с рамкой, а не со всем разделом. Подмножество строк в рамке может меняться в зависимости от того, какая строка является текущей. Рамку можно задать в режимах <code class="literal">RANGE</code>, <code class="literal">ROWS</code> или <code class="literal">GROUPS</code>; в каждом случае она начинается с положения <em class="replaceable"><code>начало_рамки</code></em> и заканчивается положением <em class="replaceable"><code>конец_рамки</code></em>. Если <em class="replaceable"><code>конец_рамки</code></em> не задаётся явно, подразумевается <code class="literal">CURRENT ROW</code> (текущая строка).</p><p>Если <em class="replaceable"><code>начало_рамки</code></em> задано как <code class="literal">UNBOUNDED PRECEDING</code>, рамка начинается с первой строки раздела, а если <em class="replaceable"><code>конец_рамки</code></em> определён как <code class="literal">UNBOUNDED FOLLOWING</code>, рамка заканчивается последней строкой раздела.</p><p>В режиме <code class="literal">RANGE</code> или <code class="literal">GROUPS</code> <em class="replaceable"><code>начало_рамки</code></em>, заданное как <code class="literal">CURRENT ROW</code>, определяет в качестве начала первую <em class="firstterm">родственную</em> строку (строку, которая при сортировке согласно указанному для окна предложению <code class="literal">ORDER BY</code> считается равной текущей), тогда как <em class="replaceable"><code>конец_рамки</code></em>, заданный как <code class="literal">CURRENT ROW</code>, определяет концом рамки последнюю родственную строку. В режиме <code class="literal">ROWS</code> вариант <code class="literal">CURRENT ROW</code> просто обозначает текущую строку.</p><p>В вариантах определения рамки <em class="replaceable"><code>смещение</code></em> <code class="literal">PRECEDING</code> и <em class="replaceable"><code>смещение</code></em> <code class="literal">FOLLOWING</code> в качестве <em class="replaceable"><code>смещения</code></em> должно задаваться выражение, не содержащее какие-либо переменные и вызовы агрегатных или оконных функций. Что именно будет означать <em class="replaceable"><code>смещение</code></em>, определяется в зависимости от режима рамки: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>В режиме <code class="literal">ROWS</code> <em class="replaceable"><code>смещение</code></em> должно задаваться отличным от NULL неотрицательным целым числом, и это число определяет сдвиг, с которым начало рамки позиционируется перед текущей строкой, а конец — после текущей строки.</p></li><li class="listitem"><p>В режиме <code class="literal">GROUPS</code> <em class="replaceable"><code>смещение</code></em> также должно задаваться отличным от NULL неотрицательным целым числом, и это число определяет сдвиг (по количеству групп родственных строк), с которым начало рамки позиционируется перед группой строк, родственных текущей, а конец — после этой группы. Группу родственных строк образуют строки, которые считаются равными согласно <code class="literal">ORDER BY</code>. (Для использования режима <code class="literal">GROUPS</code> определение окна должно содержать предложение <code class="literal">ORDER BY</code>.)</p></li><li class="listitem"><p>В режиме <code class="literal">RANGE</code> для использования этих указаний предложение <code class="literal">ORDER BY</code> должно содержать ровно один столбец. В этом случае <em class="replaceable"><code>смещение</code></em> задаёт максимальную разницу между значением этого столбца в текущей строке и значением его же в предшествующих или последующих строках рамки. Тип данных выражения <em class="replaceable"><code>смещение</code></em> зависит от типа данных упорядочивающего столбца. Для числовых столбцов это обычно тот же числовой тип, а для столбцов с типом дата/время — тип <code class="type">interval</code>. Например, если упорядочивающий столбец имеет тип <code class="type">date</code> или <code class="type">timestamp</code>, возможна такая запись: <code class="literal">RANGE BETWEEN '1 day' PRECEDING AND '10 days' FOLLOWING</code>. Значение <em class="replaceable"><code>смещение</code></em> при этом может так же быть отличным от NULL и неотрицательным, хотя что считать <span class="quote">«<span class="quote">неотрицательным</span>»</span>, будет зависит от типа данных.</p></li></ul></div><p> В любом случае расстояние до конца рамки ограничивается расстоянием до конца раздела, так что для строк, которые находятся у конца раздела, рамка может содержать меньше строк, чем для других.</p><p>Заметьте, что в режимах <code class="literal">ROWS</code> и <code class="literal">GROUPS</code> указания <code class="literal">0 PRECEDING</code> и <code class="literal">0 FOLLOWING</code> равнозначны указанию <code class="literal">CURRENT ROW</code>. Обычно это справедливо и для режима <code class="literal">RANGE</code>, в случае подходящего для типа данных определения значения <span class="quote">«<span class="quote">нуля</span>»</span>.</p><p>Дополнение <em class="replaceable"><code>исключение_рамки</code></em> позволяет исключить из рамки строки, которые окружают текущую строку, даже если они должны быть включены согласно указаниям, определяющим начало и конец рамки. <code class="literal">EXCLUDE CURRENT ROW</code> исключает из рамки текущую строку. <code class="literal">EXCLUDE GROUP</code> исключает из рамки текущую строку и родственные ей согласно порядку сортировки. <code class="literal">EXCLUDE TIES</code> исключает из рамки все родственные строки для текущей, но не собственно текущую строку. <code class="literal">EXCLUDE NO OTHERS</code> просто явно выражает поведение по умолчанию — не исключает ни текущую строку, ни родственные ей.</p><p>По умолчанию рамка определяется как <code class="literal">RANGE UNBOUNDED PRECEDING</code>, что равносильно расширенному определению <code class="literal">RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>. С указанием <code class="literal">ORDER BY</code> это означает, что рамка будет включать все строки от начала раздела до последней строки, родственной текущей (для <code class="literal">ORDER BY</code>). Без <code class="literal">ORDER BY</code> это означает, что в рамку включаются все строки раздела, так как все они считаются родственными текущей.</p><p>Действуют также следующие ограничения: в качестве <em class="replaceable"><code>начала_рамки</code></em> нельзя задать <code class="literal">UNBOUNDED FOLLOWING</code>, в качестве <em class="replaceable"><code>конца_рамки</code></em> не допускается <code class="literal">UNBOUNDED PRECEDING</code> и <em class="replaceable"><code>конец_рамки</code></em> не может идти в показанном выше списке указаний <em class="replaceable"><code>начало_рамки</code></em> AND <em class="replaceable"><code>конец_рамки</code></em> перед <em class="replaceable"><code>началом_рамки</code></em>. В частности, синтаксис <code class="literal">RANGE BETWEEN CURRENT ROW AND <em class="replaceable"><code>смещение</code></em> PRECEDING</code> не допускается. Но при этом, например, определение <code class="literal">ROWS BETWEEN 7 PRECEDING AND 8 PRECEDING</code> допустимо, хотя оно и не выберет никакие строки.</p><p>Если добавлено предложение <code class="literal">FILTER</code>, оконной функции подаются только те входные строки, для которых <em class="replaceable"><code>условие_фильтра</code></em> вычисляется как истинное; другие строки отбрасываются. Предложение <code class="literal">FILTER</code> допускается только для агрегирующих оконных функций.</p><p>Встроенные оконные функции описаны в <a class="xref" href="functions-window.html#FUNCTIONS-WINDOW-TABLE" title="Таблица 9.64. Оконные функции общего назначения">Таблице 9.64</a>, но пользователь может расширить этот набор, создавая собственные функции. Кроме того, в качестве оконных функций можно использовать любые встроенные или пользовательские универсальные, а также статистические агрегатные функции. (Сортирующие и гипотезирующие агрегатные функции в настоящее время использовать в качестве оконных нельзя.)</p><p>Запись со звёздочкой (<code class="literal">*</code>) применяется при вызове не имеющих параметров агрегатных функций в качестве оконных, например <code class="literal">count(*) OVER (PARTITION BY x ORDER BY y)</code>. Звёздочка (<code class="literal">*</code>) обычно не применяется для исключительно оконных функций. Такие функции не допускают использования <code class="literal">DISTINCT</code> и <code class="literal">ORDER BY</code> в списке аргументов функции.</p><p>Вызовы оконных функций разрешены в запросах только в списке <code class="literal">SELECT</code> и в предложении <code class="literal">ORDER BY</code>.</p><p>Дополнительно об оконных функциях можно узнать в <a class="xref" href="tutorial-window.html" title="3.5. Оконные функции">Разделе 3.5</a>, <a class="xref" href="functions-window.html" title="9.22. Оконные функции">Разделе 9.22</a> и <a class="xref" href="queries-table-expressions.html#QUERIES-WINDOW" title="7.2.5. Обработка оконных функций">Подразделе 7.2.5</a>.</p></div><div class="sect2" id="SQL-SYNTAX-TYPE-CASTS"><div class="titlepage"><div><div><h3 class="title">4.2.9. Приведения типов <a href="#SQL-SYNTAX-TYPE-CASTS" class="id_link">#</a></h3></div></div></div><a id="id-1.5.3.6.17.2" class="indexterm"></a><a id="id-1.5.3.6.17.3" class="indexterm"></a><a id="id-1.5.3.6.17.4" class="indexterm"></a><p>Приведение типа определяет преобразование данных из одного типа в другой. <span class="productname">PostgreSQL</span> воспринимает две равносильные записи приведения типов: </p><pre class="synopsis">
CAST ( <em class="replaceable"><code>выражение</code></em> AS <em class="replaceable"><code>тип</code></em> )
<em class="replaceable"><code>выражение</code></em>::<em class="replaceable"><code>тип</code></em>
</pre><p> Запись с <code class="literal">CAST</code> соответствует стандарту SQL, тогда как вариант с <code class="literal">::</code> — историческое наследие <span class="productname">PostgreSQL</span>.</p><p>Когда приведению подвергается значение выражения известного типа, происходит преобразование типа во время выполнения. Это приведение будет успешным, только если определён подходящий оператор преобразования типов. Обратите внимание на небольшое отличие от приведения констант, описанного в <a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-CONSTANTS-GENERIC" title="4.1.2.7. Константы других типов">Подразделе 4.1.2.7</a>. Приведение строки в чистом виде представляет собой начальное присваивание строковой константы и оно будет успешным для любого типа (конечно, если строка содержит значение, приемлемое для данного типа данных).</p><p>Явное приведение типа можно опустить, если возможно однозначно определить, какой тип должно иметь выражение (например, когда оно присваивается столбцу таблицы); в таких случаях система автоматически преобразует тип. Однако автоматическое преобразование выполняется только для приведений с пометкой <span class="quote">«<span class="quote">допускается неявное применение</span>»</span> в системных каталогах. Все остальные приведения должны записываться явно. Это ограничение позволяет избежать сюрпризов с неявным преобразованием.</p><p>Также можно записать приведение типа как вызов функции: </p><pre class="synopsis">
<em class="replaceable"><code>имя_типа</code></em> ( <em class="replaceable"><code>выражение</code></em> )
</pre><p> Однако это будет работать только для типов, имена которых являются также допустимыми именами функций. Например, <code class="literal">double precision</code> так использовать нельзя, а <code class="literal">float8</code> (альтернативное название того же типа) — можно. Кроме того, имена типов <code class="literal">interval</code>, <code class="literal">time</code> и <code class="literal">timestamp</code> из-за синтаксического конфликта можно использовать в такой записи только в кавычках. Таким образом, запись приведения типа в виде вызова функции провоцирует несоответствия и, возможно, лучше будет её не применять.</p><div class="note"><h3 class="title">Примечание</h3><p>Приведение типа, представленное в виде вызова функции, на самом деле соответствует внутреннему механизму. Даже при использовании двух стандартных типов записи внутри происходит вызов зарегистрированной функции, выполняющей преобразование. По соглашению именем такой функции преобразования является имя выходного типа, и таким образом запись <span class="quote">«<span class="quote">в виде вызова функции</span>»</span> есть не что иное, как прямой вызов нижележащей функции преобразования. При создании переносимого приложения на это поведение, конечно, не следует рассчитывать. Подробнее это описано в справке <a class="xref" href="sql-createcast.html" title="CREATE CAST"><span class="refentrytitle">CREATE CAST</span></a>.</p></div></div><div class="sect2" id="SQL-SYNTAX-COLLATE-EXPRS"><div class="titlepage"><div><div><h3 class="title">4.2.10. Применение правил сортировки <a href="#SQL-SYNTAX-COLLATE-EXPRS" class="id_link">#</a></h3></div></div></div><a id="id-1.5.3.6.18.2" class="indexterm"></a><p>Предложение <code class="literal">COLLATE</code> переопределяет правило сортировки выражения. Оно добавляется после выражения: </p><pre class="synopsis">
<em class="replaceable"><code>выражение</code></em> COLLATE <em class="replaceable"><code>правило_сортировки</code></em>
</pre><p> где <em class="replaceable"><code>правило_сортировки</code></em> — идентификатор правила, возможно дополненный именем схемы. Предложение <code class="literal">COLLATE</code> связывает выражение сильнее, чем операторы, так что при необходимости следует использовать скобки.</p><p>Если правило сортировки не определено явно, система либо выбирает его по столбцам, которые используются в выражении, либо, если таких столбцов нет, переключается на установленное для базы данных правило сортировки по умолчанию.</p><p>Предложение <code class="literal">COLLATE</code> имеет два распространённых применения: переопределение порядка сортировки в предложении <code class="literal">ORDER BY</code>, например: </p><pre class="programlisting">SELECT a, b, c FROM tbl WHERE ... ORDER BY a COLLATE "C";</pre><p> и переопределение правил сортировки при вызове функций или операторов, возвращающих языкозависимые результаты, например: </p><pre class="programlisting">SELECT * FROM tbl WHERE a &gt; 'foo' COLLATE "C";</pre><p> Заметьте, что в последнем случае предложение <code class="literal">COLLATE</code> добавлено к аргументу оператора, на действие которого мы хотим повлиять. При этом не имеет значения, к какому именно аргументу оператора или функции добавляется <code class="literal">COLLATE</code>, так как правило сортировки, применяемое к оператору или функции, выбирается при рассмотрении всех аргументов, а явное предложение <code class="literal">COLLATE</code> переопределяет правила сортировки для всех других аргументов. (Однако добавление разных предложений <code class="literal">COLLATE</code> к нескольким аргументам будет ошибкой. Подробнее об этом см. <a class="xref" href="collation.html" title="24.2. Поддержка правил сортировки">Раздел 24.2</a>.) Таким образом, эта команда выдаст тот же результат: </p><pre class="programlisting">SELECT * FROM tbl WHERE a COLLATE "C" &gt; 'foo';</pre><p> Но это будет ошибкой: </p><pre class="programlisting">SELECT * FROM tbl WHERE (a &gt; 'foo') COLLATE "C";</pre><p> здесь правило сортировки нельзя применить к результату оператора <code class="literal">&gt;</code>, который имеет несравниваемый тип данных <code class="type">boolean</code>.</p></div><div class="sect2" id="SQL-SYNTAX-SCALAR-SUBQUERIES"><div class="titlepage"><div><div><h3 class="title">4.2.11. Скалярные подзапросы <a href="#SQL-SYNTAX-SCALAR-SUBQUERIES" class="id_link">#</a></h3></div></div></div><a id="id-1.5.3.6.19.2" class="indexterm"></a><p>Скалярный подзапрос — это обычный запрос <code class="command">SELECT</code> в скобках, который возвращает ровно одну строку и один столбец. (Написание запросов освещается в <a class="xref" href="queries.html" title="Глава 7. Запросы">Главе 7</a>.) После выполнения запроса <code class="command">SELECT</code> его единственный результат используется в окружающем его выражении. В качестве скалярного подзапроса нельзя использовать запросы, возвращающие более одной строки или столбца. (Но если в результате выполнения подзапрос не вернёт строк, скалярный результат считается равным NULL.) В подзапросе можно ссылаться на переменные из окружающего запроса; в процессе одного вычисления подзапроса они будут считаться константами. Другие выражения с подзапросами описаны в <a class="xref" href="functions-subquery.html" title="9.23. Выражения подзапросов">Разделе 9.23</a>.</p><p>Например, следующий запрос находит самый населённый город в каждом штате: </p><pre class="programlisting">SELECT name, (SELECT max(pop) FROM cities WHERE cities.state = states.name)
    FROM states;</pre></div><div class="sect2" id="SQL-SYNTAX-ARRAY-CONSTRUCTORS"><div class="titlepage"><div><div><h3 class="title">4.2.12. Конструкторы массивов <a href="#SQL-SYNTAX-ARRAY-CONSTRUCTORS" class="id_link">#</a></h3></div></div></div><a id="id-1.5.3.6.20.2" class="indexterm"></a><a id="id-1.5.3.6.20.3" class="indexterm"></a><p>Конструктор массива — это выражение, которое создаёт массив, определяя значения его элементов. Конструктор простого массива состоит из ключевого слова <code class="literal">ARRAY</code>, открывающей квадратной скобки <code class="literal">[</code>, списка выражений (разделённых запятыми), задающих значения элементов массива, и закрывающей квадратной скобки <code class="literal">]</code>. Например: </p><pre class="programlisting">SELECT ARRAY[1,2,3+4];
  array
---------
 {1,2,7}
(1 row)</pre><p> По умолчанию типом элементов массива считается общий тип для всех выражений, определённый по правилам, действующим и для конструкций <code class="literal">UNION</code> и <code class="literal">CASE</code> (см. <a class="xref" href="typeconv-union-case.html" title="10.5. UNION, CASE и связанные конструкции">Раздел 10.5</a>). Вы можете переопределить его явно, приведя конструктор массива к требуемому типу, например: </p><pre class="programlisting">SELECT ARRAY[1,2,22.7]::integer[];
  array
----------
 {1,2,23}
(1 row)</pre><p> Это равносильно тому, что привести к нужному типу каждое выражение по отдельности. Подробнее приведение типов описано в <a class="xref" href="sql-expressions.html#SQL-SYNTAX-TYPE-CASTS" title="4.2.9. Приведения типов">Подразделе 4.2.9</a>.</p><p>Многомерные массивы можно образовывать, вкладывая конструкторы массивов. При этом во внутренних конструкторах слово <code class="literal">ARRAY</code> можно опускать. Например, результат работы этих конструкторов одинаков: </p><pre class="programlisting">SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)

SELECT ARRAY[[1,2],[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)</pre><p> Многомерные массивы должны быть прямоугольными, и поэтому внутренние конструкторы одного уровня должны создавать вложенные массивы одинаковой размерности. Любое приведение типа, применённое к внешнему конструктору <code class="literal">ARRAY</code>, автоматически распространяется на все внутренние.</p><p>Элементы многомерного массива можно создавать не только вложенными конструкторами <code class="literal">ARRAY</code>, но и другими способами, позволяющими получить массивы нужного типа. Например: </p><pre class="programlisting">CREATE TABLE arr(f1 int[], f2 int[]);

INSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], ARRAY[[5,6],[7,8]]);

SELECT ARRAY[f1, f2, '{{9,10},{11,12}}'::int[]] FROM arr;
                     array
------------------------------------------------
 {{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}}
(1 row)</pre><p>Вы можете создать и пустой массив, но так как массив не может быть не типизированным, вы должны явно привести пустой массив к нужному типу. Например: </p><pre class="programlisting">SELECT ARRAY[]::integer[];
 array
-------
 {}
(1 row)</pre><p>Также возможно создать массив из результатов подзапроса. В этом случае конструктор массива записывается так же с ключевым словом <code class="literal">ARRAY</code>, за которым в круглых скобках следует подзапрос. Например: </p><pre class="programlisting">SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');
                              array
------------------------------------------------------------------
 {2011,1954,1948,1952,1951,1244,1950,2005,1949,1953,2006,31,2412}
(1 row)

SELECT ARRAY(SELECT ARRAY[i, i*2] FROM generate_series(1,5) AS a(i));
              array
----------------------------------
 {{1,2},{2,4},{3,6},{4,8},{5,10}}
(1 row)</pre><p> Такой подзапрос должен возвращать один столбец. Если этот столбец имеет тип, отличный от массива, результирующий одномерный массив будет включать элементы для каждой строки-результата подзапроса и типом элемента будет тип столбца результата. Если же тип столбца — массив, будет создан массив того же типа, но большей размерности; в любом случае во всех строках подзапроса должны выдаваться массивы одинаковой размерности, чтобы можно было получить прямоугольный результат.</p><p>Индексы массива, созданного конструктором <code class="literal">ARRAY</code>, всегда начинаются с одного. Подробнее о массивах вы узнаете в <a class="xref" href="arrays.html" title="8.15. Массивы">Разделе 8.15</a>.</p></div><div class="sect2" id="SQL-SYNTAX-ROW-CONSTRUCTORS"><div class="titlepage"><div><div><h3 class="title">4.2.13. Конструкторы табличных строк <a href="#SQL-SYNTAX-ROW-CONSTRUCTORS" class="id_link">#</a></h3></div></div></div><a id="id-1.5.3.6.21.2" class="indexterm"></a><a id="id-1.5.3.6.21.3" class="indexterm"></a><a id="id-1.5.3.6.21.4" class="indexterm"></a><p>Конструктор табличной строки — это выражение, создающее строку или кортеж (или составное значение) из значений его аргументов-полей. Конструктор строки состоит из ключевого слова <code class="literal">ROW</code>, открывающей круглой скобки, нескольких выражений (разделённых запятыми), определяющих значения полей, и закрывающей скобки. При этом выражения могут отсутствовать, то есть конструктор имеет вид ROW(). Например: </p><pre class="programlisting">SELECT ROW(1,2.5,'this is a test');</pre><p> Если в списке более одного выражения, ключевое слово <code class="literal">ROW</code> можно опустить.</p><p>Конструктор строки поддерживает запись <em class="replaceable"><code>составное_значение</code></em><code class="literal">.*</code>, при этом данное значение будет развёрнуто в список элементов, так же, как в записи <code class="literal">.*</code> на верхнем уровне списка <code class="command">SELECT</code> (см. <a class="xref" href="rowtypes.html#ROWTYPES-USAGE" title="8.16.5. Использование составных типов в запросах">Подраздел 8.16.5</a>). Например, если таблица <code class="literal">t</code> содержит столбцы <code class="literal">f1</code> и <code class="literal">f2</code>, эти записи равнозначны: </p><pre class="programlisting">SELECT ROW(t.*, 42) FROM t;
SELECT ROW(t.f1, t.f2, 42) FROM t;</pre><div class="note"><h3 class="title">Примечание</h3><p>До версии <span class="productname">PostgreSQL</span> 8.2 запись <code class="literal">.*</code> не разворачивалась в конструкторах строк, так что выражение <code class="literal">ROW(t.*, 42)</code> создавало составное значение из двух полей, в котором первое поле так же было составным. Новое поведение обычно более полезно. Если вам нужно получить прежнее поведение, чтобы одно значение строки было вложено в другое, напишите внутреннее значение без <code class="literal">.*</code>, например: <code class="literal">ROW(t, 42)</code>.</p></div><p>По умолчанию значение, созданное выражением <code class="literal">ROW</code>, имеет тип анонимной записи. Если необходимо, его можно привести к именованному составному типу — либо к типу строки таблицы, либо составному типу, созданному оператором <code class="command">CREATE TYPE AS</code>. Явное приведение может потребоваться для достижения однозначности. Например: </p><pre class="programlisting">CREATE TABLE mytable(f1 int, f2 float, f3 text);

CREATE FUNCTION getf1(mytable) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

-- Приведение не требуется, так как существует только одна getf1()
SELECT getf1(ROW(1,2.5,'this is a test'));
 getf1
-------
     1
(1 row)

CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);

CREATE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

-- Теперь приведение необходимо для однозначного выбора функции:
SELECT getf1(ROW(1,2.5,'this is a test'));
ОШИБКА:  функция getf1(record) не уникальна

SELECT getf1(ROW(1,2.5,'this is a test')::mytable);
 getf1
-------
     1
(1 row)

SELECT getf1(CAST(ROW(11,'this is a test',2.5) AS myrowtype));
 getf1
-------
    11
(1 row)</pre><p>Используя конструктор строк (кортежей), можно создавать составное значение для сохранения в столбце составного типа или для передачи функции, принимающей составной параметр. Также вы можете сравнить два составных значения или проверить их с помощью <code class="literal">IS NULL</code> или <code class="literal">IS NOT NULL</code>, например: </p><pre class="programlisting">SELECT ROW(1,2.5,'this is a test') = ROW(1, 3, 'not the same');

  -- выбрать все строки, содержащие только NULL
SELECT ROW(table.*) IS NULL FROM table;</pre><p> Подробнее см. <a class="xref" href="functions-comparisons.html" title="9.24. Сравнение табличных строк и массивов">Раздел 9.24</a>. Конструкторы строк также могут использоваться в сочетании с подзапросами, как описано в <a class="xref" href="functions-subquery.html" title="9.23. Выражения подзапросов">Разделе 9.23</a>.</p></div><div class="sect2" id="SYNTAX-EXPRESS-EVAL"><div class="titlepage"><div><div><h3 class="title">4.2.14. Правила вычисления выражений <a href="#SYNTAX-EXPRESS-EVAL" class="id_link">#</a></h3></div></div></div><a id="id-1.5.3.6.22.2" class="indexterm"></a><p>Порядок вычисления подвыражений не определён. В частности, аргументы оператора или функции не обязательно вычисляются слева направо или в любом другом фиксированном порядке.</p><p>Более того, если результат выражения можно получить, вычисляя только некоторые его части, тогда другие подвыражения не будут вычисляться вовсе. Например, если написать: </p><pre class="programlisting">SELECT true OR somefunc();</pre><p> тогда функция <code class="literal">somefunc()</code> не будет вызываться (возможно). То же самое справедливо для записи: </p><pre class="programlisting">SELECT somefunc() OR true;</pre><p> Заметьте, что это отличается от <span class="quote">«<span class="quote">оптимизации</span>»</span> вычисления логических операторов слева направо, реализованной в некоторых языках программирования.</p><p>Как следствие, в сложных выражениях не стоит использовать функции с побочными эффектами. Особенно опасно рассчитывать на порядок вычисления или побочные эффекты в предложениях <code class="literal">WHERE</code> и <code class="literal">HAVING</code>, так как эти предложения тщательно оптимизируются при построении плана выполнения. Логические выражения (сочетания <code class="literal">AND</code>/<code class="literal">OR</code>/<code class="literal">NOT</code>) в этих предложениях могут быть видоизменены любым способом, допустимым законами Булевой алгебры.</p><p>Когда порядок вычисления важен, его можно зафиксировать с помощью конструкции <code class="literal">CASE</code> (см. <a class="xref" href="functions-conditional.html" title="9.18. Условные выражения">Раздел 9.18</a>). Например, такой способ избежать деления на ноль в предложении <code class="literal">WHERE</code> ненадёжен: </p><pre class="programlisting">SELECT ... WHERE x &gt; 0 AND y/x &gt; 1.5;</pre><p> Безопасный вариант: </p><pre class="programlisting">SELECT ... WHERE CASE WHEN x &gt; 0 THEN y/x &gt; 1.5 ELSE false END;</pre><p> Применяемая так конструкция <code class="literal">CASE</code> защищает выражение от оптимизации, поэтому использовать её нужно только при необходимости. (В данном случае было бы лучше решить проблему, переписав условие как <code class="literal">y &gt; 1.5*x</code>.)</p><p>Однако <code class="literal">CASE</code> не всегда спасает в подобных случаях. Показанный выше приём плох тем, что не предотвращает раннее вычисление константных подвыражений. Как описано в <a class="xref" href="xfunc-volatility.html" title="38.7. Категории изменчивости функций">Разделе 38.7</a>, функции и операторы, помеченные как <code class="literal">IMMUTABLE</code>, могут вычисляться при планировании, а не выполнении запроса. Поэтому в примере </p><pre class="programlisting">SELECT CASE WHEN x &gt; 0 THEN x ELSE 1/0 END FROM tab;</pre><p>, скорее всего, произойдёт деление на ноль из-за того, что планировщик попытается упростить константное подвыражение, даже если во всех строках в таблице <code class="literal">x &gt; 0</code>, а значит во время выполнения ветвь <code class="literal">ELSE</code> никогда не будет выполняться.</p><p>Хотя этот конкретный пример может показаться надуманным, похожие ситуации, в которых неявно появляются константы, могут возникать и в запросах внутри функций, так как значения аргументов функции и локальных переменных при планировании могут быть заменены константами. Поэтому, например, в функциях <span class="application">PL/pgSQL</span> гораздо безопаснее для защиты от рискованных вычислений использовать конструкцию <code class="literal">IF</code>-<code class="literal">THEN</code>-<code class="literal">ELSE</code>, чем выражение <code class="literal">CASE</code>.</p><p>Ещё один подобный недостаток этого подхода в том, что <code class="literal">CASE</code> не может предотвратить вычисление заключённого в нём агрегатного выражения, так как агрегатные выражения вычисляются перед всеми остальными в списке <code class="literal">SELECT</code> или предложении <code class="literal">HAVING</code>. Например, в следующем запросе может возникнуть ошибка деления на ноль, несмотря на то, что он вроде бы защищён от неё: </p><pre class="programlisting">SELECT CASE WHEN min(employees) &gt; 0
            THEN avg(expenses / employees)
       END
    FROM departments;</pre><p> Агрегатные функции <code class="function">min()</code> и <code class="function">avg()</code> вычисляются независимо по всем входным строкам, так что если в какой-то строке поле <code class="structfield">employees</code> окажется равным нулю, деление на ноль произойдёт раньше, чем станет возможным проверить результат функции <code class="function">min()</code>. Поэтому, чтобы проблемные входные строки изначально не попали в агрегатную функцию, следует воспользоваться предложениями <code class="literal">WHERE</code> или <code class="literal">FILTER</code>.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-syntax-lexical.html" title="4.1. Лексическая структура">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-syntax.html" title="Глава 4. Синтаксис SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-syntax-calling-funcs.html" title="4.3. Вызов функций">След.</a></td></tr><tr><td width="40%" align="left" valign="top">4.1. Лексическая структура </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 4.3. Вызов функций</td></tr></table></div></body></html>