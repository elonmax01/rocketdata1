<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>LOCK</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sql-load.html" title="LOAD" /><link rel="next" href="sql-merge.html" title="MERGE" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">LOCK</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-load.html" title="LOAD">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><th width="60%" align="center">Команды SQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-merge.html" title="MERGE">След.</a></td></tr></table><hr /></div><div class="refentry" id="SQL-LOCK"><div class="titlepage"></div><a id="id-1.9.3.155.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">LOCK</span></h2><p>LOCK — заблокировать таблицу</p></div><div class="refsynopsisdiv"><h2>Синтаксис</h2><pre class="synopsis">LOCK [ TABLE ] [ ONLY ] <em class="replaceable"><code>имя</code></em> [ * ] [, ...] [ IN <em class="replaceable"><code>режим_блокировки</code></em> MODE ] [ NOWAIT ]

<span class="phrase">Где <em class="replaceable"><code>режим_блокировки</code></em> может быть следующим:</span>

    ACCESS SHARE | ROW SHARE | ROW EXCLUSIVE | SHARE UPDATE EXCLUSIVE
    | SHARE | SHARE ROW EXCLUSIVE | EXCLUSIVE | ACCESS EXCLUSIVE</pre></div><div class="refsect1" id="id-1.9.3.155.5"><h2>Описание</h2><p><code class="command">LOCK TABLE</code> получает блокировку на уровне таблицы, при необходимости ожидая освобождения таблицы от других конфликтующих блокировок. Если указано <code class="literal">NOWAIT</code>, <code class="command">LOCK TABLE</code> не ждёт, пока таблица освободится: если блокировку нельзя получить немедленно, команда прерывается и выдаётся ошибка. Как только блокировка получена, она удерживается до завершения текущей транзакции. (Команды <code class="command">UNLOCK TABLE</code> не существует; блокировки всегда освобождаются в конце транзакции.)</p><p>Когда блокируется представление, блокировка с тем же режимом рекурсивно распределяется на все отношения, фигурирующие в определяющем представление запросе.</p><p>Запрашивая автоматические блокировки для команд, работающих с таблицами, <span class="productname">PostgreSQL</span> всегда выбирает наименее ограничивающий режим блокировки из возможных. Оператор <code class="command">LOCK TABLE</code> предназначен для случаев, когда требуется более сильная блокировка. Например, предположим, что приложение выполняет транзакцию на уровне изоляции <code class="literal">READ COMMITTED</code> и оно должно получать неизменные данные на протяжении всей транзакции. Для достижения этой цели можно получить для таблицы блокировку в режиме <code class="literal">SHARE</code>, прежде чем обращаться к ней. В результате параллельные изменения данных будут исключены и при последующих чтениях будет получено стабильное представление зафиксированных данных, так как режим блокировки <code class="literal">SHARE</code> конфликтует с блокировкой <code class="literal">ROW EXCLUSIVE</code>, запрашиваемой при записи, а <code class="command">LOCK TABLE <em class="replaceable"><code>имя</code></em> IN SHARE MODE</code> будет ждать, пока параллельные транзакции с блокировкой <code class="literal">ROW EXCLUSIVE</code> не будут зафиксированы или отменены. Таким образом, в момент получения такой блокировки не останется ни одной открытой незафиксированной операции записи; кроме того, никто не сможет записывать в таблицу, пока блокировка не будет снята.</p><p>Чтобы получить похожий эффект в транзакции на уровне изоляции <code class="literal">REPEATABLE READ</code> или <code class="literal">SERIALIZABLE</code>, необходимо выполнить оператор <code class="command">LOCK TABLE</code> перед первым <code class="command">SELECT</code> или оператором, изменяющим данные. Представление данных для транзакции уровня <code class="literal">REPEATABLE READ</code> или <code class="literal">SERIALIZABLE</code> будет заморожено в момент, когда начнёт выполняться этот запрос. Если команда <code class="command">LOCK TABLE</code> выполняется в транзакции позже, она так же исключает параллельную запись, но не даёт гарантии, что транзакция будет читать последние зафиксированные данные.</p><p>Если в транзакции такого рода требуется изменять данные в таблице, для неё следует использовать режим блокировки <code class="literal">SHARE ROW EXCLUSIVE</code> вместо <code class="literal">SHARE</code>. Этот режим гарантирует, что в один момент времени будет выполняться только одна транзакция такого типа. Без этого ограничения возможна взаимоблокировка: две транзакции могут одновременно получить блокировки <code class="literal">SHARE</code>, после чего они не смогут получить блокировку <code class="literal">ROW EXCLUSIVE</code>, чтобы собственно выполнить изменения. (Заметьте, что собственные блокировки транзакции никогда не конфликтуют, так что транзакция может получить блокировку <code class="literal">ROW EXCLUSIVE</code>, когда она владеет блокировкой <code class="literal">SHARE</code> — но не тогда, когда блокировку <code class="literal">SHARE</code> удерживает другая транзакция.) Чтобы не допустить взаимоблокировок, убедитесь, что все транзакции запрашивают блокировки одних объектов в одинаковом порядке, и если для одного объекта запрашиваются блокировки в разных режимах, транзакции всегда должны запрашивать самую строгую блокировку.</p><p>Дополнительно о режимах и стратегиях блокировки можно узнать в <a class="xref" href="explicit-locking.html" title="13.3. Явные блокировки">Разделе 13.3</a>.</p></div><div class="refsect1" id="id-1.9.3.155.6"><h2>Параметры</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>имя</code></em></span></dt><dd><p>Имя (возможно, дополненное схемой) существующей таблицы, для которой запрашивается блокировка. Если перед именем таблицы указано <code class="literal">ONLY</code>, блокируется только заданная таблица. Без <code class="literal">ONLY</code> блокируется и заданная таблица, и все её потомки (если таковые есть). После имени таблицы можно также добавить необязательное указание <code class="literal">*</code>, чтобы явно обозначить, что блокировка затрагивает и все дочерние таблицы.</p><p>Команда <code class="literal">LOCK TABLE a, b;</code> равнозначна последовательности <code class="literal">LOCK TABLE a; LOCK TABLE b;</code>. Таблицы блокируются по одной в порядке, заданном в команде <code class="command">LOCK TABLE</code>.</p></dd><dt><span class="term"><em class="replaceable"><code>режим_блокировки</code></em></span></dt><dd><p>Режим блокировки определяет, с какой блокировкой будет конфликтовать данная. Режимы блокировок описаны в <a class="xref" href="explicit-locking.html" title="13.3. Явные блокировки">Разделе 13.3</a>.</p><p>Если режим блокировки не указан, применяется самый строгий режим, <code class="literal">ACCESS EXCLUSIVE</code>.</p></dd><dt><span class="term"><code class="literal">NOWAIT</code></span></dt><dd><p>Указывает, что <code class="command">LOCK TABLE</code> не должна ожидать освобождения конфликтующих блокировок: если запрошенная блокировка не может быть получена немедленно, транзакция прерывается.</p></dd></dl></div></div><div class="refsect1" id="id-1.9.3.155.7"><h2>Замечания</h2><p>Чтобы заблокировать таблицу, используя <em class="replaceable"><code>режимы_блокировки</code></em>, необходимо либо иметь определённые права, либо быть владельцем таблицы или суперпользователем. Если у пользователя есть право <code class="literal">UPDATE</code>, <code class="literal">DELETE</code> или <code class="literal">TRUNCATE</code> для таблицы, может использоваться любой <em class="replaceable"><code>режим_блокировки</code></em>. Если у пользователя есть право <code class="literal">INSERT</code> для таблицы, допускается <code class="literal">ROW EXCLUSIVE MODE</code> (или менее конфликтующий режим, что описано в <a class="xref" href="explicit-locking.html" title="13.3. Явные блокировки">Разделе 13.3</a>). Если у пользователя есть право <code class="literal">SELECT</code> для таблицы, допускается <code class="literal">ACCESS SHARE MODE</code>.</p><p>Пользователь, выполняющий операцию блокировки представления, должен иметь соответствующее право для этого представления. Кроме того, владелец представления должен иметь сопутствующие права в нижележащих базовых отношениях, хотя пользователь, устанавливающий блокировку, может этих прав не иметь. Однако если для свойства представления <code class="literal">security_invoker</code> установлено значение <code class="literal">true</code> (см. <a class="link" href="sql-createview.html" title="CREATE VIEW"><code class="command">CREATE VIEW</code></a>), соответствующие права для нижележащих базовых отношений должен иметь пользователь, устанавливающий блокировку, а не владелец представления.</p><p>Вне блока транзакции команда <code class="command">LOCK TABLE</code> бесполезна: блокировка сохранится только до завершения операции. Поэтому <span class="productname">PostgreSQL</span> выдаёт ошибку при попытке применить <code class="command">LOCK</code> не в блоке транзакции. Чтобы определить блок транзакции, используйте <a class="link" href="sql-begin.html" title="BEGIN"><code class="command">BEGIN</code></a> и <a class="link" href="sql-commit.html" title="COMMIT"><code class="command">COMMIT</code></a> (или <a class="link" href="sql-rollback.html" title="ROLLBACK"><code class="command">ROLLBACK</code></a>).</p><p><code class="command">LOCK TABLE</code> может устанавливать только блокировки на уровне таблицы, так что все имена режимов, включающие слово <code class="literal">ROW</code> (строка), не совсем корректны. Следует воспринимать их так, что в этих режимах пользователь намеревается получать в заблокированной таблице блокировки уровня строк. Также учтите, что в режиме <code class="literal">ROW EXCLUSIVE</code> устанавливается разделяемая блокировка таблицы. Заметьте, что применительно к <code class="command">LOCK TABLE</code> все режимы блокировки действуют одинаково, отличаются только правила, определяющие, какой режим с каким конфликтует. Чтобы узнать, как получить блокировку именно на уровне строк, обратитесь к <a class="xref" href="explicit-locking.html#LOCKING-ROWS" title="13.3.2. Блокировки на уровне строк">Подразделу 13.3.2</a> и разделу <a class="xref" href="sql-select.html#SQL-FOR-UPDATE-SHARE" title="Предложение блокировки">Предложение блокировки</a> в описании <a class="xref" href="sql-select.html" title="SELECT"><span class="refentrytitle">SELECT</span></a>.</p></div><div class="refsect1" id="id-1.9.3.155.8"><h2>Примеры</h2><p>Получение блокировки <code class="literal">SHARE</code> для первичного ключа таблицы при добавлении записи в подчинённую таблицу: </p><pre class="programlisting">BEGIN WORK;
LOCK TABLE films IN SHARE MODE;
SELECT id FROM films
    WHERE name = 'Star Wars: Episode I - The Phantom Menace';
-- Если запись не будет возвращена, произойдёт откат транзакции
INSERT INTO films_user_comments VALUES
    (_id_, 'GREAT! I was waiting for it for so long!');
COMMIT WORK;</pre><p>Установление блокировки <code class="literal">SHARE ROW EXCLUSIVE</code> в таблице первичного ключа перед выполнением операции удаления: </p><pre class="programlisting">BEGIN WORK;
LOCK TABLE films IN SHARE ROW EXCLUSIVE MODE;
DELETE FROM films_user_comments WHERE id IN
    (SELECT id FROM films WHERE rating &lt; 5);
DELETE FROM films WHERE rating &lt; 5;
COMMIT WORK;</pre></div><div class="refsect1" id="id-1.9.3.155.9"><h2>Совместимость</h2><p>Команда <code class="command">LOCK TABLE</code> отсутствует в стандарте SQL, в нём уровни изоляции транзакции определяются командой <code class="command">SET TRANSACTION</code>. <span class="productname">PostgreSQL</span> поддерживает и этот вариант; подробнее это описано в <a class="xref" href="sql-set-transaction.html" title="SET TRANSACTION"><span class="refentrytitle">SET TRANSACTION</span></a>.</p><p>За исключением <code class="literal">ACCESS SHARE</code>, <code class="literal">ACCESS EXCLUSIVE</code> и <code class="literal">SHARE UPDATE EXCLUSIVE</code>, режимы блокировки в <span class="productname">PostgreSQL</span> и синтаксис <code class="command">LOCK TABLE</code> совместимы с теми, что представлены в СУБД <span class="productname">Oracle</span>.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-load.html" title="LOAD">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-merge.html" title="MERGE">След.</a></td></tr><tr><td width="40%" align="left" valign="top">LOAD </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> MERGE</td></tr></table></div></body></html>