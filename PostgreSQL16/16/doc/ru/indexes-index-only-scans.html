<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>11.9. Сканирование только индекса и покрывающие индексы</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="indexes-partial.html" title="11.8. Частичные индексы" /><link rel="next" href="indexes-opclass.html" title="11.10. Семейства и классы операторов" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">11.9. Сканирование только индекса и покрывающие индексы</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="indexes-partial.html" title="11.8. Частичные индексы">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="indexes.html" title="Глава 11. Индексы">Наверх</a></td><th width="60%" align="center">Глава 11. Индексы</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="indexes-opclass.html" title="11.10. Семейства и классы операторов">След.</a></td></tr></table><hr /></div><div class="sect1" id="INDEXES-INDEX-ONLY-SCANS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">11.9. Сканирование только индекса и покрывающие индексы <a href="#INDEXES-INDEX-ONLY-SCANS" class="id_link">#</a></h2></div></div></div><a id="id-1.5.10.12.2" class="indexterm"></a><a id="id-1.5.10.12.3" class="indexterm"></a><a id="id-1.5.10.12.4" class="indexterm"></a><a id="id-1.5.10.12.5" class="indexterm"></a><p>Все индексы в <span class="productname">PostgreSQL</span> являются <em class="firstterm">вторичными</em>, что значит, что каждый индекс хранится вне области основных данных таблицы (которая в терминологии <span class="productname">PostgreSQL</span> называется <em class="firstterm">кучей</em> таблицы). Это значит, что при обычном сканировании индекса для извлечения каждой строки необходимо прочитать данные и из индекса, и из кучи. Более того, тогда как элементы индекса, соответствующие заданному условию <code class="literal">WHERE</code>, обычно находятся в индексе рядом, строки таблицы могут располагаться в куче произвольным образом. Таким образом, обращение к куче при поиске по индексу влечёт множество операций произвольного чтения кучи, которые могут обойтись недёшево, особенно на традиционных вращающихся носителях. (Как описано в <a class="xref" href="indexes-bitmap-scans.html" title="11.5. Объединение нескольких индексов">Разделе 11.5</a>, сканирование по битовой карте пытается снизить стоимость этих операций, упорядочивая доступ к куче, но не более того.)</p><p>Чтобы решить эту проблему с производительностью, <span class="productname">PostgreSQL</span> поддерживает <em class="firstterm">сканирование только индекса</em>, при котором результат запроса может быть получен из самого индекса, без обращения к куче. Основная идея такого сканирования в том, чтобы выдавать значения непосредственно из элемента индекса, и не обращаться к соответствующей записи в куче. Для применения этого метода есть два фундаментальных ограничения: </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Тип индекса должен поддерживать сканирование только индекса. Индексы-B-деревья поддерживают его всегда. Индексы GiST и SP-GiST могут поддерживать его с одними классами операторов и не поддерживать с другими. Другие индексы такое сканирование не поддерживают. Суть нижележащего требования в том, что индекс должен физически хранить или каким-то образом восстанавливать исходное значение данных для каждого элемента индекса. В качестве контрпримера, индексы GIN неспособны поддерживать сканирование только индекса, так как в элементах индекса обычно хранится только часть исходного значения данных.</p></li><li class="listitem"><p>Запрос должен обращаться только к столбцам, сохранённым в индексе. Например, если в таблице построен индекс по столбцам <code class="literal">x</code> и <code class="literal">y</code>, и в ней есть также столбец <code class="literal">z</code>, такие запросы будут использовать сканирование только индекса: </p><pre class="programlisting">SELECT x, y FROM tab WHERE x = 'key';
SELECT x FROM tab WHERE x = 'key' AND y &lt; 42;</pre><p> А эти запросы не будут: </p><pre class="programlisting">SELECT x, z FROM tab WHERE x = 'key';
SELECT x FROM tab WHERE x = 'key' AND z &lt; 42;</pre><p> (Индексы по выражениям и частичные индексы усложняют это правило, как описано ниже.)</p></li></ol></div><p>Если два этих фундаментальных ограничения выполняются, то все данные, требуемые для выполнения запроса, содержатся в индексе, так что сканирование только по индексу физически возможно. Но в <span class="productname">PostgreSQL</span> существует и ещё одно требование для сканирования таблицы: необходимо убедиться, что все возвращаемые строки <span class="quote">«<span class="quote">видны</span>»</span> в снимке MVCC запроса, как описано в <a class="xref" href="mvcc.html" title="Глава 13. Управление конкурентным доступом">Главе 13</a>. Информация о видимости хранится не в элементах индекса, а только в куче; поэтому на первый взгляд может показаться, что для получения данных каждой строки всё равно необходимо обращаться к куче. И это в самом деле так, если в таблице недавно произошли изменения. Однако для редко меняющихся данных есть возможность обойти эту проблему. <span class="productname">PostgreSQL</span> отслеживает для каждой страницы в куче таблицы, являются ли все строки в этой странице достаточно старыми, чтобы их видели все текущие и будущие транзакции. Это отражается в битах в <em class="firstterm">карте видимости</em> таблицы. Процедура сканирования только индекса, найдя потенциально подходящую запись в индексе, проверяет бит в карте видимости для соответствующей страницы в куче. Если он установлен, значит эта строка видна, и данные могут быть возвращены сразу. В противном случае придётся посетить запись строки в куче и проверить, видима ли она, так что никакого выигрыша по сравнению с обычным сканированием индекса не будет. И даже в благоприятном случае обращение к куче не исключается совсем, а заменяется обращением к карте видимости; но так как карта видимости на четыре порядка меньше соответствующей ей области кучи, для работы с ней требуется много меньше операций физического ввода/вывода. В большинстве ситуаций карта видимости просто всё время находится в памяти.</p><p>Таким образом, тогда как сканирование только по индексу возможно лишь при выполнении двух фундаментальных требований, оно даст выигрыш, только если для значительной части страниц в куче таблицы установлены биты полной видимости. Но таблицы, в которых меняется лишь небольшая часть строк, встречаются достаточно часто, чтобы этот тип сканирования был весьма полезен на практике.</p><p><a id="id-1.5.10.12.10.1" class="indexterm"></a> Чтобы эффективно использовать возможность сканирования только индекса, вы можете создавать <em class="firstterm">покрывающие индексы</em>. Такие индексы специально предназначены для включения столбцов, которые требуются в определённых часто выполняемых запросах. Так как в запросах обычно нужно получить не только столбцы, по которым выполняется поиск, <span class="productname">PostgreSQL</span> позволяет создать индекс, в котором некоторые столбцы будут просто <span class="quote">«<span class="quote">дополнительной нагрузкой</span>»</span>, но не войдут в поисковый ключ. Это реализуется предложением <code class="literal">INCLUDE</code>, в котором перечисляются дополнительные столбцы. Например, если часто выполняется запрос вида </p><pre class="programlisting">SELECT y FROM tab WHERE x = 'key';</pre><p> при традиционном подходе его можно ускорить, создав индекс только по <code class="literal">x</code>. Однако такой индекс: </p><pre class="programlisting">CREATE INDEX tab_x_y ON tab(x) INCLUDE (y);</pre><p> может удовлетворить такие запросы при сканировании только индекса, так как значение <code class="literal">y</code> можно получить из индекса, не обращаясь к данным в куче.</p><p>Так как столбец <code class="literal">y</code> не является частью поискового ключа, он не обязательно должен иметь тип данных, воспринимаемый данным индексом; он просто сохраняется внутри индекса и никак не обрабатывается механизмом индекса. Кроме того, в случае с уникальным индексом, например: </p><pre class="programlisting">CREATE UNIQUE INDEX tab_x_y ON tab(x) INCLUDE (y);</pre><p> условие уникальности распространяется только на столбец <code class="literal">x</code>, а не на <code class="literal">x</code> и <code class="literal">y</code> в совокупности. (Предложение <code class="literal">INCLUDE</code> можно также добавить в ограничения <code class="literal">UNIQUE</code> и <code class="literal">PRIMARY KEY</code>, что позволяет определить такой индекс альтернативным образом.)</p><p>Добавлять в индекс неключевые дополнительные столбцы следует обдуманно, особенно когда это большие столбцы. Если размер кортежа в индексе превысит максимально допустимый размер для типа индексов, при добавлении данных возникнет ошибка. В любом случае в неключевых столбцах дублируются данные из самой таблицы, что приводит к раздуванию индекса, а следствием этого может быть замедление запросов. И помните, что практический смысл включать дополнительные столбцы в индекс есть только тогда, когда таблица меняется достаточно медленно, и при сканировании только индекса не приходится обращаться к куче. Если кортеж в любом случае придётся прочитывать из кучи, получить значение столбца из него ничего не стоит. Покрывающие индексы имеют и другие ограничения: в настоящее время в качестве неключевых столбцов нельзя задать выражения, и поддерживаются такие индексы только трёх типов: B-деревья, GiST и SP-GIST.</p><p>До появления в <span class="productname">PostgreSQL</span> покрывающих индексов (<code class="literal">INCLUDE</code>) пользователям иногда приходилось задействовать дополнительные столбцы как обычные столбцы индекса, то есть писать </p><pre class="programlisting">CREATE INDEX tab_x_y ON tab(x, y);</pre><p> даже не намереваясь когда-либо использовать <code class="literal">y</code> в предложении <code class="literal">WHERE</code>. Это работает, когда дополнительные столбцы добавляются в конец; делать их начальными неразумно по причинам, описанным в <a class="xref" href="indexes-multicolumn.html" title="11.3. Составные индексы">Разделе 11.3</a>. Однако этот подход не годится для случая, когда вам нужно обеспечить уникальность ключевого столбца (столбцов).</p><p>В процессе <em class="firstterm">усечения суффикса</em> с верхних уровней B-дерева всегда удаляются неключевые столбцы. Так как они содержат дополнительную нагрузку, они никогда не управляют поиском по индексу. В этом процессе также удаляется один или несколько замыкающих столбцов, если остающегося префикса ключевых столбцов оказывается достаточно, чтобы описать кортежи на нижележащем уровне B-дерева. На практике и в покрывающих индексах без предложения <code class="literal">INCLUDE</code> часто удаётся избежать хранения столбцов, которые вверху по сути являются допнагрузкой. Однако явное обозначение дополнительных столбцов неключевыми <span class="emphasis"><em>гарантирует</em></span> минимальный размер кортежей на верхних уровнях.</p><p>В принципе сканирование только индекса может применяться и с индексами по выражениям. Например, при наличии индекса по <code class="literal">f(x)</code>, где <code class="literal">x</code> — столбец таблицы, должно быть возможно выполнить </p><pre class="programlisting">SELECT f(x) FROM tab WHERE f(x) &lt; 1;</pre><p> как сканирование только индекса; и это очень заманчиво, если <code class="literal">f()</code> — сложная для вычисления функция. Однако планировщик <span class="productname">PostgreSQL</span> в настоящее время может вести себя не очень разумно. Он считает, что запрос может выполняться со сканированием только индекса, лишь когда из индекса могут быть получены все <span class="emphasis"><em>столбцы</em></span>, требующиеся для запроса. В этом примере <code class="literal">x</code> фигурирует только в контексте <code class="literal">f(x)</code>, но планировщик не замечает этого и решает, что сканирование только по индексу невозможно. Если сканирование только индекса заслуживает того, эту проблему можно обойти, добавив <code class="literal">x</code> как неключевой столбец, например: </p><pre class="programlisting">CREATE INDEX tab_f_x ON tab (f(x)) INCLUDE (x);</pre><p> Если это делается ради предотвращения многократных вычислений <code class="literal">f(x)</code>, следует также учесть, что планировщик не обязательно свяжет упоминания <code class="literal">f(x)</code>, фигурирующие вне индексируемых предложений <code class="literal">WHERE</code>, со столбцом индекса. Обычно он делает это правильно в простых запросах, вроде показанного выше, но не в запросах с соединениями. Эти недостатки могут быть устранены в будущих версиях <span class="productname">PostgreSQL</span>.</p><p>С использованием частичных индексов при сканировании только по индексу тоже связаны интересные особенности. Предположим, что у нас есть частичный индекс, показанный в <a class="xref" href="indexes-partial.html#INDEXES-PARTIAL-EX3" title="Пример 11.3. Настройка частичного уникального индекса">Примере 11.3</a>: </p><pre class="programlisting">CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)
    WHERE success;</pre><p> В принципе с ним мы можем произвести сканирование только по индексу при выполнении запроса </p><pre class="programlisting">SELECT target FROM tests WHERE subject = 'some-subject' AND success;</pre><p> Но есть одна проблема: предложение <code class="literal">WHERE</code> обращается к столбцу <code class="literal">success</code>, который отсутствует в результирующих столбцах индекса. Тем не менее сканирование только индекса возможно, так как плану не нужно перепроверять эту часть предложения <code class="literal">WHERE</code> во время выполнения: у всех записей, найденных в индексе, значение <code class="literal">success = true</code>, так что в плане его не нужно проверять явно. <span class="productname">PostgreSQL</span> версий 9.6 и новее распознает такую ситуацию и сможет произвести сканирование только по индексу, но старые версии неспособны на это.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="indexes-partial.html" title="11.8. Частичные индексы">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="indexes.html" title="Глава 11. Индексы">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="indexes-opclass.html" title="11.10. Семейства и классы операторов">След.</a></td></tr><tr><td width="40%" align="left" valign="top">11.8. Частичные индексы </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 11.10. Семейства и классы операторов</td></tr></table></div></body></html>