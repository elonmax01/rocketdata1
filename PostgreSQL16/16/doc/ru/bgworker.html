<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Глава 48. Фоновые рабочие процессы</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="spi-spi-start-transaction.html" title="SPI_start_transaction" /><link rel="next" href="logicaldecoding.html" title="Глава 49. Логическое декодирование" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">Глава 48. Фоновые рабочие процессы</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="spi-spi-start-transaction.html" title="SPI_start_transaction">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="server-programming.html" title="Часть V. Серверное программирование">Наверх</a></td><th width="60%" align="center">Часть V. Серверное программирование</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="logicaldecoding.html" title="Глава 49. Логическое декодирование">След.</a></td></tr></table><hr /></div><div class="chapter" id="BGWORKER"><div class="titlepage"><div><div><h2 class="title">Глава 48. Фоновые рабочие процессы</h2></div></div></div><a id="id-1.8.13.2" class="indexterm"></a><p>PostgreSQL поддерживает расширенную возможность запускать пользовательский код в отдельных процессах. Такие процессы запускаются, останавливаются и контролируются главным процессом <code class="command">postgres</code>, который позволяет тесно связать их жизненный цикл с состоянием сервера. Эти процессы получают доступ к области разделяемой памяти <span class="productname">PostgreSQL</span> и могут устанавливать внутренние подключения к базам данных; они также могут последовательно запускать транзакции, как и обычные серверные процессы, обслуживающие клиентов. Кроме того, используя <span class="application">libpq</span>, они могут подключаться к серверу и работать как обычные клиентские приложения.</p><div class="warning"><h3 class="title">Предупреждение</h3><p>С использованием фоновых рабочих процессов сопряжены угрозы стабильности и безопасности, так как они реализуются на языке <code class="literal">C</code>, и значит имеют неограниченный доступ к данным. Администраторы, желающие использовать модули, в которых задействованы фоновые рабочие процессы, должны быть крайне осторожными. Запускать рабочие процессы можно разрешать только модулям, прошедшим всесторонний аудит.</p></div><p>Рабочие процессы могут инициализироваться во время запуска <span class="productname">PostgreSQL</span>, если имя соответствующего модуля добавлено в <code class="varname">shared_preload_libraries</code>. Модуль, желающий запустить рабочий процесс, может зарегистрировать его, вызвав <code class="function">RegisterBackgroundWorker(<code class="type">BackgroundWorker</code> *<em class="parameter"><code>worker</code></em>)</code> из своей функции <code class="function">_PG_init()</code>. Рабочие процессы также могут быть запущены после запуска системы с помощью функции <code class="function">RegisterDynamicBackgroundWorker(<code class="type">BackgroundWorker</code> *<em class="parameter"><code>worker</code></em>, <code class="type">BackgroundWorkerHandle</code> **<em class="parameter"><code>handle</code></em>)</code>. В отличие от <code class="function">RegisterBackgroundWorker</code>, которую можно вызывать только из главного управляющего процесса, <code class="function">RegisterDynamicBackgroundWorker</code> должна вызываться из обычного обслуживающего процесса или другого рабочего процесса.</p><p>Структура <code class="structname">BackgroundWorker</code> определяется так: </p><pre class="programlisting">typedef void (*bgworker_main_type)(Datum main_arg);
typedef struct BackgroundWorker
{
    char        bgw_name[BGW_MAXLEN];
    char        bgw_type[BGW_MAXLEN];
    int         bgw_flags;
    BgWorkerStartTime bgw_start_time;
    int         bgw_restart_time;   /* время в секундах либо BGW_NEVER_RESTART */
    char        bgw_library_name[BGW_MAXLEN];
    char        bgw_function_name[BGW_MAXLEN];
    Datum       bgw_main_arg;
    char        bgw_extra[BGW_EXTRALEN];
    pid_t       bgw_notify_pid;
} BackgroundWorker;</pre><p>Поля <code class="structfield">bgw_name</code> и <code class="structfield">bgw_type</code> содержат строки, выводимые в отладочных сообщениях, списках процессов и подобных контекстах. Строка <code class="structfield">bgw_type</code> должна быть одинаковой для всех рабочих процессов одного типа, чтобы такие процессы можно было сгруппировать, например, в списке процессов. <code class="structfield">bgw_name</code>, с другой стороны, может содержать дополнительную информацию об определённом процессе. (Обычно строка <code class="structfield">bgw_name</code> содержит тип в некотором виде, но строго это не требуется.)</p><p>Поле <code class="structfield">bgw_flags</code> представляет битовую маску, обозначающую запрашиваемые модулем возможности. Допустимые в нём флаги: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">BGWORKER_SHMEM_ACCESS</code></span></dt><dd><p><a id="id-1.8.13.8.2.1.2.1.1" class="indexterm"></a> Запрашивает доступ к общей памяти. Этот флаг является обязательным.</p></dd><dt><span class="term"><code class="literal">BGWORKER_BACKEND_DATABASE_CONNECTION</code></span></dt><dd><p><a id="id-1.8.13.8.2.2.2.1.1" class="indexterm"></a> Запрашивается возможность устанавливать подключение к базе данных, через которое можно запускать транзакции и запросы. Рабочий процесс, использующий <code class="literal">BGWORKER_BACKEND_DATABASE_CONNECTION</code> для подключения к базе данных, должен также запросить доступ к разделяемой памяти, установив <code class="literal">BGWORKER_SHMEM_ACCESS</code>; в противном случае процесс не запустится.</p></dd></dl></div><p>В <code class="structfield">bgw_start_time</code> определяется состояние сервера, в котором <code class="command">postgres</code> должен запустить этот процесс; возможные варианты: <code class="literal">BgWorkerStart_PostmasterStart</code> (выполнить запуск сразу после того, как <code class="command">postgres</code> завершит инициализацию; процессы, выбирающие такой режим, не могут подключаться к базам данных), <code class="literal">BgWorkerStart_ConsistentState</code> (выполнить запуск, когда будет достигнуто согласованное состояние горячего резерва, и когда процессы могут подключаться к базам данных и выполнять запросы на чтение), и <code class="literal">BgWorkerStart_RecoveryFinished</code> (выполнить запуск, как только система перейдёт в обычный режим чтения-записи). Заметьте, что два последних варианта различаются только для серверов горячего резерва. Заметьте также, что этот параметр указывает только, когда должны запускаться процессы; при переходе в другое состояние они не будут останавливаться.</p><p><code class="structfield">bgw_restart_time</code> задаёт паузу (в секундах), которую должен сделать <code class="command">postgres</code>, прежде чем перезапускать процесс в случае его отказа. Это может быть любое положительное значение, либо <code class="literal">BGW_NEVER_RESTART</code>, указывающее, что процесс не нужно перезапускать в случае сбоя.</p><p><code class="structfield">bgw_library_name</code> определяет имя библиотеки, в которой следует искать точку входа для запуска рабочего процесса. Указанная библиотека будет динамически загружена рабочим процессом, а вызываемая функция будет выбрана по имени <code class="structfield">bgw_function_name</code>. Для функции, вызываемой в коде ядра, в этом поле должно быть <code class="literal">postgres</code>.</p><p><code class="structfield">bgw_function_name</code> определяет имя функции, которая будет использоваться как точка входа в новый рабочий процесс. Если эта функция в динамически загружаемой библиотеке, она должна быть помечена как <code class="literal">PGDLLEXPORT</code> (а не быть помечена как <code class="literal">static</code>).</p><p>В <code class="structfield">bgw_main_arg</code> задаётся аргумент <code class="type">Datum</code>, передаваемый основной функции фонового процесса. Эта функция должна принимать один аргумент типа <code class="type">Datum</code> и возвращать <code class="type">void</code>. В качестве этого аргумента ей и передаётся <code class="structfield">bgw_main_arg</code>. Кроме того, глобальная переменная <code class="literal">MyBgworkerEntry</code> указывает на копию структуры <code class="structname">BackgroundWorker</code>, переданной при регистрации; содержимое этой структуры может быть полезно рабочему процессу.</p><p>В Windows (и везде, где определяется <code class="literal">EXEC_BACKEND</code>) или в динамических рабочих процессах передавать <code class="type">Datum</code> по ссылке небезопасно, возможна только передача по значению. Поэтому если функции требуется аргумент, наиболее безопасно будет передать int32 или другое небольшое значение, содержащее индекс в массиве, размещённом в разделяемой памяти. Если же попытаться передать значение <code class="type">cstring</code> или <code class="type">text</code>, этот указатель нельзя будет использовать в новом рабочем процессе.</p><p>Поле <code class="structfield">bgw_extra</code> может содержать дополнительные данные, передаваемые фоновому рабочему процессу. В отличие от <code class="structfield">bgw_main_arg</code>, эти данные не передаются в качестве аргумента основной функции рабочего процесса, но могут быть получены через <code class="literal">MyBgworkerEntry</code>, как описывалось выше.</p><p>В <code class="structfield">bgw_notify_pid</code> задаётся PID обслуживающего процесса PostgreSQL, которому главный процесс должен посылать сигнал <code class="literal">SIGUSR1</code> при запуске и завершении нового рабочего процесса. Это поле должно содержать 0 для рабочих процессов, регистрируемых при запуске главного процесса, либо когда обслуживающий процесс не желает ждать окончания запуска рабочего процесса. Во всех остальных случаях в нём должно быть значение <code class="literal">MyProcPid</code>.</p><p>Запущенный процесс может подключиться к базе данных, вызвав <code class="function">BackgroundWorkerInitializeConnection(<em class="parameter"><code>char *dbname</code></em>, <em class="parameter"><code>char *username</code></em>, <em class="parameter"><code>uint32 flags</code></em>)</code> или <code class="function">BackgroundWorkerInitializeConnectionByOid(<em class="parameter"><code>Oid dboid</code></em>, <em class="parameter"><code>Oid useroid</code></em>, <em class="parameter"><code>uint32 flags</code></em>)</code>. Через это подключение процесс может выполнять транзакции и запросы, используя интерфейс <code class="literal">SPI</code>. Если в <code class="varname">dbname</code> передаётся NULL или <code class="varname">dboid</code> равен <code class="literal">InvalidOid</code>, сеанс не подключается ни к какой конкретной базе данных, но может обращаться к общим каталогам. Если в <code class="varname">username</code> передаётся NULL или <code class="varname">useroid</code> равен <code class="literal">InvalidOid</code>, процесс будет действовать от имени суперпользователя, созданного во время <code class="command">initdb</code>. Значение <code class="literal">BGWORKER_BYPASS_ALLOWCONN</code> в поле <code class="varname">flags</code> позволяет подключаться к базам, не принимающим подключения пользователей. Рабочий процесс может вызвать только одну из этих двух функций и только один раз. Переключаться между базами данных он не может.</p><p>Сигналы изначально блокируются при вызове основной функции рабочего процесса и должны быть разблокированы ей: это позволяет процессу при необходимости настроить собственные обработчики событий. Новый процесс может разблокировать сигналы, вызвав <code class="function">BackgroundWorkerUnblockSignals</code>, и заблокировать их, вызвав <code class="function">BackgroundWorkerBlockSignals</code>.</p><p>Если <code class="structfield">bgw_restart_time</code> для рабочего процесса имеет значение <code class="literal">BGW_NEVER_RESTART</code>, либо он завершается с кодом выхода 0, либо если его работа заканчивается вызовом <code class="function">TerminateBackgroundWorker</code>, он автоматически перестаёт контролироваться управляющим процессом при выходе. В противном случае он будет перезапущен через время, заданное в <code class="structfield">bgw_restart_time</code>, либо немедленно, если управляющему серверу пришлось переинициализировать кластер из-за сбоя обслуживающего процесса. Обслуживающие процессы, которым нужно только приостановить своё выполнение на время, должны переходить в состояние прерываемого ожидания, а не завершаться; для этого используется функция <code class="function">WaitLatch()</code>. При вызове этой функции обязательно установите флаг <code class="literal">WL_POSTMASTER_DEATH</code> и проверьте код возврата, чтобы корректно выйти в экстренном случае, когда был завершён сам <code class="command">postgres</code>.</p><p>Когда рабочий процесс регистрируется функцией <code class="function">RegisterDynamicBackgroundWorker</code>, обслуживающий процесс, производящий эту регистрацию, может получить информацию о состоянии порождённого процесса. Обслуживающие процессы, желающие сделать это, должны передать адрес <code class="type">BackgroundWorkerHandle *</code> во втором аргументе <code class="function">RegisterDynamicBackgroundWorker</code>. Если рабочий процесс успешно зарегистрирован, по этому адресу будет записан указатель на скрытую структуру, который можно затем передать функции <code class="function">GetBackgroundWorkerPid(<em class="parameter"><code>BackgroundWorkerHandle *</code></em>, <em class="parameter"><code>pid_t *</code></em>)</code> или <code class="function">TerminateBackgroundWorker(<em class="parameter"><code>BackgroundWorkerHandle *</code></em>)</code>. Вызывая <code class="function">GetBackgroundWorkerPid</code>, можно опрашивать состояние рабочего процесса: значение результата <code class="literal">BGWH_NOT_YET_STARTED</code> показывает, что рабочий процесс ещё не запущен управляющим; <code class="literal">BGWH_STOPPED</code> показывает, что он был запущен, но сейчас не работает; и <code class="literal">BGWH_STARTED</code> показывает, что он работает в данный момент. В последнем случае через второй аргумент также возвращается PID этого процесса. Обрабатывая вызов <code class="function">TerminateBackgroundWorker</code>, управляющий процесс посылает <code class="literal">SIGTERM</code> рабочему процессу, если он работает, и перестаёт его контролировать сразу по его завершении.</p><p>В некоторых случаях процессу, регистрирующему рабочий процесс, может потребоваться дождаться завершения запуска этого процесса. Это можно реализовать, записав в <code class="structfield">bgw_notify_pid</code> значение <code class="literal">MyProcPid</code>, а затем передав указатель <code class="type">BackgroundWorkerHandle *</code>, полученный во время регистрации, функции <code class="function">WaitForBackgroundWorkerStartup(<em class="parameter"><code>BackgroundWorkerHandle *handle</code></em>, <em class="parameter"><code>pid_t *</code></em>)</code>. Эта функция заблокирует выполнение, пока управляющий процесс не попытается запустить рабочий процесс, либо пока сам управляющий процесс не завершится. Если рабочий процесс запущен, возвращается значение <code class="literal">BGWH_STARTED</code> и по переданному адресу записывается PID. В противном случае возвращается <code class="literal">BGWH_STOPPED</code> или <code class="literal">BGWH_POSTMASTER_DIED</code>.</p><p>Процесс также может ожидать завершения рабочего процесса, вызвав функцию <code class="function">WaitForBackgroundWorkerShutdown(<em class="parameter"><code>BackgroundWorkerHandle *handle</code></em>)</code> с указателем <code class="type">BackgroundWorkerHandle *</code>, полученным при регистрации. Эта функция заблокирует выполнение, пока не завершится рабочий процесс либо управляющий процесс. При завершении рабочего процесса эта функция возвращает <code class="literal">BGWH_STOPPED</code>, а при завершении управляющего — <code class="literal">BGWH_POSTMASTER_DIED</code>.</p><p>Рабочие процессы могут передавать асинхронные уведомления, вызывая либо команду <code class="command">NOTIFY</code> через <acronym class="acronym">SPI</acronym> (Server Programming Interface, Интерфейс программирования сервера), либо функцию <code class="function">Async_Notify()</code> напрямую. Такие уведомления будут отправлены в момент фиксации транзакции. Фоновые рабочие процессы не должны регистрироваться командой <code class="command">LISTEN</code> для получения асинхронных уведомлений, ввиду отсутствия инфрастуктуры для получения таких уведомлений рабочим процессом.</p><p>Рабочий пример, демонстрирующий некоторые полезные приёмы, можно найти в модуле <code class="filename">src/test/modules/worker_spi</code>.</p><p>Максимальное число рабочих процессов, которые можно зарегистрировать, ограничивается значением <a class="xref" href="runtime-config-resource.html#GUC-MAX-WORKER-PROCESSES">max_worker_processes</a>.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="spi-spi-start-transaction.html" title="SPI_start_transaction">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="server-programming.html" title="Часть V. Серверное программирование">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="logicaldecoding.html" title="Глава 49. Логическое декодирование">След.</a></td></tr><tr><td width="40%" align="left" valign="top">SPI_start_transaction </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> Глава 49. Логическое декодирование</td></tr></table></div></body></html>