<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>11.8. Частичные индексы</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="indexes-expressional.html" title="11.7. Индексы по выражениям" /><link rel="next" href="indexes-index-only-scans.html" title="11.9. Сканирование только индекса и покрывающие индексы" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">11.8. Частичные индексы</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="indexes-expressional.html" title="11.7. Индексы по выражениям">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="indexes.html" title="Глава 11. Индексы">Наверх</a></td><th width="60%" align="center">Глава 11. Индексы</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="indexes-index-only-scans.html" title="11.9. Сканирование только индекса и покрывающие индексы">След.</a></td></tr></table><hr /></div><div class="sect1" id="INDEXES-PARTIAL"><div class="titlepage"><div><div><h2 class="title" style="clear: both">11.8. Частичные индексы <a href="#INDEXES-PARTIAL" class="id_link">#</a></h2></div></div></div><a id="id-1.5.10.11.2" class="indexterm"></a><p><em class="firstterm">Частичный индекс</em> — это индекс, который строится по подмножеству строк таблицы, определяемому условным выражением (оно называется <em class="firstterm">предикатом</em> частичного индекса). Такой индекс содержит записи только для строк, удовлетворяющих предикату. Частичные индексы довольно специфичны, но в ряде ситуаций они могут быть очень полезны.</p><p>Частичные индексы могут быть полезны, во-первых, тем, что позволяют избежать индексирования распространённых значений. Так как при поиске распространённого значения (такого, которое содержится в значительном проценте всех строк) индекс всё равно не будет использоваться, хранить эти строки в индексе нет смысла. Исключив их из индекса, можно уменьшить его размер, а значит и ускорить запросы, использующие этот индекс. Это также может ускорить операции изменения данных в таблице, так как индекс будет обновляться не всегда. Возможное применение этой идеи проиллюстрировано в <a class="xref" href="indexes-partial.html#INDEXES-PARTIAL-EX1" title="Пример 11.1. Настройка частичного индекса, исключающего распространённые значения">Примере 11.1</a>.</p><div class="example" id="INDEXES-PARTIAL-EX1"><p class="title"><strong>Пример 11.1. Настройка частичного индекса, исключающего распространённые значения</strong></p><div class="example-contents"><p>Предположим, что вы храните в базе данных журнал обращений к корпоративному сайту. Большая часть обращений будет происходить из диапазона IP-адресов вашей компании, а остальные могут быть откуда угодно (например, к нему могут подключаться внешние сотрудники с динамическими IP). Если при поиске по IP вас обычно интересуют внешние подключения, IP-диапазон внутренней сети компании можно не включать в индекс.</p><p>Пусть у вас есть такая таблица: </p><pre class="programlisting">CREATE TABLE access_log (
    url varchar,
    client_ip inet,
    ...
);</pre><p>Создать частичный индекс для нашего примера можно так: </p><pre class="programlisting">CREATE INDEX access_log_client_ip_ix ON access_log (client_ip)
WHERE NOT (client_ip &gt; inet '192.168.100.0' AND
           client_ip &lt; inet '192.168.100.255');</pre><p>Так будет выглядеть типичный запрос, использующий этот индекс: </p><pre class="programlisting">SELECT *
FROM access_log
WHERE url = '/index.html' AND client_ip = inet '212.78.10.32';</pre><p> В нём фигурирует IP-адрес, попадающий в частичный индекс. Следующий запрос не может использовать частичный индекс, так как в нём IP-адрес не попадает в диапазон индекса: </p><pre class="programlisting">SELECT *
FROM access_log
WHERE url = '/index.html' AND client_ip = inet '192.168.100.23';</pre><p>Заметьте, что при таком определении частичного индекса необходимо, чтобы распространённые значения были известны заранее, так что такие индексы лучше использовать, когда распределение данных не меняется. Хотя такие индексы можно пересоздавать время от времени, подстраиваясь под новое распределение, это значительно усложняет поддержку.</p></div></div><br class="example-break" /><p>Во-вторых, частичные индексы могут быть полезны тем, что позволяют исключить из индекса значения, которые обычно не представляют интереса; это проиллюстрировано в <a class="xref" href="indexes-partial.html#INDEXES-PARTIAL-EX2" title="Пример 11.2. Настройка частичного индекса, исключающего неинтересные значения">Примере 11.2</a>. При этом вы получаете те же преимущества, что и в предыдущем случае, но система не сможет извлечь <span class="quote">«<span class="quote">неинтересные</span>»</span> значения по этому индексу, даже если сканирование индекса может быть эффективным. Очевидно, настройка частичных индексов в таких случаях требует тщательного анализа и тестирования.</p><div class="example" id="INDEXES-PARTIAL-EX2"><p class="title"><strong>Пример 11.2. Настройка частичного индекса, исключающего неинтересные значения</strong></p><div class="example-contents"><p>Если у вас есть таблица, в которой хранятся и оплаченные, и неоплаченные счета, и при этом неоплаченные счета составляют только небольшую часть всей таблицы, но представляют наибольший интерес, производительность запросов можно увеличить, создав индекс только по неоплаченным счетам. Сделать это можно следующей командой: </p><pre class="programlisting">CREATE INDEX orders_unbilled_index ON orders (order_nr)
    WHERE billed is not true;</pre><p>Этот индекс будет применяться, например в таком запросе: </p><pre class="programlisting">SELECT * FROM orders WHERE billed is not true AND order_nr &lt; 10000;</pre><p> Однако он также может применяться в запросах, где <code class="structfield">order_nr</code> вообще не используется, например: </p><pre class="programlisting">SELECT * FROM orders WHERE billed is not true AND amount &gt; 5000.00;</pre><p> Конечно, он будет не так эффективен, как мог бы быть частичный индекс по столбцу <code class="structfield">amount</code>, так как системе придётся сканировать его целиком. Тем не менее, если неоплаченных счетов сравнительно мало, выиграть при поиске неоплаченного счёта можно и с таким частичным индексом.</p><p>Заметьте, что в таком запросе этот индекс не будет использоваться: </p><pre class="programlisting">SELECT * FROM orders WHERE order_nr = 3501;</pre><p> Счёт с номером 3501 может оказаться, как в числе неоплаченных, так и оплаченных.</p></div></div><br class="example-break" /><p><a class="xref" href="indexes-partial.html#INDEXES-PARTIAL-EX2" title="Пример 11.2. Настройка частичного индекса, исключающего неинтересные значения">Пример 11.2</a> также показывает, что индексируемый столбец не обязательно должен совпадать со столбцом, используемым в предикате. <span class="productname">PostgreSQL</span> поддерживает частичные индексы с произвольными предикатами — главное, чтобы в них фигурировали только столбцы индексируемой таблицы. Однако не забывайте, что предикат должен соответствовать условиям запросов, для оптимизации которых предназначается данный индекс. Точнее, частичный индекс будет применяться в запросе, только если система сможет понять, что условие <code class="literal">WHERE</code> данного запроса математически сводится к предикату индекса. Но учтите, что <span class="productname">PostgreSQL</span> не умеет доказывать математические утверждения об эквивалентности выражений, записанных в разных формах. (Составить программу для таких доказательств крайне сложно, и если даже это удастся, скорость её будет неприемлема для применения на практике.) Система может выявить только самые простые следствия с неравенствами; например, понять, что из <span class="quote">«<span class="quote">x &lt; 1</span>»</span> следует <span class="quote">«<span class="quote">x &lt; 2</span>»</span>; во всех остальных случаях условие предиката должно точно совпадать с условием в предложении <code class="literal">WHERE</code>, иначе индекс будет считаться неподходящим. Сопоставление условий происходит во время планирования запросов, а не во время выполнения. Как следствие, запросы с параметрами не будут работать с частичными индексами. Например, условие с параметром <span class="quote">«<span class="quote">x &lt; ?</span>»</span> в подготовленном запросе никогда не будет сведено к <span class="quote">«<span class="quote">x &lt; 2</span>»</span> при всех возможных значениях параметра.</p><p>Третье возможное применение частичных индексов вообще не связано с использованием индекса в запросах. Идея заключается в том, чтобы создать уникальный индекс по подмножеству строк таблицы, как в <a class="xref" href="indexes-partial.html#INDEXES-PARTIAL-EX3" title="Пример 11.3. Настройка частичного уникального индекса">Примере 11.3</a>. Это обеспечит уникальность среди строк, удовлетворяющих условию предиката, но никак не будет ограничивать остальные.</p><div class="example" id="INDEXES-PARTIAL-EX3"><p class="title"><strong>Пример 11.3. Настройка частичного уникального индекса</strong></p><div class="example-contents"><p>Предположим, что у нас есть таблица с результатами теста. Мы хотим, чтобы для каждого сочетания предмета и целевой темы была только одна запись об успешном результате, а неудачных попыток могло быть много. Вот как можно этого добиться: </p><pre class="programlisting">CREATE TABLE tests (
    subject text,
    target text,
    success boolean,
    ...
);

CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)
    WHERE success;</pre><p> Это подход будет особенно эффективным, когда неудачных попыток будет намного больше, чем удачных. Также можно потребовать, чтобы в столбце допускался только один NULL, создав уникальный частичный индекс с ограничением <code class="literal">IS NULL</code>.</p></div></div><br class="example-break" /><p>Наконец, с помощью частичных индексов можно также переопределять выбираемый системой план запроса. Возможно, что для данных с неудачным распределением система решит использовать индекс, тогда как на самом деле это неэффективно. В этом случае индекс можно настроить так, чтобы в подобных запросах он не работал. Обычно <span class="productname">PostgreSQL</span> принимает разумные решения относительно применения индексов (т. е. старается не использовать их для получения распространённых значений, так что частичный индекс в вышеприведённом примере помог только уменьшить размер индекса, для отказа от использования индекса он не требовался), поэтому крайне неэффективный план может быть поводом для сообщения об ошибке.</p><p>Помните, что настраивая частичный индекс, вы тем самым заявляете, что знаете о данных гораздо больше, чем планировщик запросов. В частности, вы знаете, когда такой индекс может быть полезен. Это знание обязательно должно подкрепляться опытом и пониманием того, как работают индексы в <span class="productname">PostgreSQL</span>. В большинстве случаев преимущества частичных индексов по сравнению с обычными будут минимальными. Однако в ряде случаев эти индексы могут быть даже вредны, о чём говорится в <a class="xref" href="indexes-partial.html#INDEXES-PARTIAL-EX4" title="Пример 11.4. Не применяйте частичные индексы в качестве замены секционированию">Примере 11.4</a>.</p><div class="example" id="INDEXES-PARTIAL-EX4"><p class="title"><strong>Пример 11.4. Не применяйте частичные индексы в качестве замены секционированию</strong></p><div class="example-contents"><p>У вас может возникнуть желание создать множество неперекрывающихся частичных индексов, например: </p><pre class="programlisting">CREATE INDEX mytable_cat_1 ON mytable (data) WHERE category = 1;
CREATE INDEX mytable_cat_2 ON mytable (data) WHERE category = 2;
CREATE INDEX mytable_cat_3 ON mytable (data) WHERE category = 3;
...
CREATE INDEX mytable_cat_<em class="replaceable"><code>N</code></em> ON mytable (data) WHERE category = <em class="replaceable"><code>N</code></em>;</pre><p> Но так делать не следует! Почти наверняка вам лучше использовать один не частичный индекс, объявленный так: </p><pre class="programlisting">CREATE INDEX mytable_cat_data ON mytable (category, data);</pre><p> (Поставьте первым столбец категорий, по причинам описанным в <a class="xref" href="indexes-multicolumn.html" title="11.3. Составные индексы">Разделе 11.3</a>.) При поиске в большем индексе может потребоваться опуститься на несколько уровней ниже, чем при поиске в меньшем частичном, но это почти гарантированно будет дешевле, чем выбрать при планировании из всех частичных индексов подходящий. Сложность с выбором индекса объясняется тем, что система не знает, как взаимосвязаны частичные индексы, и ей придётся проверять каждый из них, чтобы понять, соответствует ли он текущему запросу.</p><p>Если ваша таблица настолько велика, что создавать один индекс кажется действительно плохой идей, рассмотрите возможность использования секционирования (см. <a class="xref" href="ddl-partitioning.html" title="5.11. Секционирование таблиц">Раздел 5.11</a>). Когда применяется этот механизм, система понимает, что таблицы и индексы не перекрываются, и может выполнять запросы гораздо эффективнее.</p></div></div><br class="example-break" /><p>Узнать о частичных индексах больше можно в следующих источниках: <a class="xref" href="biblio.html#STON89B">[ston89b]</a>, <a class="xref" href="biblio.html#OLSON93" title="Partial indexing in POSTGRES: research project">[olson93]</a> и <a class="xref" href="biblio.html#SESHADRI95">[seshadri95]</a>.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="indexes-expressional.html" title="11.7. Индексы по выражениям">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="indexes.html" title="Глава 11. Индексы">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="indexes-index-only-scans.html" title="11.9. Сканирование только индекса и покрывающие индексы">След.</a></td></tr><tr><td width="40%" align="left" valign="top">11.7. Индексы по выражениям </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 11.9. Сканирование только индекса и покрывающие индексы</td></tr></table></div></body></html>