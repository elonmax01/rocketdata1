<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>38.5. Функции на языке запросов (SQL)</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="xproc.html" title="38.4. Пользовательские процедуры" /><link rel="next" href="xfunc-overload.html" title="38.6. Перегрузка функций" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">38.5. Функции на языке запросов (<acronym class="acronym">SQL</acronym>)</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="xproc.html" title="38.4. Пользовательские процедуры">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="extend.html" title="Глава 38. Расширение SQL">Наверх</a></td><th width="60%" align="center">Глава 38. Расширение <acronym class="acronym">SQL</acronym></th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="xfunc-overload.html" title="38.6. Перегрузка функций">След.</a></td></tr></table><hr /></div><div class="sect1" id="XFUNC-SQL"><div class="titlepage"><div><div><h2 class="title" style="clear: both">38.5. Функции на языке запросов (<acronym class="acronym">SQL</acronym>) <a href="#XFUNC-SQL" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="xfunc-sql.html#XFUNC-SQL-FUNCTION-ARGUMENTS">38.5.1. Аргументы <acronym class="acronym">SQL</acronym>-функций</a></span></dt><dt><span class="sect2"><a href="xfunc-sql.html#XFUNC-SQL-BASE-FUNCTIONS">38.5.2. Функции <acronym class="acronym">SQL</acronym> с базовыми типами</a></span></dt><dt><span class="sect2"><a href="xfunc-sql.html#XFUNC-SQL-COMPOSITE-FUNCTIONS">38.5.3. Функции <acronym class="acronym">SQL</acronym> со сложными типами</a></span></dt><dt><span class="sect2"><a href="xfunc-sql.html#XFUNC-OUTPUT-PARAMETERS">38.5.4. Функции <acronym class="acronym">SQL</acronym> с выходными параметрами</a></span></dt><dt><span class="sect2"><a href="xfunc-sql.html#XFUNC-OUTPUT-PARAMETERS-PROC">38.5.5. Процедуры <acronym class="acronym">SQL</acronym> с выходными параметрами</a></span></dt><dt><span class="sect2"><a href="xfunc-sql.html#XFUNC-SQL-VARIADIC-FUNCTIONS">38.5.6. Функции <acronym class="acronym">SQL</acronym> с переменным числом аргументов</a></span></dt><dt><span class="sect2"><a href="xfunc-sql.html#XFUNC-SQL-PARAMETER-DEFAULTS">38.5.7. Функции <acronym class="acronym">SQL</acronym> со значениями аргументов по умолчанию</a></span></dt><dt><span class="sect2"><a href="xfunc-sql.html#XFUNC-SQL-TABLE-FUNCTIONS">38.5.8. Функции <acronym class="acronym">SQL</acronym>, порождающие таблицы</a></span></dt><dt><span class="sect2"><a href="xfunc-sql.html#XFUNC-SQL-FUNCTIONS-RETURNING-SET">38.5.9. Функции <acronym class="acronym">SQL</acronym>, возвращающие множества</a></span></dt><dt><span class="sect2"><a href="xfunc-sql.html#XFUNC-SQL-FUNCTIONS-RETURNING-TABLE">38.5.10. Функции <acronym class="acronym">SQL</acronym>, возвращающие таблицы (<code class="literal">TABLE</code>)</a></span></dt><dt><span class="sect2"><a href="xfunc-sql.html#XFUNC-SQL-POLYMORPHIC-FUNCTIONS">38.5.11. Полиморфные функции <acronym class="acronym">SQL</acronym></a></span></dt><dt><span class="sect2"><a href="xfunc-sql.html#XFUNC-SQL-COLLATIONS">38.5.12. Функции <acronym class="acronym">SQL</acronym> с правилами сортировки</a></span></dt></dl></div><a id="id-1.8.3.8.2" class="indexterm"></a><p>SQL-функции выполняют произвольный список операторов SQL и возвращают результат последнего запроса в списке. В простом случае (не с множеством) будет возвращена первая строка результата последнего запроса. (Помните, что понятие <span class="quote">«<span class="quote">первая строка</span>»</span> в наборе результатов с несколькими строками определено точно, только если присутствует <code class="literal">ORDER BY</code>.) Если последний запрос вообще не вернёт строки, будет возвращено значение NULL.</p><p>Кроме того, можно объявить SQL-функцию как возвращающую множество (то есть, несколько строк), указав в качестве возвращаемого типа функции <code class="literal">SETOF <em class="replaceable"><code>некий_тип</code></em></code>, либо объявив её с указанием <code class="literal">RETURNS TABLE(<em class="replaceable"><code>столбцы</code></em>)</code>. В этом случае будут возвращены все строки результата последнего запроса. Подробнее это описывается ниже.</p><p>Тело SQL-функции должно представлять собой список SQL-операторов, разделённых точкой с запятой. Точка с запятой после последнего оператора может отсутствовать. Если только функция не объявлена как возвращающая <code class="type">void</code>, последним оператором должен быть <code class="command">SELECT</code>, либо <code class="command">INSERT</code>, <code class="command">UPDATE</code> или <code class="command">DELETE</code> с предложением <code class="literal">RETURNING</code>.</p><p>Любой набор команд на языке <acronym class="acronym">SQL</acronym> можно скомпоновать вместе и обозначить как функцию. Помимо запросов <code class="command">SELECT</code>, эти команды могут включать запросы, изменяющие данные (<code class="command">INSERT</code>, <code class="command">UPDATE</code> и <code class="command">DELETE</code> и <code class="command">MERGE</code>), а также другие SQL-команды. (В <acronym class="acronym">SQL</acronym>-функциях нельзя использовать команды управления транзакциями, например <code class="command">COMMIT</code>, <code class="command">SAVEPOINT</code>, и некоторые вспомогательные команды, в частности <code class="literal">VACUUM</code>.) Однако последней командой должна быть <code class="command">SELECT</code> или команда с предложением <code class="literal">RETURNING</code>, возвращающая результат с типом возврата функции. Если же вы хотите определить функцию SQL, выполняющую действия, но не возвращающую полезное значение, вы можете объявить её как возвращающую тип <code class="type">void</code>. Например, эта функция удаляет строки с отрицательным жалованьем из таблицы <code class="literal">emp</code>: </p><pre class="screen">
CREATE FUNCTION clean_emp() RETURNS void AS '
    DELETE FROM emp
        WHERE salary &lt; 0;
' LANGUAGE SQL;

SELECT clean_emp();

 clean_emp
-----------

(1 row)
</pre><p>Если записать то же самое в виде процедуры, то можно не указывать возвращаемый тип. Например: </p><pre class="screen">
CREATE PROCEDURE clean_emp() AS '
    DELETE FROM emp
        WHERE salary &lt; 0;
' LANGUAGE SQL;

CALL clean_emp();
</pre><p> В таких простых случаях разница между процедурой и функцией, возвращающей <code class="type">void</code>, в основном стилистическая. Однако по сравнению с функциями процедуры предоставляют дополнительную функциональность, например возможности управления транзакциями. Кроме того, процедуры соответствуют стандарту SQL, а возвращающие <code class="type">void</code> функции специфичны для PostgreSQL.</p><div class="note"><h3 class="title">Примечание</h3><p>Прежде чем начинается выполнение команд, разбирается всё тело SQL-функции. Когда SQL-функция содержит команды, модифицирующие системные каталоги (например, <code class="command">CREATE TABLE</code>), действие таких команд не будет проявляться на стадии анализа последующих команд этой функции. Так, например, команды <code class="literal">CREATE TABLE foo (...); INSERT INTO foo VALUES(...);</code> не будут работать, как ожидается, если их упаковать в одну SQL-функцию, так как <code class="structname">foo</code> не будет существовать к моменту разбору команды <code class="command">INSERT</code>. В подобных ситуациях вместо SQL-функции рекомендуется использовать <span class="application">PL/pgSQL</span>.</p></div><p>Синтаксис команды <code class="command">CREATE FUNCTION</code> требует, чтобы тело функции было записано как строковая константа. Обычно для этого удобнее всего заключать строковую константу в доллары (см. <a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-DOLLAR-QUOTING" title="4.1.2.4. Строковые константы, заключённые в доллары">Подраздел 4.1.2.4</a>). Если вы решите использовать обычный синтаксис с заключением строки в апострофы, вам придётся дублировать апострофы (<code class="literal">'</code>) и обратную косую черту (<code class="literal">\</code>) (предполагается синтаксис спецпоследовательностей) в теле функции (см. <a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-STRINGS" title="4.1.2.1. Строковые константы">Подраздел 4.1.2.1</a>).</p><div class="sect2" id="XFUNC-SQL-FUNCTION-ARGUMENTS"><div class="titlepage"><div><div><h3 class="title">38.5.1. Аргументы <acronym class="acronym">SQL</acronym>-функций <a href="#XFUNC-SQL-FUNCTION-ARGUMENTS" class="id_link">#</a></h3></div></div></div><a id="id-1.8.3.8.10.2" class="indexterm"></a><p>К аргументам SQL-функции можно обращаться в теле функции по именам или номерам. Ниже приведены примеры обоих вариантов.</p><p>Чтобы использовать имя, объявите аргумент функции как именованный, а затем просто пишите это имя в теле функции. Если имя аргумента совпадает с именем какого-либо столбца в текущей SQL-команде внутри функции, имя столбца будет иметь приоритет. Чтобы всё же перекрыть имя столбца, дополните имя аргумента именем самой функции, то есть запишите его в виде <code class="literal"><em class="replaceable"><code>имя_функции</code></em>.<em class="replaceable"><code>имя_аргумента</code></em></code>. (Если и это имя будет конфликтовать с полным именем столбца, снова выиграет имя столбца. Неоднозначности в этом случае вы можете избежать, выбрав другой псевдоним для таблицы в SQL-команде.)</p><p>Старый подход с нумерацией позволяет обращаться к аргументам, применяя запись <code class="literal">$<em class="replaceable"><code>n</code></em></code>: <code class="literal">$1</code> обозначает первый аргумент, <code class="literal">$2</code> — второй и т. д. Это будет работать и в том случае, если данному аргументу назначено имя.</p><p>Если аргумент имеет составной тип, то для обращения к его атрибутам можно использовать запись с точкой, например: <code class="literal"><em class="replaceable"><code>аргумент</code></em>.<em class="replaceable"><code>поле</code></em></code> или <code class="literal">$1.<em class="replaceable"><code>поле</code></em></code>. И опять же, при этом может потребоваться дополнить имя аргумента именем функции, чтобы сделать имя аргумента однозначным.</p><p>Аргументы SQL-функции могут использоваться только как значения данных, но не как идентификаторы. Например, это приемлемо: </p><pre class="programlisting">INSERT INTO mytable VALUES ($1);</pre><p> а это не будет работать: </p><pre class="programlisting">INSERT INTO $1 VALUES (42);</pre><div class="note"><h3 class="title">Примечание</h3><p>Возможность обращаться к аргументам SQL-функций по именам появилась в <span class="productname">PostgreSQL</span> 9.2. В функциях, которые должны работать со старыми серверами, необходимо применять запись <code class="literal">$<em class="replaceable"><code>n</code></em></code>.</p></div></div><div class="sect2" id="XFUNC-SQL-BASE-FUNCTIONS"><div class="titlepage"><div><div><h3 class="title">38.5.2. Функции <acronym class="acronym">SQL</acronym> с базовыми типами <a href="#XFUNC-SQL-BASE-FUNCTIONS" class="id_link">#</a></h3></div></div></div><p>Простейшая возможная функция <acronym class="acronym">SQL</acronym> не имеет аргументов и просто возвращает базовый тип, например <code class="type">integer</code>: </p><pre class="screen">
CREATE FUNCTION one() RETURNS integer AS $$
    SELECT 1 AS result;
$$ LANGUAGE SQL;

-- Альтернативная запись строковой константы:
CREATE FUNCTION one() RETURNS integer AS '
    SELECT 1 AS result;
' LANGUAGE SQL;

SELECT one();

 one
-----
   1
</pre><p>Заметьте, что мы определили псевдоним столбца в теле функции для её результата (дали ему имя <code class="literal">result</code>), но этот псевдоним не виден снаружи функции. Вследствие этого, столбец результата получил имя <code class="literal">one</code>, а не <code class="literal">result</code>.</p><p>Практически так же легко определяются функции <acronym class="acronym">SQL</acronym>, которые принимают в аргументах базовые типы: </p><pre class="screen">
CREATE FUNCTION add_em(x integer, y integer) RETURNS integer AS $$
    SELECT x + y;
$$ LANGUAGE SQL;

SELECT add_em(1, 2) AS answer;

 answer
--------
      3
</pre><p>Мы также можем отказаться от имён аргументов и обращаться к ним по номерам: </p><pre class="screen">
CREATE FUNCTION add_em(integer, integer) RETURNS integer AS $$
    SELECT $1 + $2;
$$ LANGUAGE SQL;

SELECT add_em(1, 2) AS answer;

 answer
--------
      3
</pre><p>Вот более полезная функция, которую можно использовать, чтобы дебетовать банковский счёт: </p><pre class="programlisting">CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS $$
    UPDATE bank
        SET balance = balance - debit
        WHERE accountno = tf1.accountno;
    SELECT 1;
$$ LANGUAGE SQL;</pre><p> Пользователь может выполнить эту функцию, чтобы дебетовать счёт 17 на 100 долларов, так: </p><pre class="programlisting">SELECT tf1(17, 100.0);</pre><p>В этом примере мы выбрали имя <code class="literal">accountno</code> для первого аргумента, но это же имя имеет столбец в таблице <code class="literal">bank</code>. В команде <code class="command">UPDATE</code> имя <code class="literal">accountno</code> относится к столбцу <code class="literal">bank.accountno</code>, так для обращения к аргументу нужно записать <code class="literal">tf1.accountno</code>. Конечно, мы могли бы избежать этого, выбрав другое имя для аргумента.</p><p>На практике обычно желательно получать от функции более полезный результат, чем константу 1, поэтому более реалистично такое определение: </p><pre class="programlisting">CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS $$
    UPDATE bank
        SET balance = balance - debit
        WHERE accountno = tf1.accountno;
    SELECT balance FROM bank WHERE accountno = tf1.accountno;
$$ LANGUAGE SQL;</pre><p> Эта функция изменяет баланс и возвращает полученное значение. То же самое можно сделать в одной команде, применив <code class="literal">RETURNING</code>: </p><pre class="programlisting">CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS $$
    UPDATE bank
        SET balance = balance - debit
        WHERE accountno = tf1.accountno
    RETURNING balance;
$$ LANGUAGE SQL;</pre><p>Если последняя команда <code class="literal">SELECT</code> или <code class="literal">RETURNING</code> в <acronym class="acronym">SQL</acronym>-функции возвращает не в точности объявленный тип результата, <span class="productname">PostgreSQL</span> автоматически приведёт возвращаемое значение к нужному типу, если это возможно с применением приведения присваивания или неявным образом. В противном случае вы должны применить явное приведение. Например, предположим, что мы захотели изменить возвращаемый тип в предыдущей функции <code class="function">add_em</code> на <code class="type">float8</code>. Это можно сделать так: </p><pre class="programlisting">CREATE FUNCTION add_em(integer, integer) RETURNS float8 AS $$
    SELECT $1 + $2;
$$ LANGUAGE SQL;</pre><p> Сумма типа <code class="type">integer</code> может быть неявно приведена к типу <code class="type">float8</code>, поэтому достаточно сменить только тип результата. (Подробнее о приведениях говорится в <a class="xref" href="typeconv.html" title="Глава 10. Преобразование типов">Главе 10</a> и описании <a class="xref" href="sql-createcast.html" title="CREATE CAST"><span class="refentrytitle">CREATE CAST</span></a>.)</p></div><div class="sect2" id="XFUNC-SQL-COMPOSITE-FUNCTIONS"><div class="titlepage"><div><div><h3 class="title">38.5.3. Функции <acronym class="acronym">SQL</acronym> со сложными типами <a href="#XFUNC-SQL-COMPOSITE-FUNCTIONS" class="id_link">#</a></h3></div></div></div><p>В функциях с аргументами составных типов мы должны указывать не только, какой аргумент, но и какой атрибут (поле) этого аргумента нам нужен. Например, предположим, что <code class="type">emp</code> — таблица, содержащая данные работников, и это же имя составного типа, представляющего каждую строку таблицы. Следующая функция <code class="function">double_salary</code> вычисляет, каким было бы чьё-либо жалование в случае увеличения вдвое: </p><pre class="screen">
CREATE TABLE emp (
    name        text,
    salary      numeric,
    age         integer,
    cubicle     point
);

INSERT INTO emp VALUES ('Bill', 4200, 45, '(2,1)');

CREATE FUNCTION double_salary(emp) RETURNS numeric AS $$
    SELECT $1.salary * 2 AS salary;
$$ LANGUAGE SQL;

SELECT name, double_salary(emp.*) AS dream
    FROM emp
    WHERE emp.cubicle ~= point '(2,1)';

 name | dream
------+-------
 Bill |  8400
</pre><p>Обратите внимание на запись <code class="literal">$1.salary</code> позволяющую выбрать одно поле из значения строки аргумента. Также заметьте, что в вызывающей команде <code class="command">SELECT</code> указание <em class="replaceable"><code>имя_таблицы</code></em><code class="literal">.*</code> выбирает всю текущую строку таблицы как составное значение. На строку таблицы можно сослаться и просто по имени таблицы, например так: </p><pre class="screen">
SELECT name, double_salary(emp) AS dream
    FROM emp
    WHERE emp.cubicle ~= point '(2,1)';
</pre><p> Однако это использование считается устаревшим, так как провоцирует путаницу. (Подробнее эти две записи составных значений строки таблицы описаны в <a class="xref" href="rowtypes.html#ROWTYPES-USAGE" title="8.16.5. Использование составных типов в запросах">Подразделе 8.16.5</a>.)</p><p>Иногда бывает удобно образовать составное значение аргумента на лету. Это позволяет сделать конструкция <code class="literal">ROW</code>. Например, так можно изменить данные, передаваемые функции: </p><pre class="screen">
SELECT name, double_salary(ROW(name, salary*1.1, age, cubicle)) AS dream
    FROM emp;
</pre><p>Также возможно создать функцию, возвращающую составной тип. Например, эта функция возвращает одну строку <code class="type">emp</code>: </p><pre class="programlisting">CREATE FUNCTION new_emp() RETURNS emp AS $$
    SELECT text 'None' AS name,
        1000.0 AS salary,
        25 AS age,
        point '(2,2)' AS cubicle;
$$ LANGUAGE SQL;</pre><p> В этом примере мы задали для каждого атрибута постоянное значение, но вместо этих констант можно подставить любые вычисления.</p><p>Учтите два важных требования относительно определения функции: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Порядок в списке выборки внутреннего запроса должен в точности совпадать с порядком следования столбцов в составном типе. (Имена столбцов, как показывает пример выше, для системы значения не имеют.)</p></li><li class="listitem"><p>Необходимо сделать так, чтобы каждое выражение могло приводиться к типу соответствующего столбца составного типа. В противном случае вы получите такие ошибки: </p><pre class="screen">
<code class="computeroutput">
ERROR:  return type mismatch in function declared to return emp
DETAIL:  Final statement returns text instead of point at column 4.
</code>
</pre><p> (ОШИБКА:  несовпадение типа возврата в функции (в объявлении указан тип emp); ПОДРОБНОСТИ:  Последний оператор возвращает text вместо point для столбца 4.) Как и в случае с базовыми типами, никакие явные приведения автоматически не добавляются, возможны только приведения присваивания или неявные.</p></li></ul></div><p>Ту же функцию можно определить другим способом: </p><pre class="programlisting">CREATE FUNCTION new_emp() RETURNS emp AS $$
    SELECT ROW('None', 1000.0, 25, '(2,2)')::emp;
$$ LANGUAGE SQL;</pre><p> Здесь мы записали <code class="command">SELECT</code>, который возвращает один столбец нужного составного типа. В данной ситуации этот вариант на самом деле не лучше, но в некоторых случаях он может быть удобной альтернативой — например, если нам нужно вычислить результат, вызывая другую функцию, которая возвращает нужное составное значение. Этот вариант полезен и в случае, когда мы хотим написать функцию, которая возвращает не обычный составной тип, а домен, определённый поверх составного типа; тогда она в любом случае должна определяться как возвращающая единственный столбец, так как никакого способа осуществить нужное приведение для всей строки результата нет.</p><p>Мы можем вызывать эту функцию напрямую, либо указав её в выражении значения: </p><pre class="screen">
SELECT new_emp();

         new_emp
--------------------------
 (None,1000.0,25,"(2,2)")
</pre><p> либо обратившись к ней, как к табличной функции: </p><pre class="screen">
SELECT * FROM new_emp();

 name | salary | age | cubicle
------+--------+-----+---------
 None | 1000.0 |  25 | (2,2)
</pre><p> Второй способ более подробно описан в <a class="xref" href="xfunc-sql.html#XFUNC-SQL-TABLE-FUNCTIONS" title="38.5.8. Функции SQL, порождающие таблицы">Подразделе 38.5.8</a>.</p><p>Когда используется функция, возвращающая составной тип, может возникнуть желание получить из её результата только одно поле (атрибут). Это можно сделать, применяя такую запись: </p><pre class="screen">
SELECT (new_emp()).name;

 name
------
 None
</pre><p> Дополнительные скобки необходимы во избежание неоднозначности при разборе запроса. Если вы попытаетесь выполнить запрос без них, вы получите ошибку: </p><pre class="screen">
SELECT new_emp().name;
ERROR:  syntax error at or near "."
LINE 1: SELECT new_emp().name;
                        ^
</pre><p>
(ОШИБКА:  синтаксическая ошибка (примерное положение: "."))</p><p>Функциональную запись также можно использовать и для извлечения атрибутов: </p><pre class="screen">
SELECT name(new_emp());

 name
------
 None
</pre><p> Как рассказывалось в <a class="xref" href="rowtypes.html#ROWTYPES-USAGE" title="8.16.5. Использование составных типов в запросах">Подразделе 8.16.5</a>, запись с указанием поля и функциональная запись являются равнозначными.</p><p>Ещё один вариант использования функции, возвращающей составной тип, заключается в передаче её результата другой функции, которая принимает этот тип строки на вход: </p><pre class="screen">
CREATE FUNCTION getname(emp) RETURNS text AS $$
    SELECT $1.name;
$$ LANGUAGE SQL;

SELECT getname(new_emp());
 getname
---------
 None
(1 row)
</pre></div><div class="sect2" id="XFUNC-OUTPUT-PARAMETERS"><div class="titlepage"><div><div><h3 class="title">38.5.4. Функции <acronym class="acronym">SQL</acronym> с выходными параметрами <a href="#XFUNC-OUTPUT-PARAMETERS" class="id_link">#</a></h3></div></div></div><a id="id-1.8.3.8.13.2" class="indexterm"></a><p>Альтернативный способ описать результаты функции — определить её с <em class="firstterm">выходными параметрами</em>, как в этом примере: </p><pre class="screen">
CREATE FUNCTION add_em (IN x int, IN y int, OUT sum int)
AS 'SELECT x + y'
LANGUAGE SQL;

SELECT add_em(3,7);
 add_em
--------
     10
(1 row)
</pre><p> Это по сути не отличается от версии <code class="literal">add_em</code>, показанной в <a class="xref" href="xfunc-sql.html#XFUNC-SQL-BASE-FUNCTIONS" title="38.5.2. Функции SQL с базовыми типами">Подразделе 38.5.2</a>. Действительная ценность выходных параметров в том, что они позволяют удобным способом определить функции, возвращающие несколько столбцов. Например: </p><pre class="screen">
CREATE FUNCTION sum_n_product (x int, y int, OUT sum int, OUT product int)
AS 'SELECT x + y, x * y'
LANGUAGE SQL;

 SELECT * FROM sum_n_product(11,42);
 sum | product
-----+---------
  53 |     462
(1 row)
</pre><p> Фактически здесь мы определили анонимный составной тип для результата функции. Показанный выше пример даёт тот же конечный результат, что и команды: </p><pre class="screen">
CREATE TYPE sum_prod AS (sum int, product int);

CREATE FUNCTION sum_n_product (int, int) RETURNS sum_prod
AS 'SELECT $1 + $2, $1 * $2'
LANGUAGE SQL;
</pre><p> Но предыдущий вариант зачастую удобнее, так как он не требует отдельно заниматься определением составного типа. Заметьте, что имена, назначаемые выходным параметрам, не просто декоративные, а определяют имена столбцов анонимного составного типа. (Если вы опустите имя выходного параметра, система выберет имя сама.)</p><p>Заметьте, что выходные параметры не включаются в список аргументов при вызове такой функции из SQL. Это объясняется тем, что <span class="productname">PostgreSQL</span> определяет сигнатуру вызова функции, рассматривая только входные параметры. Это также значит, что при таких операциях, как удаление функции, в ссылках на функцию учитываются только типы входных параметров. Таким образом, удалить эту конкретную функцию можно любой из этих команд: </p><pre class="screen">
DROP FUNCTION sum_n_product (x int, y int, OUT sum int, OUT product int);
DROP FUNCTION sum_n_product (int, int);
</pre><p>Параметры функции могут быть объявлены как <code class="literal">IN</code> (по умолчанию), <code class="literal">OUT</code>, <code class="literal">INOUT</code> или <code class="literal">VARIADIC</code>. Параметр <code class="literal">INOUT</code> действует как входной (является частью списка аргументов при вызове) и как выходной (часть типа записи результата). Параметры <code class="literal">VARIADIC</code> являются входными, но обрабатывается специальным образом, как описано далее.</p></div><div class="sect2" id="XFUNC-OUTPUT-PARAMETERS-PROC"><div class="titlepage"><div><div><h3 class="title">38.5.5. Процедуры <acronym class="acronym">SQL</acronym> с выходными параметрами <a href="#XFUNC-OUTPUT-PARAMETERS-PROC" class="id_link">#</a></h3></div></div></div><a id="id-1.8.3.8.14.2" class="indexterm"></a><p>Процедуры также поддерживают выходные параметры, но несколько иначе, чем функции. В командах <code class="command">CALL</code> выходные параметры должны быть включены в список аргументов. Например, описанную ранее операцию списания средств с банковского счета можно записать следующим образом: </p><pre class="programlisting">CREATE PROCEDURE tp1 (accountno integer, debit numeric, OUT new_balance numeric) AS $$
    UPDATE bank
        SET balance = balance - debit
        WHERE accountno = tp1.accountno
    RETURNING balance;
$$ LANGUAGE SQL;</pre><p> Для вызова этой процедуры необходимо задать аргумент, соответствующий параметру <code class="literal">OUT</code>. Обычно принято писать <code class="literal">NULL</code>: </p><pre class="programlisting">CALL tp1(17, 100.0, NULL);</pre><p> Если вы пишете что-то ещё, то это должно быть выражение, неявно приводимое к объявленному типу параметра, как и для входных параметров. Однако обратите внимание, что такое выражение не вычисляется.</p><p>Вызывая процедуру из <span class="application">PL/pgSQL</span>, вместо <code class="literal">NULL</code> вы должны написать переменную, которая будет получать результат процедуры. За подробностями обратитесь к <a class="xref" href="plpgsql-control-structures.html#PLPGSQL-STATEMENTS-CALLING-PROCEDURE" title="43.6.3. Вызов процедуры">Подразделу 43.6.3</a>.</p></div><div class="sect2" id="XFUNC-SQL-VARIADIC-FUNCTIONS"><div class="titlepage"><div><div><h3 class="title">38.5.6. Функции <acronym class="acronym">SQL</acronym> с переменным числом аргументов <a href="#XFUNC-SQL-VARIADIC-FUNCTIONS" class="id_link">#</a></h3></div></div></div><a id="id-1.8.3.8.15.2" class="indexterm"></a><a id="id-1.8.3.8.15.3" class="indexterm"></a><p>Функции <acronym class="acronym">SQL</acronym> могут быть объявлены как принимающие переменное число аргументов, с условием, что все <span class="quote">«<span class="quote">необязательные</span>»</span> аргументы имеют один тип данных. Необязательные аргументы будут переданы такой функции в виде массива. Для этого в объявлении функции последний параметр помечается как <code class="literal">VARIADIC</code>; при этом он должен иметь тип массива. Например: </p><pre class="screen">
CREATE FUNCTION mleast(VARIADIC arr numeric[]) RETURNS numeric AS $$
    SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;

SELECT mleast(10, -1, 5, 4.4);
 mleast
--------
     -1
(1 row)
</pre><p> По сути, все фактические аргументы, начиная с позиции <code class="literal">VARIADIC</code>, собираются в одномерный массив, как если бы вы написали </p><pre class="screen">
SELECT mleast(ARRAY[10, -1, 5, 4.4]);    -- это не будет работать
</pre><p> На самом деле так вызвать эту функцию нельзя, или, по крайней мере, это не будет соответствовать определению функции. Параметру <code class="literal">VARIADIC</code> соответствуют одно или несколько вхождений типа его элемента, но не его собственного типа.</p><p>Но иногда бывает полезно передать функции с переменными параметрами уже подготовленный массив; особенно когда одна функция с переменными параметрами хочет передавать свой массив параметров другой. Также это более безопасный способ вызывать такую функцию, существующую в схеме, где могут создавать объекты недоверенные пользователи; см. <a class="xref" href="typeconv-func.html" title="10.3. Функции">Раздел 10.3</a>. Это можно сделать, добавив <code class="literal">VARIADIC</code> в вызов: </p><pre class="screen">
SELECT mleast(VARIADIC ARRAY[10, -1, 5, 4.4]);
</pre><p> Это предотвращает разворачивание переменного множества параметров функции в базовый тип, что позволяет сопоставить с ним значение типа массива. <code class="literal">VARIADIC</code> можно добавить только к последнему фактическому аргументу вызова функции.</p><p>Также указание <code class="literal">VARIADIC</code> даёт единственную возможность передать пустой массив функции с переменными параметрами, например, так: </p><pre class="screen">
SELECT mleast(VARIADIC ARRAY[]::numeric[]);
</pre><p> Простой вызов <code class="literal">SELECT mleast()</code> не будет работать, так как переменным параметрам должен соответствовать минимум один фактический аргумент. (Можно определить вторую функцию с таким же именем <code class="literal">mleast</code>, но без параметров, если вы хотите выполнять такие вызовы.)</p><p>Элементы массива, создаваемые из переменных параметров, считаются не имеющими собственных имён. Это означает, что передать функции с переменными параметрами именованные аргументы нельзя (см. <a class="xref" href="sql-syntax-calling-funcs.html" title="4.3. Вызов функций">Раздел 4.3</a>), если только при вызове не добавлено <code class="literal">VARIADIC</code>. Например, этот вариант будет работать: </p><pre class="screen">
SELECT mleast(VARIADIC arr =&gt; ARRAY[10, -1, 5, 4.4]);
</pre><p> А эти варианты нет: </p><pre class="screen">
SELECT mleast(arr =&gt; 10);
SELECT mleast(arr =&gt; ARRAY[10, -1, 5, 4.4]);
</pre></div><div class="sect2" id="XFUNC-SQL-PARAMETER-DEFAULTS"><div class="titlepage"><div><div><h3 class="title">38.5.7. Функции <acronym class="acronym">SQL</acronym> со значениями аргументов по умолчанию <a href="#XFUNC-SQL-PARAMETER-DEFAULTS" class="id_link">#</a></h3></div></div></div><a id="id-1.8.3.8.16.2" class="indexterm"></a><p>Функции могут быть объявлены со значениями по умолчанию для некоторых или всех входных аргументов. Значения по умолчанию подставляются, когда функция вызывается с недостаточным количеством фактических аргументов. Так как аргументы можно опускать только с конца списка фактических аргументов, все параметры после параметра со значением по умолчанию также получат значения по умолчанию. (Хотя запись с именованными аргументами могла бы ослабить это ограничение, оно всё же остаётся в силе, чтобы позиционные ссылки на аргументы оставались действительными.) Независимо от того, используете вы эту возможность или нет, она требует осторожности при вызове функций в базах данных, где одни пользователи не доверяют другим; см. <a class="xref" href="typeconv-func.html" title="10.3. Функции">Раздел 10.3</a>.</p><p>Например: </p><pre class="screen">
CREATE FUNCTION foo(a int, b int DEFAULT 2, c int DEFAULT 3)
RETURNS int
LANGUAGE SQL
AS $$
    SELECT $1 + $2 + $3;
$$;

SELECT foo(10, 20, 30);
 foo
-----
  60
(1 row)

SELECT foo(10, 20);
 foo
-----
  33
(1 row)

SELECT foo(10);
 foo
-----
  15
(1 row)

SELECT foo();  -- не работает из-за отсутствия значения по умолчанию для первого аргумента
ERROR:  function foo() does not exist
</pre><p> (ОШИБКА: функция foo() не существует) Вместо ключевого слова <code class="literal">DEFAULT</code> можно использовать знак <code class="literal">=</code>.</p></div><div class="sect2" id="XFUNC-SQL-TABLE-FUNCTIONS"><div class="titlepage"><div><div><h3 class="title">38.5.8. Функции <acronym class="acronym">SQL</acronym>, порождающие таблицы <a href="#XFUNC-SQL-TABLE-FUNCTIONS" class="id_link">#</a></h3></div></div></div><p>Все функции SQL можно использовать в предложении <code class="literal">FROM</code> запросов, но наиболее полезно это для функций, возвращающих составные типы. Если функция объявлена как возвращающая базовый тип, она возвращает таблицу с одним столбцом. Если же функция объявлена как возвращающая составной тип, она возвращает таблицу со столбцами для каждого атрибута составного типа.</p><p>Например: </p><pre class="screen">
CREATE TABLE foo (fooid int, foosubid int, fooname text);
INSERT INTO foo VALUES (1, 1, 'Joe');
INSERT INTO foo VALUES (1, 2, 'Ed');
INSERT INTO foo VALUES (2, 1, 'Mary');

CREATE FUNCTION getfoo(int) RETURNS foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT *, upper(fooname) FROM getfoo(1) AS t1;

 fooid | foosubid | fooname | upper
-------+----------+---------+-------
     1 |        1 | Joe     | JOE
(1 row)
</pre><p> Как показывает этот пример, мы можем работать со столбцами результата функции так же, как если бы это были столбцы обычной таблицы.</p><p>Заметьте, что мы получаем из данной функции только одну строку. Это объясняется тем, что мы не использовали указание <code class="literal">SETOF</code>. Оно описывается в следующем разделе.</p></div><div class="sect2" id="XFUNC-SQL-FUNCTIONS-RETURNING-SET"><div class="titlepage"><div><div><h3 class="title">38.5.9. Функции <acronym class="acronym">SQL</acronym>, возвращающие множества <a href="#XFUNC-SQL-FUNCTIONS-RETURNING-SET" class="id_link">#</a></h3></div></div></div><a id="id-1.8.3.8.18.2" class="indexterm"></a><p>Когда SQL-функция объявляется как возвращающая <code class="literal">SETOF <em class="replaceable"><code>некий_тип</code></em></code>, конечный запрос функции выполняется до завершения и каждая строка выводится как элемент результирующего множества.</p><p>Это обычно используется, когда функция вызывается в предложении <code class="literal">FROM</code>. В этом случае каждая строка, возвращаемая функцией, становится строкой таблицы, появляющейся в запросе. Например, в предположении, что таблица <code class="literal">foo</code> имеет то же содержимое, что и раньше, мы выполняем: </p><pre class="programlisting">CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT * FROM getfoo(1) AS t1;</pre><p> Тогда в ответ мы получим: </p><pre class="screen">
 fooid | foosubid | fooname
-------+----------+---------
     1 |        1 | Joe
     1 |        2 | Ed
(2 rows)
</pre><p>Также возможно выдать несколько строк со столбцами, определяемыми выходными параметрами, следующим образом: </p><pre class="programlisting">CREATE TABLE tab (y int, z int);
INSERT INTO tab VALUES (1, 2), (3, 4), (5, 6), (7, 8);

CREATE FUNCTION sum_n_product_with_tab (x int, OUT sum int, OUT product int)
RETURNS SETOF record
AS $$
    SELECT $1 + tab.y, $1 * tab.y FROM tab;
$$ LANGUAGE SQL;

SELECT * FROM sum_n_product_with_tab(10);
 sum | product
-----+---------
  11 |      10
  13 |      30
  15 |      50
  17 |      70
(4 rows)</pre><p> Здесь ключевая особенность заключается в записи <code class="literal">RETURNS SETOF record</code>, показывающей, что функция возвращает множество строк вместо одной. Если существует только один выходной параметр, укажите тип этого параметра вместо <code class="type">record</code>.</p><p>Часто бывает полезно сконструировать результат запроса, вызывая функцию, возвращающую множество, несколько раз, передавая при каждом вызове параметры из очередных строк таблицы или подзапроса. Для этого рекомендуется применить ключевое слово <code class="literal">LATERAL</code>, описываемое в <a class="xref" href="queries-table-expressions.html#QUERIES-LATERAL" title="7.2.1.5. Подзапросы LATERAL">Подразделе 7.2.1.5</a>. Ниже приведён пример использования функции, возвращающей множество, для перечисления элементов древовидной структуры: </p><pre class="screen">
SELECT * FROM nodes;
   name    | parent
-----------+--------
 Top       |
 Child1    | Top
 Child2    | Top
 Child3    | Top
 SubChild1 | Child1
 SubChild2 | Child1
(6 rows)

CREATE FUNCTION listchildren(text) RETURNS SETOF text AS $$
    SELECT name FROM nodes WHERE parent = $1
$$ LANGUAGE SQL STABLE;

SELECT * FROM listchildren('Top');
 listchildren
--------------
 Child1
 Child2
 Child3
(3 rows)

SELECT name, child FROM nodes, LATERAL listchildren(name) AS child;
  name  |   child
--------+-----------
 Top    | Child1
 Top    | Child2
 Top    | Child3
 Child1 | SubChild1
 Child1 | SubChild2
(5 rows)
</pre><p> В этом примере не делается ничего такого, что мы не могли бы сделать, применив простое соединение, но для более сложных вычислений возможность поместить некоторую логику в функцию может быть весьма удобной.</p><p>Функции, возвращающие множества, могут также вызываться в списке выборки запроса. Для каждой строки, которая генерируется самим запросом, вызывается функция, возвращающая множество, и для каждого элемента набора её результатов генерируется отдельная строка. Предыдущий пример можно было бы также переписать с применением запросов следующим образом: </p><pre class="screen">
SELECT listchildren('Top');
 listchildren
--------------
 Child1
 Child2
 Child3
(3 rows)

SELECT name, listchildren(name) FROM nodes;
  name  | listchildren
--------+--------------
 Top    | Child1
 Top    | Child2
 Top    | Child3
 Child1 | SubChild1
 Child1 | SubChild2
(5 rows)
</pre><p> Заметьте, что в последней команде <code class="command">SELECT</code> для <code class="literal">Child2</code>, <code class="literal">Child3</code> и т. д. строки не выдаются. Это происходит потому, что <code class="function">listchildren</code> возвращает пустое множество для этих аргументов, так что строки результата не генерируются. Это же поведение мы получаем при внутреннем соединении с результатом функции с применением <code class="literal">LATERAL</code>.</p><p>Поведение <span class="productname">PostgreSQL</span> с функциями, возвращающими множества, в списке выборки запроса практически не отличается от поведения с такими функциями, помещёнными в предложение <code class="literal">LATERAL FROM</code>. Например, запрос: </p><pre class="programlisting">SELECT x, generate_series(1,5) AS g FROM tab;</pre><p> почти равнозначен </p><pre class="programlisting">SELECT x, g FROM tab, LATERAL generate_series(1,5) AS g;</pre><p> Он мог быть полностью идентичным, но в данном конкретном примере планировщик может решить перенести <code class="structname">g</code> во внешнюю сторону соединения, так как <code class="structname">g</code> не имеет фактической зависимости по времени вычисления от <code class="structname">tab</code>. Такое решение привело бы к изменению порядка строк. Функции, возвращающие множества, в списке выборки всегда вычисляются так, как они вычислялись бы внутри соединения с вложенным циклом с остальным предложением <code class="literal">FROM</code>, так что эти функции выполняются до завершения прежде чем начинается рассмотрение следующей строки из предложения <code class="literal">FROM</code>.</p><p>Если в списке выборки запроса используются несколько функций, возвращающих запросы, они вычисляются примерно так же, как если бы они были помещены в один элемент <code class="literal">LATERAL ROWS FROM( ... )</code> предложения <code class="literal">FROM</code>. Для каждой строки из нижележащего запроса выдаётся строка с первым результатом каждой функции, а затем строка со вторым результатом и так далее. Если какие-либо из функций, возвращающих множества, выдают меньше результатов, чем другие, то вместо недостающих данных подставляются значения NULL, так что общее число строк, выдаваемых для одной нижележащей строки, равно числу строк, которое выдаёт функция с наибольшим количеством строк в возвращаемом множестве. Таким образом, функции, возвращающие множества, выполняются совместно, пока все их множества не будут исчерпаны, а затем выполнение продолжается со следующей нижележащей строкой.</p><p>Функции, возвращающие множества, могут быть вложенными в списке выборки, но это не допускается в элементах предложения <code class="literal">FROM</code>. В таких случаях каждый уровень вложенности обрабатывается отдельно, как если бы это был отдельный элемент <code class="literal">LATERAL ROWS FROM( ... )</code>. Например, в </p><pre class="programlisting">SELECT srf1(srf2(x), srf3(y)), srf4(srf5(z)) FROM tab;</pre><p> возвращающие множества функции <code class="function">srf2</code>, <code class="function">srf3</code> и <code class="function">srf5</code> будут выполняться совместно для каждой строки <code class="structname">tab</code>, а затем <code class="function">srf1</code> и <code class="function">srf4</code> будут совместно применяться к каждой строке, произведённой нижними функциями.</p><p>Функции, возвращающие множества, нельзя использовать в конструкциях, вычисляемых по условию, например, <code class="literal">CASE</code> или <code class="literal">COALESCE</code>. Например, рассмотрите запрос </p><pre class="programlisting">SELECT x, CASE WHEN x &gt; 0 THEN generate_series(1, 5) ELSE 0 END FROM tab;</pre><p> Может показаться, что он должен выдать пять экземпляров входных строк, в которых <code class="literal">x &gt; 0</code>, и по одному экземпляру остальных строк; но на деле, так как <code class="function">generate_series(1, 5)</code> будет выполняться в неявном элементе <code class="literal">LATERAL FROM</code> до того, как выражение <code class="literal">CASE</code> вообще будет рассматриваться, должно было бы выдаваться пять экземпляров абсолютно всех выходных строк. Во избежание путаницы в таких случаях выдаётся ошибка при разборе запроса.</p><div class="note"><h3 class="title">Примечание</h3><p>Если последняя команда функции — <code class="command">INSERT</code>, <code class="command">UPDATE</code> или <code class="command">DELETE</code> с <code class="literal">RETURNING</code>, эта команда будет всегда выполняться до завершения, даже если функция не объявлена с указанием <code class="literal">SETOF</code> или вызывающий запрос не выбирает все строки результата. Все дополнительные строки, выданные предложением <code class="literal">RETURNING</code>, просто игнорируются, но соответствующие изменения в таблице всё равно произойдут (и будут завершены до выхода из функции).</p></div><div class="note"><h3 class="title">Примечание</h3><p>В <span class="productname">PostgreSQL</span> до версии 10 при помещении нескольких функций, возвращающих множества, в один список выборки поведение было не очень разумным, если они возвращали не одинаковое число строк. В таких случаях число выходных строк равнялось наименьшему общему множителю количеств строк, возвращаемых этими функциями. Также и вложенные функции, возвращающие множества, работали не так, как описано выше; у такой функции мог быть максимум один аргумент, возвращающий множество, и каждая вложенность вычислялась независимо. Кроме того, ранее допускалось и условное выполнение (вычисление таких функций внутри <code class="literal">CASE</code> и т. п.), что ещё больше всё усложняло. При написании запросов, которые должны работать и со старыми версиями <span class="productname">PostgreSQL</span>, рекомендуется использовать синтаксис <code class="literal">LATERAL</code>, так как это гарантирует одинаковый результат с разными версиями. Если в вашем запросе используется условное вычисление функции, возвращающей множество, его можно исправить, переместив проверку условия в специально созданную функцию, возвращающую множество. Например: </p><pre class="programlisting">SELECT x, CASE WHEN y &gt; 0 THEN generate_series(1, z) ELSE 5 END FROM tab;</pre><p> можно заменить на </p><pre class="programlisting">CREATE FUNCTION case_generate_series(cond bool, start int, fin int, els int)
  RETURNS SETOF int AS $$
BEGIN
  IF cond THEN
    RETURN QUERY SELECT generate_series(start, fin);
  ELSE
    RETURN QUERY SELECT els;
  END IF;
END$$ LANGUAGE plpgsql;

SELECT x, case_generate_series(y &gt; 0, 1, z, 5) FROM tab;</pre><p> Это будет работать одинаково во всех версиях <span class="productname">PostgreSQL</span>.</p></div></div><div class="sect2" id="XFUNC-SQL-FUNCTIONS-RETURNING-TABLE"><div class="titlepage"><div><div><h3 class="title">38.5.10. Функции <acronym class="acronym">SQL</acronym>, возвращающие таблицы (<code class="literal">TABLE</code>) <a href="#XFUNC-SQL-FUNCTIONS-RETURNING-TABLE" class="id_link">#</a></h3></div></div></div><a id="id-1.8.3.8.19.2" class="indexterm"></a><p>Есть ещё один способ объявить функцию, возвращающую множества, — использовать синтаксис <code class="literal">RETURNS TABLE(<em class="replaceable"><code>столбцы</code></em>)</code>. Это равнозначно использованию одного или нескольких параметров <code class="literal">OUT</code> с объявлением функции как возвращающей <code class="literal">SETOF record</code> (или <code class="literal">SETOF</code> тип единственного параметра, если это применимо). Этот синтаксис описан в последних версиях стандарта SQL, так что этот вариант может быть более портируемым, чем <code class="literal">SETOF</code>.</p><p>Например, предыдущий пример с суммой и произведением можно также переписать так: </p><pre class="programlisting">CREATE FUNCTION sum_n_product_with_tab (x int)
RETURNS TABLE(sum int, product int) AS $$
    SELECT $1 + tab.y, $1 * tab.y FROM tab;
$$ LANGUAGE SQL;</pre><p> Запись <code class="literal">RETURNS TABLE</code> не позволяет явно указывать <code class="literal">OUT</code> и <code class="literal">INOUT</code> для параметров — все выходные столбцы необходимо записать в списке <code class="literal">TABLE</code>.</p></div><div class="sect2" id="XFUNC-SQL-POLYMORPHIC-FUNCTIONS"><div class="titlepage"><div><div><h3 class="title">38.5.11. Полиморфные функции <acronym class="acronym">SQL</acronym> <a href="#XFUNC-SQL-POLYMORPHIC-FUNCTIONS" class="id_link">#</a></h3></div></div></div><p>Функции <acronym class="acronym">SQL</acronym> могут быть объявлены как принимающие и возвращающие полиморфные типы, описанные в <a class="xref" href="extend-type-system.html#EXTEND-TYPES-POLYMORPHIC" title="38.2.5. Полиморфные типы">Подразделе 38.2.5</a>. В следующем примере полиморфная функция <code class="function">make_array</code> создаёт массив из двух элементов произвольных типов: </p><pre class="screen">
CREATE FUNCTION make_array(anyelement, anyelement) RETURNS anyarray AS $$
    SELECT ARRAY[$1, $2];
$$ LANGUAGE SQL;

SELECT make_array(1, 2) AS intarray, make_array('a'::text, 'b') AS textarray;
 intarray | textarray
----------+-----------
 {1,2}    | {a,b}
(1 row)
</pre><p>Обратите внимание на приведение типа <code class="literal">'a'::text</code>, определяющее, что аргумент имеет тип <code class="type">text</code>. Оно необходимо, если аргумент задаётся просто строковой константой, так как иначе он будет воспринят как имеющий тип <code class="type">unknown</code>, а массив типов <code class="type">unknown</code> является недопустимым. Без этого приведения вы получите такую ошибку: </p><pre class="screen">
<code class="computeroutput">
ERROR:  could not determine polymorphic type because input has type unknown
</code>
</pre><p> (ОШИБКА:  не удалось определить полиморфный тип, так как входные аргументы имеют тип unknown)</p><p>С показанным выше объявлением <code class="function">make_array</code> этой функции нужно предоставить два аргумента, имеющих один и тот же тип данных; система не будет пытаться совмещать различные типы. Так, например, следующий вызов не будет работать: </p><pre class="screen">
SELECT make_array(1, 2.5) AS numericarray;
ERROR:  function make_array(integer, numeric) does not exist
</pre><p> (ОШИБКА: функция make_array(integer, numeric) не существует) Альтернативный подход заключается в использовании <span class="quote">«<span class="quote">общего</span>»</span> семейства полиморфных типов; в этом случае система попытается найти подходящий общий тип: </p><pre class="screen">
CREATE FUNCTION make_array2(anycompatible, anycompatible)
RETURNS anycompatiblearray AS $$
    SELECT ARRAY[$1, $2];
$$ LANGUAGE SQL;

SELECT make_array2(1, 2.5) AS numericarray;
 numericarray
--------------
 {1,2.5}
(1 row)
</pre><p> Так как правила нахождения общего типа по умолчанию сводятся к выбору типа <code class="type">text</code>, когда все аргументы имеют неизвестные типы, работать будет и следующий вызов: </p><pre class="screen">
SELECT make_array2('a', 'b') AS textarray;
 textarray 
-----------
 {a,b}
(1 row)
</pre><p>Функция с полиморфными аргументами может иметь фиксированный тип результата, однако обратное не допускается. Например: </p><pre class="screen">
CREATE FUNCTION is_greater(anyelement, anyelement) RETURNS boolean AS $$
    SELECT $1 &gt; $2;
$$ LANGUAGE SQL;

SELECT is_greater(1, 2);
 is_greater
------------
 f
(1 row)

CREATE FUNCTION invalid_func() RETURNS anyelement AS $$
    SELECT 1;
$$ LANGUAGE SQL;
ERROR:  cannot determine result data type
DETAIL:  A result of type anyelement requires at least one input of type anyelement, anyarray, anynonarray, anyenum, or anyrange.
</pre><p> (ОШИБКА: не удалось определить тип результата; ПОДРОБНОСТИ: Для результата типа anyelement требуется минимум один аргумент типа anyelement, anyarray, anynonarray, anyenum или anyrange.)</p><p>Полиморфизм можно применять и с функциями, имеющими выходные аргументы. Например: </p><pre class="screen">
CREATE FUNCTION dup (f1 anyelement, OUT f2 anyelement, OUT f3 anyarray)
AS 'select $1, array[$1,$1]' LANGUAGE SQL;

SELECT * FROM dup(22);
 f2 |   f3
----+---------
 22 | {22,22}
(1 row)
</pre><p>Полиморфизм также можно применять с функциями с переменными параметрами. Например: </p><pre class="screen">
CREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS $$
    SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;

SELECT anyleast(10, -1, 5, 4);
 anyleast 
----------
       -1
(1 row)

SELECT anyleast('abc'::text, 'def');
 anyleast 
----------
 abc
(1 row)

CREATE FUNCTION concat_values(text, VARIADIC anyarray) RETURNS text AS $$
    SELECT array_to_string($2, $1);
$$ LANGUAGE SQL;

SELECT concat_values('|', 1, 4, 2);
 concat_values 
---------------
 1|4|2
(1 row)
</pre></div><div class="sect2" id="XFUNC-SQL-COLLATIONS"><div class="titlepage"><div><div><h3 class="title">38.5.12. Функции <acronym class="acronym">SQL</acronym> с правилами сортировки <a href="#XFUNC-SQL-COLLATIONS" class="id_link">#</a></h3></div></div></div><a id="id-1.8.3.8.21.2" class="indexterm"></a><p>Когда функция SQL принимает один или несколько параметров сортируемых типов данных, правило сортировки определяется при каждом вызове функции, в зависимости от правил сортировки, связанных с фактическими аргументами, как описано в <a class="xref" href="collation.html" title="24.2. Поддержка правил сортировки">Разделе 24.2</a>. Если правило сортировки определено успешно (то есть не возникло конфликтов между неявно установленными правилами сортировки аргументов), оно неявно назначается для всех сортируемых параметров. Выбранное правило будет определять поведение операций, связанных с сортировкой, в данной функции. Например, для показанной выше функции <code class="function">anyleast</code>, результат </p><pre class="programlisting">SELECT anyleast('abc'::text, 'ABC');</pre><p> будет зависеть от правила сортировки по умолчанию, заданного в базе данных. С локалью <code class="literal">C</code> результатом будет строка <code class="literal">ABC</code>, но со многими другими локалями это будет <code class="literal">abc</code>. Нужное правило сортировки можно установить принудительно, добавив предложение <code class="literal">COLLATE</code> к одному из аргументов функции, например: </p><pre class="programlisting">SELECT anyleast('abc'::text, 'ABC' COLLATE "C");</pre><p> С другой стороны, если вы хотите, чтобы функция работала с определённым правилом сортировки, вне зависимости от того, с каким она была вызвана, вставьте предложения <code class="literal">COLLATE</code> где требуется в определении функции. Эта версия <code class="function">anyleast</code> всегда будет сравнивать строки по правилам локали <code class="literal">en_US</code>: </p><pre class="programlisting">CREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS $$
    SELECT min($1[i] COLLATE "en_US") FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;</pre><p> Но заметьте, что при попытке применить правило к несортируемому типу данных, возникнет ошибка.</p><p>Если для фактических аргументов не удаётся определить общее правило сортировки, функция SQL считает, что им назначено правило сортировки по умолчанию для их типа данных (обычно это то же правило сортировки, что определено по умолчанию для базы данных, но оно может быть и другим для параметров доменных типов).</p><p>Поведение сортируемых параметров можно воспринимать как ограниченную форму полиморфизма, применимую только к текстовым типам данных.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="xproc.html" title="38.4. Пользовательские процедуры">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="extend.html" title="Глава 38. Расширение SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="xfunc-overload.html" title="38.6. Перегрузка функций">След.</a></td></tr><tr><td width="40%" align="left" valign="top">38.4. Пользовательские процедуры </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 38.6. Перегрузка функций</td></tr></table></div></body></html>