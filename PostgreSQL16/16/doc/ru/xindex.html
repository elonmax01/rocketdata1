<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>38.16. Интерфейсы расширений для индексов</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="xoper-optimization.html" title="38.15. Информация для оптимизации операторов" /><link rel="next" href="extend-extensions.html" title="38.17. Упаковывание связанных объектов в расширение" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">38.16. Интерфейсы расширений для индексов</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="xoper-optimization.html" title="38.15. Информация для оптимизации операторов">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="extend.html" title="Глава 38. Расширение SQL">Наверх</a></td><th width="60%" align="center">Глава 38. Расширение <acronym class="acronym">SQL</acronym></th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="extend-extensions.html" title="38.17. Упаковывание связанных объектов в расширение">След.</a></td></tr></table><hr /></div><div class="sect1" id="XINDEX"><div class="titlepage"><div><div><h2 class="title" style="clear: both">38.16. Интерфейсы расширений для индексов <a href="#XINDEX" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="xindex.html#XINDEX-OPCLASS">38.16.1. Методы индексов и классы операторов</a></span></dt><dt><span class="sect2"><a href="xindex.html#XINDEX-STRATEGIES">38.16.2. Стратегии методов индексов</a></span></dt><dt><span class="sect2"><a href="xindex.html#XINDEX-SUPPORT">38.16.3. Опорные процедуры метода индекса</a></span></dt><dt><span class="sect2"><a href="xindex.html#XINDEX-EXAMPLE">38.16.4. Пример</a></span></dt><dt><span class="sect2"><a href="xindex.html#XINDEX-OPFAMILY">38.16.5. Семейства и классы операторов</a></span></dt><dt><span class="sect2"><a href="xindex.html#XINDEX-OPCLASS-DEPENDENCIES">38.16.6. Системные зависимости от классов операторов</a></span></dt><dt><span class="sect2"><a href="xindex.html#XINDEX-ORDERING-OPS">38.16.7. Операторы упорядочивания</a></span></dt><dt><span class="sect2"><a href="xindex.html#XINDEX-OPCLASS-FEATURES">38.16.8. Особенности классов операторов</a></span></dt></dl></div><a id="id-1.8.3.19.2" class="indexterm"></a><p>Описанные до этого процедуры позволяли определять новые типы, функции и операторы. Однако мы ещё не можем определить индекс по столбцу нового типа данных. Для этого нам потребуется создать <em class="firstterm">класс операторов</em> для нового типа данных. Далее в этом разделе мы продемонстрируем эту концепцию на примере: мы создадим новый класс операторов для метода индекса-B-дерева, в котором будут храниться комплексные числа и сортироваться по возрастанию абсолютного значения.</p><p>Классы операторов могут объединяться в <em class="firstterm">семейства операторов</em>, выражающие зависимости между семантически совместимыми классами. Когда вводится один тип данных, достаточно класса операторов, так что мы начнём с него, а к семействам операторов вернёмся позже.</p><div class="sect2" id="XINDEX-OPCLASS"><div class="titlepage"><div><div><h3 class="title">38.16.1. Методы индексов и классы операторов <a href="#XINDEX-OPCLASS" class="id_link">#</a></h3></div></div></div><p>В системном каталоге есть таблица <code class="classname">pg_am</code>, содержащая записи для каждого метода индекса (внутри называемого методом доступа). Поддержка обычного доступа к таблицам встроена в <span class="productname">PostgreSQL</span>, но все методы доступа описываются в <code class="classname">pg_am</code>. Система позволяет добавлять новые методы доступа — для этого нужно написать необходимый код, а затем добавить запись в <code class="classname">pg_am</code>, но это выходит за рамки данной главы (см. <a class="xref" href="indexam.html" title="Глава 64. Определение интерфейса для индексных методов доступа">Главу 64</a>).</p><p>Процедуры метода индекса непосредственно ничего не знают о типах данных, с которыми будет применяться этот метод. Вместо этого, набор операций, которые нужны методу индекса для работы с конкретным типом данных, определяется <em class="firstterm">классом операторов</em><a id="id-1.8.3.19.5.3.2" class="indexterm"></a>. Классы операторов называются так потому, что они определяют множество операторов в предложении <code class="literal">WHERE</code>, которые могут использоваться с индексом (т. е. могут быть сведены к сканированию индекса). В классе операторов могут также определяться некоторые <em class="firstterm">опорные функции</em>, необходимые для внутренних операций метода индекса, но они не соответствуют напрямую каким-либо операторам предложения <code class="literal">WHERE</code>, которые могут обрабатываться с индексом.</p><p>Для одного типа данных и метода индекса можно определить несколько классов операторов. Благодаря этому, для одного типа данных можно использовать несколько семантически разных вариантов индексирования. Например, индекс-B-дерево требует, чтобы для каждого типа данных, с которым он работает, определялся порядок сортировки. Для типа комплексных чисел может быть полезен класс операторов B-дерева, сортирующий данные по модулю комплексного числа, и ещё один, сортирующий по вещественной части, и т. п. Обычно предполагается, что один из классов операторов будет применяться чаще других, и тогда он помечается как класс по умолчанию для данного типа и метода индекса.</p><p>Одно и то же имя класса операторов может использоваться для разных методов индекса (например, для методов индекса-B-дерева или хеш-индекса применяются классы операторов <code class="literal">int4_ops</code>), но все такие классы являются независимыми и должны определяться отдельно.</p></div><div class="sect2" id="XINDEX-STRATEGIES"><div class="titlepage"><div><div><h3 class="title">38.16.2. Стратегии методов индексов <a href="#XINDEX-STRATEGIES" class="id_link">#</a></h3></div></div></div><p>Операторам, которые связываются с классом операторов, назначаются <span class="quote">«<span class="quote">номера стратегий</span>»</span>, определяющие роль каждого оператора в контексте его класса. Например, в B-дереве должен быть строгий порядок ключей с отношениями меньше/больше, так что в данном контексте представляют интерес операторы <span class="quote">«<span class="quote">меньше</span>»</span> и <span class="quote">«<span class="quote">больше или равно</span>»</span>. Так как <span class="productname">PostgreSQL</span> позволяет пользователям определять операторы произвольным образом, <span class="productname">PostgreSQL</span> не может просто посмотреть на имя оператора (<code class="literal">&lt;</code> или <code class="literal">&gt;=</code>) и сказать, какое сравнение он выполняет. Вместо этого для метода индекса определяется набор <span class="quote">«<span class="quote">стратегий</span>»</span>, которые можно считать обобщёнными операторами. Каждый класс операторов устанавливает, какие фактические операторы соответствуют стратегиям для определённого типа данных и интерпретации семантики индекса.</p><p>Для метода индекса-B-дерева определены пять стратегий, описанных в <a class="xref" href="xindex.html#XINDEX-BTREE-STRAT-TABLE" title="Таблица 38.3. Стратегии B-дерева">Таблице 38.3</a>.</p><div class="table" id="XINDEX-BTREE-STRAT-TABLE"><p class="title"><strong>Таблица 38.3. Стратегии B-дерева</strong></p><div class="table-contents"><table class="table" summary="Стратегии B-дерева" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Операция</th><th>Номер стратегии</th></tr></thead><tbody><tr><td>меньше</td><td>1</td></tr><tr><td>меньше или равно</td><td>2</td></tr><tr><td>равно</td><td>3</td></tr><tr><td>больше или равно</td><td>4</td></tr><tr><td>больше</td><td>5</td></tr></tbody></table></div></div><br class="table-break" /><p>Индексы по хешу поддерживают только сравнение на равенство, так что они используют только одну стратегию, показанную в <a class="xref" href="xindex.html#XINDEX-HASH-STRAT-TABLE" title="Таблица 38.4. Стратегии хеша">Таблице 38.4</a>.</p><div class="table" id="XINDEX-HASH-STRAT-TABLE"><p class="title"><strong>Таблица 38.4. Стратегии хеша</strong></p><div class="table-contents"><table class="table" summary="Стратегии хеша" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Операция</th><th>Номер стратегии</th></tr></thead><tbody><tr><td>равно</td><td>1</td></tr></tbody></table></div></div><br class="table-break" /><p>Индексы GiST более гибкие: для них вообще нет фиксированного набора стратегий. Вместо этого опорная процедура <span class="quote">«<span class="quote">согласованности</span>»</span> каждого конкретного класса операторов GiST интерпретирует номера стратегий как ей угодно. Например, некоторые из встроенных классов операторов для индексов GiST индексируют двумерные геометрические объекты, и реализуют стратегии <span class="quote">«<span class="quote">R-дерева</span>»</span>, показанные в <a class="xref" href="xindex.html#XINDEX-RTREE-STRAT-TABLE" title="Таблица 38.5. Стратегии двумерного «R-дерева» индекса GiST">Таблице 38.5</a>. Четыре из них являются истинно двумерными проверками (overlaps, same, contains, contained by); другие четыре учитывают только ординаты, а ещё четыре проводят же проверки только с абсциссами.</p><div class="table" id="XINDEX-RTREE-STRAT-TABLE"><p class="title"><strong>Таблица 38.5. Стратегии двумерного <span class="quote">«<span class="quote">R-дерева</span>»</span> индекса GiST</strong></p><div class="table-contents"><table class="table" summary="Стратегии двумерного R-дерева индекса GiST" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Операция</th><th>Номер стратегии</th></tr></thead><tbody><tr><td>строго слева от</td><td>1</td></tr><tr><td>не простирается правее</td><td>2</td></tr><tr><td>пересекается с</td><td>3</td></tr><tr><td>не простирается левее</td><td>4</td></tr><tr><td>строго справа от</td><td>5</td></tr><tr><td>одинаковы</td><td>6</td></tr><tr><td>содержит</td><td>7</td></tr><tr><td>содержится в</td><td>8</td></tr><tr><td>не простирается выше</td><td>9</td></tr><tr><td>строго ниже</td><td>10</td></tr><tr><td>строго выше</td><td>11</td></tr><tr><td>не простирается ниже</td><td>12</td></tr></tbody></table></div></div><br class="table-break" /><p>Индексы SP-GiST такие же гибкие, как и индексы GiST: для них не задаётся фиксированный набор стратегий. Вместо этого опорные процедуры каждого класса операторов интерпретируют номера стратегий в соответствии с определением класса операторов. В качестве примера, в <a class="xref" href="xindex.html#XINDEX-SPGIST-POINT-STRAT-TABLE" title="Таблица 38.6. Стратегии SP-GiST для точек">Таблице 38.6</a> приведены номера стратегий, установленные для встроенных классов операторов для точек.</p><div class="table" id="XINDEX-SPGIST-POINT-STRAT-TABLE"><p class="title"><strong>Таблица 38.6. Стратегии SP-GiST для точек</strong></p><div class="table-contents"><table class="table" summary="Стратегии SP-GiST для точек" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Операция</th><th>Номер стратегии</th></tr></thead><tbody><tr><td>строго слева от</td><td>1</td></tr><tr><td>строго справа от</td><td>5</td></tr><tr><td>одинаковы</td><td>6</td></tr><tr><td>содержится в</td><td>8</td></tr><tr><td>строго ниже</td><td>10</td></tr><tr><td>строго выше</td><td>11</td></tr></tbody></table></div></div><br class="table-break" /><p>Индексы GIN такие же гибкие, как и индексы GiST и SP-GiST: для них не задаётся фиксированный набор стратегий. Вместо этого опорные процедуры каждого класса операторов интерпретируют номера стратегий в соответствии с определением класса операторов. В качестве примера, в <a class="xref" href="xindex.html#XINDEX-GIN-ARRAY-STRAT-TABLE" title="Таблица 38.7. Стратегии GIN для массивов">Таблице 38.7</a> приведены номера стратегий, установленные для встроенного класса операторов для массивов.</p><div class="table" id="XINDEX-GIN-ARRAY-STRAT-TABLE"><p class="title"><strong>Таблица 38.7. Стратегии GIN для массивов</strong></p><div class="table-contents"><table class="table" summary="Стратегии GIN для массивов" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Операция</th><th>Номер стратегии</th></tr></thead><tbody><tr><td>пересекается с</td><td>1</td></tr><tr><td>содержит</td><td>2</td></tr><tr><td>содержится в</td><td>3</td></tr><tr><td>равно</td><td>4</td></tr></tbody></table></div></div><br class="table-break" /><p>Индексы BRIN такие же гибкие, как и индексы GiST, SP-GiST и GIN: для них не задаётся фиксированный набор стратегий. Вместо этого опорные процедуры каждого класса операторов интерпретируют номера стратегий в соответствии с определением класса операторов. В качестве примера, в <a class="xref" href="xindex.html#XINDEX-BRIN-MINMAX-STRAT-TABLE" title="Таблица 38.8. Стратегии BRIN Minmax">Таблице 38.8</a> приведены номера стратегий, используемые встроенными классами операторов <code class="literal">Minmax</code>.</p><div class="table" id="XINDEX-BRIN-MINMAX-STRAT-TABLE"><p class="title"><strong>Таблица 38.8. Стратегии BRIN Minmax</strong></p><div class="table-contents"><table class="table" summary="Стратегии BRIN Minmax" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Операция</th><th>Номер стратегии</th></tr></thead><tbody><tr><td>меньше</td><td>1</td></tr><tr><td>меньше или равно</td><td>2</td></tr><tr><td>равно</td><td>3</td></tr><tr><td>больше или равно</td><td>4</td></tr><tr><td>больше</td><td>5</td></tr></tbody></table></div></div><br class="table-break" /><p>Заметьте, что все вышеперечисленные операторы возвращают булевы значения. На практике все операторы, определённые как операторы поиска для метода индекса, должны возвращать тип <code class="type">boolean</code>, так как они должны находиться на верхнем уровне предложения <code class="literal">WHERE</code>, чтобы для них применялся индекс. (Некоторые методы доступа по индексу также поддерживают <em class="firstterm">операторы упорядочивания</em>, которые обычно не возвращают булевы значения; это обсуждается в <a class="xref" href="xindex.html#XINDEX-ORDERING-OPS" title="38.16.7. Операторы упорядочивания">Подразделе 38.16.7</a>.)</p></div><div class="sect2" id="XINDEX-SUPPORT"><div class="titlepage"><div><div><h3 class="title">38.16.3. Опорные процедуры метода индекса <a href="#XINDEX-SUPPORT" class="id_link">#</a></h3></div></div></div><p>Стратегии обычно не дают системе достаточно информации, чтобы понять, как использовать индекс. На практике, чтобы методы индекса работали, необходимы дополнительные опорные процедуры. Например, метод индекса-B-дерева должен уметь сравнивать два ключа и определять, больше, равен или меньше ли первый второго. Аналогично, метод индекса по хешу должен уметь сравнивать хеш-коды значений ключа. Эти операции не соответствуют операторам, которые применяются в условиях в командах SQL; это внутрисистемные подпрограммы, используемые методами индекса.</p><p>Так же, как и со стратегиями, класс операторов определяет, какие конкретные функции должны играть каждую из ролей для определённого типа данных и интерпретации семантики индекса. Для метода индекса определяется набор нужных ему функций, а класс оператора выбирает нужные функции для применения, назначая им <span class="quote">«<span class="quote">номера опорных функций</span>»</span>, определяемые методом индекса.</p><p>Некоторые классы операторов дополнительно позволяют задать параметры, управляющие их поведением. У всех встроенных индексных методов доступа имеется необязательная опорная функция <code class="function">options</code>, которая определяет набор параметров, поддерживаемых данным классом.</p><p>Для B-деревьев требуется опорная функция сравнения и могут предоставляться четыре дополнительные опорные функции по выбору разработчика класса операторов, описанные в <a class="xref" href="xindex.html#XINDEX-BTREE-SUPPORT-TABLE" title="Таблица 38.9. Опорные функции B-деревьев">Таблице 38.9</a>. Требования к этим опорным функциям подробно рассматриваются в <a class="xref" href="btree-support-funcs.html" title="67.3. Опорные функции B-деревьев">Разделе 67.3</a>.</p><div class="table" id="XINDEX-BTREE-SUPPORT-TABLE"><p class="title"><strong>Таблица 38.9. Опорные функции B-деревьев</strong></p><div class="table-contents"><table class="table" summary="Опорные функции B-деревьев" border="1"><colgroup><col class="col1" /><col class="col2" /></colgroup><thead><tr><th>Функция</th><th>Номер опорной функции</th></tr></thead><tbody><tr><td>Сравнивает два ключа и возвращает целое меньше нуля, ноль или целое больше нуля, показывающее, что первый ключ меньше, равен или больше второго</td><td>1</td></tr><tr><td>Возвращает адреса вызываемых из C опорных функций (или функции) сортировки (необязательная)</td><td>2</td></tr><tr><td>Сравнивает проверяемое значение с базовым плюс/минус смещение и возвращает true или false в зависимости от результата сравнения (необязательная)</td><td>3</td></tr><tr><td>Определяет, может ли в индексах, использующих данный класс операторов, безопасно применяться реализованное в btree исключение дубликатов (необязательная)</td><td>4</td></tr><tr><td>Определяет параметры, относящиеся к данному классу операторов (необязательная)</td><td>5</td></tr></tbody></table></div></div><br class="table-break" /><p>Для хеш-индексов требуется одна опорная функция, и ещё две могут задаваться по выбору разработчика класса операторов, как показано в <a class="xref" href="xindex.html#XINDEX-HASH-SUPPORT-TABLE" title="Таблица 38.10. Опорные функции хеша">Таблице 38.10</a>.</p><div class="table" id="XINDEX-HASH-SUPPORT-TABLE"><p class="title"><strong>Таблица 38.10. Опорные функции хеша</strong></p><div class="table-contents"><table class="table" summary="Опорные функции хеша" border="1"><colgroup><col class="col1" /><col class="col2" /></colgroup><thead><tr><th>Функция</th><th>Номер опорной функции</th></tr></thead><tbody><tr><td>Вычисляет 32-битное значение хеша для ключа</td><td>1</td></tr><tr><td>Вычисляет 64-битное значение хеша для ключа с заданной 64-битной солью; если значение соли равно 0, младшие 32 бита результата должны соответствовать значению, которое было бы вычислено функцией 1 (необязательная)</td><td>2</td></tr><tr><td>Определяет параметры, относящиеся к данному классу операторов (необязательная)</td><td>3</td></tr></tbody></table></div></div><br class="table-break" /><p>Для индексов GiST предусмотрены одиннадцать опорных функций, шесть из которых необязательные; они описаны в <a class="xref" href="xindex.html#XINDEX-GIST-SUPPORT-TABLE" title="Таблица 38.11. Опорные функции GiST">Таблице 38.11</a>. (За дополнительными сведениями обратитесь к <a class="xref" href="gist.html" title="Глава 68. Индексы GiST">Главе 68</a>.)</p><div class="table" id="XINDEX-GIST-SUPPORT-TABLE"><p class="title"><strong>Таблица 38.11. Опорные функции GiST</strong></p><div class="table-contents"><table class="table" summary="Опорные функции GiST" border="1"><colgroup><col class="col1" /><col class="col2" /><col class="col3" /></colgroup><thead><tr><th>Функция</th><th>Описание</th><th>Номер опорной функции</th></tr></thead><tbody><tr><td><code class="function">consistent</code></td><td>определяет, удовлетворяет ли ключ условию запроса</td><td>1</td></tr><tr><td><code class="function">union</code></td><td>вычисляет объединение набора ключей</td><td>2</td></tr><tr><td><code class="function">compress</code></td><td>вычисляет сжатое представление ключа или индексируемого значения (необязательная)</td><td>3</td></tr><tr><td><code class="function">decompress</code></td><td>вычисляет развёрнутое представление сжатого ключа (необязательная)</td><td>4</td></tr><tr><td><code class="function">penalty</code></td><td>вычисляет стоимость добавления нового ключа в поддерево с заданным ключом</td><td>5</td></tr><tr><td><code class="function">picksplit</code></td><td>определяет, какие записи страницы должны быть перемещены в новую страницу, и вычисляет ключи объединения для результирующих страниц</td><td>6</td></tr><tr><td><code class="function">same</code></td><td>сравнивает два ключа и возвращает true, если они равны</td><td>7</td></tr><tr><td><code class="function">distance</code></td><td>определяет дистанцию от ключа до искомого значения (необязательная)</td><td>8</td></tr><tr><td><code class="function">fetch</code></td><td>вычисляет исходное представление сжатого ключа для сканирования только по индексу (необязательная)</td><td>9</td></tr><tr><td><code class="function">options</code></td><td>определяет параметры, относящиеся к данному классу операторов (необязательная)</td><td>10</td></tr><tr><td><code class="function">sortsupport</code></td><td>предоставляет компаратор для сортировки, который будет использоваться для быстрого построения индекса (необязательная)</td><td>11</td></tr></tbody></table></div></div><br class="table-break" /><p>Для индексов SP-GiST предусмотрены шесть опорных функций, одна из которых необязательная; они описаны в <a class="xref" href="xindex.html#XINDEX-SPGIST-SUPPORT-TABLE" title="Таблица 38.12. Опорные функции SP-GiST">Таблице 38.12</a>. (За дополнительными сведениями обратитесь к <a class="xref" href="spgist.html" title="Глава 69. Индексы SP-GiST">Главе 69</a>.)</p><div class="table" id="XINDEX-SPGIST-SUPPORT-TABLE"><p class="title"><strong>Таблица 38.12. Опорные функции SP-GiST</strong></p><div class="table-contents"><table class="table" summary="Опорные функции SP-GiST" border="1"><colgroup><col class="col1" /><col class="col2" /><col class="col3" /></colgroup><thead><tr><th>Функция</th><th>Описание</th><th>Номер опорной функции</th></tr></thead><tbody><tr><td><code class="function">config</code></td><td>предоставляет основную информацию о классе операторов</td><td>1</td></tr><tr><td><code class="function">choose</code></td><td>определяет, как вставить новое значение во внутренний элемент</td><td>2</td></tr><tr><td><code class="function">picksplit</code></td><td>определяет, как разделить множество значений</td><td>3</td></tr><tr><td><code class="function">inner_consistent</code></td><td>определяет, в каких внутренних ветвях нужно искать заданное значение</td><td>4</td></tr><tr><td><code class="function">leaf_consistent</code></td><td>определяет, удовлетворяет ли ключ условию запроса</td><td>5</td></tr><tr><td><code class="function">options</code></td><td>определяет параметры, относящиеся к данному классу операторов (необязательная)</td><td>6</td></tr></tbody></table></div></div><br class="table-break" /><p>Для индексов GIN предусмотрены семь опорных функций, четыре из которых необязательные; они описаны в <a class="xref" href="xindex.html#XINDEX-GIN-SUPPORT-TABLE" title="Таблица 38.13. Опорные функции GIN">Таблице 38.13</a>. (За дополнительными сведениями обратитесь к <a class="xref" href="gin.html" title="Глава 70. Индексы GIN">Главе 70</a>.)</p><div class="table" id="XINDEX-GIN-SUPPORT-TABLE"><p class="title"><strong>Таблица 38.13. Опорные функции GIN</strong></p><div class="table-contents"><table class="table" summary="Опорные функции GIN" border="1"><colgroup><col class="col1" /><col class="col2" /><col class="col3" /></colgroup><thead><tr><th>Функция</th><th>Описание</th><th>Номер опорной функции</th></tr></thead><tbody><tr><td><code class="function">compare</code></td><td>сравнивает два ключа и возвращает целое меньше нуля, ноль или целое больше нуля, показывающее, что первый ключ меньше, равен или больше второго</td><td>1</td></tr><tr><td><code class="function">extractValue</code></td><td>извлекает ключи из индексируемого значения</td><td>2</td></tr><tr><td><code class="function">extractQuery</code></td><td>извлекает ключи из условия запроса</td><td>3</td></tr><tr><td><code class="function">consistent</code></td><td>определяет, соответствует ли значение условию запроса (логическая вариация) (не требуется, если присутствует опорная функция 6)</td><td>4</td></tr><tr><td><code class="function">comparePartial</code></td><td>сравнивает частичный ключ из запроса с ключом из индекса и возвращает целое число меньше нуля, ноль или больше нуля, показывающее, что GIN должен игнорировать эту запись индекса, принять её как соответствующую или прекратить сканирование индекса (необязательная)</td><td>5</td></tr><tr><td><code class="function">triConsistent</code></td><td>определяет, соответствует ли значение условию запроса (троичная вариация) (не требуется, если присутствует опорная функция 4)</td><td>6</td></tr><tr><td><code class="function">options</code></td><td>определяет параметры, относящиеся к данному классу операторов (необязательная)</td><td>7</td></tr></tbody></table></div></div><br class="table-break" /><p>Для индексов BRIN предусмотрены пять базовых опорных функций, перечисленных в <a class="xref" href="xindex.html#XINDEX-BRIN-SUPPORT-TABLE" title="Таблица 38.14. Опорные функции BRIN">Таблице 38.14</a>. Для некоторых видов базовых функций может потребоваться предоставить дополнительные опорные функции. (За дополнительными сведениями обратитесь к <a class="xref" href="brin-extensibility.html" title="71.3. Расширяемость">Разделу 71.3</a>.)</p><div class="table" id="XINDEX-BRIN-SUPPORT-TABLE"><p class="title"><strong>Таблица 38.14. Опорные функции BRIN</strong></p><div class="table-contents"><table class="table" summary="Опорные функции BRIN" border="1"><colgroup><col class="col1" /><col class="col2" /><col class="col3" /></colgroup><thead><tr><th>Функция</th><th>Описание</th><th>Номер опорной функции</th></tr></thead><tbody><tr><td><code class="function">opcInfo</code></td><td>возвращает внутреннюю информацию, описывающую сводные данные по индексированным столбцам</td><td>1</td></tr><tr><td><code class="function">add_value</code></td><td>добавляет новое значение в существующий сводный кортеж индекса</td><td>2</td></tr><tr><td><code class="function">consistent</code></td><td>определяет, удовлетворяет ли значение условию запроса</td><td>3</td></tr><tr><td><code class="function">union</code></td><td>вычисляет объединение двух обобщающих кортежей</td><td>4</td></tr><tr><td><code class="function">options</code></td><td>определяет параметры, относящиеся к данному классу операторов (необязательная)</td><td>5</td></tr></tbody></table></div></div><br class="table-break" /><p>В отличие от операторов поиска, опорные функции возвращают тот тип данных, который ожидает конкретный метод индекса; например, функция сравнения для B-деревьев возвращает знаковое целое. Количество и типы аргументов для каждой опорной функции так же зависят от метода индекса. Для методов B-дерева и хеша функции сравнения и хеширования принимают те же типы данных, что и операторы, включённые в класс операторов, но для большинства опорных функций GiST, SP-GiST, GIN и BRIN это не так.</p></div><div class="sect2" id="XINDEX-EXAMPLE"><div class="titlepage"><div><div><h3 class="title">38.16.4. Пример <a href="#XINDEX-EXAMPLE" class="id_link">#</a></h3></div></div></div><p>Теперь, когда мы познакомились с основными идеями, мы можем перейти к обещанному примеру создания нового класса операторов. (Рабочую копию этого примера можно найти в <code class="filename">src/tutorial/complex.c</code> и <code class="filename">src/tutorial/complex.sql</code> в пакете исходного кода.) Класс операторов включает операторы, сортирующие комплексные числа по порядку абсолютных значений, поэтому мы выбрали для него имя <code class="literal">complex_abs_ops</code>. Во-первых, нам понадобится набор операторов. Процедура определения операторов была рассмотрена в <a class="xref" href="xoper.html" title="38.14. Пользовательские операторы">Разделе 38.14</a>. Для класса операторов B-деревьев нам понадобятся операторы: </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: disc; "><li class="listitem">абсолютное-значение меньше (стратегия 1)</li><li class="listitem">абсолютное-значение меньше-или-равно (стратегия 2)</li><li class="listitem">абсолютное-значение равно (стратегия 3)</li><li class="listitem">абсолютное-значение больше-или-равно (стратегия 4)</li><li class="listitem">абсолютное-значение больше (стратегия 5)</li></ul></div><p>Чтобы не провоцировать ошибки при определении связанного набора операторов сравнения, лучше всего сначала написать вспомогательную функцию сравнения для B-дерева, а затем написать другие функции как однострочные оболочки этой вспомогательной функции. Это уменьшит вероятность получения несогласованных результатов в исключительных случаях. Следуя этому подходу, мы сначала напишем: </p><pre class="programlisting">
#define Mag(c)  ((c)-&gt;x*(c)-&gt;x + (c)-&gt;y*(c)-&gt;y)

static int
complex_abs_cmp_internal(Complex *a, Complex *b)
{
    double      amag = Mag(a),
                bmag = Mag(b);

    if (amag &lt; bmag)
        return -1;
    if (amag &gt; bmag)
        return 1;
    return 0;
}

</pre><p> Теперь функция «меньше» будет выглядеть так: </p><pre class="programlisting">
PG_FUNCTION_INFO_V1(complex_abs_lt);

Datum
complex_abs_lt(PG_FUNCTION_ARGS)
{
    Complex    *a = (Complex *) PG_GETARG_POINTER(0);
    Complex    *b = (Complex *) PG_GETARG_POINTER(1);

    PG_RETURN_BOOL(complex_abs_cmp_internal(a, b) &lt; 0);
}

</pre><p> Остальные четыре функции отличаются от неё только тем, как сравнивают результат внутренней функции с нулём.</p><p>Затем мы объявим в SQL функции и операторы на основе этих функций: </p><pre class="programlisting">CREATE FUNCTION complex_abs_lt(complex, complex) RETURNS bool
    AS '<em class="replaceable"><code>имя_файла</code></em>', 'complex_abs_lt'
    LANGUAGE C IMMUTABLE STRICT;

CREATE OPERATOR &lt; (
   leftarg = complex, rightarg = complex, procedure = complex_abs_lt,
   commutator = &gt; , negator = &gt;= ,
   restrict = scalarltsel, join = scalarltjoinsel
);</pre><p> Важно правильно определить обратные и коммутирующие операторы, а также подходящие функции избирательности ограничения и соединения; иначе оптимизатор не сможет использовать наш индекс эффективно.</p><p>Здесь также стоит обратить внимание на следующее: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Учтите, что может быть только один оператор с именем, например, <code class="literal">=</code>, который будет принимать тип <code class="type">complex</code> с двух сторон. В этом случае у нас не будет другого оператора <code class="literal">=</code> для <code class="type">complex</code>, но если мы создаём практически полезный тип данных, вероятно, мы захотим, чтобы оператор <code class="literal">=</code> проверял обычное равенство двух комплексных чисел (а не равенство их абсолютных значений). В этом случае для <code class="function">complex_abs_eq</code> нужно выбрать какое-то другое имя оператора.</p></li><li class="listitem"><p>Хотя в <span class="productname">PostgreSQL</span> разные функции могут иметь одинаковые имена SQL, если у них различные типы аргументов, в C только одна глобальная функция может иметь заданное имя. Поэтому не следует давать функции на C имя вроде <code class="filename">abs_eq</code>. Во избежание конфликтов с функциями для других типов данных, в имя функции на C обычно включается имя конкретного типа данных.</p></li><li class="listitem"><p>Мы могли быть дать нашей функции имя <code class="filename">abs_eq</code> в SQL, рассчитывая на то, что <span class="productname">PostgreSQL</span> отличит её от любых других одноимённых функций SQL по типам аргументов. Но в данном случае для упрощения примера мы дали ей одинаковые имена на уровне C и уровне SQL.</p></li></ul></div><p>На следующем этапе регистрируется опорная процедура, необходимая для B-деревьев. В нашем примере код C, реализующий её, находится в том же файле, что и функции операторов. Мы объявляем эту процедуру так: </p><pre class="programlisting">CREATE FUNCTION complex_abs_cmp(complex, complex)
    RETURNS integer
    AS '<em class="replaceable"><code>имя_файла</code></em>'
    LANGUAGE C IMMUTABLE STRICT;</pre><p>Теперь, когда мы объявили требуемые операторы и опорную функцию, мы наконец можем создать класс операторов: </p><pre class="programlisting">
CREATE OPERATOR CLASS complex_abs_ops
    DEFAULT FOR TYPE complex USING btree AS
        OPERATOR        1       &lt; ,
        OPERATOR        2       &lt;= ,
        OPERATOR        3       = ,
        OPERATOR        4       &gt;= ,
        OPERATOR        5       &gt; ,
        FUNCTION        1       complex_abs_cmp(complex, complex);

</pre><p>Вот и всё! Теперь должно быть возможно создавать и использовать индексы-B-деревья по столбцам <code class="type">complex</code>.</p><p>Операторы можно было записать более многословно, например, так: </p><pre class="programlisting">        OPERATOR        1       &lt; (complex, complex) ,</pre><p> но в этом необходимости, так как эти операторы принимают тот же тип данных, для которого определяется класс операторов.</p><p>В приведённом примере предполагается, что этот класс операторов будет классом операторов B-дерева по умолчанию для типа <code class="type">complex</code>. Если вам это не нужно, просто опустите слово <code class="literal">DEFAULT</code>.</p></div><div class="sect2" id="XINDEX-OPFAMILY"><div class="titlepage"><div><div><h3 class="title">38.16.5. Семейства и классы операторов <a href="#XINDEX-OPFAMILY" class="id_link">#</a></h3></div></div></div><p>До этого мы неявно полагали, что класс операторов работает только с одним типом данных. Хотя в конкретном индексируемом столбце, определённо, может быть только один тип данных, часто бывает полезно индексировать операции, сравнивающие значение столбца со значением другого типа. Также, если в сочетании с классом операторов возможно применение оператора, работающего с двумя типами, для другого типа данных обычно тоже создаётся собственный класс. В таких случаях полезно установить явную связь между связанными классами, так как это поможет планировщику оптимизировать SQL-запросы (особенно для классов операторов B-дерева, потому что планировщик хорошо знает, как работать с ними).</p><p>Для удовлетворения этих потребностей в <span class="productname">PostgreSQL</span> введена концепция <em class="firstterm">семейства операторов</em><a id="id-1.8.3.19.9.3.3" class="indexterm"></a>. Семейство операторов содержит один или несколько классов операторов и может также содержать индексируемые операторы и соответствующие опорные функции, принадлежащие к семейству в целом, но не к какому-то одному классу в нём. Мы называем такую связь операторов и функций с семейством <span class="quote">«<span class="quote">слабой</span>»</span>, в отличие от обычной связи с определённым классом. Как правило, классы содержат операторы с операндами одного типа, тогда как межтиповые операторы слабо связываются с семейством.</p><p>Все операторы и функции в семействе операторов должны иметь совместимую семантику; требования к совместимости устанавливаются методом индекса. Вы можете спросить, зачем в таком случае вообще выделять конкретные подмножества семейства в виде классов операторов; и на самом деле во многих случаях деление на классы не имеет значения, важно только связывание с семейством. Смысл классов операторов в том, что они определяют, какая часть семейства необходима для поддержки некоторого индекса. Если существует индекс, использующий класс операторов, этот класс нельзя будет удалить, не удалив индекс — но другие части семейства, а именно, другие классы операторов и слабосвязанные операторы, удалить можно. Таким образом, класс операторов должен определяться так, чтобы он содержал минимальный набор операторов и функций, обоснованно требующихся для работы с индексом по определённому типу данных, а несущественные операторы могут добавляться в качестве слабосвязанных членов в семейство операторов.</p><p>В качестве примера, в <span class="productname">PostgreSQL</span> есть встроенное семейство операторов B-дерева <code class="literal">integer_ops</code>, включающее классы операторов <code class="literal">int8_ops</code>, <code class="literal">int4_ops</code> и <code class="literal">int2_ops</code> для индексов по столбцам <code class="type">bigint</code> (<code class="type">int8</code>), <code class="type">integer</code> (<code class="type">int4</code>) и <code class="type">smallint</code> (<code class="type">int2</code>), соответственно. В этом семействе также содержатся операторы межтипового сравнения, позволяющие сравнивать значения любых двух этих типов, так что индексом по любому из этих типов можно пользоваться, выполняя сравнение с другим типом. Это семейство можно представить такими определениями: </p><pre class="programlisting">
CREATE OPERATOR FAMILY integer_ops USING btree;

CREATE OPERATOR CLASS int8_ops
DEFAULT FOR TYPE int8 USING btree FAMILY integer_ops AS
  -- standard int8 comparisons
  OPERATOR 1 &lt; ,
  OPERATOR 2 &lt;= ,
  OPERATOR 3 = ,
  OPERATOR 4 &gt;= ,
  OPERATOR 5 &gt; ,
  FUNCTION 1 btint8cmp(int8, int8) ,
  FUNCTION 2 btint8sortsupport(internal) ,
  FUNCTION 3 in_range(int8, int8, int8, boolean, boolean) ,
  FUNCTION 4 btequalimage(oid) ;

CREATE OPERATOR CLASS int4_ops
DEFAULT FOR TYPE int4 USING btree FAMILY integer_ops AS
  -- standard int4 comparisons
  OPERATOR 1 &lt; ,
  OPERATOR 2 &lt;= ,
  OPERATOR 3 = ,
  OPERATOR 4 &gt;= ,
  OPERATOR 5 &gt; ,
  FUNCTION 1 btint4cmp(int4, int4) ,
  FUNCTION 2 btint4sortsupport(internal) ,
  FUNCTION 3 in_range(int4, int4, int4, boolean, boolean) ,
  FUNCTION 4 btequalimage(oid) ;

CREATE OPERATOR CLASS int2_ops
DEFAULT FOR TYPE int2 USING btree FAMILY integer_ops AS
  -- standard int2 comparisons
  OPERATOR 1 &lt; ,
  OPERATOR 2 &lt;= ,
  OPERATOR 3 = ,
  OPERATOR 4 &gt;= ,
  OPERATOR 5 &gt; ,
  FUNCTION 1 btint2cmp(int2, int2) ,
  FUNCTION 2 btint2sortsupport(internal) ,
  FUNCTION 3 in_range(int2, int2, int2, boolean, boolean) ,
  FUNCTION 4 btequalimage(oid) ;

ALTER OPERATOR FAMILY integer_ops USING btree ADD
  -- cross-type comparisons int8 vs int2
  OPERATOR 1 &lt; (int8, int2) ,
  OPERATOR 2 &lt;= (int8, int2) ,
  OPERATOR 3 = (int8, int2) ,
  OPERATOR 4 &gt;= (int8, int2) ,
  OPERATOR 5 &gt; (int8, int2) ,
  FUNCTION 1 btint82cmp(int8, int2) ,

  -- cross-type comparisons int8 vs int4
  OPERATOR 1 &lt; (int8, int4) ,
  OPERATOR 2 &lt;= (int8, int4) ,
  OPERATOR 3 = (int8, int4) ,
  OPERATOR 4 &gt;= (int8, int4) ,
  OPERATOR 5 &gt; (int8, int4) ,
  FUNCTION 1 btint84cmp(int8, int4) ,

  -- cross-type comparisons int4 vs int2
  OPERATOR 1 &lt; (int4, int2) ,
  OPERATOR 2 &lt;= (int4, int2) ,
  OPERATOR 3 = (int4, int2) ,
  OPERATOR 4 &gt;= (int4, int2) ,
  OPERATOR 5 &gt; (int4, int2) ,
  FUNCTION 1 btint42cmp(int4, int2) ,

  -- cross-type comparisons int4 vs int8
  OPERATOR 1 &lt; (int4, int8) ,
  OPERATOR 2 &lt;= (int4, int8) ,
  OPERATOR 3 = (int4, int8) ,
  OPERATOR 4 &gt;= (int4, int8) ,
  OPERATOR 5 &gt; (int4, int8) ,
  FUNCTION 1 btint48cmp(int4, int8) ,

  -- cross-type comparisons int2 vs int8
  OPERATOR 1 &lt; (int2, int8) ,
  OPERATOR 2 &lt;= (int2, int8) ,
  OPERATOR 3 = (int2, int8) ,
  OPERATOR 4 &gt;= (int2, int8) ,
  OPERATOR 5 &gt; (int2, int8) ,
  FUNCTION 1 btint28cmp(int2, int8) ,

  -- cross-type comparisons int2 vs int4
  OPERATOR 1 &lt; (int2, int4) ,
  OPERATOR 2 &lt;= (int2, int4) ,
  OPERATOR 3 = (int2, int4) ,
  OPERATOR 4 &gt;= (int2, int4) ,
  OPERATOR 5 &gt; (int2, int4) ,
  FUNCTION 1 btint24cmp(int2, int4) ,

  -- cross-type in_range functions
  FUNCTION 3 in_range(int4, int4, int8, boolean, boolean) ,
  FUNCTION 3 in_range(int4, int4, int2, boolean, boolean) ,
  FUNCTION 3 in_range(int2, int2, int8, boolean, boolean) ,
  FUNCTION 3 in_range(int2, int2, int4, boolean, boolean) ;

</pre><p> Заметьте, что в определении семейства <span class="quote">«<span class="quote">перегружаются</span>»</span> номера стратегий операторов и опорных функций: каждый номер фигурирует в семействе неоднократно. Это допускается, если для каждого экземпляра определённого номера задаются свои типы данных. Экземпляры, у которых оба входных типа совпадают с входным типом класса операторов, являются первичными операторами и опорными функциями для этого класса, и в большинстве случаев они должны объявляться в составе класса операторов, а не быть слабосвязанными членами семейства.</p><p>В семействе операторов B-дерева все операторы должны быть совместимыми в контексте сортировки; это подробно описано в <a class="xref" href="btree-behavior.html" title="67.2. Поведение классов операторов B-дерева">Разделе 67.2</a>. Для каждого оператора в семействе должна существовать опорная функция, принимающая на вход те же два типа, что и оператор. Семейство рекомендуется делать полным, то есть включать в него все операторы для каждого сочетания типов данных. В классы операторов следует включать только однотиповые операторы и опорные функции для определённого типа данных.</p><p>Чтобы создать семейство операторов хеширования для нескольких типов данных, необходимо создать совместимые функции поддержки хеша для каждого типа данных, который будет поддерживать семейство. Здесь под совместимостью понимается гарантия получения одного хеш-кода для любых двух значений, которые операторы сравнения в этом семействе считают равными, даже если они имеют разные типы. Обычно это сложно осуществить, когда типы имеют разное физическое представление, но в некоторых случаях всё же возможно. Более того, преобразование значения одного типа данных, представленного в семействе операторов, к другому типу, также представленному в этом семействе, путём неявного или двоичного сведения не должно менять значение вычисляемого хеша. Заметьте, что единственная опорная функция задаётся для типа данных, а не для оператора равенства. Семейство рекомендуется делать полным, то есть включить в него оператор равенства для всех сочетаний типов данных. В классы операторов следует включать только однотиповый оператор равенства и опорную функция для определённого типа данных.</p><p>В индексах GiST, SP-GiST и GIN межтиповые операции явно не выражены. Множество поддерживаемых операторов определяется только теми операциями, которые могут выполнять основные опорные функции заданного класса операторов.</p><p>В BRIN требования зависят от инфраструктуры, предоставляющей классы операторов. Для классов операторов, построенных на инфраструктуре <code class="literal">minmax</code>, требуется то же поведение, что и для семейств операторов B-дерева: все операторы в семействе должны поддерживать совместимый порядок, а приведения не должны влиять на установленный порядок сортировки.</p><div class="note"><h3 class="title">Примечание</h3><p>До версии 8.3 в <span class="productname">PostgreSQL</span> не было понятия семейства операторов, поэтому любые межтиповые операторы, предназначенные для применения с индексом, должны были привязываться непосредственно к классу оператора индекса. Хотя этот подход по-прежнему работает, он считается устаревшим, потому что он создаёт слишком много зависимостей для индекса, а также потому, что планировщик может выполнять межтиповые сравнения более эффективно, когда для обоих типов данных определены операторы в одном семействе.</p></div></div><div class="sect2" id="XINDEX-OPCLASS-DEPENDENCIES"><div class="titlepage"><div><div><h3 class="title">38.16.6. Системные зависимости от классов операторов <a href="#XINDEX-OPCLASS-DEPENDENCIES" class="id_link">#</a></h3></div></div></div><a id="id-1.8.3.19.10.2" class="indexterm"></a><p><span class="productname">PostgreSQL</span> использует классы операторов для наделения операторов такими свойствами, которые могут быть полезны не только для индексов. Поэтому классы операторов могут быть полезны, даже если вы не намерены индексировать столбцы со значениями определённого вами типа.</p><p>В частности, это касается SQL-конструкций <code class="literal">ORDER BY</code> и <code class="literal">DISTINCT</code>, для которых требуется сравнивать и упорядочивать значения. Чтобы эти конструкции работали с определённым пользователем типом данных, <span class="productname">PostgreSQL</span> задействует класс операторов B-дерева по умолчанию для этого типа. Член <span class="quote">«<span class="quote">равно</span>»</span> этого класса определяет, как система будет понимать равенство значений для <code class="literal">GROUP BY</code> и <code class="literal">DISTINCT</code>, а порядок сортировки, задаваемый классом операторов, определяет порядок <code class="literal">ORDER BY</code> по умолчанию.</p><p>Если класс операторов B-дерева по умолчанию для типа данных не определён, система будет искать класс операторов хеширования по умолчанию. Но так как подобный класс поддерживает только равенство, с ним будет возможна только группировка, но не сортировка.</p><p>Если для типа не определён класс операторов по умолчанию, попытавшись использовать эти конструкции SQL с данным типом, вы получите ошибку вида <span class="quote">«<span class="quote">не удалось найти оператор сортировки</span>»</span>.</p><div class="note"><h3 class="title">Примечание</h3><p>До версии <span class="productname">PostgreSQL</span> 7.4, в операциях сортировки и группировки неявно использовались операторы с именами <code class="literal">=</code>, <code class="literal">&lt;</code> и <code class="literal">&gt;</code>. С новым подходом, опирающимся на классы операторов по умолчанию, система не делает никаких предположений о поведении операторов по их именам.</p></div><p>Сортировка с нестандартным классом операторов B-дерева возможна, если указать в предложении <code class="literal">USING</code> оператор «меньше или равно» в данном классе: </p><pre class="programlisting">SELECT * FROM mytable ORDER BY somecol USING ~&lt;~;</pre><p> Также возможно выполнить сортировку в порядке по убыванию, если указать в <code class="literal">USING</code> оператор «больше или равно».</p><p>Сравнение массивов пользовательских типов также производится в зависимости от семантики, определённой классом операторов B-дерева. Если класс операторов B-дерева по умолчанию для данного типа не определён, но имеется класс операторов хеширования, то будет поддерживаться сравнение массивов, но не упорядочивание.</p><p>Ещё одна возможность языка SQL, которая требует дополнительных знаний о типе данных — это указание <code class="literal">RANGE</code> <em class="replaceable"><code>смещение</code></em> <code class="literal">PRECEDING</code>/<code class="literal">FOLLOWING</code> для оконных функций (см. <a class="xref" href="sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS" title="4.2.8. Вызовы оконных функций">Подраздел 4.2.8</a>). Для запроса вида </p><pre class="programlisting">SELECT sum(x) OVER (ORDER BY x RANGE BETWEEN 5 PRECEDING AND 10 FOLLOWING)
  FROM mytable;</pre><p> недостаточно знать, как упорядочить <code class="literal">x</code>; база данных должна также понимать, как <span class="quote">«<span class="quote">вычесть 5</span>»</span> или <span class="quote">«<span class="quote">прибавить 10</span>»</span> к значению <code class="literal">x</code> в текущей строке для определения рамок текущего окна. Сравнивать результирующие границы со значениями <code class="literal">x</code> в других строках можно используя операторы сравнения, предоставленные классом операторов B-дерева, которые задают упорядочивание <code class="literal">ORDER BY</code>, но операторы сложения и вычитания не входят в этот класс операторов. Так какие же использовать в этом случае? Жёстко зафиксировать операторы в коде было бы нежелательно, так как при различных порядках сортировки (с различными классами операторов B-дерева) поведение может меняться. Поэтому класс операторов B-дерева позволяет задать опорную функцию <em class="firstterm">in_range</em>, осуществляющую сложение и вычитание в соответствии с порядком сортировки. Опорных функций in_range может быть даже несколько, если в качестве смещения в предложениях <code class="literal">RANGE</code> имеет смысл передавать данные разных типов. Если в классе операторов B-дерева, связанном с указанным для окна предложением <code class="literal">ORDER BY</code>, нет подходящей опорной функции in_range, то указание <code class="literal">RANGE</code> <em class="replaceable"><code>смещение</code></em> <code class="literal">PRECEDING</code>/<code class="literal">FOLLOWING</code> не поддерживается.</p><p>Также важно отметить, что оператор равенства, указанный в семействе операторов хеширования, является кандидатом для применения при слиянии и агрегации по хешу, а также при связанной оптимизации. Семейство операторов хеширования играет в данном случае определяющую роль, так как именно в нём задаётся функция хеширования.</p></div><div class="sect2" id="XINDEX-ORDERING-OPS"><div class="titlepage"><div><div><h3 class="title">38.16.7. Операторы упорядочивания <a href="#XINDEX-ORDERING-OPS" class="id_link">#</a></h3></div></div></div><p>Некоторые методы доступа индексов (в настоящее время только GiST и SP-GiST) поддерживают концепцию <em class="firstterm">операторов упорядочивания</em>. Операторы, которые мы обсуждали до этого, были <em class="firstterm">операторами поиска</em>. Оператором поиска называется такой оператор, для которого можно выполнить поиск по индексу и найти все строки, удовлетворяющие условию <code class="literal">WHERE</code> <em class="replaceable"><code>индексированный_столбец</code></em> <em class="replaceable"><code>оператор</code></em> <em class="replaceable"><code>константа</code></em>. Заметьте, что при этом ничего не говорится о порядке, в котором будут возвращены подходящие строки. Оператор упорядочивания, напротив, не ограничивает набор возвращаемых строк, но определяет их порядок. С таким оператором, просканировав индекс, можно получить строки в порядке, заданным указанием <code class="literal">ORDER BY</code> <em class="replaceable"><code>индексированный_столбец</code></em> <em class="replaceable"><code>оператор</code></em> <em class="replaceable"><code>константа</code></em>. Такое определение объясняется тем, что оно поддерживает поиск ближайшего соседа, если этот оператор вычисляет расстояние. Например, запрос </p><pre class="programlisting">
SELECT * FROM places ORDER BY location &lt;-&gt; point '(101,456)' LIMIT 10;

</pre><p> находит десять ближайших к заданной точке мест. Индекс GiST по столбцу location может сделать это эффективно, так как <code class="literal">&lt;-&gt;</code> — это оператор упорядочивания.</p><p>Тогда как операторы поиска должны возвращать логические результаты, операторы упорядочивания обычно возвращают другой тип, например, float или numeric для расстояний. Этот тип, как правило, отличается от типа индексируемых данных. Чтобы избежать жёстко запрограммированных предположений о поведении различных типов данных, при объявлении оператора упорядочивания должно указываться семейство операторов B-дерева, определяющее порядок сортировки результирующего типа данных. Как было отмечено в предыдущем разделе, семейства операторов B-дерева определяют понятие упорядочивания для <span class="productname">PostgreSQL</span>, так что такое объявление оказывается естественным. Так как оператор <code class="literal">&lt;-&gt;</code> для точек возвращает <code class="type">float8</code>, его можно включить в команду создания класса операторов так: </p><pre class="programlisting">
OPERATOR 15    &lt;-&gt; (point, point) FOR ORDER BY float_ops

</pre><p> где <code class="literal">float_ops</code> — встроенное семейство операторов, включающее операции с <code class="type">float8</code>. Это объявление означает, что индекс может возвращать строки в порядке увеличения значений оператора <code class="literal">&lt;-&gt;</code>.</p></div><div class="sect2" id="XINDEX-OPCLASS-FEATURES"><div class="titlepage"><div><div><h3 class="title">38.16.8. Особенности классов операторов <a href="#XINDEX-OPCLASS-FEATURES" class="id_link">#</a></h3></div></div></div><p>Есть ещё две особенности классов операторов, которые мы до этого не обсуждали, в первую очередь потому, что они не востребованы для наиболее часто применяемых методов индексов.</p><p>Обычно объявление оператора в качестве члена класса операторов (или семейства) означает, что метод индекса может получить точно набор строк, который удовлетворяет условию <code class="literal">WHERE</code> с этим оператором. Например, запрос: </p><pre class="programlisting">SELECT * FROM table WHERE integer_column &lt; 4;</pre><p> может быть удовлетворён в точности индексом-B-деревом по целочисленному столбцу. Но бывают случаи, когда индекс полезен как приблизительный указатель на соответствующие строки. Например, если индекс GiST хранит только прямоугольники, описанные вокруг геометрических объектов, он не может точно удовлетворить условие <code class="literal">WHERE</code>, которое проверяет пересечение не прямоугольных объектов, а например, многоугольников. Однако этот индекс можно применить, чтобы найти объекты, для которых описанные вокруг прямоугольники пересекаются с прямоугольником, описанным вокруг целевого объекта, а затем провести точную проверку пересечения только для найденных по индексу объектов. Если это имеет место, такой индекс называется <span class="quote">«<span class="quote">неточным</span>»</span> для оператора. Для реализации поиска по неточному индексу метод индекса возвращает флаг <em class="firstterm">recheck</em> (перепроверить), когда строка может действительно удовлетворять, а может не удовлетворять условию запроса. Затем исполнитель запроса перепроверяет полученную строку по исходному условию запроса и определяет, должна ли она выдаваться как действительно соответствующая ему. Этот подход работает, если индекс гарантированно выдаёт все требуемые строки плюс, возможно, дополнительные строки, которые можно исключить, вызвав первоначальный оператор. Методы индексов, поддерживающие неточный поиск (в настоящее время, GiST, SP-GiST и GIN), позволяют устанавливать флаг recheck опорным функциям отдельных классов операторов, так что по сути это особенность класса операторов.</p><p>Вернёмся к ситуации, когда мы храним в индексе только прямоугольник, описанный вокруг сложного объекта, такого как многоугольник. В этом случае нет большого смысла хранить в элементе индекса весь многоугольник — мы можем с тем же успехом хранить более простой объект типа <code class="type">box</code>. Это отклонение выражается указанием <code class="literal">STORAGE</code> в команде <code class="command">CREATE OPERATOR CLASS</code>, которое записывается примерно так: </p><pre class="programlisting">CREATE OPERATOR CLASS polygon_ops
    DEFAULT FOR TYPE polygon USING gist AS
        ...
        STORAGE box;</pre><p> В настоящее время только методы индексов GiST, SP-GiST, GIN и BRIN позволяют задать в <code class="literal">STORAGE</code> тип, отличный от типа данных столбца. В GiST преобразованием данных, связанным с использованием <code class="literal">STORAGE</code>, должны заниматься опорные процедуры <code class="function">compress</code> и <code class="function">decompress</code>. Аналогичным образом в SP-GiST опорная процедура <code class="function">compress</code> занимается преобразованием данных к типу хранения, если они имеют другой тип; если класс операторов SP-GiST поддерживает и получение данных, обратное преобразование выполняет функция <code class="function">consistent</code>. В GIN тип <code class="literal">STORAGE</code> определяет тип значений <span class="quote">«<span class="quote">ключа</span>»</span>, который обычно отличается от типа индексируемого столбца — например, в классе операторов для столбцов с целочисленным массивом ключами могут быть просто целые числа. За извлечение ключей из индексированных значений в GIN отвечают опорные функции <code class="function">extractValue</code> и <code class="function">extractQuery</code>. BRIN похож на GIN: в нём тип <code class="literal">STORAGE</code> определяет тип хранимых обобщённых значений, а опорные процедуры классов операторов отвечают за правильное прочтение этих значений.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="xoper-optimization.html" title="38.15. Информация для оптимизации операторов">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="extend.html" title="Глава 38. Расширение SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="extend-extensions.html" title="38.17. Упаковывание связанных объектов в расширение">След.</a></td></tr><tr><td width="40%" align="left" valign="top">38.15. Информация для оптимизации операторов </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 38.17. Упаковывание связанных объектов в расширение</td></tr></table></div></body></html>