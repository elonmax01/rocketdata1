<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CREATE DOMAIN</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sql-createdatabase.html" title="CREATE DATABASE" /><link rel="next" href="sql-createeventtrigger.html" title="CREATE EVENT TRIGGER" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">CREATE DOMAIN</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-createdatabase.html" title="CREATE DATABASE">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><th width="60%" align="center">Команды SQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-createeventtrigger.html" title="CREATE EVENT TRIGGER">След.</a></td></tr></table><hr /></div><div class="refentry" id="SQL-CREATEDOMAIN"><div class="titlepage"></div><a id="id-1.9.3.62.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">CREATE DOMAIN</span></h2><p>CREATE DOMAIN — создать домен</p></div><div class="refsynopsisdiv"><h2>Синтаксис</h2><pre class="synopsis">CREATE DOMAIN <em class="replaceable"><code>имя</code></em> [ AS ] <em class="replaceable"><code>тип_данных</code></em>
    [ COLLATE <em class="replaceable"><code>правило_сортировки</code></em> ]
    [ DEFAULT <em class="replaceable"><code>выражение</code></em> ]
    [ <em class="replaceable"><code>ограничение</code></em> [ ... ] ]

<span class="phrase">Здесь <em class="replaceable"><code>ограничение</code></em>:</span>

[ CONSTRAINT <em class="replaceable"><code>имя_ограничения</code></em> ]
{ NOT NULL | NULL | CHECK (<em class="replaceable"><code>выражение</code></em>) }</pre></div><div class="refsect1" id="id-1.9.3.62.5"><h2>Описание</h2><p><code class="command">CREATE DOMAIN</code> создаёт новый домен. Домен по сути представляет собой тип данных с дополнительными условиями (ограничивающими допустимый набор значений). Владельцем домена становится пользователь его создавший.</p><p>Если задаётся имя схемы (например, <code class="literal">CREATE DOMAIN myschema.mydomain ...</code>), домен создаётся в указанной схеме, в противном случае — в текущей. Имя домена должно быть уникальным среди имён типов и доменов, существующих в этой схеме.</p><p>Домены полезны для абстрагирования и вынесения общих характеристик разных полей в единое место для упрощения сопровождения. Например, в нескольких таблицах может присутствовать столбец, содержащий электронный адрес, и для всех требуются одинаковые ограничения CHECK, проверяющие синтаксис адреса. В этом случае лучше определить домен, а не задавать для каждой таблицы отдельные ограничения.</p><p>Чтобы создать домен, необходимо иметь право <code class="literal">USAGE</code> для нижележащего типа.</p></div><div class="refsect1" id="id-1.9.3.62.6"><h2>Параметры</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>имя</code></em></span></dt><dd><p>Имя создаваемого домена (возможно, дополненное схемой).</p></dd><dt><span class="term"><em class="replaceable"><code>тип_данных</code></em></span></dt><dd><p>Нижележащий тип данных домена (может включать определение массива с этим типом).</p></dd><dt><span class="term"><em class="replaceable"><code>правило_сортировки</code></em></span></dt><dd><p>Необязательное указание правила сортировки для домена. Если это указание отсутствует, в домене используется правило сортировки нижележащего типа данных. Указать <code class="literal">COLLATE</code> можно, только если нижележащий тип данных является сортируемым.</p></dd><dt><span class="term"><code class="literal">DEFAULT <em class="replaceable"><code>выражение</code></em></code></span></dt><dd><p>Предложение <code class="literal">DEFAULT</code> определяет значение по умолчанию для столбцов, типом данных которых является этот домен. Значением может быть любое выражение без переменных (подзапросы также не допускаются). Тип данных этого выражения должен соответствовать типу данных домена. Если значение по умолчанию не указано, им будет значение NULL.</p><p>Значение по умолчанию будет использоваться в любой операции добавления строк, в которой не задано значение для этого столбца. Если значение по умолчанию установлено для конкретного столбца, оно будет переопределять значение по умолчанию, связанное с доменом. В свою очередь, значение по умолчанию для домена переопределяет любое значение по умолчанию, связанное с нижележащим типом данных.</p></dd><dt><span class="term"><code class="literal">CONSTRAINT <em class="replaceable"><code>имя_ограничения</code></em></code></span></dt><dd><p>Имя ограничения. Если не указано явно, имя будет сгенерировано системой.</p></dd><dt><span class="term"><code class="literal">NOT NULL</code></span></dt><dd><p>Значения этого домена будут отличны от NULL (но см. замечания ниже).</p></dd><dt><span class="term"><code class="literal">NULL</code></span></dt><dd><p>Этот домен может содержать значение NULL. Это свойство домена по умолчанию.</p><p>Это предложение предназначено только для совместимости с нестандартными базами данных SQL. Использовать его в новых приложениях не рекомендуется.</p></dd><dt><span class="term"><code class="literal">CHECK (<em class="replaceable"><code>выражение</code></em>)</code></span></dt><dd><p>Предложения <code class="literal">CHECK</code> задают ограничения целостности или проверки, которым должны удовлетворять значения домена. Каждое ограничение должно представлять собой выражение, выдающее результат типа Boolean. Проверяемое значение в этом выражении обозначается ключевым словом <code class="literal">VALUE</code>. Если выражение выдаёт FALSE, сообщается об ошибке и приведение значения к типу домена запрещается.</p><p>В настоящее время выражения <code class="literal">CHECK</code> не могут содержать переменные, кроме <code class="literal">VALUE</code>, и подзапросы.</p><p>Когда для домена задано несколько ограничений <code class="literal">CHECK</code>, они будут проверяться в алфавитном порядке имён. (До версии 9.5 в <span class="productname">PostgreSQL</span> не было установлено никакого определённого порядка обработки ограничений <code class="literal">CHECK</code>.)</p></dd></dl></div></div><div class="refsect1" id="id-1.9.3.62.7"><h2>Замечания</h2><p>Ограничения домена, в частности <code class="literal">NOT NULL</code>, проверяются при преобразовании значения к типу домена. Однако из столбца, который номинально имеет тип домена, всё же можно прочитать NULL, несмотря на такое ограничение. Например, это может происходить в запросе внешнего соединения, если столбец домена окажется в обнуляемой стороне внешнего соединения. Более тонкий пример: </p><pre class="programlisting">INSERT INTO tab (domcol) VALUES ((SELECT domcol FROM tab WHERE false));</pre><p> Пустой скалярный вложенный SELECT выдаст значение NULL, типом которого будет считаться домен, так что к этому значению не будут применены дополнительные проверки ограничений и строка будет успешно добавлена.</p><p>Избежать таких проблем очень сложно, так как в SQL вообще предполагается, что значение NULL является подходящим для любого типа данных. Таким образом, лучше всего разрабатывать ограничения так, чтобы значения NULL допускались, а затем при необходимости применять ограничения <code class="literal">NOT NULL</code> к столбцам доменного типа, а не непосредственно к самому этому типу.</p><p>В <span class="productname">PostgreSQL</span> предполагается, что условия ограничений <code class="literal">CHECK</code> являются постоянными, то есть при одинаковых входных значениях они всегда выдают одинаковый результат. Именно этим предположением оправдывается то, что ограничения <code class="literal">CHECK</code> проверяются только при первом преобразовании значения в тип домена, а не при каждом обращении к нему. (По сути таким же образом обрабатываются ограничения <code class="literal">CHECK</code> для таблиц, как описано в <a class="xref" href="ddl-constraints.html#DDL-CONSTRAINTS-CHECK-CONSTRAINTS" title="5.4.1. Ограничения-проверки">Подразделе 5.4.1</a>.)</p><p>Однако это предположение может нарушаться, как часто бывает, когда в выражении <code class="literal">CHECK</code> используется пользовательская функция, поведение которой впоследствии меняется. <span class="productname">PostgreSQL</span> не запрещает этого, и если сохранённые значения типа домена перестанут удовлетворять ограничению <code class="literal">CHECK</code>, это останется незамеченным. В итоге при попытке загрузить выгруженные позже данные могут возникнуть проблемы. Поэтому подобные изменения рекомендуется осуществлять следующим образом: удалить ограничение (используя <code class="command">ALTER DOMAIN</code>), изменить определение функции, а затем пересоздать ограничение той же командой, которая при этом перепроверит сохранённые данные.</p><p>Рекомендуется следить за тем, чтобы выражения <code class="literal">CHECK</code> не выдавали ошибки.</p></div><div class="refsect1" id="id-1.9.3.62.8"><h2>Примеры</h2><p>В этом примере создаётся тип данных <code class="type">us_postal_code</code> (почтовый индекс США), который затем используется в определении таблицы. Для проверки значения на соответствие формату почтовых индексов США применяется проверка с регулярными выражениями: </p><pre class="programlisting">CREATE DOMAIN us_postal_code AS TEXT
CHECK(
   VALUE ~ '^\d{5}$'
OR VALUE ~ '^\d{5}-\d{4}$'
);

CREATE TABLE us_snail_addy (
  address_id SERIAL PRIMARY KEY,
  street1 TEXT NOT NULL,
  street2 TEXT,
  street3 TEXT,
  city TEXT NOT NULL,
  postal us_postal_code NOT NULL
);</pre></div><div class="refsect1" id="SQL-CREATEDOMAIN-COMPATIBILITY"><h2>Совместимость</h2><p>Команда <code class="command">CREATE DOMAIN</code> соответствует стандарту SQL.</p></div><div class="refsect1" id="SQL-CREATEDOMAIN-SEE-ALSO"><h2>См. также</h2><span class="simplelist"><a class="xref" href="sql-alterdomain.html" title="ALTER DOMAIN"><span class="refentrytitle">ALTER DOMAIN</span></a>, <a class="xref" href="sql-dropdomain.html" title="DROP DOMAIN"><span class="refentrytitle">DROP DOMAIN</span></a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-createdatabase.html" title="CREATE DATABASE">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-createeventtrigger.html" title="CREATE EVENT TRIGGER">След.</a></td></tr><tr><td width="40%" align="left" valign="top">CREATE DATABASE </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> CREATE EVENT TRIGGER</td></tr></table></div></body></html>