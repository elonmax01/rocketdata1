<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>F.43. tablefunc — функции, возвращающие таблицы (crosstab и не только)</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sslinfo.html" title="F.42. sslinfo — получение информации об SSL-сертификате клиента" /><link rel="next" href="tcn.html" title="F.44. tcn — триггерная функция, сообщающая приёмникам уведомлений об изменениях в содержимом таблицы" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">F.43. tablefunc — функции, возвращающие таблицы (<code class="function">crosstab</code> и не только)</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sslinfo.html" title="F.42. sslinfo — получение информации об SSL-сертификате клиента">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="contrib.html" title="Приложение F. Дополнительно поставляемые модули и расширения">Наверх</a></td><th width="60%" align="center">Приложение F. Дополнительно поставляемые модули и расширения</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="tcn.html" title="F.44. tcn — триггерная функция, сообщающая приёмникам уведомлений об изменениях в содержимом таблицы">След.</a></td></tr></table><hr /></div><div class="sect1" id="TABLEFUNC"><div class="titlepage"><div><div><h2 class="title" style="clear: both">F.43. tablefunc — функции, возвращающие таблицы (<code class="function">crosstab</code> и не только) <a href="#TABLEFUNC" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="tablefunc.html#TABLEFUNC-FUNCTIONS-SECT">F.43.1. Предоставляемые функции</a></span></dt><dt><span class="sect2"><a href="tablefunc.html#TABLEFUNC-AUTHOR">F.43.2. Автор</a></span></dt></dl></div><a id="id-1.11.7.53.2" class="indexterm"></a><p>Модуль <code class="filename">tablefunc</code> содержит ряд функций, возвращающих таблицы (то есть, множества строк). Эти функции полезны и сами по себе, и как примеры написания на C функций, возвращающих наборы строк.</p><p>Данный модуль считается <span class="quote">«<span class="quote">доверенным</span>»</span>, то есть его могут устанавливать обычные пользователи, имеющие право <code class="literal">CREATE</code> в текущей базе данных.</p><div class="sect2" id="TABLEFUNC-FUNCTIONS-SECT"><div class="titlepage"><div><div><h3 class="title">F.43.1. Предоставляемые функции <a href="#TABLEFUNC-FUNCTIONS-SECT" class="id_link">#</a></h3></div></div></div><p>Функции, предоставляемые модулем <code class="filename">tablefunc</code>, перечислены в <a class="xref" href="tablefunc.html#TABLEFUNC-FUNCTIONS" title="Таблица F.32. Функции tablefunc">Таблице F.32</a>.</p><div class="table" id="TABLEFUNC-FUNCTIONS"><p class="title"><strong>Таблица F.32. Функции <code class="filename">tablefunc</code></strong></p><div class="table-contents"><table class="table" summary="Функции tablefunc" border="1"><colgroup><col /></colgroup><thead><tr><th class="func_table_entry"><p class="func_signature">Функция</p>
       <p>Описание</p></th></tr></thead><tbody><tr><td class="func_table_entry"><p class="func_signature"><code class="function">normal_rand</code> ( <em class="parameter"><code>numvals</code></em> <code class="type">integer</code>, <em class="parameter"><code>mean</code></em> <code class="type">float8</code>, <em class="parameter"><code>stddev</code></em> <code class="type">float8</code> ) → <code class="returnvalue">setof float8</code></p>
       <p>Выдаёт набор случайных значений, имеющих нормальное распределение.</p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">crosstab</code> ( <em class="parameter"><code>sql</code></em> <code class="type">text</code> ) → <code class="returnvalue">setof record</code></p>
       <p>Выдаёт <span class="quote">«<span class="quote">повёрнутую таблицу</span>»</span>, содержащую имена строк плюс <em class="replaceable"><code>N</code></em> столбцов значений, где <em class="replaceable"><code>N</code></em> определяется видом строк, заданным в вызывающем запросе.</p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">crosstab<em class="replaceable"><code>N</code></em></code> ( <em class="parameter"><code>sql</code></em> <code class="type">text</code> ) → <code class="returnvalue">setof table_crosstab_<em class="replaceable"><code>N</code></em></code></p>
       <p>Выдаёт <span class="quote">«<span class="quote">повёрнутую таблицу</span>»</span>, содержащую имена строк плюс <em class="replaceable"><code>N</code></em> столбцов значений. Функции <code class="function">crosstab2</code>, <code class="function">crosstab3</code> и <code class="function">crosstab4</code> предопределены, но вы можете создать дополнительные функции <code class="function">crosstab<em class="replaceable"><code>N</code></em></code>, как описано ниже.</p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">crosstab</code> ( <em class="parameter"><code>source_sql</code></em> <code class="type">text</code>, <em class="parameter"><code>category_sql</code></em> <code class="type">text</code> ) → <code class="returnvalue">setof record</code></p>
       <p>Выдаёт <span class="quote">«<span class="quote">повёрнутую таблицу</span>»</span> со столбцами значений, заданными вторым запросом.</p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">crosstab</code> ( <em class="parameter"><code>sql</code></em> <code class="type">text</code>, <em class="parameter"><code>N</code></em> <code class="type">integer</code> ) → <code class="returnvalue">setof record</code></p>
       <p>Устаревшая версия <code class="function">crosstab(text)</code>. Параметр <em class="parameter"><code>N</code></em> теперь игнорируется, так как число столбцов значений всегда определяется вызывающим запросом.</p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.11.7.53.5.3.2.2.6.1.1.1" class="indexterm"></a> <code class="function">connectby</code> ( <em class="parameter"><code>relname</code></em> <code class="type">text</code>, <em class="parameter"><code>keyid_fld</code></em> <code class="type">text</code>, <em class="parameter"><code>parent_keyid_fld</code></em> <code class="type">text</code> [<span class="optional">, <em class="parameter"><code>orderby_fld</code></em> <code class="type">text</code></span>], <em class="parameter"><code>start_with</code></em> <code class="type">text</code>, <em class="parameter"><code>max_depth</code></em> <code class="type">integer</code> [<span class="optional">, <em class="parameter"><code>branch_delim</code></em> <code class="type">text</code></span>] ) → <code class="returnvalue">setof record</code></p>
       <p>Выдаёт представление иерархической древовидной структуры.</p></td></tr></tbody></table></div></div><br class="table-break" /><div class="sect3" id="TABLEFUNC-FUNCTIONS-NORMAL-RAND"><div class="titlepage"><div><div><h4 class="title">F.43.1.1. <code class="function">normal_rand</code> <a href="#TABLEFUNC-FUNCTIONS-NORMAL-RAND" class="id_link">#</a></h4></div></div></div><a id="id-1.11.7.53.5.4.2" class="indexterm"></a><pre class="synopsis">normal_rand(int numvals, float8 mean, float8 stddev) returns setof float8</pre><p>Функция <code class="function">normal_rand</code> выдаёт набор случайных значений, имеющих нормальное распределение (распределение Гаусса).</p><p>Параметр <em class="parameter"><code>numvals</code></em> задаёт количество значений, которое выдаст эта функция. Параметр <em class="parameter"><code>mean</code></em> задаёт медиану нормального распределения, а <em class="parameter"><code>stddev</code></em> — стандартное отклонение.</p><p>Например, этот вызов запрашивает 1000 значений с медианой 5 и стандартным отклонением 3:</p><pre class="screen">test=# SELECT * FROM normal_rand(1000, 5, 3);
     normal_rand
----------------------
     1.56556322244898
     9.10040991424657
     5.36957140345079
   -0.369151492880995
    0.283600703686639
       .
       .
       .
     4.82992125404908
     9.71308014517282
     2.49639286969028
(1000 rows)</pre></div><div class="sect3" id="TABLEFUNC-FUNCTIONS-CROSSTAB-TEXT"><div class="titlepage"><div><div><h4 class="title">F.43.1.2. <code class="function">crosstab(text)</code> <a href="#TABLEFUNC-FUNCTIONS-CROSSTAB-TEXT" class="id_link">#</a></h4></div></div></div><a id="id-1.11.7.53.5.5.2" class="indexterm"></a><pre class="synopsis">crosstab(text sql)
crosstab(text sql, int N)</pre><p>Функция <code class="function">crosstab</code> применяется для формирования <span class="quote">«<span class="quote">повёрнутых</span>»</span> отображений, в которых данные идут вдоль строк, а не сверху вниз. Например, мы можем иметь такие данные: </p><pre class="programlisting">row1    val11
row1    val12
row1    val13
...
row2    val21
row2    val22
row2    val23
...</pre><p> и хотим видеть их так: </p><pre class="programlisting">row1    val11   val12   val13   ...
row2    val21   val22   val23   ...
...</pre><p> Функция <code class="function">crosstab</code> принимает в текстовом параметре SQL-запрос, выдающий исходные данные первым способом, и выдаёт таблицу, отформатированную вторым способом.</p><p>В параметре <em class="parameter"><code>sql</code></em> передаётся SQL-запрос, выдающий исходный набор данных. Этот запрос должен возвращать один столбец <code class="structfield">row_name</code>, один столбец <code class="structfield">category</code> и один столбец <code class="structfield">value</code>. Параметр <em class="parameter"><code>N</code></em> является устаревшим и игнорируется, если передаётся при вызове (раньше он должен был соответствовать количеству выходных столбцов значений, но теперь это количество определяется вызывающим запросом).</p><p>Например, заданный запрос может выдавать такой результат: </p><pre class="programlisting"> row_name    cat    value
----------+-------+-------
  row1      cat1    val1
  row1      cat2    val2
  row1      cat3    val3
  row1      cat4    val4
  row2      cat1    val5
  row2      cat2    val6
  row2      cat3    val7
  row2      cat4    val8</pre><p>Функция <code class="function">crosstab</code> объявлена как возвращающая <code class="type">setof record</code>, так что фактические имена и типы столбцов должны определяться в предложении <code class="literal">FROM</code> вызывающего оператора <code class="command">SELECT</code>, например так: </p><pre class="programlisting">SELECT * FROM crosstab('...') AS ct(row_name text, category_1 text, category_2 text);</pre><p> Этот запрос выдаст примерно такой результат: </p><pre class="programlisting">           &lt;== столбцы значений ==&gt;
 row_name   category_1   category_2
----------+------------+------------
  row1        val1         val2
  row2        val5         val6</pre><p>Предложение <code class="literal">FROM</code> должно определять результат со столбцом <code class="structfield">row_name</code> (того же типа данных, что у первого результирующего столбца SQL-запроса), за которым следуют N столбцов значений (все того же типа данных, что и третий результирующий столбец SQL-запроса). Количество выходных столбцов значений может быть произвольным и имена выходных столбцов определяете вы сами.</p><p>Функция <code class="function">crosstab</code> выдаёт одну выходную строку для каждой последовательной группы с одним значением <code class="structfield">row_name</code>. Она заполняет столбцы значений слева направо полями <code class="structfield">value</code> из этих строк. Если в группе оказывается меньше строк, чем выходных столбцов значений, дополнительные столбцы принимают значения NULL; если же строк оказывается больше, лишние строки игнорируются.</p><p>На практике в SQL-запросе всегда должно указываться <code class="literal">ORDER BY 1,2</code>, чтобы входные строки были отсортированы должным образом, то есть, чтобы данные с одинаковым значением <code class="structfield">row_name</code> собирались вместе и корректно упорядочивались в строке. Заметьте, что сама <code class="function">crosstab</code> не учитывает второй столбец результата запроса; он присутствует только для того, чтобы определять порядок, в котором значения третьего столбца будут следовать в строке.</p><p>Полный пример: </p><pre class="programlisting">CREATE TABLE ct(id SERIAL, rowid TEXT, attribute TEXT, value TEXT);
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att1','val1');
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att2','val2');
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att3','val3');
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att4','val4');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att1','val5');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att2','val6');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att3','val7');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att4','val8');

SELECT *
FROM crosstab(
  'select rowid, attribute, value
   from ct
   where attribute = ''att2'' or attribute = ''att3''
   order by 1,2')
AS ct(row_name text, category_1 text, category_2 text, category_3 text);

 row_name | category_1 | category_2 | category_3
----------+------------+------------+------------
 test1    | val2       | val3       |
 test2    | val6       | val7       |
(2 rows)</pre><p>Вы можете в любом случае обойтись без написания предложения <code class="literal">FROM</code>, определяющего выходные столбцы, создав собственную функцию crosstab, в определении которой будет зашит желательный тип выходной строки. Это описывается в следующем разделе. Также имеется возможность включить требуемое предложение <code class="literal">FROM</code> в определение представления.</p><div class="note"><h3 class="title">Примечание</h3><p>Также изучите команду <code class="command"><a class="link" href="app-psql.html#APP-PSQL-META-COMMANDS-CROSSTABVIEW">\crosstabview</a></code> в <span class="application">psql</span>, реализующую функциональность, подобную <code class="function">crosstab()</code>.</p></div></div><div class="sect3" id="TABLEFUNC-FUNCTIONS-CROSSTAB-N-TEXT"><div class="titlepage"><div><div><h4 class="title">F.43.1.3. <code class="function">crosstab<em class="replaceable"><code>N</code></em>(text)</code> <a href="#TABLEFUNC-FUNCTIONS-CROSSTAB-N-TEXT" class="id_link">#</a></h4></div></div></div><a id="id-1.11.7.53.5.6.2" class="indexterm"></a><pre class="synopsis">crosstab<em class="replaceable"><code>N</code></em>(text sql)</pre><p>Функции <code class="function">crosstab<em class="replaceable"><code>N</code></em></code> являются примерами того, как можно создать собственные обёртки универсальной функции <code class="function">crosstab</code>, чтобы не приходилось выписывать имена и типы столбцов в вызывающем запросе <code class="command">SELECT</code>. Модуль <code class="filename">tablefunc</code> включает функции <code class="function">crosstab2</code>, <code class="function">crosstab3</code> и <code class="function">crosstab4</code>, определяющие типы выходных строк так:</p><pre class="programlisting">CREATE TYPE tablefunc_crosstab_N AS (
    row_name TEXT,
    category_1 TEXT,
    category_2 TEXT,
        .
        .
        .
    category_N TEXT
);</pre><p>Таким образом, эти функции могут применяться непосредственно, когда входной запрос выдаёт столбцы <code class="structfield">row_name</code> и <code class="structfield">value</code> типа <code class="type">text</code> и вы хотите получить на выходе 2, 3 или 4 столбца значений. В остальном эти функции ведут себя в точности так же, как и универсальная функция <code class="function">crosstab</code>.</p><p>Так, пример, приведённый в предыдущем разделе, можно переписать и в таком виде: </p><pre class="programlisting">SELECT *
FROM crosstab3(
  'select rowid, attribute, value
   from ct
   where attribute = ''att2'' or attribute = ''att3''
   order by 1,2');</pre><p>Эти функции представлены в основном в демонстрационных целях. Вы можете создать собственные типы возвращаемых данных и реализовать функции на базе нижележащей функции <code class="function">crosstab()</code>. Это можно сделать двумя способами: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Создать составной тип, описывающий желаемые выходные столбцы, примерно как это делается в примерах в <code class="filename">contrib/tablefunc/tablefunc--1.0.sql</code>. Затем нужно выбрать уникальное имя для функции, принимающей один параметр <code class="type">text</code> и возвращающей <code class="type">setof имя_вашего_типа</code>, и связать его с той же нижележащей функцией <code class="function">crosstab</code> на C. Например, если ваш источник данных выдаёт имена строк типа <code class="type">text</code> и значения типа <code class="type">float8</code>, и вы хотите получить 5 столбцов значений: </p><pre class="programlisting">CREATE TYPE my_crosstab_float8_5_cols AS (
    my_row_name text,
    my_category_1 float8,
    my_category_2 float8,
    my_category_3 float8,
    my_category_4 float8,
    my_category_5 float8
);

CREATE OR REPLACE FUNCTION crosstab_float8_5_cols(text)
    RETURNS setof my_crosstab_float8_5_cols
    AS '$libdir/tablefunc','crosstab' LANGUAGE C STABLE STRICT;</pre></li><li class="listitem"><p>Использовать выходные параметры (<code class="literal">OUT</code>), чтобы явно определить возвращаемый тип. Тот же пример можно реализовать и таким способом: </p><pre class="programlisting">CREATE OR REPLACE FUNCTION crosstab_float8_5_cols(
    IN text,
    OUT my_row_name text,
    OUT my_category_1 float8,
    OUT my_category_2 float8,
    OUT my_category_3 float8,
    OUT my_category_4 float8,
    OUT my_category_5 float8)
  RETURNS setof record
  AS '$libdir/tablefunc','crosstab' LANGUAGE C STABLE STRICT;</pre></li></ul></div></div><div class="sect3" id="TABLEFUNC-FUNCTIONS-CROSSTAB-TEXT-2"><div class="titlepage"><div><div><h4 class="title">F.43.1.4. <code class="function">crosstab(text, text)</code> <a href="#TABLEFUNC-FUNCTIONS-CROSSTAB-TEXT-2" class="id_link">#</a></h4></div></div></div><a id="id-1.11.7.53.5.7.2" class="indexterm"></a><pre class="synopsis">crosstab(text source_sql, text category_sql)</pre><p>Основное ограничение формы <code class="function">crosstab</code> с одним параметром состоит в том, что она воспринимает все значения в группе одинаково и вставляет очередное значение в первый свободный столбец. Если вы хотите, чтобы столбцы значений соответствовали определённым категориям данных и некоторые группы могли содержать данные не для всех категорий, этот подход не будет работать. Форма <code class="function">crosstab</code> с двумя параметрами решает эту задачу, принимая явный список категорий, соответствующих выходным столбцам.</p><p>В параметре <em class="parameter"><code>source_sql</code></em> передаётся SQL-оператор, выдающий исходный набор данных. Этот оператор должен выдавать строки со столбцом <code class="structfield">row_name</code>, столбцом <code class="structfield">category</code> и столбцом <code class="structfield">value</code>. Также он может выдать один или несколько <span class="quote">«<span class="quote">дополнительных</span>»</span> столбцов. Столбец <code class="structfield">row_name</code> должен быть первым, а столбцы <code class="structfield">category</code> и <code class="structfield">value</code> — последними двумя, именно в этом порядке. Все столбцы между <code class="structfield">row_name</code> и <code class="structfield">category</code> воспринимаются как <span class="quote">«<span class="quote">дополнительные</span>»</span>. Ожидается, что <span class="quote">«<span class="quote">дополнительные</span>»</span> столбцы будут содержать одинаковые значения для всех строк с одним значением <code class="structfield">row_name</code>.</p><p>Например, <em class="parameter"><code>source_sql</code></em> может выдать такой набор данных: </p><pre class="programlisting">SELECT row_name, extra_col, cat, value FROM foo ORDER BY 1;

 row_name    extra_col   cat    value
----------+------------+-----+---------
  row1         extra1    cat1    val1
  row1         extra1    cat2    val2
  row1         extra1    cat4    val4
  row2         extra2    cat1    val5
  row2         extra2    cat2    val6
  row2         extra2    cat3    val7
  row2         extra2    cat4    val8</pre><p>В параметре <em class="parameter"><code>category_sql</code></em> передаётся оператор SQL, выдающий набор категорий. Этот оператор должен возвращать всего один столбец. Он должен выдать минимум одну строку; в противном случае произойдёт ошибка. Кроме того, выдаваемые им значения не должны повторяться, иначе так же произойдёт ошибка. В качестве <em class="parameter"><code>category_sql</code></em> можно передать, например, такой запрос: </p><pre class="programlisting">SELECT DISTINCT cat FROM foo ORDER BY 1;
    cat
  -------
    cat1
    cat2
    cat3
    cat4</pre><p>Функция <code class="function">crosstab</code> объявлена как возвращающая тип <code class="type">setof record</code>, так что фактические имена и типы выходных столбцов должны определяться в предложении <code class="literal">FROM</code> вызывающего оператора <code class="command">SELECT</code>, например так: </p><pre class="programlisting">SELECT * FROM crosstab('...', '...')
    AS ct(row_name text, extra text, cat1 text, cat2 text, cat3 text, cat4 text);</pre><p>При этом будет получен примерно такой результат: </p><pre class="programlisting">                  &lt;==  столбцы значений   ==&gt;
row_name   extra   cat1   cat2   cat3   cat4
---------+-------+------+------+------+------
  row1     extra1  val1   val2          val4
  row2     extra2  val5   val6   val7   val8</pre><p>В предложении <code class="literal">FROM</code> должно определяться нужное количество выходных столбцов соответствующих типов данных. Если запрос <em class="parameter"><code>source_sql</code></em> выдаёт <em class="replaceable"><code>N</code></em> столбцов, первые <em class="replaceable"><code>N</code></em>-2 из них должны соответствовать первым <em class="replaceable"><code>N</code></em>-2 выходным столбцам. Оставшиеся выходные столбцы должны иметь тип последнего столбца результата <em class="parameter"><code>source_sql</code></em> и их должно быть столько, сколько строк оказалось в результате запроса <em class="parameter"><code>category_sql</code></em>.</p><p>Функция <code class="function">crosstab</code> выдаёт одну выходную строку для каждой последовательной группы входных строк с одним значением <code class="structfield">row_name</code>. Выходной столбец <code class="structfield">row_name</code> плюс все <span class="quote">«<span class="quote">дополнительные</span>»</span> столбцы копируются из первой строки группы. Выходные столбцы значений заполняются содержимым полей <code class="structfield">value</code> из строк с соответствующими значениями <code class="structfield">category</code>. Если в поле <code class="structfield">category</code> оказывается значение, отсутствующее в результате запроса <em class="parameter"><code>category_sql</code></em>, содержимое поля <code class="structfield">value</code> в этой строке игнорируется. Выходные столбцы, для которых соответствующая категория не представлена ни в одной из входных строк группы, принимают значения NULL.</p><p>На практике в запросе <em class="parameter"><code>source_sql</code></em> всегда нужно указывать <code class="literal">ORDER BY 1</code>, чтобы все значения с одним <code class="structfield">row_name</code> гарантированно выводились вместе. Порядок же категорий внутри группы не важен. Кроме того, важно, чтобы порядок значений, выдаваемых запросом <em class="parameter"><code>category_sql</code></em>, соответствовал заданному порядку выходных столбцов.</p><p>Два законченных примера: </p><pre class="programlisting">create table sales(year int, month int, qty int);
insert into sales values(2007, 1, 1000);
insert into sales values(2007, 2, 1500);
insert into sales values(2007, 7, 500);
insert into sales values(2007, 11, 1500);
insert into sales values(2007, 12, 2000);
insert into sales values(2008, 1, 1000);

select * from crosstab(
  'select year, month, qty from sales order by 1',
  'select m from generate_series(1,12) m'
) as (
  year int,
  "Jan" int,
  "Feb" int,
  "Mar" int,
  "Apr" int,
  "May" int,
  "Jun" int,
  "Jul" int,
  "Aug" int,
  "Sep" int,
  "Oct" int,
  "Nov" int,
  "Dec" int
);
 year | Jan  | Feb  | Mar | Apr | May | Jun | Jul | Aug | Sep | Oct | Nov  | Dec
------+------+------+-----+-----+-----+-----+-----+-----+-----+-----+------+------
 2007 | 1000 | 1500 |     |     |     |     | 500 |     |     |     | 1500 | 2000
 2008 | 1000 |      |     |     |     |     |     |     |     |     |      |
(2 rows)</pre><p> </p><pre class="programlisting">CREATE TABLE cth(rowid text, rowdt timestamp, attribute text, val text);
INSERT INTO cth VALUES('test1','01 March 2003','temperature','42');
INSERT INTO cth VALUES('test1','01 March 2003','test_result','PASS');
INSERT INTO cth VALUES('test1','01 March 2003','volts','2.6987');
INSERT INTO cth VALUES('test2','02 March 2003','temperature','53');
INSERT INTO cth VALUES('test2','02 March 2003','test_result','FAIL');
INSERT INTO cth VALUES('test2','02 March 2003','test_startdate','01 March 2003');
INSERT INTO cth VALUES('test2','02 March 2003','volts','3.1234');

SELECT * FROM crosstab
(
  'SELECT rowid, rowdt, attribute, val FROM cth ORDER BY 1',
  'SELECT DISTINCT attribute FROM cth ORDER BY 1'
)
AS
(
       rowid text,
       rowdt timestamp,
       temperature int4,
       test_result text,
       test_startdate timestamp,
       volts float8
);
 rowid |          rowdt           | temperature | test_result |      test_startdate      | volts
-------+--------------------------+-------------+-------------+--------------------------+--------
 test1 | Sat Mar 01 00:00:00 2003 |          42 | PASS        |                          | 2.6987
 test2 | Sun Mar 02 00:00:00 2003 |          53 | FAIL        | Sat Mar 01 00:00:00 2003 | 3.1234
(2 rows)</pre><p>Вы можете создать предопределённые функции, чтобы не выписывать имена и типы результирующих столбцов в каждом запросе. Примеры приведены в предыдущем разделе. Нижележащая функция C для этой формы <code class="function">crosstab</code> называется <code class="literal">crosstab_hash</code>.</p></div><div class="sect3" id="TABLEFUNC-FUNCTIONS-CONNECTBY"><div class="titlepage"><div><div><h4 class="title">F.43.1.5. <code class="function">connectby</code> <a href="#TABLEFUNC-FUNCTIONS-CONNECTBY" class="id_link">#</a></h4></div></div></div><a id="id-1.11.7.53.5.8.2" class="indexterm"></a><pre class="synopsis">connectby(text relname, text keyid_fld, text parent_keyid_fld
          [, text orderby_fld ], text start_with, int max_depth
          [, text branch_delim ])</pre><p>Функция <code class="function">connectby</code> выдаёт отображение данных, содержащихся в таблице, в иерархическом виде. Таблица должна содержать поле ключа, однозначно идентифицирующее строки, и поле ключа родителя, ссылающееся на родителя строки (если он есть). Функция <code class="function">connectby</code> может вывести вложенное дерево, начиная с любой строки.</p><p>Параметры описаны в <a class="xref" href="tablefunc.html#TABLEFUNC-CONNECTBY-PARAMETERS" title="Таблица F.33. Параметры connectby">Таблице F.33</a>.</p><div class="table" id="TABLEFUNC-CONNECTBY-PARAMETERS"><p class="title"><strong>Таблица F.33. Параметры <code class="function">connectby</code></strong></p><div class="table-contents"><table class="table" summary="Параметры connectby" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Параметр</th><th>Описание</th></tr></thead><tbody><tr><td><em class="parameter"><code>relname</code></em></td><td>Имя исходного отношения</td></tr><tr><td><em class="parameter"><code>keyid_fld</code></em></td><td>Имя поля ключа</td></tr><tr><td><em class="parameter"><code>parent_keyid_fld</code></em></td><td>Имя поля, содержащего ключ родителя</td></tr><tr><td><em class="parameter"><code>orderby_fld</code></em></td><td>Имя поля, по которому сортируются потомки (необязательно)</td></tr><tr><td><em class="parameter"><code>start_with</code></em></td><td>Значение ключа отправной строки</td></tr><tr><td><em class="parameter"><code>max_depth</code></em></td><td>Максимальная глубина, на которую можно погрузиться, либо ноль для неограниченного погружения</td></tr><tr><td><em class="parameter"><code>branch_delim</code></em></td><td>Строка, разделяющая ключи в выводе ветви (необязательно)</td></tr></tbody></table></div></div><br class="table-break" /><p>Поля ключа и ключа родителя могут быть любого типа, но должны иметь общий тип. Заметьте, что значение <em class="parameter"><code>start_with</code></em> должно задаваться текстовой строкой, вне зависимости от типа поля ключа.</p><p>Функция <code class="function">connectby</code> объявлена как возвращающая <code class="type">setof record</code>, так что фактические имена и типы выходных столбцов должны определяться в предложении <code class="literal">FROM</code> вызывающего оператора <code class="command">SELECT</code>, например так:</p><pre class="programlisting">SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0, '~')
    AS t(keyid text, parent_keyid text, level int, branch text, pos int);</pre><p>Первые два выходных столбца используются для вывода ключа текущей строки и ключа её родителя; их тип должен соответствовать типу поля ключа. Третий выходной столбец задаёт глубину в дереве и должен иметь тип <code class="type">integer</code>. Если передаётся параметр <em class="parameter"><code>branch_delim</code></em>, в следующем столбце выводятся ветви, и этот столбец должен иметь тип <code class="type">text</code>. Наконец, если передаётся параметр <em class="parameter"><code>orderby_fld</code></em>, в последнем столбце выводятся последовательные числа, и он должен иметь тип <code class="type">integer</code>.</p><p>В столбце <span class="quote">«<span class="quote">branch</span>»</span> показывается путь по ключам, приведший к текущей строке. Ключи разделяются заданной строкой <em class="parameter"><code>branch_delim</code></em>. Если выводить ветви не требуется, опустите параметр <em class="parameter"><code>branch_delim</code></em> и столбец branch в списке выходных столбцов.</p><p>Если порядок потомков одного родителя имеет значение, добавьте параметр <em class="parameter"><code>orderby_fld</code></em>, указывающий поле для упорядочивания потомков. Это поле может иметь любой тип, допускающий сортировку. Список выходных столбцов должен включать последним столбцом целочисленный столбец с последовательными значениями, если и только если передаётся параметр <em class="parameter"><code>orderby_fld</code></em>.</p><p>Параметры, представляющие имена таблицы и полей, копируются как есть в SQL-запросы, которые <code class="function">connectby</code> генерирует внутри. Таким образом, их нужно заключить в двойные кавычки, если они содержат буквы в разном регистре или специальные символы. Также может понадобиться дополнить имя таблицы схемой.</p><p>С большими таблицами производительность будет неудовлетворительной, если не создать индекс по полю с ключом родителя.</p><p>Важно, чтобы строка <em class="parameter"><code>branch_delim</code></em> не фигурировала в значениях ключа, иначе <code class="function">connectby</code> может некорректно сообщить об ошибке бесконечной вложенности. Заметьте, что если параметр <em class="parameter"><code>branch_delim</code></em> не задаётся, для выявления зацикленности применяется символ <code class="literal">~</code>.</p><p>Пример: </p><pre class="programlisting">CREATE TABLE connectby_tree(keyid text, parent_keyid text, pos int);

INSERT INTO connectby_tree VALUES('row1',NULL, 0);
INSERT INTO connectby_tree VALUES('row2','row1', 0);
INSERT INTO connectby_tree VALUES('row3','row1', 0);
INSERT INTO connectby_tree VALUES('row4','row2', 1);
INSERT INTO connectby_tree VALUES('row5','row2', 0);
INSERT INTO connectby_tree VALUES('row6','row4', 0);
INSERT INTO connectby_tree VALUES('row7','row3', 0);
INSERT INTO connectby_tree VALUES('row8','row6', 0);
INSERT INTO connectby_tree VALUES('row9','row5', 0);

-- с ветвями без orderby_fld (порядок результатов не гарантируется)
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'row2', 0, '~')
 AS t(keyid text, parent_keyid text, level int, branch text);
 keyid | parent_keyid | level |       branch
-------+--------------+-------+---------------------
 row2  |              |     0 | row2
 row4  | row2         |     1 | row2~row4
 row6  | row4         |     2 | row2~row4~row6
 row8  | row6         |     3 | row2~row4~row6~row8
 row5  | row2         |     1 | row2~row5
 row9  | row5         |     2 | row2~row5~row9
(6 rows)

-- без ветвей и без orderby_fld (порядок результатов не гарантируется)
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'row2', 0)
 AS t(keyid text, parent_keyid text, level int);
 keyid | parent_keyid | level
-------+--------------+-------
 row2  |              |     0
 row4  | row2         |     1
 row6  | row4         |     2
 row8  | row6         |     3
 row5  | row2         |     1
 row9  | row5         |     2
(6 rows)

-- с ветвями и с orderby_fld (заметьте, что row5 идёт перед row4)
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0, '~')
 AS t(keyid text, parent_keyid text, level int, branch text, pos int);
 keyid | parent_keyid | level |       branch        | pos
-------+--------------+-------+---------------------+-----
 row2  |              |     0 | row2                |   1
 row5  | row2         |     1 | row2~row5           |   2
 row9  | row5         |     2 | row2~row5~row9      |   3
 row4  | row2         |     1 | row2~row4           |   4
 row6  | row4         |     2 | row2~row4~row6      |   5
 row8  | row6         |     3 | row2~row4~row6~row8 |   6
(6 rows)

-- без ветвей, с orderby_fld (заметьте, что row5 идёт перед row4)
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0)
 AS t(keyid text, parent_keyid text, level int, pos int);
 keyid | parent_keyid | level | pos
-------+--------------+-------+-----
 row2  |              |     0 |   1
 row5  | row2         |     1 |   2
 row9  | row5         |     2 |   3
 row4  | row2         |     1 |   4
 row6  | row4         |     2 |   5
 row8  | row6         |     3 |   6
(6 rows)</pre></div></div><div class="sect2" id="TABLEFUNC-AUTHOR"><div class="titlepage"><div><div><h3 class="title">F.43.2. Автор <a href="#TABLEFUNC-AUTHOR" class="id_link">#</a></h3></div></div></div><p>Джо Конвей</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sslinfo.html" title="F.42. sslinfo — получение информации об SSL-сертификате клиента">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="contrib.html" title="Приложение F. Дополнительно поставляемые модули и расширения">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="tcn.html" title="F.44. tcn — триггерная функция, сообщающая приёмникам уведомлений об изменениях в содержимом таблицы">След.</a></td></tr><tr><td width="40%" align="left" valign="top">F.42. sslinfo — получение информации об SSL-сертификате клиента </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> F.44. tcn — триггерная функция, сообщающая приёмникам уведомлений об изменениях в содержимом таблицы</td></tr></table></div></body></html>