<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>64.3. Сканирование индекса</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="index-functions.html" title="64.2. Функции для индексных методов доступа" /><link rel="next" href="index-locking.html" title="64.4. Замечания о блокировке с индексами" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">64.3. Сканирование индекса</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="index-functions.html" title="64.2. Функции для индексных методов доступа">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="indexam.html" title="Глава 64. Определение интерфейса для индексных методов доступа">Наверх</a></td><th width="60%" align="center">Глава 64. Определение интерфейса для индексных методов доступа</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="index-locking.html" title="64.4. Замечания о блокировке с индексами">След.</a></td></tr></table><hr /></div><div class="sect1" id="INDEX-SCANNING"><div class="titlepage"><div><div><h2 class="title" style="clear: both">64.3. Сканирование индекса <a href="#INDEX-SCANNING" class="id_link">#</a></h2></div></div></div><p>В процессе сканирования индексный метод доступа отвечает только за выдачу идентификаторов всех кортежей, которые по его представлению соответствуют <em class="firstterm">ключам сканирования</em>. Метод доступа <span class="emphasis"><em>не</em></span> участвует в самой процедуре выборки этих кортежей из основной таблицы и не определяет, удовлетворяют ли эти кортежи условиям видимости или другим ограничениям.</p><p>Ключом сканирования является внутреннее представление предложения <code class="literal">WHERE</code> в виде <em class="replaceable"><code>ключ_индекса</code></em> <em class="replaceable"><code>оператор</code></em> <em class="replaceable"><code>константа</code></em>, где ключ индекса — один из столбцов индекса, а оператор — один из членов семейства операторов, связанного с типом данного столбца. При сканировании по индексу могут задаваться несколько или ноль ключей сканирования, результаты поиска которых должны неявно объединяться операцией AND — ожидается, что возвращаемые кортежи будут удовлетворять всем заданным условиям.</p><p>Метод доступа для конкретного запроса может сообщить, что индекс является <em class="firstterm">неточным</em> или, другими словами, требует перепроверки. Это подразумевает, что при сканировании индекса будут возвращены все записи, соответствующие ключу сканирования, плюс, возможно, дополнительные записи, которые ему не соответствуют. Внутренний механизм сканирования затем повторно применит условия индекса к кортежу данных, чтобы проверить, нужно ли его выбирать на самом деле. Если признак перепроверки не установлен, при сканировании индекса должны возвращаться только соответствующие ключам записи.</p><p>Заметьте, что именно метод доступа должен гарантировать, что корректно будут найдены все и только те записи, которые соответствуют всем переданным ключам сканирования. Также учтите, что ядро системы просто передаёт все предложения <code class="literal">WHERE</code> с подходящими ключами индекса и семействами операторов, не проводя семантический анализ на предмет их избыточности или противоречивости. Например, с условием <code class="literal">WHERE x &gt; 4 AND x &gt; 14</code>, где <code class="literal">x</code> — столбец с индексом-B-деревом, именно самой функции <code class="function">amrescan</code> в методе B-дерева предоставляется возможность понять, что первый ключ сканирования избыточный и может быть отброшен. Объём предварительной обработки, которую нужно произвести для этого в <code class="function">amrescan</code>, зависит от того, до какой степени метод доступа должен сводить ключи к <span class="quote">«<span class="quote">нормализованной</span>»</span> форме.</p><p>Некоторые методы доступа возвращают записи индекса в чётко определённом порядке, в отличие от других. Фактически есть два различных варианта реализации упорядоченного вывода некоторым методом доступа: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Для методов доступа, которые всегда возвращают записи в порядке их естественной сортировки (как например, в B-дереве), устанавливается признак <code class="structfield">amcanorder</code>. В настоящее время операторам проверки равенства и упорядочивания при этом должны назначаться номера соответствующих стратегий B-дерева.</p></li><li class="listitem"><p>Для методов доступа, которые поддерживают операторы упорядочивания, устанавливается признак <code class="structfield">amcanorderbyop</code>. Он показывает, что индекс может возвращать записи в порядке, определяемом предложением <code class="literal">ORDER BY</code> <em class="replaceable"><code>ключ_индекса</code></em> <em class="replaceable"><code>оператор</code></em> <em class="replaceable"><code>константа</code></em>. Модификаторы для такого сканирования могут передаваться в <code class="function">amrescan</code>, как описывалось ранее.</p></li></ul></div><p>У функции <code class="function">amgettuple</code> есть аргумент <code class="literal">direction</code>, который может принимать значение <code class="literal">ForwardScanDirection</code> (обычный вариант, сканирование вперёд) или <code class="literal">BackwardScanDirection</code> (сканирование назад). Если в первом вызове после <code class="function">amrescan</code> указывается <code class="literal">BackwardScanDirection</code>, то множество соответствующих записей индекса сканируется от конца к началу, а не в обычном направлении от начала к концу. В этом случае <code class="function">amgettuple</code> должна вернуть последний соответствующий кортеж индекса, а не первый как обычно. (Это распространяется только на методы доступа с установленным признаком <code class="structfield">amcanorder</code>.) После первого вызова <code class="function">amgettuple</code> должна быть готова продолжать сканирование в любом направлении от записи, выданной последней до этого. (Но если признак <code class="structfield">amcanbackward</code> не установлен, при всех последующих вызовах должно сохраняться то же направление, что было в первом.)</p><p>Методы доступа, которые поддерживают упорядоченное сканирование, должны уметь <span class="quote">«<span class="quote">помечать</span>»</span> позицию сканирования и затем возвращаться к помеченной позиции (возможно, несколько раз к одной и той же позиции). Но запоминаться должна только одна позиция в ходе сканирования; последующий вызов <code class="function">ammarkpos</code> переопределяет ранее сохранённую позицию. Метод доступа, не поддерживающий упорядоченное сканирование, не должен определять функции <code class="function">ammarkpos</code> и <code class="function">amrestrpos</code> в <code class="structname">IndexAmRoutine</code>; достаточно записать в эти указатели NULL.</p><p>И позиция сканирования, и отмеченная позиция (при наличии) должны поддерживаться в согласованном состоянии с учётом одновременных добавлений или удалений записей в индексе. Не будет ошибкой, если только что вставленная запись не будет выдана при сканировании, которое могло бы найти эту запись, если бы она существовала до его начала, либо если сканирование выдаст такую запись после перезапуска или возврата, даже если она не была выдана в первый раз. Подобным образом, параллельное удаление может отражаться, а может и не отражаться в результатах сканирования. Важно только, чтобы при таких операциях добавления или удаления не происходило потерь или дублирования записей, которые в этих операциях не участвовали.</p><p>Если индекс сохраняет исходные индексируемые значения данных (а не их искажённое представление), обычно полезно поддержать <a class="link" href="indexes-index-only-scans.html" title="11.9. Сканирование только индекса и покрывающие индексы">сканирование только индекса</a>, при котором индекс возвращает фактические данные, а не только TID кортежа данных. Это позволит соптимизировать ввод/вывод, только если карта видимости показывает, что TID относится к полностью видимой странице; в противном случае всё равно придётся посетить кортеж, чтобы проверить его видимость для MVCC. Но это не является заботой метода доступа.</p><p>Вместо <code class="function">amgettuple</code>, сканирование индекса может осуществляться функцией <code class="function">amgetbitmap</code>, которая выбирает все кортежи за один вызов. Это может быть значительно эффективнее <code class="function">amgettuple</code>, так как позволяет избежать циклов блокировки/разблокировки в методе доступа. В принципе, <code class="function">amgetbitmap</code> должна давать тот же эффект, что и многократные вызовы <code class="function">amgettuple</code>, но простоты ради мы накладываем ряд дополнительных ограничений. Во-первых, <code class="function">amgetbitmap</code> возвращает все кортежи сразу и не поддерживает пометку позиций и возвращение к ним. Во-вторых, кортежи, возвращаемые в битовой карте, не упорядочиваются каким-либо определённым образом, поэтому <code class="function">amgetbitmap</code> не принимает аргумент <code class="literal">direction</code>. (И операторы упорядочивания никогда не будут передаваться для такого сканирования.) Кроме того, сканирование только индекса с <code class="function">amgetbitmap</code> неосуществимо, так как нет никакой возможности возвратить содержимое кортежей индекса. Наконец, <code class="function">amgetbitmap</code> не гарантирует, что будут установлены какие-либо блокировки для возвращаемых кортежей, и следствия этого описаны в <a class="xref" href="index-locking.html" title="64.4. Замечания о блокировке с индексами">Разделе 64.4</a>.</p><p>Заметьте, что метод доступа может реализовывать только функцию <code class="function">amgetbitmap</code>, но не <code class="function">amgettuple</code>, и наоборот, если его внутренняя реализация несовместима с одной из этих функций.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="index-functions.html" title="64.2. Функции для индексных методов доступа">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="indexam.html" title="Глава 64. Определение интерфейса для индексных методов доступа">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="index-locking.html" title="64.4. Замечания о блокировке с индексами">След.</a></td></tr><tr><td width="40%" align="left" valign="top">64.2. Функции для индексных методов доступа </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 64.4. Замечания о блокировке с индексами</td></tr></table></div></body></html>