<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>11.1. Введение</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="indexes.html" title="Глава 11. Индексы" /><link rel="next" href="indexes-types.html" title="11.2. Типы индексов" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">11.1. Введение</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="indexes.html" title="Глава 11. Индексы">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="indexes.html" title="Глава 11. Индексы">Наверх</a></td><th width="60%" align="center">Глава 11. Индексы</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="indexes-types.html" title="11.2. Типы индексов">След.</a></td></tr></table><hr /></div><div class="sect1" id="INDEXES-INTRO"><div class="titlepage"><div><div><h2 class="title" style="clear: both">11.1. Введение <a href="#INDEXES-INTRO" class="id_link">#</a></h2></div></div></div><p>Предположим, что у нас есть такая таблица: </p><pre class="programlisting">CREATE TABLE test1 (
    id integer,
    content varchar
);</pre><p> и приложение выполняет много подобных запросов: </p><pre class="programlisting">SELECT content FROM test1 WHERE id = <em class="replaceable"><code>константа</code></em>;</pre><p> Если система не будет заранее подготовлена, ей придётся сканировать всю таблицу <code class="structname">test1</code>, строку за строкой, чтобы найти все подходящие записи. Когда таблица <code class="structname">test1</code> содержит большое количество записей, а этот запрос должен вернуть всего несколько (возможно, одну или ноль), такое сканирование, очевидно, неэффективно. Но если создать в системе индекс по полю <code class="structfield">id</code>, она сможет находить строки гораздо быстрее. Возможно, для этого ей понадобится опуститься всего на несколько уровней в дереве поиска.</p><p>Подобный подход часто используется в технической литературе: термины и понятия, которые могут представлять интерес, собираются в алфавитном указателе в конце книги. Читатель может просмотреть этот указатель довольно быстро и затем перейти сразу к соответствующей странице, вместо того, чтобы пролистывать всю книгу в поисках нужного материала. Так же, как задача автора предугадать, что именно будут искать в книге читатели, задача программиста баз данных — заранее определить, какие индексы будут полезны.</p><p>Создать индекс для столбца <code class="structfield">id</code> рассмотренной ранее таблицы можно с помощью следующей команды: </p><pre class="programlisting">CREATE INDEX test1_id_index ON test1 (id);</pre><p> Имя индекса <code class="structname">test1_id_index</code> может быть произвольным, главное, чтобы оно позволяло понять, для чего этот индекс.</p><p>Для удаления индекса используется команда <code class="command">DROP INDEX</code>. Добавлять и удалять индексы можно в любое время.</p><p>Когда индекс создан, никакие дополнительные действия не требуются: система сама будет обновлять его при изменении данных в таблице и сама будет использовать его в запросах, где, по её мнению, это будет эффективнее, чем сканирование всей таблицы. Вам, возможно, придётся только периодически запускать команду <code class="command">ANALYZE</code> для обновления статистических данных, на основе которых планировщик запросов принимает решения. В <a class="xref" href="performance-tips.html" title="Глава 14. Оптимизация производительности">Главе 14</a> вы можете узнать, как определить, используется ли определённый индекс и при каких условиях планировщик может решить <span class="emphasis"><em>не</em></span> использовать его.</p><p>Индексы могут быть полезны также при выполнении команд <code class="command">UPDATE</code> и <code class="command">DELETE</code> с условиями поиска. Кроме того, они могут применяться в поиске с соединением. То есть, индекс, определённый для столбца, участвующего в условии соединения, может значительно ускорить запросы с JOIN.</p><p>В целом индексы <span class="productname">PostgreSQL</span> можно использовать для оптимизации запросов, содержащих одно или несколько предложений <code class="literal">WHERE</code> или <code class="literal">JOIN</code> в таком виде: </p><pre class="synopsis">
<em class="replaceable"><code>индексированный-столбец</code></em> <em class="replaceable"><code>индексируемый-оператор</code></em> <em class="replaceable"><code>значение-сравнения</code></em>
</pre><p> Здесь <em class="replaceable"><code>индексированный-столбец</code></em> — это любой столбец или выражение, для которого был определён индекс, <em class="replaceable"><code>индексируемый-оператор</code></em> — это оператор, который является членом <em class="firstterm">класса операторов</em> индекса для индексированного столбца (более подробную информацию об этом см. ниже), а <em class="replaceable"><code>значение-сравнения</code></em> может быть любым выражением, которое не является изменчивым и не ссылается на таблицу с этим индексом.</p><p>В некоторых случаях планировщик запросов может извлечь индексируемое предложение этого вида из другой конструкции SQL. Например, если исходное предложение выглядело так: </p><pre class="synopsis">
<em class="replaceable"><code>значение сравнения</code></em> <em class="replaceable"><code>оператор</code></em> <em class="replaceable"><code>индексированный столбец</code></em>
</pre><p>, то его можно преобразовать в индексируемую форму, если исходный <em class="replaceable"><code>оператор</code></em> имеет коммутирующий оператор, который является членом класса операторов индекса.</p><p>Создание индекса для большой таблицы может занимать много времени. По умолчанию <span class="productname">PostgreSQL</span> позволяет параллельно с созданием индекса выполнять чтение (операторы <code class="command">SELECT</code>) таблицы, но операции записи (<code class="command">INSERT</code>, <code class="command">UPDATE</code> и <code class="command">DELETE</code>) блокируются до окончания построения индекса. Для производственной среды это ограничение часто бывает неприемлемым. Хотя есть возможность разрешить запись параллельно с созданием индексов, при этом нужно учитывать ряд оговорок — они описаны в подразделе <a class="xref" href="sql-createindex.html#SQL-CREATEINDEX-CONCURRENTLY" title="Неблокирующее построение индексов">Неблокирующее построение индексов</a>.</p><p>После создания индекса система должна поддерживать его в состоянии, соответствующем данным таблицы. С этим связаны неизбежные накладные расходы при изменении данных. Наличие индексов также может препятствовать созданию <a class="link" href="storage-hot.html" title="73.7. Кортежи только в куче (Heap-Only Tuples, HOT)">кортежей только в куче</a>. Таким образом, индексы, которые используются в запросах редко или вообще никогда, должны быть удалены.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="indexes.html" title="Глава 11. Индексы">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="indexes.html" title="Глава 11. Индексы">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="indexes-types.html" title="11.2. Типы индексов">След.</a></td></tr><tr><td width="40%" align="left" valign="top">Глава 11. Индексы </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 11.2. Типы индексов</td></tr></table></div></body></html>