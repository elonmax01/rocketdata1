<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>43.7. Курсоры</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="plpgsql-control-structures.html" title="43.6. Управляющие структуры" /><link rel="next" href="plpgsql-transactions.html" title="43.8. Управление транзакциями" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">43.7. Курсоры</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="plpgsql-control-structures.html" title="43.6. Управляющие структуры">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="plpgsql.html" title="Глава 43. PL/pgSQL — процедурный язык SQL">Наверх</a></td><th width="60%" align="center">Глава 43. <span class="application">PL/pgSQL</span> — процедурный язык <acronym class="acronym">SQL</acronym></th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="plpgsql-transactions.html" title="43.8. Управление транзакциями">След.</a></td></tr></table><hr /></div><div class="sect1" id="PLPGSQL-CURSORS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">43.7. Курсоры <a href="#PLPGSQL-CURSORS" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="plpgsql-cursors.html#PLPGSQL-CURSOR-DECLARATIONS">43.7.1. Объявление курсорных переменных</a></span></dt><dt><span class="sect2"><a href="plpgsql-cursors.html#PLPGSQL-CURSOR-OPENING">43.7.2. Открытие курсора</a></span></dt><dt><span class="sect2"><a href="plpgsql-cursors.html#PLPGSQL-CURSOR-USING">43.7.3. Использование курсоров</a></span></dt><dt><span class="sect2"><a href="plpgsql-cursors.html#PLPGSQL-CURSOR-FOR-LOOP">43.7.4. Обработка курсора в цикле</a></span></dt></dl></div><a id="id-1.8.8.9.2" class="indexterm"></a><p>Вместо того чтобы сразу выполнять весь запрос, есть возможность настроить курсор, инкапсулирующий запрос, и затем получать результат запроса по нескольку строк за раз. Одна из причин так делать заключается в том, чтобы избежать переполнения памяти, когда результат содержит большое количество строк. (Пользователям <span class="application">PL/pgSQL</span> не нужно об этом беспокоиться, так как циклы <code class="literal">FOR</code> автоматически используют курсоры, чтобы избежать проблем с памятью.) Более интересным вариантом использования является возврат из функции ссылки на курсор, что позволяет вызывающему получать строки запроса. Это эффективный способ получать большие наборы строк из функций.</p><div class="sect2" id="PLPGSQL-CURSOR-DECLARATIONS"><div class="titlepage"><div><div><h3 class="title">43.7.1. Объявление курсорных переменных <a href="#PLPGSQL-CURSOR-DECLARATIONS" class="id_link">#</a></h3></div></div></div><p>Доступ к курсорам в <span class="application">PL/pgSQL</span> осуществляется через курсорные переменные, которые всегда имеют специальный тип данных <code class="type">refcursor</code>. Один из способов создать курсорную переменную, просто объявить её как переменную типа <code class="type">refcursor</code>. Другой способ заключается в использовании синтаксиса объявления курсора, который в общем виде выглядит так: </p><pre class="synopsis">
<em class="replaceable"><code>имя</code></em> [<span class="optional"> [<span class="optional"> NO </span>] SCROLL </span>] CURSOR [<span class="optional"> ( <em class="replaceable"><code>аргументы</code></em> ) </span>] FOR <em class="replaceable"><code>запрос</code></em>;
</pre><p> (Для совместимости с Oracle, <code class="literal">FOR</code> можно заменять на <code class="literal">IS</code>.) С указанием <code class="literal">SCROLL</code> курсор можно будет прокручивать назад. При <code class="literal">NO SCROLL</code> прокрутка назад не разрешается. Если ничего не указано, то возможность прокрутки назад зависит от запроса. Если указаны <em class="replaceable"><code>аргументы</code></em>, то они должны представлять собой пары <code class="literal"><em class="replaceable"><code>имя</code></em> <em class="replaceable"><code>тип_данных</code></em></code>, разделённые через запятую. Эти пары определяют имена, которые будут заменены значениями параметров в данном запросе. Фактические значения для замены этих имён появятся позже, при открытии курсора.</p><p>Примеры: </p><pre class="programlisting">DECLARE
    curs1 refcursor;
    curs2 CURSOR FOR SELECT * FROM tenk1;
    curs3 CURSOR (key integer) FOR SELECT * FROM tenk1 WHERE unique1 = key;</pre><p> Все три переменные имеют тип данных <code class="type">refcursor</code>. Первая может быть использована с любым запросом, вторая связана (<code class="literal">bound</code>) с полностью сформированным запросом, а последняя связана с параметризованным запросом. (<code class="literal">key</code> будет заменён целочисленным значением параметра при открытии курсора.) Про переменную <code class="literal">curs1</code> говорят, что она является несвязанной (<code class="literal">unbound</code>), так как к ней не привязан никакой запрос.</p><p>Реализация <code class="literal">SCROLL</code> рассчитывает на то, что в запросе курсора используется <code class="literal">FOR UPDATE/SHARE</code>. Кроме того, с запросом, включающим изменчивые функции, лучше всего использовать <code class="literal">NO SCROLL</code>. Реализация <code class="literal">SCROLL</code> предполагает, что повторное чтение вывода запроса даст согласованные результаты, чего нельзя гарантировать при использовании изменчивой функции.</p></div><div class="sect2" id="PLPGSQL-CURSOR-OPENING"><div class="titlepage"><div><div><h3 class="title">43.7.2. Открытие курсора <a href="#PLPGSQL-CURSOR-OPENING" class="id_link">#</a></h3></div></div></div><p>Прежде чем получать строки из курсора, его нужно открыть. (Это эквивалентно действию SQL-команды <a class="link" href="sql-declare.html" title="DECLARE"><code class="command">DECLARE CURSOR</code></a>.) В <span class="application">PL/pgSQL</span> есть три формы оператора <code class="command">OPEN</code>, две из которых используются для несвязанных курсорных переменных, а третья для связанных.</p><div class="note"><h3 class="title">Примечание</h3><p>Связанные курсорные переменные можно использовать с циклом <code class="command">FOR</code> без явного открытия курсора, как описано в <a class="xref" href="plpgsql-cursors.html#PLPGSQL-CURSOR-FOR-LOOP" title="43.7.4. Обработка курсора в цикле">Подразделе 43.7.4</a>. Цикл <code class="command">FOR</code> откроет курсор, а затем закроет его по завершении цикла.</p></div><a id="id-1.8.8.9.5.4" class="indexterm"></a><p>Открытие курсора подразумевает создание внутренней для сервера структуры данных под названием <em class="firstterm">портал</em>, который удерживает состояние выполнения для запроса курсора. У портала есть имя, которое должно быть уникальным в рамках сеанса на протяжении существования портала. По умолчанию <span class="application">PL/pgSQL</span> присваивает уникальное имя создаваемому им порталу. Однако если присвоить переменной курсора непустое строковое значение, в качестве имени портала будет использовано именно оно. Использование этой функциональности описано в <a class="xref" href="plpgsql-cursors.html#PLPGSQL-CURSOR-RETURNING" title="43.7.3.5. Возврат курсора из функции">Подразделе 43.7.3.5</a>.</p><div class="sect3" id="PLPGSQL-CURSOR-OPENING-OPEN-FOR-QUERY"><div class="titlepage"><div><div><h4 class="title">43.7.2.1. <code class="command">OPEN FOR</code> <em class="replaceable"><code>запрос</code></em> <a href="#PLPGSQL-CURSOR-OPENING-OPEN-FOR-QUERY" class="id_link">#</a></h4></div></div></div><pre class="synopsis">OPEN <em class="replaceable"><code>несвязанная_переменная_курсора</code></em> [<span class="optional">[<span class="optional">NO</span>] SCROLL</span>] FOR <em class="replaceable"><code>запрос</code></em>;</pre><p>Курсорная переменная открывается и получает конкретный запрос для выполнения. Курсор не может уже быть открытым, а курсорная переменная обязана быть несвязанной (то есть просто переменной типа <code class="type">refcursor</code>). Запрос должен быть командой <code class="command">SELECT</code> или любой другой, которая возвращает строки (к примеру <code class="command">EXPLAIN</code>). Запрос обрабатывается так же, как и другие команды SQL в <span class="application">PL/pgSQL</span>: имена переменных <span class="application">PL/pgSQL</span> заменяются на значения, план запроса кешируется для повторного использования. Подстановка значений переменных <span class="application">PL/pgSQL</span> проводится при открытии курсора командой <code class="command">OPEN</code>, последующие изменения значений переменных не влияют на работу курсора. <code class="literal">SCROLL</code> и <code class="literal">NO SCROLL</code> имеют тот же смысл, что и для связанного курсора.</p><p>Пример: </p><pre class="programlisting">OPEN curs1 FOR SELECT * FROM foo WHERE key = mykey;</pre></div><div class="sect3" id="PLPGSQL-CURSOR-OPENING-OPEN-FOR-EXECUTE"><div class="titlepage"><div><div><h4 class="title">43.7.2.2. <code class="command">OPEN FOR EXECUTE</code> <a href="#PLPGSQL-CURSOR-OPENING-OPEN-FOR-EXECUTE" class="id_link">#</a></h4></div></div></div><pre class="synopsis">OPEN <em class="replaceable"><code>несвязанная_переменная_курсора</code></em> [<span class="optional">[<span class="optional">NO</span>] SCROLL</span>] FOR EXECUTE <em class="replaceable"><code>строка_запроса</code></em>
                                     [<span class="optional">USING <em class="replaceable"><code>выражение</code></em> [<span class="optional">, ...</span>]</span>];</pre><p>Переменная курсора открывается и получает конкретный запрос для выполнения. Курсор не может быть уже открыт и он должен быть объявлен как несвязанная переменная курсора (то есть, как просто переменная <code class="type">refcursor</code>). Запрос задаётся строковым выражением, так же, как в команде <code class="command">EXECUTE</code>. Как обычно, это даёт возможность гибко менять план запроса от раза к разу (см. <a class="xref" href="plpgsql-implementation.html#PLPGSQL-PLAN-CACHING" title="43.11.2. Кеширование плана">Подраздел 43.11.2</a>). Это также означает, что замена переменных происходит не в самой строке команды. Как и с <code class="command">EXECUTE</code>, значения параметров вставляются в динамическую команду, используя <code class="literal">format()</code> и <code class="literal">USING</code>. Параметры <code class="literal">SCROLL</code> и <code class="literal">NO SCROLL</code> здесь действуют так же, как и со связанным курсором.</p><p>Пример: </p><pre class="programlisting">OPEN curs1 FOR EXECUTE format('SELECT * FROM %I WHERE col1 = $1',tabname) USING keyvalue;</pre><p> В этом примере в текст запроса вставляется имя таблицы с применением <code class="function">format()</code>. Значение, сравниваемое с <code class="literal">col1</code>, вставляется посредством параметра <code class="literal">USING</code>, так что заключать его в апострофы не нужно.</p></div><div class="sect3" id="PLPGSQL-OPEN-BOUND-CURSOR"><div class="titlepage"><div><div><h4 class="title">43.7.2.3. Открытие связанного курсора <a href="#PLPGSQL-OPEN-BOUND-CURSOR" class="id_link">#</a></h4></div></div></div><pre class="synopsis">OPEN <em class="replaceable"><code>связанная_переменная_курсора</code></em> [<span class="optional">( [<span class="optional"><em class="replaceable"><code>имя_аргумента</code></em> :=</span>] <em class="replaceable"><code>значение_аргумента</code></em> [<span class="optional">, ...</span>] )</span>];</pre><p>Эта форма <code class="command">OPEN</code> используется для открытия курсорной переменной, которая была связана с запросом при объявлении. Курсор не может уже быть открытым. Список фактических значений аргументов должен присутствовать только в том случае, если курсор объявлялся с параметрами. Эти значения будут подставлены в запрос.</p><p>План запроса для связанного курсора всегда считается кешируемым. В этом случае нет эквивалента <code class="command">EXECUTE</code>. Обратите внимание, что <code class="literal">SCROLL</code> и <code class="literal">NO SCROLL</code> не могут быть указаны в этой форме <code class="command">OPEN</code>, возможность прокрутки назад была определена при объявлении курсора.</p><p>При передаче значений аргументов можно использовать позиционную или именную нотацию. В позиционной нотации все аргументы указываются по порядку. В именной нотации имя каждого аргумента отделяется от выражения аргумента с помощью <code class="literal">:=</code>. Это подобно вызову функций, описанному в <a class="xref" href="sql-syntax-calling-funcs.html" title="4.3. Вызов функций">Разделе 4.3</a>. Также разрешается смешивать позиционную и именную нотации.</p><p>Примеры (здесь используются ранее объявленные курсоры): </p><pre class="programlisting">OPEN curs2;
OPEN curs3(42);
OPEN curs3(key := 42);</pre><p>Так как для связанного курсора выполняется подстановка значений переменных, то, на самом деле, существует два способа передать значения в курсор. Либо использовать явные аргументы в <code class="command">OPEN</code>, либо неявно, ссылаясь на переменные <span class="application">PL/pgSQL</span> в запросе. В связанном курсоре можно ссылаться только на те переменные, которые были объявлены до самого курсора. В любом случае значение переменной для подстановки в запрос будет определяться на момент выполнения <code class="command">OPEN</code>. Вот ещё один способ получить тот же результат с <code class="literal">curs3</code>, как в примере выше: </p><pre class="programlisting">DECLARE
    key integer;
    curs4 CURSOR FOR SELECT * FROM tenk1 WHERE unique1 = key;
BEGIN
    key := 42;
    OPEN curs4;</pre></div></div><div class="sect2" id="PLPGSQL-CURSOR-USING"><div class="titlepage"><div><div><h3 class="title">43.7.3. Использование курсоров <a href="#PLPGSQL-CURSOR-USING" class="id_link">#</a></h3></div></div></div><p>После того как курсор будет открыт, с ним можно работать при помощи описанных здесь операторов.</p><p>Работать с курсором необязательно в той же функции, где он был открыт. Из функции можно вернуть значение с типом <code class="type">refcursor</code>, что позволит вызывающему продолжить работу с курсором. (Внутри <code class="type">refcursor</code> представляет собой обычное строковое имя портала, содержащего активный запрос курсора. Это имя можно передавать, присваивать другим переменным с типом <code class="type">refcursor</code> и так далее, при этом портал не нарушается.)</p><p>Все порталы неявно закрываются в конце транзакции, поэтому значение <code class="type">refcursor</code> можно использовать для ссылки на открытый курсор только до конца транзакции.</p><div class="sect3" id="PLPGSQL-CURSOR-USING-FETCH"><div class="titlepage"><div><div><h4 class="title">43.7.3.1. <code class="literal">FETCH</code> <a href="#PLPGSQL-CURSOR-USING-FETCH" class="id_link">#</a></h4></div></div></div><pre class="synopsis">FETCH [<span class="optional"><em class="replaceable"><code>направление</code></em> { FROM | IN }</span>] <em class="replaceable"><code>курсор</code></em> INTO <em class="replaceable"><code>цель</code></em>;</pre><p><code class="command">FETCH</code> извлекает следующую строку из курсора в <em class="replaceable"><code>цель</code></em>. В качестве <em class="replaceable"><code>цели</code></em> может быть переменная-кортеж, переменная типа <code class="type">record</code> или разделённый запятыми список простых переменных, как и в <code class="command">SELECT INTO</code>. Если следующей строки нет, <em class="replaceable"><code>цели</code></em> присваивается NULL. Как и в <code class="command">SELECT INTO</code>, проверить, была ли получена запись, можно при помощи специальной переменной <code class="literal">FOUND</code>.</p><p>Здесь <em class="replaceable"><code>направление</code></em> может быть любым допустимым в SQL-команде <a class="xref" href="sql-fetch.html" title="FETCH"><span class="refentrytitle">FETCH</span></a> вариантом, кроме тех, что извлекают более одной строки. А именно: <code class="literal">NEXT</code>, <code class="literal">PRIOR</code>, <code class="literal">FIRST</code>, <code class="literal">LAST</code>, <code class="literal">ABSOLUTE</code> <em class="replaceable"><code>число</code></em>, <code class="literal">RELATIVE</code> <em class="replaceable"><code>число</code></em>, <code class="literal">FORWARD</code> или <code class="literal">BACKWARD</code>. Без указания <em class="replaceable"><code>направления</code></em> подразумевается вариант <code class="literal">NEXT</code>. Везде, где используется <em class="replaceable"><code>число</code></em>, оно может определяться любым целочисленным выражением (в отличие от SQL-команды <code class="command">FETCH</code>, допускающей только целочисленные константы). Значения <em class="replaceable"><code>направления</code></em>, которые требуют перемещения назад, приведут к ошибке, если курсор не был объявлен или открыт с указанием <code class="literal">SCROLL</code>.</p><p><em class="replaceable"><code>курсор</code></em> это переменная с типом <code class="type">refcursor</code>, которая ссылается на открытый портал курсора.</p><p>Примеры: </p><pre class="programlisting">FETCH curs1 INTO rowvar;
FETCH curs2 INTO foo, bar, baz;
FETCH LAST FROM curs3 INTO x, y;
FETCH RELATIVE -2 FROM curs4 INTO x;</pre></div><div class="sect3" id="PLPGSQL-CURSOR-USING-MOVE"><div class="titlepage"><div><div><h4 class="title">43.7.3.2. <code class="literal">MOVE</code> <a href="#PLPGSQL-CURSOR-USING-MOVE" class="id_link">#</a></h4></div></div></div><pre class="synopsis">MOVE [<span class="optional"><em class="replaceable"><code>направление</code></em> { FROM | IN }</span>] <em class="replaceable"><code>курсор</code></em>;</pre><p><code class="command">MOVE</code> перемещает курсор без извлечения данных. <code class="command">MOVE</code> работает точно так же как и <code class="command">FETCH</code>, но при этом только перемещает курсор и не извлекает строку, к которой переместился. Как и в <code class="command">SELECT INTO</code>, проверить успешность перемещения можно с помощью специальной переменной <code class="literal">FOUND</code>.</p><p>Примеры: </p><pre class="programlisting">MOVE curs1;
MOVE LAST FROM curs3;
MOVE RELATIVE -2 FROM curs4;
MOVE FORWARD 2 FROM curs4;</pre></div><div class="sect3" id="PLPGSQL-CURSOR-USING-UPDATE-DELETE"><div class="titlepage"><div><div><h4 class="title">43.7.3.3. <code class="literal">UPDATE/DELETE WHERE CURRENT OF</code> <a href="#PLPGSQL-CURSOR-USING-UPDATE-DELETE" class="id_link">#</a></h4></div></div></div><pre class="synopsis">UPDATE <em class="replaceable"><code>таблица</code></em> SET ... WHERE CURRENT OF <em class="replaceable"><code>курсор</code></em>;
DELETE FROM <em class="replaceable"><code>таблица</code></em> WHERE CURRENT OF <em class="replaceable"><code>курсор</code></em>;</pre><p>Когда курсор позиционирован на строку таблицы, эту строку можно изменить или удалить при помощи курсора. Есть ограничения на то, каким может быть запрос курсора (в частности, не должно быть группировок), и крайне желательно использовать указание <code class="literal">FOR UPDATE</code>. За дополнительными сведениями обратитесь к странице справки <a class="xref" href="sql-declare.html" title="DECLARE"><span class="refentrytitle">DECLARE</span></a>.</p><p>Пример: </p><pre class="programlisting">UPDATE foo SET dataval = myval WHERE CURRENT OF curs1;</pre></div><div class="sect3" id="PLPGSQL-CURSOR-USING-CLOSE"><div class="titlepage"><div><div><h4 class="title">43.7.3.4. <code class="literal">CLOSE</code> <a href="#PLPGSQL-CURSOR-USING-CLOSE" class="id_link">#</a></h4></div></div></div><pre class="synopsis">CLOSE <em class="replaceable"><code>курсор</code></em>;</pre><p><code class="command">CLOSE</code> закрывает связанный с курсором портал. Используется для того, чтобы освободить ресурсы раньше, чем закончится транзакция, или чтобы освободить курсорную переменную для повторного открытия.</p><p>Пример: </p><pre class="programlisting">CLOSE curs1;</pre></div><div class="sect3" id="PLPGSQL-CURSOR-RETURNING"><div class="titlepage"><div><div><h4 class="title">43.7.3.5. Возврат курсора из функции <a href="#PLPGSQL-CURSOR-RETURNING" class="id_link">#</a></h4></div></div></div><p>Курсоры можно возвращать из функции на <span class="application">PL/pgSQL</span>. Это полезно, когда нужно вернуть множество строк и столбцов, особенно если выборки очень большие. Для этого, в функции открывается курсор и его имя возвращается вызывающему (или просто открывается курсор, используя указанное имя портала, каким-либо образом известное вызывающему). Вызывающий затем может извлекать строки из курсора. Курсор может быть закрыт вызывающим или он будет автоматически закрыт при завершении транзакции.</p><p>Имя портала, используемое для курсора, может быть указано разработчиком или будет генерироваться автоматически. Чтобы указать имя портала, нужно просто присвоить строку в переменную <code class="type">refcursor</code> перед его открытием. Значение строки переменной <code class="type">refcursor</code> будет использоваться командой <code class="command">OPEN</code> как имя портала. Однако если переменная <code class="type">refcursor</code> имеет значение NULL (как и установлено по умолчанию), <code class="command">OPEN</code> автоматически генерирует имя, которое не конфликтует с любым существующим порталом, и присваивает его переменной <code class="type">refcursor</code>.</p><div class="note"><h3 class="title">Примечание</h3><p>В версиях <span class="productname">PostgreSQL</span> ниже 16 связанные курсорные переменные инициализировались в значения, содержащие собственные имена, а не в NULL, поэтому имя портала совпадало с именем курсорной переменной, заданным по умолчанию. Поведение изменилось во избежание конфликтов между курсорами с одинаковыми именами в разных функциях.</p></div><p>Следующий пример показывает один из способов передачи имени курсора вызывающему: </p><pre class="programlisting">CREATE TABLE test (col text);
INSERT INTO test VALUES ('123');

CREATE FUNCTION reffunc(refcursor) RETURNS refcursor AS '
BEGIN
    OPEN $1 FOR SELECT col FROM test;
    RETURN $1;
END;
' LANGUAGE plpgsql;

BEGIN;
SELECT reffunc('funccursor');
FETCH ALL IN funccursor;
COMMIT;</pre><p>В следующем примере используется автоматическая генерация имени курсора: </p><pre class="programlisting">CREATE FUNCTION reffunc2() RETURNS refcursor AS '
DECLARE
    ref refcursor;
BEGIN
    OPEN ref FOR SELECT col FROM test;
    RETURN ref;
END;
' LANGUAGE plpgsql;

-- для использования курсоров, необходимо начать транзакцию
BEGIN;
SELECT reffunc2();

      reffunc2
--------------------
 &lt;unnamed cursor 1&gt;
(1 row)

FETCH ALL IN "&lt;unnamed cursor 1&gt;";
COMMIT;</pre><p>В следующем примере показан один из способов вернуть несколько курсоров из одной функции: </p><pre class="programlisting">CREATE FUNCTION myfunc(refcursor, refcursor) RETURNS SETOF refcursor AS $$
BEGIN
    OPEN $1 FOR SELECT * FROM table_1;
    RETURN NEXT $1;
    OPEN $2 FOR SELECT * FROM table_2;
    RETURN NEXT $2;
END;
$$ LANGUAGE plpgsql;

-- для использования курсоров необходимо начать транзакцию
BEGIN;

SELECT * FROM myfunc('a', 'b');

FETCH ALL FROM a;
FETCH ALL FROM b;
COMMIT;</pre></div></div><div class="sect2" id="PLPGSQL-CURSOR-FOR-LOOP"><div class="titlepage"><div><div><h3 class="title">43.7.4. Обработка курсора в цикле <a href="#PLPGSQL-CURSOR-FOR-LOOP" class="id_link">#</a></h3></div></div></div><p>Один из вариантов цикла <code class="command">FOR</code> позволяет перебирать строки, возвращённые курсором. Вот его синтаксис: </p><pre class="synopsis">
[<span class="optional"> &lt;&lt;<em class="replaceable"><code>метка</code></em>&gt;&gt; </span>]
FOR <em class="replaceable"><code>переменная-запись</code></em> IN <em class="replaceable"><code>связанная_переменная_курсора</code></em> [<span class="optional"> ( [<span class="optional"> <em class="replaceable"><code>имя_аргумента</code></em> := </span>] <em class="replaceable"><code>значение_аргумента</code></em> [<span class="optional">, ...</span>] ) </span>] LOOP
    <em class="replaceable"><code>операторы</code></em>
END LOOP [<span class="optional"> <em class="replaceable"><code>метка</code></em> </span>];
</pre><p> Курсорная переменная должна быть связана с запросом при объявлении. Курсор <span class="emphasis"><em>не может</em></span> быть открытым. Команда <code class="command">FOR</code> автоматически открывает курсор и автоматически закрывает при завершении цикла. Список фактических значений аргументов должен присутствовать только в том случае, если курсор объявлялся с параметрами. Эти значения будут подставлены в запрос, как и при выполнении <code class="command">OPEN</code> (см. <a class="xref" href="plpgsql-cursors.html#PLPGSQL-OPEN-BOUND-CURSOR" title="43.7.2.3. Открытие связанного курсора">Подраздел 43.7.2.3</a>).</p><p>Данная <em class="replaceable"><code>переменная-запись</code></em> автоматически определяется как переменная типа <code class="type">record</code> и существует только внутри цикла (другие объявленные переменные с таким именем игнорируется в цикле). Каждая возвращаемая курсором строка последовательно присваивается этой переменной и выполняется тело цикла.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="plpgsql-control-structures.html" title="43.6. Управляющие структуры">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="plpgsql.html" title="Глава 43. PL/pgSQL — процедурный язык SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="plpgsql-transactions.html" title="43.8. Управление транзакциями">След.</a></td></tr><tr><td width="40%" align="left" valign="top">43.6. Управляющие структуры </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 43.8. Управление транзакциями</td></tr></table></div></body></html>