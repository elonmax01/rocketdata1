<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>12.6. Словари</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="textsearch-parsers.html" title="12.5. Анализаторы" /><link rel="next" href="textsearch-configuration.html" title="12.7. Пример конфигурации" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">12.6. Словари</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="textsearch-parsers.html" title="12.5. Анализаторы">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="textsearch.html" title="Глава 12. Полнотекстовый поиск">Наверх</a></td><th width="60%" align="center">Глава 12. Полнотекстовый поиск</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="textsearch-configuration.html" title="12.7. Пример конфигурации">След.</a></td></tr></table><hr /></div><div class="sect1" id="TEXTSEARCH-DICTIONARIES"><div class="titlepage"><div><div><h2 class="title" style="clear: both">12.6. Словари <a href="#TEXTSEARCH-DICTIONARIES" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="textsearch-dictionaries.html#TEXTSEARCH-STOPWORDS">12.6.1. Стоп-слова</a></span></dt><dt><span class="sect2"><a href="textsearch-dictionaries.html#TEXTSEARCH-SIMPLE-DICTIONARY">12.6.2. Простой словарь</a></span></dt><dt><span class="sect2"><a href="textsearch-dictionaries.html#TEXTSEARCH-SYNONYM-DICTIONARY">12.6.3. Словарь синонимов</a></span></dt><dt><span class="sect2"><a href="textsearch-dictionaries.html#TEXTSEARCH-THESAURUS">12.6.4. Тезаурус</a></span></dt><dt><span class="sect2"><a href="textsearch-dictionaries.html#TEXTSEARCH-ISPELL-DICTIONARY">12.6.5. Словарь <span class="application">Ispell</span></a></span></dt><dt><span class="sect2"><a href="textsearch-dictionaries.html#TEXTSEARCH-SNOWBALL-DICTIONARY">12.6.6. Словарь <span class="application">Snowball</span></a></span></dt></dl></div><p>Словари полнотекстового поиска предназначены для исключения <em class="firstterm">стоп-слов</em> (слов, которые не должны учитываться при поиске) и <em class="firstterm">нормализации</em> слов, чтобы разные словоформы считались совпадающими. Успешно нормализованное слово называется <em class="firstterm">лексемой</em>. Нормализация и исключение стоп-слов не только улучшает качество поиска, но и уменьшает размер представления документа в формате <code class="type">tsvector</code>, и, как следствие, увеличивает быстродействие. Нормализация не всегда имеет лингвистический смысл, обычно она зависит от требований приложения.</p><p>Несколько примеров нормализации: </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p>Лингвистическая нормализация — словари Ispell пытаются свести слова на входе к нормализованной форме, а стеммеры убирают окончания слов</p></li><li class="listitem" style="list-style-type: disc"><p>Адреса <acronym class="acronym">URL</acronym> могут быть канонизированы, чтобы например следующие адреса считались одинаковыми: </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p>http://www.pgsql.ru/db/mw/index.html</p></li><li class="listitem" style="list-style-type: disc"><p>http://www.pgsql.ru/db/mw/</p></li><li class="listitem" style="list-style-type: disc"><p>http://www.pgsql.ru/db/../db/mw/index.html</p></li></ul></div></li><li class="listitem" style="list-style-type: disc"><p>Названия цветов могут быть заменены их шестнадцатеричными значениями, например <code class="literal">red, green, blue, magenta -&gt; FF0000, 00FF00, 0000FF, FF00FF</code></p></li><li class="listitem" style="list-style-type: disc"><p>При индексировании чисел можно отбросить цифры в дробной части для сокращения множества всевозможных чисел, чтобы например <span class="emphasis"><em>3.14</em></span>159265359, <span class="emphasis"><em>3.14</em></span>15926 и <span class="emphasis"><em>3.14</em></span> стали одинаковыми после нормализации, при которой после точки останутся только две цифры.</p></li></ul></div><p>Словарь — это программа, которая принимает на вход фрагмент и возвращает: </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p>массив лексем, если входной фрагмент известен в словаре (заметьте, один фрагмент может породить несколько лексем)</p></li><li class="listitem" style="list-style-type: disc"><p>одну лексему с установленным флагом <code class="literal">TSL_FILTER</code> для замены исходного фрагмента новым, чтобы следующие словари работали с новым вариантом (словарь, который делает это, называется <em class="firstterm">фильтрующим словарём</em>)</p></li><li class="listitem" style="list-style-type: disc"><p>пустой массив, если словарь воспринимает этот фрагмент, но считает его стоп-словом</p></li><li class="listitem" style="list-style-type: disc"><p><code class="literal">NULL</code>, если словарь не воспринимает полученный фрагмент</p></li></ul></div><p>В <span class="productname">PostgreSQL</span> встроены стандартные словари для многих языков. Есть также несколько предопределённых шаблонов, на основании которых можно создавать новые словари с изменёнными параметрами. Все эти шаблоны описаны ниже. Если же ни один из них не подходит, можно создать и свои собственные шаблоны. Соответствующие примеры можно найти в каталоге <code class="filename">contrib/</code> инсталляции <span class="productname">PostgreSQL</span>.</p><p>Конфигурация текстового поиска связывает анализатор с набором словарей, которые будут обрабатывать выделенные им фрагменты. Для каждого типа фрагментов, выданных анализатором, в конфигурации задаётся отдельный список словарей. Найденный анализатором фрагмент проходит через все словари по порядку, пока какой-либо словарь не увидит в нём знакомое для него слово. Если он окажется стоп-словом или его не распознает ни один словарь, этот фрагмент не будет учитываться при индексации и поиске. Обычно результат определяет первый же словарь, который возвращает не <code class="literal">NULL</code>, и остальные словари уже не проверяются; однако фильтрующий словарь может заменить полученное слово другим, которое и будет передано следующим словарям.</p><p>Общее правило настройки списка словарей заключается в том, чтобы поставить наиболее частные и специфические словари в начале, затем перечислить более общие и закончить самым общим словарём, например стеммером <span class="application">Snowball</span> или словарём <code class="literal">simple</code>, который распознаёт всё. Например, для поиска по теме астрономии (конфигурация <code class="literal">astro_en</code>) тип фрагментов <code class="type">asciiword</code> (слово из букв ASCII) можно связать со словарём синонимов астрономических терминов, затем с обычным английским словарём и наконец со стеммером английских окончаний <span class="application">Snowball</span>: </p><pre class="programlisting">ALTER TEXT SEARCH CONFIGURATION astro_en
    ADD MAPPING FOR asciiword WITH astrosyn, english_ispell, english_stem;</pre><p>Фильтрующий словарь можно включить в любом месте списка, кроме конца, где он будет бесполезен. Фильтрующие словари бывают полезны для частичной нормализации слов и упрощения задачи следующих словарей. Например, фильтрующий словарь может удалить из текста диакритические знаки, как это делает модуль <a class="xref" href="unaccent.html" title="F.48. unaccent — словарь текстового поиска, который убирает диакритические знаки">unaccent</a>.</p><div class="sect2" id="TEXTSEARCH-STOPWORDS"><div class="titlepage"><div><div><h3 class="title">12.6.1. Стоп-слова <a href="#TEXTSEARCH-STOPWORDS" class="id_link">#</a></h3></div></div></div><p>Стоп-словами называются слова, которые встречаются очень часто, практически в каждом документе, и поэтому не имеют различительной ценности. Таким образом, при полнотекстовом поиске их можно игнорировать. Например, в каждом английском тексте содержатся артикли <code class="literal">a</code> и <code class="literal">the</code>, так что хранить их в индексе бессмысленно. Однако стоп-слова влияют на позиции лексем в значении <code class="type">tsvector</code>, от чего, в свою очередь, зависит ранжирование: </p><pre class="screen">
SELECT to_tsvector('english', 'in the list of stop words');
        to_tsvector
----------------------------
 'list':3 'stop':5 'word':6
</pre><p> В результате отсутствуют позиции 1,2,4, потому что фрагменты в этих позициях оказались стоп-словами. Ранги, вычисленные для документов со стоп-словами и без них, могут значительно различаться: </p><pre class="screen">
SELECT ts_rank_cd (to_tsvector('english', 'in the list of stop words'),
  to_tsquery('list &amp; stop'));
 ts_rank_cd
------------
       0.05

SELECT ts_rank_cd (to_tsvector('english', 'list stop words'),
  to_tsquery('list &amp; stop'));
 ts_rank_cd
------------
        0.1
</pre><p>Как именно обрабатывать стоп-слова, определяет сам словарь. Например, словари <code class="literal">ispell</code> сначала нормализуют слова, а затем просматривают список стоп-слов, тогда как стеммеры <code class="literal">Snowball</code> просматривают свой список стоп-слов в первую очередь. Это различие в поведении объясняется стремлением уменьшить шум.</p></div><div class="sect2" id="TEXTSEARCH-SIMPLE-DICTIONARY"><div class="titlepage"><div><div><h3 class="title">12.6.2. Простой словарь <a href="#TEXTSEARCH-SIMPLE-DICTIONARY" class="id_link">#</a></h3></div></div></div><p>Работа шаблона словарей <code class="literal">simple</code> сводится к преобразованию входного фрагмента в нижний регистр и проверки результата по файлу со списком стоп-слов. Если это слово находится в файле, словарь возвращает пустой массив и фрагмент исключается из дальнейшего рассмотрения. В противном случае словарь возвращает в качестве нормализованной лексемы слово в нижнем регистре. Этот словарь можно настроить и так, чтобы все слова, кроме стоп-слов, считались неопознанными и передавались следующему словарю в списке.</p><p>Определить словарь на основе шаблона <code class="literal">simple</code> можно так: </p><pre class="programlisting">CREATE TEXT SEARCH DICTIONARY public.simple_dict (
    TEMPLATE = pg_catalog.simple,
    STOPWORDS = english
);</pre><p> Здесь <code class="literal">english</code> — базовое имя файла со стоп-словами. Полным именем файла будет <code class="filename">$SHAREDIR/tsearch_data/english.stop</code>, где <code class="literal">$SHAREDIR</code> указывает на каталог с общими данными <span class="productname">PostgreSQL</span>, часто это <code class="filename">/usr/local/share/postgresql</code> (точно узнать его можно с помощью команды <code class="command">pg_config --sharedir</code>). Этот текстовый файл должен содержать просто список слов, по одному слову в строке. Пустые строки и окружающие пробелы игнорируются, все символы переводятся в нижний регистр и на этом обработка файла заканчивается.</p><p>Теперь мы можем проверить наш словарь: </p><pre class="screen">
SELECT ts_lexize('public.simple_dict', 'YeS');
 ts_lexize
-----------
 {yes}

SELECT ts_lexize('public.simple_dict', 'The');
 ts_lexize
-----------
 {}
</pre><p>Мы также можем настроить словарь так, чтобы он возвращал <code class="literal">NULL</code> вместо слова в нижнем регистре, если оно не находится в файле стоп-слов. Для этого нужно присвоить параметру <code class="literal">Accept</code> значение <code class="literal">false</code>. Продолжая наш пример: </p><pre class="screen">
ALTER TEXT SEARCH DICTIONARY public.simple_dict ( Accept = false );

SELECT ts_lexize('public.simple_dict', 'YeS');
 ts_lexize
-----------


SELECT ts_lexize('public.simple_dict', 'The');
 ts_lexize
-----------
 {}
</pre><p>Со значением <code class="literal">Accept</code> = <code class="literal">true</code> (по умолчанию) словарь <code class="literal">simple</code> имеет смысл включать только в конце списка словарей, так как он никогда не передаст фрагмент следующему словарю. И напротив, <code class="literal">Accept</code> = <code class="literal">false</code> имеет смысл, только если за ним следует ещё минимум один словарь.</p><div class="caution"><h3 class="title">Внимание</h3><p>Большинство словарей работают с дополнительными файлами, например, файлами стоп-слов. Содержимое этих файлов <span class="emphasis"><em>должно</em></span> иметь кодировку UTF-8. Если база данных работает в другой кодировке, они будут переведены в неё, когда сервер будет загружать их.</p></div><div class="caution"><h3 class="title">Внимание</h3><p>Обычно в рамках одного сеанса дополнительный файл словаря загружается только один раз, при первом использовании. Если же вы измените его и захотите, чтобы существующие сеансы работали с новым содержимым, выполните для этого словаря команду <code class="command">ALTER TEXT SEARCH DICTIONARY</code>. Это обновление словаря может быть <span class="quote">«<span class="quote">фиктивным</span>»</span>, фактически не меняющим значения никаких параметров.</p></div></div><div class="sect2" id="TEXTSEARCH-SYNONYM-DICTIONARY"><div class="titlepage"><div><div><h3 class="title">12.6.3. Словарь синонимов <a href="#TEXTSEARCH-SYNONYM-DICTIONARY" class="id_link">#</a></h3></div></div></div><p>Этот шаблон словарей используется для создания словарей, заменяющих слова синонимами. Словосочетания такие словари не поддерживают (используйте для этого тезаурус (<a class="xref" href="textsearch-dictionaries.html#TEXTSEARCH-THESAURUS" title="12.6.4. Тезаурус">Подраздел 12.6.4</a>)). Словарь синонимов может помочь в преодолении лингвистических проблем, например, не дать стеммеру английского уменьшить слово <span class="quote">«<span class="quote">Paris</span>»</span> до <span class="quote">«<span class="quote">pari</span>»</span>. Для этого достаточно поместить в словарь синонимов строку <code class="literal">Paris paris</code> и поставить этот словарь перед словарём <code class="literal">english_stem</code>. Например: </p><pre class="screen">
SELECT * FROM ts_debug('english', 'Paris');
   alias   |   description   | token |  dictionaries  |  dictionary  | lexemes
-----------+-----------------+-------+----------------+--------------+---------
 asciiword | Word, all ASCII | Paris | {english_stem} | english_stem | {pari}

CREATE TEXT SEARCH DICTIONARY my_synonym (
    TEMPLATE = synonym,
    SYNONYMS = my_synonyms
);

ALTER TEXT SEARCH CONFIGURATION english
    ALTER MAPPING FOR asciiword
    WITH my_synonym, english_stem;

SELECT * FROM ts_debug('english', 'Paris');
   alias   |   description   | token |       dictionaries        | dictionary | lexemes
-----------+-----------------+-------+---------------------------+------------+---------
 asciiword | Word, all ASCII | Paris | {my_synonym,english_stem} | my_synonym | {paris}
</pre><p>Шаблон <code class="literal">synonym</code> принимает единственный параметр, <code class="literal">SYNONYMS</code>, в котором задаётся базовое имя его файла конфигурации — в данном примере это <code class="literal">my_synonyms</code>. Полным именем файла будет <code class="filename">$SHAREDIR/tsearch_data/my_synonyms.syn</code> (где <code class="literal">$SHAREDIR</code> указывает на каталог общих данных <span class="productname">PostgreSQL</span>). Содержимое этого файла должны составлять строки с двумя словами в каждой (первое — заменяемое слово, а второе — его синоним), разделёнными пробелами. Пустые строки и окружающие пробелы при разборе этого файла игнорируются.</p><p>Шаблон <code class="literal">synonym</code> также принимает необязательный параметр <code class="literal">CaseSensitive</code>, который по умолчанию имеет значение <code class="literal">false</code>. Когда <code class="literal">CaseSensitive</code> равен <code class="literal">false</code>, слова в файле синонимов переводятся в нижний регистр, вместе с проверяемыми фрагментами. Если же он не равен <code class="literal">true</code>, регистр слов в файле и проверяемых фрагментов не меняются, они сравниваются «как есть».</p><p>В конце синонима в этом файле можно добавить звёздочку (<code class="literal">*</code>), тогда этот синоним будет рассматриваться как префикс. Эта звёздочка будет игнорироваться в <code class="function">to_tsvector()</code>, но <code class="function">to_tsquery()</code> изменит результат, добавив в него маркер сопоставления префикса (см. <a class="xref" href="textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES" title="12.3.2. Разбор запросов">Подраздел 12.3.2</a>). Например, предположим, что файл <code class="filename">$SHAREDIR/tsearch_data/synonym_sample.syn</code> имеет следующее содержание: </p><pre class="programlisting">postgres        pgsql
postgresql      pgsql
postgre pgsql
gogle   googl
indices index*</pre><p> С ним мы получим такие результаты: </p><pre class="screen">
mydb=# CREATE TEXT SEARCH DICTIONARY syn (template=synonym, synonyms='synonym_sample');
mydb=# SELECT ts_lexize('syn', 'indices');
 ts_lexize
-----------
 {index}
(1 row)

mydb=# CREATE TEXT SEARCH CONFIGURATION tst (copy=simple);
mydb=# ALTER TEXT SEARCH CONFIGURATION tst ALTER MAPPING FOR asciiword WITH syn;
mydb=# SELECT to_tsvector('tst', 'indices');
 to_tsvector
-------------
 'index':1
(1 row)

mydb=# SELECT to_tsquery('tst', 'indices');
 to_tsquery
------------
 'index':*
(1 row)

mydb=# SELECT 'indexes are very useful'::tsvector;
            tsvector
---------------------------------
 'are' 'indexes' 'useful' 'very'
(1 row)

mydb=# SELECT 'indexes are very useful'::tsvector @@ to_tsquery('tst', 'indices');
 ?column?
----------
 t
(1 row)
</pre></div><div class="sect2" id="TEXTSEARCH-THESAURUS"><div class="titlepage"><div><div><h3 class="title">12.6.4. Тезаурус <a href="#TEXTSEARCH-THESAURUS" class="id_link">#</a></h3></div></div></div><p>Тезаурус (или сокращённо <acronym class="acronym">TZ</acronym>) содержит набор слов и информацию о связях слов и словосочетаний, то есть более широкие понятия (Broader Terms, <acronym class="acronym">BT</acronym>), более узкие понятия (Narrow Terms, <acronym class="acronym">NT</acronym>), предпочитаемые названия, исключаемые названия, связанные понятия и т. д.</p><p>В основном тезаурус заменяет исключаемые слова и словосочетания предпочитаемыми и может также сохранить исходные слова для индексации. Текущая реализация тезауруса в <span class="productname">PostgreSQL</span> представляет собой расширение словаря синонимов с поддержкой <em class="firstterm">фраз</em>. Конфигурация тезауруса определяется файлом следующего формата: </p><pre class="programlisting"># это комментарий
образец слов(а) : индексируемые слова
другой образец слов(а) : другие индексируемые слова
...</pre><p> Здесь двоеточие (<code class="symbol">:</code>) служит разделителем между исходной фразой и её заменой.</p><p>Прежде чем проверять соответствие фраз, тезаурус нормализует файл конфигурации, используя <em class="firstterm">внутренний словарь</em> (который указывается в конфигурации словаря-тезауруса). Этот внутренний словарь для тезауруса может быть только одним. Если он не сможет распознать какое-либо слово, произойдёт ошибка. В этом случае необходимо либо исключить это слово, либо добавить его во внутренний словарь. Также можно добавить звёздочку (<code class="symbol">*</code>) перед индексируемыми словами, чтобы они не проверялись по внутреннему словарю, но все слова-образцы <span class="emphasis"><em>должны</em></span> быть известны внутреннему словарю.</p><p>Если входному фрагменту соответствуют несколько фраз в этом списке, тезаурус выберет самое длинное определение, а если таких окажется несколько, самое последнее из них.</p><p>Выделить во фразе какие-то стоп-слова нельзя; вместо этого можно вставить <code class="literal">?</code> в том месте, где может оказаться стоп-слово. Например, в предположении, что <code class="literal">a</code> и <code class="literal">the</code> — стоп-слова по внутреннему словарю: </p><pre class="programlisting">? one ? two : swsw</pre><p> соответствует входным строкам <code class="literal">a one the two</code> и <code class="literal">the one a two</code>, так что обе эти строки будут заменены на <code class="literal">swsw</code>.</p><p>Как и обычный словарь, тезаурус должен привязываться к лексемам определённых типов. Так как тезаурус может распознавать фразы, он должен запоминать своё состояние и взаимодействовать с анализатором. Учитывая свои привязки, он может либо обрабатывать следующий фрагмент, либо прекратить накопление фразы. Поэтому настройка тезаурусов в системе требует особого внимания. Например, если привязать тезаурус только к типу фрагментов <code class="literal">asciiword</code>, тогда определение в тезаурусе <code class="literal">one 7</code> не будет работать, так как этот тезаурус не связан с типом <code class="literal">uint</code>.</p><div class="caution"><h3 class="title">Внимание</h3><p>Тезаурусы используются при индексации, поэтому при любом изменении параметров или содержимого тезауруса <span class="emphasis"><em>необходима</em></span> переиндексация. Для большинства других типов словарей при небольших изменениях, таких как удаление и добавление стоп-слов, переиндексация не требуется.</p></div><div class="sect3" id="TEXTSEARCH-THESAURUS-CONFIG"><div class="titlepage"><div><div><h4 class="title">12.6.4.1. Конфигурация тезауруса <a href="#TEXTSEARCH-THESAURUS-CONFIG" class="id_link">#</a></h4></div></div></div><p>Для создания нового словаря-тезауруса используется шаблон <code class="literal">thesaurus</code>. Например: </p><pre class="programlisting">CREATE TEXT SEARCH DICTIONARY thesaurus_simple (
    TEMPLATE = thesaurus,
    DictFile = mythesaurus,
    Dictionary = pg_catalog.english_stem
);</pre><p> Здесь: </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p><code class="literal">thesaurus_simple</code> — имя нового словаря</p></li><li class="listitem" style="list-style-type: disc"><p><code class="literal">mythesaurus</code> — базовое имя файла конфигурации тезауруса. (Полным путём к файлу будет <code class="filename">$SHAREDIR/tsearch_data/mythesaurus.ths</code>, где <code class="literal">$SHAREDIR</code> указывает на каталог общих данных <span class="productname">PostgreSQL</span>.)</p></li><li class="listitem" style="list-style-type: disc"><p><code class="literal">pg_catalog.english_stem</code> — внутренний словарь (в данном случае это стеммер Snowball для английского) для нормализации тезауруса. Заметьте, что внутренний словарь имеет собственную конфигурацию (например, список стоп-слов), но здесь она не рассматривается.</p></li></ul></div><p> Теперь тезаурус <code class="literal">thesaurus_simple</code> можно связать с желаемыми типами фрагментов в конфигурации, например так: </p><pre class="programlisting">ALTER TEXT SEARCH CONFIGURATION english
    ALTER MAPPING FOR asciiword, asciihword, hword_asciipart
    WITH thesaurus_simple;</pre></div><div class="sect3" id="TEXTSEARCH-THESAURUS-EXAMPLES"><div class="titlepage"><div><div><h4 class="title">12.6.4.2. Пример тезауруса <a href="#TEXTSEARCH-THESAURUS-EXAMPLES" class="id_link">#</a></h4></div></div></div><p>Давайте рассмотрим простой астрономический тезаурус <code class="literal">thesaurus_astro</code>, содержащий несколько астрономических терминов: </p><pre class="programlisting">supernovae stars : sn
crab nebulae : crab</pre><p> Ниже мы создадим словарь и привяжем некоторые типы фрагментов к астрономическому тезаурусу и английскому стеммеру: </p><pre class="programlisting">CREATE TEXT SEARCH DICTIONARY thesaurus_astro (
    TEMPLATE = thesaurus,
    DictFile = thesaurus_astro,
    Dictionary = english_stem
);

ALTER TEXT SEARCH CONFIGURATION russian
    ALTER MAPPING FOR asciiword, asciihword, hword_asciipart
    WITH thesaurus_astro, english_stem;</pre><p> Теперь можно проверить, как он работает. Функция <code class="function">ts_lexize</code> не очень полезна для проверки тезауруса, так как она обрабатывает входную строку как один фрагмент. Вместо неё мы можем использовать функции <code class="function">plainto_tsquery</code> и <code class="function">to_tsvector</code>, которые разбивают входную строку на несколько фрагментов: </p><pre class="screen">
SELECT plainto_tsquery('supernova star');
 plainto_tsquery
-----------------
 'sn'

SELECT to_tsvector('supernova star');
 to_tsvector
-------------
 'sn':1
</pre><p> В принципе так же можно использовать <code class="function">to_tsquery</code>, если заключить аргумент в кавычки: </p><pre class="screen">
SELECT to_tsquery(' ''supernova star''');
 to_tsquery
------------
 'sn'
</pre><p> Заметьте, что <code class="literal">supernova star</code> совпадает с <code class="literal">supernovae stars</code> в <code class="literal">thesaurus_astro</code>, так как мы подключили стеммер <code class="literal">english_stem</code> в определении тезауруса. Этот стеммер удалил конечные буквы <code class="literal">e</code> и <code class="literal">s</code>.</p><p>Чтобы проиндексировать исходную фразу вместе с заменой, её нужно просто добавить в правую часть соответствующего определения: </p><pre class="screen">
supernovae stars : sn supernovae stars

SELECT plainto_tsquery('supernova star');
       plainto_tsquery
-----------------------------
 'sn' &amp; 'supernova' &amp; 'star'
</pre></div></div><div class="sect2" id="TEXTSEARCH-ISPELL-DICTIONARY"><div class="titlepage"><div><div><h3 class="title">12.6.5. Словарь <span class="application">Ispell</span> <a href="#TEXTSEARCH-ISPELL-DICTIONARY" class="id_link">#</a></h3></div></div></div><p>Шаблон словарей <span class="application">Ispell</span> поддерживает <em class="firstterm">морфологические словари</em>, которые могут сводить множество разных лингвистических форм слова к одной лексеме. Например, английский словарь <span class="application">Ispell</span> может связать вместе все склонения и спряжения ключевого слова <code class="literal">bank</code>: <code class="literal">banking</code>, <code class="literal">banked</code>, <code class="literal">banks</code>, <code class="literal">banks'</code>,<code class="literal">bank's</code> и т. п.</p><p>Стандартный дистрибутив <span class="productname">PostgreSQL</span> не включает файлы конфигурации <span class="application">Ispell</span>. Загрузить словари для множества языков можно со страницы <a class="ulink" href="https://www.cs.hmc.edu/~geoff/ispell.html" target="_top">Ispell</a>. Кроме того, поддерживаются и другие современные форматы словарей: <a class="ulink" href="https://en.wikipedia.org/wiki/MySpell" target="_top">MySpell</a> (OO &lt; 2.0.1) и <a class="ulink" href="https://hunspell.github.io/" target="_top">Hunspell</a> (OO &gt;= 2.0.2). Большой набор соответствующих словарей можно найти на странице <a class="ulink" href="https://wiki.openoffice.org/wiki/Dictionaries" target="_top">OpenOffice Wiki</a>.</p><p>Чтобы создать словарь <span class="application">Ispell</span>, выполните следующие действия:</p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p>загрузите файлы конфигурации словаря. Пакет с дополнительным словарём <span class="productname">OpenOffice</span> имеет расширение <code class="filename">.oxt</code>. Из него необходимо извлечь файлы <code class="filename">.aff</code> и <code class="filename">.dic</code>, и сменить их расширения на <code class="filename">.affix</code> и <code class="filename">.dict</code>, соответственно. Для некоторых файлов словарей также необходимо преобразовать символы в кодировку UTF-8 с помощью, например, таких команд (для норвежского языка): </p><pre class="programlisting">iconv -f ISO_8859-1 -t UTF-8 -o nn_no.affix nn_NO.aff
iconv -f ISO_8859-1 -t UTF-8 -o nn_no.dict nn_NO.dic</pre></li><li class="listitem" style="list-style-type: disc"><p>скопируйте файлы в каталог <code class="filename">$SHAREDIR/tsearch_data</code></p></li><li class="listitem" style="list-style-type: disc"><p>загрузите эти файлы в PostgreSQL следующей командой: </p><pre class="programlisting">CREATE TEXT SEARCH DICTIONARY english_hunspell (
    TEMPLATE = ispell,
    DictFile = en_us,
    AffFile = en_us,
    Stopwords = english);</pre></li></ul></div><p>Здесь параметры <code class="literal">DictFile</code>, <code class="literal">AffFile</code> и <code class="literal">StopWords</code> определяют базовые имена файлов словаря, аффиксов и стоп-слов. Файл стоп-слов должен иметь тот же формат, что рассматривался выше в описании словаря <code class="literal">simple</code>. Формат других файлов здесь не рассматривается, но его можно узнать по вышеуказанным веб-адресам.</p><p>Словари Ispell обычно воспринимают ограниченный набор слов, так что за ними следует подключить другой, более общий словарь, например, Snowball, который принимает всё.</p><p>Файл <code class="filename">.affix</code> для <span class="application">Ispell</span> имеет такую структуру: </p><pre class="programlisting">prefixes
flag *A:
    .           &gt;   RE      # As in enter &gt; reenter
suffixes
flag T:
    E           &gt;   ST      # As in late &gt; latest
    [^AEIOU]Y   &gt;   -Y,IEST # As in dirty &gt; dirtiest
    [AEIOU]Y    &gt;   EST     # As in gray &gt; grayest
    [^EY]       &gt;   EST     # As in small &gt; smallest</pre><p>А файл <code class="filename">.dict</code> — такую: </p><pre class="programlisting">lapse/ADGRS
lard/DGRS
large/PRTY
lark/MRS</pre><p>Формат файла <code class="filename">.dict</code> следующий: </p><pre class="programlisting">basic_form/affix_class_name</pre><p>В файле <code class="filename">.affix</code> каждый флаг аффиксов описывается в следующем формате: </p><pre class="programlisting">условие &gt; [-отсекаемые_буквы,] добавляемый_аффикс</pre><p>Здесь условие записывается в формате, подобном формату регулярных выражений. В нём возможно описать группы <code class="literal">[...]</code> и <code class="literal">[^...]</code>. Например, запись <code class="literal">[AEIOU]Y</code> означает, что последняя буква слова — <code class="literal">"y"</code>, а предпоследней может быть <code class="literal">"a"</code>, <code class="literal">"e"</code>, <code class="literal">"i"</code>, <code class="literal">"o"</code> или <code class="literal">"u"</code>. Запись <code class="literal">[^EY]</code> означает, что последняя буква не <code class="literal">"e"</code> и не <code class="literal">"y"</code>.</p><p>Словари Ispell поддерживают разделение составных слов, что бывает полезно. Заметьте, что для этого в файле аффиксов нужно пометить специальным оператором <code class="literal">compoundwords controlled</code> слова, которые могут участвовать в составных образованиях: </p><pre class="programlisting">compoundwords  controlled z</pre><p> Вот как это работает для норвежского языка: </p><pre class="programlisting">SELECT ts_lexize('norwegian_ispell',
  'overbuljongterningpakkmesterassistent');
   {over,buljong,terning,pakk,mester,assistent}
SELECT ts_lexize('norwegian_ispell', 'sjokoladefabrikk');
   {sjokoladefabrikk,sjokolade,fabrikk}</pre><p>Формат <span class="application">MySpell</span> представляет собой подмножество формата <span class="application">Hunspell</span>. Файл <code class="filename">.affix</code> словаря <span class="application">Hunspell</span> имеет следующую структуру: </p><pre class="programlisting">PFX A Y 1
PFX A   0     re         .
SFX T N 4
SFX T   0     st         e
SFX T   y     iest       [^aeiou]y
SFX T   0     est        [aeiou]y
SFX T   0     est        [^ey]</pre><p>Первая строка класса аффиксов — заголовок. Поля правил аффиксов указываются после заголовка:</p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p>имя параметра (PFX или SFX)</p></li><li class="listitem" style="list-style-type: disc"><p>флаг (имя класса аффиксов)</p></li><li class="listitem" style="list-style-type: disc"><p>отсекаемые символы в начале (в префиксе) или в конце (в суффиксе) слова</p></li><li class="listitem" style="list-style-type: disc"><p>добавляемый аффикс</p></li><li class="listitem" style="list-style-type: disc"><p>условие в формате, подобном регулярным выражениям.</p></li></ul></div><p>Файл <code class="filename">.dict</code> подобен файлу <code class="filename">.dict</code> словаря <span class="application">Ispell</span>: </p><pre class="programlisting">larder/M
lardy/RT
large/RSPMYT
largehearted</pre><div class="note"><h3 class="title">Примечание</h3><p>Словарь <span class="application">MySpell</span> не поддерживает составные слова. С другой стороны, <span class="application">Hunspell</span> поддерживает множество операции с ними, но в настоящее время <span class="productname">PostgreSQL</span> использует только самые простые из этого множества.</p></div></div><div class="sect2" id="TEXTSEARCH-SNOWBALL-DICTIONARY"><div class="titlepage"><div><div><h3 class="title">12.6.6. Словарь <span class="application">Snowball</span> <a href="#TEXTSEARCH-SNOWBALL-DICTIONARY" class="id_link">#</a></h3></div></div></div><p>Шаблон словарей <span class="application">Snowball</span> основан на проекте Мартина Потера, изобретателя популярного алгоритма стемминга для английского языка. Сейчас Snowball предлагает алгоритмы и для многих других языков (за подробностями обратитесь на <a class="ulink" href="https://snowballstem.org/" target="_top">сайт Snowball</a>). Каждый алгоритм знает, как для данного языка свести распространённые словоформы к начальной форме. Для словаря Snowball задаётся обязательный параметр <code class="literal">language</code>, определяющий, какой именно стеммер использовать, и может задаваться параметр <code class="literal">stopword</code>, указывающий файл со списком исключаемых слов. (Стандартные списки стоп-слов <span class="productname">PostgreSQL</span> используется также в и проекте Snowball.) Например, встроенное определение выглядит так </p><pre class="programlisting">CREATE TEXT SEARCH DICTIONARY english_stem (
    TEMPLATE = snowball,
    Language = english,
    StopWords = english
);</pre><p> Формат файла стоп-слов не отличается от рассмотренного ранее.</p><p>Словарь <span class="application">Snowball</span> распознаёт любые фрагменты, даже если он не может упростить слова, так что он должен быть самым последним в списке словарей. Помещать его перед другими словарями нет смысла, так как после него никакой фрагмент не будет передан следующему словарю.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="textsearch-parsers.html" title="12.5. Анализаторы">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="textsearch.html" title="Глава 12. Полнотекстовый поиск">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="textsearch-configuration.html" title="12.7. Пример конфигурации">След.</a></td></tr><tr><td width="40%" align="left" valign="top">12.5. Анализаторы </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 12.7. Пример конфигурации</td></tr></table></div></body></html>