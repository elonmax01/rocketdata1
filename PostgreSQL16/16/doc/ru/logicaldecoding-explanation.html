<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>49.2. Концепции логического декодирования</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="logicaldecoding-example.html" title="49.1. Примеры логического декодирования" /><link rel="next" href="logicaldecoding-walsender.html" title="49.3. Интерфейс протокола потоковой репликации" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">49.2. Концепции логического декодирования</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="logicaldecoding-example.html" title="49.1. Примеры логического декодирования">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="logicaldecoding.html" title="Глава 49. Логическое декодирование">Наверх</a></td><th width="60%" align="center">Глава 49. Логическое декодирование</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="logicaldecoding-walsender.html" title="49.3. Интерфейс протокола потоковой репликации">След.</a></td></tr></table><hr /></div><div class="sect1" id="LOGICALDECODING-EXPLANATION"><div class="titlepage"><div><div><h2 class="title" style="clear: both">49.2. Концепции логического декодирования <a href="#LOGICALDECODING-EXPLANATION" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="logicaldecoding-explanation.html#LOGICALDECODING-EXPLANATION-LOG-DEC">49.2.1. Логическое декодирование</a></span></dt><dt><span class="sect2"><a href="logicaldecoding-explanation.html#LOGICALDECODING-REPLICATION-SLOTS">49.2.2. Слоты репликации</a></span></dt><dt><span class="sect2"><a href="logicaldecoding-explanation.html#LOGICALDECODING-EXPLANATION-OUTPUT-PLUGINS">49.2.3. Модули вывода</a></span></dt><dt><span class="sect2"><a href="logicaldecoding-explanation.html#LOGICALDECODING-EXPLANATION-EXPORTED-SNAPSHOTS">49.2.4. Экспортированные снимки</a></span></dt></dl></div><div class="sect2" id="LOGICALDECODING-EXPLANATION-LOG-DEC"><div class="titlepage"><div><div><h3 class="title">49.2.1. Логическое декодирование <a href="#LOGICALDECODING-EXPLANATION-LOG-DEC" class="id_link">#</a></h3></div></div></div><a id="id-1.8.14.8.2.2" class="indexterm"></a><p>Логическое декодирование — это процедура извлечения всех постоянных изменений, происходящих в таблицах базы данных, в согласованном и понятном формате, который можно интерпретировать, не имея полного представления о внутреннем состоянии базы данных.</p><p>В <span class="productname">PostgreSQL</span> логическое декодирование реализуется путём перевода содержимого <a class="link" href="wal.html" title="Глава 30. Надёжность и журнал предзаписи">журнала предзаписи</a>, описывающего изменения на уровне хранения, в специальную форму уровня приложения, например, в поток кортежей или операторов SQL.</p></div><div class="sect2" id="LOGICALDECODING-REPLICATION-SLOTS"><div class="titlepage"><div><div><h3 class="title">49.2.2. Слоты репликации <a href="#LOGICALDECODING-REPLICATION-SLOTS" class="id_link">#</a></h3></div></div></div><a id="id-1.8.14.8.3.2" class="indexterm"></a><p>В контексте логической репликации слот представляет поток изменений, которые могут быть воспроизведены клиентом в том порядке, в каком они происходили на исходном сервере. Через каждый слот передаётся последовательность изменений в одной базе данных.</p><div class="note"><h3 class="title">Примечание</h3><p>В <span class="productname">PostgreSQL</span> также есть слоты потоковой репликации (см. <a class="xref" href="warm-standby.html#STREAMING-REPLICATION" title="27.2.5. Потоковая репликация">Подраздел 27.2.5</a>), но они используются несколько по-другому.</p></div><p>Слоту репликации назначается идентификатор, уникальный для всех баз данных в кластере <span class="productname">PostgreSQL</span>. Слоты сохраняются независимо от подключений, использующих их, и защищены от сбоев сервера.</p><p>При обычных условиях через логический слот каждое изменение передаётся только один раз. Текущая позиция в каждом слоте сохраняется только в контрольной точке, так что в случае сбоя слот может вернуться к предыдущему LSN, вследствие чего последние изменения могут быть переданы повторно при перезапуске сервера. За исключение нежелательных эффектов от повторной обработки одного и того же сообщения отвечают клиенты логического декодирования. Клиенты могут запоминать при декодировании, какой последний LSN они уже получали, и пропускать повторяющиеся данные или (при использовании протокола репликации) запрашивать, чтобы декодирование начиналось с этого LSN, а не с позиции, выбираемой сервером. Для этого разработан механизм отслеживания репликации, о котором можно узнать подробнее в описании <a class="link" href="replication-origins.html" title="Глава 50. Отслеживание прогресса репликации">источников репликации</a>.</p><p>Для одной базы данных могут существовать несколько независимых слотов. Каждый слот имеет собственное состояние, что позволяет различным потребителям получать изменения с разных позиций в потоке изменений базы данных. Для большинства приложений каждому потребителю требуется отдельный слот.</p><p>Слот логической репликации ничего не знает о состоянии получателя(ей). Возможно даже иметь несколько различных потребителей одного слота в разные моменты времени; они просто будут получать изменения с момента, когда их перестал получать предыдущий потребитель. Но в любой определённый момент получать изменения может только один потребитель.</p><p>Логический слот репликации также можно создать на сервере горячего резерва. Чтобы запретить <code class="command">VACUUM</code> удалять требуемые строки из системных каталогов, на резервном сервере необходимо установить параметр <code class="varname">hot_standby_feedback</code>. Несмотря на это, если какие-либо требуемые строки будут удалены, слот станет аннулирован. Настоятельно рекомендуется использовать физический слот между ведущим и резервным сервером. В противном случае <code class="varname">hot_standby_feedback</code> будет работать только пока соединение активно (например, перезапуск узла может разорвать соединение). Затем ведущий сервер может удалить строки системного каталога, которые могут потребоваться для логического декодирования на резервном сервере (поскольку ведущий сервер не знает о catalog_xmin на резервном сервере). Существующие логические слоты в режиме ожидания также становятся недействительными, если значение <code class="varname">wal_level</code> на основном сервере становится ниже <code class="literal">logical</code>. Это происходит, как только резервный сервер обнаруживает такое изменение в потоке WAL и означает, что для отстающих процессов walsender (если таковые имеются) некоторые записи WAL до изменения параметра <code class="varname">wal_level</code> на ведущем сервере не будут декодированы.</p><p>Для создания логического слота необходима информация обо всех текущих транзакциях. На ведущем сервере эта информация доступна напрямую, а на резервном её необходимо получать от ведущего. Таким образом, при создании слота может потребоваться ожидание каких-либо действий на ведущем сервере. Если ведущий сервер простаивает, создание логического слота на резервном может занять много времени. Это время можно сократить, вызвав функцию <code class="function">pg_log_standby_snapshot</code> на ведущем сервере.</p><div class="caution"><h3 class="title">Внимание</h3><p>Слоты репликации сохраняются при сбоях сервера и ничего не знают о состоянии их потребителя. Они не дают удалять требуемые ресурсы, даже когда не используются никаким подключением. На это уходит место в хранилище, так как ни сегменты WAL, ни требуемые строки из системных каталогов нельзя будет удалить в результате <code class="command">VACUUM</code>, пока они нужны этому слоту репликации. В особых случаях это может привести к отключению базы для предотвращения зацикливания идентификаторов транзакций (см. <a class="xref" href="routine-vacuuming.html#VACUUM-FOR-WRAPAROUND" title="25.1.5. Предотвращение ошибок из-за зацикливания счётчика транзакций">Подраздел 25.1.5</a>). Поэтому, если слот больше не требуется, его следует ликвидировать.</p></div></div><div class="sect2" id="LOGICALDECODING-EXPLANATION-OUTPUT-PLUGINS"><div class="titlepage"><div><div><h3 class="title">49.2.3. Модули вывода <a href="#LOGICALDECODING-EXPLANATION-OUTPUT-PLUGINS" class="id_link">#</a></h3></div></div></div><p>Модули вывода переводят данные из внутреннего представления в журнале предзаписи в формат, устраивающий потребителя слота репликации.</p></div><div class="sect2" id="LOGICALDECODING-EXPLANATION-EXPORTED-SNAPSHOTS"><div class="titlepage"><div><div><h3 class="title">49.2.4. Экспортированные снимки <a href="#LOGICALDECODING-EXPLANATION-EXPORTED-SNAPSHOTS" class="id_link">#</a></h3></div></div></div><p>Когда новый слот репликации создаётся через интерфейс потоковой репликации, экспортируется снимок (см. <a class="xref" href="protocol-replication.html#PROTOCOL-REPLICATION-CREATE-REPLICATION-SLOT">CREATE_REPLICATION_SLOT</a>), который будет показывать ровно то состояние базы данных, изменения после которого будут включаться в поток изменений. Используя его, можно создать новую реплику, воспользовавшись командой <a class="link" href="sql-set-transaction.html" title="SET TRANSACTION"><code class="literal">SET TRANSACTION SNAPSHOT</code></a>, чтобы получить состояние базы в момент создания слота. После этого данную транзакцию можно использовать для выгрузки состояния базы на момент экспорта снимка, а затем изменять это состояние, применяя содержимое слота, так что никакие изменения не будут потеряны.</p><p>Создание снимка возможно не всегда. В частности, невозможно создать снимок при подключении к горячему резерву. Приложения, которым не требуется экспорт снимка, могут подавить его, воспользовавшись указанием <code class="literal">NOEXPORT_SNAPSHOT</code>.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="logicaldecoding-example.html" title="49.1. Примеры логического декодирования">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="logicaldecoding.html" title="Глава 49. Логическое декодирование">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="logicaldecoding-walsender.html" title="49.3. Интерфейс протокола потоковой репликации">След.</a></td></tr><tr><td width="40%" align="left" valign="top">49.1. Примеры логического декодирования </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 49.3. Интерфейс протокола потоковой репликации</td></tr></table></div></body></html>