<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>36.6. Библиотека pgtypes</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="ecpg-dynamic.html" title="36.5. Динамический SQL" /><link rel="next" href="ecpg-descriptors.html" title="36.7. Использование областей дескрипторов" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">36.6. Библиотека pgtypes</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="ecpg-dynamic.html" title="36.5. Динамический SQL">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="ecpg.html" title="Глава 36. ECPG — Встраиваемый SQL в C">Наверх</a></td><th width="60%" align="center">Глава 36. <span class="application">ECPG</span> — Встраиваемый <acronym class="acronym">SQL</acronym> в C</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="ecpg-descriptors.html" title="36.7. Использование областей дескрипторов">След.</a></td></tr></table><hr /></div><div class="sect1" id="ECPG-PGTYPES"><div class="titlepage"><div><div><h2 class="title" style="clear: both">36.6. Библиотека pgtypes <a href="#ECPG-PGTYPES" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="ecpg-pgtypes.html#ECPG-PGTYPES-CSTRINGS">36.6.1. Символьные строки</a></span></dt><dt><span class="sect2"><a href="ecpg-pgtypes.html#ECPG-PGTYPES-NUMERIC">36.6.2. Тип numeric</a></span></dt><dt><span class="sect2"><a href="ecpg-pgtypes.html#ECPG-PGTYPES-DATE">36.6.3. Тип date</a></span></dt><dt><span class="sect2"><a href="ecpg-pgtypes.html#ECPG-PGTYPES-TIMESTAMP">36.6.4. Тип timestamp</a></span></dt><dt><span class="sect2"><a href="ecpg-pgtypes.html#ECPG-PGTYPES-INTERVAL">36.6.5. Тип interval</a></span></dt><dt><span class="sect2"><a href="ecpg-pgtypes.html#ECPG-PGTYPES-DECIMAL">36.6.6. Тип decimal</a></span></dt><dt><span class="sect2"><a href="ecpg-pgtypes.html#ECPG-PGTYPES-ERRNO">36.6.7. Значения errno, которые устанавливает pgtypeslib</a></span></dt><dt><span class="sect2"><a href="ecpg-pgtypes.html#ECPG-PGTYPES-CONSTANTS">36.6.8. Специальные константы pgtypeslib</a></span></dt></dl></div><p>Библиотека pgtypes сопоставляет типы базы данных <span class="productname">PostgreSQL</span> с их эквивалентами в C, которые можно использовать в программах на C. Она также предлагает функции для выполнения простых вычислений с этими типами в C, то есть без помощи сервера <span class="productname">PostgreSQL</span>. Рассмотрите следующий пример: </p><pre class="programlisting">
EXEC SQL BEGIN DECLARE SECTION;
   date date1;
   timestamp ts1, tsout;
   interval iv1;
   char *out;
EXEC SQL END DECLARE SECTION;

PGTYPESdate_today(&amp;date1);
EXEC SQL SELECT started, duration INTO :ts1, :iv1 FROM datetbl WHERE d=:date1;
PGTYPEStimestamp_add_interval(&amp;ts1, &amp;iv1, &amp;tsout);
out = PGTYPEStimestamp_to_asc(&amp;tsout);
printf("Started + duration: %s\n", out);
PGTYPESchar_free(out);

</pre><div class="sect2" id="ECPG-PGTYPES-CSTRINGS"><div class="titlepage"><div><div><h3 class="title">36.6.1. Символьные строки <a href="#ECPG-PGTYPES-CSTRINGS" class="id_link">#</a></h3></div></div></div><p>Некоторые функции, в частности <code class="function">PGTYPESnumeric_to_asc</code>, возвращают указатель на строку в выделенной для неё памяти. Их результаты должны освобождаться функцией <code class="function">PGTYPESchar_free</code>, а не <code class="function">free</code>. (Это важно только в Windows, где выделение и освобождение памяти в определённых случаях должно производиться одной библиотекой.)</p></div><div class="sect2" id="ECPG-PGTYPES-NUMERIC"><div class="titlepage"><div><div><h3 class="title">36.6.2. Тип numeric <a href="#ECPG-PGTYPES-NUMERIC" class="id_link">#</a></h3></div></div></div><p>Тип numeric позволяет производить вычисления с произвольной точностью. Эквивалентный ему тип на сервере <span class="productname">PostgreSQL</span> описан в <a class="xref" href="datatype-numeric.html" title="8.1. Числовые типы">Разделе 8.1</a>. Ввиду того, что переменная имеет произвольную точность, она должна расширяться и сжиматься динамически. Поэтому такие переменные можно создавать только в области кучи, используя функции <code class="function">PGTYPESnumeric_new</code> и <code class="function">PGTYPESnumeric_free</code>. Тип decimal подобен numeric, но имеет ограниченную точность, и поэтому может размещаться и в области кучи, и в стеке.</p><p>Для работы с типом numeric можно использовать следующие функции: </p><div class="variablelist"><dl class="variablelist"><dt id="ECPG-PGTYPES-NUMERIC-NEW"><span class="term"><code class="function">PGTYPESnumeric_new</code></span> <a href="#ECPG-PGTYPES-NUMERIC-NEW" class="id_link">#</a></dt><dd><p>Запрашивает указатель на новую переменную, размещённую в памяти. </p><pre class="synopsis">
numeric *PGTYPESnumeric_new(void);
</pre></dd><dt id="ECPG-PGTYPES-NUMERIC-FREE"><span class="term"><code class="function">PGTYPESnumeric_free</code></span> <a href="#ECPG-PGTYPES-NUMERIC-FREE" class="id_link">#</a></dt><dd><p>Освобождает переменную типа numeric, высвобождая всю её память. </p><pre class="synopsis">
void PGTYPESnumeric_free(numeric *var);
</pre></dd><dt id="ECPG-PGTYPES-NUMERIC-FROM-ASC"><span class="term"><code class="function">PGTYPESnumeric_from_asc</code></span> <a href="#ECPG-PGTYPES-NUMERIC-FROM-ASC" class="id_link">#</a></dt><dd><p>Разбирает числовой тип из строковой записи. </p><pre class="synopsis">
numeric *PGTYPESnumeric_from_asc(char *str, char **endptr);
</pre><p> Допускаются в частности следующие форматы: <code class="literal">-2</code>, <code class="literal">.794</code>, <code class="literal">+3.44</code>, <code class="literal">592.49E07</code> и <code class="literal">-32.84e-4</code>. Если значение удаётся разобрать успешно, возвращается действительный указатель, в противном случае указатель NULL. На данный момент ECPG всегда разбирает строку до конца, так что эта функция не может вернуть адрес первого недопустимого символа в <code class="literal">*endptr</code>. Поэтому в <code class="literal">endptr</code> свободно можно передать NULL.</p></dd><dt id="ECPG-PGTYPES-NUMERIC-TO-ASC"><span class="term"><code class="function">PGTYPESnumeric_to_asc</code></span> <a href="#ECPG-PGTYPES-NUMERIC-TO-ASC" class="id_link">#</a></dt><dd><p>Возвращает указатель на строку, выделенную функцией <code class="function">malloc</code> и содержащую строковое представление значения <code class="literal">num</code> числового типа. </p><pre class="synopsis">
char *PGTYPESnumeric_to_asc(numeric *num, int dscale);
</pre><p> Числовое значение будет выводиться с заданным в <code class="literal">dscale</code> количеством цифр после запятой, округлённое при необходимости. Результат нужно освободить функцией <code class="function">PGTYPESchar_free()</code>.</p></dd><dt id="ECPG-PGTYPES-NUMERIC-ADD"><span class="term"><code class="function">PGTYPESnumeric_add</code></span> <a href="#ECPG-PGTYPES-NUMERIC-ADD" class="id_link">#</a></dt><dd><p>Суммирует две числовые переменные и возвращает результат в третьей. </p><pre class="synopsis">
int PGTYPESnumeric_add(numeric *var1, numeric *var2, numeric *result);
</pre><p> Эта функция суммирует переменные <code class="literal">var1</code> и <code class="literal">var2</code> в результирующую переменную <code class="literal">result</code>. Функция возвращает 0 в случае успеха и -1 при ошибке.</p></dd><dt id="ECPG-PGTYPES-NUMERIC-SUB"><span class="term"><code class="function">PGTYPESnumeric_sub</code></span> <a href="#ECPG-PGTYPES-NUMERIC-SUB" class="id_link">#</a></dt><dd><p>Вычисляет разность двух числовых переменных и возвращает результат в третьей. </p><pre class="synopsis">
int PGTYPESnumeric_sub(numeric *var1, numeric *var2, numeric *result);
</pre><p> Эта функция вычитает переменную <code class="literal">var2</code> из <code class="literal">var1</code>. Результат операции помещается в переменную <code class="literal">result</code>. Функция возвращает 0 в случае успеха и -1 при ошибке.</p></dd><dt id="ECPG-PGTYPES-NUMERIC-MUL"><span class="term"><code class="function">PGTYPESnumeric_mul</code></span> <a href="#ECPG-PGTYPES-NUMERIC-MUL" class="id_link">#</a></dt><dd><p>Перемножает две числовые переменные и возвращает результат в третьей. </p><pre class="synopsis">
int PGTYPESnumeric_mul(numeric *var1, numeric *var2, numeric *result);
</pre><p> Эта функция перемножает переменные <code class="literal">var1</code> и <code class="literal">var2</code>. Результат операции сохраняется в переменной <code class="literal">result</code>. Функция возвращает 0 в случае успеха и -1 при ошибке.</p></dd><dt id="ECPG-PGTYPES-NUMERIC-DIV"><span class="term"><code class="function">PGTYPESnumeric_div</code></span> <a href="#ECPG-PGTYPES-NUMERIC-DIV" class="id_link">#</a></dt><dd><p>Вычисляет частное двух числовых переменных и возвращает результат в третьей. </p><pre class="synopsis">
int PGTYPESnumeric_div(numeric *var1, numeric *var2, numeric *result);
</pre><p> Эта функция делит переменную <code class="literal">var1</code> на <code class="literal">var2</code>. Результат операции сохраняется в переменной <code class="literal">result</code>. Функция возвращает 0 в случае успеха и -1 при ошибке.</p></dd><dt id="ECPG-PGTYPES-NUMERIC-CMP"><span class="term"><code class="function">PGTYPESnumeric_cmp</code></span> <a href="#ECPG-PGTYPES-NUMERIC-CMP" class="id_link">#</a></dt><dd><p>Сравнивает две числовые переменные. </p><pre class="synopsis">
int PGTYPESnumeric_cmp(numeric *var1, numeric *var2)
</pre><p> Эта функция производит сравнение двух числовых переменных. При ошибке возвращается <code class="literal">INT_MAX</code>. В случае успеха функция возвращает одно из трёх возможных значений: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>1, если <code class="literal">var1</code> больше <code class="literal">var2</code></p></li><li class="listitem"><p>-1, если <code class="literal">var1</code> меньше <code class="literal">var2</code></p></li><li class="listitem"><p>0, если <code class="literal">var1</code> и <code class="literal">var2</code> равны</p></li></ul></div></dd><dt id="ECPG-PGTYPES-NUMERIC-FROM-INT"><span class="term"><code class="function">PGTYPESnumeric_from_int</code></span> <a href="#ECPG-PGTYPES-NUMERIC-FROM-INT" class="id_link">#</a></dt><dd><p>Преобразует переменную int в переменную numeric. </p><pre class="synopsis">
int PGTYPESnumeric_from_int(signed int int_val, numeric *var);
</pre><p> Эта функция принимает целочисленную переменную со знаком типа signed int и сохраняет её значение в переменной <code class="literal">var</code> типа numeric. Функция возвращает 0 в случае успеха и -1 при ошибке.</p></dd><dt id="ECPG-PGTYPES-NUMERIC-FROM-LONG"><span class="term"><code class="function">PGTYPESnumeric_from_long</code></span> <a href="#ECPG-PGTYPES-NUMERIC-FROM-LONG" class="id_link">#</a></dt><dd><p>Преобразует переменную long int в переменную numeric. </p><pre class="synopsis">
int PGTYPESnumeric_from_long(signed long int long_val, numeric *var);
</pre><p> Эта функция принимает целочисленную переменную со знаком типа signed long int и сохраняет её значение в переменной <code class="literal">var</code> типа numeric. Функция возвращает 0 в случае успеха и -1 при ошибке.</p></dd><dt id="ECPG-PGTYPES-NUMERIC-COPY"><span class="term"><code class="function">PGTYPESnumeric_copy</code></span> <a href="#ECPG-PGTYPES-NUMERIC-COPY" class="id_link">#</a></dt><dd><p>Копирует одну числовую переменную в другую. </p><pre class="synopsis">
int PGTYPESnumeric_copy(numeric *src, numeric *dst);
</pre><p> Эта функция копирует значение переменной, на которую указывает <code class="literal">src</code>, в переменную, на которую указывает <code class="literal">dst</code>. Она возвращает 0 в случае успеха и -1 при ошибке.</p></dd><dt id="ECPG-PGTYPES-NUMERIC-FROM-DOUBLE"><span class="term"><code class="function">PGTYPESnumeric_from_double</code></span> <a href="#ECPG-PGTYPES-NUMERIC-FROM-DOUBLE" class="id_link">#</a></dt><dd><p>Преобразует переменную типа double в переменную numeric. </p><pre class="synopsis">
int  PGTYPESnumeric_from_double(double d, numeric *dst);
</pre><p> Эта функция принимает переменную типа double и сохраняет преобразованное значение в переменной, на которую указывает <code class="literal">dst</code>. Она возвращает 0 в случае успеха и -1 при ошибке.</p></dd><dt id="ECPG-PGTYPES-NUMERIC-TO-DOUBLE"><span class="term"><code class="function">PGTYPESnumeric_to_double</code></span> <a href="#ECPG-PGTYPES-NUMERIC-TO-DOUBLE" class="id_link">#</a></dt><dd><p>Преобразует переменную типа numeric в переменную double. </p><pre class="synopsis">
int PGTYPESnumeric_to_double(numeric *nv, double *dp)
</pre><p> Эта функция преобразует значение типа numeric переменной, на которую указывает <code class="literal">nv</code>, в переменную типа double, на которую указывает <code class="literal">dp</code>. Она возвращает 0 в случае успеха и -1 при ошибке, в том числе при переполнении. Если происходит переполнение, в глобальной переменной <code class="literal">errno</code> дополнительно устанавливается значение <code class="literal">PGTYPES_NUM_OVERFLOW</code>.</p></dd><dt id="ECPG-PGTYPES-NUMERIC-TO-INT"><span class="term"><code class="function">PGTYPESnumeric_to_int</code></span> <a href="#ECPG-PGTYPES-NUMERIC-TO-INT" class="id_link">#</a></dt><dd><p>Преобразует переменную типа numeric в переменную int. </p><pre class="synopsis">
int PGTYPESnumeric_to_int(numeric *nv, int *ip);
</pre><p> Эта функция преобразует значение типа numeric переменной, на которую указывает <code class="literal">nv</code>, в целочисленную переменную, на которую указывает <code class="literal">ip</code>. Она возвращает 0 в случае успеха и -1 при ошибке, в том числе при переполнении. Если происходит переполнение, в глобальной переменной <code class="literal">errno</code> дополнительно устанавливается значение <code class="literal">PGTYPES_NUM_OVERFLOW</code>.</p></dd><dt id="ECPG-PGTYPES-NUMERIC-TO-LONG"><span class="term"><code class="function">PGTYPESnumeric_to_long</code></span> <a href="#ECPG-PGTYPES-NUMERIC-TO-LONG" class="id_link">#</a></dt><dd><p>Преобразует переменную типа numeric в переменную long. </p><pre class="synopsis">
int PGTYPESnumeric_to_long(numeric *nv, long *lp);
</pre><p> Эта функция преобразует значение типа numeric переменной, на которую указывает <code class="literal">nv</code>, в целочисленную переменную типа long, на которую указывает <code class="literal">lp</code>. Она возвращает 0 в случае успеха и -1 при ошибке, в том числе при переполнении. Если происходит переполнение, в глобальной переменной <code class="literal">errno</code> дополнительно устанавливается значение <code class="literal">PGTYPES_NUM_OVERFLOW</code>.</p></dd><dt id="ECPG-PGTYPES-NUMERIC-TO-DECIMAL"><span class="term"><code class="function">PGTYPESnumeric_to_decimal</code></span> <a href="#ECPG-PGTYPES-NUMERIC-TO-DECIMAL" class="id_link">#</a></dt><dd><p>Преобразует переменную типа numeric в переменную decimal. </p><pre class="synopsis">
int PGTYPESnumeric_to_decimal(numeric *src, decimal *dst);
</pre><p> Эта функция преобразует значение типа numeric переменной, на которую указывает <code class="literal">src</code>, в переменную типа decimal, на которую указывает <code class="literal">dst</code>. Она возвращает 0 в случае успеха и -1 при ошибке, в том числе при переполнении. Если происходит переполнение, в глобальной переменной <code class="literal">errno</code> дополнительно устанавливается значение <code class="literal">PGTYPES_NUM_OVERFLOW</code>.</p></dd><dt id="ECPG-PGTYPES-NUMERIC-FROM-DECIMAL"><span class="term"><code class="function">PGTYPESnumeric_from_decimal</code></span> <a href="#ECPG-PGTYPES-NUMERIC-FROM-DECIMAL" class="id_link">#</a></dt><dd><p>Преобразует переменную типа decimal в переменную numeric. </p><pre class="synopsis">
int PGTYPESnumeric_from_decimal(decimal *src, numeric *dst);
</pre><p> Эта функция преобразует значение типа decimal переменной, на которую указывает <code class="literal">src</code>, в переменную типа numeric, на которую указывает <code class="literal">dst</code>. Она возвращает 0 в случае успеха и -1 при ошибке. Так как тип decimal реализован как ограниченная версия типа numeric, при таком преобразовании переполнение невозможно.</p></dd></dl></div></div><div class="sect2" id="ECPG-PGTYPES-DATE"><div class="titlepage"><div><div><h3 class="title">36.6.3. Тип date <a href="#ECPG-PGTYPES-DATE" class="id_link">#</a></h3></div></div></div><p>Тип date, реализованный в C, позволяет программам работать с данными типа date в SQL. Соответствующий тип сервера <span class="productname">PostgreSQL</span> описан в <a class="xref" href="datatype-datetime.html" title="8.5. Типы даты/времени">Разделе 8.5</a>.</p><p>Для работы с типом date можно использовать следующие функции: </p><div class="variablelist"><dl class="variablelist"><dt id="PGTYPESDATEFROMTIMESTAMP"><span class="term"><code class="function">PGTYPESdate_from_timestamp</code></span> <a href="#PGTYPESDATEFROMTIMESTAMP" class="id_link">#</a></dt><dd><p>Извлекает часть даты из значения типа timestamp. </p><pre class="synopsis">
date PGTYPESdate_from_timestamp(timestamp dt);
</pre><p> Эта функция получает в единственном аргументе значение времени типа timestamp и возвращает извлечённую из него дату.</p></dd><dt id="PGTYPESDATEFROMASC"><span class="term"><code class="function">PGTYPESdate_from_asc</code></span> <a href="#PGTYPESDATEFROMASC" class="id_link">#</a></dt><dd><p>Разбирает дату из её текстового представления. </p><pre class="synopsis">
date PGTYPESdate_from_asc(char *str, char **endptr);
</pre><p> Эта функция получает строку C char* <code class="literal">str</code> и указатель на строку C char* <code class="literal">endptr</code>. На данный момент ECPG всегда разбирает строку до конца, так что эта функция не может вернуть адрес первого недопустимого символа в <code class="literal">*endptr</code>. Поэтому в <code class="literal">endptr</code> свободно можно передать NULL.</p><p>Заметьте, что эта функция всегда подразумевает формат дат MDY (месяц-день-год) и никакой переменной для изменения этого формата в ECPG нет.</p><p>Все допустимые форматы ввода перечислены в <a class="xref" href="ecpg-pgtypes.html#ECPG-PGTYPESDATE-FROM-ASC-TABLE" title="Таблица 36.2. Допустимые форматы ввода для PGTYPESdate_from_asc">Таблице 36.2</a>.</p><div class="table" id="ECPG-PGTYPESDATE-FROM-ASC-TABLE"><p class="title"><strong>Таблица 36.2. Допустимые форматы ввода для <code class="function">PGTYPESdate_from_asc</code></strong></p><div class="table-contents"><table class="table" summary="Допустимые форматы ввода для PGTYPESdate_from_asc" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Ввод</th><th>Результат</th></tr></thead><tbody><tr><td><code class="literal">January 8, 1999</code></td><td><code class="literal">January 8, 1999</code></td></tr><tr><td><code class="literal">1999-01-08</code></td><td><code class="literal">January 8, 1999</code></td></tr><tr><td><code class="literal">1/8/1999</code></td><td><code class="literal">January 8, 1999</code></td></tr><tr><td><code class="literal">1/18/1999</code></td><td><code class="literal">January 18, 1999</code></td></tr><tr><td><code class="literal">01/02/03</code></td><td><code class="literal">February 1, 2003</code></td></tr><tr><td><code class="literal">1999-Jan-08</code></td><td><code class="literal">January 8, 1999</code></td></tr><tr><td><code class="literal">Jan-08-1999</code></td><td><code class="literal">January 8, 1999</code></td></tr><tr><td><code class="literal">08-Jan-1999</code></td><td><code class="literal">January 8, 1999</code></td></tr><tr><td><code class="literal">99-Jan-08</code></td><td><code class="literal">January 8, 1999</code></td></tr><tr><td><code class="literal">08-Jan-99</code></td><td><code class="literal">January 8, 1999</code></td></tr><tr><td><code class="literal">08-Jan-06</code></td><td><code class="literal">January 8, 2006</code></td></tr><tr><td><code class="literal">Jan-08-99</code></td><td><code class="literal">January 8, 1999</code></td></tr><tr><td><code class="literal">19990108</code></td><td><code class="literal">ISO 8601; January 8, 1999</code></td></tr><tr><td><code class="literal">990108</code></td><td><code class="literal">ISO 8601; January 8, 1999</code></td></tr><tr><td><code class="literal">1999.008</code></td><td><code class="literal">год и день года</code></td></tr><tr><td><code class="literal">J2451187</code></td><td><code class="literal">Юлианский день</code></td></tr><tr><td><code class="literal">January 8, 99 BC</code></td><td><code class="literal">99 год до нашей эры</code></td></tr></tbody></table></div></div><br class="table-break" /></dd><dt id="PGTYPESDATETOASC"><span class="term"><code class="function">PGTYPESdate_to_asc</code></span> <a href="#PGTYPESDATETOASC" class="id_link">#</a></dt><dd><p>Возвращает текстовое представление переменной типа date. </p><pre class="synopsis">
char *PGTYPESdate_to_asc(date dDate);
</pre><p> Эта функция получает в качестве единственного параметра дату <code class="literal">dDate</code> и выводит её в виде <code class="literal">1999-01-18</code>, то есть в формате <code class="literal">YYYY-MM-DD</code>. Результат необходимо освободить функцией <code class="function">PGTYPESchar_free()</code>.</p></dd><dt id="PGTYPESDATEJULMDY"><span class="term"><code class="function">PGTYPESdate_julmdy</code></span> <a href="#PGTYPESDATEJULMDY" class="id_link">#</a></dt><dd><p>Извлекает значения дня, месяца и года из переменной типа date. </p><pre class="synopsis">
void PGTYPESdate_julmdy(date d, int *mdy);
</pre><p> Эта функция получает дату <code class="literal">d</code> и указатель на 3 целочисленных значения <code class="literal">mdy</code>. Имя переменной указывает на порядок значений: в <code class="literal">mdy[0]</code> записывается номер месяца, в <code class="literal">mdy[1]</code> — номер дня, а в <code class="literal">mdy[2]</code> — год.</p></dd><dt id="PGTYPESDATEMDYJUL"><span class="term"><code class="function">PGTYPESdate_mdyjul</code></span> <a href="#PGTYPESDATEMDYJUL" class="id_link">#</a></dt><dd><p>Образует значение даты из массива 3 целых чисел, задающих день, месяц и год даты. </p><pre class="synopsis">
void PGTYPESdate_mdyjul(int *mdy, date *jdate);
</pre><p> Эта функция получает в первом аргументе массив из 3 целых чисел (<code class="literal">mdy</code>), а во втором указатель на переменную типа date, в которую будет помещён результат операции.</p></dd><dt id="PGTYPESDATEDAYOFWEEK"><span class="term"><code class="function">PGTYPESdate_dayofweek</code></span> <a href="#PGTYPESDATEDAYOFWEEK" class="id_link">#</a></dt><dd><p>Возвращает число, представляющее день недели для заданной даты. </p><pre class="synopsis">
int PGTYPESdate_dayofweek(date d);
</pre><p> Эта функция принимает в единственном аргументе переменную <code class="literal">d</code> типа date и возвращает целое число, выражающее день недели для этой даты. </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>0 — Воскресенье</p></li><li class="listitem"><p>1 — Понедельник</p></li><li class="listitem"><p>2 — Вторник</p></li><li class="listitem"><p>3 — Среда</p></li><li class="listitem"><p>4 — Четверг</p></li><li class="listitem"><p>5 — Пятница</p></li><li class="listitem"><p>6 — Суббота</p></li></ul></div></dd><dt id="PGTYPESDATETODAY"><span class="term"><code class="function">PGTYPESdate_today</code></span> <a href="#PGTYPESDATETODAY" class="id_link">#</a></dt><dd><p>Выдаёт текущую дату. </p><pre class="synopsis">
void PGTYPESdate_today(date *d);
</pre><p> Эта функция получает указатель на переменную (<code class="literal">d</code>) типа date, в которую будет записана текущая дата.</p></dd><dt id="PGTYPESDATEFMTASC"><span class="term"><code class="function">PGTYPESdate_fmt_asc</code></span> <a href="#PGTYPESDATEFMTASC" class="id_link">#</a></dt><dd><p>Преобразует переменную типа date в текстовое представление по маске формата. </p><pre class="synopsis">
int PGTYPESdate_fmt_asc(date dDate, char *fmtstring, char *outbuf);
</pre><p> Эта функция принимает дату для преобразования (<code class="literal">dDate</code>), маску формата (<code class="literal">fmtstring</code>) и строку, в которую будет помещено текстовое представление даты (<code class="literal">outbuf</code>).</p><p>В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.</p><p>В строке формата можно использовать следующие коды полей: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">dd</code> — Номер дня в месяце.</p></li><li class="listitem"><p><code class="literal">mm</code> — Номер месяца в году.</p></li><li class="listitem"><p><code class="literal">yy</code> — Номер года в виде двух цифр.</p></li><li class="listitem"><p><code class="literal">yyyy</code> — Номер года в виде четырёх цифр.</p></li><li class="listitem"><p><code class="literal">ddd</code> — Название дня недели (сокращённое).</p></li><li class="listitem"><p><code class="literal">mmm</code> — Название месяца (сокращённое).</p></li></ul></div><p> Все другие символы копируются в выводимую строку 1:1.</p><p>В <a class="xref" href="ecpg-pgtypes.html#ECPG-PGTYPESDATE-FMT-ASC-EXAMPLE-TABLE" title="Таблица 36.3. Допустимые форматы ввода для PGTYPESdate_fmt_asc">Таблице 36.3</a> перечислены несколько возможных форматов. Это даёт представление, как можно использовать эту функцию. Все строки вывода даны для одной даты: 23 ноября 1959 г.</p><div class="table" id="ECPG-PGTYPESDATE-FMT-ASC-EXAMPLE-TABLE"><p class="title"><strong>Таблица 36.3. Допустимые форматы ввода для <code class="function">PGTYPESdate_fmt_asc</code></strong></p><div class="table-contents"><table class="table" summary="Допустимые форматы ввода для PGTYPESdate_fmt_asc" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Формат</th><th>Результат</th></tr></thead><tbody><tr><td><code class="literal">mmddyy</code></td><td><code class="literal">112359</code></td></tr><tr><td><code class="literal">ddmmyy</code></td><td><code class="literal">231159</code></td></tr><tr><td><code class="literal">yymmdd</code></td><td><code class="literal">591123</code></td></tr><tr><td><code class="literal">yy/mm/dd</code></td><td><code class="literal">59/11/23</code></td></tr><tr><td><code class="literal">yy mm dd</code></td><td><code class="literal">59 11 23</code></td></tr><tr><td><code class="literal">yy.mm.dd</code></td><td><code class="literal">59.11.23</code></td></tr><tr><td><code class="literal">.mm.yyyy.dd.</code></td><td><code class="literal">.11.1959.23.</code></td></tr><tr><td><code class="literal">mmm. dd, yyyy</code></td><td><code class="literal">Nov. 23, 1959</code></td></tr><tr><td><code class="literal">mmm dd yyyy</code></td><td><code class="literal">Nov 23 1959</code></td></tr><tr><td><code class="literal">yyyy dd mm</code></td><td><code class="literal">1959 23 11</code></td></tr><tr><td><code class="literal">ddd, mmm. dd, yyyy</code></td><td><code class="literal">Mon, Nov. 23, 1959</code></td></tr><tr><td><code class="literal">(ddd) mmm. dd, yyyy</code></td><td><code class="literal">(Mon) Nov. 23, 1959</code></td></tr></tbody></table></div></div><br class="table-break" /></dd><dt id="PGTYPESDATEDEFMTASC"><span class="term"><code class="function">PGTYPESdate_defmt_asc</code></span> <a href="#PGTYPESDATEDEFMTASC" class="id_link">#</a></dt><dd><p>Преобразует строку C <code class="type">char*</code> в значение типа date по маске формата. </p><pre class="synopsis">
int PGTYPESdate_defmt_asc(date *d, char *fmt, char *str);
</pre><p> Эта функция принимает указатель на переменную типа date (<code class="literal">d</code>), в которую будет помещён результат операции, маску формата для разбора даты (<code class="literal">fmt</code>) и строку C char*, содержащую текстовое представление даты (<code class="literal">str</code>). Ожидается, что текстовое представление будет соответствовать маске формата. Однако это соответствие не обязательно должно быть точным. Данная функция анализирует только порядок элементов и ищет в нём подстроки <code class="literal">yy</code> или <code class="literal">yyyy</code>, обозначающие позицию года, подстроку <code class="literal">mm</code>, обозначающую позицию месяца, и <code class="literal">dd</code>, обозначающую позицию дня.</p><p>В <a class="xref" href="ecpg-pgtypes.html#ECPG-RDEFMTDATE-EXAMPLE-TABLE" title="Таблица 36.4. Допустимые форматы ввода для rdefmtdate">Таблица 36.4</a> перечислены несколько возможных форматов. Это даёт представление, как можно использовать эту функцию.</p><div class="table" id="ECPG-RDEFMTDATE-EXAMPLE-TABLE"><p class="title"><strong>Таблица 36.4. Допустимые форматы ввода для <code class="function">rdefmtdate</code></strong></p><div class="table-contents"><table class="table" summary="Допустимые форматы ввода для rdefmtdate" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Формат</th><th>Строка</th><th>Результат</th></tr></thead><tbody><tr><td><code class="literal">ddmmyy</code></td><td><code class="literal">21-2-54</code></td><td><code class="literal">1954-02-21</code></td></tr><tr><td><code class="literal">ddmmyy</code></td><td><code class="literal">2-12-54</code></td><td><code class="literal">1954-12-02</code></td></tr><tr><td><code class="literal">ddmmyy</code></td><td><code class="literal">20111954</code></td><td><code class="literal">1954-11-20</code></td></tr><tr><td><code class="literal">ddmmyy</code></td><td><code class="literal">130464</code></td><td><code class="literal">1964-04-13</code></td></tr><tr><td><code class="literal">mmm.dd.yyyy</code></td><td><code class="literal">MAR-12-1967</code></td><td><code class="literal">1967-03-12</code></td></tr><tr><td><code class="literal">yy/mm/dd</code></td><td><code class="literal">1954, February 3rd</code></td><td><code class="literal">1954-02-03</code></td></tr><tr><td><code class="literal">mmm.dd.yyyy</code></td><td><code class="literal">041269</code></td><td><code class="literal">1969-04-12</code></td></tr><tr><td><code class="literal">yy/mm/dd</code></td><td><code class="literal">In the year 2525, in the month of July, mankind will be alive on the 28th day</code></td><td><code class="literal">2525-07-28</code></td></tr><tr><td><code class="literal">dd-mm-yy</code></td><td><code class="literal">I said on the 28th of July in the year 2525</code></td><td><code class="literal">2525-07-28</code></td></tr><tr><td><code class="literal">mmm.dd.yyyy</code></td><td><code class="literal">9/14/58</code></td><td><code class="literal">1958-09-14</code></td></tr><tr><td><code class="literal">yy/mm/dd</code></td><td><code class="literal">47/03/29</code></td><td><code class="literal">1947-03-29</code></td></tr><tr><td><code class="literal">mmm.dd.yyyy</code></td><td><code class="literal">oct 28 1975</code></td><td><code class="literal">1975-10-28</code></td></tr><tr><td><code class="literal">mmddyy</code></td><td><code class="literal">Nov 14th, 1985</code></td><td><code class="literal">1985-11-14</code></td></tr></tbody></table></div></div><br class="table-break" /></dd></dl></div></div><div class="sect2" id="ECPG-PGTYPES-TIMESTAMP"><div class="titlepage"><div><div><h3 class="title">36.6.4. Тип timestamp <a href="#ECPG-PGTYPES-TIMESTAMP" class="id_link">#</a></h3></div></div></div><p>Тип timestamp, реализованный в C, позволяет программам работать с данными типа timestamp в SQL. Соответствующий тип сервера <span class="productname">PostgreSQL</span> описан в <a class="xref" href="datatype-datetime.html" title="8.5. Типы даты/времени">Разделе 8.5</a>.</p><p>Для работы с типом timestamp можно использовать следующие функции: </p><div class="variablelist"><dl class="variablelist"><dt id="PGTYPESTIMESTAMPFROMASC"><span class="term"><code class="function">PGTYPEStimestamp_from_asc</code></span> <a href="#PGTYPESTIMESTAMPFROMASC" class="id_link">#</a></dt><dd><p>Разбирает значение даты/времени из текстового представления в переменную типа timestamp. </p><pre class="synopsis">
timestamp PGTYPEStimestamp_from_asc(char *str, char **endptr);
</pre><p> Эта функция получает строку (<code class="literal">str</code>), которую нужно разобрать, и указатель на строку C char* (<code class="literal">endptr</code>). На данный момент ECPG всегда разбирает строку до конца, так что эта функция не может вернуть адрес первого недопустимого символа в <code class="literal">*endptr</code>. Поэтому в <code class="literal">endptr</code> свободно можно передать NULL.</p><p>В случае успеха эта функция возвращает разобранное время, а в случае ошибки возвращается <code class="literal">PGTYPESInvalidTimestamp</code> и в <code class="varname">errno</code> устанавливается значение <code class="literal">PGTYPES_TS_BAD_TIMESTAMP</code>. См. замечание относительно <a class="xref" href="ecpg-pgtypes.html#PGTYPESINVALIDTIMESTAMP"><code class="literal">PGTYPESInvalidTimestamp</code></a>.</p><p>Вообще вводимая строка может содержать допустимое указание даты, пробельные символы и допустимое указание времени в любом сочетании. Заметьте, что часовые пояса ECPG не поддерживает. Эта функция может разобрать их, но не задействует их в вычислениях как это делает, например, сервер <span class="productname">PostgreSQL</span>. Указания часового пояса во вводимой строке просто игнорируются.</p><p>В <a class="xref" href="ecpg-pgtypes.html#ECPG-PGTYPESTIMESTAMP-FROM-ASC-EXAMPLE-TABLE" title="Таблица 36.5. Допустимые форматы ввода для PGTYPEStimestamp_from_asc">Таблица 36.5</a> приведены несколько примеров вводимых строк.</p><div class="table" id="ECPG-PGTYPESTIMESTAMP-FROM-ASC-EXAMPLE-TABLE"><p class="title"><strong>Таблица 36.5. Допустимые форматы ввода для <code class="function">PGTYPEStimestamp_from_asc</code></strong></p><div class="table-contents"><table class="table" summary="Допустимые форматы ввода для PGTYPEStimestamp_from_asc" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Ввод</th><th>Результат</th></tr></thead><tbody><tr><td><code class="literal">1999-01-08 04:05:06</code></td><td><code class="literal">1999-01-08 04:05:06</code></td></tr><tr><td><code class="literal">January 8 04:05:06 1999 PST</code></td><td><code class="literal">1999-01-08 04:05:06</code></td></tr><tr><td><code class="literal">1999-Jan-08 04:05:06.789-8</code></td><td><code class="literal">1999-01-08 04:05:06.789 (указание часового пояса игнорируется)</code></td></tr><tr><td><code class="literal">J2451187 04:05-08:00</code></td><td><code class="literal">1999-01-08 04:05:00 (указание часового пояса игнорируется)</code></td></tr></tbody></table></div></div><br class="table-break" /></dd><dt id="PGTYPESTIMESTAMPTOASC"><span class="term"><code class="function">PGTYPEStimestamp_to_asc</code></span> <a href="#PGTYPESTIMESTAMPTOASC" class="id_link">#</a></dt><dd><p>Преобразует значение даты в строку C char*. </p><pre class="synopsis">
char *PGTYPEStimestamp_to_asc(timestamp tstamp);
</pre><p> Эта функция принимает в качестве единственного аргумента <code class="literal">tstamp</code> значение типа timestamp и возвращает размещённую в памяти строку, содержащую текстовое представление даты/времени. Результат необходимо освободить функцией <code class="function">PGTYPESchar_free()</code>.</p></dd><dt id="PGTYPESTIMESTAMPCURRENT"><span class="term"><code class="function">PGTYPEStimestamp_current</code></span> <a href="#PGTYPESTIMESTAMPCURRENT" class="id_link">#</a></dt><dd><p>Получает текущее время. </p><pre class="synopsis">
void PGTYPEStimestamp_current(timestamp *ts);
</pre><p> Эта функция получает текущее время и сохраняет его в переменной типа timestamp, на которую указывает <code class="literal">ts</code>.</p></dd><dt id="PGTYPESTIMESTAMPFMTASC"><span class="term"><code class="function">PGTYPEStimestamp_fmt_asc</code></span> <a href="#PGTYPESTIMESTAMPFMTASC" class="id_link">#</a></dt><dd><p>Преобразует переменную типа timestamp в строку C char* по маске формата. </p><pre class="synopsis">
int PGTYPEStimestamp_fmt_asc(timestamp *ts, char *output, int str_len, char *fmtstr);
</pre><p> Эта функция получает в первом аргументе (<code class="literal">ts</code>) указатель на переменную типа timestamp, а в последующих указатель на буфер вывода (<code class="literal">output</code>), максимальную длину строки, которую может принять буфер (<code class="literal">str_len</code>), и маску формата, с которой будет выполняться преобразование (<code class="literal">fmtstr</code>).</p><p>В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.</p><p>В маске формата можно использовать коды формата, перечисленные ниже. Эти же коды принимает функция <code class="function">strftime</code> из библиотеки <span class="productname">libc</span>. Любые символы, не относящиеся к кодам формата, будут просто скопированы в буфер вывода. </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">%A</code> — заменяется локализованным представлением полного названия дня недели.</p></li><li class="listitem"><p><code class="literal">%a</code> — заменяется локализованным представлением сокращённого названия дня недели.</p></li><li class="listitem"><p><code class="literal">%B</code> — заменяется локализованным представлением полного названия месяца.</p></li><li class="listitem"><p><code class="literal">%b</code> — заменяется локализованным представлением сокращённого названия месяца.</p></li><li class="listitem"><p><code class="literal">%C</code> — заменяется столетием (год / 100) в виде десятичного числа; одиночная цифра предваряется нулём.</p></li><li class="listitem"><p><code class="literal">%c</code> — заменяется локализованным представлением даты и времени.</p></li><li class="listitem"><p><code class="literal">%D</code> — равнозначно <code class="literal">%m/%d/%y</code>.</p></li><li class="listitem"><p><code class="literal">%d</code> — заменяется днём месяца в виде десятичного числа (01–31).</p></li><li class="listitem"><p><code class="literal">%E*</code> <code class="literal">%O*</code> — расширения локали POSIX. Последовательности <code class="literal">%Ec</code> <code class="literal">%EC</code> <code class="literal">%Ex</code> <code class="literal">%EX</code> <code class="literal">%Ey</code> <code class="literal">%EY</code> <code class="literal">%Od</code> <code class="literal">%Oe</code> <code class="literal">%OH</code> <code class="literal">%OI</code> <code class="literal">%Om</code> <code class="literal">%OM</code> <code class="literal">%OS</code> <code class="literal">%Ou</code> <code class="literal">%OU</code> <code class="literal">%OV</code> <code class="literal">%Ow</code> <code class="literal">%OW</code> <code class="literal">%Oy</code> должны выводить альтернативные представления.</p><p>Кроме того, альтернативные названия месяцев представляет код формата <code class="literal">%OB</code> (используется отдельно, без упоминания дня).</p></li><li class="listitem"><p><code class="literal">%e</code> — заменяется днём в виде десятичного числа (1–31); одиночная цифра предваряется пробелом.</p></li><li class="listitem"><p><code class="literal">%F</code> — равнозначно <code class="literal">%Y-%m-%d</code>.</p></li><li class="listitem"><p><code class="literal">%G</code> — заменяется годом в виде десятичного числа (со столетием). При этом годом считается тот, что содержит наибольшую часть недели (дни недели начинаются с понедельника).</p></li><li class="listitem"><p><code class="literal">%g</code> — заменяется тем же годом, что и <code class="literal">%G</code>, но в виде десятичного числа без столетия (00–99).</p></li><li class="listitem"><p><code class="literal">%H</code> — заменяется часами (в 24-часовом формате) в виде десятичного числа (00–23).</p></li><li class="listitem"><p><code class="literal">%h</code> — равнозначно <code class="literal">%b</code>.</p></li><li class="listitem"><p><code class="literal">%I</code> — заменяется часами (в 12-часовом формате) в виде десятичного числа (01–12).</p></li><li class="listitem"><p><code class="literal">%j</code> — заменяется днём года в виде десятичного числа (001–366).</p></li><li class="listitem"><p><code class="literal">%k</code> — заменяется часами (в 24-часовом формате) в виде десятичного числа (0–23); одиночная цифра предваряется пробелом.</p></li><li class="listitem"><p><code class="literal">%l</code> — заменяется часами (в 12-часовом формате) в виде десятичного числа (1–12); одиночная цифра предваряется пробелом.</p></li><li class="listitem"><p><code class="literal">%M</code> — заменяется минутами в виде десятичного числа (00–59).</p></li><li class="listitem"><p><code class="literal">%m</code> — заменяется номером месяца в виде десятичного числа (01–12).</p></li><li class="listitem"><p><code class="literal">%n</code> — заменяется символом новой строки.</p></li><li class="listitem"><p><code class="literal">%O*</code> — равнозначно <code class="literal">%E*</code>.</p></li><li class="listitem"><p><code class="literal">%p</code> — заменяется локализованным представлением <span class="quote">«<span class="quote">до полудня</span>»</span> или <span class="quote">«<span class="quote">после полудня</span>»</span> в зависимости от времени.</p></li><li class="listitem"><p><code class="literal">%R</code> — равнозначно <code class="literal">%H:%M</code>.</p></li><li class="listitem"><p><code class="literal">%r</code> — равнозначно <code class="literal">%I:%M:%S %p</code>.</p></li><li class="listitem"><p><code class="literal">%S</code> — заменяется секундами в виде десятичного числа (00–60).</p></li><li class="listitem"><p><code class="literal">%s</code> — заменяется числом секунд с начала эпохи, по мировому времени (UTC).</p></li><li class="listitem"><p><code class="literal">%T</code> — равнозначно <code class="literal">%H:%M:%S</code></p></li><li class="listitem"><p><code class="literal">%t</code> — заменяется символом табуляции.</p></li><li class="listitem"><p><code class="literal">%U</code> — заменяется номером недели в году (первым днём недели считается воскресенье) в виде десятичного числа (00–53).</p></li><li class="listitem"><p><code class="literal">%u</code> — заменяется номером дня недели (первым днём недели считается понедельник) в виде десятичного числа (1–7).</p></li><li class="listitem"><p><code class="literal">%V</code> — заменяется номером недели в году (первым днём недели считается понедельник) в виде десятичного числа (01–53). Если к недели, включающей 1 января, относятся 4 или больше дней нового года, она считается неделей с номером 1; в противном случае это последняя неделя предыдущего года, а неделей под номером 1 будет следующая.</p></li><li class="listitem"><p><code class="literal">%v</code> — равнозначно <code class="literal">%e-%b-%Y</code>.</p></li><li class="listitem"><p><code class="literal">%W</code> — заменяется номером недели в году (первым днём недели считается понедельник) в виде десятичного числа (00–53).</p></li><li class="listitem"><p><code class="literal">%w</code> — заменяется номером дня недели (первым днём недели считается воскресенье) в виде десятичного числа (0–6).</p></li><li class="listitem"><p><code class="literal">%X</code> — заменяется локализованным представлением времени.</p></li><li class="listitem"><p><code class="literal">%x</code> — заменяется локализованным представлением даты.</p></li><li class="listitem"><p><code class="literal">%Y</code> — заменяется годом со столетием в виде десятичного числа.</p></li><li class="listitem"><p><code class="literal">%y</code> — заменяется годом без столетия в виде десятичного числа (00–99).</p></li><li class="listitem"><p><code class="literal">%Z</code> — заменяется названием часового пояса.</p></li><li class="listitem"><p><code class="literal">%z</code> — заменяется смещением часового пояса от UTC; ведущий знак плюс обозначает смещение к востоку от UTC, а знак минус — к западу, часы и минуты задаются парами цифр без разделителя между ними (эта форма установлена для даты в <a class="ulink" href="https://datatracker.ietf.org/doc/html/rfc822" target="_top">RFC 822</a>).</p></li><li class="listitem"><p><code class="literal">%+</code> — заменяется локализованным представлением даты и времени.</p></li><li class="listitem"><p><code class="literal">%-*</code> — расширение GNU libc. Отключает дополнение чисел по ширине при выводе.</p></li><li class="listitem"><p>$_* — расширение GNU libc. Явно включает дополнение пробелами.</p></li><li class="listitem"><p><code class="literal">%0*</code> — расширение GNU libc. Явно включает дополнение нулями.</p></li><li class="listitem"><p><code class="literal">%%</code> — заменяется символом <code class="literal">%</code>.</p></li></ul></div></dd><dt id="PGTYPESTIMESTAMPSUB"><span class="term"><code class="function">PGTYPEStimestamp_sub</code></span> <a href="#PGTYPESTIMESTAMPSUB" class="id_link">#</a></dt><dd><p>Вычитает одно значение времени из другого и сохраняет результат в переменной типа interval. </p><pre class="synopsis">
int PGTYPEStimestamp_sub(timestamp *ts1, timestamp *ts2, interval *iv);
</pre><p> Эта функция вычитает значение типа timestamp, на которое указывает <code class="literal">ts2</code>, из значения timestamp, на которое указывает <code class="literal">ts1</code>, и сохраняет результат в переменной типа interval, на которую указывает <code class="literal">iv</code>.</p><p>В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.</p></dd><dt id="PGTYPESTIMESTAMPDEFMTASC"><span class="term"><code class="function">PGTYPEStimestamp_defmt_asc</code></span> <a href="#PGTYPESTIMESTAMPDEFMTASC" class="id_link">#</a></dt><dd><p>Разбирает значение типа timestamp из текстового представления с заданной маской формата. </p><pre class="synopsis">
int PGTYPEStimestamp_defmt_asc(char *str, char *fmt, timestamp *d);
</pre><p> Эта функция получает текстовое представление даты/времени в переменной <code class="literal">str</code>, а также маску формата для разбора в переменной <code class="literal">fmt</code>. Результат будет сохранён в переменной, на которую указывает <code class="literal">d</code>.</p><p>Если вместо маски формата <code class="literal">fmt</code> передаётся NULL, эта функция переходит к стандартной маске форматирования, а именно: <code class="literal">%Y-%m-%d %H:%M:%S</code>.</p><p>Данная функция является обратной к функции <a class="xref" href="ecpg-pgtypes.html#PGTYPESTIMESTAMPFMTASC"><code class="function">PGTYPEStimestamp_fmt_asc</code></a>. Обратитесь к её документации, чтобы узнать о возможных вариантах маски формата.</p></dd><dt id="PGTYPESTIMESTAMPADDINTERVAL"><span class="term"><code class="function">PGTYPEStimestamp_add_interval</code></span> <a href="#PGTYPESTIMESTAMPADDINTERVAL" class="id_link">#</a></dt><dd><p>Добавляет переменную типа interval к переменной типа timestamp. </p><pre class="synopsis">
int PGTYPEStimestamp_add_interval(timestamp *tin, interval *span, timestamp *tout);
</pre><p> Эта функция получает указатель на переменную <code class="literal">tin</code> типа timestamp и указатель на переменную <code class="literal">span</code> типа interval. Она добавляет временной интервал к значению даты/времени и сохраняет полученную дату/время в переменной типа timestamp, на которую указывает <code class="literal">tout</code>.</p><p>В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.</p></dd><dt id="PGTYPESTIMESTAMPSUBINTERVAL"><span class="term"><code class="function">PGTYPEStimestamp_sub_interval</code></span> <a href="#PGTYPESTIMESTAMPSUBINTERVAL" class="id_link">#</a></dt><dd><p>Вычитает переменную типа interval из переменной типа timestamp. </p><pre class="synopsis">
int PGTYPEStimestamp_sub_interval(timestamp *tin, interval *span, timestamp *tout);
</pre><p> Эта функция вычитает значение типа interval, на которое указывает <code class="literal">span</code>, из значения типа timestamp, на которое указывает <code class="literal">tin</code>, и сохраняет результат в переменной, на которую указывает <code class="literal">tout</code>.</p><p>В случае успеха возвращается 0, а в случае ошибки — отрицательное значение.</p></dd></dl></div></div><div class="sect2" id="ECPG-PGTYPES-INTERVAL"><div class="titlepage"><div><div><h3 class="title">36.6.5. Тип interval <a href="#ECPG-PGTYPES-INTERVAL" class="id_link">#</a></h3></div></div></div><p>Тип interval, реализованный в C, позволяет программам работать с данными типа interval в SQL. Соответствующий тип сервера <span class="productname">PostgreSQL</span> описан в <a class="xref" href="datatype-datetime.html" title="8.5. Типы даты/времени">Разделе 8.5</a>.</p><p>Для работы с типом interval можно использовать следующие функции: </p><div class="variablelist"><dl class="variablelist"><dt id="PGTYPESINTERVALNEW"><span class="term"><code class="function">PGTYPESinterval_new</code></span> <a href="#PGTYPESINTERVALNEW" class="id_link">#</a></dt><dd><p>Возвращает указатель на новую переменную interval, размещённую в памяти. </p><pre class="synopsis">
interval *PGTYPESinterval_new(void);
</pre></dd><dt id="PGTYPESINTERVALFREE"><span class="term"><code class="function">PGTYPESinterval_free</code></span> <a href="#PGTYPESINTERVALFREE" class="id_link">#</a></dt><dd><p>Освобождает место, занимаемое ранее размещённой в памяти переменной типа interval. </p><pre class="synopsis">
void PGTYPESinterval_free(interval *intvl);
</pre></dd><dt id="PGTYPESINTERVALFROMASC"><span class="term"><code class="function">PGTYPESinterval_from_asc</code></span> <a href="#PGTYPESINTERVALFROMASC" class="id_link">#</a></dt><dd><p>Разбирает значение типа interval из его текстового представления. </p><pre class="synopsis">
interval *PGTYPESinterval_from_asc(char *str, char **endptr);
</pre><p> Эта функция разбирает входную строку <code class="literal">str</code> и возвращает указатель на размещённую в памяти переменную типа interval. На данный момент ECPG всегда разбирает строку до конца, так что эта функция не может вернуть адрес первого недопустимого символа в <code class="literal">*endptr</code>. Поэтому в <code class="literal">endptr</code> свободно можно передать NULL.</p></dd><dt id="PGTYPESINTERVALTOASC"><span class="term"><code class="function">PGTYPESinterval_to_asc</code></span> <a href="#PGTYPESINTERVALTOASC" class="id_link">#</a></dt><dd><p>Преобразует переменную типа interval в текстовое представление. </p><pre class="synopsis">
char *PGTYPESinterval_to_asc(interval *span);
</pre><p> Эта функция преобразует переменную типа interval, на которую указывает <code class="literal">span</code>, в строку C char*. Её вывод выглядит примерно так: <code class="literal">@ 1 day 12 hours 59 mins 10 secs</code>. Результат необходимо освободить функцией <code class="function">PGTYPESchar_free()</code>.</p></dd><dt id="PGTYPESINTERVALCOPY"><span class="term"><code class="function">PGTYPESinterval_copy</code></span> <a href="#PGTYPESINTERVALCOPY" class="id_link">#</a></dt><dd><p>Копирует переменную типа interval. </p><pre class="synopsis">
int PGTYPESinterval_copy(interval *intvlsrc, interval *intvldest);
</pre><p> Эта функция копирует переменную типа interval, на которую указывает <code class="literal">intvlsrc</code>, в переменную, на которую указывает <code class="literal">intvldest</code>. Заметьте, что для целевой переменной необходимо предварительно выделить память.</p></dd></dl></div></div><div class="sect2" id="ECPG-PGTYPES-DECIMAL"><div class="titlepage"><div><div><h3 class="title">36.6.6. Тип decimal <a href="#ECPG-PGTYPES-DECIMAL" class="id_link">#</a></h3></div></div></div><p>Тип decimal похож на тип numeric, однако его максимальная точность ограничена 30 значащими цифрами. В отличие от типа numeric, который можно создать только в области кучи, тип decimal можно создать и в стеке, и в области кучи (посредством функций <code class="function">PGTYPESdecimal_new</code> и <code class="function">PGTYPESdecimal_free</code>). Для работы с типом decimal есть много других функций, подключаемых в режиме совместимости с <span class="productname">Informix</span>, описанном в <a class="xref" href="ecpg-informix-compat.html" title="36.15. Режим совместимости с Informix">Разделе 36.15</a>.</p><p>Для работы с типом decimal можно использовать следующие функции (содержащиеся не в библиотеке <code class="literal">libcompat</code>). </p><div class="variablelist"><dl class="variablelist"><dt id="ECPG-PGTYPES-DECIMAL-NEW"><span class="term"><code class="function">PGTYPESdecimal_new</code></span> <a href="#ECPG-PGTYPES-DECIMAL-NEW" class="id_link">#</a></dt><dd><p>Запрашивает указатель на новую переменную decimal, размещённую в памяти. </p><pre class="synopsis">
decimal *PGTYPESdecimal_new(void);
</pre></dd><dt id="ECPG-PGTYPES-DECIMAL-FREE"><span class="term"><code class="function">PGTYPESdecimal_free</code></span> <a href="#ECPG-PGTYPES-DECIMAL-FREE" class="id_link">#</a></dt><dd><p>Освобождает переменную типа decimal, высвобождая всю её память. </p><pre class="synopsis">
void PGTYPESdecimal_free(decimal *var);
</pre></dd></dl></div></div><div class="sect2" id="ECPG-PGTYPES-ERRNO"><div class="titlepage"><div><div><h3 class="title">36.6.7. Значения errno, которые устанавливает pgtypeslib <a href="#ECPG-PGTYPES-ERRNO" class="id_link">#</a></h3></div></div></div><p>
    </p><div class="variablelist"><dl class="variablelist"><dt id="ECPG-PGTYPES-ERRNO-PGTYPES-NUM-BAD-NUMERIC"><span class="term"><code class="literal">PGTYPES_NUM_BAD_NUMERIC</code></span> <a href="#ECPG-PGTYPES-ERRNO-PGTYPES-NUM-BAD-NUMERIC" class="id_link">#</a></dt><dd><p>Аргумент должен содержать переменную типа numeric (либо указывать на переменную типа numeric), но представление этого типа в памяти оказалось некорректным.</p></dd><dt id="ECPG-PGTYPES-ERRNO-PGTYPES-NUM-OVERFLOW"><span class="term"><code class="literal">PGTYPES_NUM_OVERFLOW</code></span> <a href="#ECPG-PGTYPES-ERRNO-PGTYPES-NUM-OVERFLOW" class="id_link">#</a></dt><dd><p>Произошло переполнение. Так как тип numeric может принимать значения практически любой точности, при преобразовании этого типа в другие типы возможно переполнение.</p></dd><dt id="ECPG-PGTYPES-ERRNO-PGTYPES-NUM-UNDERFLOW"><span class="term"><code class="literal">PGTYPES_NUM_UNDERFLOW</code></span> <a href="#ECPG-PGTYPES-ERRNO-PGTYPES-NUM-UNDERFLOW" class="id_link">#</a></dt><dd><p>Произошло антипереполнение. Так как тип numeric может принимать значения практически любой точности, при преобразовании переменной этого типа в другие типы возможно антипереполнение.</p></dd><dt id="ECPG-PGTYPES-ERRNO-PGTYPES-NUM-DIVIDE-ZERO"><span class="term"><code class="literal">PGTYPES_NUM_DIVIDE_ZERO</code></span> <a href="#ECPG-PGTYPES-ERRNO-PGTYPES-NUM-DIVIDE-ZERO" class="id_link">#</a></dt><dd><p>Имела место попытка деления на ноль.</p></dd><dt id="ECPG-PGTYPES-ERRNO-PGTYPES-DATE-BAD-DATE"><span class="term"><code class="literal">PGTYPES_DATE_BAD_DATE</code></span> <a href="#ECPG-PGTYPES-ERRNO-PGTYPES-DATE-BAD-DATE" class="id_link">#</a></dt><dd><p>Функции <code class="function">PGTYPESdate_from_asc</code> передана некорректная строка даты.</p></dd><dt id="ECPG-PGTYPES-ERRNO-PGTYPES-DATE-ERR-EARGS"><span class="term"><code class="literal">PGTYPES_DATE_ERR_EARGS</code></span> <a href="#ECPG-PGTYPES-ERRNO-PGTYPES-DATE-ERR-EARGS" class="id_link">#</a></dt><dd><p>Функции <code class="function">PGTYPESdate_defmt_asc</code> переданы некорректные аргументы.</p></dd><dt id="ECPG-PGTYPES-ERRNO-PGTYPES-DATE-ERR-ENOSHORTDATE"><span class="term"><code class="literal">PGTYPES_DATE_ERR_ENOSHORTDATE</code></span> <a href="#ECPG-PGTYPES-ERRNO-PGTYPES-DATE-ERR-ENOSHORTDATE" class="id_link">#</a></dt><dd><p>В строке, переданной функции <code class="function">PGTYPESdate_defmt_asc</code>, оказался неправильный компонент даты.</p></dd><dt id="ECPG-PGTYPES-ERRNO-PGTYPES-INTVL-BAD-INTERVAL"><span class="term"><code class="literal">PGTYPES_INTVL_BAD_INTERVAL</code></span> <a href="#ECPG-PGTYPES-ERRNO-PGTYPES-INTVL-BAD-INTERVAL" class="id_link">#</a></dt><dd><p>Функции <code class="function">PGTYPESinterval_from_asc</code> передана некорректная строка, задающая интервал, либо функции <code class="function">PGTYPESinterval_to_asc</code> передано некорректное значение интервала.</p></dd><dt id="ECPG-PGTYPES-ERRNO-PGTYPES-DATE-ERR-ENOTDMY"><span class="term"><code class="literal">PGTYPES_DATE_ERR_ENOTDMY</code></span> <a href="#ECPG-PGTYPES-ERRNO-PGTYPES-DATE-ERR-ENOTDMY" class="id_link">#</a></dt><dd><p>Обнаружено несоответствие при выводе компонентов день/месяц/год в функции <code class="function">PGTYPESdate_defmt_asc</code>.</p></dd><dt id="ECPG-PGTYPES-ERRNO-PGTYPES-DATE-BAD-DAY"><span class="term"><code class="literal">PGTYPES_DATE_BAD_DAY</code></span> <a href="#ECPG-PGTYPES-ERRNO-PGTYPES-DATE-BAD-DAY" class="id_link">#</a></dt><dd><p>Функция <code class="function">PGTYPESdate_defmt_asc</code> обнаружила некорректное значение дня месяца.</p></dd><dt id="ECPG-PGTYPES-ERRNO-PGTYPES-DATE-BAD-MONTH"><span class="term"><code class="literal">PGTYPES_DATE_BAD_MONTH</code></span> <a href="#ECPG-PGTYPES-ERRNO-PGTYPES-DATE-BAD-MONTH" class="id_link">#</a></dt><dd><p>Функция <code class="function">PGTYPESdate_defmt_asc</code> обнаружила некорректное значение месяца.</p></dd><dt id="ECPG-PGTYPES-ERRNO-PGTYPES-TS-BAD-TIMESTAMP"><span class="term"><code class="literal">PGTYPES_TS_BAD_TIMESTAMP</code></span> <a href="#ECPG-PGTYPES-ERRNO-PGTYPES-TS-BAD-TIMESTAMP" class="id_link">#</a></dt><dd><p>Функции <code class="function">PGTYPEStimestamp_from_asc</code> передана некорректная строка даты/времени, либо функции <code class="function">PGTYPEStimestamp_to_asc</code> передано некорректное значение типа timestamp.</p></dd><dt id="ECPG-PGTYPES-ERRNO-PGTYPES-TS-ERR-EINFTIME"><span class="term"><code class="literal">PGTYPES_TS_ERR_EINFTIME</code></span> <a href="#ECPG-PGTYPES-ERRNO-PGTYPES-TS-ERR-EINFTIME" class="id_link">#</a></dt><dd><p>Значение типа timestamp, представляющее бесконечность, получено в недопустимом контексте.</p></dd></dl></div><p>
   </p></div><div class="sect2" id="ECPG-PGTYPES-CONSTANTS"><div class="titlepage"><div><div><h3 class="title">36.6.8. Специальные константы pgtypeslib <a href="#ECPG-PGTYPES-CONSTANTS" class="id_link">#</a></h3></div></div></div><p>
    </p><div class="variablelist"><dl class="variablelist"><dt id="PGTYPESINVALIDTIMESTAMP"><span class="term"><code class="literal">PGTYPESInvalidTimestamp</code></span> <a href="#PGTYPESINVALIDTIMESTAMP" class="id_link">#</a></dt><dd><p>Значение типа timestamp, представляющее недопустимое время. Это значение возвращает функция <code class="function">PGTYPEStimestamp_from_asc</code> при ошибке разбора. Заметьте, что вследствие особенности внутреннего представления типа <code class="type">timestamp</code>, значение <code class="literal">PGTYPESInvalidTimestamp</code> в то же время представляет корректное время (<code class="literal">1899-12-31 23:59:59</code>). Поэтому для выявления ошибок необходимо, чтобы приложение не только сравнивало результат функции с <code class="literal">PGTYPESInvalidTimestamp</code>, но и проверяло условие <code class="literal">errno != 0</code> после каждого вызова <code class="function">PGTYPEStimestamp_from_asc</code>.</p></dd></dl></div><p>
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ecpg-dynamic.html" title="36.5. Динамический SQL">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="ecpg.html" title="Глава 36. ECPG — Встраиваемый SQL в C">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="ecpg-descriptors.html" title="36.7. Использование областей дескрипторов">След.</a></td></tr><tr><td width="40%" align="left" valign="top">36.5. Динамический SQL </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 36.7. Использование областей дескрипторов</td></tr></table></div></body></html>