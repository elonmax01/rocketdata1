<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>34.4. Асинхронная обработка команд</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="libpq-exec.html" title="34.3. Функции для исполнения команд" /><link rel="next" href="libpq-pipeline-mode.html" title="34.5. Конвейерный режим" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">34.4. Асинхронная обработка команд</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="libpq-exec.html" title="34.3. Функции для исполнения команд">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="libpq.html" title="Глава 34. libpq — библиотека для языка C">Наверх</a></td><th width="60%" align="center">Глава 34. <span class="application">libpq</span> — библиотека для языка C</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="libpq-pipeline-mode.html" title="34.5. Конвейерный режим">След.</a></td></tr></table><hr /></div><div class="sect1" id="LIBPQ-ASYNC"><div class="titlepage"><div><div><h2 class="title" style="clear: both">34.4. Асинхронная обработка команд <a href="#LIBPQ-ASYNC" class="id_link">#</a></h2></div></div></div><a id="id-1.7.3.11.2" class="indexterm"></a><p>Функция <a class="xref" href="libpq-exec.html#LIBPQ-PQEXEC"><code class="function">PQexec</code></a> хорошо подходит для отправки команд серверу в нормальных, синхронных приложениях. Однако она имеет ряд недостатков, которые могут иметь значение для некоторых пользователей: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="libpq-exec.html#LIBPQ-PQEXEC"><code class="function">PQexec</code></a> ожидает завершения выполнения команды. Однако приложение может быть занято чем-то другим (например, обрабатывать активность в пользовательском интерфейсе), в таком случае блокировка приложения в ожидании ответа будет нежелательной.</p></li><li class="listitem"><p>Поскольку выполнение клиентского приложения приостанавливается, пока оно ожидает результата, то приложению трудно решить, что оно хотело бы попытаться отменить выполняющуюся команду. (Это можно сделать из обработчика сигнала, но никак иначе.)</p></li><li class="listitem"><p><a class="xref" href="libpq-exec.html#LIBPQ-PQEXEC"><code class="function">PQexec</code></a> может возвратить только одну структуру <code class="structname">PGresult</code>. Если отправленная серверу командная строка содержит несколько <acronym class="acronym">SQL</acronym>-команд, функция <a class="xref" href="libpq-exec.html#LIBPQ-PQEXEC"><code class="function">PQexec</code></a> отбрасывает все результаты <code class="structname">PGresult</code>, кроме последнего.</p></li><li class="listitem"><p><a class="xref" href="libpq-exec.html#LIBPQ-PQEXEC"><code class="function">PQexec</code></a> всегда собирает все результаты выполнения команды, буферизуя их в единственной структуре <code class="structname">PGresult</code>. В то время как для приложения это упрощает логику обработки ошибок, это может быть непрактично, когда результат содержит много строк.</p></li></ul></div><p>Приложения, которым эти ограничения не подходят, могут вместо <a class="xref" href="libpq-exec.html#LIBPQ-PQEXEC"><code class="function">PQexec</code></a> использовать функции, на которых она базируется, <a class="xref" href="libpq-async.html#LIBPQ-PQSENDQUERY"><code class="function">PQsendQuery</code></a> и <a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a>. Есть также функции <a class="xref" href="libpq-async.html#LIBPQ-PQSENDQUERYPARAMS"><code class="function">PQsendQueryParams</code></a>, <a class="xref" href="libpq-async.html#LIBPQ-PQSENDPREPARE"><code class="function">PQsendPrepare</code></a>, <a class="xref" href="libpq-async.html#LIBPQ-PQSENDQUERYPREPARED"><code class="function">PQsendQueryPrepared</code></a>, <a class="xref" href="libpq-async.html#LIBPQ-PQSENDDESCRIBEPREPARED"><code class="function">PQsendDescribePrepared</code></a> и <a class="xref" href="libpq-async.html#LIBPQ-PQSENDDESCRIBEPORTAL"><code class="function">PQsendDescribePortal</code></a>, которые в сочетании с <a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a> действуют аналогично функциям <a class="xref" href="libpq-exec.html#LIBPQ-PQEXECPARAMS"><code class="function">PQexecParams</code></a>, <a class="xref" href="libpq-exec.html#LIBPQ-PQPREPARE"><code class="function">PQprepare</code></a>, <a class="xref" href="libpq-exec.html#LIBPQ-PQEXECPREPARED"><code class="function">PQexecPrepared</code></a>, <a class="xref" href="libpq-exec.html#LIBPQ-PQDESCRIBEPREPARED"><code class="function">PQdescribePrepared</code></a> и <a class="xref" href="libpq-exec.html#LIBPQ-PQDESCRIBEPORTAL"><code class="function">PQdescribePortal</code></a>, соответственно. </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQSENDQUERY"><span class="term"><code class="function">PQsendQuery</code><a id="id-1.7.3.11.4.15.1.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQSENDQUERY" class="id_link">#</a></dt><dd><p>Отправляет команду серверу, не ожидая получения результата. Если команда была отправлена успешно, то функция возвратит значение 1, в противном случае она возвратит 0 (тогда нужно воспользоваться функцией <a class="xref" href="libpq-status.html#LIBPQ-PQERRORMESSAGE"><code class="function">PQerrorMessage</code></a> для получения дополнительной информации о сбое). </p><pre class="synopsis">
int PQsendQuery(PGconn *conn, const char *command);
</pre><p> После успешного вызова <a class="xref" href="libpq-async.html#LIBPQ-PQSENDQUERY"><code class="function">PQsendQuery</code></a> вызовите <a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a> один или несколько раз, чтобы получить результаты. Функцию <a class="xref" href="libpq-async.html#LIBPQ-PQSENDQUERY"><code class="function">PQsendQuery</code></a> нельзя вызвать повторно (на том же самом соединении) до тех пор, пока <a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a> не вернёт нулевой указатель, означающий, что выполнение команды завершено.</p><p>В конвейерном режиме эту функцию вызывать нельзя.</p></dd><dt id="LIBPQ-PQSENDQUERYPARAMS"><span class="term"><code class="function">PQsendQueryParams</code><a id="id-1.7.3.11.4.15.2.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQSENDQUERYPARAMS" class="id_link">#</a></dt><dd><p>Отправляет серверу команду и обособленные параметры, не ожидая получения результатов. </p><pre class="synopsis">
int PQsendQueryParams(PGconn *conn,
                      const char *command,
                      int nParams,
                      const Oid *paramTypes,
                      const char * const *paramValues,
                      const int *paramLengths,
                      const int *paramFormats,
                      int resultFormat);
</pre><p> Эта функция эквивалентна функции <a class="xref" href="libpq-async.html#LIBPQ-PQSENDQUERY"><code class="function">PQsendQuery</code></a>, за исключением того, что параметры запроса можно указать отдельно от самой строки запроса. Эта функция обрабатывает свои параметры точно так же, как и функция <a class="xref" href="libpq-exec.html#LIBPQ-PQEXECPARAMS"><code class="function">PQexecParams</code></a>. Аналогично функции <a class="xref" href="libpq-exec.html#LIBPQ-PQEXECPARAMS"><code class="function">PQexecParams</code></a> она позволяет включить только одну команду в строку запроса.</p></dd><dt id="LIBPQ-PQSENDPREPARE"><span class="term"><code class="function">PQsendPrepare</code><a id="id-1.7.3.11.4.15.3.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQSENDPREPARE" class="id_link">#</a></dt><dd><p>Посылает запрос на создание подготовленного оператора с данными параметрами и не дожидается завершения его выполнения.</p><pre class="synopsis">
int PQsendPrepare(PGconn *conn,
                  const char *stmtName,
                  const char *query,
                  int nParams,
                  const Oid *paramTypes);
</pre><p> Это асинхронная версия функции  <a class="xref" href="libpq-exec.html#LIBPQ-PQPREPARE"><code class="function">PQprepare</code></a>. Она возвращает 1, если ей удалось отправить запрос, и 0 в противном случае. После её успешного вызова следует вызвать функцию <a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a>, чтобы определить, создал ли сервер подготовленный оператор. Эта функция обрабатывает свои параметры точно так же, как и функция  <a class="xref" href="libpq-exec.html#LIBPQ-PQPREPARE"><code class="function">PQprepare</code></a>.</p></dd><dt id="LIBPQ-PQSENDQUERYPREPARED"><span class="term"><code class="function">PQsendQueryPrepared</code><a id="id-1.7.3.11.4.15.4.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQSENDQUERYPREPARED" class="id_link">#</a></dt><dd><p>Посылает запрос на выполнение подготовленного оператора с данными параметрами, не ожидая получения результата. </p><pre class="synopsis">
int PQsendQueryPrepared(PGconn *conn,
                        const char *stmtName,
                        int nParams,
                        const char * const *paramValues,
                        const int *paramLengths,
                        const int *paramFormats,
                        int resultFormat);
</pre><p> Эта функция подобна функции <a class="xref" href="libpq-async.html#LIBPQ-PQSENDQUERYPARAMS"><code class="function">PQsendQueryParams</code></a>, но выполняемую команду определяет не текст запроса, а ссылка на предварительно подготовленный оператор. Эта функция обрабатывает свои параметры точно так же, как и функция <a class="xref" href="libpq-exec.html#LIBPQ-PQEXECPREPARED"><code class="function">PQexecPrepared</code></a>.</p></dd><dt id="LIBPQ-PQSENDDESCRIBEPREPARED"><span class="term"><code class="function">PQsendDescribePrepared</code><a id="id-1.7.3.11.4.15.5.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQSENDDESCRIBEPREPARED" class="id_link">#</a></dt><dd><p>Отправляет запрос на получение информации об указанном подготовленном операторе и не дожидается завершения выполнения запроса. </p><pre class="synopsis">
int PQsendDescribePrepared(PGconn *conn, const char *stmtName);
</pre><p> Это асинхронная версия функции <a class="xref" href="libpq-exec.html#LIBPQ-PQDESCRIBEPREPARED"><code class="function">PQdescribePrepared</code></a>. Она возвращает 1, если ей удалось отправить запрос, и 0 в противном случае. После её успешного вызова следует вызвать функцию <a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a> для получения результата. Эта функция обрабатывает свои параметры точно так же, как и функция <a class="xref" href="libpq-exec.html#LIBPQ-PQDESCRIBEPREPARED"><code class="function">PQdescribePrepared</code></a>.</p></dd><dt id="LIBPQ-PQSENDDESCRIBEPORTAL"><span class="term"><code class="function">PQsendDescribePortal</code><a id="id-1.7.3.11.4.15.6.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQSENDDESCRIBEPORTAL" class="id_link">#</a></dt><dd><p>Отправляет запрос на получение информации об указанном портале и не дожидается завершения выполнения запроса. </p><pre class="synopsis">
int PQsendDescribePortal(PGconn *conn, const char *portalName);
</pre><p> Это асинхронная версия функции <a class="xref" href="libpq-exec.html#LIBPQ-PQDESCRIBEPORTAL"><code class="function">PQdescribePortal</code></a>. Она возвращает 1, если ей удалось отправить запрос, и 0 в противном случае. После её успешного вызова следует вызвать функцию <a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a> для получения результата. Эта функция обрабатывает свои параметры точно так же, как и функция <a class="xref" href="libpq-exec.html#LIBPQ-PQDESCRIBEPORTAL"><code class="function">PQdescribePortal</code></a>.</p></dd><dt id="LIBPQ-PQGETRESULT"><span class="term"><code class="function">PQgetResult</code><a id="id-1.7.3.11.4.15.7.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQGETRESULT" class="id_link">#</a></dt><dd><p>Ожидает получения следующего результата после предшествующего вызова <a class="xref" href="libpq-async.html#LIBPQ-PQSENDQUERY"><code class="function">PQsendQuery</code></a>, <a class="xref" href="libpq-async.html#LIBPQ-PQSENDQUERYPARAMS"><code class="function">PQsendQueryParams</code></a>, <a class="xref" href="libpq-async.html#LIBPQ-PQSENDPREPARE"><code class="function">PQsendPrepare</code></a>, <a class="xref" href="libpq-async.html#LIBPQ-PQSENDQUERYPREPARED"><code class="function">PQsendQueryPrepared</code></a>, <a class="xref" href="libpq-async.html#LIBPQ-PQSENDDESCRIBEPREPARED"><code class="function">PQsendDescribePrepared</code></a>, <a class="xref" href="libpq-async.html#LIBPQ-PQSENDDESCRIBEPORTAL"><code class="function">PQsendDescribePortal</code></a> или <a class="xref" href="libpq-pipeline-mode.html#LIBPQ-PQPIPELINESYNC"><code class="function">PQpipelineSync</code></a> и возвращает его. Когда команда завершена и результатов больше не будет, возвращается нулевой указатель. </p><pre class="synopsis">
PGresult *PQgetResult(PGconn *conn);
</pre><p>Функция <a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a> должна вызываться повторно до тех пор, пока она не вернёт нулевой указатель, означающий, что команда завершена. (Если она вызвана, когда нет ни одной активной команды, тогда <a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a> просто возвратит нулевой указатель сразу же.) Каждый ненулевой результат, полученный от <a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a>, должен обрабатываться с помощью тех же самых функций доступа к структуре <code class="structname">PGresult</code>, которые были описаны выше. Не забывайте освобождать память, занимаемую каждым результирующим объектом, с помощью функции <a class="xref" href="libpq-exec.html#LIBPQ-PQCLEAR"><code class="function">PQclear</code></a> когда работа с этим объектом закончена. Обратите внимание, что <a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a> заблокируется, только если какая-либо команда активна, а необходимые ответные данные ещё не были прочитаны функцией <a class="xref" href="libpq-async.html#LIBPQ-PQCONSUMEINPUT"><code class="function">PQconsumeInput</code>
     </a>.</p><p>В конвейерном режиме <code class="function">PQgetResult</code> будет работать как обычно, если не произойдёт ошибка; для любого запроса, отправленного после запроса, вызвавшего ошибку, до следующей точки синхронизации (но не включая её), будет возвращаться специальный результат типа <code class="literal">PGRES_PIPELINE_ABORTED</code>, а после него — нулевой указатель. При достижении точки синхронизации конвейера будет возвращён результат типа <code class="literal">PGRES_PIPELINE_SYNC</code>. Результат следующего запроса после точки синхронизации поступит немедленно (то есть после точки синхронизации нулевой указатель не возвращается).</p><div class="note"><h3 class="title">Примечание</h3><p>Даже когда <a class="xref" href="libpq-exec.html#LIBPQ-PQRESULTSTATUS"><code class="function">PQresultStatus</code></a> показывает критическую ошибку, всё равно следует вызывать функцию <a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a> до тех пор, пока она не возвратит нулевой указатель, чтобы позволить <span class="application">libpq</span> полностью обработать информацию об ошибке.</p></div></dd></dl></div><p>Использование <a class="xref" href="libpq-async.html#LIBPQ-PQSENDQUERY"><code class="function">PQsendQuery</code></a> и <a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a> решает одну из проблем <a class="xref" href="libpq-exec.html#LIBPQ-PQEXEC"><code class="function">PQexec</code></a>: если строка запроса содержит несколько <acronym class="acronym">SQL</acronym>-команд, то результаты каждой из них можно получить индивидуально. (Между прочим, это позволяет организовать частичное совмещение обработки: клиент может обрабатывать результаты одной команды, в то время как сервер ещё работает с более поздними запросами, содержащимися в той же строке.)</p><p>Ещё одной часто требующейся функциональной возможностью, которую можно получить с помощью <a class="xref" href="libpq-async.html#LIBPQ-PQSENDQUERY"><code class="function">PQsendQuery</code></a> и <a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a>, является извлечение больших выборок по одной строке за раз. Это обсуждается в <a class="xref" href="libpq-single-row-mode.html" title="34.6. Построчное извлечение результатов запроса">Разделе 34.6</a>.</p><p>Сам по себе вызов <a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a> всё же приведёт к блокировке клиента до тех пор, пока сервер не завершит выполнение следующей <acronym class="acronym">SQL</acronym>-команды. Этого можно избежать с помощью надлежащего использования ещё двух функций: </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQCONSUMEINPUT"><span class="term"><code class="function">PQconsumeInput</code><a id="id-1.7.3.11.7.3.1.1.2" class="indexterm"></a>
     </span> <a href="#LIBPQ-PQCONSUMEINPUT" class="id_link">#</a></dt><dd><p>Если сервер готов передать данные, принять их. </p><pre class="synopsis">
int PQconsumeInput(PGconn *conn);
</pre><p><a class="xref" href="libpq-async.html#LIBPQ-PQCONSUMEINPUT"><code class="function">PQconsumeInput</code>
     </a> обычно возвращает 1, показывая, что <span class="quote">«<span class="quote">ошибки нет</span>»</span>, но возвращает 0, если имела место какая-либо проблема (в таком случае можно обратиться к функции <a class="xref" href="libpq-status.html#LIBPQ-PQERRORMESSAGE"><code class="function">PQerrorMessage</code></a> за уточнением). Обратите внимание, что результат не говорит, были ли какие-либо входные данные фактически собраны. После вызова функции <a class="xref" href="libpq-async.html#LIBPQ-PQCONSUMEINPUT"><code class="function">PQconsumeInput</code>
     </a> приложение может проверить <a class="xref" href="libpq-async.html#LIBPQ-PQISBUSY"><code class="function">PQisBusy</code></a> и/или <code class="function">PQnotifies</code>, чтобы посмотреть, не изменилось ли их состояние.</p><p><a class="xref" href="libpq-async.html#LIBPQ-PQCONSUMEINPUT"><code class="function">PQconsumeInput</code>
     </a> можно вызвать, даже если приложение ещё не готово иметь дело с результатом или уведомлением. Функция прочитает доступные данные и сохранит их в буфере, при этом обрабатывая условие готовности к чтению функции <code class="function">select()</code>. Таким образом, приложение может использовать <a class="xref" href="libpq-async.html#LIBPQ-PQCONSUMEINPUT"><code class="function">PQconsumeInput</code>
     </a>&gt;, чтобы немедленно обработать это состояние <code class="function">select()</code>, а изучать результаты позже.</p></dd><dt id="LIBPQ-PQISBUSY"><span class="term"><code class="function">PQisBusy</code><a id="id-1.7.3.11.7.3.2.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQISBUSY" class="id_link">#</a></dt><dd><p>Возвращает 1, если команда занята работой, то есть функция <a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a> в случае вызова будет заблокирована в ожидании ввода. Возвращаемое значение 0 показывает, что функция <a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a> при её вызове гарантированно не будет заблокирована. </p><pre class="synopsis">
int PQisBusy(PGconn *conn);
</pre><p>Функция <a class="xref" href="libpq-async.html#LIBPQ-PQISBUSY"><code class="function">PQisBusy</code></a> сама не будет пытаться прочитать данные с сервера, поэтому, чтобы выйти из занятого состояния, необходимо вызвать <a class="xref" href="libpq-async.html#LIBPQ-PQCONSUMEINPUT"><code class="function">PQconsumeInput</code>
     </a>, .</p></dd></dl></div><p>В типичном приложении, использующем эти функции, будет главный цикл, в котором с применением функций <code class="function">select()</code> или <code class="function">poll()</code> организуется ожидание всех условий, на которые нужно реагировать в этом цикле. Одним из условий будет поступление на вход данных от сервера, что в терминах функции <code class="function">select()</code> означает наличие данных, которые можно прочитать через файловый дескриптор, выдаваемый функцией <a class="xref" href="libpq-status.html#LIBPQ-PQSOCKET"><code class="function">PQsocket</code></a>. Когда в главном цикле обнаруживаются готовые входные данные, следует вызвать <a class="xref" href="libpq-async.html#LIBPQ-PQCONSUMEINPUT"><code class="function">PQconsumeInput</code>
     </a>, чтобы прочитать их. После этого можно вызвать <a class="xref" href="libpq-async.html#LIBPQ-PQISBUSY"><code class="function">PQisBusy</code></a>, и если в результате получен 0 (что свидетельствует о свободном состоянии), затем вызвать <a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a>. В главном цикле также можно вызвать <code class="function">PQnotifies</code>, чтобы проверить сообщения <code class="command">NOTIFY</code> (см. <a class="xref" href="libpq-notify.html" title="34.9. Асинхронное уведомление">Раздел 34.9</a>).</p><p>Клиент, который использует <a class="xref" href="libpq-async.html#LIBPQ-PQSENDQUERY"><code class="function">PQsendQuery</code></a>/<a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a>, может также попытаться отменить команду, которая всё ещё обрабатывается сервером; см. <a class="xref" href="libpq-cancel.html" title="34.7. Отмена запросов в процессе выполнения">Раздел 34.7</a>. Но независимо от возвращаемого значения функции <a class="xref" href="libpq-cancel.html#LIBPQ-PQCANCEL"><code class="function">PQcancel</code></a>, приложение должно продолжать обычную последовательность операций чтения результатов запроса, вызывая <a class="xref" href="libpq-async.html#LIBPQ-PQGETRESULT"><code class="function">PQgetResult</code></a>. В случае успешной отмены команда просто завершится раньше, чем она завершилась бы, выполняясь до конца.</p><p>Используя функции, описанные выше, можно избежать блокирования, ожидая ввода от сервера баз данных. Однако всё же возможно, что приложение будет заблокировано в ожидании отправки вывода на сервер. Это бывает относительно нечасто, но может иметь место, если отправлены очень длинные SQL-команды или значения данных. (Однако это значительно более вероятно, если приложение отправляет данные через команду <code class="command">COPY IN</code>.) Чтобы предотвратить эту возможность и достичь совершенно неблокирующего режима работы с базой данных, можно использовать следующие дополнительные функции. </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQSETNONBLOCKING"><span class="term"><code class="function">PQsetnonblocking</code><a id="id-1.7.3.11.10.2.1.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQSETNONBLOCKING" class="id_link">#</a></dt><dd><p>Устанавливает неблокирующий статус подключения. </p><pre class="synopsis">
int PQsetnonblocking(PGconn *conn, int arg);
</pre><p>Устанавливает состояние подключения как неблокирующее, если <em class="parameter"><code>arg</code></em> равен 1, или блокирующее, если <em class="parameter"><code>arg</code></em> равен 0. Возвращает 0 в случае успешного завершения и -1 в случае ошибки.</p><p>В неблокирующем состоянии успешные вызовы <a class="xref" href="libpq-async.html#LIBPQ-PQSENDQUERY"><code class="function">PQsendQuery</code></a>, <a class="xref" href="libpq-copy.html#LIBPQ-PQPUTLINE"><code class="function">PQputline</code></a>, <a class="xref" href="libpq-copy.html#LIBPQ-PQPUTNBYTES"><code class="function">PQputnbytes</code></a>, <a class="xref" href="libpq-copy.html#LIBPQ-PQPUTCOPYDATA"><code class="function">PQputCopyData</code></a> и <a class="xref" href="libpq-copy.html#LIBPQ-PQENDCOPY"><code class="function">PQendcopy</code></a> не блокируются; изменения сохраняются в локальном буфере вывода до тех пор, пока не будут сброшены. Неудачные вызовы возвращают ошибку, и их придётся повторить.</p><p>Обратите внимание, что функция <a class="xref" href="libpq-exec.html#LIBPQ-PQEXEC"><code class="function">PQexec</code></a> не соблюдает неблокирующий режим. Если она вызывается, она всё равно работает в блокирующем режиме.</p></dd><dt id="LIBPQ-PQISNONBLOCKING"><span class="term"><code class="function">PQisnonblocking</code><a id="id-1.7.3.11.10.2.2.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQISNONBLOCKING" class="id_link">#</a></dt><dd><p>Возвращает режим блокирования для подключения базы данных. </p><pre class="synopsis">
int PQisnonblocking(const PGconn *conn);
</pre><p>Возвращает 1, если подключение установлено в неблокирующем режиме, и 0, если режим блокирующий.</p></dd><dt id="LIBPQ-PQFLUSH"><span class="term"><code class="function">PQflush</code><a id="id-1.7.3.11.10.2.3.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQFLUSH" class="id_link">#</a></dt><dd><p>Пытается сбросить любые выходные данные, стоящие в очереди, на сервер. Возвращает 0 в случае успеха (или если очередь на отправку пуста), -1 в случае сбоя по какой-либо причине или 1, если она ещё не смогла отправить все данные, находящиеся в очереди (этот случай может иметь место, только если соединение неблокирующее). </p><pre class="synopsis">
int PQflush(PGconn *conn);
</pre></dd></dl></div><p>После отправки любой команды или данных через неблокирующее подключение следует вызвать функцию <a class="xref" href="libpq-async.html#LIBPQ-PQFLUSH"><code class="function">PQflush</code></a>. Если она возвратит 1, подождите, пока сокет станет готовым к чтению или записи. Если он станет готовым к записи, снова вызовите <a class="xref" href="libpq-async.html#LIBPQ-PQFLUSH"><code class="function">PQflush</code></a>. Если он станет готовым к чтению, вызовите <a class="xref" href="libpq-async.html#LIBPQ-PQCONSUMEINPUT"><code class="function">PQconsumeInput</code>
     </a>, а затем вновь вызовите <a class="xref" href="libpq-async.html#LIBPQ-PQFLUSH"><code class="function">PQflush</code></a>. Повторяйте до тех пор, пока <a class="xref" href="libpq-async.html#LIBPQ-PQFLUSH"><code class="function">PQflush</code></a> не возвратит 0. (Необходимо выполнять проверку на состояние готовности к чтению и забирать входные данные с помощью <a class="xref" href="libpq-async.html#LIBPQ-PQCONSUMEINPUT"><code class="function">PQconsumeInput</code>
     </a>, потому что сервер может заблокироваться, пытаясь отправить нам данные, например, сообщения NOTICE, и не будет читать наши данные до тех пор, пока мы не прочитаем его.) Как только <a class="xref" href="libpq-async.html#LIBPQ-PQFLUSH"><code class="function">PQflush</code></a> возвратит 0, подождите, пока сокет не станет готовым к чтению, а затем прочитайте ответ, как описано выше.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="libpq-exec.html" title="34.3. Функции для исполнения команд">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="libpq.html" title="Глава 34. libpq — библиотека для языка C">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="libpq-pipeline-mode.html" title="34.5. Конвейерный режим">След.</a></td></tr><tr><td width="40%" align="left" valign="top">34.3. Функции для исполнения команд </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 34.5. Конвейерный режим</td></tr></table></div></body></html>