<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>38.15. Информация для оптимизации операторов</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="xoper.html" title="38.14. Пользовательские операторы" /><link rel="next" href="xindex.html" title="38.16. Интерфейсы расширений для индексов" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">38.15. Информация для оптимизации операторов</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="xoper.html" title="38.14. Пользовательские операторы">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="extend.html" title="Глава 38. Расширение SQL">Наверх</a></td><th width="60%" align="center">Глава 38. Расширение <acronym class="acronym">SQL</acronym></th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="xindex.html" title="38.16. Интерфейсы расширений для индексов">След.</a></td></tr></table><hr /></div><div class="sect1" id="XOPER-OPTIMIZATION"><div class="titlepage"><div><div><h2 class="title" style="clear: both">38.15. Информация для оптимизации операторов <a href="#XOPER-OPTIMIZATION" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="xoper-optimization.html#XOPER-COMMUTATOR">38.15.1. <code class="literal">COMMUTATOR</code></a></span></dt><dt><span class="sect2"><a href="xoper-optimization.html#XOPER-NEGATOR">38.15.2. <code class="literal">NEGATOR</code></a></span></dt><dt><span class="sect2"><a href="xoper-optimization.html#XOPER-RESTRICT">38.15.3. <code class="literal">RESTRICT</code></a></span></dt><dt><span class="sect2"><a href="xoper-optimization.html#XOPER-JOIN">38.15.4. <code class="literal">JOIN</code></a></span></dt><dt><span class="sect2"><a href="xoper-optimization.html#XOPER-HASHES">38.15.5. <code class="literal">HASHES</code></a></span></dt><dt><span class="sect2"><a href="xoper-optimization.html#XOPER-MERGES">38.15.6. <code class="literal">MERGES</code></a></span></dt></dl></div><a id="id-1.8.3.18.2" class="indexterm"></a><p>Определение оператора в <span class="productname">PostgreSQL</span> может включать различные дополнительные предложения, которые сообщают системе полезные сведения о поведении оператора. Старайтесь задавать эти предложения при возможности, так как они могут значительно ускорить выполнение запросов, использующих данный оператор. Но если вы задаёте их, убедитесь, что они корректны! Неправильное применение предложений оптимизации может привести к замедлению запросов, неочевидным ошибочным результатам и другим неприятностям. Если вы не уверены в правильности предложения оптимизации, лучше вовсе не использовать его; единственным последствием будет то, что запросы будут работать медленнее, чем могли бы.</p><p>В будущих версиях <span class="productname">PostgreSQL</span> могут быть добавлены и другие предложения. Здесь описываются те, что поддерживаются версией 16.3.</p><p>Также для функции, реализующей оператор, имеется возможность добавить вспомогательную функцию для планировщика, которая будет передавать другую информацию о поведении оператора. За дополнительными сведениями обратитесь к <a class="xref" href="xfunc-optimization.html" title="38.11. Информация для оптимизации функций">Разделу 38.11</a>.</p><div class="sect2" id="XOPER-COMMUTATOR"><div class="titlepage"><div><div><h3 class="title">38.15.1. <code class="literal">COMMUTATOR</code> <a href="#XOPER-COMMUTATOR" class="id_link">#</a></h3></div></div></div><p>Предложение <code class="literal">COMMUTATOR</code>, если представлено, задаёт оператор, коммутирующий для определяемого. Оператор A является коммутирующим для оператора B, если (x A y) равняется (y B x) для всех возможных значений x, y. Заметьте, что B также будет коммутирующим для A. Например, операторы <code class="literal">&lt;</code> и <code class="literal">&gt;</code> для конкретного типа данных обычно являются коммутирующими друг для друга, а оператор <code class="literal">+</code> — коммутирующий для себя. Но традиционный оператор <code class="literal">-</code> коммутирующего не имеет.</p><p>Тип левого операнда оператора должен совпадать с типом правого операнда коммутирующего для него оператора, и наоборот. Поэтому имя коммутирующего оператора — это всё, что <span class="productname">PostgreSQL</span> должен знать, чтобы найти коммутатор, и всё, что нужно указать в предложении <code class="literal">COMMUTATOR</code>.</p><p>Информация о коммутирующих операторах крайне важна для операторов, которые будут применяться в индексах и условиях соединения, так как, используя её, оптимизатор запросов может <span class="quote">«<span class="quote">переворачивать</span>»</span> такие выражения и получать формы, необходимые для разных типов планов. Например, рассмотрим запрос с предложением WHERE <code class="literal">tab1.x = tab2.y</code>, где <code class="literal">tab1.x</code> и <code class="literal">tab2.y</code> имеют пользовательский тип, и предположим, что у нас есть индекс по столбцу <code class="literal">tab2.y</code>. Оптимизатор сможет задействовать сканирование по индексу, только если ему удастся перевернуть выражение <code class="literal">tab2.y = tab1.x</code>, так как механизм сканирования по индексу ожидает, что индексируемый столбец находится слева от оператора. <span class="productname">PostgreSQL</span> сам по себе <span class="emphasis"><em>не</em></span> будет полагать, что такое преобразование возможно — это должен определить создатель оператора <code class="literal">=</code>, добавив информацию о коммутирующем операторе.</p><p>Когда вы определяете оператор, коммутирующий сам для себя, вы делаете именно это. Если же вы определяете пару коммутирующих операторов, возникает небольшое затруднение: как оператор, определяемый первым, может ссылаться на другой, ещё не определённый? Есть два решения этой проблемы: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Во-первых, можно опустить предложение <code class="literal">COMMUTATOR</code> для первого оператора, который вы определяете, а затем добавить его в определении второго. Так как <span class="productname">PostgreSQL</span> знает, что коммутирующие операторы связаны парами, встречая второе определение, он автоматически возвращается к первому и добавляет в него недостающее предложение <code class="literal">COMMUTATOR</code>.</p></li><li class="listitem"><p>Во-вторых, можно добавить предложение <code class="literal">COMMUTATOR</code> в оба определения. Когда <span class="productname">PostgreSQL</span> обрабатывает первое определение и видит, что <code class="literal">COMMUTATOR</code> ссылается на несуществующий оператор, в системном каталоге создаётся фиктивная запись для этого оператора. В этой фиктивной записи актуальны будут только имя оператора, типы левого и правого операндов, а также тип результата, так как это всё, что <span class="productname">PostgreSQL</span> может определить в этот момент. Запись первого оператора будет связана с этой фиктивной записью. Затем, когда вы определите второй оператор, система внесёт в эту фиктивную запись дополнительную информацию из второго определения. Если вы попытаетесь применить фиктивный оператор, прежде чем он будет полностью определён, вы просто получите сообщение об ошибке.</p></li></ul></div></div><div class="sect2" id="XOPER-NEGATOR"><div class="titlepage"><div><div><h3 class="title">38.15.2. <code class="literal">NEGATOR</code> <a href="#XOPER-NEGATOR" class="id_link">#</a></h3></div></div></div><p>Предложение <code class="literal">NEGATOR</code>, если присутствует, задаёт оператор, обратный к определяемому. Оператор A является обратным к оператору B, если они оба возвращают логический результат и (x A y) равняется NOT (x B y) для всех возможных x, y. Заметьте, что B так же является обратным к A. Например, операторы <code class="literal">&lt;</code> и <code class="literal">&gt;=</code> составляют пару обратных друг к другу для большинства типов данных. Никакой оператор не может быть обратным к себе же.</p><p>В отличие от коммутирующих операторов, два унарных оператора вполне могут быть обратными к друг другу; это будет означать, что (A x) равняется NOT (B x) для всех x.</p><p>У оператора, обратного данному, типы левого и/или правого операнда должны соответствовать типам данного оператора, так же как и с предложением <code class="literal">COMMUTATOR</code>; отличие только в том, что имя оператора задаётся в предложении <code class="literal">NEGATOR</code>.</p><p>Указание обратного оператора очень полезно для оптимизатора запросов, так как это позволяет упростить выражение вида <code class="literal">NOT (x = y)</code> до <code class="literal">x &lt;&gt; y</code>. Такие выражения не так редки, как может показаться, так как операции <code class="literal">NOT</code> могут добавляться автоматически в результате реорганизаций выражений.</p><p>Пару обратных операторов можно определить теми же способами, что были описаны ранее для пары коммутирующих.</p></div><div class="sect2" id="XOPER-RESTRICT"><div class="titlepage"><div><div><h3 class="title">38.15.3. <code class="literal">RESTRICT</code> <a href="#XOPER-RESTRICT" class="id_link">#</a></h3></div></div></div><p>Предложение <code class="literal">RESTRICT</code>, если представлено, определяет функцию оценки избирательности ограничения для оператора. (Заметьте, что в нём задаётся имя функции, а не оператора.) Предложения <code class="literal">RESTRICT</code> имеют смысл только для бинарных операторов, возвращающих <code class="type">boolean</code>. Идея оценки избирательности ограничения заключается в том, чтобы определить, какой процент строк в таблице будет удовлетворять условию <code class="literal">WHERE</code> вида: </p><pre class="programlisting">column OP constant</pre><p> для текущего оператора и определённого значения константы. Это помогает оптимизатору примерно определить, сколько строк будет исключено предложениями <code class="literal">WHERE</code> такого вида. (ВЫ спросите, а что если константа находится слева? Ну, собственно для таких случаев и задаётся <code class="literal">COMMUTATOR</code>...)</p><p>Рамки данной главы не позволяют описать разработку новых функций оценки избирательности ограничения, но обычно можно использовать один из стандартных системных оценщиков для большинства дополнительных операторов. Стандартные оценщики ограничений следующие: </p><table border="0" summary="Simple list" class="simplelist"><tr><td><code class="function">eqsel</code> для <code class="literal">=</code></td></tr><tr><td><code class="function">neqsel</code> для <code class="literal">&lt;&gt;</code></td></tr><tr><td><code class="function">scalarltsel</code> для <code class="literal">&lt;</code></td></tr><tr><td><code class="function">scalarlesel</code> для <code class="literal">&lt;=</code></td></tr><tr><td><code class="function">scalargtsel</code> для <code class="literal">&gt;</code></td></tr><tr><td><code class="function">scalargesel</code> для <code class="literal">&gt;=</code></td></tr></table><p>Часто вы можете обойтись функциями <code class="function">eqsel</code> и <code class="function">neqsel</code> для операторов с очень высокой или низкой избирательностью, даже если это не операторы собственно равенства или неравенства. Например, геометрические операторы приблизительного равенства используют <code class="function">eqsel</code> в предположении, что соответствующие (равные) элементы будут составлять только небольшой процент от всех записей таблицы.</p><p>Функции <code class="function">scalarltsel</code>, <code class="function">scalarlesel</code>, <code class="function">scalargtsel</code> и <code class="function">scalargesel</code> можно использовать для сравнений с типами данных, которые могут быть каким-либо осмысленным образом преобразованы в числовые скалярные значения для сравнения диапазонов. Если возможно, добавьте свой тип данных в число типов, которые понимает функция <code class="function">convert_to_scalar()</code>, реализованная в <code class="filename">src/backend/utils/adt/selfuncs.c</code>. (Когда-нибудь на смену ей придут специализированные функции, которые будут устанавливаться для конкретных типов в определённом столбце системного каталога <code class="classname">pg_type</code>; но пока этого не произошло.) Если вы этого не сделаете, всё будет работать, но оценки оптимизатора будут не так хороши, как могли бы быть.</p><p>Есть ещё одна полезная функция оценки избирательности, <code class="function">matchingsel</code>, которая будет работать практически с любым бинарным оператором, если для его входных типов данных собирается статистика MCV и/или строится гистограмма. По умолчанию эта оценка в два раза больше той, что выдаёт <code class="function">eqsel</code>, таким образом, данная функция наиболее полезна для операторов сравнения, более избирательных, чем оператор равенства. (Также можно вызвать нижележащую функцию <code class="function">generic_restriction_selectivity</code>, передав ей другую оценку по умолчанию.)</p><p>Для геометрических операторов разработаны дополнительные функции оценки избирательности в <code class="filename">src/backend/utils/adt/geo_selfuncs.c</code>: <code class="function">areasel</code>, <code class="function">positionsel</code> и <code class="function">contsel</code>. На момент написания документации это просто заглушки, но вы тем не менее вполне можете использовать (или, ещё лучше, доработать) их.</p></div><div class="sect2" id="XOPER-JOIN"><div class="titlepage"><div><div><h3 class="title">38.15.4. <code class="literal">JOIN</code> <a href="#XOPER-JOIN" class="id_link">#</a></h3></div></div></div><p>Предложение <code class="literal">JOIN</code>, если представлено, определяет функцию оценки избирательности соединения для оператора. (Заметьте, что в нём задаётся имя функции, а не оператора.) Предложения <code class="literal">JOIN</code> имеют смысл только для бинарных операторов, возвращающих <code class="type">boolean</code>. Идея оценки избирательности соединения заключается в том, чтобы угадать, какой процент строк в паре таблиц будет удовлетворять условию <code class="literal">WHERE</code> следующего вида: </p><pre class="programlisting">table1.column1 OP table2.column2</pre><p> для текущего оператора. Как и <code class="literal">RESTRICT</code>, это предложение очень помогает оптимизатору, позволяя ему выяснить, какой из возможных вариантов соединения скорее всего окажется выгоднее.</p><p>Как и ранее, в этой главе мы не будем пытаться рассказать, как написать функцию оценивания избирательности соединения, а просто отметим, что вы можете использовать один из подходящих стандартных оценщиков: </p><table border="0" summary="Simple list" class="simplelist"><tr><td><code class="function">eqjoinsel</code> для <code class="literal">=</code></td></tr><tr><td><code class="function">neqjoinsel</code> для <code class="literal">&lt;&gt;</code></td></tr><tr><td><code class="function">scalarltjoinsel</code> для <code class="literal">&lt;</code></td></tr><tr><td><code class="function">scalarlejoinsel</code> для <code class="literal">&lt;=</code></td></tr><tr><td><code class="function">scalargtjoinsel</code> для <code class="literal">&gt;</code></td></tr><tr><td><code class="function">scalargejoinsel</code> для <code class="literal">&gt;=</code></td></tr><tr><td><code class="function">matchingjoinsel</code> для типовых операторов сопоставления</td></tr><tr><td><code class="function">areajoinsel</code> для сравнений областей в плоскости</td></tr><tr><td><code class="function">positionjoinsel</code> для сравнения положений в плоскости</td></tr><tr><td><code class="function">contjoinsel</code> для проверки на включение в плоскости</td></tr></table></div><div class="sect2" id="XOPER-HASHES"><div class="titlepage"><div><div><h3 class="title">38.15.5. <code class="literal">HASHES</code> <a href="#XOPER-HASHES" class="id_link">#</a></h3></div></div></div><p>Предложение <code class="literal">HASHES</code>, если присутствует, говорит системе, что для соединений с применением этого оператора допустимо использовать метод соединения по хешу. <code class="literal">HASHES</code> имеет смысл только для бинарного оператора, который возвращает <code class="literal">boolean</code>, и на практике этот оператор должен выражать равенство значений некоторого типа данных или пары типов данных.</p><p>Соединение по хешу базируется на том предположении, что оператор соединения возвращает истину только для таких пар значений слева и справа, для которых получается одинаковый хеш. Если два значения оказываются в разных ячейках хеша, операция соединения никогда не будет сравнивать их, неявно подразумевая, что результат оператора соединения в этом случае должен быть ложным. Поэтому не имеет никакого смысла указывать <code class="literal">HASHES</code> для операторов, которые не представляют какую-любо форму равенства. В большинстве случаев практический смысл в поддержке хеширования есть только для операторов, принимающих один тип данных с обеих сторон. Однако иногда возможно разработать хеш-функции, совместимые сразу с несколькими типами данных; то есть, функции, которые будут выдавать одинаковые хеш-коды для <span class="quote">«<span class="quote">равных</span>»</span> значений, несмотря на то, что эти значения будут представлены по-разному. Например, довольно легко функции с такой особенностью реализуются для хеширования целых чисел различного размера.</p><p>Чтобы оператор соединения имел характеристику <code class="literal">HASHES</code>, он должен входить в семейство операторов индексирования по хешу. Это требование откладывается, когда оператор только создаётся, ведь нужное семейство операторов, разумеется, ещё не может существовать. Но при попытке использовать такой оператор для соединения по хешу, возникнет ошибка во время выполнения, если такого семейства не окажется. Системе необходимо знать семейство операторов, чтобы найти функции для хеширования типа(ов) входных данных оператора. Конечно, вы должны также определить подходящие функции хеширования, прежде чем сможете создать семейство операторов.</p><p>При подготовке функции хеширования обязательно позаботьтесь о том, чтобы она всегда выдавала нужный результат, вне зависимости от особенностей машинной архитектуры. Например, если ваш тип данных представлен в структуре, в которой есть незначащие дополняющие биты, нельзя просто передать всю структуру функции <code class="function">hash_any</code>. (Это возможно, только если все ваши операторы и функции гарантированно очищают незначащие биты, что является рекомендуемой стратегией.) В качестве другого примера можно привести типы с плавающей точкой в стандарте <acronym class="acronym">IEEE</acronym>, в которых отрицательный ноль и положительный ноль — различные значения (отличаются на уровне битов), но при сравнении они считаются равными. Если значение с плавающей точкой может содержать отрицательный ноль, требуются дополнительные действия, чтобы для него выдавался тот же хеш, что и для положительного нуля.</p><p>Оператор соединения по хешу должен иметь коммутирующий (это может быть тот же оператор, если у него два операнда одного типа, либо связанный оператор равенства, в противном случае), относящийся к тому же семейству операторов. В случае его отсутствия, при попытке использования оператора возможны ошибки планировщика. Также желательно (хотя это строго не требуется), чтобы в семействе операторов хеширования, поддерживающем несколько типов данных, определялись операторы равенства для всех комбинаций этих типов данных; это способствует лучшей оптимизации.</p><div class="note"><h3 class="title">Примечание</h3><p>Функция, реализующая оператор соединения по хешу, должна быть постоянной (IMMUTABLE) или стабильной (STABLE). Если эта функция изменчивая (VOLATILE), система никогда не будет применять этот оператор для соединения по хешу.</p></div><div class="note"><h3 class="title">Примечание</h3><p>Если оператор соединения по хешу реализуется строгой функцией (STRICT), эта функция также должна быть полной: то есть она должна возвращать true или false, но не NULL, для любых двух аргументов, отличных от NULL. Если это правило не соблюдается, оптимизация операций <code class="literal">IN</code> с хешем может приводить к неверным результатам. (В частности, выражение <code class="literal">IN</code> может вернуть false, когда правильным ответом, согласно стандарту, должен быть NULL, либо выдать ошибку с сообщением о том, что оно не готов к результату NULL.)</p></div></div><div class="sect2" id="XOPER-MERGES"><div class="titlepage"><div><div><h3 class="title">38.15.6. <code class="literal">MERGES</code> <a href="#XOPER-MERGES" class="id_link">#</a></h3></div></div></div><p>Предложение <code class="literal">MERGES</code>, если присутствует, говорит системе, что для соединений с применением этого оператора допустимо использовать метод соединения слиянием. <code class="literal">MERGES</code> имеет смысл только для бинарного оператора, который возвращает <code class="literal">boolean</code>, и на практике этот оператор должен выражать равенство значений некоторого типа данных или пары типов данных.</p><p>Идея объединения слиянием заключается в упорядочивании таблиц слева и справа и затем параллельном сканировании их. Поэтому оба типа данных должны поддерживать сортировку в полном объёме, а оператор соединения должен давать положительный результат только для пар значений, оказавшихся в <span class="quote">«<span class="quote">одном месте</span>»</span> при определённом порядке сортировки. На практике это означает, что оператор соединения должен работать как проверка на равенство. Но при этом возможно объединить слиянием два различных типа данных, если они совместимы логически. Например, оператор проверки равенства <code class="type">smallint</code> и <code class="type">integer</code> может применяться для соединений слиянием; понадобятся только операторы сортировки, приводящие оба типа данных в логически совместимые последовательности.</p><p>Чтобы оператор соединения имел характеристику <code class="literal">MERGES</code>, он должен являться членом семейства операторов индекса <code class="literal">btree</code>, реализующим равенство. Это требование откладывается, когда оператор только создаётся, ведь нужное семейство операторов, разумеется, ещё не может существовать. Но этот оператор не будет фактически применяться для соединений слиянием, пока не будет найдено соответствующее семейство операторов. Таким образом, флаг <code class="literal">MERGES</code> только подсказывает планировщику, что стоит обратиться к соответствующему семейству.</p><p>Оператор соединения слиянием должен иметь коммутирующий (это может быть тот же оператор, если у него два операнда одного типа, либо связанный оператор равенства, в противном случае), относящийся к тому же семейству операторов. В случае его отсутствия, при попытке использования оператора возможны ошибки планировщика. Также желательно (хотя это строго не требуется), чтобы в семействе операторов <code class="literal">btree</code>, поддерживающем несколько типов данных, определялись операторы равенства для всех комбинаций этих типов данных; это способствует лучшей оптимизации.</p><div class="note"><h3 class="title">Примечание</h3><p>Функция, реализующая оператор соединения слиянием, должна быть постоянной (IMMUTABLE) или стабильной (STABLE). Если эта функция изменчивая (VOLATILE), система никогда не будет применять этот оператор для соединения слиянием.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="xoper.html" title="38.14. Пользовательские операторы">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="extend.html" title="Глава 38. Расширение SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="xindex.html" title="38.16. Интерфейсы расширений для индексов">След.</a></td></tr><tr><td width="40%" align="left" valign="top">38.14. Пользовательские операторы </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 38.16. Интерфейсы расширений для индексов</td></tr></table></div></body></html>