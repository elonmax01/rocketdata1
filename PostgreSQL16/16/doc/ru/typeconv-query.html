<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>10.4. Хранимое значение</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="typeconv-func.html" title="10.3. Функции" /><link rel="next" href="typeconv-union-case.html" title="10.5. UNION, CASE и связанные конструкции" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">10.4. Хранимое значение</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="typeconv-func.html" title="10.3. Функции">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="typeconv.html" title="Глава 10. Преобразование типов">Наверх</a></td><th width="60%" align="center">Глава 10. Преобразование типов</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="typeconv-union-case.html" title="10.5. UNION, CASE и связанные конструкции">След.</a></td></tr></table><hr /></div><div class="sect1" id="TYPECONV-QUERY"><div class="titlepage"><div><div><h2 class="title" style="clear: both">10.4. Хранимое значение <a href="#TYPECONV-QUERY" class="id_link">#</a></h2></div></div></div><p>Значения, вставляемые в таблицу, преобразуется в тип данных целевого столбца по следующему алгоритму.</p><div class="procedure" id="id-1.5.9.9.3"><p class="title"><strong>Преобразование по типу хранения</strong></p><ol class="procedure" type="1"><li class="step"><p>Проверить точное совпадение с целевым типом.</p></li><li class="step"><p>Если типы не совпадают, попытаться привести тип к целевому. Это возможно, если в каталоге <code class="structname">pg_cast</code> (см. <a class="xref" href="sql-createcast.html" title="CREATE CAST"><span class="refentrytitle">CREATE CAST</span></a>) зарегистрировано <em class="firstterm">приведение присваивания</em> между двумя типами. Если же результат выражения — строка неизвестного типа, содержимое этой строки будет подано на вход процедуре ввода целевого типа.</p></li><li class="step"><p>Проверить, не требуется ли приведение размера для целевого типа. Приведение размера — это преобразование типа к такому же. Если это приведение описано в каталоге <code class="structname">pg_cast</code>, применить к его к результату выражения, прежде чем сохранить в целевом столбце. Функция, реализующая такое приведение, всегда принимает дополнительный параметр типа <code class="type">integer</code>, в котором передаётся значение <code class="structfield">atttypmod</code> для целевого столбца (обычно это её объявленный размер, хотя интерпретироваться значение <code class="structfield">atttypmod</code> для разных типов данных может по-разному), и третий параметр типа <code class="type">boolean</code>, передающий признак явное/неявное преобразование. Функция приведения отвечает за все операции с длиной, включая её проверку и усечение данных.</p></li></ol></div><div class="example" id="id-1.5.9.9.4"><p class="title"><strong>Пример 10.9. Преобразование для типа хранения <code class="type">character</code></strong></p><div class="example-contents"><p>Следующие запросы показывают, что сохраняемое значение подгоняется под размер целевого столбца, объявленного как <code class="type">character(20)</code>: </p><pre class="screen">
CREATE TABLE vv (v character(20));
INSERT INTO vv SELECT 'abc' || 'def';
SELECT v, octet_length(v) FROM vv;

          v           | octet_length
----------------------+--------------
 abcdef               |           20
(1 row)
</pre><p>Суть происходящего здесь в том, что две константы неизвестного типа по умолчанию воспринимаются как значения <code class="type">text</code>, что позволяет применить к ним оператор <code class="literal">||</code> как оператор конкатенации значений <code class="type">text</code>. Затем результат оператора, имеющий тип <code class="type">text</code>, приводится к типу <code class="type">bpchar</code> (<span class="quote">«<span class="quote">blank-padded char</span>»</span> (символы, дополненные пробелами), внутреннее имя типа <code class="type">character</code>) в соответствии с типом целевого столбца. (Так как типы <code class="type">text</code> и <code class="type">bpchar</code> двоично-совместимы, при этом преобразовании реальный вызов функции не добавляется.) Наконец, в системном каталоге находится функция изменения размера <code class="literal">bpchar(bpchar, integer, boolean)</code> и применяется для результата оператора и длины столбца. Эта связанная с типом функция проверяет длину данных и добавляет недостающие пробелы.</p></div></div><br class="example-break" /></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="typeconv-func.html" title="10.3. Функции">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="typeconv.html" title="Глава 10. Преобразование типов">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="typeconv-union-case.html" title="10.5. UNION, CASE и связанные конструкции">След.</a></td></tr><tr><td width="40%" align="left" valign="top">10.3. Функции </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 10.5. <code class="literal">UNION</code>, <code class="literal">CASE</code> и связанные конструкции</td></tr></table></div></body></html>