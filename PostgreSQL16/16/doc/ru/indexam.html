<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Глава 64. Определение интерфейса для индексных методов доступа</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="tableam.html" title="Глава 63. Определение интерфейса для табличных методов доступа" /><link rel="next" href="index-api.html" title="64.1. Базовая структура API для индексов" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">Глава 64. Определение интерфейса для индексных методов доступа</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="tableam.html" title="Глава 63. Определение интерфейса для табличных методов доступа">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="internals.html" title="Часть VII. Внутреннее устройство">Наверх</a></td><th width="60%" align="center">Часть VII. Внутреннее устройство</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="index-api.html" title="64.1. Базовая структура API для индексов">След.</a></td></tr></table><hr /></div><div class="chapter" id="INDEXAM"><div class="titlepage"><div><div><h2 class="title">Глава 64. Определение интерфейса для индексных методов доступа</h2></div></div></div><div class="toc"><p><strong>Содержание</strong></p><dl class="toc"><dt><span class="sect1"><a href="index-api.html">64.1. Базовая структура API для индексов</a></span></dt><dt><span class="sect1"><a href="index-functions.html">64.2. Функции для индексных методов доступа</a></span></dt><dt><span class="sect1"><a href="index-scanning.html">64.3. Сканирование индекса</a></span></dt><dt><span class="sect1"><a href="index-locking.html">64.4. Замечания о блокировке с индексами</a></span></dt><dt><span class="sect1"><a href="index-unique-checks.html">64.5. Проверки уникальности в индексе</a></span></dt><dt><span class="sect1"><a href="index-cost-estimation.html">64.6. Функции оценки стоимости индекса</a></span></dt></dl></div><a id="id-1.10.15.2" class="indexterm"></a><a id="id-1.10.15.3" class="indexterm"></a><p>В этой главе описывается интерфейс между ядром системы <span class="productname">PostgreSQL</span> и <em class="firstterm">индексными методами доступа</em>, которые управляют отдельными типами индексов. Ядро системы не знает об индексах ничего, кроме того, что описано здесь; благодаря этому можно реализовывать абсолютно новые типы индексов в рамках расширений.</p><p>Все индексы <span class="productname">PostgreSQL</span> являются, говоря на техническом уровне, <em class="firstterm">вторичными индексами</em>; то есть, они физически отделены от файла таблицы, к которой относятся. Каждый индекс хранится в собственном отдельном физическом <em class="firstterm">отношении</em> и описывается в отдельной записи в каталоге <code class="structname">pg_class</code>. Содержимое индекса находится полностью под контролем соответствующего метода доступа. На практике все индексные методы доступа делят индексы на страницы стандартного размера, чтобы для обращения к содержимому индекса можно было задействовать обычный менеджер хранилища и менеджер буферов. (Более того, большинство существующих методов доступа используют одну структуру страницы, описанную в <a class="xref" href="storage-page-layout.html" title="73.6. Компоновка страницы базы данных">Разделе 73.6</a>, и одинаковый формат заголовков кортежей индекса; но эти решения методам доступа не навязываются.)</p><p>Индекс по сути представляет собой сопоставление некоторых значений ключей данных с <em class="firstterm">идентификаторами кортежей</em>, <acronym class="acronym">TID</acronym> (Tuple Identifier), или версиями строк в основной таблице индекса. TID состоит из номера блока и номера записи в этом блоке (см. <a class="xref" href="storage-page-layout.html" title="73.6. Компоновка страницы базы данных">Раздел 73.6</a>). Этой информации достаточно, чтобы выбрать определённую версию строки из таблицы. Индексы сами по себе не знают, что в модели MVCC у одной логической строки может быть несколько существующих версий; для индекса каждый кортеж — независимый объект, которому нужна своя запись в индексе. Таким образом, при изменении строки для неё всегда заново создаются новые записи индекса, даже если значения ключа не изменились. (Кортежи <a class="link" href="storage-hot.html" title="73.7. Кортежи только в куче (Heap-Only Tuples, HOT)">HOT</a> представляют собой исключение из этого утверждения; но индексы всё равно не имеют с этим дела.) Записи индексов для мёртвых кортежей высвобождаются (при очистке), когда высвобождаются сами мёртвые кортежи.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="tableam.html" title="Глава 63. Определение интерфейса для табличных методов доступа">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="internals.html" title="Часть VII. Внутреннее устройство">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="index-api.html" title="64.1. Базовая структура API для индексов">След.</a></td></tr><tr><td width="40%" align="left" valign="top">Глава 63. Определение интерфейса для табличных методов доступа </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 64.1. Базовая структура API для индексов</td></tr></table></div></body></html>