<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>14.3. Управление планировщиком с помощью явных предложений JOIN</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="planner-stats.html" title="14.2. Статистика, используемая планировщиком" /><link rel="next" href="populate.html" title="14.4. Наполнение базы данных" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">14.3. Управление планировщиком с помощью явных предложений <code class="literal">JOIN</code></th></tr><tr><td width="10%" align="left"><a accesskey="p" href="planner-stats.html" title="14.2. Статистика, используемая планировщиком">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="performance-tips.html" title="Глава 14. Оптимизация производительности">Наверх</a></td><th width="60%" align="center">Глава 14. Оптимизация производительности</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="populate.html" title="14.4. Наполнение базы данных">След.</a></td></tr></table><hr /></div><div class="sect1" id="EXPLICIT-JOINS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">14.3. Управление планировщиком с помощью явных предложений <code class="literal">JOIN</code> <a href="#EXPLICIT-JOINS" class="id_link">#</a></h2></div></div></div><a id="id-1.5.13.6.2" class="indexterm"></a><p>Поведением планировщика в некоторой степени можно управлять, используя явный синтаксис <code class="literal">JOIN</code>. Понять, когда и почему это бывает нужно, поможет небольшое введение.</p><p>В простом запросе с соединением, например таком: </p><pre class="programlisting">SELECT * FROM a, b, c WHERE a.id = b.id AND b.ref = c.id;</pre><p> планировщик может соединять данные таблицы в любом порядке. Например, он может разработать план, в котором сначала A соединяется с B по условию <code class="literal">WHERE</code> <code class="literal">a.id = b.id</code>, а затем C соединяется с получившейся таблицей по другому условию <code class="literal">WHERE</code>. Либо он может соединить B с C, а затем с A результатом соединения. Он также может соединить сначала A с C, а затем результат с B — но это будет не эффективно, так как ему придётся сформировать полное декартово произведение A и C из-за отсутствия в предложении <code class="literal">WHERE</code> условия, подходящего для оптимизации соединения. (В <span class="productname">PostgreSQL</span> исполнитель запросов может соединять только по две таблицы, поэтому для получения результата нужно выбрать один из этих способов.) При этом важно понимать, что все эти разные способы соединения дают одинаковые по смыслу результаты, но стоимость их может различаться многократно. Поэтому планировщик должен изучить их все и найти самый эффективный способ выполнения запроса.</p><p>Когда запрос включает только две или три таблицы, возможны всего несколько вариантов их соединения. Но их число растёт экспоненциально с увеличением числа задействованных таблиц. Если число таблиц больше десяти, уже практически невозможно выполнить полный перебор всех вариантов, и даже для шести или семи таблиц планирование может занять недопустимо много времени. Когда таблиц слишком много, планировщик <span class="productname">PostgreSQL</span> переключается с полного поиска на алгоритм <em class="firstterm">генетического</em> вероятностного поиска в ограниченном числе вариантов. (Порог для этого переключения задаётся параметром выполнения <a class="xref" href="runtime-config-query.html#GUC-GEQO-THRESHOLD">geqo_threshold</a>.) Генетический поиск выполняется быстрее, но не гарантирует, что найденный план будет наилучшим.</p><p>Когда запрос включает внешние соединения, планировщик имеет меньше степеней свободы, чем с обычными (внутренними) соединениями. Например, рассмотрим запрос: </p><pre class="programlisting">SELECT * FROM a LEFT JOIN (b JOIN c ON (b.ref = c.id)) ON (a.id = b.id);</pre><p> Хотя ограничения в этом запросе очень похожи на показанные в предыдущем примере, смысл его отличается, так как результирующая строка должна выдаваться для каждой строки A, даже если для неё не находится соответствия в соединении B и C. Таким образом, здесь планировщик не может выбирать порядок соединения: он должен соединить B с C, а затем соединить A с результатом. Соответственно, и план этого запроса построится быстрее, чем предыдущего. В других случаях планировщик сможет определить, что можно безопасно выбрать один из нескольких способов соединения. Например, для запроса: </p><pre class="programlisting">SELECT * FROM a LEFT JOIN b ON (a.bid = b.id) LEFT JOIN c ON (a.cid = c.id);</pre><p> можно соединить A либо с B, либо с C. В настоящее время только <code class="literal">FULL JOIN</code> полностью ограничивает порядок соединения. На практике в большинстве запросов с <code class="literal">LEFT JOIN</code> и <code class="literal">RIGHT JOIN</code> порядком можно управлять в некоторой степени.</p><p>Синтаксис явного внутреннего соединения (<code class="literal">INNER JOIN</code>, <code class="literal">CROSS JOIN</code> или лаконичный <code class="literal">JOIN</code>) по смыслу равнозначен перечислению отношений в предложении <code class="literal">FROM</code>, так что он никак не ограничивает порядок соединений.</p><p>Хотя большинство видов <code class="literal">JOIN</code> не полностью ограничивают порядок соединения, в <span class="productname">PostgreSQL</span> можно принудить планировщик обрабатывать все предложения <code class="literal">JOIN</code> как ограничивающие этот порядок. Например, следующие три запроса логически равнозначны: </p><pre class="programlisting">SELECT * FROM a, b, c WHERE a.id = b.id AND b.ref = c.id;
SELECT * FROM a CROSS JOIN b CROSS JOIN c WHERE a.id = b.id AND b.ref = c.id;
SELECT * FROM a JOIN (b JOIN c ON (b.ref = c.id)) ON (a.id = b.id);</pre><p> Но если мы укажем планировщику соблюдать порядок <code class="literal">JOIN</code>, на планирование второго и третьего уйдёт меньше времени. Когда речь идёт только о трёх таблицах, выигрыш будет незначительным, но для множества таблиц это может быть очень эффективно.</p><p>Чтобы планировщик соблюдал порядок внутреннего соединения, выраженный явно предложениями <code class="literal">JOIN</code>, нужно присвоить параметру выполнения <a class="xref" href="runtime-config-query.html#GUC-JOIN-COLLAPSE-LIMIT">join_collapse_limit</a> значение 1. (Другие допустимые значения обсуждаются ниже.)</p><p>Чтобы сократить время поиска, необязательно полностью ограничивать порядок соединений, в <code class="literal">JOIN</code> можно соединять элементы как в обычном списке <code class="literal">FROM</code>. Например, рассмотрите следующий запрос: </p><pre class="programlisting">SELECT * FROM a CROSS JOIN b, c, d, e WHERE ...;</pre><p> Если <code class="varname">join_collapse_limit</code> = 1, планировщик будет вынужден соединить A с B раньше, чем результат с другими таблицами, но в дальнейшем выборе вариантов он не ограничен. В данном примере число возможных вариантов соединения уменьшается в 5 раз.</p><p>Упрощать для планировщика задачу перебора вариантов таким способом — это полезный приём, помогающий не только выбрать сократить время планирования, но и подтолкнуть планировщик к хорошему плану. Если планировщик по умолчанию выбирает неудачный порядок соединения, вы можете заставить его выбрать лучший, применив синтаксис <code class="literal">JOIN</code>, конечно если вы сами его знаете. Эффект подобной оптимизации рекомендуется подтверждать экспериментально.</p><p>На время планирования влияет и другой, тесно связанный фактор — решение о включении подзапросов в родительский запрос. Пример такого запроса: </p><pre class="programlisting">SELECT *
FROM x, y,
    (SELECT * FROM a, b, c WHERE something) AS ss
WHERE somethingelse;</pre><p> Такая же ситуация может возникнуть с представлением, содержащим соединение; вместо ссылки на это представление будет вставлено его выражение <code class="literal">SELECT</code> и в результате получится запрос, похожий на показанный выше. Обычно планировщик старается включить подзапрос в родительский запрос и получить таким образом: </p><pre class="programlisting">SELECT * FROM x, y, a, b, c WHERE something AND somethingelse;</pre><p> Часто это позволяет построить лучший план, чем при планировании подзапросов по отдельности. (Например, внешние условия <code class="literal">WHERE</code> могут быть таковы, что при соединении сначала X с A будет исключено множество строк A, а значит формировать логический результат подзапроса полностью не потребуется.) Но в то же время тем самым мы увеличиваем время планирования; две задачи соединения трёх элементов мы заменяем одной с пятью элементами. Так как число вариантов увеличивается экспоненциально, сложность задачи увеличивается многократно. Планировщик пытается избежать проблем поиска с огромным числом вариантов, рассматривая подзапросы отдельно, если в предложении <code class="literal">FROM</code> родительского запроса оказывается больше чем <code class="varname">from_collapse_limit</code> элементов. Изменяя этот параметр выполнения, можно подобрать оптимальное соотношение времени планирования и качества плана.</p><p>Параметры <a class="xref" href="runtime-config-query.html#GUC-FROM-COLLAPSE-LIMIT">from_collapse_limit</a> и <a class="xref" href="runtime-config-query.html#GUC-JOIN-COLLAPSE-LIMIT">join_collapse_limit</a> называются похоже, потому что они делают практически одно и то же: первый параметр определяет, когда планировщик будет <span class="quote">«<span class="quote">сносить</span>»</span> в предложение <code class="literal">FROM</code> подзапросы, а второй — явные соединения. Обычно <code class="varname">join_collapse_limit</code> устанавливается равным <code class="varname">from_collapse_limit</code> (чтобы явные соединения и подзапросы обрабатывались одинаково) или 1 (если требуется управлять порядком соединений). Но вы можете задать другие значения, чтобы добиться оптимального соотношения времени планирования и времени выполнения запросов.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="planner-stats.html" title="14.2. Статистика, используемая планировщиком">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="performance-tips.html" title="Глава 14. Оптимизация производительности">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="populate.html" title="14.4. Наполнение базы данных">След.</a></td></tr><tr><td width="40%" align="left" valign="top">14.2. Статистика, используемая планировщиком </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 14.4. Наполнение базы данных</td></tr></table></div></body></html>