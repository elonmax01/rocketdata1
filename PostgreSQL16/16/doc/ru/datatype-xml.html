<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>8.13. Тип XML</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="datatype-uuid.html" title="8.12. Тип UUID" /><link rel="next" href="datatype-json.html" title="8.14. Типы JSON" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">8.13. Тип <acronym class="acronym">XML</acronym></th></tr><tr><td width="10%" align="left"><a accesskey="p" href="datatype-uuid.html" title="8.12. Тип UUID">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="datatype.html" title="Глава 8. Типы данных">Наверх</a></td><th width="60%" align="center">Глава 8. Типы данных</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="datatype-json.html" title="8.14. Типы JSON">След.</a></td></tr></table><hr /></div><div class="sect1" id="DATATYPE-XML"><div class="titlepage"><div><div><h2 class="title" style="clear: both">8.13. Тип <acronym class="acronym">XML</acronym> <a href="#DATATYPE-XML" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="datatype-xml.html#DATATYPE-XML-CREATING">8.13.1. Создание XML-значений</a></span></dt><dt><span class="sect2"><a href="datatype-xml.html#DATATYPE-XML-ENCODING-HANDLING">8.13.2. Обработка кодировки</a></span></dt><dt><span class="sect2"><a href="datatype-xml.html#DATATYPE-XML-ACCESSING-XML-VALUES">8.13.3. Обращение к XML-значениям</a></span></dt></dl></div><a id="id-1.5.7.21.2" class="indexterm"></a><p>Тип <code class="type">xml</code> предназначен для хранения XML-данных. Его преимущество по сравнению с обычным типом <code class="type">text</code> в том, что он проверяет вводимые значения на допустимость по правилам XML и для работы с ним есть типобезопасные функции; см. <a class="xref" href="functions-xml.html" title="9.15. XML-функции">Раздел 9.15</a>. Для использования этого типа дистрибутив должен быть скомпилирован в конфигурации <code class="command">configure --with-libxml</code>.</p><p>Тип <code class="type">xml</code> может сохранять правильно оформленные <span class="quote">«<span class="quote">документы</span>»</span>, в соответствии со стандартом XML, а также фрагменты <span class="quote">«<span class="quote">содержимого</span>»</span>, определяемые как менее ограниченные <a class="ulink" href="https://www.w3.org/TR/2010/REC-xpath-datamodel-20101214/#DocumentNode" target="_top"><span class="quote">«<span class="quote">узлы документа</span>»</span></a> в модели данных XQuery и XPath. Другими словами, это означает, что во фрагментах содержимого может быть несколько элементов верхнего уровня или текстовых узлов. Является ли некоторое значение типа <code class="type">xml</code> полным документом или фрагментом содержимого, позволяет определить выражение <code class="literal"><em class="replaceable"><code>xml-значение</code></em> IS DOCUMENT</code>.</p><p>Информацию о совместимости и ограничениях типа данных <code class="type">xml</code> можно найти в <a class="xref" href="xml-limits-conformance.html" title="D.3. Ограничения XML и совместимость с SQL/XML">Разделе D.3</a>.</p><div class="sect2" id="DATATYPE-XML-CREATING"><div class="titlepage"><div><div><h3 class="title">8.13.1. Создание XML-значений <a href="#DATATYPE-XML-CREATING" class="id_link">#</a></h3></div></div></div><p>Чтобы получить значение типа <code class="type">xml</code> из текстовой строки, используйте функцию <code class="function">xmlparse</code>:<a id="id-1.5.7.21.6.2.3" class="indexterm"></a> </p><pre class="synopsis">
XMLPARSE ( { DOCUMENT | CONTENT } <em class="replaceable"><code>value</code></em>)
</pre><p> Примеры: </p><pre class="programlisting">
XMLPARSE (DOCUMENT '&lt;?xml version="1.0"?&gt;&lt;book&gt;&lt;title&gt;Manual&lt;/title&gt;&lt;chapter&gt;...&lt;/chapter&gt;&lt;/book&gt;')
XMLPARSE (CONTENT 'abc&lt;foo&gt;bar&lt;/foo&gt;&lt;bar&gt;foo&lt;/bar&gt;')
</pre><p> Хотя в стандарте SQL описан только один способ преобразования текстовых строк в XML-значения, специфический синтаксис PostgreSQL: </p><pre class="programlisting">
xml '&lt;foo&gt;bar&lt;/foo&gt;'
'&lt;foo&gt;bar&lt;/foo&gt;'::xml
</pre><p> тоже допустим.</p><p>Тип <code class="type">xml</code> не проверяет вводимые значения по схеме DTD (Document Type Declaration, Объявления типа документа),<a id="id-1.5.7.21.6.3.2" class="indexterm"></a> даже если в них присутствуют ссылка на DTD. В настоящее время в <span class="productname">PostgreSQL</span> также нет встроенной поддержки других разновидностей схем, например XML Schema.</p><p>Обратная операция, получение текстовой строки из <code class="type">xml</code>, выполняется с помощью функции <code class="function">xmlserialize</code>:<a id="id-1.5.7.21.6.4.3" class="indexterm"></a> </p><pre class="synopsis">
XMLSERIALIZE ( { DOCUMENT | CONTENT } <em class="replaceable"><code>значение</code></em> AS <em class="replaceable"><code>тип</code></em> [ [ NO ] INDENT ] )
</pre><p> Здесь допустимый <em class="replaceable"><code>тип</code></em> — <code class="type">character</code>, <code class="type">character varying</code> или <code class="type">text</code> (или их псевдонимы). И в данном случае стандарт SQL предусматривает только один способ преобразования <code class="type">xml</code> в тип текстовых строк, но PostgreSQL позволяет просто привести значение к нужному типу.</p><p>С параметром <code class="literal">INDENT</code> результат будет визуально улучшен, а с <code class="literal">NO INDENT</code> (по умолчанию) сохранится исходное форматирование результата. Если значение приводится к символьному типу, сохраняется исходное форматирование.</p><p>При преобразовании текстовой строки в тип <code class="type">xml</code> или наоборот без использования функций <code class="type">XMLPARSE</code> и <code class="type">XMLSERIALIZE</code>, выбор режима <code class="literal">DOCUMENT</code> или <code class="literal">CONTENT</code> определяется параметром конфигурации сеанса <span class="quote">«<span class="quote">XML option</span>»</span><a id="id-1.5.7.21.6.6.7" class="indexterm"></a>, установить который можно следующей стандартной командой: </p><pre class="synopsis">
SET XML OPTION { DOCUMENT | CONTENT };
</pre><p> или такой командой в духе PostgreSQL:</p><pre class="synopsis">
SET xmloption TO { DOCUMENT | CONTENT };
</pre><p> По умолчанию этот параметр имеет значение <code class="literal">CONTENT</code>, так что допускаются все формы XML-данных.</p></div><div class="sect2" id="DATATYPE-XML-ENCODING-HANDLING"><div class="titlepage"><div><div><h3 class="title">8.13.2. Обработка кодировки <a href="#DATATYPE-XML-ENCODING-HANDLING" class="id_link">#</a></h3></div></div></div><p>Если на стороне сервера и клиента и в XML-данных используются разные кодировки символов, с этим могут возникать проблемы. Когда запросы передаются на сервер, а их результаты возвращаются клиенту в обычном текстовом режиме, PostgreSQL преобразует все передаваемые текстовые данные в кодировку для соответствующей стороны; см. <a class="xref" href="multibyte.html" title="24.3. Поддержка кодировок">Раздел 24.3</a>. В том числе это происходит и со строковыми представлениями XML-данных, подобными тем, что показаны в предыдущих примерах. Обычно это означает, что объявления кодировки, содержащиеся в XML-данных, могут не соответствовать действительности, когда текстовая строка преобразуется из одной кодировки в другую при передаче данных между клиентом и сервером, так как подобные включённые в данные объявления не будут изменены автоматически. Для решения этой проблемы объявления кодировки, содержащиеся в текстовых строках, вводимых в тип <code class="type">xml</code>, просто <span class="emphasis"><em>игнорируются</em></span> и предполагается, что XML-содержимое представлено в текущей кодировке сервера. Как следствие, для правильной обработки таких строк с XML-данными клиент должен передавать их в своей текущей кодировке. Для сервера не важно, будет ли клиент для этого преобразовывать документы в свою кодировку, или изменит её, прежде чем передавать ему данные. При выводе значения типа <code class="type">xml</code> не содержат объявления кодировки, а клиент должен предполагать, что все данные поступают в его текущей кодировке.</p><p>Если параметры запроса передаются на сервер и он возвращает результаты клиенту в двоичном режиме, кодировка символов не преобразуется, так что возникает другая ситуация. В этом случае объявление кодировки в XML принимается во внимание, а если его нет, то предполагается, что данные закодированы в UTF-8 (это соответствует стандарту XML; заметьте, что PostgreSQL не поддерживает UTF-16). При выводе в данные будет добавлено объявление кодировки, выбранной на стороне клиента (но если это UTF-8, объявление будет опущено).</p><p>Само собой, XML-данные в PostgreSQL будут обрабатываться гораздо эффективнее, когда и в XML-данных, и на стороне клиента, и на стороне сервера используется одна кодировка. Так как внутри XML-данные представляются в UTF-8, оптимальный вариант, когда на сервере также выбрана кодировка UTF-8.</p><div class="caution"><h3 class="title">Внимание</h3><p>Некоторые XML-функции способны работать исключительно с ASCII-данными, если кодировка сервера не UTF-8. В частности, это известная особенность функций <code class="function">xmltable()</code> и <code class="function">xpath()</code>.</p></div></div><div class="sect2" id="DATATYPE-XML-ACCESSING-XML-VALUES"><div class="titlepage"><div><div><h3 class="title">8.13.3. Обращение к XML-значениям <a href="#DATATYPE-XML-ACCESSING-XML-VALUES" class="id_link">#</a></h3></div></div></div><p>Тип <code class="type">xml</code> отличается от других тем, что для него не определены никакие операторы сравнения, так как чётко определённого и универсального алгоритма сравнения XML-данных не существует. Одно из следствий этого — нельзя отфильтровать строки таблицы, сравнив столбец <code class="type">xml</code> с искомым значением. Поэтому обычно XML-значения должны дополняться отдельным ключевым полем, например ID. Можно также сравнивать XML-значения, преобразовав их сначала в текстовые строки, но заметьте, что с учётом специфики XML-данных этот метод практически бесполезен.</p><p>Из-за отсутствия операторов сравнения для типа <code class="type">xml</code>, для столбца этого типа также нельзя создать индекс. Поэтому, когда требуется быстрый поиск в XML данных, обойти это ограничение можно, приведя данные к типу текстовой строки и проиндексировав эти строки, либо проиндексировав выражение XPath. Конечно сам запрос при этом следует изменить, чтобы поиск выполнялся по индексированному выражению.</p><p>Для ускорения поиска в XML-данных также можно использовать функции полнотекстового поиска в PostgreSQL. Однако это требует определённой подготовки данных, что дистрибутив PostgreSQL пока не поддерживает.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="datatype-uuid.html" title="8.12. Тип UUID">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="datatype.html" title="Глава 8. Типы данных">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="datatype-json.html" title="8.14. Типы JSON">След.</a></td></tr><tr><td width="40%" align="left" valign="top">8.12. Тип <acronym class="acronym">UUID</acronym> </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 8.14. Типы <acronym class="acronym">JSON</acronym></td></tr></table></div></body></html>