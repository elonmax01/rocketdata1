<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>8.4. Двоичные типы данных</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="datatype-character.html" title="8.3. Символьные типы" /><link rel="next" href="datatype-datetime.html" title="8.5. Типы даты/времени" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">8.4. Двоичные типы данных</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="datatype-character.html" title="8.3. Символьные типы">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="datatype.html" title="Глава 8. Типы данных">Наверх</a></td><th width="60%" align="center">Глава 8. Типы данных</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="datatype-datetime.html" title="8.5. Типы даты/времени">След.</a></td></tr></table><hr /></div><div class="sect1" id="DATATYPE-BINARY"><div class="titlepage"><div><div><h2 class="title" style="clear: both">8.4. Двоичные типы данных <a href="#DATATYPE-BINARY" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="datatype-binary.html#DATATYPE-BINARY-BYTEA-HEX-FORMAT">8.4.1. Шестнадцатеричный формат <code class="type">bytea</code></a></span></dt><dt><span class="sect2"><a href="datatype-binary.html#DATATYPE-BINARY-BYTEA-ESCAPE-FORMAT">8.4.2. Формат спецпоследовательностей <code class="type">bytea</code></a></span></dt></dl></div><a id="id-1.5.7.12.2" class="indexterm"></a><a id="id-1.5.7.12.3" class="indexterm"></a><p>Для хранения двоичных данных предназначен тип <code class="type">bytea</code>; см. <a class="xref" href="datatype-binary.html#DATATYPE-BINARY-TABLE" title="Таблица 8.6. Двоичные типы данных">Таблицу 8.6</a>.</p><div class="table" id="DATATYPE-BINARY-TABLE"><p class="title"><strong>Таблица 8.6. Двоичные типы данных</strong></p><div class="table-contents"><table class="table" summary="Двоичные типы данных" border="1"><colgroup><col class="col1" /><col class="col2" /><col class="col3" /></colgroup><thead><tr><th>Name</th><th>Размер</th><th>Описание</th></tr></thead><tbody><tr><td><code class="type">bytea</code></td><td>1 или 4 байта плюс сама двоичная строка</td><td>двоичная строка переменной длины</td></tr></tbody></table></div></div><br class="table-break" /><p>Двоичные строки представляют собой последовательность октетов (байт) и имеют два отличия от текстовых строк. Во-первых, в двоичных строках можно хранить байты с кодом 0 и другими <span class="quote">«<span class="quote">непечатаемыми</span>»</span> значениями (обычно это значения вне десятичного диапазона 32..126). В текстовых строках нельзя сохранять нулевые байты, а также значения и последовательности значений, не соответствующие выбранной кодировке базы данных. Во-вторых, в операциях с двоичными строками обрабатываются байты в чистом виде, тогда как текстовые строки обрабатываются в зависимости от языковых стандартов. То есть, двоичные строки больше подходят для данных, которые программист видит как <span class="quote">«<span class="quote">просто байты</span>»</span>, а символьные строки — для хранения текста.</p><p>Тип <code class="type">bytea</code> поддерживает два формата ввода и вывода: <span class="quote">«<span class="quote">шестнадцатеричный</span>»</span> и традиционный для <span class="productname">PostgreSQL</span> формат <span class="quote">«<span class="quote">спецпоследовательностей</span>»</span>. Входные данные принимаются в обоих форматах, а формат выходных данных зависит от параметра конфигурации <a class="xref" href="runtime-config-client.html#GUC-BYTEA-OUTPUT">bytea_output</a>; по умолчанию выбран шестнадцатеричный. (Заметьте, что шестнадцатеричный формат был введён в <span class="productname">PostgreSQL</span> 9.0; в ранних версиях и некоторых программах он не будет работать.)</p><p>Стандарт <acronym class="acronym">SQL</acronym> определяет другой тип двоичных данных, <code class="type">BLOB</code> (<code class="type">BINARY LARGE OBJECT</code>, большой двоичный объект). Его входной формат отличается от форматов <code class="type">bytea</code>, но функции и операторы в основном те же.</p><div class="sect2" id="DATATYPE-BINARY-BYTEA-HEX-FORMAT"><div class="titlepage"><div><div><h3 class="title">8.4.1. Шестнадцатеричный формат <code class="type">bytea</code> <a href="#DATATYPE-BINARY-BYTEA-HEX-FORMAT" class="id_link">#</a></h3></div></div></div><p>В <span class="quote">«<span class="quote">шестнадцатеричном</span>»</span> формате двоичные данные кодируются двумя шестнадцатеричными цифрами на байт, при этом первая цифра соответствует старшим 4 битам. К полученной строке добавляется префикс <code class="literal">\x</code> (чтобы она отличалась от формата спецпоследовательности). В некоторых контекстах обратную косую черту нужно экранировать, продублировав её (см. <a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-STRINGS" title="4.1.2.1. Строковые константы">Подраздел 4.1.2.1</a>). Вводимые шестнадцатеричные цифры могут быть в любом регистре, а между парами цифр допускаются пробельные символы (но не внутри пары и не в начале последовательности <code class="literal">\x</code>). Этот формат совместим со множеством внешних приложений и протоколов, к тому же обычно преобразуется быстрее, поэтому предпочтительнее использовать его.</p><p>Пример: </p><pre class="programlisting">SET bytea_output = 'hex';

SELECT '\xDEADBEEF'::bytea;
   bytea
------------
 \xdeadbeef</pre></div><div class="sect2" id="DATATYPE-BINARY-BYTEA-ESCAPE-FORMAT"><div class="titlepage"><div><div><h3 class="title">8.4.2. Формат спецпоследовательностей <code class="type">bytea</code> <a href="#DATATYPE-BINARY-BYTEA-ESCAPE-FORMAT" class="id_link">#</a></h3></div></div></div><p>Формат <span class="quote">«<span class="quote">спецпоследовательностей</span>»</span> традиционно использовался в <span class="productname">PostgreSQL</span> для значений типа <code class="type">bytea</code>. В нём двоичная строка представляется в виде последовательности ASCII-символов, а байты, непредставимые в виде ASCII-символов, передаются в виде спецпоследовательностей. Этот формат может быть удобен, если с точки зрения приложения представление байт в виде символов имеет смысл. Но на практике это обычно создаёт путаницу, так как двоичные и символьные строки могут выглядеть одинаково, а кроме того выбранный механизм спецпоследовательностей довольно неуклюж. Поэтому в новых приложениях этот формат обычно не стоит использовать.</p><p>Передавая значения <code class="type">bytea</code> в формате спецпоследовательности, байты с определёнными значениями <span class="emphasis"><em>необходимо</em></span> записывать специальным образом, хотя так <span class="emphasis"><em>можно</em></span> записывать и все значения. В общем виде для этого значение байта нужно преобразовать в трёхзначное восьмеричное число и добавить перед ним обратную косую черту. Саму обратную косую черту (символ с десятичным кодом 92) можно записать в виде двух таких символов. В <a class="xref" href="datatype-binary.html#DATATYPE-BINARY-SQLESC" title="Таблица 8.7. Спецпоследовательности записи значений bytea">Таблице 8.7</a> перечислены символы, которые нужно записывать спецпоследовательностями, и приведены альтернативные варианты записи, если они возможны.</p><div class="table" id="DATATYPE-BINARY-SQLESC"><p class="title"><strong>Таблица 8.7. Спецпоследовательности записи значений <code class="type">bytea</code></strong></p><div class="table-contents"><table class="table" summary="Спецпоследовательности записи значений bytea" border="1"><colgroup><col class="col1" /><col class="col2" /><col class="col3" /><col class="col4" /><col class="col5" /></colgroup><thead><tr><th>Десятичное значение байта</th><th>Описание</th><th>Спецпоследовательность ввода</th><th>Пример</th><th>Шестнадцатеричное представление</th></tr></thead><tbody><tr><td>0</td><td>нулевой байт</td><td><code class="literal">'\000'</code></td><td><code class="literal">'\000'::bytea</code></td><td><code class="literal">\x00</code></td></tr><tr><td>39</td><td>апостроф</td><td><code class="literal">''''</code> или <code class="literal">'\047'</code></td><td><code class="literal">''''::bytea</code></td><td><code class="literal">\x27</code></td></tr><tr><td>92</td><td>обратная косая черта</td><td><code class="literal">'\\'</code> или <code class="literal">'\134'</code></td><td><code class="literal">'\\'::bytea</code></td><td><code class="literal">\x5c</code></td></tr><tr><td>от 0 до 31 и от 127 до 255</td><td><span class="quote">«<span class="quote">непечатаемые</span>»</span> байты</td><td><code class="literal">E'\\<em class="replaceable"><code>xxx'</code></em></code> (восьмеричное значение)</td><td><code class="literal">'\001'::bytea</code></td><td><code class="literal">\x01</code></td></tr></tbody></table></div></div><br class="table-break" /><p>Требования экранирования <span class="emphasis"><em>непечатаемых</em></span> символов определяются языковыми стандартами. Иногда такие символы могут восприниматься и без спецпоследовательностей.</p><p>Апострофы должны дублироваться, как показано в <a class="xref" href="datatype-binary.html#DATATYPE-BINARY-SQLESC" title="Таблица 8.7. Спецпоследовательности записи значений bytea">Таблице 8.7</a>, потому что это обязательно для любой текстовой строки в команде SQL. При общем разборе текстовой строки внешние апострофы убираются, а каждая пара внутренних сводится к одному символу. Таким образом, функция ввода <code class="type">bytea</code> видит всего один апостроф, который она обрабатывает как обычный символ в данных. Дублировать же обратную косую черту при вводе <code class="type">bytea</code> не требуется: этот символ считается особым и меняет поведение функции ввода, как показано в <a class="xref" href="datatype-binary.html#DATATYPE-BINARY-SQLESC" title="Таблица 8.7. Спецпоследовательности записи значений bytea">Таблице 8.7</a>.</p><p>В некоторых контекстах обратная косая черта должна дублироваться (относительно примеров выше), так как при общем разборе строковых констант пара таких символов будет сведена к одному; см. <a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-STRINGS" title="4.1.2.1. Строковые константы">Подраздел 4.1.2.1</a>.</p><p>Данные <code class="type">Bytea</code> по умолчанию выводятся в шестнадцатеричном формате (<code class="literal">hex</code>). Если поменять значение <a class="xref" href="runtime-config-client.html#GUC-BYTEA-OUTPUT">bytea_output</a> на <code class="literal">escape</code>, <span class="quote">«<span class="quote">непечатаемые</span>»</span> байты представляются в виде соответствующих трёхзначных восьмеричных значений, которые предваряются одной обратной косой чертой. Большинство <span class="quote">«<span class="quote">печатаемых</span>»</span> байтов представляются обычными символами из клиентского набора символов, например: </p><pre class="programlisting">SET bytea_output = 'escape';

SELECT 'abc \153\154\155 \052\251\124'::bytea;
     bytea
----------------
 abc klm *\251T</pre><p> Байт с десятичным кодом 92 (обратная косая черта) при выводе дублируется. Это иллюстрирует <a class="xref" href="datatype-binary.html#DATATYPE-BINARY-RESESC" title="Таблица 8.8. Спецпоследовательности выходных значений bytea">Таблица 8.8</a>.</p><div class="table" id="DATATYPE-BINARY-RESESC"><p class="title"><strong>Таблица 8.8. Спецпоследовательности выходных значений <code class="type">bytea</code></strong></p><div class="table-contents"><table class="table" summary="Спецпоследовательности выходных значений bytea" border="1"><colgroup><col class="col1" /><col class="col2" /><col class="col3" /><col class="col4" /><col class="col5" /></colgroup><thead><tr><th>Десятичное значение байта</th><th>Описание</th><th>Спецпоследовательность вывода</th><th>Пример</th><th>Выводимый результат</th></tr></thead><tbody><tr><td>92</td><td>обратная косая черта</td><td><code class="literal">\\</code></td><td><code class="literal">'\134'::bytea</code></td><td><code class="literal">\\</code></td></tr><tr><td>от 0 до 31 и от 127 до 255</td><td><span class="quote">«<span class="quote">непечатаемые</span>»</span> байты</td><td><code class="literal">\<em class="replaceable"><code>xxx</code></em></code> (значение байта)</td><td><code class="literal">'\001'::bytea</code></td><td><code class="literal">\001</code></td></tr><tr><td>от 32 до 126</td><td><span class="quote">«<span class="quote">печатаемые</span>»</span> байты</td><td>представление из клиентского набора символов</td><td><code class="literal">'\176'::bytea</code></td><td><code class="literal">~</code></td></tr></tbody></table></div></div><br class="table-break" /><p>В зависимости от применяемой клиентской библиотеки <span class="productname">PostgreSQL</span>, для преобразования значений <code class="type">bytea</code> в спецстроки и обратно могут потребоваться дополнительные действия. Например, если приложение сохраняет в строках символы перевода строк, возможно их также нужно будет представить спецпоследовательностями.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="datatype-character.html" title="8.3. Символьные типы">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="datatype.html" title="Глава 8. Типы данных">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="datatype-datetime.html" title="8.5. Типы даты/времени">След.</a></td></tr><tr><td width="40%" align="left" valign="top">8.3. Символьные типы </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 8.5. Типы даты/времени</td></tr></table></div></body></html>