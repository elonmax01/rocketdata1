<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>39.1. Обзор механизма работы триггеров</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="triggers.html" title="Глава 39. Триггеры" /><link rel="next" href="trigger-datachanges.html" title="39.2. Видимость изменений в данных" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">39.1. Обзор механизма работы триггеров</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="triggers.html" title="Глава 39. Триггеры">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="triggers.html" title="Глава 39. Триггеры">Наверх</a></td><th width="60%" align="center">Глава 39. Триггеры</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="trigger-datachanges.html" title="39.2. Видимость изменений в данных">След.</a></td></tr></table><hr /></div><div class="sect1" id="TRIGGER-DEFINITION"><div class="titlepage"><div><div><h2 class="title" style="clear: both">39.1. Обзор механизма работы триггеров <a href="#TRIGGER-DEFINITION" class="id_link">#</a></h2></div></div></div><p>Триггер является указанием, что база данных должна автоматически выполнить заданную функцию, всякий раз когда выполнен определённый тип операции. Триггеры можно использовать с таблицами (секционированными и обычными), с представлениями и с внешними таблицами.</p><p>Для обычных и сторонних таблиц можно определять триггеры, которые будут срабатывать до или после любой из команд <code class="command">INSERT</code>, <code class="command">UPDATE</code> или <code class="command">DELETE</code>; либо один раз для каждой модифицируемой строки, либо один раз для оператора <acronym class="acronym">SQL</acronym>. Триггеры на <code class="command">UPDATE</code> можно установить так, чтобы они срабатывали, только когда в предложении <code class="literal">SET</code> оператора <code class="command">UPDATE</code> упоминаются определённые столбцы. Также триггеры могут срабатывать для операторов <code class="command">TRUNCATE</code>. Если происходит событие триггера, для обработки этого события в установленный момент времени вызывается функция триггера.</p><p>Для представлений триггеры могут быть определены для выполнения вместо операций <code class="command">INSERT</code>, <code class="command">UPDATE</code> и <code class="command">DELETE</code>. Такие триггеры <code class="literal">INSTEAD OF</code> вызываются единожды для каждой строки, которая должна быть изменена в этом представлении. Именно функция триггера отвечает за то, чтобы произвести необходимые изменения в нижележащих базовых таблицах представления и должным образом возвращать изменённые строки, чтобы они появлялись в представлении. Триггеры для представлений тоже могут быть определены так, что они будут выполняться единожды для всего оператора <acronym class="acronym">SQL</acronym>, до или после операций <code class="command">INSERT</code>, <code class="command">UPDATE</code> или <code class="command">DELETE</code>. Однако такие триггеры срабатывают, только если для представления определён триггер <code class="literal">INSTEAD OF</code>. В противном случае все операторы, обращающиеся к представлению, должны быть переписаны в виде операторов, обращающихся к нижележащим базовым таблицам, и тогда будут срабатывать триггеры, установленные для этих таблиц.</p><p>Триггерная функция должна быть создана до триггера. Она должна быть объявлена без аргументов и возвращать тип <code class="literal">trigger</code>. (Триггерная функция получает данные на вход посредством специально переданной структуры <code class="structname">TriggerData</code>, а не в форме обычных аргументов.)</p><p>После создания триггерной функции создаётся триггер с помощью <a class="xref" href="sql-createtrigger.html" title="CREATE TRIGGER"><span class="refentrytitle">CREATE TRIGGER</span></a>. Одна и та же триггерная функция может быть использована для нескольких триггеров.</p><p><span class="productname">PostgreSQL</span> предлагает как <em class="firstterm">построчные</em>, так и <em class="firstterm">операторные</em> триггеры. В случае построчного триггера триггерная функция вызывается один раз для каждой строки, затронутой оператором, запустившим триггер. Операторный же триггер, напротив, вызывается только один раз при выполнении соответствующего оператора, независимо от количества строк, которые он затрагивает. В частности оператор, который не затрагивает никаких строк, всё равно приведёт к срабатыванию операторного триггера. Эти два типа триггеров также называют триггерами <em class="firstterm">уровня строк</em> и триггерами <em class="firstterm">уровня оператора</em>, соответственно. Триггеры на <code class="command">TRUNCATE</code> могут быть определены только на уровне оператора, а не на уровне строк.</p><p>Триггеры также классифицируются в соответствии с тем, срабатывают ли они до, после или вместо операции. Они называются триггерами <code class="literal">BEFORE</code>, <code class="literal">AFTER</code> и <code class="literal">INSTEAD OF</code>, соответственно. Триггеры <code class="literal">BEFORE</code> уровня оператора срабатывают до того, как оператор начинает делать что-либо, тогда как триггеры <code class="literal">AFTER</code> уровня оператора срабатывают в самом конце работы оператора. Эти типы триггеров могут быть определены для таблиц, представлений или сторонних таблиц. Триггеры <code class="literal">BEFORE</code> уровня строки срабатывают непосредственно перед обработкой конкретной строки, в то время как триггеры <code class="literal">AFTER</code> уровня строки срабатывают в конце работы всего оператора (но до любого из триггеров <code class="literal">AFTER</code> уровня оператора). Эти типы триггеров могут определяться только для таблиц, в том числе сторонних, но не для представлений. Триггеры <code class="literal">INSTEAD OF</code> могут определяться только для представлений и только на уровне строк: они срабатывают для каждой строки сразу после того как строка представления идентифицирована как подлежащая обработке.</p><p>Если триггер <code class="literal">AFTER</code> — это <em class="firstterm">триггер ограничения</em>, его выполнение может быть отложено не до конца работы оператора, а до конца транзакции. В любом случае триггер выполняется в рамках той же транзакции, к которой относится вызвавший его оператор, поэтому если или оператор, или триггер вызывает ошибку, оба действия отменяются.</p><p>Оператор, нацеленный на родительскую таблицу в иерархии наследования или секционирования, не вызывает срабатывания триггеров уровня оператора для задействованных дочерних таблиц; срабатывать будут только такие триггеры для родительской таблицы. Однако если для этих дочерних таблиц установлены триггеры уровня строк, они будут срабатывать.</p><p>Если запрос <code class="command">INSERT</code> содержит предложение <code class="literal">ON CONFLICT DO UPDATE</code>, возможно совместное применение и триггеров уровня строк <code class="literal">BEFORE</code> <code class="command">INSERT</code>, и триггеров уровня строк <code class="literal">BEFORE</code> <code class="command">UPDATE</code>, которое отразится в окончательном состоянии изменяемой строки, если в запросе задействуются столбцы <code class="varname">EXCLUDED</code>. При этом обращение к <code class="varname">EXCLUDED</code> не обязательно должно иметь место в обоих наборах триггеров <code class="literal">BEFORE</code> на уровне строк. Следует рассмотреть возможность получения неожиданного результата, когда имеются и триггеры <code class="literal">BEFORE</code> <code class="command">INSERT</code>, и <code class="literal">BEFORE</code> <code class="command">UPDATE</code> на уровне строки, и они вместе модифицируют добавляемую/изменяемую строку (проблемы возможны, даже если изменения более или менее равнозначные, но при этом не идемпотентные). Заметьте, что триггеры <code class="command">UPDATE</code> уровня оператора вызываются при <code class="literal">ON CONFLICT DO UPDATE</code> независимо от того, будут ли изменены какие-либо строки в результате <code class="command">UPDATE</code> (и даже в случае, когда альтернативный путь <code class="command">UPDATE</code> вообще не выбирается). При выполнении запроса <code class="command">INSERT</code> с предложением <code class="literal">ON CONFLICT DO UPDATE</code> сначала выполняются триггеры <code class="literal">BEFORE</code> <code class="command">INSERT</code>, затем триггеры <code class="literal">BEFORE</code> <code class="command">UPDATE</code>, потом триггеры <code class="literal">AFTER</code> <code class="command">UPDATE</code> и, наконец, <code class="literal">AFTER</code> <code class="command">INSERT</code> (речь идёт о триггерах на уровне операторов).</p><p>Если оператор <code class="command">UPDATE</code> в секционированной таблице должен переместить строку в другую секцию, это перемещение реализуется в результате выполнения <code class="command">DELETE</code> в исходной секции и последующего <code class="command">INSERT</code> в новой секции. При этом в исходной секции срабатывают все триггеры <code class="literal">BEFORE</code> <code class="command">UPDATE</code> и <code class="literal">BEFORE</code> <code class="command">DELETE</code> уровня строк. Затем в целевой секции срабатывают все триггеры <code class="literal">BEFORE</code> <code class="command">INSERT</code> уровня строк. Следует иметь в виду, что в случаях, когда все эти триггеры модифицируют перемещаемую строку, полученный результат может быть неожиданным. Если рассматривать триггеры <code class="literal">AFTER ROW</code>, то применяться будут триггеры <code class="literal">AFTER</code> <code class="command">DELETE</code> и <code class="literal">AFTER</code> <code class="command">INSERT</code>, но не триггеры <code class="literal">AFTER</code> <code class="command">UPDATE</code>, так как команда <code class="command">UPDATE</code> заменяется на <code class="command">DELETE</code> и <code class="command">INSERT</code>. Если же рассматривать триггеры уровня операторов, ни триггеры <code class="command">DELETE</code>, ни триггеры <code class="command">INSERT</code> не будут срабатывать, даже если производится перемещение строк; сработают только триггеры <code class="command">UPDATE</code>, установленные в целевой таблице оператора <code class="command">UPDATE</code>.</p><p>Для команды <code class="command">MERGE</code> нет отдельных триггеров. Вместо этого срабатывают триггеры команд <code class="command">UPDATE</code>, <code class="command">DELETE</code> и <code class="command">INSERT</code> в зависимости от того, какие действия указаны в запросе <code class="command">MERGE</code> (триггеры уровня оператора) и какие действия выполняются (триггеры уровня строк).</p><p>При выполнении команды <code class="command">MERGE</code> срабатывают триггеры уровня оператора <code class="literal">BEFORE</code> и <code class="literal">AFTER</code> при событиях, указанных в действиях команды <code class="command">MERGE</code>, независимо от того, было ли действие в итоге выполнено. Это не отличается от поведения команды <code class="command">UPDATE</code>, для которой также срабатывают триггеры уровня оператора, когда строки не меняются. Триггеры уровня строк срабатывают только при фактическом добавлении, изменении или удалении строки. Таким образом, абсолютно нормально, когда для определённых действий срабатывают триггеры уровня оператора и при этом не срабатывают триггеры уровня строк.</p><p>Триггерные функции, вызываемые триггерами операторов, должны всегда возвращать <code class="symbol">NULL</code>. Триггерные функции, вызываемые триггерами строк, могут вернуть строку таблицы (значение типа <code class="structname">HeapTuple</code>). У триггера уровня строки, срабатывающего до операции, есть следующий выбор: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Можно вернуть <code class="symbol">NULL</code>, чтобы пропустить операцию для текущей строки. Это указывает исполнителю запросов, что не нужно выполнять операцию со строкой вызвавшей триггер (вставку, изменение или удаление конкретной строки в таблице).</p></li><li class="listitem"><p>Возвращаемая строка для триггеров <code class="command">INSERT</code> или <code class="command">UPDATE</code> будет именно той, которая будет вставлена или обновлена в таблице. Это позволяет триггерной функции изменять вставляемую или обновляемую строку.</p></li></ul></div><p> Если в триггере <code class="literal">BEFORE</code> уровня строки не планируется использовать любой из этих вариантов, то нужно аккуратно вернуть в качестве результата ту же строку, которая была передана на вход (то есть строку <code class="varname">NEW</code> для триггеров <code class="command">INSERT</code> и <code class="command">UPDATE</code>, или строку <code class="varname">OLD</code> для триггеров <code class="command">DELETE</code>).</p><p>Триггер уровня строки <code class="literal">INSTEAD OF</code> должен вернуть либо <code class="symbol">NULL</code>, чтобы указать, что он не модифицирует базовые таблицы представления, либо он должен вернуть строку представления, полученную на входе (строку <code class="varname">NEW</code> для операций <code class="command">INSERT</code> и <code class="command">UPDATE</code> или строку <code class="varname">OLD</code> для операций <code class="command">DELETE</code>). Отличное от <code class="symbol">NULL</code> возвращаемое значение сигнализирует, что триггер выполнил необходимые изменения данных в представлении. Это приведёт к увеличению счётчика количества строк, затронутых командой. Для операций <code class="command">INSERT</code> и <code class="command">UPDATE</code> (и только для них) триггер может изменить строку <code class="varname">NEW</code> перед тем как её вернуть. В результате будут изменены данные, возвращаемые <code class="command">INSERT RETURNING</code> или <code class="command">UPDATE RETURNING</code>, что полезно, когда представление должно возвращать не те данные, что были получены.</p><p>Возвращаемое значение игнорируется для триггеров уровня строки, вызываемых после операции, поэтому они могут возвращать <code class="symbol">NULL</code>.</p><p>Генерируемые столбцы заслуживают отдельного внимания. <a id="id-1.8.4.5.18.1" class="indexterm"></a> Сохраняемые генерируемые столбцы вычисляются после триггеров <code class="literal">BEFORE</code> и перед триггерами <code class="literal">AFTER</code>. Таким образом, в триггерах <code class="literal">AFTER</code> можно наблюдать сгенерированное значение. В триггерах <code class="literal">BEFORE</code> строка <code class="literal">OLD</code>, как можно было ожидать, содержит предыдущее значение, однако в строке <code class="literal">NEW</code> ещё не содержится новое сгенерированное значение, и обращаться к нему не следует. На уровне языка C содержимое столбца в этот момент считается неопределённым; более высокоуровневые языки должны блокировать обращения к сохраняемому генерируемому столбцу в строке <code class="literal">NEW</code> внутри триггера <code class="literal">BEFORE</code>. Изменённые в триггере <code class="literal">BEFORE</code> значения генерируемого столбца игнорируются и будут перезаписаны.</p><p>Если есть несколько триггеров на одно и то же событие для одной и той же таблицы, то они будут вызываться в алфавитном порядке по имени триггера. Для триггеров <code class="literal">BEFORE</code> и <code class="literal">INSTEAD OF</code> потенциально изменённая строка, возвращаемая одним триггером, становится входящей строкой для следующего триггера. Если любой из триггеров <code class="literal">BEFORE</code> или <code class="literal">INSTEAD OF</code> возвращает <code class="symbol">NULL</code>, операция для этой строки прекращается и последующие триггеры (для этой строки) не срабатывают.</p><p>В определении триггера можно указать логическое условие <code class="literal">WHEN</code>, которое будет проверяться, чтобы посмотреть, нужно ли запускать триггер. В триггерах уровня строки в условии <code class="literal">WHEN</code> можно проверять старые и/или новые значения столбцов строки. (В триггерах уровня оператора также можно использовать условие <code class="literal">WHEN</code>, хотя в этом случае это не так полезно.) В триггерах <code class="literal">BEFORE</code> условие <code class="literal">WHEN</code> вычисляется непосредственно перед тем, как триггерная функция будет выполнена, поэтому использование <code class="literal">WHEN</code> существенно не отличается от выполнения той же проверки в самом начале триггерной функции. Однако в триггерах <code class="literal">AFTER</code> условие <code class="literal">WHEN</code> вычисляется сразу после обновления строки и от этого зависит, будет ли поставлено в очередь событие запуска триггера в конце оператора или нет. Поэтому, когда условие <code class="literal">WHEN</code> в триггере <code class="literal">AFTER</code> не возвращает истину, не требуется ни постановка события в очередь, ни повторная выборка этой строки в конце оператора. Это может существенно ускорить работу операторов, изменяющих большое количество строк, с триггером, который должен сработать только для нескольких. В триггерах <code class="literal">INSTEAD OF</code> не поддерживается использование условий <code class="literal">WHEN</code>.</p><p>Как правило, триггеры <code class="literal">BEFORE</code> уровня строки используются для проверки или модификации данных, которые будут вставлены или изменены. Например, триггер <code class="literal">BEFORE</code> можно использовать для вставки текущего времени в столбец <code class="type">timestamp</code> или проверки, что два элемента строки согласованы между собой. Триггеры <code class="literal">AFTER</code> уровня строки наиболее разумно использовать для каскадного обновления данных в других таблицах или проверки согласованности сделанных изменений с данными в других таблицах. Причина для такого разделения работы в том, что триггер <code class="literal">AFTER</code> видит окончательное значение строки, в то время как для триггера <code class="literal">BEFORE</code> это не так, ведь могут быть другие триггеры <code class="literal">BEFORE</code>, которые сработают позже. Если нет особых причин для выбора между триггерами <code class="literal">BEFORE</code> или <code class="literal">AFTER</code>, то триггер <code class="literal">BEFORE</code> предпочтительнее, так как не требует сохранения информации об операции до конца работы оператора.</p><p>Если триггерная функция выполняет команды SQL, эти команды могут заново запускать триггеры. Это известно как каскадные триггеры. Прямых ограничений на количество каскадных уровней не существует. Вполне возможно, что каскадные вызовы приведут к рекурсивному срабатыванию одного и того же триггера. Например, в триггере <code class="command">INSERT</code> может выполняться команда, которая добавляет строку в эту же таблицу, тем самым опять вызывая триггер на <code class="command">INSERT</code>. Обязанность программиста не допускать бесконечную рекурсию в таких случаях.</p><p><a id="id-1.8.4.5.23.1" class="indexterm"></a> При определении триггера можно указывать аргументы. Цель включения аргументов в определение триггера в том, чтобы позволить разным триггерам с аналогичными требованиями вызывать одну и ту же функцию. В качестве примера можно создать обобщенную триггерную функцию, которая принимает два аргумента с именами столбцов и записывает текущего пользователя в первый аргумент и текущий штамп времени во второй. При правильном написании такая триггерная функция будет независима от конкретной таблицы, для которой она будет запускаться. Таким образом, одна и та же функция может использоваться при выполнении <code class="command">INSERT</code> в любую таблицу с соответствующими столбцами, чтобы, например, автоматически отслеживать создание записей в транзакционной таблице. Для триггеров <code class="command">UPDATE</code> аргументы также могут использоваться для отслеживания последних сделанных изменений.</p><p>У каждого языка программирования, поддерживающего триггеры, есть свой собственный метод доступа из триггерной функции к входным данным триггера. Входные данные триггера включают в себя тип события (например, <code class="command">INSERT</code> или <code class="command">UPDATE</code>), а также любые аргументы, перечисленные в <code class="command">CREATE TRIGGER</code>. Для триггеров уровня строки входные данные также включают строку <code class="varname">NEW</code> для триггеров <code class="command">INSERT</code> и <code class="command">UPDATE</code> и/или строку <code class="varname">OLD</code> для триггеров <code class="command">UPDATE</code> и <code class="command">DELETE</code>.</p><p>Триггеры уровня оператора по умолчанию не имеют возможностей для проверки отдельных строк, модифицированных оператором. Но триггер <code class="literal">AFTER STATEMENT</code> может запросить создание для него <em class="firstterm">переходных таблиц</em>, чтобы ему были доступны наборы затрагиваемых операцией строк. Триггерам <code class="literal">AFTER ROW</code> также могут предоставляться переходные таблицы, чтобы они могли видеть все изменения в таблице, а не только изменения в отдельных строках, для которых они срабатывают. Метод обращения к переходным таблицам определяется применяемым языком программирования, но обычно переходные таблицы представляются как временные таблицы только для чтения, к которым в триггерной функции можно обращаться, выполняя SQL-команды.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="triggers.html" title="Глава 39. Триггеры">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="triggers.html" title="Глава 39. Триггеры">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="trigger-datachanges.html" title="39.2. Видимость изменений в данных">След.</a></td></tr><tr><td width="40%" align="left" valign="top">Глава 39. Триггеры </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 39.2. Видимость изменений в данных</td></tr></table></div></body></html>