<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>71.3. Расширяемость</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="brin-builtin-opclasses.html" title="71.2. Встроенные классы операторов" /><link rel="next" href="hash-index.html" title="Глава 72. Хеш-индексы" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">71.3. Расширяемость</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="brin-builtin-opclasses.html" title="71.2. Встроенные классы операторов">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="brin.html" title="Глава 71. Индексы BRIN">Наверх</a></td><th width="60%" align="center">Глава 71. Индексы BRIN</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="hash-index.html" title="Глава 72. Хеш-индексы">След.</a></td></tr></table><hr /></div><div class="sect1" id="BRIN-EXTENSIBILITY"><div class="titlepage"><div><div><h2 class="title" style="clear: both">71.3. Расширяемость <a href="#BRIN-EXTENSIBILITY" class="id_link">#</a></h2></div></div></div><p>Интерфейс <acronym class="acronym">BRIN</acronym> характеризуется высоким уровнем абстракции и таким образом требует от разработчика метода доступа реализовать только смысловое наполнение обрабатываемого типа данных. Уровень <acronym class="acronym">BRIN</acronym> берёт на себя заботу о параллельном доступе, поддержке журнала и поиске в структуре индекса.</p><p>Всё, что нужно, чтобы получить работающий метод доступа <acronym class="acronym">BRIN</acronym> — это реализовать несколько пользовательских методов, определяющих поведение сводных значений, хранящихся в индексе, и их взаимоотношения с ключами сканирования. Словом, <acronym class="acronym">BRIN</acronym> сочетает расширяемость с универсальностью, повторным использованием кода и аккуратным интерфейсом.</p><p>Класс операторов для <acronym class="acronym">BRIN</acronym> должен предоставлять четыре метода: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="function">BrinOpcInfo *opcInfo(Oid type_oid)</code></span></dt><dd><p>Возвращает внутреннюю информацию о сводных данных индексированных столбцов. Возвращаемое значение должно указывать на <code class="structname">BrinOpcInfo</code> (в памяти palloc) со следующим определением: </p><pre class="programlisting">typedef struct BrinOpcInfo
{
    /* Число полей, хранящихся в столбце индекса этого класса операторов */
    uint16      oi_nstored;

    /* Непрозрачный указатель для внутреннего использования классом операторов */
    void       *oi_opaque;

    /* Элементы кеша типов для сохранённых столбцов */
    TypeCacheEntry *oi_typcache[FLEXIBLE_ARRAY_MEMBER];
} BrinOpcInfo;</pre><p> Поле <code class="structname">BrinOpcInfo</code>.<code class="structfield">oi_opaque</code> могут использовать подпрограммы класса операторов для передачи информации опорным функциям при сканировании индекса.</p></dd><dt><span class="term"><code class="function">bool consistent(BrinDesc *bdesc, BrinValues *column, ScanKey *keys, int nkeys)</code></span></dt><dd><p>Показывает, соответствуют ли все значения ScanKey заданным индексированным значениям некоторой зоны. Номер целевого атрибута передаётся в составе ключа сканирования. Для одного атрибута может передаваться несколько ключей сканирования. Количество записей определяется параметром <code class="literal">nkeys</code>.</p></dd><dt><span class="term"><code class="function">bool consistent(BrinDesc *bdesc, BrinValues *column, ScanKey key)</code></span></dt><dd><p>Показывает, соответствует ли значение ScanKey заданным индексированным значениям некоторой зоны. Номер целевого атрибута передаётся в составе ключа сканирования. Этот обратно совместимый вариант функции consistent устарел.</p></dd><dt><span class="term"><code class="function">bool addValue(BrinDesc *bdesc, BrinValues *column, Datum newval, bool isnull)</code></span></dt><dd><p>Для заданного кортежа индекса и индексируемого значения изменяет выбранный атрибут кортежа, чтобы он дополнительно охватывал новое значение. Если в кортеж вносятся какие-либо изменения, возвращается <code class="literal">true</code>.</p></dd><dt><span class="term"><code class="function">bool unionTuples(BrinDesc *bdesc, BrinValues *a, BrinValues *b)</code></span></dt><dd><p>Консолидирует два кортежа индекса. Получая два кортежа, изменяет выбранный атрибут первого из них, что он охватывал оба кортежа. Второй кортеж не изменяется.</p></dd></dl></div><p> Дополнительно класс операторов для <acronym class="acronym">BRIN</acronym> может предоставить следующий метод: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="function">void options(local_relopts *relopts)</code></span></dt><dd><p>Определяет набор видимых пользователю параметров, управляющих поведением класса операторов.</p><p>Функции <code class="function">options</code> передаётся указатель на структуру <code class="structname">local_relopts</code>, в которую нужно внести набор параметров, относящихся к классу операторов. Обращаться к этим параметрам из других опорных функций можно с помощью макросов <code class="literal">PG_HAS_OPCLASS_OPTIONS()</code> и <code class="literal">PG_GET_OPCLASS_OPTIONS()</code>.</p><p>Так как в <acronym class="acronym">BRIN</acronym> и извлечение ключа из индексируемых значений, и его представление допускают гибкость, могут быть полезны параметры для настройки этого индекса.</p></dd></dl></div><p> Основной дистрибутив включает поддержку четырёх типов классов операторов: minmax, minmax-multi, inclusion и bloom. Определения классов операторов, использующие их, представлены для встроенных типов данных, насколько это уместно. Пользователь может определить дополнительные классы операторов для других типов данных, применяя аналогичные определения, и обойтись таким образом без написания кода; достаточно будет объявить нужные записи в каталоге. Заметьте, что предположения о семантике стратегий операторов зашиты в исходном коде опорных функций.</p><p>Также возможно создать классы операторов, воплощающие полностью другую семантику, разработав реализации четырёх основных опорных функций, описанных выше. Заметьте, что обратная совместимость между разными основными версиями не гарантируется: к примеру, в следующих выпусках могут потребоваться дополнительные опорные функции.</p><p>При написании класса операторов для типа данных, представляющего полностью упорядоченное множество, можно использовать опорные функции minmax вместе с соответствующими операторами, как показано в <a class="xref" href="brin-extensibility.html#BRIN-EXTENSIBILITY-MINMAX-TABLE" title="Таблица 71.2. Номера стратегий и опорных функций для классов операторов minmax">Таблице 71.2</a>. Все члены класса операторов (функции и операторы) являются обязательными.</p><div class="table" id="BRIN-EXTENSIBILITY-MINMAX-TABLE"><p class="title"><strong>Таблица 71.2. Номера стратегий и опорных функций для классов операторов minmax</strong></p><div class="table-contents"><table class="table" summary="Номера стратегий и опорных функций для классов операторов minmax" border="1"><colgroup><col class="col1" /><col class="col2" /></colgroup><thead><tr><th>Член класса операторов</th><th>Объект</th></tr></thead><tbody><tr><td>Опорная функция 1</td><td>внутренняя функция <code class="function">brin_minmax_opcinfo()</code></td></tr><tr><td>Опорная функция 2</td><td>внутренняя функция <code class="function">brin_minmax_add_value()</code></td></tr><tr><td>Опорная функция 3</td><td>внутренняя функция <code class="function">brin_minmax_consistent()</code></td></tr><tr><td>Опорная функция 4</td><td>внутренняя функция <code class="function">brin_minmax_union()</code></td></tr><tr><td>Стратегия оператора 1</td><td>оператор меньше</td></tr><tr><td>Стратегия оператора 2</td><td>оператор меньше-или-равно</td></tr><tr><td>Стратегия оператора 3</td><td>оператор равно</td></tr><tr><td>Стратегия оператора 4</td><td>оператор больше-или-равно</td></tr><tr><td>Стратегия оператора 5</td><td>оператор больше</td></tr></tbody></table></div></div><br class="table-break" /><p>При написании класса операторов для сложного типа данных, значения которого включаются в другой тип, можно использовать опорные функции inclusion вместе с соответствующими операторами, как показано в <a class="xref" href="brin-extensibility.html#BRIN-EXTENSIBILITY-INCLUSION-TABLE" title="Таблица 71.3. Номера стратегий и опорных функций для классов операторов inclusion">Таблице 71.3</a>. Для этого требуется одна дополнительная функция, которую можно написать на любом языке. Для расширенной функциональности можно определить другие функции. Все операторы являются необязательными. Некоторые из них требует наличия других, что показано в таблице как зависимости.</p><div class="table" id="BRIN-EXTENSIBILITY-INCLUSION-TABLE"><p class="title"><strong>Таблица 71.3. Номера стратегий и опорных функций для классов операторов inclusion</strong></p><div class="table-contents"><table class="table" summary="Номера стратегий и опорных функций для классов операторов inclusion" border="1"><colgroup><col class="col1" /><col class="col2" /><col class="col3" /></colgroup><thead><tr><th>Член класса операторов</th><th>Объект</th><th>Зависимость</th></tr></thead><tbody><tr><td>Опорная функция 1</td><td>внутренняя функция <code class="function">brin_inclusion_opcinfo()</code></td><td> </td></tr><tr><td>Опорная функция 2</td><td>внутренняя функция <code class="function">brin_inclusion_add_value()</code></td><td> </td></tr><tr><td>Опорная функция 3</td><td>внутренняя функция <code class="function">brin_inclusion_consistent()</code></td><td> </td></tr><tr><td>Опорная функция 4</td><td>внутренняя функция <code class="function">brin_inclusion_union()</code></td><td> </td></tr><tr><td>Опорная функция 11</td><td>функция для слияния двух элементов</td><td> </td></tr><tr><td>Опорная функция 12</td><td>необязательная функция для проверки возможности слияния двух элементов</td><td> </td></tr><tr><td>Опорная функция 13</td><td>необязательная функция для проверки, содержится ли один элемент в другом</td><td> </td></tr><tr><td>Опорная функция 14</td><td>необязательная функция для проверки, является ли элемент пустым</td><td> </td></tr><tr><td>Стратегия оператора 1</td><td>оператор левее</td><td>Стратегия оператора 4</td></tr><tr><td>Стратегия оператора 2</td><td>оператор не-простирается-правее</td><td>Стратегия оператора 5</td></tr><tr><td>Стратегия оператора 3</td><td>оператор перекрывается</td><td> </td></tr><tr><td>Стратегия оператора 4</td><td>оператор не-простирается-левее</td><td>Стратегия оператора 1</td></tr><tr><td>Стратегия оператора 5</td><td>оператор правее</td><td>Стратегия оператора 2</td></tr><tr><td>Стратегия оператора 6, 18</td><td>оператор то-же-или-равно</td><td>Стратегия оператора 7</td></tr><tr><td>Стратегия оператора 7, 16, 24, 25</td><td>оператор содержит-или-равно</td><td> </td></tr><tr><td>Стратегия оператора 8, 26, 27</td><td>оператор содержится-в-или-равно</td><td>Стратегия оператора 3</td></tr><tr><td>Стратегия оператора 9</td><td>оператор не-простирается-выше</td><td>Стратегия оператора 11</td></tr><tr><td>Стратегия оператора 10</td><td>оператор ниже</td><td>Стратегия оператора 12</td></tr><tr><td>Стратегия оператора 11</td><td>оператор выше</td><td>Стратегия оператора 9</td></tr><tr><td>Стратегия оператора 12</td><td>оператор не-простирается-ниже</td><td>Стратегия оператора 10</td></tr><tr><td>Стратегия оператора 20</td><td>оператор меньше</td><td>Стратегия оператора 5</td></tr><tr><td>Стратегия оператора 21</td><td>оператор меньше-или-равно</td><td>Стратегия оператора 5</td></tr><tr><td>Стратегия оператора 22</td><td>оператор больше</td><td>Стратегия оператора 1</td></tr><tr><td>Стратегия оператора 23</td><td>оператор больше-или-равно</td><td>Стратегия оператора 1</td></tr></tbody></table></div></div><br class="table-break" /><p>Номера опорных функций от 1 до 10 зарезервированы для внутренних функций BRIN, так что функции уровня SQL начинаются с номера 11. Опорная функция номер 11 является основной, необходимой для построения индекса. Она должна принимать два аргумента того же типа данных, что и целевой тип класса, и возвращать их объединение. Класс операторов inclusion может сохранять значения объединения в различных типах данных, в зависимости от параметра <code class="literal">STORAGE</code>. Возвращаемое функцией объединения значение должно соответствовать типу данных <code class="literal">STORAGE</code>.</p><p>Опорные функции под номерами 12 и 14 предоставляются для поддержки нерегулярностей встроенных типов данных. Функция номер 12 применяется для поддержки работы с сетевыми адресами из различных семейств, которые нельзя объединять. Функция номер 14 применяется для поддержки зон с пустыми значениями. Функция номер 13 является необязательной, но рекомендуемой; она проверяет новое значение, прежде чем оно будет передано функции объединения. Инфраструктура BRIN может соптимизировать некоторые операции, когда объединение не меняется, поэтому применение этой функции может способствовать увеличению быстродействия индекса.</p><p>При написании класса операторов для типа данных, который реализует только оператор равенства и поддерживает хеширование, можно использовать опорные процедуры bloom вместе с соответствующими операторами, как показано в <a class="xref" href="brin-extensibility.html#BRIN-EXTENSIBILITY-BLOOM-TABLE" title="Таблица 71.4. Номера стратегий и опорных процедур для классов операторов bloom">Таблица 71.4</a>. Все члены класса операторов (процедуры и операторы) являются обязательными.</p><div class="table" id="BRIN-EXTENSIBILITY-BLOOM-TABLE"><p class="title"><strong>Таблица 71.4. Номера стратегий и опорных процедур для классов операторов bloom</strong></p><div class="table-contents"><table class="table" summary="Номера стратегий и опорных процедур для классов операторов bloom" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Член класса операторов</th><th>Объект</th></tr></thead><tbody><tr><td>Опорная процедура 1</td><td>внутренняя функция <code class="function">brin_bloom_opcinfo()</code></td></tr><tr><td>Опорная процедура 2</td><td>внутренняя функция <code class="function">brin_bloom_add_value()</code></td></tr><tr><td>Опорная процедура 3</td><td>внутренняя функция <code class="function">brin_bloom_consistent()</code></td></tr><tr><td>Опорная процедура 4</td><td>внутренняя функция <code class="function">brin_bloom_union()</code></td></tr><tr><td>Опорная процедура 5</td><td>внутренняя функция <code class="function">brin_bloom_options()</code></td></tr><tr><td>Опорная процедура 11</td><td>функция для вычисления хеша элемента</td></tr><tr><td>Стратегия оператора 1</td><td>оператор равно</td></tr></tbody></table></div></div><br class="table-break" /><p>Номера опорных процедур 1-10 зарезервированы для внутренних функций BRIN, так что функции уровня SQL начинаются с номера 11. Опорная функция номер 11 является основной, необходимой для построения индекса. Она должна принимать один аргумент того же типа данных, что и класс оператора, и возвращать хеш значения.</p><p>Класс операторов minmax-multi также используется для типов данных, представляющих полностью упорядоченное множество, и может рассматриваться просто как расширение класса операторов minmax. Класс операторов minmax для каждого блока обобщает информацию по значениям в один непрерывный интервал, а minmax-multi позволяет обобщить информацию по значениям в несколько меньших интервалов для более эффективной обработки выпадающих значений. При написании класса операторов можно использовать опорные процедуры minmax-multi вместе с соответствующими операторами, как показано в <a class="xref" href="brin-extensibility.html#BRIN-EXTENSIBILITY-MINMAX-MULTI-TABLE" title="Таблица 71.5. Номера стратегий и опорных процедур для классов операторов minmax-multi">Таблица 71.5</a>. Все члены класса операторов (процедуры и операторы) являются обязательными.</p><div class="table" id="BRIN-EXTENSIBILITY-MINMAX-MULTI-TABLE"><p class="title"><strong>Таблица 71.5. Номера стратегий и опорных процедур для классов операторов minmax-multi</strong></p><div class="table-contents"><table class="table" summary="Номера стратегий и опорных процедур для классов операторов minmax-multi" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Член класса операторов</th><th>Объект</th></tr></thead><tbody><tr><td>Опорная процедура 1</td><td>внутренняя функция <code class="function">brin_minmax_multi_opcinfo()</code></td></tr><tr><td>Опорная процедура 2</td><td>внутренняя функция <code class="function">brin_minmax_add_value()</code></td></tr><tr><td>Опорная процедура 3</td><td>внутренняя функция <code class="function">brin_minmax_consistent()</code></td></tr><tr><td>Опорная процедура 4</td><td>внутренняя функция <code class="function">brin_minmax_union()</code></td></tr><tr><td>Опорная процедура 5</td><td>внутренняя функция <code class="function">brin_minmax_multi_options()</code></td></tr><tr><td>Опорная процедура 11</td><td>функция для вычисления расстояния между двумя значениями (размер зоны)</td></tr><tr><td>Стратегия оператора 1</td><td>оператор меньше</td></tr><tr><td>Стратегия оператора 2</td><td>оператор меньше-или-равно</td></tr><tr><td>Стратегия оператора 3</td><td>оператор равно</td></tr><tr><td>Стратегия оператора 4</td><td>оператор больше-или-равно</td></tr><tr><td>Стратегия оператора 5</td><td>оператор больше</td></tr></tbody></table></div></div><br class="table-break" /><p>Классы операторов minmax и inclusion поддерживают межтиповые операторы, хотя с ними зависимости становятся более сложными. Класс minmax требует, чтобы для двух аргументов одного типа определялся полный набор операторов. Это позволяет поддерживать дополнительные типы данных, определяя дополнительные наборы операторов. Стратегии операторов класса inclusion могут зависеть от других стратегий, как показано в <a class="xref" href="brin-extensibility.html#BRIN-EXTENSIBILITY-INCLUSION-TABLE" title="Таблица 71.3. Номера стратегий и опорных функций для классов операторов inclusion">Таблице 71.3</a>, или от своих собственных стратегий. Для них требуется, чтобы был определён необходимый оператор с типом данных <code class="literal">STORAGE</code> для левого аргумента и другим поддерживаемым типом для правого аргумента реализуемого оператора. См. определение <code class="literal">float4_minmax_ops</code> в качестве примера для minmax и <code class="literal">box_inclusion_ops</code> в качестве примера для inclusion.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="brin-builtin-opclasses.html" title="71.2. Встроенные классы операторов">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="brin.html" title="Глава 71. Индексы BRIN">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="hash-index.html" title="Глава 72. Хеш-индексы">След.</a></td></tr><tr><td width="40%" align="left" valign="top">71.2. Встроенные классы операторов </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> Глава 72. Хеш-индексы</td></tr></table></div></body></html>