<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>34.1. Функции управления подключением к базе данных</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="libpq.html" title="Глава 34. libpq — библиотека для языка C" /><link rel="next" href="libpq-status.html" title="34.2. Функции, описывающие текущее состояние подключения" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">34.1. Функции управления подключением к базе данных</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="libpq.html" title="Глава 34. libpq — библиотека для языка C">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="libpq.html" title="Глава 34. libpq — библиотека для языка C">Наверх</a></td><th width="60%" align="center">Глава 34. <span class="application">libpq</span> — библиотека для языка C</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="libpq-status.html" title="34.2. Функции, описывающие текущее состояние подключения">След.</a></td></tr></table><hr /></div><div class="sect1" id="LIBPQ-CONNECT"><div class="titlepage"><div><div><h2 class="title" style="clear: both">34.1. Функции управления подключением к базе данных <a href="#LIBPQ-CONNECT" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="libpq-connect.html#LIBPQ-CONNSTRING">34.1.1. Строки параметров подключения</a></span></dt><dt><span class="sect2"><a href="libpq-connect.html#LIBPQ-PARAMKEYWORDS">34.1.2. Ключевые слова-параметры</a></span></dt></dl></div><p>Следующие функции имеют дело с созданием подключения к серверу <span class="productname">PostgreSQL</span>. Прикладная программа может иметь несколько подключений к серверу, открытых одновременно. (Одна из причин этого заключается в необходимости доступа к более чем одной базе данных.) Каждое соединение представляется объектом <code class="structname">PGconn</code><a id="id-1.7.3.8.2.3" class="indexterm"></a>, который можно получить от функции <a class="xref" href="libpq-connect.html#LIBPQ-PQCONNECTDB"><code class="function">PQconnectdb</code></a>, <a class="xref" href="libpq-connect.html#LIBPQ-PQCONNECTDBPARAMS"><code class="function">PQconnectdbParams</code></a> или <a class="xref" href="libpq-connect.html#LIBPQ-PQSETDBLOGIN"><code class="function">PQsetdbLogin</code></a>. Обратите внимание, что эти функции всегда возвращают ненулевой указатель на объект, кроме случая, когда не остаётся свободной памяти даже для объекта <code class="structname">PGconn</code>. Прежде чем передавать запросы через объект подключения, следует вызвать функцию <a class="xref" href="libpq-status.html#LIBPQ-PQSTATUS"><code class="function">PQstatus</code></a> для проверки возвращаемого значения в случае успешного подключения. </p><div class="warning"><h3 class="title">Предупреждение</h3><p>Если к базе данных, которая не приведена в соответствие <a class="link" href="ddl-schemas.html#DDL-SCHEMAS-PATTERNS" title="5.9.6. Шаблоны использования">шаблону безопасного использования схем</a>, имеют доступ недоверенные пользователи, начинайте сеанс с удаления доступных им для записи схем из пути поиска (<code class="varname">search_path</code>). Для этого можно присвоить параметру с ключом <code class="literal">options</code> значение <code class="literal">-csearch_path=</code>. Также можно выполнить <code class="literal">PQexec(<em class="replaceable"><code>соединение</code></em>, "SELECT pg_catalog.set_config('search_path', '', false)")</code> после подключения. Это касается не только <span class="application">psql</span>, но и любых других интерфейсов для выполнения произвольных SQL-команд.</p></div><p> </p><div class="warning"><h3 class="title">Предупреждение</h3><p>В системе Unix создание дочернего процесса на основе процесса, уже имеющего открытые подключения с помощью libpq, может привести к непредсказуемым результатам, потому что родительский и дочерний процессы совместно используют одни и те же сокеты и ресурсы операционной системы. По этой причине подобный подход не рекомендуется. Однако использование системного вызова <code class="function">exec</code> из дочернего процесса для загрузки нового исполняемого файла является безопасным.</p></div><p> </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQCONNECTDBPARAMS"><span class="term"><code class="function">PQconnectdbParams</code><a id="id-1.7.3.8.2.11.1.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQCONNECTDBPARAMS" class="id_link">#</a></dt><dd><p>Создаёт новое подключение к серверу баз данных. </p><pre class="synopsis">
PGconn *PQconnectdbParams(const char * const *keywords,
                          const char * const *values,
                          int expand_dbname);
</pre><p>Эта функция открывает новое соединение с базой данных, используя параметры, содержащиеся в двух массивах, завершающихся символом <code class="symbol">NULL</code>. Первый из них, <code class="literal">keywords</code>, определяется как массив строк, каждая из которых представляет собой ключевое слово. Второй, <code class="literal">values</code>, даёт значение для каждого ключевого слова. В отличие от функции <a class="xref" href="libpq-connect.html#LIBPQ-PQSETDBLOGIN"><code class="function">PQsetdbLogin</code></a>, описываемой ниже, её набор параметров может быть расширен без изменения сигнатуры функции, поэтому при разработке новых приложений предпочтительнее использовать данную функцию (или её неблокирующие аналоги <a class="xref" href="libpq-connect.html#LIBPQ-PQCONNECTSTARTPARAMS"><code class="function">PQconnectStartParams</code></a> и <code class="function">PQconnectPoll</code>).</p><p>Ключевые слова-параметры, распознаваемые в настоящее время, приведены в <a class="xref" href="libpq-connect.html#LIBPQ-PARAMKEYWORDS" title="34.1.2. Ключевые слова-параметры">Подразделе 34.1.2</a>.</p><p>Передаваемые массивы могут быть пустыми (в этом случае будут использоваться все параметры по умолчанию) или содержать одно или несколько имён/значений параметров. При этом они должны быть одинаковой длины. Просмотр массивов завершается, как только в массиве <code class="literal">keywords</code> встречается <code class="symbol">NULL</code>. Если элемент массива <code class="literal">values</code>, соответствующий отличному от <code class="symbol">NULL</code> элементу <code class="literal">keywords</code>, содержит пустую строку или NULL, такой параметр пропускается и просматривается следующая пара элементов массива.</p><p>Когда <code class="literal">expand_dbname</code> имеет ненулевое значение, первый параметр <em class="parameter"><code>dbname</code></em> может содержать <em class="firstterm">строку подключения</em>. В этом случае она <span class="quote">«<span class="quote">разворачивается</span>»</span> в отдельные параметры подключения, извлечённые из этой строки. Значение считается строкой подключения, а не просто именем базы данных, если оно содержит знак равно (<code class="literal">=</code>) или начинается с обозначения схемы URI. (Подробнее форматы строк подключения описаны в <a class="xref" href="libpq-connect.html#LIBPQ-CONNSTRING" title="34.1.1. Строки параметров подключения">Подразделе 34.1.1</a>.) Таким способом обрабатывается только первое вхождение <em class="parameter"><code>dbname</code></em>, следующие параметры <em class="parameter"><code>dbname</code></em> будут восприниматься как просто имя базы данных.</p><p>Как правило, массивы параметров обрабатываются от начала к концу. Если какой-либо параметр указывается неоднократно, использоваться будет последнее значение (отличное от <code class="symbol">NULL</code> и непустое). Это справедливо, в частности, и тогда, когда ключевое слово, заданное в строке подключения, конфликтует с заданным в массиве <code class="literal">keywords</code>. Таким образом, программист может по своему усмотрению решить, будут ли значения в массиве переопределять значения, заданными в строке подключения, или переопределяться ими. Элементы массива, предшествующие развёрнутому значению <em class="parameter"><code>dbname</code></em>, могут быть переопределены значениями в строке подключения, которые в свою очередь переопределяются элементами массива, следующими после <em class="parameter"><code>dbname</code></em> (и в этом случае речь идёт о непустых значениях).</p><p>После разбора всех элементов массива и развёрнутой строки подключения (если она задана), параметры подключения, которые остались незаданными, получают значения по умолчанию. Если незаданному параметру соответствует установленная переменная окружения (см. <a class="xref" href="libpq-envars.html" title="34.15. Переменные окружения">Раздел 34.15</a>), будет использоваться её значение. Если такая переменная не задана, для параметра будет использоваться встроенное значение по умолчанию.</p></dd><dt id="LIBPQ-PQCONNECTDB"><span class="term"><code class="function">PQconnectdb</code><a id="id-1.7.3.8.2.11.2.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQCONNECTDB" class="id_link">#</a></dt><dd><p>Создаёт новое подключение к серверу баз данных. </p><pre class="synopsis">
PGconn *PQconnectdb(const char *conninfo);
</pre><p>Эта функция открывает новое соединение с базой данных, используя параметры, полученные из строки <code class="literal">conninfo</code>.</p><p>Передаваемая строка может быть пустой. В этом случае используются все параметры по умолчанию. Она также может содержать одно или более значений параметров, разделённых пробелами, или <acronym class="acronym">URI</acronym>. За подробностями обратитесь к <a class="xref" href="libpq-connect.html#LIBPQ-CONNSTRING" title="34.1.1. Строки параметров подключения">Подразделу 34.1.1</a>.</p></dd><dt id="LIBPQ-PQSETDBLOGIN"><span class="term"><code class="function">PQsetdbLogin</code><a id="id-1.7.3.8.2.11.3.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQSETDBLOGIN" class="id_link">#</a></dt><dd><p>Создаёт новое подключение к серверу баз данных. </p><pre class="synopsis">
PGconn *PQsetdbLogin(const char *pghost,
                     const char *pgport,
                     const char *pgoptions,
                     const char *pgtty,
                     const char *dbName,
                     const char *login,
                     const char *pwd);
</pre><p>Это предшественница функции <a class="xref" href="libpq-connect.html#LIBPQ-PQCONNECTDB"><code class="function">PQconnectdb</code></a> с фиксированным набором параметров. Она имеет такую же функциональность, за исключением того, что отсутствующие параметры всегда принимают значения по умолчанию. Подставьте <code class="symbol">NULL</code> или пустую строку в качестве любого из фиксированных параметров, которые должны принять значения по умолчанию.</p><p>Если параметр <em class="parameter"><code>dbName</code></em> содержит знак <code class="symbol">=</code> или имеет допустимый префикс <acronym class="acronym">URI</acronym> для подключения, то он воспринимается в качестве строки <em class="parameter"><code>conninfo</code></em> точно таким же образом, как если бы он был передан функции <a class="xref" href="libpq-connect.html#LIBPQ-PQCONNECTDB"><code class="function">PQconnectdb</code></a>, а оставшиеся параметры применяются, как указано для <a class="xref" href="libpq-connect.html#LIBPQ-PQCONNECTDBPARAMS"><code class="function">PQconnectdbParams</code></a>.</p><p><code class="literal">pgtty</code> больше не используется, и любое переданное значение будет проигнорировано.</p></dd><dt id="LIBPQ-PQSETDB"><span class="term"><code class="function">PQsetdb</code><a id="id-1.7.3.8.2.11.4.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQSETDB" class="id_link">#</a></dt><dd><p>Создаёт новое подключение к серверу баз данных. </p><pre class="synopsis">
PGconn *PQsetdb(char *pghost,
                char *pgport,
                char *pgoptions,
                char *pgtty,
                char *dbName);
</pre><p>Это макрос, который вызывает <a class="xref" href="libpq-connect.html#LIBPQ-PQSETDBLOGIN"><code class="function">PQsetdbLogin</code></a> с нулевыми указателями в качестве значений параметров <em class="parameter"><code>login</code></em> и <em class="parameter"><code>pwd</code></em>. Обеспечивает обратную совместимость с очень старыми программами.</p></dd><dt id="LIBPQ-PQCONNECTSTARTPARAMS"><span class="term"><code class="function">PQconnectStartParams</code><a id="id-1.7.3.8.2.11.5.1.2" class="indexterm"></a><br /></span><span class="term"><code class="function">PQconnectStart</code><a id="id-1.7.3.8.2.11.5.2.2" class="indexterm"></a><br /></span><span class="term"><code class="function">PQconnectPoll</code><a id="id-1.7.3.8.2.11.5.3.2" class="indexterm"></a></span> <a href="#LIBPQ-PQCONNECTSTARTPARAMS" class="id_link">#</a></dt><dd><p><a id="id-1.7.3.8.2.11.5.4.1.1" class="indexterm"></a> Создают подключение к серверу баз данных неблокирующим способом. </p><pre class="synopsis">
PGconn *PQconnectStartParams(const char * const *keywords,
                             const char * const *values,
                             int expand_dbname);

PGconn *PQconnectStart(const char *conninfo);

PostgresPollingStatusType PQconnectPoll(PGconn *conn);
</pre><p>Три эти функции используются для того, чтобы открыть подключение к серверу баз данных таким образом, чтобы поток исполнения вашего приложения не был заблокирован при выполнении удалённой операции ввода/вывода в процессе подключения. Суть этого подхода в том, чтобы ожидание завершения операций ввода/вывода могло происходить в главном цикле приложения, а не внутри функций <a class="xref" href="libpq-connect.html#LIBPQ-PQCONNECTDBPARAMS"><code class="function">PQconnectdbParams</code></a> или <a class="xref" href="libpq-connect.html#LIBPQ-PQCONNECTDB"><code class="function">PQconnectdb</code></a>, с тем, чтобы приложение могло управлять этой операцией параллельно с другой работой.</p><p>С помощью функции <a class="xref" href="libpq-connect.html#LIBPQ-PQCONNECTSTARTPARAMS"><code class="function">PQconnectStartParams</code></a> подключение к базе данных выполняется, используя параметры, взятые из массивов <code class="literal">keywords</code> и <code class="literal">values</code>, а управление осуществляется с помощью <code class="literal">expand_dbname</code>, как описано выше для <a class="xref" href="libpq-connect.html#LIBPQ-PQCONNECTDBPARAMS"><code class="function">PQconnectdbParams</code></a>.</p><p>С помощью функции <code class="function">PQconnectStart</code> подключение к базе данных выполняется, используя параметры, взятые из строки <code class="literal">conninfo</code>, как описано выше для <a class="xref" href="libpq-connect.html#LIBPQ-PQCONNECTDB"><code class="function">PQconnectdb</code></a>.</p><p>Ни <a class="xref" href="libpq-connect.html#LIBPQ-PQCONNECTSTARTPARAMS"><code class="function">PQconnectStartParams</code></a>, ни <code class="function">PQconnectStart</code>, ни <code class="function">PQconnectPoll</code> не заблокируются до тех пор, пока выполняется ряд ограничений: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Параметр <code class="literal">hostaddr</code> должен использоваться так, чтобы для разрешения заданного имени не требовалось выполнять запросы DNS. Подробнее этот параметр описан в <a class="xref" href="libpq-connect.html#LIBPQ-PARAMKEYWORDS" title="34.1.2. Ключевые слова-параметры">Подразделе 34.1.2</a>.</p></li><li class="listitem"><p>Если вы вызываете <a class="xref" href="libpq-control.html#LIBPQ-PQTRACE"><code class="function">PQtrace</code></a>, сделайте так, чтобы поток, в который выводится трассировочная информация, не заблокировался.</p></li><li class="listitem"><p>Перед вызовом <code class="function">PQconnectPoll</code> вы должны перевести сокет в соответствующее состояние, как описано ниже.</p></li></ul></div><p>Чтобы начать неблокирующий запрос на подключение, вызовите <code class="function">PQconnectStart</code> или <a class="xref" href="libpq-connect.html#LIBPQ-PQCONNECTSTARTPARAMS"><code class="function">PQconnectStartParams</code></a>. Если результатом будет null, значит <span class="application">libpq</span> не смогла выделить память для новой структуры <code class="structname">PGconn</code>. В противном случае возвращается действительный указатель <code class="structname">PGconn</code> (хотя он ещё не представляет установленное подключение к базе данных). Затем вызовите <code class="literal">PQstatus(conn)</code>. Если результатом будет <code class="symbol">CONNECTION_BAD</code>, значит попытка подключения уже не будет успешной, возможно, из-за неверных параметров.</p><p>Если вызов <code class="function">PQconnectStart</code> или <a class="xref" href="libpq-connect.html#LIBPQ-PQCONNECTSTARTPARAMS"><code class="function">PQconnectStartParams</code></a> оказался успешным, теперь нужно опросить <span class="application">libpq</span> для продолжения процедуры подключения. Вызовите <code class="function">PQsocket(conn)</code> для получения дескриптора нижележащего сокета, через который устанавливается соединение. (Внимание: этот сокет может меняться от вызова к вызову <code class="function">PQconnectPoll</code>.) Организуйте цикл таким образом: если <code class="function">PQconnectPoll(conn)</code> при последнем вызове возвращает <code class="symbol">PGRES_POLLING_READING</code>, ожидайте, пока сокет не окажется готовым для чтения (это покажет функция <code class="function">select()</code>, <code class="function">poll()</code> или подобная системная функция). Затем снова вызовите <code class="function">PQconnectPoll(conn)</code>. Если же <code class="function">PQconnectPoll(conn)</code> при последнем вызове возвратила <code class="symbol">PGRES_POLLING_WRITING</code>, дождитесь готовности сокета к записи, а затем снова вызовите <code class="function">PQconnectPoll(conn)</code>. На первой итерации, то есть когда вы ещё не вызывали <code class="function">PQconnectPoll</code>, реализуйте то же поведение, что и после получения <code class="symbol">PGRES_POLLING_WRITING</code>. Продолжайте этот цикл, пока <code class="function">PQconnectPoll(conn)</code> не выдаст значение <code class="symbol">PGRES_POLLING_FAILED</code>, сигнализирующее об ошибке при установлении соединения, или <code class="symbol">PGRES_POLLING_OK</code>, показывающее, что соединение установлено успешно.</p><p>В любое время в процессе подключения его состояние можно проверить, вызвав <a class="xref" href="libpq-status.html#LIBPQ-PQSTATUS"><code class="function">PQstatus</code></a>. Если этот вызов возвратит <code class="symbol">CONNECTION_BAD</code>, значит, процедура подключения завершилась сбоем; если вызов возвратит <code class="function">CONNECTION_OK</code>, значит, соединение готово. Оба эти состояния можно определить на основе возвращаемого значения функции <code class="function">PQconnectPoll</code>, описанной выше. Другие состояния могут также иметь место в течение (и только в течение) асинхронной процедуры подключения. Они показывают текущую стадию процедуры подключения и могут быть полезны, например, для предоставления обратной связи пользователю. Вот эти состояния: </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-CONNECTION-STARTED"><span class="term"><code class="symbol">CONNECTION_STARTED</code></span> <a href="#LIBPQ-CONNECTION-STARTED" class="id_link">#</a></dt><dd><p>Ожидание, пока соединение будет установлено.</p></dd><dt id="LIBPQ-CONNECTION-MADE"><span class="term"><code class="symbol">CONNECTION_MADE</code></span> <a href="#LIBPQ-CONNECTION-MADE" class="id_link">#</a></dt><dd><p>Соединение установлено; ожидание отправки.</p></dd><dt id="LIBPQ-CONNECTION-AWAITING-RESPONSE"><span class="term"><code class="symbol">CONNECTION_AWAITING_RESPONSE</code></span> <a href="#LIBPQ-CONNECTION-AWAITING-RESPONSE" class="id_link">#</a></dt><dd><p>Ожидание ответа от сервера.</p></dd><dt id="LIBPQ-CONNECTION-AUTH-OK"><span class="term"><code class="symbol">CONNECTION_AUTH_OK</code></span> <a href="#LIBPQ-CONNECTION-AUTH-OK" class="id_link">#</a></dt><dd><p>Аутентификация получена; ожидание завершения запуска серверной части.</p></dd><dt id="LIBPQ-CONNECTION-SSL-STARTUP"><span class="term"><code class="symbol">CONNECTION_SSL_STARTUP</code></span> <a href="#LIBPQ-CONNECTION-SSL-STARTUP" class="id_link">#</a></dt><dd><p>Согласование SSL-шифрования.</p></dd><dt id="LIBPQ-CONNECTION-SETENV"><span class="term"><code class="symbol">CONNECTION_SETENV</code></span> <a href="#LIBPQ-CONNECTION-SETENV" class="id_link">#</a></dt><dd><p>Согласование значений параметров, зависящих от программной среды.</p></dd><dt id="LIBPQ-CONNECTION-CHECK-WRITABLE"><span class="term"><code class="symbol">CONNECTION_CHECK_WRITABLE</code></span> <a href="#LIBPQ-CONNECTION-CHECK-WRITABLE" class="id_link">#</a></dt><dd><p>Проверка, можно ли через подключение выполнять пишущие транзакции.</p></dd><dt id="LIBPQ-CONNECTION-CONSUME"><span class="term"><code class="symbol">CONNECTION_CONSUME</code></span> <a href="#LIBPQ-CONNECTION-CONSUME" class="id_link">#</a></dt><dd><p>Прочтение всех оставшихся ответных сообщений через подключение.</p></dd></dl></div><p> Заметьте, что, хотя эти константы и сохранятся (для поддержания совместимости), приложение никогда не должно полагаться на то, что они появятся в каком-то конкретном порядке или вообще появятся, а также на то, что состояние всегда примет одно из этих документированных значений. Приложение может сделать что-то наподобие: </p><pre class="programlisting">switch(PQstatus(conn))
{
        case CONNECTION_STARTED:
            feedback = "Подключение...";
            break;

        case CONNECTION_MADE:
            feedback = "Подключён к серверу...";
            break;
.
.
.
        default:
            feedback = "Подключение...";
}</pre><p>Параметр подключения <code class="literal">connect_timeout</code> игнорируется, когда используется <code class="function">PQconnectPoll</code>; именно приложение отвечает за принятие решения о том, является ли истекшее время чрезмерным. В противном случае вызов <code class="function">PQconnectStart</code> с последующим вызовом <code class="function">PQconnectPoll</code> в цикле будут эквивалентны вызову <a class="xref" href="libpq-connect.html#LIBPQ-PQCONNECTDB"><code class="function">PQconnectdb</code></a>.</p><p>Заметьте, что когда функция <code class="function">PQconnectStart</code> или <a class="xref" href="libpq-connect.html#LIBPQ-PQCONNECTSTARTPARAMS"><code class="function">PQconnectStartParams</code></a> возвращает ненулевой указатель, вы должны вызвать <a class="xref" href="libpq-connect.html#LIBPQ-PQFINISH"><code class="function">PQfinish</code></a>, закончив его использование, чтобы освободить полученную структуру и все связанные с ней блоки памяти. Это нужно сделать, даже если попытка подключения оказалась неудачной или подключение не потребовалось.</p></dd><dt id="LIBPQ-PQCONNDEFAULTS"><span class="term"><code class="function">PQconndefaults</code><a id="id-1.7.3.8.2.11.6.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQCONNDEFAULTS" class="id_link">#</a></dt><dd><p>Возвращает значения по умолчанию для параметров подключения. </p><pre class="synopsis">
PQconninfoOption *PQconndefaults(void);

typedef struct
{
    char   *keyword;   /* Ключевое слово для данного параметра */
    char   *envvar;    /* Имя альтернативной переменной окружения */
    char   *compiled;  /* Альтернативное значение по умолчанию, назначенное при компиляции */
    char   *val;       /* Текущее значение параметра или NULL */
    char   *label;     /* Обозначение этого поля в диалоге подключения */
    char   *dispchar;  /* Показывает, как отображать это поле
                          в диалоге подключения. Значения следующие:
                          ""        Отображать введённое значение "как есть"
                          "*"       Поле пароля — скрывать значение
                          "D"       Параметр отладки — не показывать по умолчанию */
    int     dispsize;  /* Размер поля в символах для диалога */
} PQconninfoOption;
</pre><p>Возвращает массив параметров подключения. Он может использоваться для определения всех возможных параметров <a class="xref" href="libpq-connect.html#LIBPQ-PQCONNECTDB"><code class="function">PQconnectdb</code></a> и их текущих значений по умолчанию. Возвращаемое значение указывает на массив структур <code class="structname">PQconninfoOption</code>, который завершается элементом, имеющим нулевой указатель <code class="structfield">keyword</code>. Если выделить память не удалось, то возвращается нулевой указатель. Обратите внимание, что текущие значения по умолчанию (поля <code class="structfield">val</code>) будут зависеть от переменных среды и другого контекста. Отсутствующий или неверный файл служб будет просто проигнорирован. Вызывающие функции должны рассматривать данные параметров подключения как данные только для чтения.</p><p>После обработки массива параметров освободите память, передав его функции <a class="xref" href="libpq-misc.html#LIBPQ-PQCONNINFOFREE"><code class="function">PQconninfoFree</code></a>. Если этого не делать, то при каждом вызове функции <a class="xref" href="libpq-connect.html#LIBPQ-PQCONNDEFAULTS"><code class="function">PQconndefaults</code></a> будет теряться небольшой объём памяти.</p></dd><dt id="LIBPQ-PQCONNINFO"><span class="term"><code class="function">PQconninfo</code><a id="id-1.7.3.8.2.11.7.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQCONNINFO" class="id_link">#</a></dt><dd><p>Возвращает параметры подключения, используемые действующим соединением. </p><pre class="synopsis">
PQconninfoOption *PQconninfo(PGconn *conn);
</pre><p>Возвращает массив параметров подключения. Он может использоваться для определения всех возможных параметров <a class="xref" href="libpq-connect.html#LIBPQ-PQCONNECTDB"><code class="function">PQconnectdb</code></a> и значений, которые были использованы для подключения к серверу. Возвращаемое значение указывает на массив структур <code class="structname">PQconninfoOption</code>, который завершается элементом, имеющим нулевой указатель <code class="structfield">keyword</code>. Все замечания, приведённые выше для <a class="xref" href="libpq-connect.html#LIBPQ-PQCONNDEFAULTS"><code class="function">PQconndefaults</code></a>, также справедливы и для результата <a class="xref" href="libpq-connect.html#LIBPQ-PQCONNINFO"><code class="function">PQconninfo</code></a>.</p></dd><dt id="LIBPQ-PQCONNINFOPARSE"><span class="term"><code class="function">PQconninfoParse</code><a id="id-1.7.3.8.2.11.8.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQCONNINFOPARSE" class="id_link">#</a></dt><dd><p>Возвращает разобранные параметры подключения, переданные в строке подключения. </p><pre class="synopsis">
PQconninfoOption *PQconninfoParse(const char *conninfo, char **errmsg);
</pre><p>Разбирает строку подключения и возвращает результирующие параметры в виде массива; возвращает <code class="symbol">NULL</code>, если возникают проблемы при разборе строки подключения. Эту функцию можно использовать для извлечения параметров функции <a class="xref" href="libpq-connect.html#LIBPQ-PQCONNECTDB"><code class="function">PQconnectdb</code></a> из предоставленной строки подключения. Возвращаемое значение указывает на массив структур <code class="structname">PQconninfoOption</code>, который завершается элементом, имеющим нулевой указатель <code class="structfield">keyword</code>.</p><p>Все разрешённые параметры будут присутствовать в результирующем массиве, но <code class="literal">PQconninfoOption</code> для любого параметра, не присутствующего в строке подключения, будет иметь значение <code class="literal">NULL</code> в поле <code class="literal">val</code>; значения по умолчанию не подставляются.</p><p>Если <code class="literal">errmsg</code> не равно <code class="symbol">NULL</code>, тогда в случае успеха <code class="literal">*errmsg</code> присваивается <code class="symbol">NULL</code>, а в противном случае -- адрес строки сообщения об ошибке, объясняющего проблему. Память для этой строки выделяет функция <code class="function">malloc</code>. (Также возможна ситуация, когда <code class="literal">*errmsg</code> будет установлено в <code class="symbol">NULL</code>, и при этом функция возвращает <code class="symbol">NULL</code>. Это указывает на нехватку памяти.)</p><p>После обработки массива параметров освободите память, передав его функции <a class="xref" href="libpq-misc.html#LIBPQ-PQCONNINFOFREE"><code class="function">PQconninfoFree</code></a>. Если этого не делать, некоторое количество памяти будет теряться при каждом вызове <a class="xref" href="libpq-connect.html#LIBPQ-PQCONNINFOPARSE"><code class="function">PQconninfoParse</code></a>. Если же произошла ошибка и <code class="literal">errmsg</code>, указывающий на строку сообщения об ошибке, не равен <code class="symbol">NULL</code>, не забудьте освободить память с этой строкой, вызвав <a class="xref" href="libpq-misc.html#LIBPQ-PQFREEMEM"><code class="function">PQfreemem</code></a>.</p></dd><dt id="LIBPQ-PQFINISH"><span class="term"><code class="function">PQfinish</code><a id="id-1.7.3.8.2.11.9.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQFINISH" class="id_link">#</a></dt><dd><p>Закрывает соединение с сервером. Также освобождает память, используемую объектом <code class="structname">PGconn</code>. </p><pre class="synopsis">
void PQfinish(PGconn *conn);
</pre><p>Обратите внимание, что даже если попытка подключения к серверу потерпела неудачу (как показывает <a class="xref" href="libpq-status.html#LIBPQ-PQSTATUS"><code class="function">PQstatus</code></a>), приложение все равно должно вызвать <a class="xref" href="libpq-connect.html#LIBPQ-PQFINISH"><code class="function">PQfinish</code></a>, чтобы освободить память, используемую объектом <code class="structname">PGconn</code>. Указатель <code class="structname">PGconn</code> не должен использоваться повторно после того, как была вызвана функция <a class="xref" href="libpq-connect.html#LIBPQ-PQFINISH"><code class="function">PQfinish</code></a>.</p></dd><dt id="LIBPQ-PQRESET"><span class="term"><code class="function">PQreset</code><a id="id-1.7.3.8.2.11.10.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQRESET" class="id_link">#</a></dt><dd><p>Переустанавливает канал связи с сервером. </p><pre class="synopsis">
void PQreset(PGconn *conn);
</pre><p>Эта функция закроет подключение к серверу, а потом попытается установить новое подключение, используя все те же параметры, которые использовались прежде. Это может быть полезным для восстановления после ошибки, если работающее соединение было разорвано.</p></dd><dt id="LIBPQ-PQRESETSTART"><span class="term"><code class="function">PQresetStart</code><a id="id-1.7.3.8.2.11.11.1.2" class="indexterm"></a><br /></span><span class="term"><code class="function">PQresetPoll</code><a id="id-1.7.3.8.2.11.11.2.2" class="indexterm"></a></span> <a href="#LIBPQ-PQRESETSTART" class="id_link">#</a></dt><dd><p>Переустанавливает канал связи с сервером неблокирующим способом. </p><pre class="synopsis">
int PQresetStart(PGconn *conn);

PostgresPollingStatusType PQresetPoll(PGconn *conn);
</pre><p>Эти функции закроют подключение к серверу, а потом попытаются установить новое подключение, используя все те же параметры, которые использовались прежде. Это может быть полезным для восстановления после ошибки, если работающее соединение оказалось потерянным. Они отличаются от <a class="xref" href="libpq-connect.html#LIBPQ-PQRESET"><code class="function">PQreset</code></a> (см. выше) тем, что действуют неблокирующим способом. На эти функции налагаются те же ограничения, что и на <a class="xref" href="libpq-connect.html#LIBPQ-PQCONNECTSTARTPARAMS"><code class="function">PQconnectStartParams</code></a>, <code class="function">PQconnectStart</code> и <code class="function">PQconnectPoll</code>.</p><p>Чтобы произвести переподключение, вызовите <a class="xref" href="libpq-connect.html#LIBPQ-PQRESETSTART"><code class="function">PQresetStart</code></a>. Если она возвратит 0, значит при переподключении произошла ошибка. Если она возвратит 1, опросите результат операции, используя <code class="function">PQresetPoll</code>, таким же образом, как это делается с помощью <code class="function">PQconnectPoll</code> при обычном установления соединения.</p></dd><dt id="LIBPQ-PQPINGPARAMS"><span class="term"><code class="function">PQpingParams</code><a id="id-1.7.3.8.2.11.12.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQPINGPARAMS" class="id_link">#</a></dt><dd><p><a class="xref" href="libpq-connect.html#LIBPQ-PQPINGPARAMS"><code class="function">PQpingParams</code></a> сообщает состояние сервера. Она принимает параметры подключения, идентичные тем, что получает функция <a class="xref" href="libpq-connect.html#LIBPQ-PQCONNECTDBPARAMS"><code class="function">PQconnectdbParams</code></a>, описанная выше. Нет необходимости предоставлять корректные имя пользователя, пароль или имя базы данных, чтобы получить состояние сервера. Но если будут предоставлены некорректные значения, сервер зафиксирует в журнале неудачную попытку подключения.</p><pre class="synopsis">
PGPing PQpingParams(const char * const *keywords,
                    const char * const *values,
                    int expand_dbname);
</pre><p> Функция возвращает одно из следующих значений: </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQPINGPARAMS-PQPING_OK"><span class="term"><code class="literal">PQPING_OK</code></span> <a href="#LIBPQ-PQPINGPARAMS-PQPING_OK" class="id_link">#</a></dt><dd><p>Сервер работает и, по-видимому, принимает подключения.</p></dd><dt id="LIBPQ-PQPINGPARAMS-PQPING_REJECT"><span class="term"><code class="literal">PQPING_REJECT</code></span> <a href="#LIBPQ-PQPINGPARAMS-PQPING_REJECT" class="id_link">#</a></dt><dd><p>Сервер работает, но находится в состоянии, которое запрещает подключения (запуск, завершение работы или восстановление после аварийного отказа).</p></dd><dt id="LIBPQ-PQPINGPARAMS-PQPING_NO_RESPONSE"><span class="term"><code class="literal">PQPING_NO_RESPONSE</code></span> <a href="#LIBPQ-PQPINGPARAMS-PQPING_NO_RESPONSE" class="id_link">#</a></dt><dd><p>Контакт с сервером не удался. Это может указывать на то, что сервер не запущен или что-то не в порядке с параметрами данного подключения (например, неверный номер порта), или имеет место проблема с возможностью соединения по сети (например, брандмауэр блокирует запрос на подключение).</p></dd><dt id="LIBPQ-PQPINGPARAMS-PQPING_NO_ATTEMPT"><span class="term"><code class="literal">PQPING_NO_ATTEMPT</code></span> <a href="#LIBPQ-PQPINGPARAMS-PQPING_NO_ATTEMPT" class="id_link">#</a></dt><dd><p>Никакой попытки установить контакт с сервером сделано не было, поскольку предоставленные параметры были явно некорректными, или имела место какая-то проблема на стороне клиента (например, нехватка памяти).</p></dd></dl></div></dd><dt id="LIBPQ-PQPING"><span class="term"><code class="function">PQping</code><a id="id-1.7.3.8.2.11.13.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQPING" class="id_link">#</a></dt><dd><p><a class="xref" href="libpq-connect.html#LIBPQ-PQPING"><code class="function">PQping</code></a> сообщает состояние сервера. Она принимает параметры подключения, идентичные тем, что получает функция <a class="xref" href="libpq-connect.html#LIBPQ-PQCONNECTDB"><code class="function">PQconnectdb</code></a>, описанная выше. Нет необходимости предоставлять корректные имя пользователя, пароль или имя базы данных, чтобы получить состояние сервера. Но если будут предоставлены некорректные значения, сервер зафиксирует в журнале неудачную попытку подключения. </p><pre class="synopsis">
PGPing PQping(const char *conninfo);
</pre><p>Возвращаемые значения такие же, как и для <a class="xref" href="libpq-connect.html#LIBPQ-PQPINGPARAMS"><code class="function">PQpingParams</code></a>.</p></dd><dt id="LIBPQ-PQSETSSLKEYPASSHOOK-OPENSSL"><span class="term"><code class="function">PQsetSSLKeyPassHook_OpenSSL</code><a id="id-1.7.3.8.2.11.14.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQSETSSLKEYPASSHOOK-OPENSSL" class="id_link">#</a></dt><dd><p><code class="function">PQsetSSLKeyPassHook_OpenSSL</code> позволяет приложению переопределить реализованный в <code class="literal">libpq</code> <a class="link" href="libpq-ssl.html#LIBPQ-SSL-CLIENTCERT" title="34.19.2. Клиентские сертификаты">стандартный вариант обработки файлов с зашифрованными ключами клиентских сертификатов</a>, используя <a class="xref" href="libpq-connect.html#LIBPQ-CONNECT-SSLPASSWORD">sslpassword</a> или интерактивное приглашение. </p><pre class="synopsis">
void PQsetSSLKeyPassHook_OpenSSL(PQsslKeyPassHook_OpenSSL_type hook);
</pre><p> Приложение передаёт указатель на функцию-обработчик со следующей сигнатурой: </p><pre class="programlisting">int callback_fn(char *buf, int size, PGconn *conn);</pre><p> Эту функцию <code class="literal">libpq</code> будет вызывать <span class="emphasis"><em>вместо</em></span> своего стандартного обработчика <code class="function">PQdefaultSSLKeyPassHook_OpenSSL</code>. Данная функция должна получить пароль для ключа и скопировать его в результирующий буфер <code class="literal">buf</code> размера <code class="literal">size</code>. Строка в <code class="literal">buf</code> должна завершаться нулём. В результате эта функция должна выдать длину пароля, сохранённого в <code class="literal">buf</code>, не считая завершающего нуля. В случае ошибки она должна установить <code class="literal">buf[0] = '\0'</code> и выдать 0. В качестве примера взгляните на реализацию <code class="function">PQdefaultSSLKeyPassHook_OpenSSL</code> в исходном коде <code class="literal">libpq</code>.</p><p>Если пользователь задал размещение ключа явно, заданный путь будет передан при вызове этого обработчика в <code class="literal">conn-&gt;sslkey</code>. Это поле будет пустым, если используется путь к ключу по умолчанию. Что касается ключей, специфичных для модулей <span class="productname">OpenSSL</span>, для них модули могут по своему усмотрению получать пароль через стандартный обработчик <span class="productname">OpenSSL</span> или через свой собственный.</p><p>Пользовательский обработчик может полностью переопределить функцию <code class="function">PQdefaultSSLKeyPassHook_OpenSSL</code>, либо делегировать ей необрабатываемые им случаи, либо сначала вызывать её и предпринимать какие-то другие действия, если она возвратит 0.</p><p>Этот обработчик <span class="emphasis"><em>не должен</em></span> нарушать обычный ход выполнения, выбрасывая исключения, вызывая <code class="function">longjmp(...)</code> и т. п. Он должен завершиться нормально.</p></dd><dt id="LIBPQ-PQGETSSLKEYPASSHOOK-OPENSSL"><span class="term"><code class="function">PQgetSSLKeyPassHook_OpenSSL</code><a id="id-1.7.3.8.2.11.15.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQGETSSLKEYPASSHOOK-OPENSSL" class="id_link">#</a></dt><dd><p><code class="function">PQgetSSLKeyPassHook_OpenSSL</code> возвращает текущий обработчик пароля для ключа клиентского сертификата либо <code class="literal">NULL</code>, если такой обработчик не установлен. </p><pre class="synopsis">
PQsslKeyPassHook_OpenSSL_type PQgetSSLKeyPassHook_OpenSSL(void);
</pre></dd></dl></div><div class="sect2" id="LIBPQ-CONNSTRING"><div class="titlepage"><div><div><h3 class="title">34.1.1. Строки параметров подключения <a href="#LIBPQ-CONNSTRING" class="id_link">#</a></h3></div></div></div><a id="id-1.7.3.8.3.2" class="indexterm"></a><a id="id-1.7.3.8.3.3" class="indexterm"></a><p>Ряд функций <span class="application">libpq</span> разбирают заданную пользователем строку для извлечения параметров подключения. Есть два принятых формата этих строк: простая строка ключ/значение и URI. Строки URI в основном соответствуют <a class="ulink" href="https://datatracker.ietf.org/doc/html/rfc3986" target="_top">RFC 3986</a>, но могут содержать также строки подключения с несколькими узлами, как описано ниже.</p><div class="sect3" id="LIBPQ-CONNSTRING-KEYWORD-VALUE"><div class="titlepage"><div><div><h4 class="title">34.1.1.1. Строки параметров подключения вида «ключ/значение» <a href="#LIBPQ-CONNSTRING-KEYWORD-VALUE" class="id_link">#</a></h4></div></div></div><p>Согласно формату ключ/значение, установка каждого параметра выполняется в форме <em class="replaceable"><code>ключ</code></em> <code class="literal">=</code> <em class="replaceable"><code>значение</code></em>, с пробелами между параметрами. Пробелы вокруг знака равенства не являются обязательными. Для записи пустого значения или значения, содержащего пробелы, заключите его в одинарные кавычки, например, <code class="literal">keyword = 'a value'</code>. Одинарные кавычки и символы обратной косой черты внутри значения нужно обязательно экранировать с помощью символа обратной косой черты, т. е., <code class="literal">\'</code> и <code class="literal">\\</code>.</p><p>Пример: </p><pre class="programlisting">host=localhost port=5432 dbname=mydb connect_timeout=10</pre><p>Ключевые слова-параметры, распознаваемые в настоящее время, приведены в <a class="xref" href="libpq-connect.html#LIBPQ-PARAMKEYWORDS" title="34.1.2. Ключевые слова-параметры">Подразделе 34.1.2</a>.</p></div><div class="sect3" id="LIBPQ-CONNSTRING-URIS"><div class="titlepage"><div><div><h4 class="title">34.1.1.2. URI для подключения <a href="#LIBPQ-CONNSTRING-URIS" class="id_link">#</a></h4></div></div></div><p>Основная форма <acronym class="acronym">URI</acronym> подключения: </p><pre class="synopsis">
postgresql://[<span class="optional"><em class="replaceable"><code>пользователь</code></em>@</span>][<span class="optional"><em class="replaceable"><code>сервер</code></em></span>][<span class="optional">/<em class="replaceable"><code>база_данных</code></em></span>][<span class="optional">?<em class="replaceable"><code>указание_параметра</code></em></span>]

<span class="phrase">где <em class="replaceable"><code>пользователь</code></em>:</span>

<em class="replaceable"><code>имя_пользователя</code></em>[<span class="optional">:<em class="replaceable"><code>пароль</code></em></span>]

<span class="phrase">и <em class="replaceable"><code>сервер</code></em>:</span>

[<span class="optional"><em class="replaceable"><code>узел</code></em></span>][<span class="optional">:<em class="replaceable"><code>порт</code></em></span>][<span class="optional">,...</span>]

<span class="phrase">и <em class="replaceable"><code>указание_параметра</code></em>:</span>

<em class="replaceable"><code>имя</code></em>=<em class="replaceable"><code>значение</code></em>[<span class="optional">&amp;...</span>]
</pre><p>В качестве обозначения схемы <acronym class="acronym">URI</acronym> может использоваться <code class="literal">postgresql://</code> или <code class="literal">postgres://</code>. Остальные части <acronym class="acronym">URI</acronym> являются необязательными. В следующих примерах показан допустимый синтаксис <acronym class="acronym">URI</acronym>: </p><pre class="programlisting">postgresql://
postgresql://localhost
postgresql://localhost:5433
postgresql://localhost/mydb
postgresql://user@localhost
postgresql://user:secret@localhost
postgresql://other@localhost/otherdb?connect_timeout=10&amp;application_name=myapp
postgresql://host1:123,host2:456/somedb?target_session_attrs=any&amp;application_name=myapp</pre><p> Значения, которые обычно задаются в иерархической части <acronym class="acronym">URI</acronym>, также можно задать в именованных параметрах. Например: </p><pre class="programlisting">postgresql:///mydb?host=localhost&amp;port=5433</pre><p> Все именованные параметры должны соответствовать ключевым словам, перечисленным в <a class="xref" href="libpq-connect.html#LIBPQ-PARAMKEYWORDS" title="34.1.2. Ключевые слова-параметры">Подраздел 34.1.2</a>, за исключением того, что вхождения <code class="literal">ssl=true</code> заменяются на <code class="literal">sslmode=require</code> для совместимости с URI-строками JDBC.</p><p>Если <acronym class="acronym">URI</acronym> подключения содержит в какой-либо из частей символы со специальным значением, он должен кодироваться в <a class="ulink" href="https://datatracker.ietf.org/doc/html/rfc3986#section-2.1" target="_top">формате с процентами</a>. Например, так выглядит <acronym class="acronym">URI</acronym>, в котором знак равно (<code class="literal">=</code>) заменён на <code class="literal">%3D</code>, а знак пробела — на <code class="literal">%20</code>: </p><pre class="programlisting">postgresql://user@localhost:5433/mydb?options=-c%20synchronous_commit%3Doff</pre><p>Сервер можно представить либо сетевым именем, либо IP-адресом. При использовании протокола IPv6 нужно заключить адрес в квадратные скобки: </p><pre class="synopsis">postgresql://[2001:db8::1234]/database
</pre><p>Часть <code class="literal">host</code> интерпретируется в соответствии с описанием параметра <a class="xref" href="libpq-connect.html#LIBPQ-CONNECT-HOST">host</a>. Так, если эта часть строки пуста или выглядит как абсолютный путь, выбирается соединение через Unix-сокеты, в противном случае инициируется соединение по TCP/IP. Учтите однако, что символ косой черты в иерархической части URI является зарезервированным. Поэтому, чтобы указать нестандартный каталог Unix-сокета, нужно поступить одним из двух способов: не задавать эту часть в URI и указать сервер в именованном параметре либо закодировать путь в части <code class="literal">host</code> с процентами: </p><pre class="programlisting">postgresql:///dbname?host=/var/lib/postgresql
postgresql://%2Fvar%2Flib%2Fpostgresql/dbname</pre><p>В одном URI можно задать несколько компонентов узлов, каждый с необязательным указанием порта. URI вида <code class="literal">postgresql://host1:port1,host2:port2,host3:port3/</code> равнозначно строке подключения вида <code class="literal">host=host1,host2,host3 port=port1,port2,port3</code>. Как описывается ниже, эти узлы будут перебираться по очереди, пока не будет установлено подключение.</p></div><div class="sect3" id="LIBPQ-MULTIPLE-HOSTS"><div class="titlepage"><div><div><h4 class="title">34.1.1.3. Указание нескольких узлов <a href="#LIBPQ-MULTIPLE-HOSTS" class="id_link">#</a></h4></div></div></div><p>В строке подключения можно задать несколько узлов, к которым клиент будет пытаться подключиться в заданном порядке. Параметры <code class="literal">host</code>, <code class="literal">hostaddr</code> и <code class="literal">port</code> в формате ключ/значение принимают списки значений, разделённых запятыми. В каждом определяемом параметре должно содержаться одинаковое число элементов, чтобы, например, первый элемент <code class="literal">hostaddr</code> соответствовал первому элементу <code class="literal">host</code>, второй — второму <code class="literal">host</code> и так далее. Исключение составляет <code class="literal">port</code> — если этот параметр содержит только один элемент, он применяется ко всем узлам.</p><p>В формате URI внутри компонента <code class="literal">host</code> можно указать несколько пар <code class="literal">host:port</code>, разделённых запятыми.</p><p>В любом формате одно имя узла может переводиться в несколько сетевых адресов. Например, часто бывает, что один узел имеет и адрес IPv4, и адрес IPv6.</p><p>Когда задаются несколько узлов или когда одно имя узла переводится в несколько адресов, все узлы и адреса перебираются по порядку, пока подключение не будет установлено. Если ни один из адресов не будет доступен, произойдёт сбой подключения. Если подключение устанавливается успешно, но происходит ошибка аутентификации, остальные узлы в списке не перебираются.</p><p>Если используется файл паролей, в нём можно задать разные пароли для разных узлов. Все остальные параметры подключения будут одинаковыми для всех узлов; например, нельзя задать для разных узлов различные имена пользователей.</p></div></div><div class="sect2" id="LIBPQ-PARAMKEYWORDS"><div class="titlepage"><div><div><h3 class="title">34.1.2. Ключевые слова-параметры <a href="#LIBPQ-PARAMKEYWORDS" class="id_link">#</a></h3></div></div></div><p>Ключевые слова-параметры, распознаваемые в настоящее время, следующие: </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-CONNECT-HOST"><span class="term"><code class="literal">host</code></span> <a href="#LIBPQ-CONNECT-HOST" class="id_link">#</a></dt><dd><p>Имя узла для подключения.<a id="id-1.7.3.8.4.2.1.1.2.1.1" class="indexterm"></a> Если это имя выглядит как указание абсолютного пути, выбирается подключение через Unix-сокет, а не через TCP/IP, и данное значение определяет имя каталога, содержащего файл сокета. (В Unix-системах абсолютный путь начинается с косой черты, а в Windows абсолютные пути также могут начинаться с буквы диска.) Если имя узла начинается с <code class="literal">@</code>, оно воспринимается как Unix-сокет в абстрактном пространстве имён (в настоящее время поддерживается в Linux и Windows). По умолчанию, если параметр <code class="literal">host</code> отсутствует или пуст, выполняется подключение к Unix-сокету <a id="id-1.7.3.8.4.2.1.1.2.1.4" class="indexterm"></a> в <code class="filename">/tmp</code> (или в том каталоге сокетов, который был задан при сборке <span class="productname">PostgreSQL</span>). В Windows по умолчанию выполняется подключение к <code class="literal">localhost</code>.</p><p>Также принимается разделённый запятыми список имён узлов; при этом данные имена будут перебираться по порядку. Для пустых элементов списка применяется поведение по умолчанию, описанное выше. За подробностями обратитесь к <a class="xref" href="libpq-connect.html#LIBPQ-MULTIPLE-HOSTS" title="34.1.1.3. Указание нескольких узлов">Подразделу 34.1.1.3</a>.</p></dd><dt id="LIBPQ-CONNECT-HOSTADDR"><span class="term"><code class="literal">hostaddr</code></span> <a href="#LIBPQ-CONNECT-HOSTADDR" class="id_link">#</a></dt><dd><p>Числовой IP-адрес узла для подключения. Он должен быть представлен в стандартном формате адресов IPv4, например, <code class="literal">172.28.40.9</code>. Если ваша машина поддерживает IPv6, вы можете использовать и адреса IPv6. Если в этом параметре передана непустая строка, для подключения всегда используется TCP/IP. В отсутствие этого параметра целевой IP-адрес будет получен из имени, заданного в параметре <code class="literal">host</code>, либо если в <code class="literal">host</code> задан IP-адрес, будет использоваться непосредственно он.</p><p>Использование <code class="literal">hostaddr</code> позволяет приложению обойтись без разрешения имён, что может быть важно для приложений с жёсткими временными ограничениями. Однако имя узла требуется для методов аутентификации GSSAPI или SSPI, а также для проверки полномочий на основе SSL-сертификатов в режиме <code class="literal">verify-full</code>. Применяются следующие правила: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Если адрес <code class="literal">host</code> задаётся без <code class="literal">hostaddr</code>, осуществляется разрешение имени. (При использовании <code class="function">PQconnectPoll</code> разрешение производится, когда <code class="function">PQconnectPoll</code> рассматривает это имя в первый раз, и может заблокировать <code class="function">PQconnectPoll</code> на неопределённое время.)</p></li><li class="listitem"><p>Если указан <code class="literal">hostaddr</code>, а <code class="literal">host</code> не указан, тогда значение <code class="literal">hostaddr</code> даёт сетевой адрес сервера. Попытка подключения завершится неудачей, если метод аутентификации требует наличия имени узла.</p></li><li class="listitem"><p>Если указаны как <code class="literal">host</code>, так и <code class="literal">hostaddr</code>, тогда значение <code class="literal">hostaddr</code> даёт сетевой адрес сервера, а значение <code class="literal">host</code> игнорируется, если только метод аутентификации его не потребует. В таком случае оно будет использоваться в качестве имени узла.</p></li></ul></div><p> Заметьте, что аутентификация может завершиться неудачей, если <code class="literal">host</code> не является именем сервера с сетевым адресом <code class="literal">hostaddr</code>. Также заметьте, что когда указывается и <code class="literal">host</code>, и <code class="literal">hostaddr</code>, соединение в файле паролей идентифицируется по значению <code class="literal">host</code> (см. <a class="xref" href="libpq-pgpass.html" title="34.16. Файл паролей">Раздел 34.16</a>).</p><p>Также принимается разделённый запятыми список значений <code class="literal">hostaddr</code>, при этом данные узлы будут перебираться по порядку. Вместо пустого элемента в этом списке будет подставлено имя соответствующего узла или, если и оно не определено, имя узла по умолчанию. За подробностями обратитесь к <a class="xref" href="libpq-connect.html#LIBPQ-MULTIPLE-HOSTS" title="34.1.1.3. Указание нескольких узлов">Подразделу 34.1.1.3</a>.</p><p>Если не указаны ни имя узла, ни его адрес, <span class="application">libpq</span> будет производить подключение, используя локальный Unix-сокет; в Windows она будет пытаться подключиться к <code class="literal">localhost</code>.</p></dd><dt id="LIBPQ-CONNECT-PORT"><span class="term"><code class="literal">port</code></span> <a href="#LIBPQ-CONNECT-PORT" class="id_link">#</a></dt><dd><p>Номер порта, к которому нужно подключаться на сервере, либо расширение имени файла сокета для соединений через Unix-сокеты.<a id="id-1.7.3.8.4.2.1.3.2.1.1" class="indexterm"></a> Если в параметрах <code class="literal">host</code> или <code class="literal">hostaddr</code> задано несколько серверов, в данном параметре может задаваться через запятую список портов такой же длины, либо может указываться один номер порта для всех узлов. Пустая строка или пустой элемент в списке через запятую воспринимается как номер порта по умолчанию, установленный при сборке <span class="productname">PostgreSQL</span>.</p></dd><dt id="LIBPQ-CONNECT-DBNAME"><span class="term"><code class="literal">dbname</code></span> <a href="#LIBPQ-CONNECT-DBNAME" class="id_link">#</a></dt><dd><p>Имя базы данных. По умолчанию оно совпадает с именем пользователя. В определённых контекстах это значение проверяется на соответствие расширенным форматам; см. <a class="xref" href="libpq-connect.html#LIBPQ-CONNSTRING" title="34.1.1. Строки параметров подключения">Подраздел 34.1.1</a> для получения подробной информации.</p></dd><dt id="LIBPQ-CONNECT-USER"><span class="term"><code class="literal">user</code></span> <a href="#LIBPQ-CONNECT-USER" class="id_link">#</a></dt><dd><p>Имя пользователя <span class="productname">PostgreSQL</span>, используемое для подключения. По умолчанию используется то же имя, которое имеет в операционной системе пользователь, от лица которого выполняется приложение.</p></dd><dt id="LIBPQ-CONNECT-PASSWORD"><span class="term"><code class="literal">password</code></span> <a href="#LIBPQ-CONNECT-PASSWORD" class="id_link">#</a></dt><dd><p>Пароль, используемый в случае, когда сервер требует аутентификации по паролю.</p></dd><dt id="LIBPQ-CONNECT-PASSFILE"><span class="term"><code class="literal">passfile</code></span> <a href="#LIBPQ-CONNECT-PASSFILE" class="id_link">#</a></dt><dd><p>Задаёт имя файла, в котором будут храниться пароли (см. <a class="xref" href="libpq-pgpass.html" title="34.16. Файл паролей">Раздел 34.16</a>). По умолчанию это <code class="filename">~/.pgpass</code> или <code class="filename">%APPDATA%\postgresql\pgpass.conf</code> в Microsoft Windows. (Отсутствие этого файла не считается ошибкой.)</p></dd><dt id="LIBPQ-CONNECT-REQUIRE-AUTH"><span class="term"><code class="literal">require_auth</code></span> <a href="#LIBPQ-CONNECT-REQUIRE-AUTH" class="id_link">#</a></dt><dd><p>Указывает метод аутентификации, который клиент требует от сервера. Если сервер не использует требуемый метод для аутентификации клиента или если обмен сообщениями аутентификации со стороны сервера не завершён, соединение не будет установлено. Также в качестве значения можно указать список методов, разделённых запятыми, из которых сервер должен использовать только один, чтобы соединение было успешным. По умолчанию принимается любой метод аутентификации, и сервер даже может вообще не выполнять её.</p><p>Методы можно указать с оператором отрицания <code class="literal">!</code>, и в этом случае сервер <span class="emphasis"><em>не</em></span> должен пытаться использовать указанный метод; допускается любой другой метод, и сервер может вообще не аутентифицировать клиента. Если указан список методов, разделённых запятыми, сервер не может использовать <span class="emphasis"><em>любой</em></span> из перечисленных методов с оператором отрицания. Формы с отрицанием и без не могут указываться вместе.</p><p>Последняя особенность метода <code class="literal">none</code> требует, чтобы сервер не использовал аутентификацию. (Его также можно указать с оператором отрицания, чтобы потребовать некоторую форму аутентификации.)</p><p>Могут быть указаны следующие методы: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">password</code></span></dt><dd><p>Сервер должен запрашивать аутентификацию по паролю, заданному открытым текстом.</p></dd><dt><span class="term"><code class="literal">md5</code></span></dt><dd><p>Сервер должен запрашивать аутентификацию по паролю, защищённому MD5.</p></dd><dt><span class="term"><code class="literal">gss</code></span></dt><dd><p>Сервер должен либо запросить подтверждение связи Kerberos через <acronym class="acronym">GSSAPI</acronym>, либо установить канал с <acronym class="acronym">GSS</acronym> шифрованием (см. также <a class="xref" href="libpq-connect.html#LIBPQ-CONNECT-GSSENCMODE">gssencmode</a>).</p></dd><dt><span class="term"><code class="literal">sspi</code></span></dt><dd><p>Сервер должен запрашивать аутентификацию Windows <acronym class="acronym">SSPI</acronym>.</p></dd><dt><span class="term"><code class="literal">scram-sha-256</code></span></dt><dd><p>Сервер должен успешно завершить обмен сообщениями по схеме аутентификации SCRAM-SHA-256 с клиентом.</p></dd><dt><span class="term"><code class="literal">none</code></span></dt><dd><p>Сервер не должен запрашивать у клиента обмен по схеме аутентификации. (Это не запрещает аутентификацию сертификата клиента через TLS или аутентификацию GSS с шифрованием данных на транспортном уровне.)</p></dd></dl></div></dd><dt id="LIBPQ-CONNECT-CHANNEL-BINDING"><span class="term"><code class="literal">channel_binding</code></span> <a href="#LIBPQ-CONNECT-CHANNEL-BINDING" class="id_link">#</a></dt><dd><p>Этот параметр определяет режим использования связывания каналов клиентом. Вариант <code class="literal">require</code> означает, что для соединения должно задействоваться связывание каналов, <code class="literal">prefer</code> — клиент будет выбирать связывание, если оно поддерживается, а <code class="literal">disable</code> предотвращает использование этого механизма. По умолчанию подразумевается вариант <code class="literal">prefer</code>, если <span class="productname">PostgreSQL</span> собирается с поддержкой SSL; в противном случае — <code class="literal">disable</code>.</p><p>Механизм связывания каналов позволяет серверу подтвердить свою подлинность клиенту. Он работает только для подключений поверх SSL с серверами <span class="productname">PostgreSQL</span> версии 11 и новее, когда используется метод аутентификации <code class="literal">SCRAM</code>.</p></dd><dt id="LIBPQ-CONNECT-CONNECT-TIMEOUT"><span class="term"><code class="literal">connect_timeout</code></span> <a href="#LIBPQ-CONNECT-CONNECT-TIMEOUT" class="id_link">#</a></dt><dd><p>Максимальное время ожидания подключения (задаётся десятичным целым числом, например: <code class="literal">10</code>). При нуле, отрицательном или неопределённом значении ожидание будет бесконечным. Минимальный допустимый тайм-аут равен 2 секундам; таким образом, значение <code class="literal">1</code> воспринимается как <code class="literal">2</code>. Этот тайм-аут применяется для каждого отдельного IP-адреса или имени сервера. Например, если вы зададите адреса двух серверов и значение <code class="literal">connect_timeout</code> будет равно 5, тайм-аут при неудачной попытке подключения к каждому серверу произойдёт через 5 секунд, а общее время ожидания подключения может достигать 10 секунд.</p></dd><dt id="LIBPQ-CONNECT-CLIENT-ENCODING"><span class="term"><code class="literal">client_encoding</code></span> <a href="#LIBPQ-CONNECT-CLIENT-ENCODING" class="id_link">#</a></dt><dd><p>Этим устанавливается конфигурационный параметр <code class="varname">client_encoding</code> для данного подключения. В дополнение к значениям, которые принимает соответствующий параметр сервера, вы можете использовать значение <code class="literal">auto</code>. В этом случае правильная кодировка определяется на основе текущей локали на стороне клиента (в системах Unix это переменная системного окружения <code class="envar">LC_CTYPE</code>).</p></dd><dt id="LIBPQ-CONNECT-OPTIONS"><span class="term"><code class="literal">options</code></span> <a href="#LIBPQ-CONNECT-OPTIONS" class="id_link">#</a></dt><dd><p>Задаёт параметры командной строки, которые будут отправлены серверу при установлении соединения. Например, значение <code class="literal">-c geqo=off</code> установит для параметра сеанса <code class="varname">geqo</code> значение <code class="literal">off</code>. Пробелы в этой строке считаются разделяющими аргументы командной строки, если только перед ними не стоит обратная косая черта (<code class="literal">\</code>); чтобы записать собственно обратную косую черту, её нужно продублировать (<code class="literal">\\</code>). Подробное описание возможных параметров можно найти в <a class="xref" href="runtime-config.html" title="Глава 20. Настройка сервера">Главе 20</a>.</p></dd><dt id="LIBPQ-CONNECT-APPLICATION-NAME"><span class="term"><code class="literal">application_name</code></span> <a href="#LIBPQ-CONNECT-APPLICATION-NAME" class="id_link">#</a></dt><dd><p>Устанавливает значение для конфигурационного параметра <a class="xref" href="runtime-config-logging.html#GUC-APPLICATION-NAME">application_name</a>.</p></dd><dt id="LIBPQ-CONNECT-FALLBACK-APPLICATION-NAME"><span class="term"><code class="literal">fallback_application_name</code></span> <a href="#LIBPQ-CONNECT-FALLBACK-APPLICATION-NAME" class="id_link">#</a></dt><dd><p>Устанавливает альтернативное значение для конфигурационного параметра <a class="xref" href="runtime-config-logging.html#GUC-APPLICATION-NAME">application_name</a>. Это значение будет использоваться, если для параметра <code class="literal">application_name</code> не было передано никакого значения с помощью параметров подключения или переменной системного окружения <code class="envar">PGAPPNAME</code>. Задание альтернативного имени полезно для универсальных программ-утилит, которые желают установить имя приложения по умолчанию, но позволяют пользователю изменить его.</p></dd><dt id="LIBPQ-KEEPALIVES"><span class="term"><code class="literal">keepalives</code></span> <a href="#LIBPQ-KEEPALIVES" class="id_link">#</a></dt><dd><p>Управляет использованием сообщений keepalive протокола TCP на стороне клиента. Значение по умолчанию равно 1, что означает использование сообщений. Вы можете изменить его на 0, если эти сообщения не нужны. Для соединений, установленных через Unix-сокеты, этот параметр игнорируется.</p></dd><dt id="LIBPQ-KEEPALIVES-IDLE"><span class="term"><code class="literal">keepalives_idle</code></span> <a href="#LIBPQ-KEEPALIVES-IDLE" class="id_link">#</a></dt><dd><p>Управляет длительностью периода отсутствия активности, выраженного числом секунд, по истечении которого TCP должен отправить сообщение keepalive серверу. При значении 0 действует системная величина. Этот параметр игнорируется для соединений, установленных через Unix-сокеты, или если сообщения keepalive отключены. Он поддерживается только в системах, воспринимающих параметр сокета <code class="symbol">TCP_KEEPIDLE</code> или равнозначный, и в Windows; в других системах он не оказывает влияния.</p></dd><dt id="LIBPQ-KEEPALIVES-INTERVAL"><span class="term"><code class="literal">keepalives_interval</code></span> <a href="#LIBPQ-KEEPALIVES-INTERVAL" class="id_link">#</a></dt><dd><p>Задаёт количество секунд, по прошествии которых сообщение keepalive протокола TCP, получение которого не подтверждено сервером, должно быть отправлено повторно. При значении 0 действует системная величина. Этот параметр игнорируется для соединений, установленных через Unix-сокеты, или если сообщения keepalive отключены. Он поддерживается только в системах, воспринимающих параметр сокета <code class="symbol">TCP_KEEPINTVL</code> или равнозначный, и в Windows; в других системах он не оказывает влияния.</p></dd><dt id="LIBPQ-KEEPALIVES-COUNT"><span class="term"><code class="literal">keepalives_count</code></span> <a href="#LIBPQ-KEEPALIVES-COUNT" class="id_link">#</a></dt><dd><p>Задаёт количество сообщений keepalive протокола TCP, которые могут быть потеряны, прежде чем соединение клиента с сервером будет признано неработающим. Нулевое значение этого параметра указывает, что будет использоваться системное значение по умолчанию. Этот параметр игнорируется для соединений, установленных через Unix-сокеты, или если сообщения keepalive отключены. Он поддерживается только в системах, воспринимающих параметр сокета <code class="symbol">TCP_KEEPCNT</code> или равнозначный; в других системах он не оказывает влияния.</p></dd><dt id="LIBPQ-TCP-USER-TIMEOUT"><span class="term"><code class="literal">tcp_user_timeout</code></span> <a href="#LIBPQ-TCP-USER-TIMEOUT" class="id_link">#</a></dt><dd><p>Управляет длительностью интервала (в миллисекундах), в течение которого данные могут оставаться неподтверждёнными, прежде чем соединение будет принудительно закрыто. При значении 0 действует системная величина. Этот параметр игнорируется для соединений, установленных через Unix-сокеты. Он поддерживается только в системах, воспринимающих параметр сокета <code class="symbol">TCP_USER_TIMEOUT</code>; в других системах он не оказывает влияния.</p></dd><dt id="LIBPQ-CONNECT-REPLICATION"><span class="term"><code class="literal">replication</code></span> <a href="#LIBPQ-CONNECT-REPLICATION" class="id_link">#</a></dt><dd><p>Этот параметр определяет, должно ли подключение использовать протокол репликации вместо обычного протокола. Этот вариант используют внутри механизмы репликации PostgreSQL и такие средства, как <span class="application">pg_basebackup</span>, но он может также применяться и сторонними приложениями. За подробным описанием протокола репликации обратитесь к <a class="xref" href="protocol-replication.html" title="55.4. Протокол потоковой репликации">Разделу 55.4</a>.</p><p>Поддерживаются следующие значения этого параметра, без учёта регистра: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">true</code>, <code class="literal">on</code>, <code class="literal">yes</code>, <code class="literal">1</code></span></dt><dd><p>Подключение осуществляется в режиме физической репликации.</p></dd><dt><span class="term"><code class="literal">database</code></span></dt><dd><p>Подключение осуществляется в режиме логической репликации, целевая база данных задаётся параметром <code class="literal">dbname</code>.</p></dd><dt><span class="term"><code class="literal">false</code>, <code class="literal">off</code>, <code class="literal">no</code>, <code class="literal">0</code></span></dt><dd><p>Подключение выполняется в обычном режиме; это поведение по умолчанию.</p></dd></dl></div><p>В режиме физической или логической репликации может использоваться только простой протокол запросов.</p></dd><dt id="LIBPQ-CONNECT-GSSENCMODE"><span class="term"><code class="literal">gssencmode</code></span> <a href="#LIBPQ-CONNECT-GSSENCMODE" class="id_link">#</a></dt><dd><p>Этот параметр определяет, будет ли согласовываться с сервером защищённое <acronym class="acronym">GSS</acronym> соединение по протоколу TCP/IP, и если да, то в какой очередности. Всего предусмотрено три режима: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">disable</code></span></dt><dd><p>пытаться установить только соединение без шифрования <acronym class="acronym">GSSAPI</acronym></p></dd><dt><span class="term"><code class="literal">prefer</code> (по умолчанию)</span></dt><dd><p>если уже имеются учётные данные <acronym class="acronym">GSSAPI</acronym> (в кеше учётных данных), сначала попытаться установить соединение с шифрованием <acronym class="acronym">GSSAPI</acronym>; если эта попытка не удастся или подходящих данных нет, попробовать соединение без шифрования <acronym class="acronym">GSSAPI</acronym>. Это значение по умолчанию, если <span class="productname">PostgreSQL</span> был скомпилирован с поддержкой <acronym class="acronym">GSSAPI</acronym>.</p></dd><dt><span class="term"><code class="literal">require</code></span></dt><dd><p>пытаться установить только соединение с шифрованием <acronym class="acronym">GSSAPI</acronym></p></dd></dl></div><p><code class="literal">sslmode</code> игнорируется при использовании Unix-сокетов. Если <span class="productname">PostgreSQL</span> скомпилирован без поддержки GSSAPI, использование варианта <code class="literal">require</code> приведёт к ошибке, в то время как параметр <code class="literal">prefer</code> будет принят, но <span class="application">libpq</span> в действительности не будет пытаться установить зашифрованное <acronym class="acronym">GSSAPI</acronym> соединение.<a id="id-1.7.3.8.4.2.1.21.2.2.7" class="indexterm"></a></p></dd><dt id="LIBPQ-CONNECT-SSLMODE"><span class="term"><code class="literal">sslmode</code></span> <a href="#LIBPQ-CONNECT-SSLMODE" class="id_link">#</a></dt><dd><p>Этот параметр определяет, будет ли согласовываться с сервером защищённое <acronym class="acronym">SSL</acronym>-соединение по протоколу TCP/IP, и если да, то в какой очередности. Всего предусмотрено шесть режимов: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">disable</code></span></dt><dd><p>следует пытаться установить только соединение без использования <acronym class="acronym">SSL</acronym></p></dd><dt><span class="term"><code class="literal">allow</code></span></dt><dd><p>сначала следует попытаться установить соединение без использования <acronym class="acronym">SSL</acronym>; если попытка будет неудачной, нужно попытаться установить <acronym class="acronym">SSL</acronym>-соединение</p></dd><dt><span class="term"><code class="literal">prefer</code> (по умолчанию)</span></dt><dd><p>сначала следует попытаться установить <acronym class="acronym">SSL</acronym>-соединение; если попытка будет неудачной, нужно попытаться установить соединение без использования <acronym class="acronym">SSL</acronym></p></dd><dt><span class="term"><code class="literal">require</code></span></dt><dd><p>следует попытаться установить только <acronym class="acronym">SSL</acronym>-соединение. Если присутствует файл корневого центра сертификации, то нужно верифицировать сертификат таким же способом, как будто был указан параметр <code class="literal">verify-ca</code></p></dd><dt><span class="term"><code class="literal">verify-ca</code></span></dt><dd><p>следует попытаться установить только <acronym class="acronym">SSL</acronym>-соединение, при этом проконтролировать, чтобы сертификат сервера был выпущен доверенным центром сертификации (<acronym class="acronym">CA</acronym>)</p></dd><dt><span class="term"><code class="literal">verify-full</code></span></dt><dd><p>следует попытаться установить только <acronym class="acronym">SSL</acronym>-соединение, при этом проконтролировать, чтобы сертификат сервера был выпущен доверенным центром сертификации (<acronym class="acronym">CA</acronym>) и чтобы имя запрошенного сервера соответствовало имени в сертификате</p></dd></dl></div><p> В <a class="xref" href="libpq-ssl.html" title="34.19. Поддержка SSL">Разделе 34.19</a> приведено подробное описание работы этих режимов.</p><p><code class="literal">sslmode</code> игнорируется при использовании Unix-сокетов. Если <span class="productname">PostgreSQL</span> скомпилирован без поддержки SSL, использование параметров <code class="literal">require</code>, <code class="literal">verify-ca</code> или <code class="literal">verify-full</code> приведёт к ошибке, в то время как параметры <code class="literal">allow</code> и <code class="literal">prefer</code> будут приняты, но <span class="application">libpq</span> в действительности не будет пытаться установить <acronym class="acronym">SSL</acronym>-соединение.<a id="id-1.7.3.8.4.2.1.22.2.2.10" class="indexterm"></a></p><p>Заметьте, что при возможности использовать шифрование <acronym class="acronym">GSSAPI</acronym>, оно будет предпочитаться шифрованию <acronym class="acronym">SSL</acronym> вне зависимости от значения <code class="literal">sslmode</code>. Чтобы принудительно использовать <acronym class="acronym">SSL</acronym> в окружении, где имеется рабочая инфраструктура <acronym class="acronym">GSSAPI</acronym> (например, сервер Kerberos), дополнительно установите для <code class="literal">gssencmode</code> значение <code class="literal">disable</code>.</p></dd><dt id="LIBPQ-CONNECT-REQUIRESSL"><span class="term"><code class="literal">requiressl</code></span> <a href="#LIBPQ-CONNECT-REQUIRESSL" class="id_link">#</a></dt><dd><p>Использовать этот параметр не рекомендуется, в качестве замены предлагается установить <code class="literal">sslmode</code>.</p><p>Если установлено значение 1, то требуется <acronym class="acronym">SSL</acronym>-соединение с сервером (это эквивалентно <code class="literal">sslmode</code> <code class="literal">require</code>). <span class="application">libpq</span> в таком случае откажется подключаться, если сервер не принимает <acronym class="acronym">SSL</acronym>-соединений. Если установлено значение 0 (по умолчанию), тогда <span class="application">libpq</span> будет согласовывать тип подключения с сервером (эквивалентно <code class="literal">sslmode</code> <code class="literal">prefer</code>). Этот параметр доступен, если только <span class="productname">PostgreSQL</span> скомпилирован с поддержкой SSL.</p></dd><dt id="LIBPQ-CONNECT-SSLCOMPRESSION"><span class="term"><code class="literal">sslcompression</code></span> <a href="#LIBPQ-CONNECT-SSLCOMPRESSION" class="id_link">#</a></dt><dd><p>Если установлено значение 1, данные, передаваемые через SSL-соединения, будут сжиматься. Если установлено значение 0 (по умолчанию), сжатие будет отключено. Этот параметр игнорируется, если установлено подключение без SSL.</p><p>Сжатие SSL в настоящее время считается небезопасным, и использовать его уже не рекомендуется. В <span class="productname">OpenSSL</span> 1.1.0 сжатие отключено по умолчанию, к тому же во многих дистрибутивах оно отключается и с более ранними версиями. А если сервер не поддерживает сжатие, включение этого параметра не окажет никакого влияния. В <span class="productname">PostgreSQL</span> 14 сжатие полностью отключено на сервере.</p><p>Если вопросы безопасности не стоят на первом месте, сжатие может ускорить передачу данных, когда узким местом является сеть. Отключение сжатия может улучшить время отклика и пропускную способность, если ограничивающим фактором является производительность CPU.</p></dd><dt id="LIBPQ-CONNECT-SSLCERT"><span class="term"><code class="literal">sslcert</code></span> <a href="#LIBPQ-CONNECT-SSLCERT" class="id_link">#</a></dt><dd><p>Этот параметр предписывает имя файла для SSL-сертификата клиента, заменяющего файл по умолчанию <code class="filename"> ~/.postgresql/postgresql.crt</code>. Этот параметр игнорируется, если SSL-подключение не выполнено.</p></dd><dt id="LIBPQ-CONNECT-SSLKEY"><span class="term"><code class="literal">sslkey</code></span> <a href="#LIBPQ-CONNECT-SSLKEY" class="id_link">#</a></dt><dd><p>Этот параметр предписывает местоположение секретного ключа, используемого для сертификата клиента. Он может либо указывать имя файла, которое будет использоваться вместо имени по умолчанию <code class="filename"> ~/.postgresql/postgresql.key</code>, либо он может указывать ключ, полученный от внешнего <span class="quote">«<span class="quote">криптомодуля</span>»</span> (криптомодули — это загружаемые модули <span class="productname">OpenSSL</span>). Спецификация внешнего криптомодуля должна состоять из имени модуля и ключевого идентификатора, зависящего от конкретного модуля, разделённых двоеточием. Этот параметр игнорируется, если SSL-подключение не выполнено.</p></dd><dt id="LIBPQ-CONNECT-SSLPASSWORD"><span class="term"><code class="literal">sslpassword</code></span> <a href="#LIBPQ-CONNECT-SSLPASSWORD" class="id_link">#</a></dt><dd><p>Этот параметр задаёт пароль для секретного ключа, указанного в <code class="literal">sslkey</code>, что позволяет хранить на диске закрытые ключи клиентских сертификатов в зашифрованном виде, даже когда применять интерактивный ввод пароля непрактично.</p><p>Когда для этого параметра задаётся непустое значение, приглашение <span class="productname">OpenSSL</span> <code class="literal">Enter PEM pass phrase:</code> (Введите пароль для PEM:) не выводится. По умолчанию это приглашение выдаётся, если в <code class="literal">libpq</code> передаётся зашифрованный ключ клиентского сертификата.</p><p>Если ключ не зашифрован, этот параметр игнорируется. Данный параметр не действует для ключей, которыми оперируют дополнительные модули <span class="productname">OpenSSL</span>, если только модуль не пользуется представленной в <span class="productname">OpenSSL</span> функцией-обработчиком запроса пароля.</p><p>Для этого параметра нет соответствующей переменной окружения, а также не реализована возможность задать его в <code class="filename">.pgpass</code>. Однако его можно задать в определении свойств подключения в файле служб. Пользователям, которых не устраивает такой простой способ задания пароля, следует использовать специальные модули и средства <span class="productname">OpenSSL</span>, например PKCS#11 или криптографические USB-устройства.</p></dd><dt id="LIBPQ-CONNECT-SSLCERTMODE"><span class="term"><code class="literal">sslcertmode</code></span> <a href="#LIBPQ-CONNECT-SSLCERTMODE" class="id_link">#</a></dt><dd><p>Этот параметр определяет, может ли сертификат клиента быть отправлен серверу и должен ли сервер запрашивать его. Всего предусмотрено три режима: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">disable</code></span></dt><dd><p>Сертификат клиента не отправляется, даже если он доступен (расположен по умолчанию или указан в <a class="xref" href="libpq-connect.html#LIBPQ-CONNECT-SSLCERT">sslcert</a>).</p></dd><dt><span class="term"><code class="literal">allow</code> (по умолчанию)</span></dt><dd><p>Сертификат может быть отправлен, если сервер запрашивает его и клиент может его отправить.</p></dd><dt><span class="term"><code class="literal">require</code></span></dt><dd><p>Сервер <span class="emphasis"><em>должен</em></span> запрашивать сертификат. Установить подключение не удастся, если клиент не отправляет сертификат, а сервер всё равно успешно аутентифицирует клиента.</p></dd></dl></div><div class="note"><h3 class="title">Примечание</h3><p>Установка <code class="literal">sslcertmode=require</code> не повышает безопасность, поскольку нет гарантии, что сервер правильно проверяет сертификат. Серверы PostgreSQL обычно запрашивают сертификаты TLS от клиентов независимо от того, проверяют они их или нет. Этот параметр может быть полезен при устранении неполадок в более сложных схемах TLS.</p></div></dd><dt id="LIBPQ-CONNECT-SSLROOTCERT"><span class="term"><code class="literal">sslrootcert</code></span> <a href="#LIBPQ-CONNECT-SSLROOTCERT" class="id_link">#</a></dt><dd><p>Этот параметр указывает имя файла, содержащего SSL-сертификаты, выданные Центром сертификации (<acronym class="acronym">CA</acronym>). Если файл существует, сертификат сервера будет проверен на предмет его подписания одним из этих центров. Имя по умолчанию — <code class="filename"> ~/.postgresql/root.crt</code>.</p><p>Вместо этого можно указать специальное значение <code class="literal">system</code>, и в этом случае будут загружены доверенные сертификаты корневых ЦС. Точное расположение этих корневых сертификатов зависит от реализации SSL и платформы. В частности, для <span class="productname">OpenSSL</span> расположение можно уточнить в переменных окружения <code class="envar">SSL_CERT_DIR</code> и <code class="envar">SSL_CERT_FILE</code>.</p><div class="note"><h3 class="title">Примечание</h3><p>При использовании <code class="literal">sslrootcert=system</code> значение <code class="literal">sslmode</code>, заданное по умолчанию, меняется на <code class="literal">verify-full</code>, и любое значение с менее строгой проверкой приведёт к ошибке. В большинстве случаев нетрудно получить доверенный для системы сертификат по имени управляемого узла, что делает <code class="literal">verify-ca</code> и все более слабые режимы бесполезными.</p><p>Если указать файл сертификата с именем <code class="literal">system</code>, оно будет распознаваться как особое значение <code class="literal">system</code>, поэтому при наличии файла с таким именем следует задать альтернативный путь, например <code class="literal">sslrootcert=./system</code>.</p></div></dd><dt id="LIBPQ-CONNECT-SSLCRL"><span class="term"><code class="literal">sslcrl</code></span> <a href="#LIBPQ-CONNECT-SSLCRL" class="id_link">#</a></dt><dd><p>Этот параметр указывает имя файла, содержащего список отозванных серверных сертификатов (CRL) для SSL. Сертификаты, перечисленные в этом файле, если он существует, будут отвергаться при попытке установить подлинность сертификата сервера. Если ни <a class="xref" href="libpq-connect.html#LIBPQ-CONNECT-SSLCRL">sslcrl</a>, ни <a class="xref" href="libpq-connect.html#LIBPQ-CONNECT-SSLCRLDIR">sslcrldir</a> не заданы, используется файл <code class="filename">~/.postgresql/root.crl</code>.</p></dd><dt id="LIBPQ-CONNECT-SSLCRLDIR"><span class="term"><code class="literal">sslcrldir</code></span> <a href="#LIBPQ-CONNECT-SSLCRLDIR" class="id_link">#</a></dt><dd><p>Этот параметр указывает имя каталога, содержащего список отозванных серверных сертификатов (CRL) для SSL. Сертификаты, перечисленные в файлах данного каталога, если он существует, будут считаться неприемлемыми при проверке подлинности сертификата сервера.</p><p>Каталог необходимо подготовить с помощью команды <span class="productname">OpenSSL</span> <code class="literal">openssl rehash</code> или <code class="literal">c_rehash</code>. За подробностями обратитесь к документации <span class="productname">OpenSSL</span>.</p><p>Параметры <code class="literal">sslcrl</code> и <code class="literal">sslcrldir</code> можно указывать вместе.</p></dd><dt id="LIBPQ-CONNECT-SSLSNI"><span class="term"><code class="literal">sslsni</code><a id="id-1.7.3.8.4.2.1.32.1.2" class="indexterm"></a></span> <a href="#LIBPQ-CONNECT-SSLSNI" class="id_link">#</a></dt><dd><p>Со значением, равным 1 (по умолчанию), libpq включает расширение TLS <span class="quote">«<span class="quote">Server Name Indication</span>»</span> (<acronym class="acronym">SNI</acronym>) для подключений с поддержкой SSL. При значении, равном 0, данное расширение отключается.</p><p>Указание имени сервера (SNI) может использоваться прокси-серверами с поддержкой SSL для маршрутизации соединений без расшифровывания потока SSL. (Обратите внимание, что для этого требуется прокси-сервер, распознающий пакеты инициализации протокола PostgreSQL, а не любой SSL прокси-сервер.) Однако при включении <acronym class="acronym">SNI</acronym> имя целевого сервера передаётся по сети в открытом виде, что в некоторых случаях может быть нежелательно.</p></dd><dt id="LIBPQ-CONNECT-REQUIREPEER"><span class="term"><code class="literal">requirepeer</code></span> <a href="#LIBPQ-CONNECT-REQUIREPEER" class="id_link">#</a></dt><dd><p>Этот параметр указывает имя пользователя операционной системы, предназначенное для сервера, например, <code class="literal">requirepeer=postgres</code>. При создании подключения через Unix-сокет, если этот параметр установлен, клиент проверяет в самом начале процедуры подключения, что серверный процесс запущен от имени указанного пользователя; если это не так, соединение аварийно прерывается с ошибкой. Этот параметр можно использовать, чтобы обеспечить аутентификацию сервера, подобную той, которая доступна с помощью SSL-сертификатов при соединениях по протоколу TCP/IP. (Заметьте, что если Unix-сокет находится в каталоге <code class="filename">/tmp</code> или в другом каталоге, запись в который разрешена всем пользователям, тогда любой пользователь сможет запустить сервер, прослушивающий сокет в том каталоге. Используйте этот параметр, чтобы гарантировать, что вы подключены к серверу, запущенному доверенным пользователем.) Он поддерживается только на платформах, для которых реализован метод аутентификации <code class="literal">peer</code>; см. <a class="xref" href="auth-peer.html" title="21.9. Аутентификация peer">Раздел 21.9</a>.</p></dd><dt id="LIBPQ-CONNECT-SSL-MIN-PROTOCOL-VERSION"><span class="term"><code class="literal">ssl_min_protocol_version</code></span> <a href="#LIBPQ-CONNECT-SSL-MIN-PROTOCOL-VERSION" class="id_link">#</a></dt><dd><p>Этот параметр определяет, с какой минимальной версией протокола SSL/TLS может быть установлено подключение. Допустимые значения: <code class="literal">TLSv1</code>, <code class="literal">TLSv1.1</code>, <code class="literal">TLSv1.2</code> и <code class="literal">TLSv1.3</code>. Набор поддерживаемых протоколов зависит от используемой версии <span class="productname">OpenSSL</span>; старые версии могут не поддерживать последние протоколы. По умолчанию минимальной считается версия <code class="literal">TLSv1.2</code>, что соответствует рекомендациям, актуальным в индустрии на момент написания этой документации.</p></dd><dt id="LIBPQ-CONNECT-SSL-MAX-PROTOCOL-VERSION"><span class="term"><code class="literal">ssl_max_protocol_version</code></span> <a href="#LIBPQ-CONNECT-SSL-MAX-PROTOCOL-VERSION" class="id_link">#</a></dt><dd><p>Этот параметр определяет, с какой максимальной версией протокола SSL/TLS может быть установлено подключение. Допустимые значения: <code class="literal">TLSv1</code>, <code class="literal">TLSv1.1</code>, <code class="literal">TLSv1.2</code> и <code class="literal">TLSv1.3</code>. Набор поддерживаемых протоколов зависит от используемой версии <span class="productname">OpenSSL</span>; старые версии могут не поддерживать последние протоколы. Если этот параметр не задан, при подключении будет действовать ограничение версии сверху, установленное на стороне сервера (при наличии такового). Возможность ограничения максимальной версии протокола полезна прежде всего при тестировании или когда какой-либо компонент работает с новым протоколом некорректно.</p></dd><dt id="LIBPQ-CONNECT-KRBSRVNAME"><span class="term"><code class="literal">krbsrvname</code></span> <a href="#LIBPQ-CONNECT-KRBSRVNAME" class="id_link">#</a></dt><dd><p>Имя службы Kerberos, которое будет использоваться при аутентификации GSSAPI. Чтобы аутентификация Kerberos прошла успешна, оно должно соответствовать имени службы, заданному в конфигурации сервера. (См. также <a class="xref" href="gssapi-auth.html" title="21.6. Аутентификация GSSAPI">Раздел 21.6</a>.) По умолчанию обычно выбирается имя <code class="literal">postgres</code>, но его можно сменить при сборке <span class="productname">PostgreSQL</span>, передав ключ <code class="option">--with-krb-srvnam</code> скрипту <span class="application">configure</span>. В большинстве случаев менять этот параметр нет необходимости. Для некоторых реализаций Kerberos может требоваться другое имя службы, например, Microsoft Active Directory требует, чтобы имя службы задавалось в верхнем регистре (<code class="literal">POSTGRES</code>).</p></dd><dt id="LIBPQ-CONNECT-GSSLIB"><span class="term"><code class="literal">gsslib</code></span> <a href="#LIBPQ-CONNECT-GSSLIB" class="id_link">#</a></dt><dd><p>Библиотека GSS, предназначенная для использования при аутентификации на основе GSSAPI. В настоящее время это действует только в сборках для Windows, поддерживающих одновременно и GSSAPI, и SSPI. Значение <code class="literal">gssapi</code> в таких сборках позволяет указать, что libpq должна использовать для аутентификации библиотеку GSSAPI, а не подразумеваемую по умолчанию SSPI.</p></dd><dt id="LIBPQ-CONNECT-GSSDELEGATION"><span class="term"><code class="literal">gssdelegation</code></span> <a href="#LIBPQ-CONNECT-GSSDELEGATION" class="id_link">#</a></dt><dd><p>Переслать (делегировать) учётные данные GSS серверу. По умолчанию используется значение <code class="literal">0</code>. Это означает, что учётные данные не будут пересылаться серверу. Установите для этого параметра значение <code class="literal">1</code>, чтобы учётные данные пересылались, когда это возможно.</p></dd><dt id="LIBPQ-CONNECT-SERVICE"><span class="term"><code class="literal">service</code></span> <a href="#LIBPQ-CONNECT-SERVICE" class="id_link">#</a></dt><dd><p>Имя сервиса, используемое для задания дополнительных параметров. Оно указывает имя сервиса в файле <code class="filename">pg_service.conf</code>, который содержит дополнительные параметры подключения. Это позволяет приложениям указывать только имя сервиса, поскольку параметры подключения могут поддерживаться централизованно. См. <a class="xref" href="libpq-pgservice.html" title="34.17. Файл соединений служб">Раздел 34.17</a>.</p></dd><dt id="LIBPQ-CONNECT-TARGET-SESSION-ATTRS"><span class="term"><code class="literal">target_session_attrs</code></span> <a href="#LIBPQ-CONNECT-TARGET-SESSION-ATTRS" class="id_link">#</a></dt><dd><p>Этот параметр может накладывать ограничения на свойства сеансов, которые будут считаться приемлемыми. Обычно он используется вместе с указанием имён нескольких серверов и позволяет выбрать из них первый подходящий вариант. Есть шесть режимов: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">any</code> (по умолчанию)</span></dt><dd><p>любое успешное соединение приемлемо</p></dd><dt><span class="term"><code class="literal">read-write</code></span></dt><dd><p>сеанс должен принимать транзакции чтения-записи по умолчанию (то есть сервер не должен находиться в режиме горячего резерва, а у параметра <code class="varname">default_transaction_read_only</code> должно быть значение <code class="literal">off</code>)</p></dd><dt><span class="term"><code class="literal">read-only</code></span></dt><dd><p>сеанс не должен принимать транзакции чтения-записи по умолчанию (противоположный случай)</p></dd><dt><span class="term"><code class="literal">primary</code></span></dt><dd><p>сервер не должен находиться в режиме горячего резерва</p></dd><dt><span class="term"><code class="literal">standby</code></span></dt><dd><p>сервер должен находиться в режиме горячего резерва</p></dd><dt><span class="term"><code class="literal">prefer-standby</code></span></dt><dd><p>сначала пытаться найти резервный сервер, но если ни один из перечисленных серверов не является резервным, попробовать снова в режиме <code class="literal">any</code></p></dd></dl></div></dd><dt id="LIBPQ-CONNECT-LOAD-BALANCE-HOSTS"><span class="term"><code class="literal">load_balance_hosts</code></span> <a href="#LIBPQ-CONNECT-LOAD-BALANCE-HOSTS" class="id_link">#</a></dt><dd><p>Управляет порядком, в котором клиент пытается подключиться к доступным узлам и адресам. Если попытка подключения окажется успешной, клиент не будет пытаться подключиться к другим узлам и адресам. Этот параметр обычно используется вместе с несколькими именами узлов или записью DNS, которая возвращает несколько IP-адресов. Его также можно использовать вместе с <a class="xref" href="libpq-connect.html#LIBPQ-CONNECT-TARGET-SESSION-ATTRS">target_session_attrs</a>, например для балансировки нагрузки только между резервными серверами. После успешного подключения все последующие запросы по возвращённому подключению будут отправлены на один и тот же сервер. В настоящее время существует два режима: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">disable</code> (по умолчанию)</span></dt><dd><p>Балансировка нагрузки между узлами не выполняется. Узлы перебираются по очереди, а адреса — в том порядке, в котором они получены от DNS или файлов узлов.</p></dd><dt><span class="term"><code class="literal">random</code></span></dt><dd><p>Узлы и адреса перебираются в случайном порядке. Это значение наиболее полезно при одновременном открытии нескольких соединений, возможно с разных компьютеров. Таким образом, нагрузка может распределяться между соединениями нескольких серверов <span class="productname">PostgreSQL</span>.</p><p>Хотя случайная балансировка нагрузки по своей природе почти никогда не приводит к полностью равномерному распределению, статистически она довольно близка к этому. Важно то, что этот алгоритм использует два уровня случайного выбора: сначала узлы разрешаются в случайном порядке, затем перед разрешением следующего узла все разрешённые адреса текущего узла перебираются в случайном порядке. Такое поведение может сильно влиять на количество подключений, которые получает каждый узел в определённых случаях, например, когда некоторые узлы разрешают больше адресов, чем другие. Но такое влияние можно использовать и намеренно. Например, чтобы увеличить количество подключений к более крупному серверу, можно несколько раз указать его имя в соответствующей строке.</p><p>При использовании этого значения рекомендуется также выбрать подходящее значение для <a class="xref" href="libpq-connect.html#LIBPQ-CONNECT-CONNECT-TIMEOUT">connect_timeout</a>, потому что в таком случае, если один из узлов, используемых для балансировки нагрузки, не отвечает, будет использоваться новый узел.</p></dd></dl></div><p>.</p></dd></dl></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="libpq.html" title="Глава 34. libpq — библиотека для языка C">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="libpq.html" title="Глава 34. libpq — библиотека для языка C">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="libpq-status.html" title="34.2. Функции, описывающие текущее состояние подключения">След.</a></td></tr><tr><td width="40%" align="left" valign="top">Глава 34. <span class="application">libpq</span> — библиотека для языка C </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 34.2. Функции, описывающие текущее состояние подключения</td></tr></table></div></body></html>