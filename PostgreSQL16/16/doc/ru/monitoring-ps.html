<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>28.1. Стандартные инструменты Unix</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="monitoring.html" title="Глава 28. Мониторинг работы СУБД" /><link rel="next" href="monitoring-stats.html" title="28.2. Система накопительной статистики" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">28.1. Стандартные инструменты Unix</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="monitoring.html" title="Глава 28. Мониторинг работы СУБД">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="monitoring.html" title="Глава 28. Мониторинг работы СУБД">Наверх</a></td><th width="60%" align="center">Глава 28. Мониторинг работы СУБД</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="monitoring-stats.html" title="28.2. Система накопительной статистики">След.</a></td></tr></table><hr /></div><div class="sect1" id="MONITORING-PS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">28.1. Стандартные инструменты Unix <a href="#MONITORING-PS" class="id_link">#</a></h2></div></div></div><a id="id-1.6.15.6.2" class="indexterm"></a><p>В большинстве Unix-платформ <span class="productname">PostgreSQL</span> модифицирует заголовок команды, который выводится на экран при выполнении команды <code class="command">ps</code>, так что серверные процессы можно легко различить. Пример вывода этой команды: </p><pre class="screen">
$ ps auxww | grep ^postgres
postgres  15551  0.0  0.1  57536  7132 pts/0    S    18:02   0:00 postgres -i
postgres  15554  0.0  0.0  57536  1184 ?        Ss   18:02   0:00 postgres: background writer
postgres  15555  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: checkpointer
postgres  15556  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: walwriter
postgres  15557  0.0  0.0  58504  2244 ?        Ss   18:02   0:00 postgres: autovacuum launcher
postgres  15582  0.0  0.0  58772  3080 ?        Ss   18:04   0:00 postgres: joe runbug 127.0.0.1 idle
postgres  15606  0.0  0.0  58772  3052 ?        Ss   18:07   0:00 postgres: tgl regression [local] SELECT waiting
postgres  15610  0.0  0.0  58772  3056 ?        Ss   18:07   0:00 postgres: tgl regression [local] idle in transaction
</pre><p> (Формат вызова <code class="command">ps</code>, а также детали отображаемой информации зависят от платформы. Это пример для одной из последних Linux-систем.) Первым здесь отображается главный процесс сервера. Для этого процесса отображены аргументы команды, которые использовались при его запуске. Следующие четыре процесса — это фоновые рабочие процессы, которые были автоматически запущены процессом сервера. (Фонового процесса <span class="quote">«<span class="quote">autovacuum launcher</span>»</span> в этом списке не будет, если автоочистка отключена в системе.) Во всех остальных строках перечислены серверные процессы, каждый из которых обслуживает одно клиентское подключение. Командная строка каждого такого процесса имеет следующий формат: </p><pre class="screen">
postgres: <em class="replaceable"><code>пользователь</code></em> <em class="replaceable"><code>база_данных</code></em> <em class="replaceable"><code>компьютер</code></em> <em class="replaceable"><code>активность</code></em>
</pre><p> Пользователь, СУБД и компьютер (клиента) остаются неизменными на протяжении всего клиентского подключения, а индикатор деятельности меняется. Возможные виды деятельности: <code class="literal">idle</code> (т. е. ожидание команды клиента), <code class="literal">idle in transaction</code> (ожидание клиента внутри блока <code class="command">BEGIN</code>) или название типа команды, например, <code class="literal">SELECT</code>. Кроме того, если в настоящий момент серверный процесс ожидает высвобождения блокировки, которую держит другой сеанс, то к виду деятельности добавляется <code class="literal">waiting</code>. В приведённом выше примере мы видим, что процесс 15606 ожидает, когда процесс 15610 завершит свою транзакцию и, следовательно, освободит какую-то блокировку. (Процесс 15610 является блокирующим, поскольку никаких других активных сеансов нет. В более сложных случаях может потребоваться обращение к системному представлению <a class="link" href="view-pg-locks.html" title="54.12. pg_locks"><code class="structname">pg_locks</code></a>, для того чтобы определить, кто кого блокирует.)</p><p>Если установлено значение <a class="xref" href="runtime-config-logging.html#GUC-CLUSTER-NAME">cluster_name</a>, имя кластера также будет показываться в выводе команды <code class="command">ps</code>: </p><pre class="screen">
$ psql -c 'SHOW cluster_name'
 cluster_name
--------------
 server1
(1 row)

$ ps aux|grep server1
postgres   27093  0.0  0.0  30096  2752 ?        Ss   11:34   0:00 postgres: server1: background writer
...
</pre><p>Если параметр <a class="xref" href="runtime-config-logging.html#GUC-UPDATE-PROCESS-TITLE">update_process_title</a> был отключён, то индикатор деятельности не обновляется; название процесса устанавливается только один раз при запуске нового процесса. На некоторых платформах это позволяет значительно сократить накладные расходы при выполнении команды; на других платформах этот выигрыш может быть незначителен.</p><div class="tip"><h3 class="title">Подсказка</h3><p>В <span class="productname">Solaris</span> требуется особый подход. Следует использовать <code class="command">/usr/ucb/ps</code> вместо <code class="command">/bin/ps</code>. Также следует использовать два флага <code class="option">w</code>, а не один. Кроме того, при выводе статусов команд с помощью <code class="command">ps</code> статус для исходной команды <code class="command">postgres</code> должен отображаться в сокращённом формате для каждого серверного процесса. Если вы не сделаете все три вещи, то вывод <code class="command">ps</code> для каждого серверного процесса будет исходной командной строкой <code class="command">postgres</code>.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="monitoring.html" title="Глава 28. Мониторинг работы СУБД">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="monitoring.html" title="Глава 28. Мониторинг работы СУБД">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="monitoring-stats.html" title="28.2. Система накопительной статистики">След.</a></td></tr><tr><td width="40%" align="left" valign="top">Глава 28. Мониторинг работы СУБД </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 28.2. Система накопительной статистики</td></tr></table></div></body></html>