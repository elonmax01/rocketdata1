<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>38.12. Пользовательские агрегатные функции</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="xfunc-optimization.html" title="38.11. Информация для оптимизации функций" /><link rel="next" href="xtypes.html" title="38.13. Пользовательские типы" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">38.12. Пользовательские агрегатные функции</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="xfunc-optimization.html" title="38.11. Информация для оптимизации функций">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="extend.html" title="Глава 38. Расширение SQL">Наверх</a></td><th width="60%" align="center">Глава 38. Расширение <acronym class="acronym">SQL</acronym></th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="xtypes.html" title="38.13. Пользовательские типы">След.</a></td></tr></table><hr /></div><div class="sect1" id="XAGGR"><div class="titlepage"><div><div><h2 class="title" style="clear: both">38.12. Пользовательские агрегатные функции <a href="#XAGGR" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="xaggr.html#XAGGR-MOVING-AGGREGATES">38.12.1. Режим движущегося агрегата</a></span></dt><dt><span class="sect2"><a href="xaggr.html#XAGGR-POLYMORPHIC-AGGREGATES">38.12.2. Агрегатные функции с полиморфными и переменными аргументами</a></span></dt><dt><span class="sect2"><a href="xaggr.html#XAGGR-ORDERED-SET-AGGREGATES">38.12.3. Сортирующие агрегатные функции</a></span></dt><dt><span class="sect2"><a href="xaggr.html#XAGGR-PARTIAL-AGGREGATES">38.12.4. Частичное агрегирование</a></span></dt><dt><span class="sect2"><a href="xaggr.html#XAGGR-SUPPORT-FUNCTIONS">38.12.5. Вспомогательные функции для агрегатов</a></span></dt></dl></div><a id="id-1.8.3.15.2" class="indexterm"></a><p>Агрегатные функции в <span class="productname">PostgreSQL</span> определяются в терминах <em class="firstterm">значений состояния</em> и <em class="firstterm">функций перехода состояния</em>. То есть агрегатная функция работает со значением состояния, которое меняется при обработке каждой последующей строки. Чтобы определить агрегатную функцию, нужно выбрать тип данных для значения состояния, начальное значение состояния и функцию перехода состояния. Функция перехода состояния принимает предыдущее значение состояния и входное агрегируемое значение для текущей строки и возвращает новое значение состояния. Также можно указать <em class="firstterm">функцию завершения</em>, на случай, если ожидаемый результат агрегатной функции отличается от данных, которые сохраняются в изменяющемся значении состояния. Функция завершения принимает конечное значение состояния и возвращает то, что она хочет вернуть в виде результата агрегирования. В принципе, функции перехода и завершения представляют собой просто обычные функции, которые также могут применяться вне контекста агрегирования. (На практике для большей производительности часто создаются специализированные функции перехода, которые работают, только когда вызываются при агрегировании.)</p><p>Таким образом, помимо типов данных аргументов и результата, с которыми имеет дело пользователь агрегатной функции, есть также тип данных внутреннего состояния, который может отличаться от этих типов.</p><p>Если мы определяем агрегат, не использующий функцию завершения, наш агрегат будет вычислять бегущее значение функции по столбцам каждой строки. Примером такой агрегатной функции является <code class="function">sum</code>. Вычисление <code class="function">sum</code> начинается с нуля, а затем к накапливаемой сумме всегда прибавляется значение из текущей строки. Например, если мы хотим сделать агрегатную функцию <code class="function">sum</code> для комплексных чисел, нам потребуется только функция сложения для такого типа данных. Такая агрегатная функция может быть определена так: </p><pre class="programlisting">CREATE AGGREGATE sum (complex)
(
    sfunc = complex_add,
    stype = complex,
    initcond = '(0,0)'
);</pre><p> Использовать её можно будет так: </p><pre class="programlisting">SELECT sum(a) FROM test_complex;

   sum
-----------
 (34,53.9)</pre><p> (Заметьте, что мы задействуем перегрузку функций: в системе есть несколько агрегатных функций с именем <code class="function">sum</code>, но <span class="productname">PostgreSQL</span> может определить, какая именно из них применима к столбцу типа <code class="type">complex</code>.)</p><p>Определённая выше функция <code class="function">sum</code> вернёт ноль (начальное значение состояния), если в наборе данных не окажется значений, отличных от NULL. У нас может возникнуть желание вернуть NULL в этом случае — стандарт SQL требует, чтобы <code class="function">sum</code> работала так. Мы можем добиться этого, просто опустив фразу <code class="literal">initcond</code>, так что начальным значением состояния будет NULL. Обычно это будет означать, что в <code class="literal">sfunc</code> придётся проверять входное значение состояния на NULL. Но для <code class="function">sum</code> и некоторых других простых агрегатных функций, как <code class="function">max</code> и <code class="function">min</code>, достаточно вставить в переменную состояния первое входное значение не NULL, а затем начать применять функцию перехода со следующего значения не NULL. <span class="productname">PostgreSQL</span> сделает это автоматически, если начальное значение состояние равно NULL и функция перехода помечена как <span class="quote">«<span class="quote">strict</span>»</span> (то есть не должна вызываться для аргументов NULL).</p><p>Ещё одна особенность поведения по умолчанию <span class="quote">«<span class="quote">строгой</span>»</span> функции перехода — предыдущее значение состояния остаётся без изменений, когда встречается значение NULL. Другими словами, значения NULL игнорируются. Если вам нужно другое поведение для входных значений NULL, не объявляйте свою функцию перехода строгой (strict); вместо этого, проверьте в ней поступающие значения на NULL и обработайте их, как требуется.</p><p>Функция <code class="function">avg</code> (вычисляющая среднее арифметическое) представляет собой более сложный пример агрегатной функции. Ей необходимы два компонента текущего состояния: сумма входных значений и их количество. Окончательный результат получается как частное этих величин. При реализации этой функции для значения состояния обычно используется массив. Например, встроенная реализация <code class="function">avg(float8)</code> выглядит так: </p><pre class="programlisting">CREATE AGGREGATE avg (float8)
(
    sfunc = float8_accum,
    stype = float8[],
    finalfunc = float8_avg,
    initcond = '{0,0,0}'
);</pre><div class="note"><h3 class="title">Примечание</h3><p>Функция <code class="function">float8_accum</code> принимает массив из трёх, а не двух элементов, так как в дополнение к количеству и сумме значений она подсчитывает ещё сумму их квадратов. Это сделано для того, чтобы её можно было применять для <code class="function">avg</code> и для некоторых других агрегатных функций.</p></div><p>Вызовы агрегатных функций SQL допускают указания <code class="literal">DISTINCT</code> и <code class="literal">ORDER BY</code>, которые определяют, какие строки и в каком порядке будут поступать в функцию перехода агрегата. Это реализовано на заднем плане и непосредственно не затрагивает функции, поддерживающие работу агрегата.</p><p>За дополнительными подробностями обратитесь к описанию <a class="xref" href="sql-createaggregate.html" title="CREATE AGGREGATE"><span class="refentrytitle">CREATE AGGREGATE</span></a>.</p><div class="sect2" id="XAGGR-MOVING-AGGREGATES"><div class="titlepage"><div><div><h3 class="title">38.12.1. Режим движущегося агрегата <a href="#XAGGR-MOVING-AGGREGATES" class="id_link">#</a></h3></div></div></div><a id="id-1.8.3.15.12.2" class="indexterm"></a><a id="id-1.8.3.15.12.3" class="indexterm"></a><p>Агрегатные функции могут дополнительно поддерживать <em class="firstterm">режим движущегося агрегата</em>, который позволяет значительно быстрее выполнять агрегатные функции в окнах со сдвигающимся началом рамки. (За информацией об использовании агрегатных функций в качестве оконных обратитесь к <a class="xref" href="tutorial-window.html" title="3.5. Оконные функции">Разделу 3.5</a> и <a class="xref" href="sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS" title="4.2.8. Вызовы оконных функций">Подразделу 4.2.8</a>.) Основная идея состоит в том, что помимо добавления обычной функции перехода <span class="quote">«<span class="quote">вперёд</span>»</span>, для агрегатной функции задаётся <em class="firstterm">функция обратного перехода</em>, которая позволяет убирать строки из накапливаемого значения состояния, когда они покидают рамку окна. Например, для <code class="function">sum</code> в качестве функции прямого перехода выполняется сложение, а в качестве функции обратного перехода выполняется вычитание. Без функции обратного перехода механизм оконных функций вынужден вычислять агрегат заново при каждом перемещении начала рамки, в результате чего время обработки оказывается пропорциональным количеству входных строк, помноженному на средний размер рамки. С функцией обратного перехода это время пропорционально только количеству входных строк.</p><p>Функции обратного перехода передаётся текущее значение состояния и агрегируемое входное значение(я) для строки, ранее учтённой в текущем состоянии. Она должна восстановить то значение состояния, которое было бы получено, если бы эта строка не агрегировалась, но агрегировались все последующие. Иногда для этого нужно, чтобы функция обратного перехода сохраняла больше информации о состоянии, чем это требуется для простого режима агрегирования. Таким образом, для режима движущегося агрегата используется реализация, отличная от простого режима: для него определяется отдельный тип данных, отдельная функция прямого перехода и отдельная функция завершения, при необходимости. Они могут совпадать с типом данных и аналогичными функциями обычного режима, если в дополнительном состоянии необходимости нет.</p><p>В качестве примера мы можем доработать показанную выше агрегатную функцию <code class="function">sum</code>, чтобы она поддерживала режим движущегося агрегата так: </p><pre class="programlisting">CREATE AGGREGATE sum (complex)
(
    sfunc = complex_add,
    stype = complex,
    initcond = '(0,0)',
    msfunc = complex_add,
    minvfunc = complex_sub,
    mstype = complex,
    minitcond = '(0,0)'
);</pre><p> Параметры, имена которых начинаются с <code class="literal">m</code>, определяют реализацию для движущегося агрегата. За исключением функции обратного перехода, <code class="literal">minvfunc</code>, они соответствуют параметрам обычного агрегата без <code class="literal">m</code>.</p><p>Функции прямого перехода в режиме движущегося агрегата не разрешено возвращать NULL в качестве нового значения состояния. Если функция обратного перехода возвращает NULL, это воспринимается как признак того, что она не может восстановить предыдущее состояние для полученных данных, и значит, агрегатное вычисление нужно производить заново с текущей позиции начала рамки. Это соглашение позволяет применять режим движущегося агрегата и в ситуациях, когда прокручивать назад значение состояния непрактично. Функция обратного перехода может <span class="quote">«<span class="quote">спасовать</span>»</span> в таких случаях, но включаться в работу, насколько это возможно в большинстве случаев. Например, агрегатная функция, работающая с числами с плавающей точкой, может спасовать, когда от неё потребуется убрать значение <code class="literal">NaN</code> (не число, not a number) из текущего значения состояния.</p><p>Разрабатывая функции, реализующие режим движущегося агрегата, важно, чтобы функция обратного перехода могла восстановить в точности требуемое значение состояния. Иначе в результатах могут проявляться различия в зависимости от того, использовался ли режим движущегося агрегата. Например, на первый взгляд может показаться, что легко добавить функцию обратного перехода для сложения, но заявленное требование не будет выполняться для <code class="function">sum</code> с типом <code class="type">float4</code> или <code class="type">float8</code>. Наивное объявление <code class="function">sum(<code class="type">float8</code>)</code> может быть таким: </p><pre class="programlisting">CREATE AGGREGATE unsafe_sum (float8)
(
    stype = float8,
    sfunc = float8pl,
    mstype = float8,
    msfunc = float8pl,
    minvfunc = float8mi
);</pre><p> Однако такой агрегат может выдавать результаты, радикально отличающиеся от тех, что он выдавал бы без функции обратного перехода. Например, рассмотрите запрос </p><pre class="programlisting">SELECT
  unsafe_sum(x) OVER (ORDER BY n ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING)
FROM (VALUES (1, 1.0e20::float8),
             (2, 1.0::float8)) AS v (n,x);</pre><p> Он возвращает <code class="literal">0</code> в качестве второго результата, а не ожидаемое значение <code class="literal">1</code>. Это связано с ограниченной точностью значений с плавающей точкой: при добавлении <code class="literal">1</code> к <code class="literal">1e20</code> снова получается <code class="literal">1e20</code>, а при вычитании <code class="literal">1e20</code> из результата получается <code class="literal">0</code>, а не <code class="literal">1</code>. Заметьте, что это принципиальное ограничение арифметики чисел с плавающей точкой, а не недостаток <span class="productname">PostgreSQL</span>.</p></div><div class="sect2" id="XAGGR-POLYMORPHIC-AGGREGATES"><div class="titlepage"><div><div><h3 class="title">38.12.2. Агрегатные функции с полиморфными и переменными аргументами <a href="#XAGGR-POLYMORPHIC-AGGREGATES" class="id_link">#</a></h3></div></div></div><a id="id-1.8.3.15.13.2" class="indexterm"></a><a id="id-1.8.3.15.13.3" class="indexterm"></a><p>Агрегатная функция может использовать полиморфные функции перехода состояния или функции завершения, так что эти функции могут применяться для реализации нескольких агрегатов. За объяснением полиморфных функций обратитесь к <a class="xref" href="extend-type-system.html#EXTEND-TYPES-POLYMORPHIC" title="38.2.5. Полиморфные типы">Подразделу 38.2.5</a>. Более того, сама агрегатная функция может описываться с полиморфными типами входных данных и состояния, так что одно определение агрегатной функции может служить для использования с разными типами данных. Пример полиморфного агрегата: </p><pre class="programlisting">CREATE AGGREGATE array_accum (anycompatible)
(
    sfunc = array_append,
    stype = anycompatiblearray,
    initcond = '{}'
);</pre><p> Здесь фактическим типом состояния для любого конкретного агрегатного вызова будет массив, элементы которого будут иметь тип входных данных. Действие данного агрегата заключается в накоплении всех входных значений в массиве этого типа. (К вашему сведению: встроенная агрегатная функция <code class="function">array_agg</code> обеспечивает подобную функциональность, но работает быстрее, чем могла бы функция с приведённым определением.)</p><p>Так будут выглядеть результаты с аргументами двух различных типов: </p><pre class="programlisting">SELECT attrelid::regclass, array_accum(attname)
    FROM pg_attribute
    WHERE attnum &gt; 0 AND attrelid = 'pg_tablespace'::regclass
    GROUP BY attrelid;

   attrelid    |              array_accum
---------------+---------------------------------------
 pg_tablespace | {spcname,spcowner,spcacl,spcoptions}
(1 row)

SELECT attrelid::regclass, array_accum(atttypid::regtype)
    FROM pg_attribute
    WHERE attnum &gt; 0 AND attrelid = 'pg_tablespace'::regclass
    GROUP BY attrelid;

   attrelid    |        array_accum
---------------+---------------------------
 pg_tablespace | {name,oid,aclitem[],text[]}
(1 row)</pre><p>Обычно агрегатная функция с полиморфным типом результата имеет и полиморфный тип состояния, как в предыдущем примере. Это необходимо, так как иначе нельзя будет объявить функцию завершения: она должна будет иметь полиморфный тип результата, но не будет иметь полиморфного аргумента, что команда <code class="command">CREATE FUNCTION</code> не примет на основании того, что тип результата нельзя будет определить при вызове. Но иметь полиморфный тип состояния не всегда удобно. Чаще всего эта проблема возникает, когда функции реализации агрегата пишутся на C и тип состояния должен объявляться как <code class="type">internal</code>, так как для него нет соответствующего типа на уровне SQL. Чтобы решить эту проблему, можно объявить функцию завершения как принимающую дополнительные фиктивные аргументы, соответствующие входным аргументам агрегата. В этих фиктивных аргументах всегда передаются значения NULL, так как при вызове функции завершения какое-либо определённое значение отсутствует. Единственное их предназначение — позволить связать тип результата полиморфной функции завершения с типом входных данных агрегата. Например, определение встроенного агрегата <code class="function">array_agg</code> выглядит так: </p><pre class="programlisting">CREATE FUNCTION array_agg_transfn(internal, anynonarray)
  RETURNS internal ...;
CREATE FUNCTION array_agg_finalfn(internal, anynonarray)
  RETURNS anyarray ...;

CREATE AGGREGATE array_agg (anynonarray)
(
    sfunc = array_agg_transfn,
    stype = internal,
    finalfunc = array_agg_finalfn,
    finalfunc_extra
);</pre><p> Здесь параметр <code class="literal">finalfunc_extra</code> указывает, что функция завершения помимо значения состояния получит дополнительные фиктивные аргументы, соответствующие входным аргументам агрегата. Дополнительный аргумент <code class="type">anynonarray</code> позволяет сделать объявление <code class="function">array_agg_finalfn</code> допустимым.</p><p>Агрегатную функцию можно сделать принимающей переменное число аргументов, объявив её последний аргумент как массив <code class="literal">VARIADIC</code>, в том же ключе, как и обычную функцию; см. <a class="xref" href="xfunc-sql.html#XFUNC-SQL-VARIADIC-FUNCTIONS" title="38.5.6. Функции SQL с переменным числом аргументов">Подраздел 38.5.6</a>. При этом у функций перехода агрегата их последний аргумент должен иметь тот же тип массива. Такие функции обычно также объявляются как <code class="literal">VARIADIC</code>, но строго это не требуется.</p><div class="note"><h3 class="title">Примечание</h3><p>Агрегатные функции с переменными аргументами легко допускают ошибочное использование в сочетании с указанием <code class="literal">ORDER BY</code> (см. <a class="xref" href="sql-expressions.html#SYNTAX-AGGREGATES" title="4.2.7. Агрегатные выражения">Подраздел 4.2.7</a>), так как анализатор запроса не может определить, было ли передано нужное количество фактических параметров в такой комбинации. Помните, что всё, находящееся справа от <code class="literal">ORDER BY</code>, является ключом сортировки, а не аргументом агрегатной функции. Например, в </p><pre class="programlisting">SELECT myaggregate(a ORDER BY a, b, c) FROM ...</pre><p> анализатор запроса увидит один агрегатный аргумент функции и три ключа сортировки. Однако пользователь мог подразумевать и следующее: </p><pre class="programlisting">SELECT myaggregate(a, b, c ORDER BY a) FROM ...</pre><p> Если функция <code class="literal">myaggregate</code> принимает переменные аргументы, оба эти вызова будут вполне допустимы.</p><p>По этой же причине, стоит подумать дважды, прежде чем создавать агрегатные функции с одинаковыми именами, но разным числом обычных аргументов.</p></div></div><div class="sect2" id="XAGGR-ORDERED-SET-AGGREGATES"><div class="titlepage"><div><div><h3 class="title">38.12.3. Сортирующие агрегатные функции <a href="#XAGGR-ORDERED-SET-AGGREGATES" class="id_link">#</a></h3></div></div></div><a id="id-1.8.3.15.14.2" class="indexterm"></a><p>Описанные выше агрегатные функции были <span class="quote">«<span class="quote">обычными</span>»</span> агрегатами. Но <span class="productname">PostgreSQL</span> также поддерживает <em class="firstterm">сортирующие агрегатные функции</em>, которые имеют два отличия от обычных. Во-первых, в дополнение к обычным агрегируемым аргументам, вычисляемых для каждой входной строки, сортирующий агрегат может иметь <span class="quote">«<span class="quote">непосредственные</span>»</span> аргументы, которые должны вычисляться в операции агрегирования только один раз. Во-вторых, для обычных агрегируемых аргументов порядок их сортировки задаётся явно, а сортирующий агрегат обычно выполняет вычисления, зависящие от конкретного порядка строк, например, вычисляет ранг или процентиль, так что порядок сортировки критичен для каждого вызова. Например, встроенное определение функции <code class="function">percentile_disc</code> равнозначно следующему: </p><pre class="programlisting">CREATE FUNCTION ordered_set_transition(internal, anyelement)
  RETURNS internal ...;
CREATE FUNCTION percentile_disc_final(internal, float8, anyelement)
  RETURNS anyelement ...;

CREATE AGGREGATE percentile_disc (float8 ORDER BY anyelement)
(
    sfunc = ordered_set_transition,
    stype = internal,
    finalfunc = percentile_disc_final,
    finalfunc_extra
);</pre><p> Этот агрегат принимает непосредственный аргумент <code class="type">float8</code> (дробь процентиля) и агрегируемые данные, которые могут быть любого упорядочиваемого типа. Используя его, можно рассчитать средний семейный доход следующим образом: </p><pre class="programlisting">SELECT percentile_disc(0.5) WITHIN GROUP (ORDER BY income) FROM households;
 percentile_disc
-----------------
           50489</pre><p> В данном случае <code class="literal">0.5</code> — это непосредственный аргумент; если бы дробь процентиля менялась от строки к строке, это не имело бы смысла.</p><p>В отличие от случая с обычными агрегатами, сортировка входных строк для сортирующего агрегата <span class="emphasis"><em>не</em></span> выполняется на заднем плане, а является задачей функций, реализующих агрегат. Типичная реализация такого агрегата заключается в сохранении ссылки на объект <span class="quote">«<span class="quote">tuplesort</span>»</span> в значении состояния агрегата, загрузке поступающих строк в этот объект, и собственно окончании сортировки и выдачи данных в функции завершения. При такой организации обработки функция завершения может выполнять специальные операции, в частности, вставлять дополнительные <span class="quote">«<span class="quote">гипотетические</span>»</span> строки в сортируемые данные. Тогда как обычные агрегаты часто реализуются функциями, написанными на <span class="application">PL/pgSQL</span> или другом процедурном языке, сортирующие агрегатные функции, как правило, должны быть написаны на C, так как их значение состояния нельзя выразить каким-либо типом данных SQL. (Обратите внимание, что в приведённом выше примере значение состояния объявлено как имеющее тип <code class="type">internal</code> — это типичный вариант.) И вследствие того, что сортировку выполняет функция завершения, нельзя возобновить добавление входных строк, продолжая вызывать функцию перехода. Это означает, что функция завершения не может иметь характеристику <code class="literal">READ_ONLY</code>; она должна объявляться командой <a class="link" href="sql-createaggregate.html" title="CREATE AGGREGATE"><code class="command">CREATE AGGREGATE</code></a> с характеристикой <code class="literal">READ_WRITE</code> или <code class="literal">SHAREABLE</code> (если она позволяет при последующих вызовах функции завершения использовать уже отсортированное состояние).</p><p>Функция перехода состояния для сортирующего агрегата получает значение текущего состояния плюс агрегируемые входные данные для каждой строки и возвращает изменённое значение состояния. Это определение распространяется и на обычные агрегаты, но заметьте, что непосредственные аргументы (если они есть) при этом не передаются. Функция завершения же получает последнее значение состояния и значения непосредственных аргументов (если они есть), а также (если присутствует указание <code class="literal">finalfunc_extra</code>) значения NULL, соответствующие агрегируемым данным. С обычными агрегатами указание <code class="literal">finalfunc_extra</code> действительно полезно, только если агрегат полиморфный; тогда дополнительные фиктивные аргументы необходимы, чтобы связать тип результата функции завершения с типом(ами) входных данных агрегата.</p><p>В настоящее время сортирующие агрегаты не могут использоваться в качестве оконных функций, поэтому от них поддержка режима движущегося агрегата не требуется.</p></div><div class="sect2" id="XAGGR-PARTIAL-AGGREGATES"><div class="titlepage"><div><div><h3 class="title">38.12.4. Частичное агрегирование <a href="#XAGGR-PARTIAL-AGGREGATES" class="id_link">#</a></h3></div></div></div><a id="id-1.8.3.15.15.2" class="indexterm"></a><p>Дополнительно агрегатная функция может поддерживать <em class="firstterm">частичное агрегирование</em>. Идея такого агрегирования в том, чтобы вызывать функции перехода состояния для различных подмножеств входных данных независимо, а затем комбинировать значения состояния, вычисленные по этим подмножествам, и получать тот же результат, что был бы получен при сканировании сразу всех входных данных. Этот режим может применяться для параллельного агрегирования, когда разные рабочие процессы сканируют различные части таблицы. При этом каждый рабочий процесс выдаёт частичное значение состояния, а в конце эти значения комбинируются вместе и получается окончательное значение состояния. (В будущем этот режим может также применяться, например для комбинированного агрегирования локальных и удалённых таблиц, но пока это не реализовано.)</p><p>Для поддержки частичного агрегирования в определении агрегатной функции должна задаваться <em class="firstterm">комбинирующая функция</em>, принимающая два значения типа состояния агрегата (представляющие результаты агрегирования по двум подмножествам входных строк) и выдающая новое значение типа состояния, представляющее то состояние, которое было бы получено при агрегировании совокупности этих подмножеств строк. При этом относительный порядок входных строк в этих двух множествах не оговаривается. Это значит, что для агрегатных функций, зависящих от порядка входных строк, обычно невозможно определить осмысленную комбинирующую функцию.</p><p>В качестве простого примера, частичное агрегирование могут поддерживать функции <code class="literal">MAX</code> и <code class="literal">MIN</code>, если задать в качестве комбинирующей соответственно функцию сравнения значений большее-из-двух или меньшее-из-двух, ту же, что они используют и как функцию перехода. Для <code class="literal">SUM</code> комбинирующей функцией будет просто функция сложения. (И это опять же функция перехода, если только значение состояния не выходит за рамки типа входных данных.)</p><p>Комбинирующая функция задействуется практически так же, как функция перехода, но принимает в качестве второго аргумента значение типа состояния, а не нижележащего входного типа. В частности, на неё распространяются те же правила строгости функции и передачи значений NULL. Также учтите, что если в определении агрегатной функции задаётся отличное от NULL значение <code class="literal">initcond</code>, оно будет задавать начальное состояние не только для каждого прохода частичного агрегирования, но также и начальное состояние для комбинирующей функции, которая будет вызываться для комбинирования каждого частичного результата в этом состоянии.</p><p>Если типом состояния агрегатной функции выбран <code class="type">internal</code>, комбинирующая функция отвечает за то, чтобы её результат был помещён в контекст памяти, подходящий для значений агрегатного состояния. В частности это значит, что, получив в первом аргументе <code class="literal">NULL</code>, нельзя просто возвратить второй аргумент, так как это значение окажется в неверном контексте и не просуществует достаточное время.</p><p>Когда типом состояния агрегатной функции выбран <code class="type">internal</code>, обычно в определении агрегатной функции также уместно задать <em class="firstterm">функцию сериализации</em> и <em class="firstterm">функцию десериализации</em>, которые позволяют копировать значение состояния из одного процесса в другой. Без этих функций параллельное агрегирование невозможно, а также вероятно не будут работать такие будущие приложения, как локальное/удалённое агрегирование.</p><p>Функция сериализации должна принимать один аргумент типа <code class="type">internal</code> и возвращать результат типа <code class="type">bytea</code>, представляющий значение состояния, упакованное в плоский набор байтов. Функция десериализации, напротив, обращает это преобразование. Она должна принимать два аргумента типов <code class="type">bytea</code> и <code class="type">internal</code> и возвращать результат типа <code class="type">internal</code>. (Второй её аргумент не используется и всегда равен нулю, но он требуется из соображений типобезопасности.) Результат функции десериализации следует просто разместить в текущем контексте памяти, так как в отличие от результата комбинирующей функции он недолговечен.</p><p>Также стоит заметить, что для выполнения агрегатной функции в параллельном режиме она должна иметь характеристику <code class="literal">PARALLEL SAFE</code> (безопасная для распараллеливания). Характеристики допустимости распараллеливания её опорных функций значения не имеют.</p></div><div class="sect2" id="XAGGR-SUPPORT-FUNCTIONS"><div class="titlepage"><div><div><h3 class="title">38.12.5. Вспомогательные функции для агрегатов <a href="#XAGGR-SUPPORT-FUNCTIONS" class="id_link">#</a></h3></div></div></div><a id="id-1.8.3.15.16.2" class="indexterm"></a><p>Функция, написанная на C, может определить, была ли она вызвана как вспомогательная функция агрегирования, вызвав <code class="function">AggCheckCallContext</code>, например, так: </p><pre class="programlisting">if (AggCheckCallContext(fcinfo, NULL))</pre><p> Смысл такой проверки в том, что в случае положительного её результата первым входным аргументом является временное значение состояния, которое можно безопасно модифицировать на месте, не создавая новую копию. Пример вы можете увидеть в функции <code class="function">int8inc()</code>. (Хотя агрегатные функции перехода всегда могут изменить непосредственно переходное значение, агрегатные функции завершения должны избегать этого; если они это делают, такое поведение должно отмечаться при создании агрегата. За дополнительными подробностями обратитесь к <a class="xref" href="sql-createaggregate.html" title="CREATE AGGREGATE"><span class="refentrytitle">CREATE AGGREGATE</span></a>.)</p><p>Второй аргумент <code class="function">AggCheckCallContext</code> можно использовать, чтобы получить контекст памяти, в котором содержатся значения агрегатного состояния. Это полезно для функций перехода, которые желают использовать <span class="quote">«<span class="quote">развёрнутые</span>»</span> объёкты (см. <a class="xref" href="xtypes.html#XTYPES-TOAST" title="38.13.1. Особенности TOAST">Подраздел 38.13.1</a>) в качестве значений состояния. При первом вызове такая функция перехода должна возвратить развёрнутый объект в контексте памяти, относящемся к контексту состояния агрегата, а затем продолжать возвращать тот же объект при последующих вызовах. Например, эту логику можно увидеть в функции <code class="function">array_append()</code>. (Функция <code class="function">array_append()</code> не используется в качестве перехода никаким встроенным агрегатом, но она написана так, чтобы работать эффективно в таком качестве в дополнительном агрегате.)</p><p>Ещё одна вспомогательная подпрограмма, предназначенная для агрегатных функций, написанных на C, называется <code class="function">AggGetAggref</code>. Эта функция возвращает узел разбора <code class="literal">Aggref</code>, описывающий вызов агрегата. Это в основном полезно для сортирующих агрегатов, которые могут исследовать структуру узла <code class="literal">Aggref</code> и выяснить, какой порядок сортировки они должны реализовать. Примеры использования можно найти в <code class="filename">orderedsetaggs.c</code> в исходном коде <span class="productname">PostgreSQL</span>.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="xfunc-optimization.html" title="38.11. Информация для оптимизации функций">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="extend.html" title="Глава 38. Расширение SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="xtypes.html" title="38.13. Пользовательские типы">След.</a></td></tr><tr><td width="40%" align="left" valign="top">38.11. Информация для оптимизации функций </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 38.13. Пользовательские типы</td></tr></table></div></body></html>