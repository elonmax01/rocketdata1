<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CREATE POLICY</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sql-createopfamily.html" title="CREATE OPERATOR FAMILY" /><link rel="next" href="sql-createprocedure.html" title="CREATE PROCEDURE" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">CREATE POLICY</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-createopfamily.html" title="CREATE OPERATOR FAMILY">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><th width="60%" align="center">Команды SQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-createprocedure.html" title="CREATE PROCEDURE">След.</a></td></tr></table><hr /></div><div class="refentry" id="SQL-CREATEPOLICY"><div class="titlepage"></div><a id="id-1.9.3.75.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">CREATE POLICY</span></h2><p>CREATE POLICY — создать новую политику защиты на уровне строк для таблицы</p></div><div class="refsynopsisdiv"><h2>Синтаксис</h2><pre class="synopsis">CREATE POLICY <em class="replaceable"><code>имя</code></em> ON <em class="replaceable"><code>имя_таблицы</code></em>
    [ AS { PERMISSIVE | RESTRICTIVE } ]
    [ FOR { ALL | SELECT | INSERT | UPDATE | DELETE } ]
    [ TO { <em class="replaceable"><code>имя_роли</code></em> | PUBLIC | CURRENT_ROLE | CURRENT_USER | SESSION_USER } [, ...] ]
    [ USING ( <em class="replaceable"><code>выражение_USING</code></em> ) ]
    [ WITH CHECK ( <em class="replaceable"><code>выражение_CHECK</code></em> ) ]</pre></div><div class="refsect1" id="id-1.9.3.75.5"><h2>Описание</h2><p>Команда <code class="command">CREATE POLICY</code> определяет для таблицы новую политику защиты на уровне строк. Заметьте, что для таблицы должна быть включена защита на уровне строк (используя <code class="command">ALTER TABLE ... ENABLE ROW LEVEL SECURITY</code>), чтобы созданные политики действовали.</p><p>Политика даёт разрешение на выборку, добавление, изменение или удаление строк, удовлетворяющих соответствующему выражению политики. Существующие строки таблицы проверяются по выражению, указанному в <code class="literal">USING</code>, тогда как строки, которые могут быть созданы командами <code class="literal">INSERT</code> или <code class="literal">UPDATE</code> проверяются по выражению, указанному в <code class="literal">WITH CHECK</code>. Когда выражение <code class="literal">USING</code> истинно для заданной строки, эта строка видна пользователю, а если ложно или выдаёт NULL, строка не видна. Когда выражение <code class="literal">WITH CHECK</code> истинно для заданной строки, эта строка добавляется или изменяется, а если ложно или выдаёт NULL, происходит ошибка.</p><p>Для операторов <code class="command">INSERT</code>, <code class="command">UPDATE</code> и <code class="command">MERGE</code> выражения <code class="literal">WITH CHECK</code> применяются после срабатывания триггеров <code class="literal">BEFORE</code>, но до того, как будут собственно модифицированы данные. Таким образом, триггер <code class="literal">BEFORE ROW</code> может изменить данные, подлежащие добавлению, и повлиять на результат условия политики защиты. Выражения <code class="literal">WITH CHECK</code> обрабатываются до каких-либо других ограничений.</p><p>Имена политик задаются на уровне таблицы. Таким образом, одно имя политики можно использовать в нескольких разных таблицах и в каждой дать отдельное, подходящее этой таблице определение политики.</p><p>Политики могут применяться для определённых команд или для определённых ролей. По умолчанию создаваемые политики применяются для всех команд и ролей, если явно не задано другое. К одной команде могут применяться несколько политик; подробнее рассказывается ниже. В <a class="xref" href="sql-createpolicy.html#SQL-CREATEPOLICY-SUMMARY" title="Таблица 292. Политики, применяемые для разных команд">Таблице 292</a> показано, как к определённым командам применяются разные типы политик.</p><p>Для политик, которые могут иметь и выражения <code class="literal">USING</code>, и выражения <code class="literal">WITH CHECK</code> (<code class="literal">ALL</code> и <code class="literal">UPDATE</code>), в случае отсутствия выражения <code class="literal">WITH CHECK</code> выражение <code class="literal">USING</code> будет использоваться и для определения видимости строк (обычное назначение <code class="literal">USING</code>) и для определения, какие строки разрешено добавить (назначение <code class="literal">WITH CHECK</code>).</p><p>Если для таблицы включена защита на уровне строк, но применимые политики отсутствуют, предполагается политика <span class="quote">«<span class="quote">запрета по умолчанию</span>»</span>, так что никакие строки нельзя будет увидеть или изменить.</p></div><div class="refsect1" id="id-1.9.3.75.6"><h2>Параметры</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>имя</code></em></span></dt><dd><p>Имя создаваемой политики. Оно должно отличаться от имён других политик для этой таблицы.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_таблицы</code></em></span></dt><dd><p>Имя (возможно, дополненное схемой) существующей таблицы (или представления), к которой применяется эта политика.</p></dd><dt><span class="term"><code class="literal">PERMISSIVE</code></span></dt><dd><p>Указывает, что создаваемая политика должна быть разрешительной. Все разрешительные политики, которые применяются к данному запросу, будут объединяться вместе логическим оператором <span class="quote">«<span class="quote">ИЛИ</span>»</span>. Создавая разрешительные политики, администраторы могут расширять множество записей, к которым можно обращаться. Политики являются разрешительными по умолчанию.</p></dd><dt><span class="term"><code class="literal">RESTRICTIVE</code></span></dt><dd><p>Указывает, что создаваемая политика должна быть ограничительной. Все ограничительные политики, которые применяются к данному запросу, будут объединяться вместе логическим оператором <span class="quote">«<span class="quote">И</span>»</span>. Создавая ограничительные политики, администраторы могут сократить множество записей, к которым можно обращаться, так как для каждой записи должны удовлетворяться все ограничительные политики.</p><p>Заметьте, что для получения доступа к записям должна быть определена минимум одна разрешительная политика, и только в дополнение к ней могут быть определены имеющие смысл ограничительные политики, ограничивающие доступ. Если разрешительные политики отсутствуют, ни к каким записям обращаться нельзя. Когда определены и разрешительные, и ограничительные политики, запись будет доступна, если удовлетворяется минимум одна из разрешительных политик и все ограничительные.</p></dd><dt><span class="term"><em class="replaceable"><code>команда</code></em></span></dt><dd><p>Команда, к которой применяется политика. Допустимые варианты: <code class="command">ALL</code>, <code class="command">SELECT</code>, <code class="command">INSERT</code>, <code class="command">UPDATE</code> и <code class="command">DELETE</code>. <code class="command">ALL</code> (все) подразумевается по умолчанию. Особенности их применения описаны ниже.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_роли</code></em></span></dt><dd><p>Роль (роли), к которой применяется политика. По умолчанию подразумевается <code class="literal">PUBLIC</code>, то есть политика применяется ко всем ролям.</p></dd><dt><span class="term"><em class="replaceable"><code>выражение_USING</code></em></span></dt><dd><p>Произвольное условное выражение <acronym class="acronym">SQL</acronym> (возвращающее <code class="type">boolean</code>). Это условное выражение не может содержать агрегатные или оконные функции. Когда включена защита на уровне строк, оно добавляется в запросы, обращающиеся к данной таблице, и в их результатах оказываются видимыми только те строки, для которых оно выдаёт true. Все строки, для которых это выражение возвращает false или NULL, не будут видны пользователю (в запросе <code class="command">SELECT</code>), и не будут доступны для модификации (запросами <code class="command">UPDATE</code> или <code class="command">DELETE</code>). Такая строка просто пропускается, ошибка при этом не выдаётся.</p></dd><dt><span class="term"><em class="replaceable"><code>выражение_CHECK</code></em></span></dt><dd><p>Произвольное условное выражение <acronym class="acronym">SQL</acronym> (возвращающее <code class="type">boolean</code>). Это условное выражение не может содержать агрегатные или оконные функции. Когда включена защита на уровне строк, оно применяется в запросах <code class="command">INSERT</code> и <code class="command">UPDATE</code> к этой таблице, так что в них принимаются только те строки, для которых оно выдаёт true. Если это выражение выдаёт false или NULL для любой из добавляемых записей или записей, получаемых при изменении, выдаётся ошибка. Заметьте, что <em class="replaceable"><code>ограничение_проверки</code></em> вычисляется для предлагаемого нового содержимого строки, а не для существующих данных.</p></dd></dl></div><div class="refsect2" id="id-1.9.3.75.6.3"><h3>Политики по командам</h3><div class="variablelist"><dl class="variablelist"><dt id="SQL-CREATEPOLICY-ALL"><span class="term"><code class="literal">ALL</code></span> <a href="#SQL-CREATEPOLICY-ALL" class="id_link">#</a></dt><dd><p>Указание <code class="literal">ALL</code> для политики означает, что она применяется ко всем командам, вне зависимости от типа. Если существует политика <code class="literal">ALL</code> и другие более детализированные политики, тогда будет применяться и политика <code class="literal">ALL</code>, и более детализированная политика (или политики). Кроме того, политики <code class="literal">ALL</code> с выражением <code class="literal">USING</code> будут применяться и к стороне выборки, и к стороне изменения данных в запросе, если определено только выражение <code class="literal">USING</code>.</p><p>Например, когда выполняется <code class="literal">UPDATE</code>, политика <code class="literal">ALL</code> будет фильтровать и строки, которые сможет прочитать <code class="literal">UPDATE</code> для изменения (применяя выражение <code class="literal">USING</code>), и окончательные изменённые строки, проверяя, можно ли записать их в таблицу (применяя выражение <code class="literal">WITH CHECK</code>, если оно определено, или <code class="literal">USING</code> в противном случае). Если команда <code class="command">INSERT</code> или <code class="command">UPDATE</code> пытается добавить в таблицу строки, не удовлетворяющие выражению <code class="literal">WITH CHECK</code> политики <code class="literal">ALL</code>, вся команда будет прервана.</p></dd><dt id="SQL-CREATEPOLICY-SELECT"><span class="term"><code class="literal">SELECT</code></span> <a href="#SQL-CREATEPOLICY-SELECT" class="id_link">#</a></dt><dd><p>Указание <code class="literal">SELECT</code> для политики означает, что она применяется к запросам <code class="literal">SELECT</code> и тогда, когда при обращении к отношению, для которого определена политика, задействуется право <code class="literal">SELECT</code>. В результате запрос <code class="literal">SELECT</code> выдаст только те записи из отношения, которые удовлетворят политике <code class="literal">SELECT</code>, и запрос, использующий право <code class="literal">SELECT</code>, например, запрос <code class="literal">UPDATE</code>, увидит только записи, разрешённые политикой <code class="literal">SELECT</code>. Для политики <code class="literal">SELECT</code> не может задаваться выражение <code class="literal">WITH CHECK</code>, так как оно действует только когда записи читаются из отношения.</p></dd><dt id="SQL-CREATEPOLICY-INSERT"><span class="term"><code class="literal">INSERT</code></span> <a href="#SQL-CREATEPOLICY-INSERT" class="id_link">#</a></dt><dd><p>Указание <code class="literal">INSERT</code> для политики означает, что она применяется к командам <code class="literal">INSERT</code>, а также к командам <code class="literal">MERGE</code> с действиями <code class="literal">INSERT</code>. Если вставляемые строки не проходят проверку политики, выдаётся ошибка нарушения политики и вся команда <code class="literal">INSERT</code> прерывается. Для политики <code class="literal">INSERT</code> не может задаваться выражение <code class="literal">USING</code>, так как она действует только когда в отношение добавляются записи.</p><p>Заметьте, что <code class="literal">INSERT</code> с указанием <code class="literal">ON CONFLICT DO UPDATE</code> проверяет выражения <code class="literal">WITH CHECK</code> политик <code class="literal">INSERT</code> только для строк, добавляемых в отношение по пути <code class="literal">INSERT</code>.</p></dd><dt id="SQL-CREATEPOLICY-UPDATE"><span class="term"><code class="literal">UPDATE</code></span> <a href="#SQL-CREATEPOLICY-UPDATE" class="id_link">#</a></dt><dd><p>Выбор типа <code class="literal">UPDATE</code> для политики означает, что она будет применяться к командам <code class="literal">UPDATE</code>, <code class="literal">SELECT FOR UPDATE</code> и <code class="literal">SELECT FOR SHARE</code>, а также к дополнительным предложениям <code class="literal">ON CONFLICT DO UPDATE</code> команд <code class="literal">INSERT</code>. Это также касается команд <code class="literal">MERGE</code> с действиями <code class="literal">UPDATE</code>. Так как <code class="literal">UPDATE</code> подразумевает извлечение существующей записи и замену её новой изменённой записью, политики <code class="literal">UPDATE</code> принимают как выражение <code class="literal">USING</code>, так и <code class="literal">WITH CHECK</code>. Выражение <code class="literal">USING</code> определяет, какие записи команда <code class="literal">UPDATE</code> сможет увидеть для последующего изменения, а выражение <code class="literal">WITH CHECK</code> — какие изменённые строки сохранить в отношении.</p><p>Если в какой-либо строке изменённые значения не будут удовлетворять выражению <code class="literal">WITH CHECK</code>, произойдёт ошибка и вся команда будет прервана. Если указывается только предложение <code class="literal">USING</code>, его выражение будет применяться и в качестве <code class="literal">USING</code>, и в качестве выражения <code class="literal">WITH CHECK</code>.</p><p>Обычно команде <code class="literal">UPDATE</code> также нужно прочитать данные из столбцов подлежащего изменению отношения (например, в предложении <code class="literal">WHERE</code> или <code class="literal">RETURNING</code> либо в выражении в правой части предложения <code class="literal">SET</code>). В этом случае также требуется иметь права <code class="literal">SELECT</code> в изменяемом отношении и в дополнение к политикам <code class="literal">UPDATE</code> будут применяться соответствующие политики <code class="literal">SELECT</code> или <code class="literal">ALL</code>. Таким образом, помимо того, что пользователю должны разрешать изменение строк политики <code class="literal">UPDATE</code> или <code class="literal">ALL</code>, ему также должны разрешать доступ к изменяемым строкам политики <code class="literal">SELECT</code> или <code class="literal">ALL</code>.</p><p>Когда для команды <code class="literal">INSERT</code> задано вспомогательное предложение <code class="literal">ON CONFLICT DO UPDATE</code>, если выбирается путь <code class="literal">UPDATE</code>, строка, подлежащая изменению, сначала проверяется по выражениям <code class="literal">USING</code> всех политик <code class="literal">UPDATE</code>, а затем изменённая строка ещё раз проверяется по выражениям <code class="literal">WITH CHECK</code>. Заметьте, однако, что в отличие от отдельной команды <code class="literal">UPDATE</code>, если существующая строка не удовлетворяет выражениям <code class="literal">USING</code>, будет выдана ошибка (путь <code class="literal">UPDATE</code> <span class="emphasis"><em>никогда</em></span> не пропускается неявно).</p></dd><dt id="SQL-CREATEPOLICY-DELETE"><span class="term"><code class="literal">DELETE</code></span> <a href="#SQL-CREATEPOLICY-DELETE" class="id_link">#</a></dt><dd><p>Указание <code class="literal">DELETE</code> для политики означает, что она применяется к командам <code class="literal">DELETE</code>. Команда <code class="literal">DELETE</code> будет видеть только те строки, которые позволит эта политика. При этом строки могут быть видны через <code class="literal">SELECT</code>, но удалить их будет нельзя, если они не удовлетворяют выражению <code class="literal">USING</code> политики <code class="literal">DELETE</code>.</p><p>В большинстве случаев команде <code class="literal">DELETE</code> также нужно прочитать данные из столбцов в отношении, из которого осуществляется удаление (например, в предложении <code class="literal">WHERE</code> или <code class="literal">RETURNING</code>). В таких случаях необходимо также иметь право <code class="literal">SELECT</code> для этого отношения, и в дополнение к политикам <code class="literal">DELETE</code> будут применятся соответствующие политики <code class="literal">SELECT</code> или <code class="literal">ALL</code>. Таким образом, пользователь должен получить доступ к удаляемым строкам через политики <code class="literal">SELECT</code> или <code class="literal">ALL</code>, помимо того что удаление этих строк ему должны разрешить политики <code class="literal">DELETE</code> или <code class="literal">ALL</code>.</p><p>Для политики <code class="literal">DELETE</code> не может задаваться выражение <code class="literal">WITH CHECK</code>, так как она применяется только тогда, когда записи удаляются из отношения, а в этом случае новые строки, подлежащие проверке, отсутствуют.</p></dd></dl></div><div class="table" id="SQL-CREATEPOLICY-SUMMARY"><p class="title"><strong>Таблица 292. Политики, применяемые для разных команд</strong></p><div class="table-contents"><table class="table" summary="Политики, применяемые для разных команд" border="1"><colgroup><col /><col /><col /><col class="update-using" /><col class="update-check" /><col /></colgroup><thead><tr><th rowspan="2">Команда</th><th><code class="literal">Политика SELECT/ALL</code></th><th><code class="literal">Политика INSERT/ALL</code></th><th colspan="2"><code class="literal">Политика UPDATE/ALL</code></th><th><code class="literal">Политика DELETE/ALL</code></th></tr><tr><th><code class="literal">Выражение USING</code></th><th><code class="literal">Выражение WITH CHECK</code></th><th><code class="literal">Выражение USING</code></th><th><code class="literal">Выражение WITH CHECK</code></th><th><code class="literal">Выражение USING</code></th></tr></thead><tbody><tr><td><code class="command">SELECT</code></td><td>Существующая строка</td><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td><code class="command">SELECT FOR UPDATE/SHARE</code></td><td>Существующая строка</td><td>—</td><td>Существующая строка</td><td>—</td><td>—</td></tr><tr><td><code class="command">INSERT</code> / <code class="command">MERGE ... THEN INSERT</code></td><td>—</td><td>Новая строка</td><td>—</td><td>—</td><td>—</td></tr><tr><td><code class="command">INSERT ... RETURNING</code></td><td>Новая строка <a href="#ftn.RLS-SELECT-PRIV" class="footnote"><sup class="footnote" id="RLS-SELECT-PRIV">[a]</sup></a></td><td>Новая строка</td><td>—</td><td>—</td><td>—</td></tr><tr><td><code class="command">UPDATE</code> / <code class="command">MERGE ... THEN UPDATE</code></td><td>Существующие и новые строки <a href="sql-createpolicy.html#ftn.RLS-SELECT-PRIV" class="footnoteref"><sup class="footnoteref">[a]</sup></a></td><td>—</td><td>Существующая строка</td><td>Новая строка</td><td>—</td></tr><tr><td><code class="command">DELETE</code></td><td>Существующая строка <a href="sql-createpolicy.html#ftn.RLS-SELECT-PRIV" class="footnoteref"><sup class="footnoteref">[a]</sup></a></td><td>—</td><td>—</td><td>—</td><td>Существующая строка</td></tr><tr><td><code class="command">ON CONFLICT DO UPDATE</code></td><td>Существующие и новые строки</td><td>—</td><td>Существующая строка</td><td>Новая строка</td><td>—</td></tr></tbody><tbody class="footnotes"><tr><td colspan="6"><div id="ftn.RLS-SELECT-PRIV" class="footnote"><p><a href="#RLS-SELECT-PRIV" class="para"><sup class="para">[a] </sup></a>Если для существующей или новой строки требуется доступ на чтение (например, предложение <code class="literal">WHERE</code> или <code class="literal">RETURNING</code>, обращающееся к столбцам отношения).</p></div></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="refsect2" id="id-1.9.3.75.6.4"><h3>Применение нескольких политик</h3><p>Когда к одной команде применяются несколько политик для различных типов команд (как например, политики <code class="literal">SELECT</code> и <code class="literal">UPDATE</code> применяются к команде <code class="literal">UPDATE</code>), пользователь должен иметь разрешения всех этих типов (например, разрешение для выборки строк из отношения, а также разрешение на их изменение). Таким образом, выражения для одного типа политики комбинируются с выражениями для другого типа операцией <code class="literal">И</code>.</p><p>Когда к одной команде применяются несколько политик для одного типа команды, доступ к отношению должна дать как минимум одна разрешительная (<code class="literal">PERMISSIVE</code>) политика, а также должны удовлетворяться все ограничительные (<code class="literal">RESTRICTIVE</code>) политики. Таким образом выражения всех политик <code class="literal">PERMISSIVE</code> объединяются операцией <code class="literal">ИЛИ</code>, выражения всех политик <code class="literal">RESTRICTIVE</code> объединяются операцией <code class="literal">И</code>, а полученные результаты объединяются операцией <code class="literal">И</code>. Если политики <code class="literal">PERMISSIVE</code> отсутствуют, доступ запрещается.</p><p>Заметьте, что при объединении нескольких политик, политики <code class="literal">ALL</code> применяются как политики каждого применимого в данном случае типа.</p><p>Например, в команде <code class="literal">UPDATE</code>, требующей разрешений и для <code class="literal">SELECT</code>, и для <code class="literal">UPDATE</code>, в случае существования нескольких применимых политик каждого типа они будут объединяться следующим образом: </p><pre class="programlisting"><em class="replaceable"><code>выражение</code></em> from RESTRICTIVE SELECT/ALL policy 1
AND
<em class="replaceable"><code>выражение</code></em> from RESTRICTIVE SELECT/ALL policy 2
AND
...
AND
(
  <em class="replaceable"><code>выражение</code></em> from PERMISSIVE SELECT/ALL policy 1
  OR
  <em class="replaceable"><code>выражение</code></em> from PERMISSIVE SELECT/ALL policy 2
  OR
  ...
)
AND
<em class="replaceable"><code>выражение</code></em> from RESTRICTIVE UPDATE/ALL policy 1
AND
<em class="replaceable"><code>выражение</code></em> from RESTRICTIVE UPDATE/ALL policy 2
AND
...
AND
(
  <em class="replaceable"><code>выражение</code></em> from PERMISSIVE UPDATE/ALL policy 1
  OR
  <em class="replaceable"><code>выражение</code></em> from PERMISSIVE UPDATE/ALL policy 2
  OR
  ...
)</pre></div></div><div class="refsect1" id="id-1.9.3.75.7"><h2>Замечания</h2><p>Чтобы создать или изменить политики для таблицы, нужно быть её владельцем.</p><p>Хотя политики применяются к явно выполняемым запросам к таблицам БД, они не применяются, когда система выполняет внутренние проверки ссылочной целостности или проверяет ограничения. Это означает, что существуют косвенные пути проверить существование заданного значения. Например, можно попытаться вставить повторяющееся значение в столбец, образующий первичный ключ или имеющую ограничение уникальности. Если при этом произойдёт ошибка, пользователь может заключить, что это значение уже существует. (В данном случае предполагается, что политика разрешает пользователю вставлять записи, которые он может не видеть.) Подобный приём также возможен, если пользователь может вставлять записи в таблицу, которая ссылается на другую, иным образом не видимую. Существование значения можно определить, вставив его в подчинённую таблицу, при этом успешный результат операции будет признаком того, что это значение есть в главной таблице. Эти изъяны можно устранить, либо тщательно разработав политики, которые вовсе не позволят пользователям выполнять операции добавления, изменения и удаления, по результатам которых можно узнать о значениях в таблицах, не видимых иным образом, либо используя генерируемые значения (например, суррогатные ключи).</p><p>Вообще система будет применять фильтры, устанавливаемые политиками безопасности, до условий в запросах пользователя, чтобы предотвратить нежелательную утечку защищаемых данных через пользовательские функции, которые могут быть недоверенными. Однако функции и операторы, помеченные системой (или системным администратором) как <code class="literal">LEAKPROOF</code> (герметичные) могут вычисляться до условий политики, так как они считаются доверенными.</p><p>Так как выражения политики добавляются непосредственно в запрос пользователя, они выполняются с правами пользователя, запускающего исходный запрос. Таким образом, пользователи, на которых распространяется заданная политика, должны иметь права для обращения ко всем таблицам и функциям, задействованным в выражении, иначе им просто будет отказано в доступе при попытке обращения к целевой таблице (если для неё включена защита на уровне строк). Однако это не влияет на работу представлений — как и с обычными запросами и представлениями, проверки разрешений и политики для нижележащих таблиц представления будут выполняться с правами владельца представления, и при этом будут действовать политики, распространяющиеся на этого владельца, за исключением случаев, когда представление определяется с характеристикой <code class="literal">security_invoker</code> (см. <a class="link" href="sql-createview.html" title="CREATE VIEW"><code class="command">CREATE VIEW</code></a>).</p><p>Для <code class="command">MERGE</code> не существует отдельной политики. Когда выполняется <code class="command">MERGE</code>, в зависимости от фактически выполняемых действий применяются политики, определённые для <code class="command">SELECT</code>, <code class="command">INSERT</code>, <code class="command">UPDATE</code> и <code class="command">DELETE</code>.</p><p>Дополнительное описание и практические примеры можно найти в <a class="xref" href="ddl-rowsecurity.html" title="5.8. Политики защиты строк">Разделе 5.8</a>.</p></div><div class="refsect1" id="id-1.9.3.75.8"><h2>Совместимость</h2><p><code class="command">CREATE POLICY</code> является расширением <span class="productname">PostgreSQL</span>.</p></div><div class="refsect1" id="id-1.9.3.75.9"><h2>См. также</h2><span class="simplelist"><a class="xref" href="sql-alterpolicy.html" title="ALTER POLICY"><span class="refentrytitle">ALTER POLICY</span></a>, <a class="xref" href="sql-droppolicy.html" title="DROP POLICY"><span class="refentrytitle">DROP POLICY</span></a>, <a class="xref" href="sql-altertable.html" title="ALTER TABLE"><span class="refentrytitle">ALTER TABLE</span></a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-createopfamily.html" title="CREATE OPERATOR FAMILY">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-createprocedure.html" title="CREATE PROCEDURE">След.</a></td></tr><tr><td width="40%" align="left" valign="top">CREATE OPERATOR FAMILY </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> CREATE PROCEDURE</td></tr></table></div></body></html>