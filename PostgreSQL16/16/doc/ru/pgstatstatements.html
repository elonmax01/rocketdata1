<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>F.32. pg_stat_statements — отслеживание статистики планирования и выполнения SQL-операторов</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="pgrowlocks.html" title="F.31. pgrowlocks — отображение информации о блокировке строк таблицы" /><link rel="next" href="pgstattuple.html" title="F.33. pgstattuple — получение статистики на уровне кортежей" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">F.32. pg_stat_statements — отслеживание статистики планирования и выполнения SQL-операторов</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="pgrowlocks.html" title="F.31. pgrowlocks — отображение информации о блокировке строк таблицы">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="contrib.html" title="Приложение F. Дополнительно поставляемые модули и расширения">Наверх</a></td><th width="60%" align="center">Приложение F. Дополнительно поставляемые модули и расширения</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="pgstattuple.html" title="F.33. pgstattuple — получение статистики на уровне кортежей">След.</a></td></tr></table><hr /></div><div class="sect1" id="PGSTATSTATEMENTS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">F.32. pg_stat_statements — отслеживание статистики планирования и выполнения SQL-операторов <a href="#PGSTATSTATEMENTS" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="pgstatstatements.html#PGSTATSTATEMENTS-PG-STAT-STATEMENTS">F.32.1. Представление <code class="structname">pg_stat_statements</code></a></span></dt><dt><span class="sect2"><a href="pgstatstatements.html#PGSTATSTATEMENTS-PG-STAT-STATEMENTS-INFO">F.32.2. Представление <code class="structname">pg_stat_statements_info</code></a></span></dt><dt><span class="sect2"><a href="pgstatstatements.html#PGSTATSTATEMENTS-FUNCS">F.32.3. Функции</a></span></dt><dt><span class="sect2"><a href="pgstatstatements.html#PGSTATSTATEMENTS-CONFIG-PARAMS">F.32.4. Параметры конфигурации</a></span></dt><dt><span class="sect2"><a href="pgstatstatements.html#PGSTATSTATEMENTS-SAMPLE-OUTPUT">F.32.5. Пример вывода</a></span></dt><dt><span class="sect2"><a href="pgstatstatements.html#PGSTATSTATEMENTS-AUTHORS">F.32.6. Авторы</a></span></dt></dl></div><a id="id-1.11.7.42.2" class="indexterm"></a><p>Модуль <code class="filename">pg_stat_statements</code> предоставляет возможность отслеживать статистику планирования и выполнения сервером всех операторов SQL.</p><p>Этот модуль нужно загружать, добавив <code class="literal">pg_stat_statements</code> в <a class="xref" href="runtime-config-client.html#GUC-SHARED-PRELOAD-LIBRARIES">shared_preload_libraries</a> в файле <code class="filename">postgresql.conf</code>, так как ему требуется дополнительная разделяемая память. Это значит, что для загрузки или выгрузки модуля необходимо перезапустить сервер. Кроме того, для функционирования этого модуля должны вычисляться идентификаторы запросов, что происходит автоматически, когда для параметра <a class="xref" href="runtime-config-statistics.html#GUC-COMPUTE-QUERY-ID">compute_query_id</a> задаётся значение <code class="literal">auto</code> или <code class="literal">on</code> или же загружается сторонний модуль, вычисляющий идентификаторы запросов.</p><p>Когда модуль <code class="filename">pg_stat_statements</code> активен, он отслеживает статистику по всем базам данных на сервере. Для получения и обработки этой статистики модуль <code class="filename">pg_stat_statements</code> предоставляет представления <code class="structname">pg_stat_statements</code> и <code class="structname">pg_stat_statements_info</code>, а также вспомогательные функции <code class="function">pg_stat_statements_reset</code> и <code class="function">pg_stat_statements</code>. Эти объекты не доступны глобально, но их можно установить в определённой базе данных, выполнив команду <code class="command">CREATE EXTENSION pg_stat_statements</code>.</p><div class="sect2" id="PGSTATSTATEMENTS-PG-STAT-STATEMENTS"><div class="titlepage"><div><div><h3 class="title">F.32.1. Представление <code class="structname">pg_stat_statements</code> <a href="#PGSTATSTATEMENTS-PG-STAT-STATEMENTS" class="id_link">#</a></h3></div></div></div><p>Статистика, собираемая модулем, выдаётся через представление с именем <code class="structname">pg_stat_statements</code>. Это представление содержит отдельные строки для каждой комбинации идентификатора базы данных, идентификатора пользователя, идентификатора запроса и признака верхнего уровня (но в количестве, не превышающем максимальное число различных операторов, которые может отслеживать модуль). Столбцы представления показаны в <a class="xref" href="pgstatstatements.html#PGSTATSTATEMENTS-COLUMNS" title="Таблица F.22. Столбцы pg_stat_statements">Таблице F.22</a>.</p><div class="table" id="PGSTATSTATEMENTS-COLUMNS"><p class="title"><strong>Таблица F.22. Столбцы <code class="structname">pg_stat_statements</code></strong></p><div class="table-contents"><table class="table" summary="Столбцы pg_stat_statements" border="1"><colgroup><col /></colgroup><thead><tr><th class="catalog_table_entry"><p class="column_definition">Тип столбца</p>
      <p>Описание</p></th></tr></thead><tbody><tr><td class="catalog_table_entry"><p class="column_definition"><code class="structfield">userid</code> <code class="type">oid</code> (ссылается на <a class="link" href="catalog-pg-authid.html" title="53.8. pg_authid"><code class="structname">pg_authid</code></a>.<code class="structfield">oid</code>)</p>
      <p>OID пользователя, выполнявшего оператор</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition"><code class="structfield">dbid</code> <code class="type">oid</code> (ссылается на <a class="link" href="catalog-pg-database.html" title="53.15. pg_database"><code class="structname">pg_database</code></a>.<code class="structfield">oid</code>)</p>
      <p>OID базы данных, в которой выполнялся оператор</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">toplevel</code> <code class="type">bool</code>
      </p>
      <p>True, если данный запрос выполнялся на верхнем уровне (всегда true, если для параметра <code class="varname">pg_stat_statements.track</code> задано значение <code class="literal">top</code>)</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">queryid</code> <code class="type">bigint</code>
      </p>
      <p>Хеш-код для выявления одинаковых нормализованных запросов</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">query</code> <code class="type">text</code>
      </p>
      <p>Текст, представляющий оператор</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">plans</code> <code class="type">bigint</code>
      </p>
      <p>Число операций планирования этого оператора (если включён параметр <code class="varname">pg_stat_statements.track_planning</code>, иначе 0)</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">total_plan_time</code> <code class="type">double precision</code>
      </p>
      <p>Общее время, затраченное на планирование этого оператора в миллисекундах (если включён параметр <code class="varname">pg_stat_statements.track_planning</code>, иначе 0)</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">min_plan_time</code> <code class="type">double precision</code>
      </p>
      <p>Минимальное время, затраченное на планирование этого оператора в миллисекундах (если включён параметр <code class="varname">pg_stat_statements.track_planning</code>, иначе 0)</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">max_plan_time</code> <code class="type">double precision</code>
      </p>
      <p>Максимальное время, затраченное на планирование этого оператора в миллисекундах (если включён параметр <code class="varname">pg_stat_statements.track_planning</code>, иначе 0)</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">mean_plan_time</code> <code class="type">double precision</code>
      </p>
      <p>Среднее время, затраченное на планирование этого оператора в миллисекундах (если включён параметр <code class="varname">pg_stat_statements.track_planning</code>, иначе 0)</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">stddev_plan_time</code> <code class="type">double precision</code>
      </p>
      <p>Стандартное отклонение времени, затраченного на планирование этого оператора в миллисекундах (если включён параметр <code class="varname">pg_stat_statements.track_planning</code>, иначе 0)</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">calls</code> <code class="type">bigint</code>
      </p>
      <p>Число выполнений</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">total_exec_time</code> <code class="type">double precision</code>
      </p>
      <p>Общее время, затраченное на выполнение оператора, в миллисекундах</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">min_exec_time</code> <code class="type">double precision</code>
      </p>
      <p>Минимальное время, затраченное на выполнение оператора, в миллисекундах</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">max_exec_time</code> <code class="type">double precision</code>
      </p>
      <p>Максимальное время, затраченное на выполнение оператора, в миллисекундах</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">mean_exec_time</code> <code class="type">double precision</code>
      </p>
      <p>Среднее время, затраченное на выполнение оператора, в миллисекундах</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">stddev_exec_time</code> <code class="type">double precision</code>
      </p>
      <p>Стандартное отклонение времени, затраченного на выполнение оператора, в миллисекундах</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">rows</code> <code class="type">bigint</code>
      </p>
      <p>Общее число строк, полученных или затронутых оператором</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">shared_blks_hit</code> <code class="type">bigint</code>
      </p>
      <p>Общее число попаданий разделяемых блоков в кеш для данного оператора</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">shared_blks_read</code> <code class="type">bigint</code>
      </p>
      <p>Общее число разделяемых блоков, прочитанных данным оператором</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">shared_blks_dirtied</code> <code class="type">bigint</code>
      </p>
      <p>Общее число разделяемых блоков, «загрязнённых» данным оператором</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">shared_blks_written</code> <code class="type">bigint</code>
      </p>
      <p>Общее число разделяемых блоков, записанных данным оператором</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">local_blks_hit</code> <code class="type">bigint</code>
      </p>
      <p>Общее число попаданий локальных блоков в кеш для данного оператора</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">local_blks_read</code> <code class="type">bigint</code>
      </p>
      <p>Общее число локальных блоков, прочитанных данным оператором</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">local_blks_dirtied</code> <code class="type">bigint</code>
      </p>
      <p>Общее число локальных блоков, «загрязнённых» данным оператором</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">local_blks_written</code> <code class="type">bigint</code>
      </p>
      <p>Общее число локальных блоков, записанных данным оператором</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">temp_blks_read</code> <code class="type">bigint</code>
      </p>
      <p>Общее число временных блоков, прочитанных данным оператором</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">temp_blks_written</code> <code class="type">bigint</code>
      </p>
      <p>Общее число временных блоков, записанных данным оператором</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">blk_read_time</code> <code class="type">double precision</code>
      </p>
      <p>Общее время, затраченное оператором на чтение блоков файлов данных, в миллисекундах (если включён <a class="xref" href="runtime-config-statistics.html#GUC-TRACK-IO-TIMING">track_io_timing</a>, или ноль в противном случае)</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">blk_write_time</code> <code class="type">double precision</code>
      </p>
      <p>Общее время, затраченное оператором на запись блоков файлов данных, в миллисекундах (если включён <a class="xref" href="runtime-config-statistics.html#GUC-TRACK-IO-TIMING">track_io_timing</a>, или ноль в противном случае)</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">temp_blk_read_time</code> <code class="type">double precision</code>
      </p>
      <p>Общее время, затраченное оператором на чтение блоков временных файлов, в миллисекундах (если включён <a class="xref" href="runtime-config-statistics.html#GUC-TRACK-IO-TIMING">track_io_timing</a>, или ноль в противном случае)</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">temp_blk_write_time</code> <code class="type">double precision</code>
      </p>
      <p>Общее время, затраченное оператором на запись блоков временных файлов, в миллисекундах (если включён <a class="xref" href="runtime-config-statistics.html#GUC-TRACK-IO-TIMING">track_io_timing</a>, или ноль в противном случае)</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">wal_records</code> <code class="type">bigint</code>
      </p>
      <p>Общее число записей WAL, сгенерированных при выполнении оператора</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">wal_fpi</code> <code class="type">bigint</code>
      </p>
      <p>Общее число образов полных страниц в WAL, сгенерированных при выполнении оператора</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">wal_bytes</code> <code class="type">numeric</code>
      </p>
      <p>Общий объём WAL, сгенерированный при выполнении оператора, в байтах</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">jit_functions</code> <code class="type">bigint</code>
      </p>
      <p>Общее число функций, скомпилированных в JIT-код при выполнении данного оператора</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">jit_generation_time</code> <code class="type">double precision</code>
      </p>
      <p>Общее время, затрачено на компиляцию JIT-кода при выполнении оператора, в миллисекундах</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">jit_inlining_count</code> <code class="type">bigint</code>
      </p>
      <p>Сколько раз встраивались функции</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">jit_inlining_time</code> <code class="type">double precision</code>
      </p>
      <p>Общее время, затраченное на встраивание функций при выполнении оператора, в миллисекундах</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">jit_optimization_count</code> <code class="type">bigint</code>
      </p>
      <p>Число JIT-оптимизаций для данного оператора</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">jit_optimization_time</code> <code class="type">double precision</code>
      </p>
      <p>Общее время, затраченное на JIT-оптимизацию при выполнении оператора, в миллисекундах</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">jit_emission_count</code> <code class="type">bigint</code>
      </p>
      <p>Сколько раз выдавался код</p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">jit_emission_time</code> <code class="type">double precision</code>
      </p>
      <p>Общее время, затраченное на выдачу кода при выполнении оператора, в миллисекундах</p></td></tr></tbody></table></div></div><br class="table-break" /><p>По соображениям безопасности только суперпользователям и ролям с правами роли <code class="literal">pg_read_all_stats</code> разрешено видеть текст SQL и <code class="structfield">queryid</code> запросов, выполняемых другими пользователями. Однако другие пользователи могут видеть статистику, если это представление установлено в их базу данных.</p><p>Планируемые запросы (то есть <code class="command">SELECT</code>, <code class="command">INSERT</code>, <code class="command">UPDATE</code>, <code class="command">DELETE</code>, <code class="command">MERGE</code>) и служебные команды объединяются в одну запись в <code class="structname">pg_stat_statements</code>, когда они имеют идентичные структуры запросов согласно внутреннему вычисленному хешу. Обычно два запроса будут считаться равными при таком сравнении, если они семантически равнозначны, не считая значений констант, фигурирующих в запросе.</p><div class="note"><h3 class="title">Примечание</h3><p>Нижеприведённые соображения о замене констант и <code class="structfield">queryid</code> применимы, только если включён <a class="xref" href="runtime-config-statistics.html#GUC-COMPUTE-QUERY-ID">compute_query_id</a>. Если же для вычисления <code class="structfield">queryid</code> вы используете встроенный модуль, обратитесь к его документации.</p></div><p>Когда значение константы игнорируется в целях сравнения запроса с другими запросами, эта константа заменяется в выводе <code class="structname">pg_stat_statements</code> обозначением параметра, например, <code class="literal">$1</code>. В остальном этот вывод содержит текст первого запроса, хеш которого равнялся значению <code class="structfield">queryid</code>, связанному с записью в <code class="structname">pg_stat_statements</code>.</p><p>В <code class="structname">pg_stat_statements</code> запросы, для которых может быть применена нормализация, могут отображаться со значениями констант, особенно при большом числе отбрасываемых записей. Чтобы снизить вероятность отбрасывания записей, можно задать более высокое значение параметра <code class="varname">pg_stat_statements.max</code>. Представление <code class="structname">pg_stat_statements_info</code>, описанное ниже в разделе <a class="xref" href="pgstatstatements.html#PGSTATSTATEMENTS-PG-STAT-STATEMENTS-INFO" title="F.32.2. Представление pg_stat_statements_info">Подраздел F.32.2</a>, предоставляет статистику об отброшенных записях.</p><p>В некоторых случаях запросы с визуально различными текстами могут быть объединены в одну запись <code class="structname">pg_stat_statements</code>. Обычно это происходит только для семантически равнозначных запросов, но есть небольшая вероятность, что из-за наложений хеша несвязанные запросы могут оказаться объединёнными в одной записи. (Однако это невозможно для запросов, принадлежащих разным пользователям баз данных.)</p><p>Так как значение хеша <code class="structfield">queryid</code> вычисляется по представлениям запроса на стадии после разбора, возможна и обратная ситуация: запросы с одинаковым текстом могут оказаться в разных записях, если они получили различные представления по разным причинам, например, из-за изменения <code class="varname">search_path</code>.</p><p>Потребители статистики <code class="structname">pg_stat_statements</code> могут пожелать использовать в качестве более стабильного и надёжного идентификатора для каждой записи не текст запроса, а <code class="structfield">queryid</code> (возможно, в сочетании с <code class="structfield">dbid</code> и <code class="structfield">userid</code>). Однако важно понимать, что стабильность значения хеша <code class="structfield">queryid</code> гарантируется с ограничениями. Так как этот идентификатор получается из дерева запроса после анализа, его значение будет, помимо прочего, зависеть от внутренних идентификаторов объектов, фигурирующих в этом представлении. С этим связано несколько неинтуитивных следствий. Например, <code class="filename">pg_stat_statements</code> будет считать два одинаково выглядящих запроса разными, если они обращаются к таблице, которая была удалена, а затем воссоздана между этими запросами. Результат хеширования также чувствителен к различиям в машинной архитектуре и другим особенностям платформы. Более того, не стоит рассчитывать на то, что <code class="structfield">queryid</code> будет оставаться неизменным при обновлении основных версий <span class="productname">PostgreSQL</span>.</p><p>Можно ожидать, что два сервера, участвующие в репликации на основе воспроизведения физического WAL, будут иметь одинаковые <code class="structfield">queryid</code> для одного запроса. Однако схемы с логической репликацией не гарантируют сохранения идентичности реплик во всех имеющих значение деталях, так что <code class="structfield">queryid</code> не будет полезным идентификатором для накопления показателей стоимости по набору логических реплик. В случае сомнений в том или ином подходе рекомендуется непосредственно протестировать его.</p><p>Как правило, можно предположить, что значения <code class="structfield">queryid</code> не меняются между корректирующими релизами <span class="productname">PostgreSQL</span> при условии, что экземпляры работают на одной и той же архитектуре и детали метаданных каталога совпадают. Совместимость между корректирующими релизами может быть нарушена только в крайнем случае.</p><p>Обозначения параметров, применяемые для замены констант в представляющем запросы тексте, нумеруются, начиная со следующего за последним параметром <code class="literal">$</code><em class="replaceable"><code>n</code></em> в исходном тексте запроса, или с <code class="literal">$1</code> в отсутствие параметров в нём. Стоит отметить, что в некоторых случаях на эту нумерацию могут влиять скрытые символы параметров. Например, <span class="application">PL/pgSQL</span> применяет такие символы для добавления в запросы значений локальных переменных функций, так что оператор <span class="application">PL/pgSQL</span> вида <code class="literal">SELECT i + 1 INTO j</code> будет представлен в тексте как <code class="literal">SELECT i + $2</code>.</p><p>Текст, представляющий запрос, сохраняется во внешнем файле на диске и не занимает разделяемую память. Поэтому даже очень объёмный текст запроса может быть сохранён успешно. Однако если в файле накапливается много длинных текстов запросов, он может вырасти до неудобоваримого размера. В качестве решения этой проблемы, <code class="filename">pg_stat_statements</code> может решить стереть текст запросов, и в результате во всех существующих записях в представлении <code class="structname">pg_stat_statements</code> в поле <code class="structfield">query</code> окажутся значения NULL, хотя статистика, связанная с каждым <code class="structfield">queryid</code> будет сохранена. Если это происходит и мешает анализу, возможно, стоит уменьшить <code class="varname">pg_stat_statements.max</code> для предотвращения таких ситуаций.</p><p>Показатели <code class="structfield">plans</code> и <code class="structfield">calls</code> не обязательно должны совпадать, так как статистика планирования и выполнения обновляется в конце соответствующей фазы и только при успешном завершении этой фазы. Например, если для оператора успешно выполнилось планирование, но во время выполнения произошла ошибка, изменится только статистика планирования. Если же планирование пропускается по причине использования кешированного плана, увеличивается только счётчик выполнения.</p></div><div class="sect2" id="PGSTATSTATEMENTS-PG-STAT-STATEMENTS-INFO"><div class="titlepage"><div><div><h3 class="title">F.32.2. Представление <code class="structname">pg_stat_statements_info</code> <a href="#PGSTATSTATEMENTS-PG-STAT-STATEMENTS-INFO" class="id_link">#</a></h3></div></div></div><a id="id-1.11.7.42.7.2" class="indexterm"></a><p>Статистика самого модуля <code class="filename">pg_stat_statements</code> собирается и выдаётся через представление с именем <code class="structname">pg_stat_statements_info</code>. Это представление содержит только одну строку. Столбцы представления показаны в <a class="xref" href="pgstatstatements.html#PGSTATSTATEMENTSINFO-COLUMNS" title="Таблица F.23. Столбцы pg_stat_statements_info">Таблице F.23</a>.</p><div class="table" id="PGSTATSTATEMENTSINFO-COLUMNS"><p class="title"><strong>Таблица F.23. Столбцы <code class="structname">pg_stat_statements_info</code></strong></p><div class="table-contents"><table class="table" summary="Столбцы pg_stat_statements_info" border="1"><colgroup><col /></colgroup><thead><tr><th class="catalog_table_entry"><p class="column_definition">Тип столбца</p>
      <p>Описание</p></th></tr></thead><tbody><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">dealloc</code> <code class="type">bigint</code>
      </p>
      <p>Сколько всего раз в <code class="structname">pg_stat_statements</code> отбрасывались записи о редко выполняемых операторах, поскольку на обработку поступало больше различных операторов, чем задано в <code class="varname">pg_stat_statements.max</code></p></td></tr><tr><td class="catalog_table_entry"><p class="column_definition">
       <code class="structfield">stats_reset</code> <code class="type">timestamp with time zone</code>
      </p>
      <p>Время последнего сброса всех статистических данных в представлении <code class="structname">pg_stat_statements</code>.</p></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect2" id="PGSTATSTATEMENTS-FUNCS"><div class="titlepage"><div><div><h3 class="title">F.32.3. Функции <a href="#PGSTATSTATEMENTS-FUNCS" class="id_link">#</a></h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">
     <code class="function">pg_stat_statements_reset(userid Oid, dbid Oid, queryid bigint) returns void</code>
     <a id="id-1.11.7.42.8.2.1.1.2" class="indexterm"></a>
    </span></dt><dd><p>Функция <code class="function">pg_stat_statements_reset</code> очищает всю статистику, собранную к этому времени модулем <code class="filename">pg_stat_statements</code> для заданного пользователя (<code class="structfield">userid</code>), базы данных (<code class="structfield">dbid</code>) и запроса (<code class="structfield">queryid</code>). В случае отсутствия одного из параметров для него подразумевается нулевое значение (неприменимое ограничение) и очищается статистика, соответствующая другим параметрам. Если никакой параметр не задан или все параметры имеют нулевое значение (неприменимое), очищается вся статистика. Вместе с очисткой всей статистики в <code class="structname">pg_stat_statements</code> также сбрасывается статистика в <code class="structname">pg_stat_statements_info</code>. По умолчанию эту функцию могут выполнять только суперпользователи. Другим пользователям можно дать доступ к ней, используя <code class="command">GRANT</code>.</p></dd><dt><span class="term">
     <code class="function">pg_stat_statements(showtext boolean) returns setof record</code>
     <a id="id-1.11.7.42.8.2.2.1.2" class="indexterm"></a>
    </span></dt><dd><p>Представление <code class="structname">pg_stat_statements</code> реализовано на базе функции, которая тоже называется <code class="function">pg_stat_statements</code>. Клиенты могут вызывать функцию <code class="function">pg_stat_statements</code> непосредственно, и могут указать <code class="literal">showtext := false</code> и получить результат без текста запроса (то есть, выходной аргумент (<code class="literal">OUT</code>), соответствующий столбцу представления <code class="structfield">query</code>, будет содержать NULL). Эта возможность предназначена для поддержки внешних инструментов, для которых желательно избежать издержек, связанных с получением текстов запросов неопределённой длины. Такие инструменты могут кешировать текст первого запроса, который они получат самостоятельно, как это и делает <code class="filename">pg_stat_statements</code>, а затем запрашивать тексты запросов только при необходимости. Так как сервер сохраняет тексты запросов в файле, этот подход сокращает объём физического ввода/вывода, порождаемого при постоянном обращении к данным <code class="structname">pg_stat_statements</code>.</p></dd></dl></div></div><div class="sect2" id="PGSTATSTATEMENTS-CONFIG-PARAMS"><div class="titlepage"><div><div><h3 class="title">F.32.4. Параметры конфигурации <a href="#PGSTATSTATEMENTS-CONFIG-PARAMS" class="id_link">#</a></h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="varname">pg_stat_statements.max</code> (<code class="type">integer</code>) <a id="id-1.11.7.42.9.2.1.1.3" class="indexterm"></a></span></dt><dd><p>Параметр <code class="varname">pg_stat_statements.max</code> задаёт максимальное число операторов, отслеживаемых модулем (то есть, максимальное число строк в представлении <code class="structname">pg_stat_statements</code>). Когда на обработку поступает больше, чем заданное число различных операторов, информация о редко выполняемых операторах отбрасывается. В представлении <code class="structname">pg_stat_statements_info</code> можно увидеть, сколько раз это происходило. Значение по умолчанию — 5000. Этот параметр можно задать только при запуске сервера.</p></dd><dt><span class="term"><code class="varname">pg_stat_statements.track</code> (<code class="type">enum</code>) <a id="id-1.11.7.42.9.2.2.1.3" class="indexterm"></a></span></dt><dd><p>Параметр <code class="varname">pg_stat_statements.track</code> определяет, какие операторы будут отслеживаться модулем. Со значением <code class="literal">top</code> отслеживаются операторы верхнего уровня (те, что непосредственно выполняются клиентами), со значением <code class="literal">all</code> также отслеживаются вложенные операторы (например, операторы, вызываемые внутри функций), а значение <code class="literal">none</code> полностью отключает сбор статистики по операторам. Значение по умолчанию — <code class="literal">top</code>. Изменять этот параметр могут только суперпользователи.</p></dd><dt><span class="term"><code class="varname">pg_stat_statements.track_utility</code> (<code class="type">boolean</code>) <a id="id-1.11.7.42.9.2.3.1.3" class="indexterm"></a></span></dt><dd><p>Параметр <code class="varname">pg_stat_statements.track_utility</code> определяет, будет ли этот модуль отслеживать служебные команды. Служебными командами считаются команды, отличные от <code class="command">SELECT</code>, <code class="command">INSERT</code>, <code class="command">UPDATE</code>, <code class="command">DELETE</code> и <code class="command">MERGE</code>. Значение по умолчанию — <code class="literal">on</code> (вкл.). Изменить этот параметр могут только суперпользователи.</p></dd><dt><span class="term"><code class="varname">pg_stat_statements.track_planning</code> (<code class="type">boolean</code>) <a id="id-1.11.7.42.9.2.4.1.3" class="indexterm"></a></span></dt><dd><p>Параметр <code class="varname">pg_stat_statements.track_planning</code> определяет, будет ли этот модуль отслеживать операции планирования и их длительность. Включение этого параметра может привести к заметному снижению производительности, особенно когда во множестве одновременных сеансов выполняются операторы с одинаковой структурой запросов, в результате чего эти сеансы пытаются одновременно изменить одни и те же записи в <code class="structname">pg_stat_statements</code>. Значение по умолчанию — <code class="literal">off</code> (выкл.). Изменить этот параметр могут только суперпользователи.</p></dd><dt><span class="term"><code class="varname">pg_stat_statements.save</code> (<code class="type">boolean</code>) <a id="id-1.11.7.42.9.2.5.1.3" class="indexterm"></a></span></dt><dd><p>Параметр <code class="varname">pg_stat_statements.save</code> определяет, должна ли статистика операторов сохраняться после перезагрузки сервера. Если он отключён (имеет значение <code class="literal">off</code>), статистика не сохраняется при остановке сервера и не перезагружается при запуске. Значение по умолчанию — <code class="literal">on</code> (вкл.). Этот параметр можно задать только в <code class="filename">postgresql.conf</code> или в командной строке сервера.</p></dd></dl></div><p>Этому модулю требуется дополнительная разделяемая память в объёме, пропорциональном <code class="varname">pg_stat_statements.max</code>. Заметьте, что эта память будет занята при загрузке модуля, даже если <code class="varname">pg_stat_statements.track</code> имеет значение <code class="literal">none</code>.</p><p>Эти параметры должны задаваться в <code class="filename">postgresql.conf</code>. Обычное использование выглядит так: </p><pre class="programlisting"># postgresql.conf
shared_preload_libraries = 'pg_stat_statements'

compute_query_id = on
pg_stat_statements.max = 10000
pg_stat_statements.track = all</pre></div><div class="sect2" id="PGSTATSTATEMENTS-SAMPLE-OUTPUT"><div class="titlepage"><div><div><h3 class="title">F.32.5. Пример вывода <a href="#PGSTATSTATEMENTS-SAMPLE-OUTPUT" class="id_link">#</a></h3></div></div></div><pre class="screen">bench=# SELECT pg_stat_statements_reset();

$ pgbench -i bench
$ pgbench -c10 -t300 bench

bench=# \x
bench=# SELECT query, calls, total_exec_time, rows, 100.0 * shared_blks_hit /
               nullif(shared_blks_hit + shared_blks_read, 0) AS hit_percent
          FROM pg_stat_statements ORDER BY total_exec_time DESC LIMIT 5;
-[ RECORD 1 ]---+--------------------------------------------------​------------------
query           | UPDATE pgbench_branches SET bbalance = bbalance + $1 WHERE bid = $2
calls           | 3000
total_exec_time | 25565.855387
rows            | 3000
hit_percent     | 100.0000000000000000
-[ RECORD 2 ]---+--------------------------------------------------​------------------
query           | UPDATE pgbench_tellers SET tbalance = tbalance + $1 WHERE tid = $2
calls           | 3000
total_exec_time | 20756.669379
rows            | 3000
hit_percent     | 100.0000000000000000
-[ RECORD 3 ]---+--------------------------------------------------​------------------
query           | copy pgbench_accounts from stdin
calls           | 1
total_exec_time | 291.865911
rows            | 100000
hit_percent     | 100.0000000000000000
-[ RECORD 4 ]---+--------------------------------------------------​------------------
query           | UPDATE pgbench_accounts SET abalance = abalance + $1 WHERE aid = $2
calls           | 3000
total_exec_time | 271.232977
rows            | 3000
hit_percent     | 98.8454011741682975
-[ RECORD 5 ]---+--------------------------------------------------​------------------
query           | alter table pgbench_accounts add primary key (aid)
calls           | 1
total_exec_time | 160.588563
rows            | 0
hit_percent     | 100.0000000000000000


bench=# SELECT pg_stat_statements_reset(0,0,s.queryid) FROM pg_stat_statements AS s
            WHERE s.query = 'UPDATE pgbench_branches SET bbalance = bbalance + $1 WHERE bid = $2';

bench=# SELECT query, calls, total_exec_time, rows, 100.0 * shared_blks_hit /
               nullif(shared_blks_hit + shared_blks_read, 0) AS hit_percent
          FROM pg_stat_statements ORDER BY total_exec_time DESC LIMIT 5;
-[ RECORD 1 ]---+--------------------------------------------------​------------------
query           | UPDATE pgbench_tellers SET tbalance = tbalance + $1 WHERE tid = $2
calls           | 3000
total_exec_time | 20756.669379
rows            | 3000
hit_percent     | 100.0000000000000000
-[ RECORD 2 ]---+--------------------------------------------------​------------------
query           | copy pgbench_accounts from stdin
calls           | 1
total_exec_time | 291.865911
rows            | 100000
hit_percent     | 100.0000000000000000
-[ RECORD 3 ]---+--------------------------------------------------​------------------
query           | UPDATE pgbench_accounts SET abalance = abalance + $1 WHERE aid = $2
calls           | 3000
total_exec_time | 271.232977
rows            | 3000
hit_percent     | 98.8454011741682975
-[ RECORD 4 ]---+--------------------------------------------------​------------------
query           | alter table pgbench_accounts add primary key (aid)
calls           | 1
total_exec_time | 160.588563
rows            | 0
hit_percent     | 100.0000000000000000
-[ RECORD 5 ]---+--------------------------------------------------​------------------
query           | vacuum analyze pgbench_accounts
calls           | 1
total_exec_time | 136.448116
rows            | 0
hit_percent     | 99.9201915403032721

bench=# SELECT pg_stat_statements_reset(0,0,0);

bench=# SELECT query, calls, total_exec_time, rows, 100.0 * shared_blks_hit /
               nullif(shared_blks_hit + shared_blks_read, 0) AS hit_percent
          FROM pg_stat_statements ORDER BY total_exec_time DESC LIMIT 5;
-[ RECORD 1 ]---+--------------------------------------------------​---------------------------
query           | SELECT pg_stat_statements_reset(0,0,0)
calls           | 1
total_exec_time | 0.189497
rows            | 1
hit_percent     |
-[ RECORD 2 ]---+--------------------------------------------------​---------------------------
query           | SELECT query, calls, total_exec_time, rows, $1 * shared_blks_hit /          +
                |                nullif(shared_blks_hit + shared_blks_read, $2) AS hit_percent+
                |           FROM pg_stat_statements ORDER BY total_exec_time DESC LIMIT $3
calls           | 0
total_exec_time | 0
rows            | 0
hit_percent     |</pre></div><div class="sect2" id="PGSTATSTATEMENTS-AUTHORS"><div class="titlepage"><div><div><h3 class="title">F.32.6. Авторы <a href="#PGSTATSTATEMENTS-AUTHORS" class="id_link">#</a></h3></div></div></div><p>Такахиро Итагаки <code class="email">&lt;<a class="email" href="mailto:itagaki.takahiro@oss.ntt.co.jp">itagaki.takahiro@oss.ntt.co.jp</a>&gt;</code>. Нормализацию запросов добавил Питер Гейган <code class="email">&lt;<a class="email" href="mailto:peter@2ndquadrant.com">peter@2ndquadrant.com</a>&gt;</code>.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="pgrowlocks.html" title="F.31. pgrowlocks — отображение информации о блокировке строк таблицы">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="contrib.html" title="Приложение F. Дополнительно поставляемые модули и расширения">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="pgstattuple.html" title="F.33. pgstattuple — получение статистики на уровне кортежей">След.</a></td></tr><tr><td width="40%" align="left" valign="top">F.31. pgrowlocks — отображение информации о блокировке строк таблицы </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> F.33. pgstattuple — получение статистики на уровне кортежей</td></tr></table></div></body></html>