<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>34.19. Поддержка SSL</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="libpq-ldap.html" title="34.18. Получение параметров соединения через LDAP" /><link rel="next" href="libpq-threading.html" title="34.20. Поведение в многопоточных программах" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">34.19. Поддержка SSL</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="libpq-ldap.html" title="34.18. Получение параметров соединения через LDAP">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="libpq.html" title="Глава 34. libpq — библиотека для языка C">Наверх</a></td><th width="60%" align="center">Глава 34. <span class="application">libpq</span> — библиотека для языка C</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="libpq-threading.html" title="34.20. Поведение в многопоточных программах">След.</a></td></tr></table><hr /></div><div class="sect1" id="LIBPQ-SSL"><div class="titlepage"><div><div><h2 class="title" style="clear: both">34.19. Поддержка SSL <a href="#LIBPQ-SSL" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="libpq-ssl.html#LIBQ-SSL-CERTIFICATES">34.19.1. Проверка сертификатов сервера на стороне клиента</a></span></dt><dt><span class="sect2"><a href="libpq-ssl.html#LIBPQ-SSL-CLIENTCERT">34.19.2. Клиентские сертификаты</a></span></dt><dt><span class="sect2"><a href="libpq-ssl.html#LIBPQ-SSL-PROTECTION">34.19.3. Защита, обеспечиваемая в различных режимах</a></span></dt><dt><span class="sect2"><a href="libpq-ssl.html#LIBPQ-SSL-FILEUSAGE">34.19.4. Файлы, используемые клиентом SSL</a></span></dt><dt><span class="sect2"><a href="libpq-ssl.html#LIBPQ-SSL-INITIALIZE">34.19.5. Инициализация библиотеки SSL</a></span></dt></dl></div><a id="id-1.7.3.26.2" class="indexterm"></a><p><span class="productname">PostgreSQL</span> реализует собственную поддержку <acronym class="acronym">SSL</acronym>-подключений, используя протоколы <acronym class="acronym">TLS</acronym>, для шифрования клиент-серверного взаимодействия в качестве меры безопасности. Подробнее функциональность <acronym class="acronym">SSL</acronym> на стороне сервера описывается в <a class="xref" href="ssl-tcp.html" title="19.9. Защита соединений TCP/IP с применением SSL">Разделе 19.9</a>.</p><p>Библиотека <span class="application">libpq</span> читает системный файл конфигурации <span class="productname">OpenSSL</span>. По умолчанию этот файл называется <code class="filename">openssl.cnf</code> и находится в каталоге, который сообщает команда <code class="literal">openssl version -d</code>. Если требуется указать другое расположение файла конфигурации, его можно задать в переменной окружения <code class="envar">OPENSSL_CONF</code>.</p><div class="sect2" id="LIBQ-SSL-CERTIFICATES"><div class="titlepage"><div><div><h3 class="title">34.19.1. Проверка сертификатов сервера на стороне клиента <a href="#LIBQ-SSL-CERTIFICATES" class="id_link">#</a></h3></div></div></div><p>По умолчанию <span class="productname">PostgreSQL</span> не выполняет никакие проверки сертификата сервера. Это означает, что клиента можно ввести в заблуждение, подменив сервер (например, изменив запись в DNS или заняв его IP-адрес). Чтобы защититься от такой подмены, клиент должен иметь возможность проверять подлинность сервера по цепочке доверия. Для создания цепочки доверия нужно установить корневой (самоподписанный) сертификат центра сертификации (<acronym class="acronym">ЦС</acronym>) на одном компьютере, а конечный сертификат, <span class="emphasis"><em>подписанный</em></span> корневым, на другом. В цепочке может использоваться и <span class="quote">«<span class="quote">промежуточный</span>»</span> сертификат, который подписывается корневым сертификатом и подписывает подчинённые сертификаты.</p><p>Чтобы клиент мог проверить подлинность сервера, установите на клиенте корневой сертификат, а на сервере установите конечный сертификат, подписанный этим корневым. Чтобы сервер мог проверить подлинность клиента, установите на сервере корневой сертификат, а на клиенте конечный сертификат, подписанный данным корневым. Конечный сертификат также может связываться с корневым через один или несколько промежуточных сертификатов (они обычно хранятся вместе с конечным сертификатом).</p><p>Когда цепочка доверия присутствует, клиент может проверить конечный сертификат, переданный сервером, двумя способами. Если параметр <code class="literal">sslmode</code> имеет значение <code class="literal">verify-ca</code>, libpq будет проверять подлинность сервера, проверяя цепочку доверия до корневого сертификата, установленного на клиенте. Если в <code class="literal">sslmode</code> выбран режим <code class="literal">verify-full</code>, libpq будет <span class="emphasis"><em>также</em></span> проверять соответствие имени узла сервера имени, записанному в сертификате. SSL-подключение не будет установлено, если проверить сертификат сервера не удастся. Режим <code class="literal">verify-full</code> рекомендуется для большинства окружений, где важна безопасность.</p><p>В режиме <code class="literal">verify-full</code> имя узла сверяется с атрибутом Subject Alternative Name (Альтернативное имя субъекта, SAN) в сертификате или с атрибутом Common Name (Общее имя), если в сертификате отсутствует атрибут SAN типа <code class="literal">dNSName</code>. Если атрибут имени сертификата начинается со звёздочки (<code class="literal">*</code>), звёздочка воспринимается как подстановочный знак и ей будут соответствовать все символы, <span class="emphasis"><em>кроме</em></span> точки (<code class="literal">.</code>). Это означает, что такой сертификат не будет соответствовать поддоменам. Если подключение устанавливается по IP-адресу, а не по имени узла, IP-адрес будет сопоставляться с записями SAN типа <code class="literal">iPAddress</code> или <code class="literal">dNSName</code> (без поиска в DNS). Если подходящих записей <code class="literal">iPAddress</code> и <code class="literal">dNSName</code> не найдётся, IP-адрес будет сопоставлен с атрибутом Common Name.</p><div class="note"><h3 class="title">Примечание</h3><p>Для обратной совместимости с более ранними версиями PostgreSQL IP-адрес узла проверяется не совсем так, как требует <a class="ulink" href="https://datatracker.ietf.org/doc/html/rfc6125" target="_top">RFC 6125</a>. IP-адрес узла всегда сопоставляется с записями <code class="literal">dNSName</code>, а также с <code class="literal">iPAddress</code> в SAN и может сопоставляться с атрибутом Common Name, если соответствующие записи SAN не существуют.</p></div><p>Чтобы настроить проверку сертификата сервера, необходимо поместить один или несколько корневых сертификатов в файл <code class="filename">~/.postgresql/root.crt</code> в домашнем каталоге пользователя. (В Microsoft Windows этот файл называется <code class="filename">%APPDATA%\postgresql\root.crt</code>.) Также следует добавлять в этот файл промежуточные сертификаты, если они нужны для связывания цепочки сертификатов, переданных сервером, с корневыми сертификатами, установленными на клиенте.</p><p>Если существует файл <code class="filename">~/.postgresql/root.crl</code> (или <code class="filename">%APPDATA%\postgresql\root.crl</code> в Microsoft Windows), при проверке также учитывается содержащийся в нём список отозванных сертификатов (CRL, Certificate Revocation List).</p><p>Размещение файла корневых сертификатов и CRL можно поменять, задав параметры соединения <code class="literal">sslrootcert</code> и <code class="literal">sslcrl</code> или переменные окружения <code class="envar">PGSSLROOTCERT</code> и <code class="envar">PGSSLCRL</code>, соответственно. Также вы можете указать расположение каталога с файлами CRL в параметре <code class="literal">sslcrldir</code> или в переменной окружения <code class="envar">PGSSLCRLDIR</code>.</p><div class="note"><h3 class="title">Примечание</h3><p>Для обратной совместимости с предыдущими версиями PostgreSQL, при наличии файла с сертификатами корневых ЦС поведение режима <code class="literal">sslmode</code>=<code class="literal">require</code> не отличается от режима <code class="literal">verify-ca</code>, то есть сертификат сервера будет проверяться по сертификату ЦС. Полагаться на это поведение не рекомендуется — приложения, которым нужно проверять сертификат, должны всегда выбирать режим <code class="literal">verify-ca</code> или <code class="literal">verify-full</code>.</p></div></div><div class="sect2" id="LIBPQ-SSL-CLIENTCERT"><div class="titlepage"><div><div><h3 class="title">34.19.2. Клиентские сертификаты <a href="#LIBPQ-SSL-CLIENTCERT" class="id_link">#</a></h3></div></div></div><p>Если сервер попытается проверить подлинность клиента, запрашивая конечный сертификат клиента, <span class="application">libpq</span> будет передавать сертификаты, сохранённые в файле <code class="filename">~/.postgresql/postgresql.crt</code> в домашнем каталоге пользователя. Эти сертификаты должны связываться по цепочке с корневым сертификатом, которому доверяет сервер. Также должен присутствовать соответствующий закрытый ключ <code class="filename">~/.postgresql/postgresql.key</code>. В Microsoft Windows эти файлы называются <code class="filename">%APPDATA%\postgresql\postgresql.crt</code> и <code class="filename">%APPDATA%\postgresql\postgresql.key</code>. Размещение файлов сертификатов и закрытого ключа можно переопределить с помощью параметров подключения <code class="literal">sslcert</code> и <code class="literal">sslkey</code> либо переменных окружения <code class="envar">PGSSLCERT</code> и <code class="envar">PGSSLKEY</code>.</p><p>В системах Unix разрешения для файла закрытого ключа должны запрещать любой доступ к нему всем и группе; этого можно добиться командой <code class="command">chmod 0600 ~/.postgresql/postgresql.key</code>. Возможен и другой вариант, когда этим файлом владеет root, а группа имеет доступ на чтение (то есть, маска разрешений <code class="literal">0640</code>). Данный вариант полезен, когда файлами сертификатов и ключей управляет сама операционная система. В этом случае пользователь, запускающий <span class="application">libpq</span>, должен быть членом группы, имеющей доступ к указанным файлам сертификата и ключа. (В Microsoft Windows каталог <code class="filename">%APPDATA%\postgresql</code> считается защищённым, поэтому разрешения для файлов не проверяются.)</p><p>Первым сертификатом в <code class="filename">postgresql.crt</code> должен быть сертификат клиента, так как он должен соответствовать закрытому ключу клиента. Дополнительно в этот файл могут быть добавлены <span class="quote">«<span class="quote">промежуточные</span>»</span> сертификаты — это позволит избежать хранения всех промежуточных сертификатов на сервере (см. <a class="xref" href="runtime-config-connection.html#GUC-SSL-CA-FILE">ssl_ca_file</a>).</p><p>Сертификат и ключ могут задаваться в формате PEM или ASN.1 DER.</p><p>Ключ может быть сохранён в открытом виде или зашифрован любым поддерживаемым <span class="productname">OpenSSL</span> алгоритмом, например AES-128. Если ключ хранится зашифрованным, пароль для его расшифровывания может быть задан в параметре подключения <a class="xref" href="libpq-connect.html#LIBPQ-CONNECT-SSLPASSWORD">sslpassword</a>. Если же ключ зашифрован, а параметр <code class="literal">sslpassword</code> не задан или имеет пустое значение, пароль будет запрошен интерактивно средствами <span class="productname">OpenSSL</span> в приглашении <code class="literal">Enter PEM pass phrase:</code> (Введите пароль для PEM:) при условии наличия TTY. Приложения могут переопределить приглашение для запроса пароля сертификата и обработку параметра <code class="literal">sslpassword</code>, установив собственную функцию-обработчик пароля ключа; см. <a class="xref" href="libpq-connect.html#LIBPQ-PQSETSSLKEYPASSHOOK-OPENSSL"><code class="function">PQsetSSLKeyPassHook_OpenSSL</code></a>.</p><p>За инструкциями по созданию сертификатов обратитесь к <a class="xref" href="ssl-tcp.html#SSL-CERTIFICATE-CREATION" title="19.9.5. Создание сертификатов">Подразделу 19.9.5</a>.</p></div><div class="sect2" id="LIBPQ-SSL-PROTECTION"><div class="titlepage"><div><div><h3 class="title">34.19.3. Защита, обеспечиваемая в различных режимах <a href="#LIBPQ-SSL-PROTECTION" class="id_link">#</a></h3></div></div></div><p>Разные значения параметра <code class="literal">sslmode</code> обеспечивают разные уровни защиты. SSL позволяет защититься от следующих типов атак: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Прослушивание</span></dt><dd><p>Если третья сторона может прослушивать сетевой трафик между клиентом и сервером, она может получить как информацию соединения (включая имя пользователя и пароль), так и передаваемые данные. Чтобы защититься от этого, <acronym class="acronym">SSL</acronym> шифрует трафик.</p></dd><dt><span class="term">Посредник (<acronym class="acronym">MITM</acronym>)</span></dt><dd><p>Если третья сторона может модифицировать данные, передаваемые между клиентом и сервером, она может представиться сервером и, таким образом, сможет видеть и модифицировать данные, <span class="emphasis"><em>даже если они зашифрованы</em></span>. Третья сторона затем может воспроизводить характеристики соединения и данные для подлинного сервера, что сделает невозможным обнаружение этой атаки. Векторами такой атаки может быть «отравление» DNS и подмена адресов, в результате чего клиент будет обращаться не к тому серверу, к которому нужно. Также есть несколько других вариантов реализации этой атаки. Для защиты в <acronym class="acronym">SSL</acronym> применяется проверка сертификатов, в результате которой сервер доказывает свою подлинность клиенту.</p></dd><dt><span class="term">Олицетворение</span></dt><dd><p>Если третья сторона может представляться авторизованным клиентом, она может просто обращаться к данным, к которым не должна иметь доступа. Обычно это происходит вследствие небезопасного управления паролями. В <acronym class="acronym">SSL</acronym> для предотвращения этой угрозы используются клиентские сертификаты, гарантирующие, что к серверу могут обращаться только владельцы действительных сертификатов.</p></dd></dl></div><p>Чтобы соединение было гарантированно защищено SSL, механизм SSL должен быть настроен <span class="emphasis"><em>на клиенте и на сервере</em></span>, прежде чем будет установлено соединение. Если он настроен только на сервере, клиент может начать передавать важную информацию (например, пароли), до того как поймёт, что сервер требует высокого уровня безопасности. В libpq для установления безопасных соединений нужно задать для параметра <code class="literal">sslmode</code> значение <code class="literal">verify-full</code> или <code class="literal">verify-ca</code> и предоставить системе корневой сертификат для проверки. В качестве аналогии можно привести использование адреса с <code class="literal">https</code> для безопасного просмотра веб-содержимого.</p><p>Когда подлинность сервера подтверждена, клиент может передавать конфиденциальные данные. Это значит, что до этого момента клиенту не нужно знать, применяются ли сертификаты для аутентификации, так что настройка использования сертификатов только на стороне сервера не угрожает безопасности.</p><p>Все варианты использования <acronym class="acronym">SSL</acronym> подразумевают издержки шифрования и обмена ключами, что порождает необходимость выбора между производительностью и безопасностью. В <a class="xref" href="libpq-ssl.html#LIBPQ-SSL-SSLMODE-STATEMENTS" title="Таблица 34.1. Описания режимов SSL">Таблице 34.1</a> описываются риски, от которых защищают различные варианты <code class="literal">sslmode</code>, и приводятся утверждения относительно защиты и издержек.</p><div class="table" id="LIBPQ-SSL-SSLMODE-STATEMENTS"><p class="title"><strong>Таблица 34.1. Описания режимов SSL</strong></p><div class="table-contents"><table class="table" summary="Описания режимов SSL" border="1"><colgroup><col class="col1" /><col class="col2" /><col class="col3" /><col class="col4" /></colgroup><thead><tr><th><code class="literal">sslmode</code></th><th>Защита от прослушивания</th><th>Защита от <acronym class="acronym">MITM</acronym></th><th>Утверждение</th></tr></thead><tbody><tr><td><code class="literal">disable</code></td><td>Нет</td><td>Нет</td><td>Мне не важна безопасность и я не приемлю издержки, связанные с шифрованием.</td></tr><tr><td><code class="literal">allow</code></td><td>Возможно</td><td>Нет</td><td>Мне не важна безопасность, но я приемлю издержки, связанные с шифрованием, если на этом настаивает сервер.</td></tr><tr><td><code class="literal">prefer</code></td><td>Возможно</td><td>Нет</td><td>Мне не важна безопасность, но я предпочитаю шифрование (и приемлю связанные издержки), если это поддерживает сервер.</td></tr><tr><td><code class="literal">require</code></td><td>Да</td><td>Нет</td><td>Я хочу, чтобы мои данные шифровались, и я приемлю сопутствующие издержки. Я доверяю сети в том, что она обеспечивает подключение к нужному серверу.</td></tr><tr><td><code class="literal">verify-ca</code></td><td>Да</td><td>Зависит от политики ЦС</td><td>Я хочу, чтобы мои данные шифровались, и я приемлю сопутствующие издержки. Мне нужна уверенность в том, что я подключаюсь к доверенному серверу.</td></tr><tr><td><code class="literal">verify-full</code></td><td>Да</td><td>Да</td><td>Я хочу, чтобы мои данные шифровались, и я приемлю сопутствующие издержки. Мне нужна уверенность в том, что я подключаюсь к доверенному серверу и это именно указанный мной сервер.</td></tr></tbody></table></div></div><br class="table-break" /><p>Различие вариантов <code class="literal">verify-ca</code> и <code class="literal">verify-full</code> зависит от характера корневого <acronym class="acronym">ЦС</acronym>. Если используется публичный <acronym class="acronym">ЦС</acronym>, режим <code class="literal">verify-ca</code> допускает подключение к серверу с сертификатом, который получил <span class="emphasis"><em>кто угодно</em></span> в этом <acronym class="acronym">ЦС</acronym>. В такой ситуации нужно всегда использовать режим <code class="literal">verify-full</code>. Если же используется локальный <acronym class="acronym">ЦС</acronym> или даже самоподписанный сертификат, режим <code class="literal">verify-ca</code> обычно обеспечивает достаточную защиту.</p><p>По умолчанию параметр <code class="literal">sslmode</code> имеет значение <code class="literal">prefer</code>. Как показано в таблице, оно неэффективно с точки зрения безопасности и может только привносить дополнительные издержки. Оно выбрано по умолчанию исключительно для обратной совместимости и не рекомендуется для защищённых окружений.</p></div><div class="sect2" id="LIBPQ-SSL-FILEUSAGE"><div class="titlepage"><div><div><h3 class="title">34.19.4. Файлы, используемые клиентом SSL <a href="#LIBPQ-SSL-FILEUSAGE" class="id_link">#</a></h3></div></div></div><p>В <a class="xref" href="libpq-ssl.html#LIBPQ-SSL-FILE-USAGE" title="Таблица 34.2. Файлы, используемые клиентом SSL/libpq">Таблице 34.2</a> перечислены файлы, имеющие отношение к настройке SSL на стороне клиента.</p><div class="table" id="LIBPQ-SSL-FILE-USAGE"><p class="title"><strong>Таблица 34.2. Файлы, используемые клиентом SSL/libpq</strong></p><div class="table-contents"><table class="table" summary="Файлы, используемые клиентом SSL/libpq" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Файл</th><th>Содержимое</th><th>Назначение</th></tr></thead><tbody><tr><td><code class="filename">~/.postgresql/postgresql.crt</code></td><td>сертификат клиента</td><td>передаётся серверу</td></tr><tr><td><code class="filename">~/.postgresql/postgresql.key</code></td><td>закрытый ключ клиента</td><td>подтверждает клиентский сертификат, передаваемый владельцем; не гарантирует, что владелец сертификата заслуживает доверия</td></tr><tr><td><code class="filename">~/.postgresql/root.crt</code></td><td>сертификаты доверенных ЦС</td><td>позволяет проверить, что сертификат сервера подписан доверенным центром сертификации</td></tr><tr><td><code class="filename">~/.postgresql/root.crl</code></td><td>сертификаты, отозванные центрами сертификации</td><td>сертификат сервера должен отсутствовать в этом списке</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect2" id="LIBPQ-SSL-INITIALIZE"><div class="titlepage"><div><div><h3 class="title">34.19.5. Инициализация библиотеки SSL <a href="#LIBPQ-SSL-INITIALIZE" class="id_link">#</a></h3></div></div></div><p>Если ваше приложение инициализирует библиотеку <code class="literal">libssl</code> и/или <code class="literal">libcrypto</code>, и <span class="application">libpq</span> собрана с поддержкой <acronym class="acronym">SSL</acronym>, вы должны вызвать <a class="xref" href="libpq-ssl.html#LIBPQ-PQINITOPENSSL"><code class="function">PQinitOpenSSL</code></a>, чтобы сообщить <span class="application">libpq</span>, что библиотека <code class="literal">libssl</code> и/или <code class="literal">libcrypto</code> уже инициализированы вашим приложением, чтобы <span class="application">libpq</span> не пыталась ещё раз инициализировать их. Однако в этом нет необходимости при использовании <span class="productname">OpenSSL</span> версии 1.1.0 или выше, в которой решена проблема повторных инициализаций.</p><p>
   </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQINITOPENSSL"><span class="term"><code class="function">PQinitOpenSSL</code><a id="id-1.7.3.26.9.3.1.1.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQINITOPENSSL" class="id_link">#</a></dt><dd><p>Позволяет приложениям выбрать, какие библиотеки безопасности нужно инициализировать. </p><pre class="synopsis">
void PQinitOpenSSL(int do_ssl, int do_crypto);
</pre><p>Когда параметр <em class="parameter"><code>do_ssl</code></em> отличен от нуля, <span class="productname">libpq</span> будет инициализировать библиотеку <span class="productname">OpenSSL</span> перед первым подключением к базе данных. Когда параметр <em class="parameter"><code>do_crypto</code></em> не равен нулю, будет инициализироваться библиотека <code class="literal">libcrypto</code>. По умолчанию (если функция <a class="xref" href="libpq-ssl.html#LIBPQ-PQINITOPENSSL"><code class="function">PQinitOpenSSL</code></a> не вызывается) инициализируются обе библиотеки. Если поддержка SSL не была скомпилирована, эта функция присутствует, но ничего не делает.</p><p>Если ваше приложение использует и инициализирует библиотеку <span class="productname">OpenSSL</span> или её нижележащую библиотеку <code class="literal">libcrypto</code>, вы <span class="emphasis"><em>должны</em></span> вызвать эту функцию, передав нули в соответствующих параметрах, перед первым подключением к базе данных. Собственно инициализацию также важно произвести перед установлением подключения.</p></dd><dt id="LIBPQ-PQINITSSL"><span class="term"><code class="function">PQinitSSL</code><a id="id-1.7.3.26.9.3.1.2.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQINITSSL" class="id_link">#</a></dt><dd><p>Позволяет приложениям выбрать, какие библиотеки безопасности нужно инициализировать. </p><pre class="synopsis">
void PQinitSSL(int do_ssl);
</pre><p>Эта функция равнозначна вызову <code class="literal">PQinitOpenSSL(do_ssl, do_ssl)</code>. Приложениям достаточно инициализировать или не инициализировать обе библиотеки <span class="productname">OpenSSL</span> и <code class="literal">libcrypto</code> одновременно.</p><p>Функция <a class="xref" href="libpq-ssl.html#LIBPQ-PQINITSSL"><code class="function">PQinitSSL</code></a> существует со времён <span class="productname">PostgreSQL</span> 8.0, тогда как <a class="xref" href="libpq-ssl.html#LIBPQ-PQINITOPENSSL"><code class="function">PQinitOpenSSL</code></a> появилась в <span class="productname">PostgreSQL</span> 8.4, так что <a class="xref" href="libpq-ssl.html#LIBPQ-PQINITSSL"><code class="function">PQinitSSL</code></a> может быть предпочтительней для приложений, которым нужно работать с более старыми версиями <span class="application">libpq</span>.</p></dd></dl></div><p>
  </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="libpq-ldap.html" title="34.18. Получение параметров соединения через LDAP">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="libpq.html" title="Глава 34. libpq — библиотека для языка C">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="libpq-threading.html" title="34.20. Поведение в многопоточных программах">След.</a></td></tr><tr><td width="40%" align="left" valign="top">34.18. Получение параметров соединения через LDAP </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 34.20. Поведение в многопоточных программах</td></tr></table></div></body></html>