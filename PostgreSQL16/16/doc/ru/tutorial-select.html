<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>2.5. Выполнение запроса</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="tutorial-populate.html" title="2.4. Добавление строк в таблицу" /><link rel="next" href="tutorial-join.html" title="2.6. Соединения таблиц" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">2.5. Выполнение запроса</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="tutorial-populate.html" title="2.4. Добавление строк в таблицу">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="tutorial-sql.html" title="Глава 2. Язык SQL">Наверх</a></td><th width="60%" align="center">Глава 2. Язык <acronym class="acronym">SQL</acronym></th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="tutorial-join.html" title="2.6. Соединения таблиц">След.</a></td></tr></table><hr /></div><div class="sect1" id="TUTORIAL-SELECT"><div class="titlepage"><div><div><h2 class="title" style="clear: both">2.5. Выполнение запроса <a href="#TUTORIAL-SELECT" class="id_link">#</a></h2></div></div></div><p><a id="id-1.4.4.6.2.1" class="indexterm"></a> <a id="id-1.4.4.6.2.2" class="indexterm"></a> Чтобы получить данные из таблицы, нужно выполнить <em class="firstterm">запрос</em>. Для этого предназначен <acronym class="acronym">SQL</acronym>-оператор <code class="command">SELECT</code>. Он состоит из нескольких частей: выборки (в которой перечисляются столбцы, которые должны быть получены), списка таблиц (в нём перечисляются таблицы, из которых будут получены данные) и необязательного условия (определяющего ограничения). Например, чтобы получить все строки таблицы <code class="structname">weather</code>, введите: </p><pre class="programlisting">SELECT * FROM weather;</pre><p> Здесь <code class="literal">*</code> — это краткое обозначение <span class="quote">«<span class="quote">всех столбцов</span>»</span>. <a href="#ftn.id-1.4.4.6.2.10" class="footnote"><sup class="footnote" id="id-1.4.4.6.2.10">[2]</sup></a> Таким образом, это равносильно записи: </p><pre class="programlisting">SELECT city, temp_lo, temp_hi, prcp, date FROM weather;</pre><p> В результате должно получиться: </p><pre class="screen">
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      43 |      57 |    0 | 1994-11-29
 Hayward       |      37 |      54 |      | 1994-11-29
(3 rows)
</pre><p>В списке выборки вы можете писать не только ссылки на столбцы, но и выражения. Например, вы можете написать: </p><pre class="programlisting">SELECT city, (temp_hi+temp_lo)/2 AS temp_avg, date FROM weather;</pre><p> И получить в результате: </p><pre class="screen">
     city      | temp_avg |    date
---------------+----------+------------
 San Francisco |       48 | 1994-11-27
 San Francisco |       50 | 1994-11-29
 Hayward       |       45 | 1994-11-29
(3 rows)
</pre><p> Обратите внимание, как предложение <code class="literal">AS</code> позволяет переименовать выходной столбец. (Само слово <code class="literal">AS</code> можно опускать.)</p><p>Запрос можно дополнить <span class="quote">«<span class="quote">условием</span>»</span>, добавив предложение <code class="literal">WHERE</code>, ограничивающее множество возвращаемых строк. В предложении <code class="literal">WHERE</code> указывается логическое выражение (проверка истинности), которое служит фильтром строк: в результате оказываются только те строки, для которых это выражение истинно. В этом выражении могут присутствовать обычные логические операторы (<code class="literal">AND</code>, <code class="literal">OR</code> и <code class="literal">NOT</code>). Например, следующий запрос покажет, какая погода была в Сан-Франциско в дождливые дни: </p><pre class="programlisting">SELECT * FROM weather
    WHERE city = 'San Francisco' AND prcp &gt; 0.0;</pre><p> Результат: </p><pre class="screen">
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
(1 row)
</pre><p><a id="id-1.4.4.6.5.1" class="indexterm"></a> Вы можете получить результаты запроса в определённом порядке: </p><pre class="programlisting">SELECT * FROM weather
    ORDER BY city;</pre><p> </p><pre class="screen">
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 Hayward       |      37 |      54 |      | 1994-11-29
 San Francisco |      43 |      57 |    0 | 1994-11-29
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
</pre><p> В этом примере порядок сортировки определён не полностью, поэтому вы можете получить строки Сан-Франциско в любом порядке. Но вы всегда получите результат, показанный выше, если напишете: </p><pre class="programlisting">SELECT * FROM weather
    ORDER BY city, temp_lo;</pre><p><a id="id-1.4.4.6.6.1" class="indexterm"></a> <a id="id-1.4.4.6.6.2" class="indexterm"></a> Если требуется, вы можете убрать дублирующиеся строки из результата запроса: </p><pre class="programlisting">SELECT DISTINCT city
    FROM weather;</pre><p> </p><pre class="screen">
     city
---------------
 Hayward
 San Francisco
(2 rows)
</pre><p> И здесь порядок строк также может варьироваться. Чтобы получать неизменные результаты, соедините предложения <code class="literal">DISTINCT</code> и <code class="literal">ORDER BY</code>: <a href="#ftn.id-1.4.4.6.6.7" class="footnote"><sup class="footnote" id="id-1.4.4.6.6.7">[3]</sup></a> </p><pre class="programlisting">SELECT DISTINCT city
    FROM weather
    ORDER BY city;</pre><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.id-1.4.4.6.2.10" class="footnote"><p><a href="#id-1.4.4.6.2.10" class="para"><sup class="para">[2] </sup></a>Хотя запросы <code class="literal">SELECT *</code> часто пишут экспромтом, это считается плохим стилем в производственном коде, так как результат таких запросов будет меняться при добавлении новых столбцов.</p></div><div id="ftn.id-1.4.4.6.6.7" class="footnote"><p><a href="#id-1.4.4.6.6.7" class="para"><sup class="para">[3] </sup></a>В некоторых СУБД, включая старые версии <span class="productname">PostgreSQL</span>, реализация предложения <code class="literal">DISTINCT</code> автоматически упорядочивает строки, так что <code class="literal">ORDER BY</code> добавлять не обязательно. Но стандарт SQL этого не требует и текущая версия <span class="productname">PostgreSQL</span> не гарантирует определённого порядка строк после <code class="literal">DISTINCT</code>.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="tutorial-populate.html" title="2.4. Добавление строк в таблицу">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="tutorial-sql.html" title="Глава 2. Язык SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="tutorial-join.html" title="2.6. Соединения таблиц">След.</a></td></tr><tr><td width="40%" align="left" valign="top">2.4. Добавление строк в таблицу </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 2.6. Соединения таблиц</td></tr></table></div></body></html>