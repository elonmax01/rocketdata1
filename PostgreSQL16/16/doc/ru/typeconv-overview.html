<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>10.1. Обзор</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="typeconv.html" title="Глава 10. Преобразование типов" /><link rel="next" href="typeconv-oper.html" title="10.2. Операторы" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">10.1. Обзор</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="typeconv.html" title="Глава 10. Преобразование типов">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="typeconv.html" title="Глава 10. Преобразование типов">Наверх</a></td><th width="60%" align="center">Глава 10. Преобразование типов</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="typeconv-oper.html" title="10.2. Операторы">След.</a></td></tr></table><hr /></div><div class="sect1" id="TYPECONV-OVERVIEW"><div class="titlepage"><div><div><h2 class="title" style="clear: both">10.1. Обзор <a href="#TYPECONV-OVERVIEW" class="id_link">#</a></h2></div></div></div><p><acronym class="acronym">SQL</acronym> — язык со строгой типизацией. То есть каждый элемент данных в нём имеет некоторый тип, определяющий его поведение и допустимое использование. <span class="productname">PostgreSQL</span> наделён расширяемой системой типов, более универсальной и гибкой по сравнению с другими реализациями <acronym class="acronym">SQL</acronym>. При этом преобразования типов в <span class="productname">PostgreSQL</span> в основном подчиняются определённым общим правилам, для их понимания не нужен эвристический анализ. Благодаря этому в выражениях со смешанными типами можно использовать даже типы, определённые пользователями.</p><p>Анализатор выражений <span class="productname">PostgreSQL</span> разделяет их лексические элементы на пять основных категорий: целые числа, другие числовые значения, текстовые строки, идентификаторы и ключевые слова. Константы большинства не числовых типов сначала классифицируются как строки. В определении языка <acronym class="acronym">SQL</acronym> допускается указывать имена типов в строках и это можно использовать в <span class="productname">PostgreSQL</span>, чтобы направить анализатор по верному пути. Например, запрос: </p><pre class="screen">
SELECT text 'Origin' AS "label", point '(0,0)' AS "value";

 label  | value
--------+-------
 Origin | (0,0)
(1 row)
</pre><p> содержит две строковых константы, типа <code class="type">text</code> и типа <code class="type">point</code>. Если для такой константы не указан тип, для неё первоначально предполагается тип <code class="type">unknown</code>, который затем может быть уточнён, как описано ниже.</p><p>В <acronym class="acronym">SQL</acronym> есть четыре фундаментальных фактора, определяющих правила преобразования типов для анализатора выражений <span class="productname">PostgreSQL</span>: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Вызовы функций</span></dt><dd><p>Система типов <span class="productname">PostgreSQL</span> во многом построена как дополнение к богатым возможностям функций. Функции могут иметь один или несколько аргументов, и при этом <span class="productname">PostgreSQL</span> разрешает перегружать имена функций, так что имя функции само по себе не идентифицирует вызываемую функцию; анализатор выбирает правильную функцию в зависимости от типов переданных аргументов.</p></dd><dt><span class="term">Операторы</span></dt><dd><p><span class="productname">PostgreSQL</span> позволяет использовать в выражениях префиксные операторы (с одним аргументом), а также инфиксные операторы (с двумя аргументами). Как и функции, операторы можно перегружать, так что и с ними существует проблема выбора правильного оператора.</p></dd><dt><span class="term">Сохранение значений</span></dt><dd><p><acronym class="acronym">SQL</acronym>-операторы <code class="command">INSERT</code> и <code class="command">UPDATE</code> помещают результаты выражений в таблицы. При этом получаемые значения должны соответствовать типам целевых столбцов или, возможно, приводиться к ним.</p></dd><dt><span class="term"><code class="literal">UNION</code>, <code class="literal">CASE</code> и связанные конструкции</span></dt><dd><p>Так как все результаты запроса объединяющего оператора <code class="command">SELECT</code> должны оказаться в одном наборе столбцов, результаты каждого подзапроса <code class="command">SELECT</code> должны приводиться к одному набору типов. Подобным образом, результирующие выражения конструкции <code class="literal">CASE</code> должны приводиться к общему типу, так как выражение <code class="literal">CASE</code> в целом должно иметь определённый выходной тип. Подобное определение общего типа для значений нескольких подвыражений требуется и для некоторых других конструкций, например <code class="literal">ARRAY[]</code>, а также для функций <code class="function">GREATEST</code> и <code class="function">LEAST</code>.</p></dd></dl></div><p>Информация о существующих преобразованиях или <em class="firstterm">приведениях</em> типов, для каких типов они определены и как их выполнять, хранится в системных каталогах. Пользователь также может добавить дополнительные преобразования с помощью команды <a class="xref" href="sql-createcast.html" title="CREATE CAST"><span class="refentrytitle">CREATE CAST</span></a>. (Обычно это делается, когда определяются новые типы данных. Набор приведений для встроенных типов достаточно хорошо проработан, так что его лучше не менять.)</p><a id="id-1.5.9.6.6" class="indexterm"></a><p>Дополнительная логика анализа помогает выбрать оптимальное приведение в группах типов, допускающих неявные преобразования. Для этого типы данных разделяются на несколько базовых <em class="firstterm">категорий</em>, которые включают: <code class="type">boolean</code>, <code class="type">numeric</code>, <code class="type">string</code>, <code class="type">bitstring</code>, <code class="type">datetime</code>, <code class="type">timespan</code>, <code class="type">geometric</code>, <code class="type">network</code> и пользовательские типы. (Полный список категорий приведён в <a class="xref" href="catalog-pg-type.html#CATALOG-TYPCATEGORY-TABLE" title="Таблица 53.65. Коды typcategory">Таблице 53.65</a>; хотя его тоже можно расширить, определив свои категории.) В каждой категории могут быть выбраны один или несколько <em class="firstterm">предпочитаемых типов</em>, которые будут считаться наиболее подходящими при рассмотрении нескольких вариантов. Аккуратно выбирая предпочитаемые типы и допустимые неявные преобразования, можно добиться того, что выражения с неоднозначностями (в которых возможны разные решения задачи преобразования) будут разрешаться наилучшим образом.</p><p>Все правила преобразования типов разработаны с учётом следующих принципов: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Результат неявных преобразованиях всегда должен быть предсказуемым и понятным.</p></li><li class="listitem"><p>Если в неявном преобразовании нет нужды, анализатор и исполнитель запроса не должны тратить лишнее время на это. То есть, если запрос хорошо сформулирован и типы значений совпадают, он должен выполняться без дополнительной обработки в анализаторе и без лишних вызовов неявных преобразований.</p></li><li class="listitem"><p>Кроме того, если запрос изначально требовал неявного преобразования для функции, а пользователь определил новую функцию с точно совпадающими типами аргументов, анализатор должен переключиться на новую функцию и больше не выполнять преобразование для вызова старой.</p></li></ul></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="typeconv.html" title="Глава 10. Преобразование типов">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="typeconv.html" title="Глава 10. Преобразование типов">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="typeconv-oper.html" title="10.2. Операторы">След.</a></td></tr><tr><td width="40%" align="left" valign="top">Глава 10. Преобразование типов </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 10.2. Операторы</td></tr></table></div></body></html>