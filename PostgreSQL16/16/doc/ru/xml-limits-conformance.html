<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>D.3. Ограничения XML и совместимость с SQL/XML</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="unsupported-features-sql-standard.html" title="D.2. Неподдерживаемые возможности" /><link rel="next" href="release.html" title="Приложение E. Замечания к выпускам" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">D.3. Ограничения XML и совместимость с SQL/XML</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="unsupported-features-sql-standard.html" title="D.2. Неподдерживаемые возможности">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="features.html" title="Приложение D. Соответствие стандарту SQL">Наверх</a></td><th width="60%" align="center">Приложение D. Соответствие стандарту SQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="release.html" title="Приложение E. Замечания к выпускам">След.</a></td></tr></table><hr /></div><div class="sect1" id="XML-LIMITS-CONFORMANCE"><div class="titlepage"><div><div><h2 class="title" style="clear: both">D.3. Ограничения XML и совместимость с SQL/XML <a href="#XML-LIMITS-CONFORMANCE" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="xml-limits-conformance.html#FUNCTIONS-XML-LIMITS-XPATH1">D.3.1. Запросы ограничиваются XPath версии 1.0</a></span></dt><dt><span class="sect2"><a href="xml-limits-conformance.html#FUNCTIONS-XML-LIMITS-POSTGRESQL">D.3.2. Непреднамеренные ограничения реализации</a></span></dt></dl></div><a id="id-1.11.5.13.2" class="indexterm"></a><p>В SQL:2006 были внесены значительные изменения в посвящённой XML части ISO/IEC 9075-14 (SQL/XML). Реализация типа данных XML и связанных функций в <span class="productname">PostgreSQL</span> в большей степени соответствует более ранней редакции, SQL:2003, с некоторыми заимствованиями из последующих редакций. В частности: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Тогда как в текущем стандарте существует семейство типов данных XML, содержащих <span class="quote">«<span class="quote">документы</span>»</span> или <span class="quote">«<span class="quote">содержимое</span>»</span> в нетипизированном виде или с типами XML Schema, а также тип <code class="type">XML(SEQUENCE)</code>, содержащий произвольные части XML-документа, в <span class="productname">PostgreSQL</span> есть только один тип <code class="type">xml</code>, который может содержать <span class="quote">«<span class="quote">документ</span>»</span> или <span class="quote">«<span class="quote">содержимое</span>»</span>. Определённый в стандарте тип <span class="quote">«<span class="quote">последовательность</span>»</span> в <span class="productname">PostgreSQL</span> отсутствует.</p></li><li class="listitem"><p><span class="productname">PostgreSQL</span> предоставляет две функции, появившиеся в SQL:2006, но вместо языка XML Query, как должно быть согласно стандарту, в них используется язык XPath 1.0.</p></li></ul></div><p>В этом разделе описаны некоторые из образовавшихся в итоге различий, с которыми вы можете столкнуться.</p><div class="sect2" id="FUNCTIONS-XML-LIMITS-XPATH1"><div class="titlepage"><div><div><h3 class="title">D.3.1. Запросы ограничиваются XPath версии 1.0 <a href="#FUNCTIONS-XML-LIMITS-XPATH1" class="id_link">#</a></h3></div></div></div><p>Специфичные для <span class="productname">PostgreSQL</span> функции <code class="function">xpath()</code> и <code class="function">xpath_exists()</code> выполняют запросы к XML-документам на языке XPath. В <span class="productname">PostgreSQL</span> также имеются поддерживающие только XPath стандартные функции <code class="function">XMLEXISTS</code> и <code class="function">XMLTABLE</code>, хотя согласно стандарту они должны поддерживать XQuery. Все эти функции в <span class="productname">PostgreSQL</span> реализованы с использованием библиотеки <span class="application">libxml2</span>, которая поддерживает только XPath 1.0.</p><p>Существует тесная связь между языком XQuery и XPath версии 2.0 и новее: любое выражение, синтаксически правильное и выполняющееся успешно, выдаёт в обоих языках одинаковые результаты (за незначительным исключением, связанным с числовым обозначением символов или использованием предопределённых сущностей — XQuery заменяет их соответствующими символами, а XPath оставляет в исходном виде). Но между XPath 1.0 и этими языками подобная связь отсутствует: он появился гораздо раньше и во многом отличается от них.</p><p>Заслуживают отдельного рассмотрения две категории ограничений: ограничение языка XQuery до XPath для функций, описанных в стандарте SQL, и ограничение XPath до версии 1.0 как для стандартизированных функций, так и для специфичных функций <span class="productname">PostgreSQL</span>.</p><div class="sect3" id="FUNCTIONS-XML-LIMITS-XPATH1-XQUERY-RESTRICTION"><div class="titlepage"><div><div><h4 class="title">D.3.1.1. Ограничение языка XQuery до XPath <a href="#FUNCTIONS-XML-LIMITS-XPATH1-XQUERY-RESTRICTION" class="id_link">#</a></h4></div></div></div><p>В число отличий XQuery от XPath входят: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Выражения XQuery могут выдавать не только всевозможные значения XPath, но и конструировать новые XML-узлы. XPath может создавать и возвращать значения атомарных типов (числа, строки и так далее), но выдаваемые им XML-узлы должны уже присутствовать в документе, поступившем на вход выражения.</p></li><li class="listitem"><p>В XQuery есть управляющие конструкции для организации циклов, сортировки и группировки.</p></li><li class="listitem"><p>В XQuery поддерживается объявление и использование локальных функций.</p></li></ul></div><p>В последних версиях XPath начинают появляться возможности, пересекающиеся с имеющимися в XQuery (например, конструкции <code class="function">for-each</code>, <code class="function">sort</code>, анонимные функции и функция <code class="function">parse-xml</code>, создающая узел из строки), но до XPath 3.0 их не было.</p></div><div class="sect3" id="XML-XPATH-1-SPECIFICS"><div class="titlepage"><div><div><h4 class="title">D.3.1.2. Ограничения XPath до версии 1.0 <a href="#XML-XPATH-1-SPECIFICS" class="id_link">#</a></h4></div></div></div><p>Разработчикам, знакомым с XQuery и XPath 2.0 или новее, приходится иметь дело с рядом недостатков XPath версии 1.0: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Фундаментальный тип результатов XQuery/XPath, тип <code class="type">sequence</code>, который может содержать XML-узлы, атомарные значения, и всё это вместе, в XPath 1.0 отсутствует. В 1.0 выражения могут выдавать только набор узлов (состоящих из нуля или нескольких узлов XML) или единственное атомарное значение.</p></li><li class="listitem"><p>В отличие от последовательностей XQuery/XPath, которые могут содержать произвольные элементы в любом требующемся порядке, во множестве узлов XPath 1.0 нет гарантированного порядка, и оно, как и любое другое множество, не может содержать несколько вхождений одного элемента. </p><div class="note"><h3 class="title">Примечание</h3><p>Библиотека <span class="application">libxml2</span> не всегда возвращает в <span class="productname">PostgreSQL</span> наборы узлов с внутренними членами в том порядке, в котором они идут во входном документе. В её документации не гарантируется корректное поведение, а выражение XPath 1.0 не может на это воздействовать.</p></div></li><li class="listitem"><p>Тогда как XQuery/XPath поддерживают все типы, определённые в стандарте XML Schema, а также множество операторов и функций, работающих с этими типами, XPath 1.0 поддерживает только множества узлов и три атомарных типа: <code class="type">boolean</code>, <code class="type">double</code> и <code class="type">string</code>.</p></li><li class="listitem"><p>В XPath 1.0 отсутствует условный оператор. Выражение XQuery/XPath вида <code class="literal">if ( hat ) then hat/@size else "no hat"</code> не имеет эквивалента в XPath 1.0.</p></li><li class="listitem"><p>В XPath 1.0 нет оператора сравнения строк с упорядочиванием. Условия <code class="literal">"cat" &lt; "dog"</code> и <code class="literal">"cat" &gt; "dog"</code> оба являются ложными, так как они выполняются как числовые сравнения двух значений <code class="literal">NaN</code>. Условия же <code class="literal">=</code> и <code class="literal">!=</code>, напротив, сравнивают строки в виде строк.</p></li><li class="listitem"><p>XPath 1.0 размывает разницу между <em class="firstterm">сравнением значений</em> и <em class="firstterm">общими сравнениями</em>, которая имеется в XQuery/XPath. Сравнения <code class="literal">sale/@hatsize = 7</code> и <code class="literal">sale/@customer = "alice"</code> по сути являются количественными сравнениями, и результатом их будет истина, если существует элемент <code class="literal">sale</code> с заданным значением атрибута, тогда как <code class="literal">sale/@taxable = false()</code> — сравнение всего набора узлов с <em class="firstterm">фактическим логическим значением</em>. Его результат будет истиной, только если у элемента <code class="literal">sale</code> вовсе не будет атрибута <code class="literal">taxable</code>.</p></li><li class="listitem"><p>В модели данных XQuery/XPath <em class="firstterm">узел документа</em> может иметь либо форму документа (то есть содержать в точности один элемент верхнего уровня, снаружи которого допускаются только комментарии и инструкции обработки), либо форму содержимого (с ослабленными ограничениями). В XPath 1.0 ему соответствует <em class="firstterm">корневой узел</em>, который может иметь только форму документа. Этим отчасти объясняется то, что значение типа <code class="type">xml</code>, передаваемое в качестве элемента контекста любым функциям <span class="productname">PostgreSQL</span> на базе XPath, должно быть в форме документа.</p></li></ul></div><p>Кроме отмеченных выше имеются и другие различия. В языках XQuery и XPath версии 2.0 и новее существует режим совместимости с XPath 1.0, а в документации W3C имеется перечень <a class="ulink" href="https://www.w3.org/TR/2010/REC-xpath-functions-20101214/#xpath1-compatibility" target="_top">изменений функций</a> и <a class="ulink" href="https://www.w3.org/TR/xpath20/#id-backwards-compatibility" target="_top">изменений в языке</a> применительно к этому режиму. Этот перечень гораздо более полный, но тоже не исчерпывающий. Даже режим совместимости этих языков не обеспечивает их полную идентичность XPath 1.0.</p></div><div class="sect3" id="FUNCTIONS-XML-LIMITS-CASTS"><div class="titlepage"><div><div><h4 class="title">D.3.1.3. Преобразование значений/типов данных между SQL и XML <a href="#FUNCTIONS-XML-LIMITS-CASTS" class="id_link">#</a></h4></div></div></div><p>В SQL:2006 и более поздних ревизиях чётко определены преобразования между стандартными типами SQL и типами стандарта XML Schema в обе стороны. Однако эти правила выражаются в типах и понятиях, определённых в XQuery/XPath, и не могут быть непосредственно применены к другой модели данных, присущей XPath 1.0.</p><p>Когда <span class="productname">PostgreSQL</span> сопоставляет значения данных SQL с XML (как в функции <code class="function">xmlelement</code>), или XML с SQL (как в выходных столбцах <code class="function">xmltable</code>), за исключением нескольких отдельно обрабатываемых случаев, <span class="productname">PostgreSQL</span> просто полагает, что строка XPath 1.0, содержащая данные типа XML, будет допустимой для ввода в текстовом виде в тип данных SQL, и наоборот. Это правило добродетельно своей простотой, и при этом преобразования для многих типов данных в итоге оказываются такими, какими и должны быть согласно стандарту.</p><p>Там же, где это нужно для взаимодействия с другими системами, для некоторых типов данных можно явно использовать функции форматирования типов данных (например, описанные в <a class="xref" href="functions-formatting.html" title="9.8. Функции форматирования данных">Разделе 9.8</a>) для получения преобразований, в точности соответствующих стандарту.</p></div></div><div class="sect2" id="FUNCTIONS-XML-LIMITS-POSTGRESQL"><div class="titlepage"><div><div><h3 class="title">D.3.2. Непреднамеренные ограничения реализации <a href="#FUNCTIONS-XML-LIMITS-POSTGRESQL" class="id_link">#</a></h3></div></div></div><p>В этом разделе описываются дополнительные ограничения, присущие текущей реализации в <span class="productname">PostgreSQL</span>, но не самой библиотеке <span class="application">libxml2</span>.</p><div class="sect3" id="FUNCTIONS-XML-LIMITS-POSTGRESQL-BY-VALUE-ONLY"><div class="titlepage"><div><div><h4 class="title">D.3.2.1. Передача параметров только по значению (<code class="literal">BY VALUE</code>) <a href="#FUNCTIONS-XML-LIMITS-POSTGRESQL-BY-VALUE-ONLY" class="id_link">#</a></h4></div></div></div><p>В стандарте SQL определены два <em class="firstterm">механизма передачи параметров</em>, осуществляющих передачу XML-аргумента из SQL в XML-функцию или получение результата: <code class="literal">BY REF</code>, в котором конкретное значение в XML остаётся привязанным к своему узлу, и <code class="literal">BY VALUE</code>, в котором передаётся содержимое XML, но связь с узлом теряется. Выбрать механизм можно перед списком параметров, в качестве механизма по умолчанию для всех параметров, или после каждого отдельного параметра, переопределив тем самым выбор по умолчанию.</p><p>В качестве иллюстрации различия взгляните на следующие два запроса, которые в окружении SQL:2006 выдают true и false, если <em class="replaceable"><code>x</code></em> является XML-значением: </p><pre class="programlisting">SELECT XMLQUERY('$a is $b' PASSING BY REF <em class="replaceable"><code>x</code></em> AS a, <em class="replaceable"><code>x</code></em> AS b NULL ON EMPTY);
SELECT XMLQUERY('$a is $b' PASSING BY VALUE <em class="replaceable"><code>x</code></em> AS a, <em class="replaceable"><code>x</code></em> AS b NULL ON EMPTY);</pre><p><span class="productname">PostgreSQL</span> принимает указания <code class="literal">BY VALUE</code> и <code class="literal">BY REF</code> в конструкции <code class="function">XMLEXISTS</code> или <code class="function">XMLTABLE</code>, но игнорирует их. Тип <code class="type">xml</code> содержит сериализованное представление данных в текстовом виде, поэтому сущность узла, которую нужно сохранять, отсутствует, и передача фактически производится по значению (<code class="literal">BY VALUE</code>).</p></div><div class="sect3" id="FUNCTIONS-XML-LIMITS-POSTGRESQL-NAMED-PARAMETERS"><div class="titlepage"><div><div><h4 class="title">D.3.2.2. Отсутствие именованных параметров запросов <a href="#FUNCTIONS-XML-LIMITS-POSTGRESQL-NAMED-PARAMETERS" class="id_link">#</a></h4></div></div></div><p>Функции на базе XPath могут принимать один параметр, служащий контекстным элементом для выражения XPath, но не поддерживают передачу дополнительных значений, которые могли бы использоваться в выражении как именованные параметры.</p></div><div class="sect3" id="FUNCTIONS-XML-LIMITS-POSTGRESQL-NO-XML-SEQUENCE"><div class="titlepage"><div><div><h4 class="title">D.3.2.3. Отсутствие типа <code class="type">XML(SEQUENCE)</code> <a href="#FUNCTIONS-XML-LIMITS-POSTGRESQL-NO-XML-SEQUENCE" class="id_link">#</a></h4></div></div></div><p>Тип данных <code class="type">xml</code> в <span class="productname">PostgreSQL</span> может содержать значение только в форме документа (<code class="literal">DOCUMENT</code>) или содержимого (<code class="literal">CONTENT</code>). Контекстный элемент выражения XQuery/XPath должен быть одиночным XML-узлом или атомарным значением, но в XPath 1.0 это может быть только XML-узел, и при этом нет типа узла, содержащего <code class="literal">CONTENT</code>. Как следствие, в <span class="productname">PostgreSQL</span> в качестве контекстного элемента XPath можно передать данные XML в единственном виде — в виде правильно оформленного документа (<code class="literal">DOCUMENT</code>).</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="unsupported-features-sql-standard.html" title="D.2. Неподдерживаемые возможности">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="features.html" title="Приложение D. Соответствие стандарту SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="release.html" title="Приложение E. Замечания к выпускам">След.</a></td></tr><tr><td width="40%" align="left" valign="top">D.2. Неподдерживаемые возможности </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> Приложение E. Замечания к выпускам</td></tr></table></div></body></html>