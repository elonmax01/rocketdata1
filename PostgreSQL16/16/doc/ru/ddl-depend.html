<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>5.14. Отслеживание зависимостей</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="ddl-others.html" title="5.13. Другие объекты баз данных" /><link rel="next" href="dml.html" title="Глава 6. Модификация данных" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">5.14. Отслеживание зависимостей</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="ddl-others.html" title="5.13. Другие объекты баз данных">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="ddl.html" title="Глава 5. Определение данных">Наверх</a></td><th width="60%" align="center">Глава 5. Определение данных</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="dml.html" title="Глава 6. Модификация данных">След.</a></td></tr></table><hr /></div><div class="sect1" id="DDL-DEPEND"><div class="titlepage"><div><div><h2 class="title" style="clear: both">5.14. Отслеживание зависимостей <a href="#DDL-DEPEND" class="id_link">#</a></h2></div></div></div><a id="id-1.5.4.16.2" class="indexterm"></a><a id="id-1.5.4.16.3" class="indexterm"></a><p>Когда вы создаёте сложные структуры баз данных, включающие множество таблиц с внешними ключами, представлениями, триггерами, функциями и т. п., вы неявно создаёте сеть зависимостей между объектами. Например, таблица с ограничением внешнего ключа зависит от таблицы, на которую она ссылается.</p><p>Для сохранения целостности структуры всей базы данных, <span class="productname">PostgreSQL</span> не позволяет удалять объекты, от которых зависят другие. Например, попытка удалить таблицу products (мы рассматривали её в <a class="xref" href="ddl-constraints.html#DDL-CONSTRAINTS-FK" title="5.4.5. Внешние ключи">Подразделе 5.4.5</a>), от которой зависит таблица orders, приведёт к ошибке примерно такого содержания: </p><pre class="screen">
DROP TABLE products;

ОШИБКА:  удалить объект "таблица products" нельзя, так как от него зависят другие
ПОДРОБНОСТИ:  ограничение orders_product_no_fkey в отношении "таблица orders" зависит от объекта "таблица products"
ПОДСКАЗКА:  Для удаления зависимых объектов используйте DROP ... CASCADE.
</pre><p> Сообщение об ошибке даёт полезную подсказку: если вы не хотите заниматься ликвидацией зависимостей по отдельности, можно выполнить: </p><pre class="screen">
DROP TABLE products CASCADE;
</pre><p> и все зависимые объекты, а также объекты, зависящие от них, будут удалены рекурсивно. В этом случае таблица orders останется, а удалено будет только её ограничение внешнего ключа. Удаление не распространится на другие объекты, так как ни один объект не зависит от этого ограничения. (Если вы хотите проверить, что произойдёт при выполнении <code class="command">DROP ... CASCADE</code>, запустите <code class="command">DROP</code> без <code class="literal">CASCADE</code> и прочитайте <code class="literal">ПОДРОБНОСТИ</code> (DETAIL).)</p><p>Почти все команды <code class="command">DROP</code> в <span class="productname">PostgreSQL</span> поддерживают указание <code class="literal">CASCADE</code>. Конечно, вид возможных зависимостей зависит от типа объекта. Вы также можете написать <code class="literal">RESTRICT</code> вместо <code class="literal">CASCADE</code>, чтобы включить поведение по умолчанию, когда объект можно удалить, только если от него не зависят никакие другие.</p><div class="note"><h3 class="title">Примечание</h3><p>Стандарт SQL требует явного указания <code class="literal">RESTRICT</code> или <code class="literal">CASCADE</code> в команде <code class="command">DROP</code>. Но это требование на самом деле не выполняется ни в одной СУБД, при этом одни системы по умолчанию подразумевают <code class="literal">RESTRICT</code>, а другие — <code class="literal">CASCADE</code>.</p></div><p>Если в команде <code class="command">DROP</code> перечисляются несколько объектов, <code class="literal">CASCADE</code> требуется указывать, только когда есть зависимости вне заданной группы. Например, в команде <code class="literal">DROP TABLE tab1, tab2</code> при наличии внешнего ключа, ссылающегося на <code class="literal">tab1</code> из <code class="literal">tab2</code>, можно не указывать <code class="literal">CASCADE</code>, чтобы она выполнилась успешно.</p><p>Для пользовательских функций или процедур, тело которых задано строковой константой, <span class="productname">PostgreSQL</span> отслеживает зависимости, связанные с внешне видимыми свойствами функции, такими как типы аргументов и результата, но <span class="emphasis"><em>не</em></span> зависимости, которые могут быть выявлены только при анализе тела функции. В качестве примера рассмотрите следующий сценарий: </p><pre class="programlisting">CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow',
                             'green', 'blue', 'purple');

CREATE TABLE my_colors (color rainbow, note text);

CREATE FUNCTION get_color_note (rainbow) RETURNS text AS
  'SELECT note FROM my_colors WHERE color = $1'
  LANGUAGE SQL;</pre><p> (Описание функций языка SQL можно найти в <a class="xref" href="xfunc-sql.html" title="38.5. Функции на языке запросов (SQL)">Разделе 38.5</a>.) <span class="productname">PostgreSQL</span> будет понимать, что функция <code class="function">get_color_note</code> зависит от типа <code class="type">rainbow</code>: при удалении типа будет принудительно удалена функция, так как тип её аргумента оказывается неопределённым. Но <span class="productname">PostgreSQL</span> не будет учитывать зависимость <code class="function">get_color_note</code> от таблицы <code class="structname">my_colors</code> и не удалит функцию при удалении таблицы. Но у этого подхода есть не только минус, но и плюс. В случае отсутствия таблицы эта функция останется рабочей в некотором смысле: хотя при попытке выполнить её возникнет ошибка, но при создании новой таблицы с тем же именем функция снова будет работать.</p><p>С другой стороны, при определении функции или процедуры в стиле стандарта SQL её тело разбирается, и все зависимости, распознаваемые синтаксическим анализатором, сохраняются. Таким образом, если записать приведённую выше функцию как </p><pre class="programlisting">CREATE FUNCTION get_color_note (rainbow) RETURNS text
BEGIN ATOMIC
  SELECT note FROM my_colors WHERE color = $1;
END;</pre><p>, то будет известна зависимость функции от таблицы <code class="structname">my_colors</code> и команда <code class="command">DROP</code> её обработает.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ddl-others.html" title="5.13. Другие объекты баз данных">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="ddl.html" title="Глава 5. Определение данных">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="dml.html" title="Глава 6. Модификация данных">След.</a></td></tr><tr><td width="40%" align="left" valign="top">5.13. Другие объекты баз данных </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> Глава 6. Модификация данных</td></tr></table></div></body></html>