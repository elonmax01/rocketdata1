<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>pgbench</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="app-pgbasebackup.html" title="pg_basebackup" /><link rel="next" href="app-pgconfig.html" title="pg_config" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center"><span class="application">pgbench</span></th></tr><tr><td width="10%" align="left"><a accesskey="p" href="app-pgbasebackup.html" title="pg_basebackup">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="reference-client.html" title="Клиентские приложения PostgreSQL">Наверх</a></td><th width="60%" align="center">Клиентские приложения PostgreSQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="app-pgconfig.html" title="pg_config">След.</a></td></tr></table><hr /></div><div class="refentry" id="PGBENCH"><div class="titlepage"></div><a id="id-1.9.4.11.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle"><span class="application">pgbench</span></span></h2><p>pgbench — запустить тест производительности <span class="productname">PostgreSQL</span></p></div><div class="refsynopsisdiv"><h2>Синтаксис</h2><div class="cmdsynopsis"><p id="id-1.9.4.11.4.1"><code class="command">pgbench</code>  <code class="option">-i</code>  [<em class="replaceable"><code>параметр</code></em>...] [<em class="replaceable"><code>имя_бд</code></em>]</p></div><div class="cmdsynopsis"><p id="id-1.9.4.11.4.2"><code class="command">pgbench</code> [<em class="replaceable"><code>параметр</code></em>...] [<em class="replaceable"><code>имя_бд</code></em>]</p></div></div><div class="refsect1" id="id-1.9.4.11.5"><h2>Описание</h2><p><span class="application">pgbench</span> — это простая программа для запуска тестов производительности <span class="productname">PostgreSQL</span>. Она многократно выполняет одну последовательность команд, возможно в параллельных сеансах базы данных, а затем вычисляет среднюю скорость транзакций (число транзакций в секунду). По умолчанию <span class="application">pgbench</span> тестирует сценарий, примерно соответствующий TPC-B, который состоит из пяти команд <code class="command">SELECT</code>, <code class="command">UPDATE</code> и <code class="command">INSERT</code> в одной транзакции. Однако вы можете легко протестировать и другие сценарии, написав собственные скрипты транзакций.</p><p>Типичный вывод <span class="application">pgbench</span> выглядит так: </p><pre class="screen">
transaction type: &lt;builtin: TPC-B (sort of)&gt;
scaling factor: 10
query mode: simple
number of clients: 10
number of threads: 1
maximum number of tries: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
number of failed transactions: 0 (0.000%)
latency average = 11.013 ms
latency stddev = 7.351 ms
initial connection time = 45.758 ms
tps = 896.967014 (without initial connection time)
</pre><p> В первых семи строках выводятся значения некоторых самых важных параметров. В шестой строке выводится максимальное число повторов транзакций с ошибками сериализации или взаимоблокировки (за подробностями обратитесь к <a class="xref" href="pgbench.html#FAILURES-AND-RETRIES" title="Повторы и отказы из-за ошибок сериализации/взаимоблокировки">Повторы и отказы из-за ошибок сериализации/взаимоблокировки</a>). В восьмой строке показывается количество выполненных и запланированных транзакций (произведение числа клиентов и числа транзакций для одного клиента); эти количества будут различаться, только если выполнение завершится досрочно или какие-либо команды SQL завершатся ошибкой. (В режиме <code class="option">-T</code> выводится только число фактически выполненных транзакций.) В следующей строке выводится количество транзакций, не выполненных из-за ошибок сериализации или взаимоблокировок (за подробностями обратитесь к <a class="xref" href="pgbench.html#FAILURES-AND-RETRIES" title="Повторы и отказы из-за ошибок сериализации/взаимоблокировки">Повторы и отказы из-за ошибок сериализации/взаимоблокировки</a>). В последней строке показывается число транзакций в секунду.</p><p>Для запускаемого по умолчанию теста типа TPC-B требуется предварительно подготовить определённые таблицы. Чтобы создать и наполнить эти таблицы, следует запустить <span class="application">pgbench</span> с ключом <code class="option">-i</code> (инициализировать). (Если вы применяете нестандартный скрипт, это не требуется, но тем не менее нужно подготовить конфигурацию, нужную вашему тесту.) Запуск инициализации выглядит так: </p><pre class="programlisting">pgbench -i [<span class="optional"> <em class="replaceable"><code>другие-параметры</code></em> </span>] <em class="replaceable"><code>имя_базы</code></em></pre><p> где <em class="replaceable"><code>имя_базы</code></em> — имя уже существующей базы, в которой будет проводиться тест. (Чтобы указать, как подключиться к серверу баз данных, вы также можете добавить параметры <code class="option">-h</code>, <code class="option">-p</code> и/или <code class="option">-U</code>.)</p><div class="caution"><h3 class="title">Внимание</h3><p><code class="literal">pgbench -i</code> создаёт четыре таблицы <code class="structname">pgbench_accounts</code>, <code class="structname">pgbench_branches</code>, <code class="structname">pgbench_history</code> и <code class="structname">pgbench_tellers</code>, предварительно уничтожая существующие таблицы с этими именами. Если вы вдруг используете эти имена в своей базе данных, обязательно переключитесь на другую базу!</p></div><p>С <span class="quote">«<span class="quote">коэффициентом масштаба</span>»</span>, по умолчанию равным 1, эти таблицы изначально содержат такое количество строк: </p><pre class="screen">
table                   # of rows
---------------------------------
pgbench_branches        1
pgbench_tellers         10
pgbench_accounts        100000
pgbench_history         0
</pre><p> Эти числа можно (и в большинстве случаев даже нужно) увеличить, воспользовавшись параметром <code class="option">-s</code> (коэффициент масштаба). При этом также может быть полезен ключ <code class="option">-F</code> (фактор заполнения).</p><p>Подготовив требуемую конфигурацию, можно запустить тест производительности командой без <code class="option">-i</code>, то есть: </p><pre class="programlisting">pgbench [<span class="optional"> <em class="replaceable"><code>параметры</code></em> </span>] <em class="replaceable"><code>имя_базы</code></em></pre><p> Практически во всех случаях, чтобы получить полезные результаты, необходимо передать какие-либо дополнительные параметры. Наиболее важные параметры: <code class="option">-c</code> (число клиентов), <code class="option">-t</code> (число транзакций), <code class="option">-T</code> (длительность) и <code class="option">-f</code> (файл со скриптом). Полный список параметров приведён ниже.</p></div><div class="refsect1" id="id-1.9.4.11.6"><h2>Параметры</h2><p>Следующий список разделён на три подраздела: одни параметры используются при инициализации базы данных, другие при проведении тестирования, а третьи в обоих случаях.</p><div class="refsect2" id="PGBENCH-INIT-OPTIONS"><h3>Параметры инициализации</h3><p><span class="application">pgbench</span> принимает следующие аргументы командной строки для инициализации: </p><div class="variablelist"><dl class="variablelist"><dt id="PGBENCH-OPTION-DBNAME"><span class="term"><em class="replaceable"><code>имя_бд</code></em></span> <a href="#PGBENCH-OPTION-DBNAME" class="id_link">#</a></dt><dd><p>Указывает имя базы, в которой будет проводиться тест. Если имя не задано, то используется значение переменной окружения <code class="envar">PGDATABASE</code>. Если и переменная не задана, то в качестве имени базы будет взято имя пользователя, под которым осуществляется подключение.</p></dd><dt id="PGBENCH-OPTION-INITIALIZE"><span class="term"><code class="option">-i</code><br /></span><span class="term"><code class="option">--initialize</code></span> <a href="#PGBENCH-OPTION-INITIALIZE" class="id_link">#</a></dt><dd><p>Требуется для вызова режима инициализации.</p></dd><dt id="PGBENCH-OPTION-INIT-STEPS"><span class="term"><code class="option">-I <em class="replaceable"><code>этапы_инициализации</code></em></code><br /></span><span class="term"><code class="option">--init-steps=<em class="replaceable"><code>этапы_инициализации</code></em></code></span> <a href="#PGBENCH-OPTION-INIT-STEPS" class="id_link">#</a></dt><dd><p>Выполнять только выбранные из всех обычных подготовительных этапов. В параметре <em class="replaceable"><code>этапы_инициализации</code></em> отдельные символы для каждого этапа выбирают, какие этапы должны выполняться. Все этапы выполняются в определённом порядке. Список этапов по умолчанию: <code class="literal">dtgvp</code>. Полный перечень подготовительных этапов: </p><div class="variablelist"><dl class="variablelist"><dt id="PGBENCH-OPTION-INIT-STEPS-D"><span class="term"><code class="literal">d</code> (Drop, удалить)</span> <a href="#PGBENCH-OPTION-INIT-STEPS-D" class="id_link">#</a></dt><dd><p>Удалить все существующие таблицы <span class="application">pgbench</span>.</p></dd><dt id="PGBENCH-OPTION-INIT-STEPS-T"><span class="term"><code class="literal">t</code> (create Tables, создать таблицы)</span> <a href="#PGBENCH-OPTION-INIT-STEPS-T" class="id_link">#</a></dt><dd><p>Создать таблицы, используемые стандартным сценарием <span class="application">pgbench</span>, а именно: <code class="structname">pgbench_accounts</code>, <code class="structname">pgbench_branches</code>, <code class="structname">pgbench_history</code> и <code class="structname">pgbench_tellers</code>.</p></dd><dt id="PGBENCH-OPTION-INIT-STEPS-G"><span class="term"><code class="literal">g</code> или <code class="literal">G</code> (Generate data, сгенерировать данные на стороне клиента или на стороне сервера)</span> <a href="#PGBENCH-OPTION-INIT-STEPS-G" class="id_link">#</a></dt><dd><p>Сгенерировать данные и загрузить их в стандартные таблицы, заменив все уже существующие данные.</p><p>С ключом <code class="literal">g</code> (выбирающим генерирование данных на стороне клиента), данные формируются в клиентском коде <code class="command">pgbench</code>, а затем передаются на сервер. При этом соединение клиент/сервер нагружается командой <code class="command">COPY</code>. С <span class="productname">PostgreSQL</span> версии 14 или выше <code class="command">pgbench</code> использует параметр FREEZE для ускорения последующей операции <code class="command">VACUUM</code>, если не применяется секционирование. Когда с ключом <code class="literal">g</code> генерируются данные для таблицы <code class="structname">pgbench_accounts</code>, после каждых 100000 строк выдаётся сообщение о прогрессе.</p><p>С ключом <code class="literal">G</code> (выбирающим генерирование данных на стороне сервера), клиентский код <code class="command">pgbench</code> передаёт на сервер только небольшие запросы, а собственно формированием данных занимается сервер. В этом случае сетевое соединение не нагружается, но возрастает нагрузка на сервер. При генерировании данных с ключом <code class="literal">G</code> никакие сообщения о ходе операции не выдаются.</p><p>По умолчанию при инициализации базы данные генерируются на стороне клиента (то есть подразумевается ключ <code class="literal">g</code>).</p></dd><dt id="PGBENCH-OPTION-INIT-STEPS-V"><span class="term"><code class="literal">v</code> (Vacuum, очистка)</span> <a href="#PGBENCH-OPTION-INIT-STEPS-V" class="id_link">#</a></dt><dd><p>Вызывать <code class="command">VACUUM</code> для стандартных таблиц.</p></dd><dt id="PGBENCH-OPTION-INIT-STEPS-P"><span class="term"><code class="literal">p</code> (create Primary keys, создать первичные ключи)</span> <a href="#PGBENCH-OPTION-INIT-STEPS-P" class="id_link">#</a></dt><dd><p>Создать первичные ключи в стандартных таблицах.</p></dd><dt id="PGBENCH-OPTION-INIT-STEPS-F"><span class="term"><code class="literal">f</code> (create Foreign keys, создать внешние ключи)</span> <a href="#PGBENCH-OPTION-INIT-STEPS-F" class="id_link">#</a></dt><dd><p>Создать ограничения внешних ключей между стандартными таблицами. (Заметьте, что это действие по умолчанию не выполняется.)</p></dd></dl></div></dd><dt id="PGBENCH-OPTION-FILLFACTOR"><span class="term"><code class="option">-F</code> <em class="replaceable"><code>фактор_заполнения</code></em><br /></span><span class="term"><code class="option">--fillfactor=</code><em class="replaceable"><code>фактор_заполнения</code></em></span> <a href="#PGBENCH-OPTION-FILLFACTOR" class="id_link">#</a></dt><dd><p>Создать таблицы <code class="structname">pgbench_accounts</code>, <code class="structname">pgbench_tellers</code> и <code class="structname">pgbench_branches</code> с заданным фактором заполнения. Значение по умолчанию — 100.</p></dd><dt id="PGBENCH-OPTION-NO-VACUUM-INIT"><span class="term"><code class="option">-n</code><br /></span><span class="term"><code class="option">--no-vacuum</code></span> <a href="#PGBENCH-OPTION-NO-VACUUM-INIT" class="id_link">#</a></dt><dd><p>Не выполнять очистку во время инициализации. (Этот параметр выключает этап инициализации <code class="literal">v</code>, даже если он был указан в <code class="option">-I</code>.)</p></dd><dt id="PGBENCH-OPTION-QUIET"><span class="term"><code class="option">-q</code><br /></span><span class="term"><code class="option">--quiet</code></span> <a href="#PGBENCH-OPTION-QUIET" class="id_link">#</a></dt><dd><p>Переключить вывод в немногословный режим, когда выводится только одно сообщение о прогрессе в 5 секунд. В режиме по умолчанию одно сообщение выводится на каждые 100000 строк, при этом за секунду обычно выводится довольно много строк (особенно на хорошем оборудовании).</p><p>Этот параметр не оказывает влияния, если в <code class="option">-I</code> выбран вариант <code class="literal">G</code>.</p></dd><dt id="PGBENCH-OPTION-SCALE-INIT"><span class="term"><code class="option">-s</code> <em class="replaceable"><code>коэффициент_масштаба</code></em><br /></span><span class="term"><code class="option">--scale=</code><em class="replaceable"><code>коэффициент_масштаба</code></em></span> <a href="#PGBENCH-OPTION-SCALE-INIT" class="id_link">#</a></dt><dd><p>Умножить число генерируемых строк на заданный коэффициент. Например, с ключом <code class="literal">-s 100</code> в таблицу <code class="structname">pgbench_accounts</code> будут записаны 10 000 000 строк. Значение по умолчанию — 1. При коэффициенте, равном 20 000 или больше, столбцы, содержащие идентификаторы счетов (столбцы <code class="structfield">aid</code>), перейдут к большим целым числам (типу <code class="type">bigint</code>), чтобы в них могли уместиться все возможные значения идентификаторов.</p></dd><dt id="PGBENCH-OPTION-FOREIGN-KEYS"><span class="term"><code class="option">--foreign-keys</code></span> <a href="#PGBENCH-OPTION-FOREIGN-KEYS" class="id_link">#</a></dt><dd><p>Создать ограничения внешних ключей между стандартными таблицами. (Этот ключ добавляет этап <code class="literal">f</code> к последовательности подготовительных этапов, если он отсутствует.)</p></dd><dt id="PGBENCH-OPTION-INDEX-TABLESPACE"><span class="term"><code class="option">--index-tablespace=<em class="replaceable"><code>табл_пространство_индексов</code></em></code></span> <a href="#PGBENCH-OPTION-INDEX-TABLESPACE" class="id_link">#</a></dt><dd><p>Создать индексы в указанном табличном пространстве, а не в пространстве по умолчанию.</p></dd><dt id="PGBENCH-OPTION-PARTITION-METHOD"><span class="term"><code class="option">--partition-method=<em class="replaceable"><code>ИМЯ</code></em></code></span> <a href="#PGBENCH-OPTION-PARTITION-METHOD" class="id_link">#</a></dt><dd><p>Создать секционированную таблицу <code class="literal">pgbench_accounts</code>, применив метод <em class="replaceable"><code>ИМЯ</code></em> (это может быть <code class="literal">range</code> или <code class="literal">hash</code>). Для использования этого параметра необходимо, чтобы было задано ненулевое значение <code class="option">--partitions</code>. Если этот параметр не указывается, подразумевается метод <code class="literal">range</code>.</p></dd><dt id="PGBENCH-OPTION-PARTITIONS"><span class="term"><code class="option">--partitions=<em class="replaceable"><code>ЧИСЛО</code></em></code></span> <a href="#PGBENCH-OPTION-PARTITIONS" class="id_link">#</a></dt><dd><p>Создать секционированную таблицу <code class="literal">pgbench_accounts</code> с заданным <em class="replaceable"><code>ЧИСЛОМ</code></em> секций примерно равного размера в соответствии с масштабированным количеством счетов. По умолчанию подразумевается число <code class="literal">0</code>, то есть таблица не секционируется.</p></dd><dt id="PGBENCH-OPTION-TABLESPACE"><span class="term"><code class="option">--tablespace=<em class="replaceable"><code>табличное_пространство</code></em></code></span> <a href="#PGBENCH-OPTION-TABLESPACE" class="id_link">#</a></dt><dd><p>Создать таблицы в указанном табличном пространстве, а не в пространстве по умолчанию.</p></dd><dt id="PGBENCH-OPTION-UNLOGGED-TABLES"><span class="term"><code class="option">--unlogged-tables</code></span> <a href="#PGBENCH-OPTION-UNLOGGED-TABLES" class="id_link">#</a></dt><dd><p>Создать все таблицы как нежурналируемые, а не как постоянные таблицы.</p></dd></dl></div></div><div class="refsect2" id="PGBENCH-RUN-OPTIONS"><h3>Параметры тестирования производительности</h3><p><span class="application">pgbench</span> принимает следующие аргументы командной строки для тестирования производительности: </p><div class="variablelist"><dl class="variablelist"><dt id="PGBENCH-OPTION-BUILTIN"><span class="term"><code class="option">-b</code> <em class="replaceable"><code>имя_скрипта[@вес]</code></em><br /></span><span class="term"><code class="option">--builtin</code>=<em class="replaceable"><code>имя_скрипта[@вес]</code></em></span> <a href="#PGBENCH-OPTION-BUILTIN" class="id_link">#</a></dt><dd><p>Добавляет в список скриптов, которые будут выполняться, указанный встроенный скрипт. В число встроенных скриптов входят <code class="literal">tpcb-like</code>, <code class="literal">simple-update</code> и <code class="literal">select-only</code>. Также принимаются однозначные начала их имён. Со специальным именем <code class="literal">list</code> программа выводит список встроенных скриптов и немедленно завершается.</p><p>Дополнительно можно задать целочисленный вес после <code class="literal">@</code>, меняющий вероятность выбора этого скрипта относительно других. По умолчанию вес считается равным 1. Подробности следуют ниже.</p></dd><dt id="PGBENCH-OPTION-CLIENT"><span class="term"><code class="option">-c</code> <em class="replaceable"><code>клиенты</code></em><br /></span><span class="term"><code class="option">--client=</code><em class="replaceable"><code>клиенты</code></em></span> <a href="#PGBENCH-OPTION-CLIENT" class="id_link">#</a></dt><dd><p>Число имитируемых клиентов, то есть число одновременных сеансов базы данных. Значение по умолчанию — 1.</p></dd><dt id="PGBENCH-OPTION-CONNECT"><span class="term"><code class="option">-C</code><br /></span><span class="term"><code class="option">--connect</code></span> <a href="#PGBENCH-OPTION-CONNECT" class="id_link">#</a></dt><dd><p>Устанавливать новое подключение для каждой транзакции вместо одного для каждого клиента. Это полезно для оценивания издержек подключений.</p></dd><dt id="PGBENCH-OPTION-DEBUG"><span class="term"><code class="option">-d</code><br /></span><span class="term"><code class="option">--debug</code></span> <a href="#PGBENCH-OPTION-DEBUG" class="id_link">#</a></dt><dd><p>Выводить отладочные сообщения.</p></dd><dt id="PGBENCH-OPTION-DEFINE"><span class="term"><code class="option">-D</code> <em class="replaceable"><code>имя_переменной</code></em><code class="literal">=</code><em class="replaceable"><code>значение</code></em><br /></span><span class="term"><code class="option">--define=</code><em class="replaceable"><code>имя_переменной</code></em><code class="literal">=</code><em class="replaceable"><code>значение</code></em></span> <a href="#PGBENCH-OPTION-DEFINE" class="id_link">#</a></dt><dd><p>Определить переменную для пользовательского скрипта (см. ниже). Параметр <code class="option">-D</code> может добавляться неоднократно.</p></dd><dt id="PGBENCH-OPTION-FILE"><span class="term"><code class="option">-f</code> <em class="replaceable"><code>имя_файла[@вес]</code></em><br /></span><span class="term"><code class="option">--file=</code><em class="replaceable"><code>имя_файла[@вес]</code></em></span> <a href="#PGBENCH-OPTION-FILE" class="id_link">#</a></dt><dd><p>Добавить в список выполняемых скриптов скрипт транзакции из файла <em class="replaceable"><code>имя_файла</code></em>.</p><p>Дополнительно можно задать целочисленный вес после <code class="literal">@</code>, меняющий вероятность выбора этого скрипта относительно других. По умолчанию вес считается равным 1. (Если вам нужно передать имя скрипта, содержащее символ <code class="literal">@</code>, добавьте к такому имени вес, чтобы исключить неоднозначность прочтения, например <code class="literal">filen@me@1</code>.) Подробности следуют ниже.</p></dd><dt id="PGBENCH-OPTION-JOBS"><span class="term"><code class="option">-j</code> <em class="replaceable"><code>потоки</code></em><br /></span><span class="term"><code class="option">--jobs=</code><em class="replaceable"><code>потоки</code></em></span> <a href="#PGBENCH-OPTION-JOBS" class="id_link">#</a></dt><dd><p>Число рабочих потоков в <span class="application">pgbench</span>. Использовать нескольких потоков может быть полезно на многопроцессорных компьютерах. Клиенты распределяются по доступным потокам равномерно, насколько это возможно. Значение по умолчанию — 1.</p></dd><dt id="PGBENCH-OPTION-LOG"><span class="term"><code class="option">-l</code><br /></span><span class="term"><code class="option">--log</code></span> <a href="#PGBENCH-OPTION-LOG" class="id_link">#</a></dt><dd><p>Записать информацию о каждой транзакции в файл протокола. Подробности описаны ниже.</p></dd><dt id="PGBENCH-OPTION-LATENCY-LIMIT"><span class="term"><code class="option">-L</code> <em class="replaceable"><code>предел</code></em><br /></span><span class="term"><code class="option">--latency-limit=</code><em class="replaceable"><code>предел</code></em></span> <a href="#PGBENCH-OPTION-LATENCY-LIMIT" class="id_link">#</a></dt><dd><p>Транзакции, продолжающиеся дольше указанного <em class="replaceable"><code>предела</code></em> (в миллисекундах), подсчитываются и отмечаются отдельно, как <em class="firstterm">опаздывающие</em>.</p><p>В режиме ограничения скорости (<code class="option">--rate=...</code>) транзакции, которые отстают от графика более чем на заданный <em class="replaceable"><code>предел</code></em> (в мс) и поэтому никак не могут уложиться в отведённый интервал, не передаются серверу вовсе. Они подсчитываются и отмечаются отдельно как <em class="firstterm">пропущенные</em>.</p><p>Когда используется параметр <code class="option">--max-tries</code>, транзакция, прерванная из-за аномалии сериализации или взаимоблокировки, не будет повторяться, если общее время всех её повторений превышает <em class="replaceable"><code>предел</code></em> в миллисекундах. Чтобы ограничить только общее время повторений, а не их количество, установите значение <code class="literal">--max-tries=0</code>. По умолчанию параметр <code class="option">--max-tries</code> имеет значение 1, и транзакции с ошибками сериализации/взаимоблокировки не повторяются. Подробнее о повторных попытках выполнения таких транзакций рассказывается в <a class="xref" href="pgbench.html#FAILURES-AND-RETRIES" title="Повторы и отказы из-за ошибок сериализации/взаимоблокировки">Повторы и отказы из-за ошибок сериализации/взаимоблокировки</a>.</p></dd><dt id="PGBENCH-OPTION-PROTOCOL"><span class="term"><code class="option">-M</code> <em class="replaceable"><code>режим_запросов</code></em><br /></span><span class="term"><code class="option">--protocol=</code><em class="replaceable"><code>режим_запросов</code></em></span> <a href="#PGBENCH-OPTION-PROTOCOL" class="id_link">#</a></dt><dd><p>Протокол, выбираемый для передачи запросов на сервер: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">simple</code>: использовать простой протокол запросов.</p></li><li class="listitem"><p><code class="literal">extended</code>: использовать расширенный протокол запросов.</p></li><li class="listitem"><p><code class="literal">prepared</code>: использовать расширенный протокол запросов с подготовленными операторами.</p></li></ul></div><p> В режиме <code class="literal">prepared</code> <span class="application">pgbench</span> повторно использует результат разбора запроса, начиная со второй итерации, и поэтому работает быстрее, чем в других режимах.</p><p>По умолчанию выбирается простой протокол запросов. (За подробностями обратитесь к <a class="xref" href="protocol.html" title="Глава 55. Клиент-серверный протокол">Главе 55</a>.)</p></dd><dt id="PGBENCH-OPTION-NO-VACUUM-RUN"><span class="term"><code class="option">-n</code><br /></span><span class="term"><code class="option">--no-vacuum</code></span> <a href="#PGBENCH-OPTION-NO-VACUUM-RUN" class="id_link">#</a></dt><dd><p>Не производить очистку таблиц перед запуском теста. Этот параметр <span class="emphasis"><em>необходим</em></span>, если вы применяете собственный сценарий, не затрагивающий стандартные таблицы <code class="structname">pgbench_accounts</code>, <code class="structname">pgbench_branches</code>, <code class="structname">pgbench_history</code> и <code class="structname">pgbench_tellers</code>.</p></dd><dt id="PGBENCH-OPTION-SKIP-SOME-UPDATES"><span class="term"><code class="option">-N</code><br /></span><span class="term"><code class="option">--skip-some-updates</code></span> <a href="#PGBENCH-OPTION-SKIP-SOME-UPDATES" class="id_link">#</a></dt><dd><p>Запустить встроенный упрощённый скрипт simple-update. Краткий вариант записи <code class="option">-b simple-update</code>.</p></dd><dt id="PGBENCH-OPTION-PROGRESS"><span class="term"><code class="option">-P</code> <em class="replaceable"><code>сек</code></em><br /></span><span class="term"><code class="option">--progress=</code><em class="replaceable"><code>сек</code></em></span> <a href="#PGBENCH-OPTION-PROGRESS" class="id_link">#</a></dt><dd><p>Выводить отчёт о прогрессе через заданное число секунд (<em class="replaceable"><code>сек</code></em>). Выдаваемый отчёт включает время, прошедшее с момента запуска, скорость (в TPS) с момента предыдущего отчёта, а также среднее время ожидания транзакций, стандартное отклонение и количество неуспешных транзакций с момента последнего отчёта. В режиме ограничения скорости (<code class="option">-R</code>) время ожидания вычисляется относительно назначенного времени запуска транзакции, а не фактического времени её начала, так что оно включает и среднее время отставания от графика. Когда параметр <code class="option">--max-tries</code> включает повторение транзакций после ошибок сериализации/взаимоблокировок, в отчёт добавляется количество повторявшихся транзакций и общее число повторов.</p></dd><dt id="PGBENCH-OPTION-REPORT-LATENCIES"><span class="term"><code class="option">-r</code><br /></span><span class="term"><code class="option">--report-per-command</code></span> <a href="#PGBENCH-OPTION-REPORT-LATENCIES" class="id_link">#</a></dt><dd><p>Выдать следующую статистику по каждой команде после завершения теста: среднюю длительность выполнения операторов (время выполнения с точки зрения клиента), число отказов и повторений вследствие ошибок сериализации и взаимоблокировки в этой команде. Статистика повторений отображается в отчёте, только если параметр <code class="option">--max-tries</code> не равен 1.</p></dd><dt id="PGBENCH-OPTION-RATE"><span class="term"><code class="option">-R</code> <em class="replaceable"><code>скорость передачи</code></em><br /></span><span class="term"><code class="option">--rate=</code><em class="replaceable"><code>скорость передачи</code></em></span> <a href="#PGBENCH-OPTION-RATE" class="id_link">#</a></dt><dd><p>Выполнять транзакции, ориентируясь на заданную скорость, а не максимально быстро (по умолчанию). Скорость задаётся в транзакциях в секунду. Если заданная скорость превышает максимально возможную, это ограничение скорости не повлияет на результаты.</p><p>Для получения нужной скорости транзакции запускаются со случайными задержками, имеющими распределение Пуассона. При этом запланированное время запуска отсчитывается от начального времени, а не от завершения предыдущей транзакции. Это означает, что если какие-то транзакции отстанут от изначально рассчитанного времени завершения, всё же возможно, что последующие нагонят график.</p><p>В режиме ограничения скорости время ожидания транзакций, выводимое по итогам тестирования, вычисляется, исходя из запланированного времени запуска, так что в него входит время, которое очередная транзакция должна была ждать завершения предыдущей транзакции. Это время называется временем отклонения от графика, и его среднее и максимальное значения выводятся отдельно. Время ожидания транзакций с момента их фактического запуска, то есть время, потраченное на выполнение транзакций в базе данных, можно получить, если вычесть время отклонения от графика из времени ожидания транзакций.</p><p>Если ограничение <code class="option">--latency-limit</code> задаётся вместе с <code class="option">--rate</code>, транзакция может заведомо не вписываться в отведённое ей время, если предыдущая транзакция завершится слишком поздно, так как ожидаемое время окончания транзакции отсчитывается от времени запуска по графику. Такие транзакции не передаются серверу, а пропускаются и подсчитываются отдельно.</p><p>Большое значение отклонения от графика свидетельствует о том, что система не успевает выполнять транзакции с заданной скоростью и выбранным числом клиентов и потоков. Когда среднее время ожидания транзакции превышает запланированный интервал между транзакциями, каждая последующая транзакция будет отставать от графика, и чем дольше будет выполняться тестирование, тем больше будет отставание. Когда это наблюдается, нужно уменьшить скорость транзакций.</p></dd><dt id="PGBENCH-OPTION-SCALE-RUN"><span class="term"><code class="option">-s</code> <em class="replaceable"><code>коэффициент_масштаба</code></em><br /></span><span class="term"><code class="option">--scale=</code><em class="replaceable"><code>коэффициент_масштаба</code></em></span> <a href="#PGBENCH-OPTION-SCALE-RUN" class="id_link">#</a></dt><dd><p>Показать заданный коэффициент масштаба в выводе <span class="application">pgbench</span>. Для встроенных тестов это не требуется; корректный коэффициент масштаба будет получен в результате подсчёта строк в таблице <code class="structname">pgbench_branches</code>. Однако при использовании только нестандартных тестов (запускаемых с ключом <code class="option">-f</code>) без этого параметра в качестве коэффициента масштаба будет выводиться 1.</p></dd><dt id="PGBENCH-OPTION-SELECT-ONLY"><span class="term"><code class="option">-S</code><br /></span><span class="term"><code class="option">--select-only</code></span> <a href="#PGBENCH-OPTION-SELECT-ONLY" class="id_link">#</a></dt><dd><p>Запустить встроенный скрипт select-only (только выборка). Краткий вариант записи <code class="option">-b select-only</code>.</p></dd><dt id="PGBENCH-OPTION-TRANSACTIONS"><span class="term"><code class="option">-t</code> <em class="replaceable"><code>транзакции</code></em><br /></span><span class="term"><code class="option">--transactions=</code><em class="replaceable"><code>транзакции</code></em></span> <a href="#PGBENCH-OPTION-TRANSACTIONS" class="id_link">#</a></dt><dd><p>Число транзакций, которые будут выполняться каждым клиентом (по умолчанию 10).</p></dd><dt id="PGBENCH-OPTION-TIME"><span class="term"><code class="option">-T</code> <em class="replaceable"><code>секунды</code></em><br /></span><span class="term"><code class="option">--time=</code><em class="replaceable"><code>секунды</code></em></span> <a href="#PGBENCH-OPTION-TIME" class="id_link">#</a></dt><dd><p>Выполнять тест с ограничением по времени (в секундах), а не по числу транзакций для каждого клиента. Параметры <code class="option">-t</code> и <code class="option">-T</code> являются взаимоисключающими.</p></dd><dt id="PGBENCH-OPTION-VACUUM-ALL"><span class="term"><code class="option">-v</code><br /></span><span class="term"><code class="option">--vacuum-all</code></span> <a href="#PGBENCH-OPTION-VACUUM-ALL" class="id_link">#</a></dt><dd><p>Очищать все четыре стандартные таблицы перед запуском теста. Без параметров <code class="option">-n</code> и <code class="option">-v</code> <span class="application">pgbench</span> будет очищать от старых записей таблицы <code class="structname">pgbench_tellers</code> и <code class="structname">pgbench_branches</code>, а также опустошать <code class="structname">pgbench_history</code>.</p></dd><dt id="PGBENCH-OPTION-AGGREGATE-INTERVAL"><span class="term"><code class="option">--aggregate-interval=<em class="replaceable"><code>секунды</code></em></code></span> <a href="#PGBENCH-OPTION-AGGREGATE-INTERVAL" class="id_link">#</a></dt><dd><p>Длительность интервала агрегации (в секундах). Может использоваться только с ключом <code class="option">-l</code>. С данным параметром в протокол выводится сводка по интервалам, как описано ниже.</p></dd><dt id="PGBENCH-OPTION-FAILURES-DETAILED"><span class="term"><code class="option">--failures-detailed</code></span> <a href="#PGBENCH-OPTION-FAILURES-DETAILED" class="id_link">#</a></dt><dd><p>Выдавать информацию об ошибках в протоколе по транзакциям и в протоколе с агрегированием, а также в основном отчёте и в отчётах по скриптам, группируя её по типам: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>ошибки сериализации;</p></li><li class="listitem"><p>ошибки взаимоблокировки;</p></li></ul></div><p> За подробностями обратитесь к <a class="xref" href="pgbench.html#FAILURES-AND-RETRIES" title="Повторы и отказы из-за ошибок сериализации/взаимоблокировки">Повторы и отказы из-за ошибок сериализации/взаимоблокировки</a>.</p></dd><dt id="PGBENCH-OPTION-LOG-PREFIX"><span class="term"><code class="option">--log-prefix=<em class="replaceable"><code>префикс</code></em></code></span> <a href="#PGBENCH-OPTION-LOG-PREFIX" class="id_link">#</a></dt><dd><p>Задать префикс имён файлов для файлов протоколов, создаваемых с ключом <code class="option">--log</code>. Префикс по умолчанию — <code class="literal">pgbench_log</code>.</p></dd><dt id="PGBENCH-OPTION-MAX-TRIES"><span class="term"><code class="option">--max-tries=<em class="replaceable"><code>число_попыток</code></em></code></span> <a href="#PGBENCH-OPTION-MAX-TRIES" class="id_link">#</a></dt><dd><p>Разрешить повторение транзакций с ошибками сериализации/взаимоблокировки и установить максимальное число попыток выполнения транзакций. Этот параметр можно комбинировать с параметром <code class="option">--latency-limit</code>, который ограничивает общее время всех попыток для транзакции; также заметьте, что нельзя выбрать неограниченное количество попыток (<code class="literal">--max-tries=0</code>), не определив <code class="option">--latency-limit</code> или <code class="option">--time</code>. Значение по умолчанию — 1, то есть транзакции с ошибками сериализации/взаимоблокировки повторяться не будут. Подробнее о повторении таких транзакций рассказывается в <a class="xref" href="pgbench.html#FAILURES-AND-RETRIES" title="Повторы и отказы из-за ошибок сериализации/взаимоблокировки">Повторы и отказы из-за ошибок сериализации/взаимоблокировки</a>.</p></dd><dt id="PGBENCH-OPTION-PROGRESS-TIMESTAMP"><span class="term"><code class="option">--progress-timestamp</code></span> <a href="#PGBENCH-OPTION-PROGRESS-TIMESTAMP" class="id_link">#</a></dt><dd><p>При отображении прогресса (с параметром <code class="option">-P</code>) выводить текущее время (в формате Unix), а не количество секунд от начала запуска. Время задаётся в секундах с точностью до миллисекунд. Это помогает сравнивать журналы, записываемые разными средствами.</p></dd><dt id="PGBENCH-OPTION-RANDOM-SEED"><span class="term"><code class="option">--random-seed=</code><em class="replaceable"><code>затравка</code></em></span> <a href="#PGBENCH-OPTION-RANDOM-SEED" class="id_link">#</a></dt><dd><p>Установить затравку для генератора случайных чисел. Инициализирует генератор случайных чисел, который затем выдаёт последовательность начальных состояний отдельных генераторов для каждого потока. <em class="replaceable"><code>затравка</code></em> может принимать следующие значения: <code class="literal">time</code> (по умолчанию, затравка базируется на текущем времени), <code class="literal">rand</code> (задействовать надёжный генератор случайных чисел или выдать ошибку, если он отсутствует) или беззнаковое десятичное число. Генератор случайных чисел может вызываться явно из скрипта pgbench (функциями <code class="literal">random...</code>) или неявно (например, для планирования выполнения транзакций с ключом <code class="option">--rate</code>). В случае установки значения явным образом оно выводится в терминале. Любое значение, допустимое в качестве <em class="replaceable"><code>затравки</code></em>, можно также задать в переменной окружения <code class="literal">PGBENCH_RANDOM_SEED</code>. Чтобы заданная затравка применялась во всех возможных случаях использования, задайте этот параметр первым или установите переменную окружения.</p><p>Явное указание определённой затравки позволяет точно воспроизвести выполнение <code class="command">pgbench</code> в части использования случайных чисел. Так как случайное состояние поддерживается внутри потока, это означает, что выполнение <code class="command">pgbench</code> при одинаковых запусках повторится в точности, если один поток используется одним клиентом и отсутствуют внешние зависимости или зависимости от данных. Со статистической точки зрения точное воспроизведение выполнения нежелательно, так как это может скрыть вариативность производительности или показать завышенную скорость, например из-за попадания в одни и те же страницы данных. Однако это может быть очень полезно для отладки, например, для повторения редкого сценария, приводящего к ошибке. Используйте данную возможность обдуманно.</p></dd><dt id="PGBENCH-OPTION-SAMPLING-RATE"><span class="term"><code class="option">--sampling-rate=<em class="replaceable"><code>скорость передачи</code></em></code></span> <a href="#PGBENCH-OPTION-SAMPLING-RATE" class="id_link">#</a></dt><dd><p>Частота выборки для записи данных в протокол, изменяя которую можно уменьшить объём протокола. При указании этого параметра в протокол выводится информация только о заданном проценте транзакций. Со значением 1.0 в нём будут отмечаться все транзакции, а с 0.05 только 5%.</p><p>Обрабатывая протокол, не забудьте учесть частоту выборки. Например, вычисляя скорость (TPS), вам нужно будет соответственно умножить содержащиеся в нём числа (например, с частотой выборки 0.01 вы получите только 1/100 фактической скорости).</p></dd><dt id="PGBENCH-OPTION-SHOW-SCRIPT"><span class="term"><code class="option">--show-script=</code><em class="replaceable"><code>имя_скрипта</code></em></span> <a href="#PGBENCH-OPTION-SHOW-SCRIPT" class="id_link">#</a></dt><dd><p>Вывести код встроенного скрипта <em class="replaceable"><code>имя_скрипта</code></em> в stderr и сразу завершиться.</p></dd><dt id="PGBENCH-OPTION-VERBOSE-ERRORS"><span class="term"><code class="option">--verbose-errors</code></span> <a href="#PGBENCH-OPTION-VERBOSE-ERRORS" class="id_link">#</a></dt><dd><p>Выводить сообщения обо всех ошибках сериализации/взаимоблокировки и отказах (ошибках, после которых транзакция не повторяется) с информацией о том, как ограничиваются повторения и насколько достигается ограничение. (Учтите, что в этом случае объём вывода может значительно увеличиться.) За подробностями обратитесь к <a class="xref" href="pgbench.html#FAILURES-AND-RETRIES" title="Повторы и отказы из-за ошибок сериализации/взаимоблокировки">Повторы и отказы из-за ошибок сериализации/взаимоблокировки</a>.</p></dd></dl></div></div><div class="refsect2" id="PGBENCH-COMMON-OPTIONS"><h3>Общие параметры</h3><p>Программа <span class="application">pgbench</span> также принимает общие аргументы командой строки, определяющие параметры подключения: </p><div class="variablelist"><dl class="variablelist"><dt id="PGBENCH-OPTION-HOST"><span class="term"><code class="option">-h</code> <em class="replaceable"><code>компьютер</code></em><br /></span><span class="term"><code class="option">--host=</code><em class="replaceable"><code>компьютер</code></em></span> <a href="#PGBENCH-OPTION-HOST" class="id_link">#</a></dt><dd><p>Адрес сервера баз данных</p></dd><dt id="PGBENCH-OPTION-PORT"><span class="term"><code class="option">-p</code> <em class="replaceable"><code>порт</code></em><br /></span><span class="term"><code class="option">--port=</code><em class="replaceable"><code>порт</code></em></span> <a href="#PGBENCH-OPTION-PORT" class="id_link">#</a></dt><dd><p>Номер порта сервера баз данных</p></dd><dt id="PGBENCH-OPTION-USERNAME"><span class="term"><code class="option">-U</code> <em class="replaceable"><code>имя_пользователя</code></em><br /></span><span class="term"><code class="option">--username=</code><em class="replaceable"><code>имя_пользователя</code></em></span> <a href="#PGBENCH-OPTION-USERNAME" class="id_link">#</a></dt><dd><p>Имя пользователя для подключения</p></dd><dt id="PGBENCH-OPTION-VERSION"><span class="term"><code class="option">-V</code><br /></span><span class="term"><code class="option">--version</code></span> <a href="#PGBENCH-OPTION-VERSION" class="id_link">#</a></dt><dd><p>Вывести версию <span class="application">pgbench</span> и завершиться.</p></dd><dt id="PGBENCH-OPTION-HELP"><span class="term"><code class="option">-?</code><br /></span><span class="term"><code class="option">--help</code></span> <a href="#PGBENCH-OPTION-HELP" class="id_link">#</a></dt><dd><p>Вывести справку об аргументах командной строки <span class="application">pgbench</span> и завершиться.</p></dd></dl></div></div></div><div class="refsect1" id="id-1.9.4.11.7"><h2>Код завершения</h2><p>В случае успешного выполнения возвращается код 0. Код завершения 1 указывает на статичные проблемы, например ошибки в параметрах командной строки или внутренние ошибки, которые не должны происходить. В случае ошибок, возникающих на ранних этапах при запуске теста, например при сбое начального подключения, кодом завершения также будет 1. При возникновении ошибок во время выполнения, например при обращении к базе данных или выполнении скрипта, выдаётся код завершения 2. В последнем случае <span class="application">pgbench</span> выведет частичные результаты.</p></div><div class="refsect1" id="id-1.9.4.11.8"><h2>Переменные окружения</h2><div class="variablelist"><dl class="variablelist"><dt id="PGBENCH-ENVIRONMENT-PGDATABASE"><span class="term"><code class="envar">PGDATABASE</code><br /></span><span class="term"><code class="envar">PGHOST</code><br /></span><span class="term"><code class="envar">PGPORT</code><br /></span><span class="term"><code class="envar">PGUSER</code></span> <a href="#PGBENCH-ENVIRONMENT-PGDATABASE" class="id_link">#</a></dt><dd><p>Параметры подключения по умолчанию.</p></dd></dl></div><p>Эта утилита, как и большинство других утилит <span class="productname">PostgreSQL</span>, использует переменные среды, поддерживаемые <span class="application">libpq</span> (см. <a class="xref" href="libpq-envars.html" title="34.15. Переменные окружения">Раздел 34.15</a>).</p><p>Переменная окружения <code class="envar">PG_COLOR</code> управляет использованием цвета в диагностических сообщениях. Возможные значения: <code class="literal">always</code> (всегда), <code class="literal">auto</code> (автоматически) и <code class="literal">never</code> (никогда).</p></div><div class="refsect1" id="id-1.9.4.11.9"><h2>Замечания</h2><div class="refsect2" id="TRANSACTIONS-AND-SCRIPTS"><h3>Каково содержание <span class="quote">«<span class="quote">транзакции</span>»</span>, которую выполняет <span class="application">pgbench</span>?</h3><p>Программа <span class="application">pgbench</span> выполняет тестовые скрипты, выбирая их случайным образом из заданного списка. Это могут быть как встроенные скрипты, задаваемые аргументами <code class="option">-b</code>, так и пользовательские, задаваемые аргументами <code class="option">-f</code>. Для каждого скрипта можно задать относительный вес после <code class="literal">@</code>, чтобы скорректировать вероятность его выбора. По умолчанию вес считается равным <code class="literal">1</code>. Скрипты с весом <code class="literal">0</code> игнорируются.</p><p>Стандартный встроенный скрипт (также вызываемый с ключом <code class="option">-b tpcb-like</code>) выдаёт семь команд в транзакции со случайно выбранными <code class="literal">aid</code>, <code class="literal">tid</code>, <code class="literal">bid</code> и <code class="literal">delta</code>. Его сценарий написан по мотивам теста производительности TPC-B, но это не собственно TPC-B, потому он называется так.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><code class="literal">BEGIN;</code></p></li><li class="listitem"><p><code class="literal">UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;</code></p></li><li class="listitem"><p><code class="literal">SELECT abalance FROM pgbench_accounts WHERE aid = :aid;</code></p></li><li class="listitem"><p><code class="literal">UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;</code></p></li><li class="listitem"><p><code class="literal">UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;</code></p></li><li class="listitem"><p><code class="literal">INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);</code></p></li><li class="listitem"><p><code class="literal">END;</code></p></li></ol></div><p>При выборе встроенного скрипта <code class="literal">simple-update</code> (или указании <code class="option">-N</code>) шаги 4 и 5 исключаются из транзакции. Это позволяет избежать конкуренции при обращении к этим таблицам, но тест становится ещё менее похожим на TPC-B.</p><p>При выборе встроенного теста <code class="literal">select-only</code> (или указании <code class="option">-S</code>) выполняется только <code class="command">SELECT</code>.</p></div><div class="refsect2" id="id-1.9.4.11.9.3"><h3>Пользовательские скрипты</h3><p>Программа <span class="application">pgbench</span> поддерживает запуск пользовательских сценариев оценки производительности, позволяя заменять стандартный скрипт транзакции (описанный выше) скриптом, считываемым из файла (с параметром <code class="option">-f</code>). В этом случае <span class="quote">«<span class="quote">транзакцией</span>»</span> считается одно выполнение данного скрипта.</p><p>Файл скрипта содержит одну или несколько команд SQL, разделённых точкой с запятой. Пустые строки и строки, начинающиеся с <code class="literal">--</code>, игнорируются. В файлах скриптов также могут содержаться <span class="quote">«<span class="quote">метакоманды</span>»</span>, которые обрабатывает сама программа <span class="application">pgbench</span>, как описано ниже.</p><div class="note"><h3 class="title">Примечание</h3><p>До версии <span class="productname">PostgreSQL</span> 9.6, SQL-команды в файлах скриптов завершались символами перевода строки, и поэтому они не могли занимать несколько строк. Теперь для разделения последовательных команд SQL <span class="emphasis"><em>требуется</em></span> добавлять точку с запятой (хотя без неё можно обойтись в конце SQL-команды, за которой идёт метакоманда). Если вам нужно создать файл скрипта, работающий и со старыми версиями <span class="application">pgbench</span>, записывайте каждую команду SQL в отдельной строке и завершайте её точкой с запятой.</p><p>Предполагается, что скрипты pgbench не содержат незавершённых блоков SQL-транзакций. Если по достижении клиентом конца скрипта окажется, что блок последней транзакции не завершён, работа клиента будет прервана.</p></div><p>Для файлов скриптов реализован простой механизм подстановки переменных. Имя переменных должно состоять из букв (буквы могут быть не латинскими), подчёркиваний и цифр (но цифра не может быть первым символом). Переменные можно задать в командной строке параметрами <code class="option">-D</code>, описанными выше, или метакомандами, рассматриваемыми ниже. Помимо переменных, которые можно установить параметрами командной строки <code class="option">-D</code>, есть несколько автоматически устанавливаемых переменных; они перечислены в <a class="xref" href="pgbench.html#PGBENCH-AUTOMATIC-VARIABLES" title="Таблица 293. Автоматические переменные pgbench">Таблице 293</a>. Если значение этих переменных задаётся в параметре <code class="option">-D</code>, оно переопределяет автоматическое значение. Когда значение переменной определено, его можно вставить в команду SQL, написав <code class="literal">:</code><em class="replaceable"><code>имя_переменной</code></em>. Каждый клиентский сеанс, если их несколько, получает собственный набор переменных. В одном операторе <span class="application">pgbench</span> поддерживает до 255 ссылок на переменные.</p><div class="table" id="PGBENCH-AUTOMATIC-VARIABLES"><p class="title"><strong>Таблица 293. Автоматические переменные pgbench</strong></p><div class="table-contents"><table class="table" summary="Автоматические переменные pgbench" border="1"><colgroup><col class="col1" /><col class="col2" /></colgroup><thead><tr><th>Переменная</th><th>Описание</th></tr></thead><tbody><tr><td> <code class="literal">client_id</code> </td><td>уникальное число, идентифицирующее клиентский сеанс (начиная с нуля)</td></tr><tr><td> <code class="literal">default_seed</code> </td><td>затравка, по умолчанию используемая в функциях, вычисляющих хеш и псевдослучайные перестановки</td></tr><tr><td> <code class="literal">random_seed</code> </td><td>затравка генератора случайных чисел (в отсутствие переопределения с ключом <code class="option">-D</code>)</td></tr><tr><td> <code class="literal">scale</code> </td><td>текущий коэффициент масштаба</td></tr></tbody></table></div></div><br class="table-break" /><p>Метакоманды в скрипте начинаются с обратной косой черты (<code class="literal">\</code>) и обычно продолжаются до конца строки, хотя их можно переносить на следующую строку последовательностью символов: обратная косая, возврат каретки. Аргументы метакоманд разделяются пробелами. Поддерживаемые метакоманды представлены ниже:</p><div class="variablelist"><dl class="variablelist"><dt id="PGBENCH-METACOMMAND-GSET"><span class="term">
     <code class="literal">\gset [<em class="replaceable"><code>префикс</code></em>]</code>
     <code class="literal">\aset [<em class="replaceable"><code>префикс</code></em>]</code>
    </span> <a href="#PGBENCH-METACOMMAND-GSET" class="id_link">#</a></dt><dd><p>Эти команды могут применяться для завершения SQL-запросов вместо завершающей точки с запятой (<code class="literal">;</code>).</p><p>Когда используется команда <code class="literal">\gset</code>, ожидается, что предыдущий SQL-запрос возвратит одну строку; значения столбцов будут сохранены в переменные с именами столбцов, а если указан <em class="replaceable"><code>префикс</code></em>, он будет добавлен в эти имена.</p><p>Когда используется команда <code class="literal">\aset</code>, значения столбцов всех совмещённых SQL-запросов (разделённых <code class="literal">\;</code>) будут сохранены в переменные, названные по именам столбцов с добавлением <em class="replaceable"><code>префикса</code></em>, если он задан. Если запрос не возвращает в результате строки, присваивание не выполняется и в этом можно убедиться, проверив, существует ли переменная. Если запрос возвращает несколько строк, в переменных сохраняется последнее значение.</p><p>Команды <code class="literal">\gset</code> и <code class="literal">\aset</code> нельзя использовать в конвейерном режиме, так как ко времени, когда результаты запросов могут понадобиться команде, они ещё не будут готовы.</p><p>В следующем примере итоговый баланс счёта из первого запроса попадает в переменную <em class="replaceable"><code>abalance</code></em>, а целочисленные значения из третьего запроса попадают в переменные <em class="replaceable"><code>p_two</code></em> и <em class="replaceable"><code>p_three</code></em>. Результат второго запроса отбрасывается. Результаты двух последних запросов объединяются и сохраняются в переменных <em class="replaceable"><code>four</code></em> и <em class="replaceable"><code>five</code></em>. </p><pre class="programlisting">UPDATE pgbench_accounts
  SET abalance = abalance + :delta
  WHERE aid = :aid
  RETURNING abalance \gset
-- объединяет два запроса
SELECT 1 \;
SELECT 2 AS two, 3 AS three \gset p_
SELECT 4 AS four \; SELECT 5 AS five \aset</pre></dd><dt id="PGBENCH-METACOMMAND-IF-ELSE"><span class="term"><code class="literal">\if</code> <em class="replaceable"><code>выражение</code></em><br /></span><span class="term"><code class="literal">\elif</code> <em class="replaceable"><code>выражение</code></em><br /></span><span class="term"><code class="literal">\else</code><br /></span><span class="term"><code class="literal">\endif</code></span> <a href="#PGBENCH-METACOMMAND-IF-ELSE" class="id_link">#</a></dt><dd><p>Эта группа команд реализует вкладываемые условные блоки, подобные <a class="xref" href="app-psql.html#PSQL-METACOMMAND-IF"><code class="literal">\if</code> <em class="replaceable"><code>выражение</code></em></a> в <code class="literal">psql</code>. В качестве условных задаются те же выражения, что и в <code class="literal">\set</code>, при этом истинным считается любое ненулевое значение.</p></dd><dt id="PGBENCH-METACOMMAND-SET"><span class="term">
     <code class="literal">\set <em class="replaceable"><code>имя_переменной</code></em> <em class="replaceable"><code>выражение</code></em></code>
    </span> <a href="#PGBENCH-METACOMMAND-SET" class="id_link">#</a></dt><dd><p>Устанавливает для переменной <em class="replaceable"><code>имя_переменной</code></em> значение, вычисленное из <em class="replaceable"><code>выражения</code></em>. Выражение может содержать константу <code class="literal">NULL</code>, логические константы <code class="literal">TRUE</code> и <code class="literal">FALSE</code>, целочисленные константы (например, <code class="literal">5432</code>), константы с плавающей точкой (например, <code class="literal">3.14159</code>), ссылки на переменные <code class="literal">:</code><em class="replaceable"><code>имя_переменной</code></em>, <a class="link" href="pgbench.html#PGBENCH-BUILTIN-OPERATORS" title="Встроенные операторы">операторы</a> с обычными для SQL приоритетами и ассоциативностью, <a class="link" href="pgbench.html#PGBENCH-BUILTIN-FUNCTIONS" title="Встроенные функции">вызовы функций</a>, <a class="link" href="functions-conditional.html#FUNCTIONS-CASE" title="9.18.1. CASE">общие условные SQL-выражения <code class="token">CASE</code></a>, а также скобки.</p><p>Функции и большинство операторов возвращают <code class="literal">NULL</code> для аргументов <code class="literal">NULL</code>.</p><p>При проверке условия отличные от нуля числовые значения воспринимаются как <code class="literal">TRUE</code>, а числовые нулевые значения и <code class="literal">NULL</code> — как <code class="literal">FALSE</code>.</p><p>При переполнениях, вызванных слишком большими числами с плавающей точкой или целыми, а также целочисленными операциями (<code class="literal">+</code>, <code class="literal">-</code>, <code class="literal">*</code> и <code class="literal">/</code>), выдаются ошибки.</p><p>Если в конструкции <code class="token">CASE</code> отсутствует заключительное <code class="token">ELSE</code>, значением по умолчанию считается <code class="literal">NULL</code>.</p><p>Примеры: </p><pre class="programlisting">\set ntellers 10 * :scale
\set aid (1021 * random(1, 100000 * :scale)) % \
           (100000 * :scale) + 1
\set divx CASE WHEN :x &lt;&gt; 0 THEN :y/:x ELSE NULL END</pre></dd><dt id="PGBENCH-METACOMMAND-SLEEP"><span class="term">
     <code class="literal">\sleep <em class="replaceable"><code>номер</code></em> [ us | ms | s ]</code>
    </span> <a href="#PGBENCH-METACOMMAND-SLEEP" class="id_link">#</a></dt><dd><p>Приостанавливает выполнение скрипта на заданное число микросекунд (<code class="literal">us</code>), миллисекунд (<code class="literal">ms</code>) или секунд (<code class="literal">s</code>). Когда единицы не указываются, подразумеваются секунды. Здесь <em class="replaceable"><code>число</code></em> может быть целочисленной константой или ссылкой <code class="literal">:</code><em class="replaceable"><code>имя_переменной</code></em> на переменную с целочисленным значением.</p><p>Пример: </p><pre class="programlisting">\sleep 10 ms</pre></dd><dt id="PGBENCH-METACOMMAND-SETSHELL"><span class="term">
     <code class="literal">\setshell <em class="replaceable"><code>имя_переменной</code></em> <em class="replaceable"><code>команда</code></em> [ <em class="replaceable"><code>аргумент</code></em> ... ]</code>
    </span> <a href="#PGBENCH-METACOMMAND-SETSHELL" class="id_link">#</a></dt><dd><p>Присваивает переменной <em class="replaceable"><code>имя_переменной</code></em> результат команды оболочки <em class="replaceable"><code>команда</code></em> с указанными <em class="replaceable"><code>аргументами</code></em>. Эта команда должна просто выдать целочисленное значение в стандартный вывод.</p><p>Здесь <em class="replaceable"><code>команда</code></em> и каждый <em class="replaceable"><code>аргумент</code></em> может быть либо текстовой константой, либо ссылкой на переменную <code class="literal">:</code><em class="replaceable"><code>имя_переменной</code></em>. Если вы хотите записать <em class="replaceable"><code>аргумент</code></em>, начинающийся с двоеточия, добавьте перед <em class="replaceable"><code>аргументом</code></em> дополнительное двоеточие.</p><p>Пример: </p><pre class="programlisting">\setshell назначаемая_переменная команда строковый_аргумент :переменная ::строка_начинающаяся_двоеточием</pre></dd><dt id="PGBENCH-METACOMMAND-SHELL"><span class="term">
     <code class="literal">\shell <em class="replaceable"><code>команда</code></em> [ <em class="replaceable"><code>аргумент</code></em> ... ]</code>
    </span> <a href="#PGBENCH-METACOMMAND-SHELL" class="id_link">#</a></dt><dd><p>Действует так же, как и <code class="literal">\setshell</code>, но не учитывает результат команды.</p><p>Пример: </p><pre class="programlisting">\shell команда строковый_аргумент :переменная ::строка_начинающаяся_двоеточием</pre></dd><dt id="PGBENCH-METACOMMAND-PIPELINE"><span class="term"><code class="literal">\startpipeline</code><br /></span><span class="term"><code class="literal">\endpipeline</code></span> <a href="#PGBENCH-METACOMMAND-PIPELINE" class="id_link">#</a></dt><dd><p>Эти команды отделяют начало и конец конвейера SQL-команд. В конвейерном режиме команды передаются серверу, не дожидаясь результатов предыдущих команд. За подробностями обратитесь к <a class="xref" href="libpq-pipeline-mode.html" title="34.5. Конвейерный режим">Разделу 34.5</a>. Для конвейерного режима должен использоваться расширенный протокол запросов.</p></dd></dl></div></div><div class="refsect2" id="PGBENCH-BUILTIN-OPERATORS"><h3>Встроенные операторы</h3><p>Перечисленные в <a class="xref" href="pgbench.html#PGBENCH-OPERATORS" title="Таблица 294. Операторы pgbench">Таблице 294</a> арифметические, битовые и логические операторы, а также операторы сравнения встроены в <span class="application">pgbench</span> и могут применяться в выражениях в <a class="link" href="pgbench.html#PGBENCH-METACOMMAND-SET"><code class="literal">\set</code></a>. Эти операторы приведены в порядке возрастания их приоритета. Не считая явно отмеченных исключений, операторы с двумя числовыми аргументами будут выдавать результат в типе с плавающей точкой, если какой-либо аргумент имеет такой тип; в противном случае результат будет целочисленным.</p><div class="table" id="PGBENCH-OPERATORS"><p class="title"><strong>Таблица 294. Операторы pgbench</strong></p><div class="table-contents"><table class="table" summary="Операторы pgbench" border="1"><colgroup><col /></colgroup><thead><tr><th class="func_table_entry"><p class="func_signature">Оператор</p>
       <p>Описание</p>
       <p>Примеры</p></th></tr></thead><tbody><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>логическое_значение</code></em> <code class="literal">OR</code> <em class="replaceable"><code>логическое_значение</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>логическое_значение</code></em></code>
       </p>
       <p>Логическое ИЛИ</p>
       <p>
        <code class="literal">5 or 0</code>
        → <code class="returnvalue">TRUE</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>логическое_значение</code></em> <code class="literal">AND</code> <em class="replaceable"><code>логическое_значение</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>логическое_значение</code></em></code>
       </p>
       <p>Логическое И</p>
       <p>
        <code class="literal">3 and 0</code>
        → <code class="returnvalue">FALSE</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="literal">NOT</code> <em class="replaceable"><code>логическое_значение</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>логическое_значение</code></em></code>
       </p>
       <p>Логическое НЕ</p>
       <p>
        <code class="literal">not false</code>
        → <code class="returnvalue">TRUE</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>логическое_значение</code></em> <code class="literal">IS [NOT] (NULL|TRUE|FALSE)</code>
        → <code class="returnvalue"><em class="replaceable"><code>логическое_значение</code></em></code>
       </p>
       <p>Логические проверки значений</p>
       <p>
        <code class="literal">1 is null</code>
        → <code class="returnvalue">FALSE</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>значение</code></em> <code class="literal">ISNULL|NOTNULL</code>
        → <code class="returnvalue"><em class="replaceable"><code>логическое_значение</code></em></code>
       </p>
       <p>Проверки на NULL</p>
       <p>
        <code class="literal">1 notnull</code>
        → <code class="returnvalue">TRUE</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>номер</code></em> <code class="literal">=</code> <em class="replaceable"><code>номер</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>логическое_значение</code></em></code>
       </p>
       <p>Равно</p>
       <p>
        <code class="literal">5 = 4</code>
        → <code class="returnvalue">FALSE</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>номер</code></em> <code class="literal">&lt;&gt;</code> <em class="replaceable"><code>номер</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>логическое_значение</code></em></code>
       </p>
       <p>Не равно</p>
       <p>
        <code class="literal">5 &lt;&gt; 4</code>
        → <code class="returnvalue">TRUE</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>номер</code></em> <code class="literal">!=</code> <em class="replaceable"><code>номер</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>логическое_значение</code></em></code>
       </p>
       <p>Не равно</p>
       <p>
        <code class="literal">5 != 5</code>
        → <code class="returnvalue">FALSE</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>номер</code></em> <code class="literal">&lt;</code> <em class="replaceable"><code>номер</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>логическое_значение</code></em></code>
       </p>
       <p>Меньше</p>
       <p>
        <code class="literal">5 &lt; 4</code>
        → <code class="returnvalue">FALSE</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>номер</code></em> <code class="literal">&lt;=</code> <em class="replaceable"><code>номер</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>логическое_значение</code></em></code>
       </p>
       <p>Меньше или равно</p>
       <p>
        <code class="literal">5 &lt;= 4</code>
        → <code class="returnvalue">FALSE</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>номер</code></em> <code class="literal">&gt;</code> <em class="replaceable"><code>номер</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>логическое_значение</code></em></code>
       </p>
       <p>Больше</p>
       <p>
        <code class="literal">5 &gt; 4</code>
        → <code class="returnvalue">TRUE</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>номер</code></em> <code class="literal">&gt;=</code> <em class="replaceable"><code>номер</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>логическое_значение</code></em></code>
       </p>
       <p>Больше или равно</p>
       <p>
        <code class="literal">5 &gt;= 4</code>
        → <code class="returnvalue">TRUE</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>integer</code></em> <code class="literal">|</code> <em class="replaceable"><code>integer</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>integer</code></em></code>
       </p>
       <p>Битовое ИЛИ</p>
       <p>
        <code class="literal">1 | 2</code>
        → <code class="returnvalue">3</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>integer</code></em> <code class="literal">#</code> <em class="replaceable"><code>integer</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>integer</code></em></code>
       </p>
       <p>Битовое исключающее ИЛИ</p>
       <p>
        <code class="literal">1 # 3</code>
        → <code class="returnvalue">2</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>integer</code></em> <code class="literal">&amp;</code> <em class="replaceable"><code>integer</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>integer</code></em></code>
       </p>
       <p>Битовое И</p>
       <p>
        <code class="literal">1 &amp; 3</code>
        → <code class="returnvalue">1</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="literal">~</code> <em class="replaceable"><code>integer</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>integer</code></em></code>
       </p>
       <p>Битовое НЕ</p>
       <p>
        <code class="literal">~ 1</code>
        → <code class="returnvalue">-2</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>integer</code></em> <code class="literal">&lt;&lt;</code> <em class="replaceable"><code>integer</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>integer</code></em></code>
       </p>
       <p>Битовый сдвиг влево</p>
       <p>
        <code class="literal">1 &lt;&lt; 2</code>
        → <code class="returnvalue">4</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>integer</code></em> <code class="literal">&gt;&gt;</code> <em class="replaceable"><code>integer</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>integer</code></em></code>
       </p>
       <p>Битовый сдвиг вправо</p>
       <p>
        <code class="literal">8 &gt;&gt; 2</code>
        → <code class="returnvalue">2</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>номер</code></em> <code class="literal">+</code> <em class="replaceable"><code>номер</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>номер</code></em></code>
       </p>
       <p>Сложение</p>
       <p>
        <code class="literal">5 + 4</code>
        → <code class="returnvalue">9</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>номер</code></em> <code class="literal">-</code> <em class="replaceable"><code>номер</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>номер</code></em></code>
       </p>
       <p>Вычитание</p>
       <p>
        <code class="literal">3 - 2.0</code>
        → <code class="returnvalue">1.0</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>номер</code></em> <code class="literal">*</code> <em class="replaceable"><code>номер</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>номер</code></em></code>
       </p>
       <p>Умножение</p>
       <p>
        <code class="literal">5 * 4</code>
        → <code class="returnvalue">20</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>номер</code></em> <code class="literal">/</code> <em class="replaceable"><code>номер</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>номер</code></em></code>
       </p>
       <p>Деление (если оба аргумента целочисленные, результат округляется в сторону нуля)</p>
       <p>
        <code class="literal">5 / 3</code>
        → <code class="returnvalue">1</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>integer</code></em> <code class="literal">%</code> <em class="replaceable"><code>integer</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>integer</code></em></code>
       </p>
       <p>Остаток от деления</p>
       <p>
        <code class="literal">3 % 2</code>
        → <code class="returnvalue">1</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="literal">-</code> <em class="replaceable"><code>номер</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>номер</code></em></code>
       </p>
       <p>Смена знака</p>
       <p>
        <code class="literal">- 2.0</code>
        → <code class="returnvalue">-2.0</code>
       </p></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="refsect2" id="PGBENCH-BUILTIN-FUNCTIONS"><h3>Встроенные функции</h3><p>Функции, перечисленные в <a class="xref" href="pgbench.html#PGBENCH-FUNCTIONS" title="Таблица 295. Функции pgbench">Таблице 295</a>, встроены в <span class="application">pgbench</span> и могут применяться в выражениях в метакоманде <a class="link" href="pgbench.html#PGBENCH-METACOMMAND-SET"><code class="literal">\set</code></a>.</p><div class="table" id="PGBENCH-FUNCTIONS"><p class="title"><strong>Таблица 295. Функции pgbench</strong></p><div class="table-contents"><table class="table" summary="Функции pgbench" border="1"><colgroup><col /></colgroup><thead><tr><th class="func_table_entry"><p class="func_signature">Функция</p>
       <p>Описание</p>
       <p>Примеры</p></th></tr></thead><tbody><tr><td class="func_table_entry"><p class="func_signature"><code class="function">abs</code> ( <em class="replaceable"><code>число</code></em> ) → <code class="returnvalue"></code> тип аргумента</p>
       <p>Модуль числа (абсолютное значение)</p>
       <p>
        <code class="literal">abs(-17)</code>
        → <code class="returnvalue">17</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">debug</code> ( <em class="replaceable"><code>число</code></em> ) → <code class="returnvalue"></code> тип аргумента</p>
       <p>Выводит аргумент в <span class="systemitem">stderr</span> и выдаёт его.</p>
       <p>
        <code class="literal">debug(5432.1)</code>
        → <code class="returnvalue">5432.1</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">double</code> ( <em class="replaceable"><code>число</code></em> ) → <code class="returnvalue">double</code></p>
       <p>Приводит аргумент к типу с плавающей точкой.</p>
       <p>
        <code class="literal">double(5432)</code>
        → <code class="returnvalue">5432.0</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">exp</code> ( <em class="replaceable"><code>число</code></em> ) → <code class="returnvalue">double</code></p>
       <p>Экспонента (<code class="literal">e</code> возводится в заданную степень)</p>
       <p>
        <code class="literal">exp(1.0)</code>
        → <code class="returnvalue">2.718281828459045</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">greatest</code> ( <em class="replaceable"><code>число</code></em> [<span class="optional">, <code class="literal">...</code></span>] ) → <code class="returnvalue"></code> <code class="type">double</code> при наличии аргумента(ов) double, иначе — <code class="type">integer</code></p>
       <p>Выбирает наибольшее значение среди аргументов.</p>
       <p>
        <code class="literal">greatest(5, 4, 3, 2)</code>
        → <code class="returnvalue">5</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">hash</code> ( <em class="parameter"><code>значение</code></em> [<span class="optional">, <em class="parameter"><code>затравка</code></em></span>] ) → <code class="returnvalue">integer</code></p>
       <p>Псевдоним <code class="function">hash_murmur2</code>.</p>
       <p>
        <code class="literal">hash(10, 5432)</code>
        → <code class="returnvalue">-5817877081768721676</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">hash_fnv1a</code> ( <em class="parameter"><code>значение</code></em> [<span class="optional">, <em class="parameter"><code>затравка</code></em></span>] ) → <code class="returnvalue">integer</code></p>
       <p>Вычисляет хеш по алгоритму <a class="ulink" href="https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function" target="_top">FNV-1a</a>.</p>
       <p>
        <code class="literal">hash_fnv1a(10, 5432)</code>
        → <code class="returnvalue">-7793829335365542153</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">hash_murmur2</code> ( <em class="parameter"><code>значение</code></em> [<span class="optional">, <em class="parameter"><code>затравка</code></em></span>] ) → <code class="returnvalue">integer</code></p>
       <p>Вычисляет хеш по алгоритму <a class="ulink" href="https://en.wikipedia.org/wiki/MurmurHash" target="_top">MurmurHash2</a>.</p>
       <p>
        <code class="literal">hash_murmur2(10, 5432)</code>
        → <code class="returnvalue">-5817877081768721676</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">int</code> ( <em class="replaceable"><code>число</code></em> ) → <code class="returnvalue">integer</code></p>
       <p>Приводит аргумент к целочисленному типу.</p>
       <p>
        <code class="literal">int(5.4 + 3.8)</code>
        → <code class="returnvalue">9</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">least</code> ( <em class="replaceable"><code>число</code></em> [<span class="optional">, <code class="literal">...</code></span>] ) → <code class="returnvalue"></code> <code class="type">double</code> при наличии аргумента(ов) double, иначе — <code class="type">integer</code></p>
       <p>Выбирает наименьшее значение среди аргументов.</p>
       <p>
        <code class="literal">least(5, 4, 3, 2.1)</code>
        → <code class="returnvalue">2.1</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">ln</code> ( <em class="replaceable"><code>число</code></em> ) → <code class="returnvalue">double</code></p>
       <p>Натуральный логарифм</p>
       <p>
        <code class="literal">ln(2.718281828459045)</code>
        → <code class="returnvalue">1.0</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">mod</code> ( <em class="replaceable"><code>целое</code></em>, <em class="replaceable"><code>целое</code></em> ) → <code class="returnvalue">integer</code></p>
       <p>Остаток от деления</p>
       <p>
        <code class="literal">mod(54, 32)</code>
        → <code class="returnvalue">22</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">permute</code> ( <em class="parameter"><code>i</code></em>, <em class="parameter"><code>size</code></em> [, <em class="parameter"><code>seed</code></em> ] ) → <code class="returnvalue">integer</code></p>
       <p>Переставленное значение <em class="parameter"><code>i</code></em> в диапазоне <code class="literal">[0, size)</code>, то есть позиция <em class="parameter"><code>i</code></em> (по модулю <em class="parameter"><code>size</code></em>) в псевдослучайной перестановке целых чисел <code class="literal">0...size-1</code>, полученной с затравкой <em class="parameter"><code>seed</code></em>, см. ниже.</p>
       <p>
        <code class="literal">permute(0, 4)</code>
        → <code class="returnvalue">целое между 0 и 3</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">pi</code> () → <code class="returnvalue">double</code></p>
       <p>Приближённое значение <span class="symbol_font">π</span></p>
       <p>
        <code class="literal">pi()</code>
        → <code class="returnvalue">3.1415926535​8979323846</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">pow</code> ( <em class="parameter"><code>x</code></em>, <em class="parameter"><code>y</code></em> ) → <code class="returnvalue">double</code></p>
       <p class="func_signature"><code class="function">power</code> ( <em class="parameter"><code>x</code></em>, <em class="parameter"><code>y</code></em> ) → <code class="returnvalue">double</code></p>
       <p>Возводит <em class="parameter"><code>x</code></em> в степень <em class="parameter"><code>y</code></em></p>
       <p>
        <code class="literal">pow(2.0, 10)</code>
        → <code class="returnvalue">1024.0</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">random</code> ( <em class="parameter"><code>lb</code></em>, <em class="parameter"><code>ub</code></em> ) → <code class="returnvalue">integer</code></p>
       <p>Выдаёт случайное целое число с равномерным распределением в интервале <code class="literal">[lb, ub]</code>.</p>
       <p>
        <code class="literal">random(1, 10)</code>
        → <code class="returnvalue">целое между 1 и 10</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">random_exponential</code> ( <em class="parameter"><code>lb</code></em>, <em class="parameter"><code>ub</code></em>, <em class="parameter"><code>parameter</code></em> ) → <code class="returnvalue">integer</code></p>
       <p>Выдаёт случайное целое число с экспоненциальным распределением в интервале <code class="literal">[lb, ub]</code>, см. ниже.</p>
       <p>
        <code class="literal">random_exponential(1, 10, 3.0)</code>
        → <code class="returnvalue">целое между 1 и 10</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">random_gaussian</code> ( <em class="parameter"><code>lb</code></em>, <em class="parameter"><code>ub</code></em>, <em class="parameter"><code>parameter</code></em> ) → <code class="returnvalue">integer</code></p>
       <p>Выдаёт целое число с распределением Гаусса в интервале <code class="literal">[lb, ub]</code>, см. ниже.</p>
       <p>
        <code class="literal">random_gaussian(1, 10, 2.5)</code>
        → <code class="returnvalue">целое между 1 и 10</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">random_zipfian</code> ( <em class="parameter"><code>lb</code></em>, <em class="parameter"><code>ub</code></em>, <em class="parameter"><code>parameter</code></em> ) → <code class="returnvalue">integer</code></p>
       <p>Выдаёт целое число с распределением Ципфа в интервале <code class="literal">[lb, ub]</code>, см. ниже.</p>
       <p>
        <code class="literal">random_zipfian(1, 10, 1.5)</code>
        → <code class="returnvalue">целое между 1 и 10</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">sqrt</code> ( <em class="replaceable"><code>число</code></em> ) → <code class="returnvalue">double</code></p>
       <p>Квадратный корень</p>
       <p>
        <code class="literal">sqrt(2.0)</code>
        → <code class="returnvalue">1.414213562</code>
       </p></td></tr></tbody></table></div></div><br class="table-break" /><p>Функция <code class="literal">random</code> выдаёт значения с равномерным распределением, то есть вероятности получения всех чисел в интервале равны. Функции <code class="literal">random_exponential</code>, <code class="literal">random_gaussian</code> и <code class="literal">random_zipfian</code> требуют указания дополнительного параметра типа double, определяющего точную форму распределения.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Для экспоненциального распределения <em class="replaceable"><code>parameter</code></em> управляет распределением, обрезая быстро спадающее экспоненциальное распределение в точке <em class="replaceable"><code>parameter</code></em>, а затем это распределение проецируется на целые числа между границами. Точнее говоря, с </p><div class="literallayout"><p><br />
f(x) = exp(-parameter * (x - min) / (max - min + 1)) / (1 - exp(-parameter))<br />
</p></div><p> значение <em class="replaceable"><code>i</code></em> между <em class="replaceable"><code>min</code></em> и <em class="replaceable"><code>max</code></em> выдаётся с вероятностью: <code class="literal">f(i) - f(i + 1)</code>.</p><p>Интуиция подсказывает, что чем больше <em class="replaceable"><code>parameter</code></em>, тем чаще будут выдаваться значения, близкие к <em class="replaceable"><code>min</code></em>, и тем реже значения, близкие к <em class="replaceable"><code>max</code></em>. Чем <em class="replaceable"><code>parameter</code></em> ближе к 0, тем более плоским (более равномерным) будет распределение. В грубом приближении при таком распределении наиболее частый 1% значений в диапазоне рядом с <em class="replaceable"><code>min</code></em> выдаётся <em class="replaceable"><code>parameter</code></em>% времени. Значение <em class="replaceable"><code>parameter</code></em> должно быть строго положительным.</p></li><li class="listitem"><p>Для распределения Гаусса по интервалу строится обычное нормальное распределение (классическая кривая Гаусса в форме колокола) и этот интервал обрезается в точке <code class="literal">-parameter</code> слева и <code class="literal">+parameter</code> справа. Вероятнее всего при таком распределении выдаются значения из середины интервала. Точнее говоря, если <code class="literal">PHI(x)</code> — функция распределения нормальной случайной величины со средним значением <code class="literal">mu</code>, равным <code class="literal">(max + min) / 2.0</code>, и </p><div class="literallayout"><p><br />
f(x) = PHI(2.0 * parameter * (x - mu) / (max - min + 1)) /<br />
       (2.0 * PHI(parameter) - 1)<br />
</p></div><p> тогда значение <em class="replaceable"><code>i</code></em> между <em class="replaceable"><code>min</code></em> и <em class="replaceable"><code>max</code></em> включительно выдаётся с вероятностью: <code class="literal">f(i + 0.5) - f(i - 0.5)</code>. Интуиция подсказывает, что чем больше <em class="replaceable"><code>parameter</code></em>, тем чаще будут выдаваться значения в середине интервала, и тем реже значения у границ <em class="replaceable"><code>min</code></em> и <em class="replaceable"><code>max</code></em>. Около 67% значений будут выдаваться из среднего интервала <code class="literal">1.0 / parameter</code>, то есть плюс/минус <code class="literal">0.5 / parameter</code> от среднего значения, и 95% из среднего интервала <code class="literal">2.0 / parameter</code>, то есть плюс/минус <code class="literal">1.0 / parameter</code> от среднего значения; например, если <em class="replaceable"><code>parameter</code></em> равен 4.0, 67% значений выдаются из средней четверти (1.0 / 4.0) интервала (то есть от <code class="literal">3.0 / 8.0</code> до <code class="literal">5.0 / 8.0</code>) и 95% из средней половины (<code class="literal">2.0 / 4.0</code>) интервала (из второй и третьей четвертей). Значение <em class="replaceable"><code>parameter</code></em> не может быть меньше 2.0.</p></li><li class="listitem"><p>Функция <code class="literal">random_zipfian</code> генерирует ограниченное распределение по закону Ципфа. <em class="replaceable"><code>parameter</code></em> определяет, насколько неравномерно распределение. Чем больше <em class="replaceable"><code>parameter</code></em>, тем чаще выдаются значения, близкие к началу интервала. Это распределение таково, что при диапазоне, начинающемся с 1, отношение вероятности получить <em class="replaceable"><code>k</code></em> к вероятности получения <em class="replaceable"><code>k+1</code></em> равняется <code class="literal">((<em class="replaceable"><code>k</code></em>+1)/<em class="replaceable"><code>k</code></em>)**<em class="replaceable"><code>parameter</code></em></code>. Например, <code class="literal">random_zipfian(1, ..., 2.5)</code> будет выдавать число <code class="literal">1</code> примерно в <code class="literal">(2/1)**2.5 = 5.66</code> раза чаще, чем число <code class="literal">2</code>, а оно, в свою очередь, будет выдаваться примерно в <code class="literal">(3/2)**2.5 = 2.76</code> раза чаще, чем <code class="literal">3</code>, и так далее.</p><p>Это распределение реализовано в <span class="application">pgbench</span> по материалу книги «Non-Uniform Random Variate Generation» («Генерация неравномерно распределённых случайных чисел» Люк Деврой, стр. 550-551, Springer 1986. Вследствие ограничений алгоритма <em class="replaceable"><code>parameter</code></em> может принимать значения только в интервале [1.001, 1000].</p></li></ul></div><div class="note"><h3 class="title">Примечание</h3><p>Разрабатывая тест производительности, выбирающий строки неравномерно, учтите, что выбираемые строки могут коррелировать с другими данными, например, идентификаторами, выдаваемыми последовательностями, или физическим расположением строк, а это может искажать оценки производительности.</p><p>Чтобы избежать этого, можно использовать функцию <code class="function">permute</code> для перемешивания выбранных строк и устранения таких корреляций, либо выполнить другие дополнительные операции, дающие подобный эффект.</p></div><p>Функции хеширования <code class="literal">hash</code>, <code class="literal">hash_murmur2</code> и <code class="literal">hash_fnv1a</code> принимают на вход хешируемое значение и необязательный параметр с затравкой. Если значение затравки не задаётся, используется значение переменной <code class="literal">:default_seed</code>, которая инициализируется случайным числом (если не задаётся явно ключом командной строки <code class="literal">-D</code>).</p><p>Функция <code class="literal">permute</code> принимает входное значение, размер и необязательный параметр с затравкой. Она получает псевдослучайную перестановку целых чисел в диапазоне <code class="literal">[0, размер)</code> и возвращает индекс входного значения в этой перестановке. Выбираемая перестановка зависит от затравки; по умолчанию затравкой будет значение <code class="literal">:default_seed</code>. В отличие от функций вычисления хеша, функция <code class="literal">permute</code> гарантирует отсутствие пропусков и наложений в выходных значениях. Входные значения, лежащие за границами интервала, пересчитываются по модулю размера. Если значение размера не положительное, эта функция выдаёт ошибку. Функцию <code class="function">permute</code> можно использовать для выравнивания результатов функций, выдающих неравномерно распределённые случайные числа, таких как <code class="literal">random_zipfian</code> или <code class="literal">random_exponential</code>, чтобы чаще выдаваемые значения не создавали корреляции. Например, следующий скрипт <span class="application">pgbench</span> эмулирует возможную реальную нагрузку, типичную для социальных медиа- и блог-платформ, где несколько пользователей генерируют львиную долю нагрузки: </p><pre class="programlisting">\set size 1000000
\set r random_zipfian(1, :size, 1.07)
\set k 1 + permute(:r, :size)</pre><p> В некоторых случаях требуются другие разнообразные распределения, не коррелирующие друг с другом, и тогда может быть полезно дополнительно указать затравку: </p><pre class="programlisting">\set k1 1 + permute(:r, :size, :default_seed + 123)
\set k2 1 + permute(:r, :size, :default_seed + 321)</pre><p> Примерно такого же эффекта можно добиться, используя функцию <code class="function">hash</code>: </p><pre class="programlisting">\set size 1000000
\set r random_zipfian(1, 100 * :size, 1.07)
\set k 1 + abs(hash(:r)) % :size</pre><p> Но так как <code class="function">hash</code> может порождать коллизии, некоторые значения окажутся пропущенными, а другие будут встречаться чаще других, при том что в исходном распределении этого не наблюдалось.</p><p>В качестве примера взгляните на встроенное определение транзакции типа TPC-B: </p><pre class="programlisting">\set aid random(1, 100000 * :scale)
\set bid random(1, 1 * :scale)
\set tid random(1, 10 * :scale)
\set delta random(-5000, 5000)
BEGIN;
UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
END;</pre><p> С таким скриптом транзакция на каждой итерации будет обращаться к разным, случайно выбираемым строкам. (Этот пример показывает, почему важно, чтобы в каждом клиентском сеансе были собственные переменные — в противном случае они не будут независимо обращаться к разным строкам.)</p></div><div class="refsect2" id="id-1.9.4.11.9.6"><h3>Протоколирование транзакций</h3><p>С параметром <code class="option">-l</code> (но без <code class="option">--aggregate-interval</code>), <span class="application">pgbench</span> записывает информацию о каждой транзакции в протокол. Этот файл протокола будет называться <code class="filename"><em class="replaceable"><code>префикс</code></em>.<em class="replaceable"><code>nnn</code></em></code>, где <em class="replaceable"><code>префикс</code></em> по умолчанию — <code class="literal">pgbench_log</code>, а <em class="replaceable"><code>nnn</code></em> — PID процесса <span class="application">pgbench</span>. Префикс можно сменить, воспользовавшись ключом <code class="option">--log-prefix</code>. Если параметр <code class="option">-j</code> равен 2 или выше, будет создано несколько рабочих потоков, и каждый будет записывать отдельный протокол. Первый рабочий процесс будет использовать файл с тем же именем, что и в стандартном случае с одним потоком, а файлы остальных потоков будут называться <code class="filename"><em class="replaceable"><code>префикс</code></em>.<em class="replaceable"><code>nnn</code></em>.<em class="replaceable"><code>mmm</code></em></code>, где <em class="replaceable"><code>mmm</code></em> — порядковый номер рабочего процесса, начиная с 1.</p><p>Каждая строка в файле протокола описывает одну транзакцию. Она содержит следующие поля, разделённые пробелами: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>код_клиента</code></em></span></dt><dd><p>идентифицирует клиентский сеанс, в котором выполнялась транзакция</p></dd><dt><span class="term"><em class="replaceable"><code>число_транзакций</code></em></span></dt><dd><p>показывает, сколько SQL-транзакций было выполнено в этом сеансе</p></dd><dt><span class="term"><em class="replaceable"><code>длительность</code></em></span></dt><dd><p>общее время транзакции, в микросекундах</p></dd><dt><span class="term"><em class="replaceable"><code>номер_скрипта</code></em></span></dt><dd><p>показывает, какой файл скрипта использовался (это полезно при указании нескольких скриптов ключами <code class="option">-f</code> и <code class="option">-b</code>)</p></dd><dt><span class="term"><em class="replaceable"><code>время_эпохи</code></em></span></dt><dd><p>отметка времени в формате Unix, показывающая, когда транзакция была завершена</p></dd><dt><span class="term"><em class="replaceable"><code>время_мкс</code></em></span></dt><dd><p>микросекунды в отметке времени, показывающей, когда транзакция была завершена</p></dd><dt><span class="term"><em class="replaceable"><code>отставание_от_графика</code></em></span></dt><dd><p>задержка начала транзакции, которая представляет собой разницу между запланированным временем запуска транзакции и фактическим временем запуска, в микросекундах (выводится, только когда указан параметр <code class="option">--rate</code>)</p></dd><dt><span class="term"><em class="replaceable"><code>повторные_попытки</code></em></span></dt><dd><p>число повторений транзакции после ошибок сериализации или взаимоблокировки (выводится, только когда <code class="option">--max-tries</code> не равен одному)</p></dd></dl></div><p>Когда одновременно применяются параметры <code class="option">--rate</code> и <code class="option">--latency-limit</code>, в поле <em class="replaceable"><code>длительность</code></em> для пропущенных транзакций выводится <code class="literal">skipped</code>. Если транзакция завершилась неудачей, в столбце <em class="replaceable"><code>длительность</code></em> выводится <code class="literal">failed</code>. Когда применяется параметр <code class="option">--failures-detailed</code>, вместо <em class="replaceable"><code>длительности</code></em> для неуспешной транзакции будет указано <code class="literal">serialization</code> или <code class="literal">deadlock</code> в зависимости от типа ошибки (за дополнительными сведениями обратитесь к <a class="xref" href="pgbench.html#FAILURES-AND-RETRIES" title="Повторы и отказы из-за ошибок сериализации/взаимоблокировки">Повторы и отказы из-за ошибок сериализации/взаимоблокировки</a>).</p><p>Фрагмент протокола, полученного при выполнении с одним клиентом: </p><pre class="screen">
0 199 2241 0 1175850568 995598
0 200 2465 0 1175850568 998079
0 201 2513 0 1175850569 608
0 202 2038 0 1175850569 2663
</pre><p> Ещё один пример с <code class="literal">--rate=100</code> и <code class="literal">--latency-limit=5</code> (обратите внимание на дополнительный столбец <em class="replaceable"><code>отставание_от_графика</code></em>): </p><pre class="screen">
0 81 4621 0 1412881037 912698 3005
0 82 6173 0 1412881037 914578 4304
0 83 skipped 0 1412881037 914578 5217
0 83 skipped 0 1412881037 914578 5099
0 83 4722 0 1412881037 916203 3108
0 84 4142 0 1412881037 918023 2333
0 85 2465 0 1412881037 919759 740
</pre><p> В этом примере транзакция 82 опоздала, так как её длительность (6.173 мс) превысила ограничение в 5 мс. Следующие две транзакции были пропущены, так как было слишком поздно их начинать.</p><p>Ниже показан фрагмент протокола с отказами и повторными попытками при максимальном числе попыток, равном 10 (обратите внимание на дополнительный столбец <em class="replaceable"><code>повторные_попытки</code></em>): </p><pre class="screen">
3 0 47423 0 1499414498 34501 3
3 1 8333 0 1499414498 42848 0
3 2 8358 0 1499414498 51219 0
4 0 72345 0 1499414498 59433 6
1 3 41718 0 1499414498 67879 4
1 4 8416 0 1499414498 76311 0
3 3 33235 0 1499414498 84469 3
0 0 failed 0 1499414498 84905 9
2 0 failed 0 1499414498 86248 9
3 4 8307 0 1499414498 92788 0
</pre><p>Если применяется параметр <code class="option">--failures-detailed</code>, в графе <em class="replaceable"><code>длительность</code></em> выводится тип ошибки: </p><pre class="screen">
3 0 47423 0 1499414498 34501 3
3 1 8333 0 1499414498 42848 0
3 2 8358 0 1499414498 51219 0
4 0 72345 0 1499414498 59433 6
1 3 41718 0 1499414498 67879 4
1 4 8416 0 1499414498 76311 0
3 3 33235 0 1499414498 84469 3
0 0 serialization 0 1499414498 84905 9
2 0 serialization 0 1499414498 86248 9
3 4 8307 0 1499414498 92788 0
</pre><p>Когда проводится длительное тестирование с большим количеством транзакций, файлы протоколов могут быть очень объёмными. Чтобы в них записывалась только случайная выборка транзакций, можно запустить команду с параметром <code class="option">--sampling-rate</code>.</p></div><div class="refsect2" id="id-1.9.4.11.9.7"><h3>Протоколирование с агрегированием</h3><p>С параметром <code class="option">--aggregate-interval</code> для файлов протоколов используется другой формат. Каждая строка протокола описывает один интервал агрегации. Она содержит следующие поля, разделённые пробелами: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>начало_интервала</code></em></span></dt><dd><p>начальное время интервала в формате времени Unix</p></dd><dt><span class="term"><em class="replaceable"><code>число_транзакций</code></em></span></dt><dd><p>количество транзакций в данном интервале</p></dd><dt><span class="term"><em class="replaceable"><code>сумма_длительности</code></em></span></dt><dd><p>суммарная длительность транзакций</p></dd><dt><span class="term"><em class="replaceable"><code>сумма_длительности_2</code></em></span></dt><dd><p>сумма квадратов длительностей транзакций</p></dd><dt><span class="term"><em class="replaceable"><code>мин_длительность</code></em></span></dt><dd><p>минимальная длительность транзакции</p></dd><dt><span class="term"><em class="replaceable"><code>макс_длительность</code></em></span></dt><dd><p>максимальная длительность транзакции</p></dd><dt><span class="term"><em class="replaceable"><code>сумма_задержки</code></em></span></dt><dd><p>сумма задержек начала транзакций (ноль, если не указан параметр <code class="option">--rate</code>)</p></dd><dt><span class="term"><em class="replaceable"><code>сумма_задержки_2</code></em></span></dt><dd><p>сумма квадратов задержек начала транзакций (ноль, если не указан параметр <code class="option">--rate</code>)</p></dd><dt><span class="term"><em class="replaceable"><code>мин_задержка</code></em></span></dt><dd><p>минимальная задержка начала транзакции (ноль, если не указан параметр <code class="option">--rate</code>)</p></dd><dt><span class="term"><em class="replaceable"><code>макс_задержка</code></em></span></dt><dd><p>максимальная задержка начала транзакции (ноль, если не указан параметр <code class="option">--rate</code>)</p></dd><dt><span class="term"><em class="replaceable"><code>пропущено_транзакций</code></em></span></dt><dd><p>число транзакций, пропущенных из-за того, что было слишком поздно их начинать (ноль, если не заданы параметры <code class="option">--rate</code> и <code class="option">--latency-limit</code>)</p></dd><dt><span class="term"><em class="replaceable"><code>повторено_транзакций</code></em></span></dt><dd><p>число транзакций, которые были повторены (ноль, если не указан параметр <code class="option">--max-tries</code>)</p></dd><dt><span class="term"><em class="replaceable"><code>повторные_попытки</code></em></span></dt><dd><p>число повторов после ошибок сериализации или взаимоблокировок (ноль, если параметр <code class="option">--max-tries</code> не единица)</p></dd><dt><span class="term"><em class="replaceable"><code>сбои_сериализации</code></em></span></dt><dd><p>число транзакций, которые были прерваны из-за ошибок сериализации и не были повторены впоследствии (ноль, если не указан параметр <code class="option">--failures-detailed</code>)</p></dd><dt><span class="term"><em class="replaceable"><code>сбои_взаимоблокировки</code></em></span></dt><dd><p>число транзакций, которые были прерваны из-за ошибок взаимоблокировки и не были повторены впоследствии (ноль, если не указан параметр <code class="option">--failures-detailed</code>)</p></dd></dl></div><p>Ниже представлен пример вывода с этим параметром: </p><pre class="screen">
<strong class="userinput"><code>pgbench --aggregate-interval=10 --time=20 --client=10 --log --rate=1000 --latency-limit=10 --failures-detailed --max-tries=10 test</code></strong>

1650260552 5178 26171317 177284491527 1136 44462 2647617 7321113867 0 9866 64 7564 28340 4148 0
1650260562 4808 25573984 220121792172 1171 62083 3037380 9666800914 0 9998 598 7392 26621 4527 0
</pre><p>Заметьте, что простой формат протокола (без агрегирования) показывает, какой скрипт использовался для каждой транзакции, в отличие от формата с агрегированием. Таким образом, если вам нужны подобные сведения, но в разрезе скриптов, вам придётся агрегировать данные самостоятельно.</p></div><div class="refsect2" id="id-1.9.4.11.9.8"><h3>Отчёт по операторам</h3><p>С параметром <code class="option">-r</code> программа <span class="application">pgbench</span> собирает следующую статистику по каждому оператору: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">latency</code> — время выполнения для каждого оператора. <span class="application">pgbench</span> выводит среднее по всем успешным попыткам выполнения оператора.</p></li><li class="listitem"><p>Число отказов для данного оператора. За дополнительной информацией обратитесь к <a class="xref" href="pgbench.html#FAILURES-AND-RETRIES" title="Повторы и отказы из-за ошибок сериализации/взаимоблокировки">Повторы и отказы из-за ошибок сериализации/взаимоблокировки</a>.</p></li><li class="listitem"><p>Число повторов после ошибок сериализации или взаимоблокировки в этом операторе. За дополнительными сведениями обратитесь к <a class="xref" href="pgbench.html#FAILURES-AND-RETRIES" title="Повторы и отказы из-за ошибок сериализации/взаимоблокировки">Повторы и отказы из-за ошибок сериализации/взаимоблокировки</a>.</p></li></ul></div><p>В отчёте отображается статистика повторов, только если параметр <code class="option">--max-tries</code> не равен 1.</p><p>Все эти значения вычисляются для каждого оператора, выполняемого каждым клиентом, и выдаются после завершения теста.</p><p>Для скрипта по умолчанию вывод будет выглядеть примерно так: </p><pre class="screen">
starting vacuum...end.
transaction type: &lt;builtin: TPC-B (sort of)&gt;
scaling factor: 1
query mode: simple
number of clients: 10
number of threads: 1
maximum number of tries: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
number of failed transactions: 0 (0.000%)
number of transactions above the 50.0 ms latency limit: 1311/10000 (13.110 %)
latency average = 28.488 ms
latency stddev = 21.009 ms
initial connection time = 69.068 ms
tps = 346.224794 (without initial connection time)
statement latencies in milliseconds and failures:
   0.012  0  \set aid random(1, 100000 * :scale)
   0.002  0  \set bid random(1, 1 * :scale)
   0.002  0  \set tid random(1, 10 * :scale)
   0.002  0  \set delta random(-5000, 5000)
   0.319  0  BEGIN;
   0.834  0  UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
   0.641  0  SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
  11.126  0  UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
  12.961  0  UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
   0.634  0  INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
   1.957  0  END;
</pre><p> Ещё один пример вывода для скрипта по умолчанию с выбором сериализуемого уровня изоляции (<code class="command">PGOPTIONS='-c default_transaction_isolation=serializable' pgbench ...</code>): </p><pre class="screen">
starting vacuum...end.
transaction type: &lt;builtin: TPC-B (sort of)&gt;
scaling factor: 1
query mode: simple
number of clients: 10
number of threads: 1
maximum number of tries: 10
number of transactions per client: 1000
number of transactions actually processed: 6317/10000
number of failed transactions: 3683 (36.830%)
number of transactions retried: 7667 (76.670%)
total number of retries: 45339
number of transactions above the 50.0 ms latency limit: 106/6317 (1.678 %)
latency average = 17.016 ms
latency stddev = 13.283 ms
initial connection time = 45.017 ms
tps = 186.792667 (without initial connection time)
statement latencies in milliseconds, failures and retries:
  0.006     0      0  \set aid random(1, 100000 * :scale)
  0.001     0      0  \set bid random(1, 1 * :scale)
  0.001     0      0  \set tid random(1, 10 * :scale)
  0.001     0      0  \set delta random(-5000, 5000)
  0.385     0      0  BEGIN;
  0.773     0      1  UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
  0.624     0      0  SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
  1.098   320   3762  UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
  0.582  3363  41576  UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
  0.465     0      0  INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
  1.933     0      0  END;
</pre><p>Если задействуется несколько файлов скриптов, все статистические данные выводятся отдельно для каждого файла.</p><p>Учтите, что сбор дополнительных временных показателей влечёт некоторые издержки и приводит к снижению средней скорости и, как результат, падению TPS. На сколько именно снизится скорость, во многом зависит от платформы и оборудования. Хороший способ оценить, каковы эти издержки — сравнить средние значения TPS, получаемые с подсчётом времени операторов и без такого подсчёта.</p></div><div class="refsect2" id="FAILURES-AND-RETRIES"><h3>Повторы и отказы из-за ошибок сериализации/взаимоблокировки</h3><p>При выполнении <span class="application">pgbench</span> могут возникать ошибки трёх основных типов: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Ошибки основной программы. Они являются наиболее серьёзными и всегда приводят к немедленному завершению <span class="application">pgbench</span> с соответствующим сообщением об ошибке. К ним относятся: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>ошибки, возникшие при запуске <span class="application">pgbench</span> (например, из-за недопустимого значения параметра);</p></li><li class="listitem"><p>ошибки в режиме инициализации (например, запрос из встроенного скрипта не смог создать таблицу);</p></li><li class="listitem"><p>ошибки перед запуском потоков (например, не удалось подключиться к серверу базы данных, синтаксическая ошибка в метакоманде, сбой при создании потока);</p></li><li class="listitem"><p>непредвиденные внутренние ошибки <span class="application">pgbench</span>.</p></li></ul></div></li><li class="listitem"><p>Ошибки при обслуживании клиентов в потоке выполнения (например, клиент не смог установить соединение с сервером, сокет для подключения клиента к серверу стал недействительным). В таких случаях все клиенты этого потока останавливаются, а другие потоки продолжают работать.</p></li><li class="listitem"><p>Непосредственно клиентские ошибки. Они вызывают немедленное завершение <span class="application">pgbench</span> с соответствующим сообщением только в случае непредвиденной внутренней ошибки <span class="application">pgbench</span>. В других случаях они могут вызвать лишь прерывание работы проблемного клиента, другие клиенты продолжат работу (однако некоторые клиентские ошибки обрабатываются без прерывания работы клиента и информация о них выдаётся отдельно, см. ниже). Далее в этом разделе ошибками считаются только непосредственно клиентские ошибки, а не внутренние ошибки <span class="application">pgbench</span>.</p></li></ul></div><p>Работа клиента прерывается в случае серьёзной ошибки; например, если было потеряно соединение с сервером баз данных или достигнут конец скрипта, а последняя транзакция не завершена. Кроме того, работа клиента прерывается, если выполнение команды SQL или метакоманды завершается сбоем по причинам, отличным от ошибок сериализации или взаимоблокировки. Если же команда SQL завершается ошибкой сериализации или взаимоблокировки, работа клиента продолжается. В таких случаях текущая транзакция откатывается, при этом клиентские переменные получают значения, которые они имели до начала этой транзакции (предполагается, что один скрипт транзакции содержит только одну транзакцию; за подробностями обратитесь к <a class="xref" href="pgbench.html#TRANSACTIONS-AND-SCRIPTS" title="Каково содержание «транзакции», которую выполняет pgbench?">Каково содержание «транзакции», которую выполняет pgbench?</a>). Транзакции с ошибками сериализации или взаимоблокировки повторяются после отката до успешного завершения либо до максимального числа повторений (которое задаётся параметром <code class="option">--max-tries</code>), максимальной длительности повторений (которая задаётся параметром <code class="option">--latency-limit</code>) или до истечения времени теста (это время задаётся параметром <code class="option">--time</code>). Если последняя попытка завершается неудачей, транзакция считается неудачной, но работа клиента не прерывается.</p><div class="note"><h3 class="title">Примечание</h3><p>Если параметр <code class="option">--max-tries</code> не указан, транзакции никогда не повторяются после ошибок сериализации или взаимоблокировки, так как его значение по умолчанию равно 1. Чтобы ограничить только общую длительность попыток, задайте неограниченное количество попыток (<code class="literal">--max-tries=0</code>) и установите параметр <code class="option">--latency-limit</code>. Вы также можете ограничить общую продолжительность теста при неограниченном количестве попыток, используя параметр <code class="option">--time</code>.</p><p>Учтите особенность повторения скриптов, содержащих несколько транзакций: скрипт всегда будет повторяться целиком, так что успешные транзакции в нём могут выполняться многократно.</p><p>Также учтите особенность повторения транзакций, содержащих команды оболочки. В отличие от результатов команд SQL, результаты команд оболочки не отменяются, за исключением значения переменной команды <code class="command">\setshell</code>.</p></div><p>Длительность успешной транзакции включает общее время выполнения транзакции с учётом откатов и повторов. Измеряется длительность только для успешных транзакций и команд.</p><p>Количество неуспешных транзакций выводится в основном отчёте. Если параметр <code class="option">--max-tries</code> не равен 1, основной отчёт также содержит статистику повторов: общее число транзакций, которые повторялись, и общее число повторов всех транзакций. Отчёт по скриптам наследует все эти поля от основного отчёта. Если параметр <code class="option">--max-tries</code> не равен 1, статистика повторных попыток также отображается в отчёте по операторам.</p><p>Если вы хотите, чтобы в протоколе c агрегированием, а также в основном отчёте, отчёте по транзакциям и отчёте по скриптам сбои группировались по базовым типам, используйте параметр <code class="option">--failures-detailed</code>. Если же вы хотите видеть все отдельные ошибки и отказы (ошибки, после которых транзакция не повторяется), а также видеть, как ограничиваются повторения и насколько достигается ограничение, используйте параметр <code class="option">--verbose-errors</code>.</p></div><div class="refsect2" id="id-1.9.4.11.9.10"><h3>Табличные методы доступа</h3><p>Можно определить <a class="link" href="tableam.html" title="Глава 63. Определение интерфейса для табличных методов доступа">табличный метод доступа</a> к таблицам <span class="application">pgbench</span>. В переменной окружения <code class="envar">PGOPTIONS</code> задаются конфигурационные параметры БД, которые передаются в PostgreSQL через командную строку (см. <a class="xref" href="config-setting.html#CONFIG-SETTING-SHELL" title="20.1.4. Управление параметрами в командной строке">Подраздел 20.1.4</a>). Например, табличный метод доступа по умолчанию к таблицам, создаваемым <span class="application">pgbench</span>, под названием <code class="literal">wuzza</code> можно определить так: </p><pre class="programlisting">PGOPTIONS='-c default_table_access_method=wuzza'</pre></div><div class="refsect2" id="id-1.9.4.11.9.11"><h3>Полезные советы</h3><p>Используя <span class="application">pgbench</span>, можно без особого труда получить абсолютно бессмысленные числа. Последуйте приведённым советам, чтобы получить полезные результаты.</p><p>Во-первых, <span class="emphasis"><em>никогда</em></span> не доверяйте тестам, которые выполняются всего несколько секунд. Воспользуйтесь параметром <code class="option">-t</code> и <code class="option">-T</code> и установите время выполнения не меньше нескольких минут, чтобы избавиться от шума в средних значениях. В некоторых случаях для получения воспроизводимых результатов тестирование должно продолжаться несколько часов. Чтобы понять, были ли получены воспроизводимые значения, имеет смысл запустить тестирование несколько раз.</p><p>Для стандартного сценария по типу TPC-B начальный коэффициент масштаба (<code class="option">-s</code>) должен быть не меньше числа клиентов, с каким вы намерены проводить тестирование (<code class="option">-c</code>); в противном случае вы, по большому счёту, будете замерять время конкурентных изменений. Таблица <code class="structname">pgbench_branches</code> содержит всего <code class="option">-s</code> строк, а каждая транзакция хочет изменить одну из них, так что если значение <code class="option">-c</code> превышает <code class="option">-s</code>, это несомненно приведёт к тому, что многие транзакции будут блокироваться другими.</p><p>Стандартный сценарий тестирования также довольно сильно зависит от того, сколько времени прошло с момента инициализации таблиц: накопление неактуальных строк и «мёртвого» пространства в таблицах влияет на результаты. Чтобы правильно оценить результаты, необходимо учитывать, сколько всего изменений было произведено и когда выполнялась очистка. Если же включена автоочистка, это может быть чревато непредсказуемыми изменениями оценок производительности.</p><p>Полезность результатов <span class="application">pgbench</span> также может ограничиваться тем, что тестирование с большим числом клиентских сеансов само по себе нагружает систему. Этого можно избежать, запуская <span class="application">pgbench</span> на другом компьютере, не на сервере баз данных, хотя при этом большое значение имеет скорость сети. Иногда, оценивая производительность одного сервера, полезно запускать даже несколько экземпляров <span class="application">pgbench</span> параллельно, на отдельных клиентских компьютерах.</p></div><div class="refsect2" id="id-1.9.4.11.9.12"><h3>Безопасность</h3><p>Если к базе данных, которая не приведена в соответствие <a class="link" href="ddl-schemas.html#DDL-SCHEMAS-PATTERNS" title="5.9.6. Шаблоны использования">шаблону безопасного использования схем</a>, имеют доступ недоверенные пользователи, не запускайте <span class="application">pgbench</span> в этой базе. Программа <span class="application">pgbench</span> использует неполные имена и не настраивает для себя путь поиска.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="app-pgbasebackup.html" title="pg_basebackup">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="reference-client.html" title="Клиентские приложения PostgreSQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="app-pgconfig.html" title="pg_config">След.</a></td></tr><tr><td width="40%" align="left" valign="top"><span class="application">pg_basebackup</span> </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> <span class="application">pg_config</span></td></tr></table></div></body></html>