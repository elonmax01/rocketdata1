<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CREATE CAST</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sql-createaggregate.html" title="CREATE AGGREGATE" /><link rel="next" href="sql-createcollation.html" title="CREATE COLLATION" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">CREATE CAST</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-createaggregate.html" title="CREATE AGGREGATE">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><th width="60%" align="center">Команды SQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-createcollation.html" title="CREATE COLLATION">След.</a></td></tr></table><hr /></div><div class="refentry" id="SQL-CREATECAST"><div class="titlepage"></div><a id="id-1.9.3.58.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">CREATE CAST</span></h2><p>CREATE CAST — создать приведение</p></div><div class="refsynopsisdiv"><h2>Синтаксис</h2><pre class="synopsis">CREATE CAST (<em class="replaceable"><code>исходный_тип</code></em> AS <em class="replaceable"><code>целевой_тип</code></em>)
    WITH FUNCTION <em class="replaceable"><code>имя_функции</code></em> [ (<em class="replaceable"><code>тип_аргумента</code></em> [, ...]) ]
    [ AS ASSIGNMENT | AS IMPLICIT ]

CREATE CAST (<em class="replaceable"><code>исходный_тип</code></em> AS <em class="replaceable"><code>целевой_тип</code></em>)
    WITHOUT FUNCTION
    [ AS ASSIGNMENT | AS IMPLICIT ]

CREATE CAST (<em class="replaceable"><code>исходный_тип</code></em> AS <em class="replaceable"><code>целевой_тип</code></em>)
    WITH INOUT
    [ AS ASSIGNMENT | AS IMPLICIT ]</pre></div><div class="refsect1" id="SQL-CREATECAST-DESCRIPTION"><h2>Описание</h2><p><code class="command">CREATE CAST</code> создаёт новое приведение. Приведение определяет, как выполнить преобразование из одного типа в другой. Например, </p><pre class="programlisting">SELECT CAST(42 AS float8);</pre><p> преобразует целочисленную константу 42 к типу <code class="type">float8</code>, вызывая ранее определённую функцию, в данном случае <code class="literal">float8(int4)</code>. (Если подходящее приведение не определено, возникнет ошибка преобразования.)</p><p>Два типа могут быть <em class="firstterm">двоично-сводимыми</em>; это означает, что преобразование может быть выполнено <span class="quote">«<span class="quote">бесплатно</span>»</span>, без вызова какой-либо функции. Для этого требуется, чтобы соответствующие значения имели одинаковое внутреннее представление. Например, типы <code class="type">text</code> и <code class="type">varchar</code> двоично-сводимые в обе стороны. Отношение двоичной сводимости не обязательно симметрично. Например, приведение типа <code class="type">xml</code> к типу <code class="type">text</code> в текущей реализации можно выполнить бесплатно, но для преобразования в обратном направлении требуется функция, выполняющая как минимум синтаксическую проверку. (Два типа, двоично-сводимые в обе стороны, также называются двоично-совместимыми.)</p><p>Приведение можно определить как <em class="firstterm">преобразование ввода/вывода</em>, используя указание <code class="literal">WITH INOUT</code>. В этом случае для приведения одного типа к другому вызывается функция вывода исходного типа данных, а выданная ей строка передаётся функции ввода целевого типа. Во многих случаях эта возможность избавляет от необходимости писать для преобразования всех типов отдельные функции приведения. Преобразование ввода/вывода работает так же, как и обычное приведение с функцией; отличается только реализация.</p><p>По умолчанию, приведение можно вызвать, только записав его явно, то есть применив конструкцию <code class="literal">CAST(<em class="replaceable"><code>x</code></em> AS <em class="replaceable"><code>имя_типа</code></em>)</code> или <em class="replaceable"><code>x</code></em><code class="literal">::</code><em class="replaceable"><code>имя_типа</code></em>.</p><p>Если приведение помечено <code class="literal">AS ASSIGNMENT</code>, его можно вызывать неявно, присваивая значение столбцу с целевым типом данных. Например, если <code class="literal">foo.f1</code> — столбец типа <code class="type">text</code>, то команда: </p><pre class="programlisting">INSERT INTO foo (f1) VALUES (42);</pre><p> будет допустимой, если приведение типа <code class="type">integer</code> к <code class="type">text</code> помечено <code class="literal">AS ASSIGNMENT</code>, и не будет в противном случае. (Для описания такого типа приведений мы обычно используем термин <em class="firstterm">приведение присваивания</em>.)</p><p>Если приведение помечено <code class="literal">AS IMPLICIT</code>, оно будет вызываться неявно в любом контексте, будь то присваивание или внутреннее преобразование в выражении. (Обычно мы называет приведение такого типа <em class="firstterm">неявным приведением</em>.) Например, рассмотрите этот запрос: </p><pre class="programlisting">SELECT 2 + 4.0;</pre><p> При разборе запроса константам сначала назначаются типы <code class="type">integer</code> и <code class="type">numeric</code>. Однако в системных каталогах нет оператора <code class="type">integer</code> <code class="literal">+</code> <code class="type">numeric</code>, хотя есть оператор <code class="type">numeric</code> <code class="literal">+</code> <code class="type">numeric</code>. Таким образом, запрос выполнится успешно, если существует преобразование типа <code class="type">integer</code> к <code class="type">numeric</code> с пометкой <code class="literal">AS IMPLICIT</code> — и на самом деле это так. Анализатор запроса применит неявное приведение и запрос будет обработан, как если бы он был записан в виде </p><pre class="programlisting">SELECT CAST ( 2 AS numeric ) + 4.0;</pre><p>Системные каталоги также содержат приведение типа <code class="type">numeric</code> к <code class="type">integer</code>. Если бы это приведение тоже было бы помечено <code class="literal">AS IMPLICIT</code> (на самом деле это не так), анализатору запроса пришлось бы выбирать между предыдущим вариантом и приведением константы <code class="type">numeric</code> к типу <code class="type">integer</code> с последующим применением оператора <code class="type">integer</code> <code class="literal">+</code> <code class="type">integer</code>. Не имея возможности выбрать лучший вариант, анализатор бы не смог разрешить запрос и объявил бы его неоднозначным. Именно благодаря тому, что только одно из двух приведений сделано неявным, анализатор приходит к пониманию, что предпочитаемым является преобразование выражения <code class="type">numeric</code>-и-<code class="type">integer</code> в <code class="type">numeric</code>; отдельного встроенного знания об этом нет.</p><p>Определяя, объявлять ли приведения неявными, разумно проявлять консерватизм. При чрезмерном количестве способов неявного приведения <span class="productname">PostgreSQL</span> может выбирать неожиданные интерпретации команд, или вовсе не сможет выполнить команды из-за наличия множества возможных интерпретаций. Как правило, следует делать приведение неявно вызываемым только для преобразований, сохраняющих информацию, между типами в одной общей категории типов. Например, приведение <code class="type">int2</code> к <code class="type">int4</code> разумно сделать неявным, но приведение <code class="type">float8</code> к <code class="type">int4</code>, возможно, лучше сделать только приведением присваивания. Приведения типов разных категорий, например, <code class="type">text</code> к <code class="type">int4</code>, лучше делать только явными.</p><div class="note"><h3 class="title">Примечание</h3><p>Иногда ради удобства или соответствия стандартам требуется ввести множество неявных преобразований для нескольких типов, что приводит к неизбежной неоднозначности. Чтобы анализатор запроса мог обеспечить желаемое поведение в таких случаях, он дополнительно принимает во внимание <em class="firstterm">категории типов</em> и <em class="firstterm">предпочитаемые типы</em>. Подробнее это описано в <a class="xref" href="sql-createtype.html" title="CREATE TYPE"><span class="refentrytitle">CREATE TYPE</span></a>.</p></div><p>Чтобы создать приведение, необходимо быть владельцем одного (исходного или целевого) типа и иметь право <code class="literal">USAGE</code> для другого типа. Создать двоично-сводимое приведение могут только суперпользователи. (Это ограничение введено потому, что преобразование данных с ошибочным двоичным сведением может легко вызывать сбой сервера.)</p></div><div class="refsect1" id="id-1.9.3.58.6"><h2>Параметры</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>исходный_тип</code></em></span></dt><dd><p>Имя исходного типа данных для приведения.</p></dd><dt><span class="term"><em class="replaceable"><code>целевой_тип</code></em></span></dt><dd><p>Имя целевого типа данных для приведения.</p></dd><dt><span class="term"><code class="literal"><em class="replaceable"><code>имя_функции</code></em>[(<em class="replaceable"><code>тип_аргумента</code></em> [, ...])]</code></span></dt><dd><p>Функция, вызываемая для выполнения приведения. Имя функции может быть дополнено схемой; в противном случае для поиска функции просматривается путь поиска. Тип данных результата должен соответствовать целевому типу приведения. Аргументы функции рассматриваются ниже. Если список аргументов отсутствует, имя функции должно быть уникальным в её схеме.</p></dd><dt><span class="term"><code class="literal">WITHOUT FUNCTION</code></span></dt><dd><p>Обозначает, что исходный тип сводится к целевому на двоичном уровне, так что функция для приведения не требуется.</p></dd><dt><span class="term"><code class="literal">WITH INOUT</code></span></dt><dd><p>Обозначает, что приведение выполняется как преобразование ввода/вывода, то есть вызывается функция вывода исходного типа данных, а её результат-строка передаётся функции ввода целевого типа.</p></dd><dt><span class="term"><code class="literal">AS ASSIGNMENT</code></span></dt><dd><p>Обозначает, что приведение может вызываться неявно в контексте присваивания.</p></dd><dt><span class="term"><code class="literal">AS IMPLICIT</code></span></dt><dd><p>Обозначает, что приведение может вызываться неявно в любом контексте.</p></dd></dl></div><p>Функции, реализующие приведение, могут иметь от одного до трёх аргументов. Тип первого аргумента должен быть идентичен или двоично-сводимым к исходному типу приведения. Второй аргумент, если он есть, должен иметь тип <code class="type">integer</code>; в нём передаётся модификатор типа, связанный с целевым типом, или <code class="literal">-1</code>, если он отсутствует. Третий аргумент, если он есть, должен иметь тип <code class="type">boolean</code>; в нём передаётся <code class="literal">true</code>, если приведение выполняется явно, либо <code class="literal">false</code> в противном случае. (Это довольно экстравагантно, но стандарт SQL предусматривает разное поведение для явного и неявного приведения в некоторых случаях. Этот аргумент предназначен для функций, которые должны реализовывать такие приведения. Однако создавать собственные типы данных, для которых это имело бы значение, не рекомендуется.)</p><p>Возвращаемый тип функции приведения должен быть идентичным или двоично-сводимым к целевому типу приведения.</p><p>Обычно исходный и целевой типы в приведении различаются, однако можно объявить приведение одного типа к такому же, если функция, реализующая преобразование, имеет более одного аргумента. Это используется для представления в системных каталогах функций, сводящих разные длины типов. Реализующая такое приведение функция будет сводить значение типа к значению с определённым модификатором, заданному вторым аргументом.</p><p>Когда исходный и целевой типы приведения различаются и функция принимает более одного аргумента, преобразование типа из одного в другой и сведение к нужной длине может выполняться за один шаг. Если же соответствующей записи не находится, приведение к типу с определённым модификатором выполняется в два этапа: сначала выполняется преобразование типа, а затем применяется модификатор типа.</p><p>Приведение типа домена или к типу домена в настоящее время не осуществляется. При попытке выполнить такое приведение вместо него выполняется приведение, связанное с базовым типом домена.</p></div><div class="refsect1" id="SQL-CREATECAST-NOTES"><h2>Замечания</h2><p>Для удаления приведений, созданных пользователем, применяется <a class="link" href="sql-dropcast.html" title="DROP CAST"><code class="command">DROP CAST</code></a>.</p><p>Помните, что когда требуется преобразовывать типы в обе стороны, необходимо явно описать два приведения.</p><a id="id-1.9.3.58.7.4" class="indexterm"></a><p>Обычно не требуется создавать приведения между пользовательскими типами и стандартными строковыми типами (<code class="type">text</code>, <code class="type">varchar</code> и <code class="type">char(<em class="replaceable"><code>n</code></em>)</code>, а также пользовательскими типами, относящимися к категории строковых). Для них <span class="productname">PostgreSQL</span> предоставляет автоматическое преобразование ввода/вывода. Автоматические приведения к строковым типам считаются приведениями присваивания, а автоматические приведения строковых типов к другим могут быть только явными. Это поведение можно переопределить, создав собственное приведение, заменяющее автоматическое, но обычно это нужно, только чтобы сделать вызов более удобным, чем стандартное только присваивание или явное указание. Возможен и другой повод для такого переопределения — желание создать приведение, работающее не так, как функция ввода/вывода типа; но это настолько удивительно, что следует дважды подумать, хороша ли эта идея. (На самом деле у небольшого количества встроенных типов имеются подобные специфические приведения, в основном из-за требований стандарта SQL.)</p><p>Хотя это и не обязательно, но рекомендуется следовать старому соглашению называть функции, реализующие приведение, по целевому типу данных. Многие привыкли выполнять преобразование типов данных, записывая его в стиле функций, т. е. <em class="replaceable"><code>имя_типа</code></em>(<em class="replaceable"><code>x</code></em>). Эта запись на самом деле ни больше ни меньше как просто вызов функции, реализующей приведение; такой вызов не воспринимается как именно приведение. Если называть функции, не следуя этому соглашению, это может оказаться неожиданным для пользователей. Так как <span class="productname">PostgreSQL</span> позволяет перегружать одно и то же имя функции с разными типами аргументов, ничто не мешает создать множество функций приведения разных типов к одному, названных по имени этого целевого типа.</p><div class="note"><h3 class="title">Примечание</h3><p>Вообще говоря, в предыдущем абзаце допущено некоторое упрощение: есть два случая, когда конструкция с вызовом функции исполняется как приведение, без сопоставления с фактической функцией. Если вызову функции <em class="replaceable"><code>имя</code></em>(<em class="replaceable"><code>x</code></em>) в точности не соответствует существующая функция, но имеется тип данных <em class="replaceable"><code>имя</code></em> и в <code class="structname">pg_cast</code> есть двоично-сводимое приведение типа <em class="replaceable"><code>x</code></em> к этому типу, такой вызов будет воспринят как приведение. Это исключение введено, чтобы двоично-сводимое приведение можно было вызывать, используя синтаксис функций, несмотря на то, что никакой функции преобразования у него нет. Аналогично, если запись приведения в <code class="structname">pg_cast</code> отсутствует, но в случае приведения это было бы преобразование в/из строкового типа, такой вызов будет выполнен как преобразование ввода/вывода. Это исключение позволяет вызывать преобразование ввода/вывода, используя синтаксис вызова функции.</p></div><div class="note"><h3 class="title">Примечание</h3><p>Но есть исключение и из этого исключения: преобразование ввода/вывода из составных типов в строковые нельзя вызвать в виде функции, его необходимо записать как явное приведение (используя <code class="literal">CAST</code> или запись <code class="literal">::</code>). Это исключение было добавлено, потому что после введения автоматически предоставляемых преобразований ввода/вывода, оказалось слишком легко случайно вызвать такое приведение, тогда как имелась в виду ссылка на столбец или функцию.</p></div></div><div class="refsect1" id="SQL-CREATECAST-EXAMPLES"><h2>Примеры</h2><p>Создание приведения присваивания типа <code class="type">bigint</code> к типу <code class="type">int4</code> с помощью функции <code class="literal">int4(bigint)</code>: </p><pre class="programlisting">CREATE CAST (bigint AS int4) WITH FUNCTION int4(bigint) AS ASSIGNMENT;</pre><p> (Это приведение уже предопределено в системе.)</p></div><div class="refsect1" id="SQL-CREATECAST-COMPAT"><h2>Совместимость</h2><p>Команда <code class="command">CREATE CAST</code> соответствует стандарту <acronym class="acronym">SQL</acronym>, за исключением того, что в стандарте ничего не говорится о двоично-сводимых типах и дополнительных аргументах реализующих функций. Указание <code class="literal">AS IMPLICIT</code> тоже является расширением <span class="productname">PostgreSQL</span>.</p></div><div class="refsect1" id="SQL-CREATECAST-SEEALSO"><h2>См. также</h2><p><a class="xref" href="sql-createfunction.html" title="CREATE FUNCTION"><span class="refentrytitle">CREATE FUNCTION</span></a>, <a class="xref" href="sql-createtype.html" title="CREATE TYPE"><span class="refentrytitle">CREATE TYPE</span></a>, <a class="xref" href="sql-dropcast.html" title="DROP CAST"><span class="refentrytitle">DROP CAST</span></a></p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-createaggregate.html" title="CREATE AGGREGATE">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-createcollation.html" title="CREATE COLLATION">След.</a></td></tr><tr><td width="40%" align="left" valign="top">CREATE AGGREGATE </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> CREATE COLLATION</td></tr></table></div></body></html>