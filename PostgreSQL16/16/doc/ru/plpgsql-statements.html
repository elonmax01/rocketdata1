<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>43.5. Основные операторы</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="plpgsql-expressions.html" title="43.4. Выражения" /><link rel="next" href="plpgsql-control-structures.html" title="43.6. Управляющие структуры" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">43.5. Основные операторы</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="plpgsql-expressions.html" title="43.4. Выражения">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="plpgsql.html" title="Глава 43. PL/pgSQL — процедурный язык SQL">Наверх</a></td><th width="60%" align="center">Глава 43. <span class="application">PL/pgSQL</span> — процедурный язык <acronym class="acronym">SQL</acronym></th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="plpgsql-control-structures.html" title="43.6. Управляющие структуры">След.</a></td></tr></table><hr /></div><div class="sect1" id="PLPGSQL-STATEMENTS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">43.5. Основные операторы <a href="#PLPGSQL-STATEMENTS" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="plpgsql-statements.html#PLPGSQL-STATEMENTS-ASSIGNMENT">43.5.1. Присваивания</a></span></dt><dt><span class="sect2"><a href="plpgsql-statements.html#PLPGSQL-STATEMENTS-GENERAL-SQL">43.5.2. Выполнение команд SQL</a></span></dt><dt><span class="sect2"><a href="plpgsql-statements.html#PLPGSQL-STATEMENTS-SQL-ONEROW">43.5.3. Выполнение команды, возвращающей одну строку</a></span></dt><dt><span class="sect2"><a href="plpgsql-statements.html#PLPGSQL-STATEMENTS-EXECUTING-DYN">43.5.4. Выполнение динамически формируемых команд</a></span></dt><dt><span class="sect2"><a href="plpgsql-statements.html#PLPGSQL-STATEMENTS-DIAGNOSTICS">43.5.5. Статус выполнения команды</a></span></dt><dt><span class="sect2"><a href="plpgsql-statements.html#PLPGSQL-STATEMENTS-NULL">43.5.6. Не делать ничего</a></span></dt></dl></div><p>В этом и последующих разделах описаны все типы операторов, которые понимает <span class="application">PL/pgSQL</span>. Все, что не признается в качестве одного из этих типов операторов, считается командой SQL и отправляется для исполнения в основную машину базы данных, как описано в <a class="xref" href="plpgsql-statements.html#PLPGSQL-STATEMENTS-GENERAL-SQL" title="43.5.2. Выполнение команд SQL">Подразделе 43.5.2</a>.</p><div class="sect2" id="PLPGSQL-STATEMENTS-ASSIGNMENT"><div class="titlepage"><div><div><h3 class="title">43.5.1. Присваивания <a href="#PLPGSQL-STATEMENTS-ASSIGNMENT" class="id_link">#</a></h3></div></div></div><p>Присваивание значения переменной <span class="application">PL/pgSQL</span> записывается в виде: </p><pre class="synopsis">
<em class="replaceable"><code>переменная</code></em> { := | = } <em class="replaceable"><code>выражение</code></em>;
</pre><p> Как описывалось ранее, выражение в таком операторе вычисляется с помощью SQL-команды <code class="command">SELECT</code>, посылаемой в основную машину базы данных. Выражение должно получить одно значение (возможно, значение строки, если это переменная-кортеж или переменная типа <code class="type">record</code>). Целевая переменная может быть простой переменной (возможно, дополненной именем блока); полем в целевом кортеже или записи; или элементом или срезом целевого массива. Для присваивания можно использовать знак равенства (<code class="literal">=</code>) вместо совместимого с PL/SQL <code class="literal">:=</code>.</p><p>Если тип данных результата выражения не соответствует типу данных переменной, это значение будет преобразовано к нужному типу с использованием приведения присваивания (см. <a class="xref" href="typeconv-query.html" title="10.4. Хранимое значение">Раздел 10.4</a>). В случае отсутствия приведения присваивания для этой пары типов, интерпретатор <span class="application">PL/pgSQL</span> попытается преобразовать значение результата через текстовый формат, то есть применив функцию вывода типа результата, а за ней функцию ввода типа переменной. Заметьте, что при этом функция ввода может выдавать ошибки времени выполнения, если не воспримет строковое представление значения результата.</p><p>Примеры: </p><pre class="programlisting">tax := subtotal * 0.06;
my_record.user_id := 20;
my_array[j] := 20;
my_array[1:3] := array[1,2,3];
complex_array[n].realpart = 12.3;</pre></div><div class="sect2" id="PLPGSQL-STATEMENTS-GENERAL-SQL"><div class="titlepage"><div><div><h3 class="title">43.5.2. Выполнение команд SQL <a href="#PLPGSQL-STATEMENTS-GENERAL-SQL" class="id_link">#</a></h3></div></div></div><p>Вообще говоря, в функции на <span class="application">PL/pgSQL</span> можно выполнить любую команду SQL, не возвращающую строк, просто написав эту команду. Например, можно создать таблицу и заполнить её данными, написав </p><pre class="programlisting">CREATE TABLE mytable (id int primary key, data text);
INSERT INTO mytable VALUES (1,'one'), (2,'two');</pre><p>Если команда всё же возвращает строки (например, <code class="command">SELECT</code> или <code class="command">INSERT</code>/<code class="command">UPDATE</code>/<code class="command">DELETE</code> с предложением <code class="literal">RETURNING</code>), есть два варианта действий. Если команда возвращает максимум одну строку или вам интересна только первая строка результата, напишите команду как обычно, но добавьте предложение <code class="literal">INTO</code> для захвата вывода, как описано в <a class="xref" href="plpgsql-statements.html#PLPGSQL-STATEMENTS-SQL-ONEROW" title="43.5.3. Выполнение команды, возвращающей одну строку">Подразделе 43.5.3</a>. Чтобы обрабатывать все результирующие строки, запишите команду в качестве источника данных для цикла <code class="command">FOR</code>, как описано в <a class="xref" href="plpgsql-control-structures.html#PLPGSQL-RECORDS-ITERATING" title="43.6.6. Цикл по результатам запроса">Подразделе 43.6.6</a>.</p><p>Обычно недостаточно выполнять только статически определённые SQL-команды. Как правило, желательно, чтобы в команде использовались различные значения данных или она менялась более кардинально, например использовала разные имена таблиц от запуска к запуску. Это можно сделать двумя способами.</p><p>Значения переменных <span class="application">PL/pgSQL</span> могут автоматически вставляться в оптимизируемые SQL-команды: <code class="command">SELECT</code>, <code class="command">INSERT</code>, <code class="command">UPDATE</code>, <code class="command">DELETE</code>, <code class="command">MERGE</code> и определённые служебные команды, содержащие вышеперечисленные, например <code class="command">EXPLAIN</code> и <code class="command">CREATE TABLE ... AS SELECT</code>. Имя любой переменной <span class="application">PL/pgSQL</span> в текстах этих команд рассматривается как параметр, и значение переменной подставляется в качестве значения параметра во время выполнения. Это в точности совпадает с описанной ранее обработкой для выражений; за подробностями обратитесь к <a class="xref" href="plpgsql-implementation.html#PLPGSQL-VAR-SUBST" title="43.11.1. Подстановка переменных">Подразделу 43.11.1</a>.</p><p>При выполнении оптимизируемой SQL-команды таким образом, <span class="application">PL/pgSQL</span> может кешировать и повторно использовать план выполнения команды, как обсуждается в <a class="xref" href="plpgsql-implementation.html#PLPGSQL-PLAN-CACHING" title="43.11.2. Кеширование плана">Подразделе 43.11.2</a>.</p><p>Неоптимизируемые SQL-команды (также называемые служебными командами) не принимают параметры запроса. Поэтому в таких командах не работает автоматическая замена переменных <span class="application">PL/pgSQL</span>. Чтобы включить изменяемый текст в служебную команду, запускаемую из <span class="application">PL/pgSQL</span>, необходимо составить текст команды в виде строки и выполнить её в <code class="command">EXECUTE</code>, как описано в <a class="xref" href="plpgsql-statements.html#PLPGSQL-STATEMENTS-EXECUTING-DYN" title="43.5.4. Выполнение динамически формируемых команд">Подразделе 43.5.4</a>.</p><p>Если нужно изменять команду, не просто передавая ей разные значения данных, а например меняя имя таблицы, также нужно использовать оператор <code class="command">EXECUTE</code>.</p><p>Иногда бывает полезно вычислить значение выражения или запроса <code class="command">SELECT</code>, но отказаться от результата, например, при вызове функции, у которой есть побочные эффекты, но нет полезного результата. Для этого в <span class="application">PL/pgSQL</span>, используется оператор <code class="command">PERFORM</code>: </p><pre class="synopsis">
PERFORM <em class="replaceable"><code>запрос</code></em>;
</pre><p> Эта команда выполняет <em class="replaceable"><code>запрос</code></em> и отбрасывает результат. <em class="replaceable"><code>Запросы</code></em> пишутся таким же образом, как и в команде SQL <code class="command">SELECT</code>, но ключевое слово <code class="command">SELECT</code> заменяется на <code class="command">PERFORM</code>. Для запросов <code class="command">WITH</code> после <code class="command">PERFORM</code> нужно поместить запрос в скобки. (В этом случае запрос может вернуть только одну строку.) Переменные <span class="application">PL/pgSQL</span> будут подставлены в запрос так же, как описано выше, план запроса также кешируется. Кроме того, специальная переменная <code class="literal">FOUND</code> принимает значение true, если запрос возвращает, по крайней мере, одну строку, или false, если не возвращает ни одной строки (см. <a class="xref" href="plpgsql-statements.html#PLPGSQL-STATEMENTS-DIAGNOSTICS" title="43.5.5. Статус выполнения команды">Подраздел 43.5.5</a>).</p><div class="note"><h3 class="title">Примечание</h3><p>Можно предположить, что такой же результат получается непосредственно командой <code class="command">SELECT</code>, но в настоящее время использование <code class="command">PERFORM</code> является единственным способом. Команда SQL, которая может возвращать строки, например <code class="command">SELECT</code>, будет отклонена с ошибкой, если не имеет предложения <code class="literal">INTO</code>, как описано в следующем разделе.</p></div><p>Пример: </p><pre class="programlisting">PERFORM create_mv('cs_session_page_requests_mv', my_query);</pre></div><div class="sect2" id="PLPGSQL-STATEMENTS-SQL-ONEROW"><div class="titlepage"><div><div><h3 class="title">43.5.3. Выполнение команды, возвращающей одну строку <a href="#PLPGSQL-STATEMENTS-SQL-ONEROW" class="id_link">#</a></h3></div></div></div><a id="id-1.8.8.7.5.2" class="indexterm"></a><a id="id-1.8.8.7.5.3" class="indexterm"></a><p>Результат SQL-команды, возвращающей одну строку (возможно из нескольких столбцов), может быть присвоен переменной типа <code class="type">record</code>, переменной-кортежу или списку скалярных переменных. Для этого нужно к основной команде SQL добавить предложение <code class="literal">INTO</code>. Так, например: </p><pre class="synopsis">
SELECT <em class="replaceable"><code>выражения_select</code></em> INTO [<span class="optional">STRICT</span>] <em class="replaceable"><code>цель</code></em> FROM ...;
INSERT ... RETURNING <em class="replaceable"><code>выражения</code></em> INTO [<span class="optional">STRICT</span>] <em class="replaceable"><code>цель</code></em>;
UPDATE ... RETURNING <em class="replaceable"><code>выражения</code></em> INTO [<span class="optional">STRICT</span>] <em class="replaceable"><code>цель</code></em>;
DELETE ... RETURNING <em class="replaceable"><code>выражения</code></em> INTO [<span class="optional">STRICT</span>] <em class="replaceable"><code>цель</code></em>;
</pre><p> где <em class="replaceable"><code>цель</code></em> может быть переменной типа <code class="type">record</code>, переменной-кортежем или разделённым запятыми списком скалярных переменных, полей записи/строки. Переменные <span class="application">PL/pgSQL</span> подставляются в оставшуюся часть команды (то есть везде, кроме предложения <code class="literal">INTO</code>), как было описано выше, и план выполнения кешируется так же. Это работает для команд <code class="command">SELECT</code>, <code class="command">INSERT</code>/<code class="command">UPDATE</code>/<code class="command">DELETE</code> с предложением <code class="literal">RETURNING</code> и определённых служебных команд, возвращающих результат в виде набора строк (таких как <code class="command">EXPLAIN</code>). За исключением предложения <code class="literal">INTO</code>, это те же SQL-команды, как их можно написать вне <span class="application">PL/pgSQL</span>.</p><div class="tip"><h3 class="title">Подсказка</h3><p>Обратите внимание, что данная интерпретация <code class="command">SELECT</code> с <code class="literal">INTO</code> полностью отличается от <span class="productname">PostgreSQL</span> команды <code class="command">SELECT INTO</code>, где в <code class="literal">INTO</code> указывается вновь создаваемая таблица. Если вы хотите в функции на <span class="application">PL/pgSQL</span> создать таблицу, основанную на результате команды <code class="command">SELECT</code>, используйте синтаксис <code class="command">CREATE TABLE ... AS SELECT</code>.</p></div><p>Если результат команды присваивается переменной-кортежу или списку переменных, то они должны в точности соответствовать по количеству и типам данных столбцам результата, иначе произойдёт ошибка во время выполнения. Если используется переменная типа <code class="type">record</code>, то она автоматически приводится к типу строки результата команды.</p><p>Предложение INTO может появиться практически в любом месте SQL-команды. Обычно его записывают непосредственно перед или сразу после списка <em class="replaceable"><code>выражения_select</code></em> в <code class="command">SELECT</code> или в конце команды для команд других типов. Рекомендуется следовать этому соглашению на случай, если правила разбора <span class="application">PL/pgSQL</span> ужесточатся в будущих версиях.</p><p>Если указание <code class="literal">STRICT</code> отсутствует в предложении <code class="literal">INTO</code>, то <em class="replaceable"><code>цели</code></em> присваивается первая строка, возвращённая командой; или NULL, если команда не вернула строки. (Заметим, что понятие <span class="quote">«<span class="quote">первая строка</span>»</span> определяется неоднозначно без <code class="literal">ORDER BY</code>.) Все остальные строки результата после первой отбрасываются. Можно проверить специальную переменную <code class="literal">FOUND</code> (см. <a class="xref" href="plpgsql-statements.html#PLPGSQL-STATEMENTS-DIAGNOSTICS" title="43.5.5. Статус выполнения команды">Подраздел 43.5.5</a>), чтобы определить, была ли возвращена запись: </p><pre class="programlisting">SELECT * INTO myrec FROM emp WHERE empname = myname;
IF NOT FOUND THEN
    RAISE EXCEPTION 'Сотрудник % не найден', myname;
END IF;</pre><p> Если добавлено указание <code class="literal">STRICT</code>, то команда должна вернуть ровно одну строку или произойдёт ошибка во время выполнения: либо <code class="literal">NO_DATA_FOUND</code> (нет строк), либо <code class="literal">TOO_MANY_ROWS</code> (более одной строки). Можно использовать секцию исключений в блоке для обработки ошибок, например: </p><pre class="programlisting">BEGIN
    SELECT * INTO STRICT myrec FROM emp WHERE empname = myname;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE EXCEPTION 'Сотрудник % не найден', myname;
        WHEN TOO_MANY_ROWS THEN
            RAISE EXCEPTION 'Сотрудник % уже существует', myname;
END;</pre><p> После успешного выполнения команды с указанием <code class="literal">STRICT</code>, значение переменной <code class="literal">FOUND</code> всегда принимает значение true.</p><p>Для <code class="command">INSERT</code>/<code class="command">UPDATE</code>/<code class="command">DELETE</code> с <code class="literal">RETURNING</code>, <span class="application">PL/pgSQL</span> возвращает ошибку, если выбрано более одной строки, даже в том случае, когда указание <code class="literal">STRICT</code> отсутствует. Так происходит потому, что у этих команд нет возможности, типа <code class="literal">ORDER BY</code>, указать какая из задействованных строк должна быть возвращена.</p><p>Если для функции включён режим <code class="literal">print_strict_params</code>, то при возникновении ошибки, связанной с нарушением условия <code class="literal">STRICT</code>, в детальную (<code class="literal">DETAIL</code>) часть сообщения об ошибке будет включена информация о параметрах, переданных команде. Изменить значение <code class="literal">print_strict_params</code> можно установкой параметра <code class="varname">plpgsql.print_strict_params</code>. Но это повлияет только на функции, скомпилированные после изменения. Для конкретной функции можно использовать указание компилятора, например: </p><pre class="programlisting">CREATE FUNCTION get_userid(username text) RETURNS int
AS $$
#print_strict_params on
DECLARE
userid int;
BEGIN
    SELECT users.userid INTO STRICT userid
        FROM users WHERE users.username = get_userid.username;
    RETURN userid;
END;
$$ LANGUAGE plpgsql;</pre><p> В случае сбоя будет сформировано примерно такое сообщение об ошибке </p><pre class="programlisting">ERROR:  query returned no rows
DETAIL:  parameters: $1 = 'nosuchuser'
CONTEXT:  PL/pgSQL function get_userid(text) line 6 at SQL statement</pre><div class="note"><h3 class="title">Примечание</h3><p>С указанием <code class="literal">STRICT</code> поведение <code class="command">SELECT INTO</code> и связанных операторов соответствует принятому в Oracle PL/SQL.</p></div></div><div class="sect2" id="PLPGSQL-STATEMENTS-EXECUTING-DYN"><div class="titlepage"><div><div><h3 class="title">43.5.4. Выполнение динамически формируемых команд <a href="#PLPGSQL-STATEMENTS-EXECUTING-DYN" class="id_link">#</a></h3></div></div></div><p>Часто требуется динамически формировать команды внутри функций на <span class="application">PL/pgSQL</span>, то есть такие команды, в которых при каждом выполнении могут использоваться разные таблицы или типы данных. Обычно <span class="application">PL/pgSQL</span> кеширует планы выполнения (как описано в <a class="xref" href="plpgsql-implementation.html#PLPGSQL-PLAN-CACHING" title="43.11.2. Кеширование плана">Подразделе 43.11.2</a>), но в случае с динамическими командами это не будет работать. Для исполнения динамических команд предусмотрен оператор <code class="command">EXECUTE</code>: </p><pre class="synopsis">
EXECUTE <em class="replaceable"><code>строка-команды</code></em> [<span class="optional"> INTO [<span class="optional">STRICT</span>] <em class="replaceable"><code>цель</code></em> </span>] [<span class="optional"> USING <em class="replaceable"><code>выражение</code></em> [<span class="optional">, ... </span>] </span>];
</pre><p> где <em class="replaceable"><code>строка-команды</code></em> это выражение, формирующее строку (типа <code class="type">text</code>) с текстом команды, которую нужно выполнить. Необязательная <em class="replaceable"><code>цель</code></em> — это переменная-запись, переменная-кортеж или разделённый запятыми список простых переменных и полей записи/кортежа, куда будут помещены результаты команды. Необязательные выражения в <code class="literal">USING</code> формируют значения, которые будут вставлены в команду.</p><p>В сформированном тексте команды замена имён переменных <span class="application">PL/pgSQL</span> на их значения проводиться не будет. Все необходимые значения переменных должны быть вставлены в командную строку при её построении, либо нужно использовать параметры, как описано ниже.</p><p>Также нет никакого кеширования плана для команд, выполняемых с помощью <code class="command">EXECUTE</code>. Вместо этого план создаётся каждый раз при выполнении. Таким образом, строка команды может динамически создаваться внутри функции для выполнения действий с различными таблицами и столбцами.</p><p>Предложение <code class="literal">INTO</code> указывает, куда должны быть помещены результаты SQL-команды, возвращающей строки. Если используется переменная-кортеж или список переменных, то они должны в точности соответствовать структуре результата команды; если используется переменная типа <code class="type">record</code>, она автоматически приводится к типу строки результата запроса. Если возвращается несколько строк, то только первая будет присвоена переменной(ым) в <code class="literal">INTO</code>. Если не возвращается ни одной строки, то присваивается NULL. Без предложения <code class="literal">INTO</code> результаты команды отбрасываются.</p><p>С указанием <code class="literal">STRICT</code> команда должна вернуть ровно одну строку, иначе выдаётся сообщение об ошибке.</p><p>В тексте команды можно использовать значения параметров, ссылки на параметры обозначаются как <code class="literal">$1</code>, <code class="literal">$2</code> и т. д. Эти символы указывают на значения, находящиеся в предложении <code class="literal">USING</code>. Такой метод зачастую предпочтительнее, чем вставка значений в команду в виде текста: он позволяет исключить во время выполнения дополнительные расходы на преобразования значений в текст и обратно, и не открывает возможности для SQL-инъекций, не требуя применять экранирование или кавычки для спецсимволов. Пример: </p><pre class="programlisting">EXECUTE 'SELECT count(*) FROM mytable WHERE inserted_by = $1 AND inserted &lt;= $2'
   INTO c
   USING checked_user, checked_date;</pre><p>Обратите внимание, что символы параметров можно использовать только вместо значений данных. Если же требуется динамически формировать имена таблиц или столбцов, их необходимо вставлять в виде текста. Например, если в предыдущем запросе необходимо динамически задавать имя таблицы, можно сделать следующее: </p><pre class="programlisting">EXECUTE 'SELECT count(*) FROM '
    || quote_ident(tabname)
    || ' WHERE inserted_by = $1 AND inserted &lt;= $2'
   INTO c
   USING checked_user, checked_date;</pre><p> Более аккуратным решением будет использование указания <code class="literal">%I</code> с функцией <code class="function">format()</code>, позволяющее вставить имя таблицы или столбца, которое будет автоматически заключено в кавычки: </p><pre class="programlisting">EXECUTE format('SELECT count(*) FROM %I '
   'WHERE inserted_by = $1 AND inserted &lt;= $2', tabname)
   INTO c
   USING checked_user, checked_date;</pre><p> (Этот пример задействует SQL-правило, согласно которому строковые значения, разделённые символом новой строки, соединяются вместе.)</p><p>Ещё одно ограничение состоит в том, что символы параметров могут использоваться только в оптимизируемых SQL-командах (<code class="command">SELECT</code>, <code class="command">INSERT</code>, <code class="command">UPDATE</code>, <code class="command">DELETE</code>, <code class="command">MERGE</code> и некоторых командах, содержащих одну из них). В операторы других типов (обычно называемые служебными) значения нужно вставлять в текстовом виде, даже если это просто значения данных.</p><p>Команда <code class="command">EXECUTE</code> c неизменяемым текстом и параметрами USING (как в первом примере выше), функционально эквивалентна команде, записанной напрямую в <span class="application">PL/pgSQL</span>, в которой переменные <span class="application">PL/pgSQL</span> автоматически заменяются значениями. Важное отличие в том, что <code class="command">EXECUTE</code> при каждом исполнении заново строит план команды с учётом текущих значений параметров, тогда как <span class="application">PL/pgSQL</span> строит общий план выполнения и кеширует его при повторном использовании. В тех случаях, когда наилучший план выполнения сильно зависит от значений параметров, может быть полезно использовать <code class="command">EXECUTE</code> для гарантии того, что не будет выбран общий план.</p><p>В настоящее время команда <code class="command">SELECT INTO</code> не поддерживается в <code class="command">EXECUTE</code>, вместо этого нужно выполнять обычный <code class="command">SELECT</code> и указать <code class="literal">INTO</code> для самой команды <code class="command">EXECUTE</code>.</p><div class="note"><h3 class="title">Примечание</h3><p>Оператор <code class="command">EXECUTE</code> в <span class="application">PL/pgSQL</span> не имеет отношения к одноимённому SQL-оператору сервера <span class="productname">PostgreSQL</span>. Серверный <a class="link" href="sql-execute.html" title="EXECUTE"><code class="command">EXECUTE</code></a> не может напрямую использоваться в функциях на <span class="application">PL/pgSQL</span> (и в этом нет необходимости).</p></div><div class="example" id="PLPGSQL-QUOTE-LITERAL-EXAMPLE"><p class="title"><strong>Пример 43.1. Использование кавычек в динамических запросах</strong></p><div class="example-contents"><a id="id-1.8.8.7.6.13.2" class="indexterm"></a><a id="id-1.8.8.7.6.13.3" class="indexterm"></a><a id="id-1.8.8.7.6.13.4" class="indexterm"></a><a id="id-1.8.8.7.6.13.5" class="indexterm"></a><p>При работе с динамическими командами часто приходится иметь дело с экранированием одинарных кавычек. Рекомендуемым методом для взятия текста в кавычки в теле функции является экранирование знаками доллара. (Если имеется унаследованный код, не использующий этот метод, пожалуйста, обратитесь к обзору в <a class="xref" href="plpgsql-development-tips.html#PLPGSQL-QUOTE-TIPS" title="43.12.1. Обработка кавычек">Подразделе 43.12.1</a>, это поможет сэкономить усилия при переводе кода к более приемлемому виду.)</p><p>Динамические значения требуют особого внимания, так как они могут содержать апострофы. Например, можно использовать функцию <code class="function">format()</code> (предполагается, что тело функции заключается в доллары, так что апострофы дублировать не нужно): </p><pre class="programlisting">EXECUTE format('UPDATE tbl SET %I = $1 '
   'WHERE key = $2', colname) USING newvalue, keyvalue;</pre><p> Также можно напрямую вызывать функции заключения в кавычки: </p><pre class="programlisting">EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = '
        || quote_literal(newvalue)
        || ' WHERE key = '
        || quote_literal(keyvalue);</pre><p>Этот пример демонстрирует использование функций <code class="function">quote_ident</code> и <code class="function">quote_literal</code> (см. <a class="xref" href="functions-string.html" title="9.4. Строковые функции и операторы">Раздел 9.4</a>). Для надёжности, выражения, содержащие идентификаторы столбцов и таблиц должны использовать функцию <code class="function">quote_ident</code> при добавлении в текст запроса. А для выражений со значениями, которые должны быть обычными строками, используется функция <code class="function">quote_literal</code>. Эти функции выполняют соответствующие шаги, чтобы вернуть текст, заключённый в двойные или одинарные кавычки соответственно и с правильно экранированными специальными символами.</p><p>Так как функция <code class="function">quote_literal</code> помечена как <code class="literal">STRICT</code>, то она всегда возвращает NULL, если переданный ей аргумент имеет значение NULL. В приведённом выше примере, если <code class="literal">newvalue</code> или <code class="literal">keyvalue</code> были NULL, вся строка с текстом запроса станет NULL, что приведёт к ошибке в <code class="command">EXECUTE</code>. Для предотвращения этой проблемы используйте функцию <code class="function">quote_nullable</code>, которая работает так же, как <code class="function">quote_literal</code> за исключением того, что при вызове с пустым аргументом возвращает строку 'NULL'. Например: </p><pre class="programlisting">EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = '
        || quote_nullable(newvalue)
        || ' WHERE key = '
        || quote_nullable(keyvalue);</pre><p> Если вы имеете дело со значениями, которые могут быть пустыми, то, как правило, нужно использовать <code class="function">quote_nullable</code> вместо <code class="function">quote_literal</code>.</p><p>Как обычно, необходимо убедиться, что значения NULL в запросе не принесут неожиданных результатов. Например, следующее условие <code class="literal">WHERE</code> </p><pre class="programlisting">'WHERE key = ' || quote_nullable(keyvalue)</pre><p> никогда не выполнится, если <code class="literal">keyvalue</code> — NULL, так как применение <code class="literal">=</code> с операндом, имеющим значение NULL, всегда даёт NULL. Если требуется, чтобы NULL обрабатывалось как обычное значение, то условие выше нужно переписать так: </p><pre class="programlisting">'WHERE key IS NOT DISTINCT FROM ' || quote_nullable(keyvalue)</pre><p> (В настоящее время <code class="literal">IS NOT DISTINCT FROM</code> работает менее эффективно, чем <code class="literal">=</code>, так что используйте этот способ, только если это действительно необходимо. Подробнее особенности NULL и <code class="literal">IS DISTINCT</code> описаны в <a class="xref" href="functions-comparison.html" title="9.2. Функции и операторы сравнения">Разделе 9.2</a>.)</p><p>Обратите внимание, что использование знака $ полезно только для взятия в кавычки фиксированного текста. Плохая идея написать этот пример так: </p><pre class="programlisting">EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = $$'
        || newvalue
        || '$$ WHERE key = '
        || quote_literal(keyvalue);</pre><p> потому что <code class="literal">newvalue</code> может также содержать <code class="literal">$$</code>. Эта же проблема может возникнуть и с любым другим разделителем, используемым после знака <code class="literal">$</code>. Поэтому, чтобы безопасно заключить заранее неизвестный текст в кавычки, <span class="emphasis"><em>нужно</em></span> использовать соответствующие функции: <code class="function">quote_literal</code>, <code class="function">quote_nullable</code>, или <code class="function">quote_ident</code>.</p><p>Динамические операторы SQL также можно безопасно сформировать, используя функцию <code class="function">format</code> (см. <a class="xref" href="functions-string.html#FUNCTIONS-STRING-FORMAT" title="9.4.1. format">Подраздел 9.4.1</a>). Например: </p><pre class="programlisting">EXECUTE format('UPDATE tbl SET %I = %L '
   'WHERE key = %L', colname, newvalue, keyvalue);</pre><p> Указание <code class="literal">%I</code> равнозначно вызову <code class="function">quote_ident</code>, а <code class="literal">%L</code> — вызову <code class="function">quote_nullable</code>. Функция <code class="function">format</code> может применяться в сочетании с предложением <code class="literal">USING</code>: </p><pre class="programlisting">EXECUTE format('UPDATE tbl SET %I = $1 WHERE key = $2', colname)
   USING newvalue, keyvalue;</pre><p> Эта форма лучше, так как с ней переменные обрабатываются в их собственном формате данных, а не преобразуются безусловно в текст, чтобы затем выводиться с использованием <code class="literal">%L</code>. Она также и более эффективна.</p></div></div><br class="example-break" /><p>Более объёмный пример использования динамической команды и <code class="command">EXECUTE</code> можно увидеть в <a class="xref" href="plpgsql-porting.html#PLPGSQL-PORTING-EX2" title="Пример 43.10. Портирование функции, создающей другую функцию, из PL/SQL в PL/pgSQL">Примере 43.10</a>. В нём создаётся и динамически выполняется команда <code class="command">CREATE FUNCTION</code> для определения новой функции.</p></div><div class="sect2" id="PLPGSQL-STATEMENTS-DIAGNOSTICS"><div class="titlepage"><div><div><h3 class="title">43.5.5. Статус выполнения команды <a href="#PLPGSQL-STATEMENTS-DIAGNOSTICS" class="id_link">#</a></h3></div></div></div><p>Определить результат команды можно несколькими способами. Во-первых, можно воспользоваться командой <code class="command">GET DIAGNOSTICS</code>, имеющей форму: </p><pre class="synopsis">
GET [<span class="optional"> CURRENT </span>] DIAGNOSTICS <em class="replaceable"><code>переменная</code></em> { = | := } <em class="replaceable"><code>элемент</code></em> [<span class="optional"> , ... </span>];
</pre><p> Эта команда позволяет получить системные индикаторы состояния. Слово <code class="literal">CURRENT</code> не несёт смысловой нагрузки (но см. также описание <code class="command">GET STACKED DIAGNOSTICS</code> в <a class="xref" href="plpgsql-control-structures.html#PLPGSQL-EXCEPTION-DIAGNOSTICS" title="43.6.8.1. Получение информации об ошибке">Подразделе 43.6.8.1</a>). Каждый <em class="replaceable"><code>элемент</code></em> представляется ключевым словом, указывающим, какое значение состояния нужно присвоить заданной <em class="replaceable"><code>переменной</code></em> (она должна иметь подходящий тип данных, чтобы принять его). Доступные в настоящее время элементы состояния показаны в <a class="xref" href="plpgsql-statements.html#PLPGSQL-CURRENT-DIAGNOSTICS-VALUES" title="Таблица 43.1. Доступные элементы диагностики">Таблице 43.1</a>. Вместо принятого в стандарте SQL присваивания (<code class="literal">=</code>) можно применять присваивание с двоеточием (<code class="literal">:=</code>). Например: </p><pre class="programlisting">GET DIAGNOSTICS integer_var = ROW_COUNT;</pre><div class="table" id="PLPGSQL-CURRENT-DIAGNOSTICS-VALUES"><p class="title"><strong>Таблица 43.1. Доступные элементы диагностики</strong></p><div class="table-contents"><table class="table" summary="Доступные элементы диагностики" border="1"><colgroup><col class="col1" /><col class="col2" /><col class="col3" /></colgroup><thead><tr><th>Name</th><th>Тип</th><th>Описание</th></tr></thead><tbody><tr><td><code class="varname">ROW_COUNT</code></td><td><code class="type">bigint</code></td><td>число строк, обработанных последней командой <acronym class="acronym">SQL</acronym></td></tr><tr><td><code class="literal">PG_CONTEXT</code></td><td><code class="type">text</code></td><td>строки текста, описывающие текущий стек вызовов (см. <a class="xref" href="plpgsql-control-structures.html#PLPGSQL-CALL-STACK" title="43.6.9. Получение информации о месте выполнения">Подраздел 43.6.9</a>)</td></tr><tr><td><code class="literal">PG_ROUTINE_OID</code></td><td><code class="type">oid</code></td><td>OID текущей функции</td></tr></tbody></table></div></div><br class="table-break" /><p>Второй способ определения статуса выполнения команды заключается в проверке значения специальной переменной <code class="literal">FOUND</code>, имеющей тип <code class="type">boolean</code>. При вызове функции на <span class="application">PL/pgSQL</span>, переменная <code class="literal">FOUND</code> инициализируется в ложь. Далее, значение переменной изменяется следующими операторами: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="command">SELECT INTO</code> записывает в <code class="literal">FOUND</code> true, если строка присвоена, или false, если строки не были получены.</p></li><li class="listitem"><p><code class="command">PERFORM</code> записывает в <code class="literal">FOUND</code> true, если строки выбраны (и отброшены) или false, если строки не выбраны.</p></li><li class="listitem"><p><code class="command">UPDATE</code>, <code class="command">INSERT</code>, <code class="command">DELETE</code> и <code class="command">MERGE</code> записывают в <code class="literal">FOUND</code> true, если при их выполнении была задействована хотя бы одна строка, или false, если ни одна строка не была задействована.</p></li><li class="listitem"><p><code class="command">FETCH</code> записывают в <code class="literal">FOUND</code> true, если команда вернула строку, или false, если строка не выбрана.</p></li><li class="listitem"><p><code class="command">MOVE</code> записывают в <code class="literal">FOUND</code> true при успешном перемещении курсора, в противном случае — false.</p></li><li class="listitem"><p><code class="command">FOR</code>, как и <code class="command">FOREACH</code>, записывает в <code class="literal">FOUND</code> true, если была произведена хотя бы одна итерация цикла, в противном случае — false. При этом значение <code class="literal">FOUND</code> будет установлено только после выхода из цикла. Пока цикл выполняется, оператор цикла не изменяет значение переменной. Но другие операторы внутри цикла могут менять значение <code class="literal">FOUND</code>.</p></li><li class="listitem"><p><code class="command">RETURN QUERY</code> и <code class="command">RETURN QUERY EXECUTE</code> записывают в <code class="literal">FOUND</code> true, если запрос вернул хотя бы одну строку, или false, если строки не выбраны.</p></li></ul></div><p> Другие операторы <span class="application">PL/pgSQL</span> не меняют значение <code class="literal">FOUND</code>. Помните в частности, что <code class="command">EXECUTE</code> изменяет вывод <code class="command">GET DIAGNOSTICS</code>, но не меняет <code class="literal">FOUND</code>.</p><p><code class="literal">FOUND</code> является локальной переменной в каждой функции <span class="application">PL/pgSQL</span> и любые её изменения, влияют только на текущую функцию.</p></div><div class="sect2" id="PLPGSQL-STATEMENTS-NULL"><div class="titlepage"><div><div><h3 class="title">43.5.6. Не делать ничего <a href="#PLPGSQL-STATEMENTS-NULL" class="id_link">#</a></h3></div></div></div><p>Иногда бывает полезен оператор, который не делает ничего. Например, он может показывать, что одна из ветвей if/then/else сознательно оставлена пустой. Для этих целей используется <code class="command">NULL</code>: </p><pre class="synopsis">
NULL;
</pre><p>В следующем примере два фрагмента кода эквивалентны: </p><pre class="programlisting">BEGIN
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN
        NULL;  -- ошибка игнорируется
END;</pre><p> </p><pre class="programlisting">BEGIN
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN  -- ошибка игнорируется
END;</pre><p> Какой вариант выбрать — дело вкуса.</p><div class="note"><h3 class="title">Примечание</h3><p>В Oracle PL/SQL не допускаются пустые списки операторов, поэтому <code class="command">NULL</code> <span class="emphasis"><em>обязателен</em></span> в подобных ситуациях. В <span class="application">PL/pgSQL</span> разрешается не писать ничего.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="plpgsql-expressions.html" title="43.4. Выражения">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="plpgsql.html" title="Глава 43. PL/pgSQL — процедурный язык SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="plpgsql-control-structures.html" title="43.6. Управляющие структуры">След.</a></td></tr><tr><td width="40%" align="left" valign="top">43.4. Выражения </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 43.6. Управляющие структуры</td></tr></table></div></body></html>