<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>52.6. Исполнитель</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="planner-optimizer.html" title="52.5. Планировщик/оптимизатор" /><link rel="next" href="catalogs.html" title="Глава 53. Системные каталоги" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">52.6. Исполнитель</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="planner-optimizer.html" title="52.5. Планировщик/оптимизатор">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="overview.html" title="Глава 52. Обзор внутреннего устройства PostgreSQL">Наверх</a></td><th width="60%" align="center">Глава 52. Обзор внутреннего устройства PostgreSQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="catalogs.html" title="Глава 53. Системные каталоги">След.</a></td></tr></table><hr /></div><div class="sect1" id="EXECUTOR"><div class="titlepage"><div><div><h2 class="title" style="clear: both">52.6. Исполнитель <a href="#EXECUTOR" class="id_link">#</a></h2></div></div></div><p><em class="firstterm">Исполнитель</em> принимает план, созданный планировщиком/оптимизатором, и обрабатывает его рекурсивно, чтобы получить требуемый набор строк. Обработка выполняется по конвейеру, с получением данных по требованию. При вызове любого узла плана он должен выдать очередную строку, либо сообщить, что выдача строк завершена.</p><p>В качестве более конкретного примера, давайте предположим, что верхним узлом плана оказался узел <code class="literal">MergeJoin</code>. Для того чтобы выполнить какое-либо соединение, необходимо выбрать две строки (одну из каждого вложенного плана). Поэтому исполнитель рекурсивно вызывает себя для обработки вложенных планов (он начинает с плана <code class="literal">левого дерева</code>). Новый верхний узел (верхний узел левого вложенного плана) может быть, например, узлом <code class="literal">Sort</code>, и тогда для получения входной строки снова требуется рекурсия. Дочерним узлом <code class="literal">Sort</code> может быть узел <code class="literal">SeqScan</code>, представляющий собственно чтение таблицы. В результате выполнения этого узла исполнитель выбирает одну строку из таблицы и возвращает её вызывающему узлу. Узел <code class="literal">Sort</code>, в свою очередь, будет продолжать вызывать дочерний узел, пока не получит все строки для сортировки. Когда строки закончатся (дочерний узел сообщит об этом, возвратив NULL вместо строки), узел <code class="literal">Sort</code> выполнит сортировку, и наконец сможет выдать свою первую строку, а именно строку первую по порядку сортировки. Остальные строки будут сохраняться в нём, чтобы он мог выдавать их по порядку при последующих вызовах.</p><p>Узел <code class="literal">MergeJoin</code> подобным образом затребует первую строку и у вложенного плана справа. Затем он сравнивает две строки и определяет, можно ли их соединить; если да, он возвращает соединённую строки вызывающему узлу. При следующем вызове, или немедленно, если он не может соединить текущую пару поступивших строк, он переходит к следующей строке в одном отношении или в другом (в зависимости от результата сравнения) и снова проверяет соответствие. В конце концов, данные в одном или другом вложенном плане заканчиваются и узел <code class="literal">MergeJoin</code> возвращает NULL, показывая тем самым, что другие строки соединения получить нельзя.</p><p>Сложные запросы могут содержать много уровней вложенности узлов плана, но общий подход тот же: каждый узел вычисляет и возвращает следующую полученную строку при очередном вызове. Каждый узел также должен производить отбор и расчёты, которые были назначены ему планировщиком.</p><p>Механизм исполнителя применяется для обработки всех пяти основных типов SQL-запросов: <code class="command">SELECT</code>, <code class="command">INSERT</code>, <code class="command">UPDATE</code>, <code class="command">DELETE</code> и <code class="command">MERGE</code>. С <code class="command">SELECT</code> код исполнителя верхнего уровня должен только выдать клиенту все строки, полученные от дерева плана запроса. Запросы <code class="command">INSERT ... SELECT</code>, <code class="command">UPDATE</code>, <code class="command">DELETE</code> и <code class="command">MERGE</code> по сути выполняются как <code class="command">SELECT</code> под специальным узлом <code class="literal">ModifyTable</code> на верхнем уровне плана.</p><p>Команда <code class="command">INSERT ... SELECT</code> подаёт строки в узел <code class="literal">ModifyTable</code> для добавления в отношение. С <code class="command">UPDATE</code> планировщик делает так, чтобы каждая вычисленная строка включала значения всех изменённых столбцов плюс <em class="firstterm">TID</em> (Tuple ID, идентификатор кортежа) исходной целевой строки; эти данные подаются в узел <code class="literal">ModifyTable</code>, который использует эту информацию, чтобы создать новую изменённую строку и пометить старую строку как удалённую. С <code class="command">DELETE</code> план фактически возвращает только один столбец, TID, а узел <code class="literal">ModifyTable</code> использует значения TID, чтобы найти каждую целевую строку и пометить её как удалённую. С <code class="command">MERGE</code> планировщик соединяет исходные и целевые отношения и включает все значения столбцов, необходимые для любого из предложений <code class="literal">WHEN</code>, плюс TID целевой строки; эти данные подаются в узел <code class="literal">ModifyTable</code>, который использует эту информацию, чтобы определить, какое предложение <code class="literal">WHEN</code> выполнять, а затем вставляет, изменяет или удаляет целевую строку по мере необходимости.</p><p>Простая команда <code class="command">INSERT ... VALUES</code> создаёт тривиальное дерево плана, содержащее единственный узел <code class="literal">Result</code>, который вычисляет ровно одну строку результата и подаёт её в вышестоящий узел <code class="literal">ModifyTable</code> для добавления в отношение.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="planner-optimizer.html" title="52.5. Планировщик/оптимизатор">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="overview.html" title="Глава 52. Обзор внутреннего устройства PostgreSQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="catalogs.html" title="Глава 53. Системные каталоги">След.</a></td></tr><tr><td width="40%" align="left" valign="top">52.5. Планировщик/оптимизатор </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> Глава 53. Системные каталоги</td></tr></table></div></body></html>