<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>9.24. Сравнение табличных строк и массивов</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="functions-subquery.html" title="9.23. Выражения подзапросов" /><link rel="next" href="functions-srf.html" title="9.25. Функции, возвращающие множества" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">9.24. Сравнение табличных строк и массивов</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="functions-subquery.html" title="9.23. Выражения подзапросов">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="functions.html" title="Глава 9. Функции и операторы">Наверх</a></td><th width="60%" align="center">Глава 9. Функции и операторы</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="functions-srf.html" title="9.25. Функции, возвращающие множества">След.</a></td></tr></table><hr /></div><div class="sect1" id="FUNCTIONS-COMPARISONS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">9.24. Сравнение табличных строк и массивов <a href="#FUNCTIONS-COMPARISONS" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="functions-comparisons.html#FUNCTIONS-COMPARISONS-IN-SCALAR">9.24.1. <code class="literal">IN</code></a></span></dt><dt><span class="sect2"><a href="functions-comparisons.html#FUNCTIONS-COMPARISONS-NOT-IN">9.24.2. <code class="literal">NOT IN</code></a></span></dt><dt><span class="sect2"><a href="functions-comparisons.html#FUNCTIONS-COMPARISONS-ANY-SOME">9.24.3. <code class="literal">ANY</code>/<code class="literal">SOME</code> (с массивом)</a></span></dt><dt><span class="sect2"><a href="functions-comparisons.html#FUNCTIONS-COMPARISONS-ALL">9.24.4. <code class="literal">ALL</code> (с массивом)</a></span></dt><dt><span class="sect2"><a href="functions-comparisons.html#ROW-WISE-COMPARISON">9.24.5. Сравнение конструкторов строк</a></span></dt><dt><span class="sect2"><a href="functions-comparisons.html#COMPOSITE-TYPE-COMPARISON">9.24.6. Сравнение составных типов</a></span></dt></dl></div><a id="id-1.5.8.30.2" class="indexterm"></a><a id="id-1.5.8.30.3" class="indexterm"></a><a id="id-1.5.8.30.4" class="indexterm"></a><a id="id-1.5.8.30.5" class="indexterm"></a><a id="id-1.5.8.30.6" class="indexterm"></a><a id="id-1.5.8.30.7" class="indexterm"></a><a id="id-1.5.8.30.8" class="indexterm"></a><a id="id-1.5.8.30.9" class="indexterm"></a><a id="id-1.5.8.30.10" class="indexterm"></a><a id="id-1.5.8.30.11" class="indexterm"></a><a id="id-1.5.8.30.12" class="indexterm"></a><p>В этом разделе описываются несколько специальных конструкций, позволяющих сравнивать группы значений. Синтаксис этих конструкций связан с формами выражений с подзапросами, описанными в предыдущем разделе, а отличаются они отсутствием подзапросов. Конструкции, в которых в качестве подвыражений используются массивы, являются расширениями <span class="productname">PostgreSQL</span>; все остальные формы соответствуют стандарту <acronym class="acronym">SQL</acronym>. Все описанные здесь выражения возвращают логические значения (true/false).</p><div class="sect2" id="FUNCTIONS-COMPARISONS-IN-SCALAR"><div class="titlepage"><div><div><h3 class="title">9.24.1. <code class="literal">IN</code> <a href="#FUNCTIONS-COMPARISONS-IN-SCALAR" class="id_link">#</a></h3></div></div></div><pre class="synopsis"><em class="replaceable"><code>выражение</code></em> IN (<em class="replaceable"><code>значение</code></em> [<span class="optional">, ...</span>])</pre><p>Справа в скобках записывается список выражений. Результатом будет <span class="quote">«<span class="quote">true</span>»</span>, если значение левого выражения равняется одному из значений выражений в правой части. Эту конструкцию можно считать краткой записью условия </p><pre class="synopsis">
<em class="replaceable"><code>выражение</code></em> = <em class="replaceable"><code>значение1</code></em>
OR
<em class="replaceable"><code>выражение</code></em> = <em class="replaceable"><code>значение2</code></em>
OR
...
</pre><p>Заметьте, что если результатом выражения слева оказывается NULL или равных значений справа не находится, а хотя бы одно из значений справа равно NULL, конструкция <code class="token">IN</code> возвращает NULL, а не false. Это соответствует принятым в SQL правилам сравнения переменных со значениями NULL.</p></div><div class="sect2" id="FUNCTIONS-COMPARISONS-NOT-IN"><div class="titlepage"><div><div><h3 class="title">9.24.2. <code class="literal">NOT IN</code> <a href="#FUNCTIONS-COMPARISONS-NOT-IN" class="id_link">#</a></h3></div></div></div><pre class="synopsis"><em class="replaceable"><code>выражение</code></em> NOT IN (<em class="replaceable"><code>значение</code></em> [<span class="optional">, ...</span>])</pre><p>Справа в скобках записывается список выражений. Результатом будет <span class="quote">«<span class="quote">true</span>»</span>, если значение левого выражения не равно ни одному из значений выражений в правой части. Эту конструкцию можно считать краткой записью условия </p><pre class="synopsis">
<em class="replaceable"><code>выражение</code></em> &lt;&gt; <em class="replaceable"><code>значение1</code></em>
AND
<em class="replaceable"><code>выражение</code></em> &lt;&gt; <em class="replaceable"><code>значение2</code></em>
AND
...
</pre><p>Заметьте, что если результатом выражения слева оказывается NULL или равных значений справа не находится, а хотя бы одно из значений справа равно NULL, конструкция <code class="token">NOT IN</code> возвращает NULL, а не true, как можно было бы наивно полагать. Это соответствует принятым в SQL правилам сравнения переменных со значениями NULL.</p><div class="tip"><h3 class="title">Подсказка</h3><p>Выражения <code class="literal">x NOT IN y</code> и <code class="literal">NOT (x IN y)</code> полностью равнозначны. Учитывая, что значения NULL могут ввести в заблуждение начинающих скорее в конструкции <code class="token">NOT IN</code>, чем в <code class="token">IN</code>, лучше формулировать условия так, чтобы в них было как можно меньше отрицаний.</p></div></div><div class="sect2" id="FUNCTIONS-COMPARISONS-ANY-SOME"><div class="titlepage"><div><div><h3 class="title">9.24.3. <code class="literal">ANY</code>/<code class="literal">SOME</code> (с массивом) <a href="#FUNCTIONS-COMPARISONS-ANY-SOME" class="id_link">#</a></h3></div></div></div><pre class="synopsis"><em class="replaceable"><code>выражение</code></em> <em class="replaceable"><code>оператор</code></em> ANY (<em class="replaceable"><code>выражение массива</code></em>)
<em class="replaceable"><code>выражение</code></em> <em class="replaceable"><code>оператор</code></em> SOME (<em class="replaceable"><code>выражение массива</code></em>)</pre><p>Справа в скобках записывается выражение, результатом которого является массив. Вычисленное значение левого выражения сравнивается с каждым элементом этого массива с применением заданного <em class="replaceable"><code>оператора</code></em> условия, который должен выдавать логическое значение. Результатом <code class="token">ANY</code> будет <span class="quote">«<span class="quote">true</span>»</span>, если для какого-либо элемента условие истинно, и <span class="quote">«<span class="quote">false</span>»</span> в противном случае (в том числе, и когда массив оказывается пустым).</p><p>Если значением массива оказывается NULL, результатом <code class="token">ANY</code> также будет NULL. Если NULL получен в левой части, результатом <code class="token">ANY</code> обычно тоже будет NULL (хотя оператор нестрогого сравнения может выдать другой результат). Кроме того, если массив в правой части содержит элементы NULL и ни c одним из элементов условие не выполняется, результатом <code class="token">ANY</code> будет NULL, а не false (опять же, если используется оператор строгого сравнения). Это соответствует принятым в SQL правилам сравнения переменных со значениями NULL.</p><p>Ключевое слово <code class="token">SOME</code> является синонимом <code class="token">ANY</code>.</p></div><div class="sect2" id="FUNCTIONS-COMPARISONS-ALL"><div class="titlepage"><div><div><h3 class="title">9.24.4. <code class="literal">ALL</code> (с массивом) <a href="#FUNCTIONS-COMPARISONS-ALL" class="id_link">#</a></h3></div></div></div><pre class="synopsis"><em class="replaceable"><code>выражение</code></em> <em class="replaceable"><code>оператор</code></em> ALL (<em class="replaceable"><code>выражение массива</code></em>)</pre><p>Справа в скобках записывается выражение, результатом которого является массив. Вычисленное значение левого выражения сравнивается с каждым элементом этого массива с применением заданного <em class="replaceable"><code>оператора</code></em> условия, который должен выдавать логическое значение. Результатом <code class="token">ALL</code> будет <span class="quote">«<span class="quote">true</span>»</span>, если для всех элементов условие истинно (или массив не содержит элементов), и <span class="quote">«<span class="quote">false</span>»</span>, если находятся строки, для которых оно ложно.</p><p>Если значением массива оказывается NULL, результатом <code class="token">ALL</code> также будет NULL. Если NULL получен в левой части, результатом <code class="token">ALL</code> обычно тоже будет NULL (хотя оператор нестрогого сравнения может выдать другой результат). Кроме того, если массив в правой части содержит элементы NULL и при этом нет элементов, с которыми условие не выполняется, результатом <code class="token">ALL</code> будет NULL, а не true (опять же, если используется оператор строгого сравнения). Это соответствует принятым в SQL правилам сравнения переменных со значениями NULL.</p></div><div class="sect2" id="ROW-WISE-COMPARISON"><div class="titlepage"><div><div><h3 class="title">9.24.5. Сравнение конструкторов строк <a href="#ROW-WISE-COMPARISON" class="id_link">#</a></h3></div></div></div><pre class="synopsis">
<em class="replaceable"><code>конструктор_строки</code></em> <em class="replaceable"><code>оператор</code></em> <em class="replaceable"><code>конструктор_строки</code></em>
</pre><p>С обеих сторон представлены конструкторы строк (они описываются в <a class="xref" href="sql-expressions.html#SQL-SYNTAX-ROW-CONSTRUCTORS" title="4.2.13. Конструкторы табличных строк">Подразделе 4.2.13</a>). При этом данные конструкторы должны содержать одинаковое число полей. Заданный <em class="replaceable"><code>оператор</code></em> применяется к каждой паре соответствующих полей. (Поскольку поля могут быть разных типов, для каждой пары может быть выбран отдельный конкретный оператор.) Все выбранные операторы должны быть членами некоторого класса операторов B-дерева или быть обратными члену класса операторов B-дерева <code class="literal">=</code>. Сравнения конструкторов строк возможны с <em class="replaceable"><code>оператором</code></em> <code class="literal">=</code>, <code class="literal">&lt;&gt;</code>, <code class="literal">&lt;</code>, <code class="literal">&lt;=</code>, <code class="literal">&gt;</code> или <code class="literal">&gt;=</code>, или имеющим аналогичную семантику.</p><p>Сравнения <code class="literal">=</code> и <code class="literal">&lt;&gt;</code> несколько отличаются от других. С этими операторами две строки считаются равными, если все их соответствующие поля не равны NULL и равны между собой, и неравными, если какие-либо соответствующие их поля не NULL и не равны между собой. В противном случае результатом сравнения будет неопределённость (NULL).</p><p>С операторами <code class="literal">&lt;</code>, <code class="literal">&lt;=</code>, <code class="literal">&gt;</code> и <code class="literal">&gt;=</code> элементы строк сравниваются слева направо до тех пор, пока не будет найдена пара неравных элементов или значений NULL. Если любым из элементов пары оказывается NULL, результатом сравнения будет неопределённость (NULL), в противном случае результат всего выражения определяется результатом сравнения этих двух элементов. Например, результатом <code class="literal">ROW(1,2,NULL) &lt; ROW(1,3,0)</code> будет true, а не NULL, так как третья пара элементов не принимается в рассмотрение.</p><pre class="synopsis"><em class="replaceable"><code>конструктор_строки</code></em> IS DISTINCT FROM <em class="replaceable"><code>конструктор_строки</code></em></pre><p>Эта конструкция похожа на сравнение строк с оператором <code class="literal">&lt;&gt;</code>, но со значениями NULL она выдаёт не NULL. Любое значение NULL для неё считается неравным (отличным от) любому значению не NULL, а два NULL считаются равными (не различными). Таким образом, результатом такого выражения будет true или false, но не NULL.</p><pre class="synopsis"><em class="replaceable"><code>конструктор_строки</code></em> IS NOT DISTINCT FROM <em class="replaceable"><code>конструктор_строки</code></em></pre><p>Эта конструкция похожа на сравнение строк с оператором <code class="literal">=</code>, но со значениями NULL она выдаёт не NULL. Любое значение NULL для неё считается неравным (отличным от) любому значению не NULL, а два NULL считаются равными (не различными). Таким образом, результатом такого выражения всегда будет true или false, но не NULL.</p></div><div class="sect2" id="COMPOSITE-TYPE-COMPARISON"><div class="titlepage"><div><div><h3 class="title">9.24.6. Сравнение составных типов <a href="#COMPOSITE-TYPE-COMPARISON" class="id_link">#</a></h3></div></div></div><pre class="synopsis">
<em class="replaceable"><code>запись</code></em> <em class="replaceable"><code>оператор</code></em> <em class="replaceable"><code>запись</code></em>
</pre><p>Стандарт SQL требует, чтобы при сравнении строк возвращался NULL, если результат зависит от сравнения двух значений NULL или значения NULL и не NULL. <span class="productname">PostgreSQL</span> выполняет это требование только при сравнении строк, созданных конструкторами (как описано в <a class="xref" href="functions-comparisons.html#ROW-WISE-COMPARISON" title="9.24.5. Сравнение конструкторов строк">Подразделе 9.24.5</a>), или строки, созданной конструктором, со строкой результата подзапроса (как было описано в <a class="xref" href="functions-subquery.html" title="9.23. Выражения подзапросов">Разделе 9.23</a>). В других контекстах при сравнении полей составных типов два значения NULL считаются равными, а любое значение не NULL полагается меньшим NULL. Это отклонение от правила необходимо для полноценной реализации сортировки и индексирования составных типов.</p><p>После вычисления каждой стороны они сравниваются по строкам. Сравнения составных типов возможны с <em class="replaceable"><code>оператором</code></em> <code class="literal">=</code>, <code class="literal">&lt;&gt;</code>, <code class="literal">&lt;</code>, <code class="literal">&lt;=</code>, <code class="literal">&gt;</code> или <code class="literal">&gt;=</code>, либо другим подобным. (Точнее, оператором сравнения строк может быть любой оператор, входящий в класс операторов B-дерева, либо обратный к оператору <code class="literal">=</code>, входящему в класс операторов B-дерева.) По умолчанию вышеперечисленные операторы действуют так же, как выражение <code class="literal">IS [ NOT ] DISTINCT FROM</code> для конструкторов строк (см. <a class="xref" href="functions-comparisons.html#ROW-WISE-COMPARISON" title="9.24.5. Сравнение конструкторов строк">Подраздел 9.24.5</a>).</p><p>Для поддержки сравнения строк с элементами, для которых не определён класс операторов B-дерева по умолчанию, введены следующие операторы: <code class="literal">*=</code>, <code class="literal">*&lt;&gt;</code>, <code class="literal">*&lt;</code>, <code class="literal">*&lt;=</code>, <code class="literal">*&gt;</code> и <code class="literal">*&gt;=</code>. Эти операторы сравнивают внутреннее двоичное представление двух строк. Учтите, что две строки могут иметь различное двоичное представление, даже когда при сравнении оператором равенства считаются равными. Порядок строк с такими операторами детерминирован, но не несёт смысловой нагрузки. Данные операторы не предназначены для обычных запросов; они применяются внутри системы для материализованных представлений и могут быть полезны для других специальных целей, например для репликации или исключения дубликатов в B-дереве (см. <a class="xref" href="btree-implementation.html#BTREE-DEDUPLICATION" title="67.4.3. Исключение дубликатов">Подраздел 67.4.3</a>).</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="functions-subquery.html" title="9.23. Выражения подзапросов">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="functions.html" title="Глава 9. Функции и операторы">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="functions-srf.html" title="9.25. Функции, возвращающие множества">След.</a></td></tr><tr><td width="40%" align="left" valign="top">9.23. Выражения подзапросов </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 9.25. Функции, возвращающие множества</td></tr></table></div></body></html>