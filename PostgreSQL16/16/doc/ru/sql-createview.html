<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CREATE VIEW</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sql-createusermapping.html" title="CREATE USER MAPPING" /><link rel="next" href="sql-deallocate.html" title="DEALLOCATE" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">CREATE VIEW</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-createusermapping.html" title="CREATE USER MAPPING">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><th width="60%" align="center">Команды SQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-deallocate.html" title="DEALLOCATE">След.</a></td></tr></table><hr /></div><div class="refentry" id="SQL-CREATEVIEW"><div class="titlepage"></div><a id="id-1.9.3.97.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">CREATE VIEW</span></h2><p>CREATE VIEW — создать представление</p></div><div class="refsynopsisdiv"><h2>Синтаксис</h2><pre class="synopsis">CREATE [ OR REPLACE ] [ TEMP | TEMPORARY ] [ RECURSIVE ] VIEW <em class="replaceable"><code>имя</code></em> [ ( <em class="replaceable"><code>имя_столбца</code></em> [, ...] ) ]
    [ WITH ( <em class="replaceable"><code>имя_параметра_представления</code></em> [= <em class="replaceable"><code>значение_параметра_представления</code></em>] [, ... ] ) ]
    AS <em class="replaceable"><code>запрос</code></em>
    [ WITH [ CASCADED | LOCAL ] CHECK OPTION ]</pre></div><div class="refsect1" id="id-1.9.3.97.5"><h2>Описание</h2><p><code class="command">CREATE VIEW</code> создаёт представление запроса. Создаваемое представление лишено физической материализации, поэтому указанный запрос будет выполняться при каждом обращении к представлению.</p><p>Команда <code class="command">CREATE OR REPLACE VIEW</code> действует подобным образом, но если представление с этим именем уже существует, оно заменяется. Новый запрос должен выдавать те же столбцы, что выдавал запрос, ранее определённый для этого представления (то есть, столбцы с такими же именами должны иметь те же типы данных и следовать в том же порядке), но может добавить несколько новых столбцов в конце списка. Вычисления, в результате которых формируются столбцы представления, могут быть совершенно другими.</p><p>Если задано имя схемы (например, <code class="literal">CREATE VIEW myschema.myview ...</code>), представление создаётся в указанной схеме, в противном случае — в текущей. Временные представления существуют в специальной схеме, так что при создании таких представлений имя схемы задать нельзя. Имя представления должно отличаться от имён других отношений (таблиц, последовательностей, индексов, представлений, материализованных представлений или сторонних таблиц) в этой схеме.</p></div><div class="refsect1" id="id-1.9.3.97.6"><h2>Параметры</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">TEMPORARY</code> или <code class="literal">TEMP</code></span></dt><dd><p>С таким указанием представление создаётся как временное. Временные представления автоматически удаляются в конце сеанса. Существующее постоянное представление с тем же именем не будет видно в текущем сеансе, пока существует временное, однако к нему можно обратиться, дополнив имя указанием схемы.</p><p>Если в определении представления задействованы временные таблицы, представление так же создаётся как временное (вне зависимости от присутствия явного указания <code class="literal">TEMPORARY</code>).</p></dd><dt><span class="term"><code class="literal">RECURSIVE</code>
      <a id="id-1.9.3.97.6.2.2.1.2" class="indexterm"></a>
    </span></dt><dd><p>Создаёт рекурсивное представление. Синтаксис </p><pre class="synopsis">
CREATE RECURSIVE VIEW [ <em class="replaceable"><code>схема</code></em> . ] <em class="replaceable"><code>имя</code></em> (<em class="replaceable"><code>имена_столбцов</code></em>) AS SELECT <em class="replaceable"><code>...</code></em>;
</pre><p> равнозначен </p><pre class="synopsis">
CREATE VIEW [ <em class="replaceable"><code>схема</code></em> . ] <em class="replaceable"><code>имя</code></em> AS WITH RECURSIVE <em class="replaceable"><code>имя</code></em> (<em class="replaceable"><code>имена_столбцов</code></em>) AS (SELECT <em class="replaceable"><code>...</code></em>) SELECT <em class="replaceable"><code>имена_столбцов</code></em> FROM <em class="replaceable"><code>имя</code></em>;
</pre><p> Для рекурсивного представления обязательно должен задаваться список с именами столбцов.</p></dd><dt><span class="term"><em class="replaceable"><code>имя</code></em></span></dt><dd><p>Имя создаваемого представления (возможно, дополненное схемой).</p></dd><dt><span class="term"><em class="replaceable"><code>имя_столбца</code></em></span></dt><dd><p>Необязательный список имён, назначаемых столбцам представления. Если отсутствует, имена столбцов формируются из результатов запроса.</p></dd><dt><span class="term"><code class="literal">WITH ( <em class="replaceable"><code>имя_параметра_представления</code></em> [= <em class="replaceable"><code>значение_параметра_представления</code></em>] [, ... ] )</code></span></dt><dd><p>В этом предложении могут задаваться следующие необязательные параметры представления: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">check_option</code> (<code class="type">enum</code>)</span></dt><dd><p>Этот параметр может принимать значение <code class="literal">local</code> (локально) или <code class="literal">cascaded</code> (каскадно) и равнозначен указанию <code class="literal">WITH [ CASCADED | LOCAL ] CHECK OPTION</code> (см. ниже).</p></dd><dt><span class="term"><code class="literal">security_barrier</code> (<code class="type">boolean</code>)</span></dt><dd><p>Этот параметр следует использовать, если представление должно обеспечивать защиту на уровне строк. За дополнительными подробностями обратитесь к <a class="xref" href="rules-privileges.html" title="41.5. Правила и права">Разделу 41.5</a>.</p></dd><dt><span class="term"><code class="literal">security_invoker</code> (<code class="type">boolean</code>)</span></dt><dd><p>При обращении к представлению, имеющему эту характеристику, для нижележащих базовых отношений будут проверяться права обращающегося пользователя, а не владельца представления. Подробнее об этом рассказывается в замечаниях ниже.</p></dd></dl></div><p> Все вышеуказанные параметры можно изменить для существующих представлений командой <a class="link" href="sql-alterview.html" title="ALTER VIEW"><code class="command">ALTER VIEW</code></a>.</p></dd><dt><span class="term"><em class="replaceable"><code>запрос</code></em></span></dt><dd><p>Команда <a class="link" href="sql-select.html" title="SELECT"><code class="command">SELECT</code></a> или <a class="link" href="sql-values.html" title="VALUES"><code class="command">VALUES</code></a>, которая выдаёт столбцы и строки представления.</p></dd><dt><span class="term"><code class="literal">WITH [ CASCADED | LOCAL ] CHECK OPTION</code>
      <a id="id-1.9.3.97.6.2.7.1.2" class="indexterm"></a>
      <a id="id-1.9.3.97.6.2.7.1.3" class="indexterm"></a>
    </span></dt><dd><p>Это указание управляет поведением автоматически изменяемых представлений. Если оно присутствует, при выполнении операций <code class="command">INSERT</code> и <code class="command">UPDATE</code> с этим представлением будет проверяться, удовлетворяют ли новые строки условию, определяющему представление (то есть, проверяется, будут ли новые строки видны через это представление). Если они не удовлетворяют условию, операция не будет выполнена. Если указание <code class="literal">CHECK OPTION</code> отсутствует, команды <code class="command">INSERT</code> и <code class="command">UPDATE</code> смогут создавать в этом представлении строки, которые не будут видны в нём. Поддерживаются следующие варианты проверки: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">LOCAL</code></span></dt><dd><p>Новые строки проверяются только по условиям, определённым непосредственно в самом представлении. Любые условия, определённые в нижележащих базовых представлениях, не проверяются (если только в них нет указания <code class="literal">CHECK OPTION</code>).</p></dd><dt><span class="term"><code class="literal">CASCADED</code></span></dt><dd><p>Новые строки проверяются по условиям данного представления и всех нижележащих базовых. Если указано <code class="literal">CHECK OPTION</code>, а <code class="literal">LOCAL</code> и <code class="literal">CASCADED</code> опущено, подразумевается указание <code class="literal">CASCADED</code>.</p></dd></dl></div><p>Указание <code class="literal">CHECK OPTION</code> нельзя использовать с рекурсивными представлениями.</p><p>Заметьте, что <code class="literal">CHECK OPTION</code> поддерживается только для автоматически изменяемых представлений, не имеющих триггеров <code class="literal">INSTEAD OF</code> и правил <code class="literal">INSTEAD</code>. Если автоматически изменяемое представление определено поверх базового представления с триггерами <code class="literal">INSTEAD OF</code>, то для проверки ограничений автоматически изменяемого представления можно применить указание <code class="literal">LOCAL CHECK OPTION</code>, хотя условия базового представления с триггерами <code class="literal">INSTEAD OF</code> при этом проверяться не будут (каскадная проверка не будет спускаться к представлению, модифицируемому триггером, и любые параметры проверки, определённые для такого представления, будут просто игнорироваться). Если для представления или любого из его базовых отношений определено правило <code class="literal">INSTEAD</code>, приводящее к перезаписи команды <code class="command">INSERT</code> или <code class="command">UPDATE</code>, в перезаписанном запросе все параметры проверки будут игнорироваться, в том числе проверки автоматически изменяемых представлений, определённых поверх отношений с правилом <code class="literal">INSTEAD</code>.</p></dd></dl></div></div><div class="refsect1" id="id-1.9.3.97.7"><h2>Замечания</h2><p>Для удаления представлений применяется оператор <a class="link" href="sql-dropview.html" title="DROP VIEW"><code class="command">DROP VIEW</code></a>.</p><p>Позаботьтесь о том, чтобы столбцы представления получили желаемые имена и типы. Например, такая команда: </p><pre class="programlisting">CREATE VIEW vista AS SELECT 'Hello World';</pre><p> плоха тем, что именем столбца по умолчанию будет <code class="literal">?column?</code>, а типом данных — <code class="type">text</code>; и это может быть не совсем то, чего вы хотите. Лучше записывать строковую константу в результате представления примерно так: </p><pre class="programlisting">CREATE VIEW vista AS SELECT text 'Hello World' AS hello;</pre><p>По умолчанию доступ к нижележащим базовым отношениям, на которые ссылается представление, определяется правами владельца представления. В некоторых случаях это позволяет организовать безопасный, но ограниченный доступ к нижележащим таблицам. Однако учтите, что не все представления могут быть защищёнными; за подробностями обратитесь к <a class="xref" href="rules-privileges.html" title="41.5. Правила и права">Разделу 41.5</a>.</p><p>Если для представления свойство <code class="literal">security_invoker</code> имеет значение <code class="literal">true</code>, доступ к нижележащим базовым отношениям определяется правами пользователя, выполняющего запрос, а не владельца представления. Таким образом, пользователь такого представления должен иметь соответствующие разрешения для доступа к представлению и его базовым отношениям.</p><p>Если какое-либо из нижележащих базовых отношений является представлением с контекстом безопасности вызывающего, оно будет обрабатываться так, как если бы в исходном запросе обращались непосредственно к нему. Таким образом, для представления с характеристикой <code class="literal">security_invoker</code> права доступа к нижележащим базовым отношениям должен иметь текущий пользователь, даже если на верхнем уровне он обращался к представлению без такой характеристики.</p><p>Если для какого-либо нижележащего базового отношения включена <a class="link" href="ddl-rowsecurity.html" title="5.8. Политики защиты строк">защита на уровне строк</a>, по умолчанию действуют политики защиты для владельца представления, и доступ к любым дополнительным отношениям, на которые ссылаются эти политики, определяются правами этого пользователя. Однако если свойство представления <code class="literal">security_invoker</code> имеет значение <code class="literal">true</code>, вместо этого действуют политики для вызывающего пользователя и проверяются его права, как если бы запрос, обращающийся к такому представлению, обращался непосредственно к его базовым отношениям.</p><p>Функции, вызываемые в представлении, обрабатываются так же, как если бы они вызывались непосредственно из запроса, обращающегося к представлению. Следовательно, пользователь представления должен иметь разрешения на вызов всех функций, используемых в представлении. Функции в представлении выполняются с правами пользователя, выполняющего запрос, или владельца функции, в зависимости от того, определены ли функции как <code class="literal">SECURITY INVOKER</code> или <code class="literal">SECURITY DEFINER</code>. Так, например, функция <code class="literal">CURRENT_USER</code>, вызванная непосредственно из представления, всегда будет выдавать имя вызывающего пользователя, а не владельца представления. На это не влияет характеристика представления <code class="literal">security_invoker</code>, поэтому обращение к представлению со свойством <code class="literal">security_invoker</code>, равным <code class="literal">false</code>, <span class="emphasis"><em>не</em></span> равнозначно вызову функции с характеристикой <code class="literal">SECURITY DEFINER</code>, и эти концепции следует различать.</p><p>Пользователь, создающий или заменяющий представление, должен иметь права <code class="literal">USAGE</code> для всех схем, фигурирующих в запросе представления, чтобы найти используемые в этом запросе объекты в этих схемах. Однако заметьте, что поиск объектов производится только при создании или замене представления. Поэтому пользователям представления требуется только право <code class="literal">USAGE</code> для схемы, содержащей представление, а не для всех схем, используемых в запросе представления, даже если это представление с контекстом безопасности вызывающего.</p><p>При выполнении <code class="command">CREATE OR REPLACE VIEW</code> для существующего представления меняется только правило SELECT, определяющее представление, и параметры <code class="literal">WITH ( ... )</code>, а также <code class="literal">CHECK OPTION</code>. Другие свойства представления, включая владельца, права и правила, кроме SELECT, остаются неизменными. Чтобы изменить определение представления, необходимо быть его владельцем (или членом роли-владельца).</p><div class="refsect2" id="SQL-CREATEVIEW-UPDATABLE-VIEWS"><h3>Изменяемые представления</h3><a id="id-1.9.3.97.7.11.2" class="indexterm"></a><p>Простые представления становятся изменяемыми автоматически: система позволит выполнять команды <code class="command">INSERT</code>, <code class="command">UPDATE</code> и <code class="command">DELETE</code> с таким представлением так же, как и с обычной таблицей. Представление будет автоматически изменяемым, если оно удовлетворяют одновременно всем следующим условиям: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Список <code class="literal">FROM</code> в запросе, определяющем представлении, должен содержать ровно один элемент, и это должна быть таблица или другое изменяемое представление.</p></li><li class="listitem"><p>Определение представления не должно содержать предложения <code class="literal">WITH</code>, <code class="literal">DISTINCT</code>, <code class="literal">GROUP BY</code>, <code class="literal">HAVING</code>, <code class="literal">LIMIT</code> и <code class="literal">OFFSET</code> на верхнем уровне запроса.</p></li><li class="listitem"><p>Определение представления не должно содержать операции с множествами (<code class="literal">UNION</code>, <code class="literal">INTERSECT</code> и <code class="literal">EXCEPT</code>) на верхнем уровне запроса.</p></li><li class="listitem"><p>Список выборки в запросе не должен содержать агрегатные и оконные функции, а также функции, возвращающие множества.</p></li></ul></div><p>Автоматически обновляемое представление может содержать как изменяемые, так и не изменяемые столбцы. Столбец будет изменяемым, если это простая ссылка на изменяемый столбец нижележащего базового отношения; в противном случае этот столбец будет доступен только для чтения, и если команда <code class="command">INSERT</code> или <code class="command">UPDATE</code> попытается записать значение в него, возникнет ошибка.</p><p>Если представление автоматически изменяемое, система будет преобразовывать обращающиеся к нему операторы <code class="command">INSERT</code>, <code class="command">UPDATE</code> и <code class="command">DELETE</code> в соответствующие операторы, обращающиеся к нижележащему базовому отношению. При этом в полной мере поддерживаются операторы <code class="command">INSERT</code> с предложением <code class="literal">ON CONFLICT UPDATE</code>.</p><p>Если автоматически изменяемое представление содержит условие <code class="literal">WHERE</code>, это условие ограничивает набор строк, которые могут быть изменены командой <code class="command">UPDATE</code> и удалены командой <code class="command">DELETE</code> в этом представлении. Однако <code class="command">UPDATE</code> может изменить строку так, что она больше не будет соответствовать условию <code class="literal">WHERE</code> и, как следствие, больше не будет видна через представление. Команда <code class="command">INSERT</code> подобным образом может вставить в базовое отношение строки, которые не удовлетворят условию <code class="literal">WHERE</code> и поэтому не будут видны через представление (<code class="literal">ON CONFLICT UPDATE</code> может подобным образом воздействовать на существующую строку, не видимую через представление). Чтобы запретить командам <code class="command">INSERT</code> и <code class="command">UPDATE</code> создавать такие строки, которые не видны через представление, можно воспользоваться указанием <code class="literal">CHECK OPTION</code>.</p><p>Если автоматически изменяемое представление имеет свойство <code class="literal">security_barrier</code> (барьер безопасности), то все условия <code class="literal">WHERE</code> этого представления (и все условия с герметичными операторами (<code class="literal">LEAKPROOF</code>)) будут всегда вычисляться перед условиями, добавленными пользователем представления. За подробностями обратитесь к <a class="xref" href="rules-privileges.html" title="41.5. Правила и права">Разделу 41.5</a>. Заметьте, что по этой причине строки, которые в конце концов не были выданы (потому что не прошли проверку в пользовательском условии <code class="literal">WHERE</code>), могут всё же остаться заблокированными. Чтобы определить, какие условия применяются на уровне отношения (и, как следствие, избавляют часть строк от блокировки), можно воспользоваться командой <code class="command">EXPLAIN</code>.</p><p>Более сложные представления, не удовлетворяющие этим условиям, по умолчанию доступны только для чтения: система не позволит выполнить операции добавления, изменения или удаления строк в таком представлении. Создать эффект изменяемого представления для них можно, определив триггеры <code class="literal">INSTEAD OF</code>, которые будут преобразовывать запросы на изменение данных в соответствующие действия с другими таблицами. За дополнительными сведениями обратитесь к <a class="xref" href="sql-createtrigger.html" title="CREATE TRIGGER"><span class="refentrytitle">CREATE TRIGGER</span></a>. Так же есть возможность создавать правила (см. <a class="xref" href="sql-createrule.html" title="CREATE RULE"><span class="refentrytitle">CREATE RULE</span></a>), но на практике триггеры проще для понимания и применения.</p><p>Учтите, что пользователь, выполняющий операции добавления, изменения или удаления данных в представлении, должен иметь соответствующие права для этого представления. Кроме того, владелец представления должен иметь сопутствующие права в нижележащих базовых отношениях, хотя пользователь, собственно выполняющий эти операции, может этих прав не иметь (см. <a class="xref" href="rules-privileges.html" title="41.5. Правила и права">Раздел 41.5</a>). Однако если для представления свойство <code class="literal">security_invoker</code> равно <code class="literal">true</code>, пользователь, выполняющий изменение, а не владелец представления должен иметь соответствующие права для нижележащих базовых отношений.</p></div></div><div class="refsect1" id="id-1.9.3.97.8"><h2>Примеры</h2><p>Создание представления, содержащего все комедийные фильмы: </p><pre class="programlisting">CREATE VIEW comedies AS
    SELECT *
    FROM films
    WHERE kind = 'Comedy';</pre><p> Эта команда создаст представление со столбцами, которые содержались в таблице <code class="literal">film</code> в момент выполнения команды. Хотя при создании представления было указано <code class="literal">*</code>, столбцы, добавляемые в таблицу позже, частью представления не будут.</p><p>Создание представления с указанием <code class="literal">LOCAL CHECK OPTION</code>: </p><pre class="programlisting">CREATE VIEW universal_comedies AS
    SELECT *
    FROM comedies
    WHERE classification = 'U'
    WITH LOCAL CHECK OPTION;</pre><p> Эта команда создаст представление на базе представления <code class="literal">comedies</code>, выдающее только комедии (<code class="literal">kind = 'Comedy'</code>) универсальной возрастной категории <code class="literal">classification = 'U'</code>. Любая попытка выполнить в представлении <code class="command">INSERT</code> или <code class="command">UPDATE</code> со строкой, не удовлетворяющей условию <code class="literal">classification = 'U'</code>, будет отвергнута, но ограничение по полю <code class="literal">kind</code> (тип фильма) проверяться не будет.</p><p>Создание представления с указанием <code class="literal">CASCADED CHECK OPTION</code>: </p><pre class="programlisting">CREATE VIEW pg_comedies AS
    SELECT *
    FROM comedies
    WHERE classification = 'PG'
    WITH CASCADED CHECK OPTION;</pre><p> Это представление будет проверять, удовлетворяют ли новые строки обоим условиям: по столбцу <code class="literal">kind</code> и по столбцу <code class="literal">classification</code>.</p><p>Создание представления с изменяемыми и неизменяемыми столбцами: </p><pre class="programlisting">CREATE VIEW comedies AS
    SELECT f.*,
           country_code_to_name(f.country_code) AS country,
           (SELECT avg(r.rating)
            FROM user_ratings r
            WHERE r.film_id = f.id) AS avg_rating
    FROM films f
    WHERE f.kind = 'Comedy';</pre><p> Это представление будет поддерживать операции <code class="command">INSERT</code>, <code class="command">UPDATE</code> и <code class="command">DELETE</code>. Изменяемыми будут все столбцы из таблицы <code class="literal">films</code>, тогда как вычисляемые столбцы <code class="literal">country</code> и <code class="literal">avg_rating</code> будут доступны только для чтения.</p><p>Создание рекурсивного представления, содержащего числа от 1 до 100: </p><pre class="programlisting">CREATE RECURSIVE VIEW public.nums_1_100 (n) AS
    VALUES (1)
UNION ALL
    SELECT n+1 FROM nums_1_100 WHERE n &lt; 100;</pre><p> Заметьте, что несмотря на то, что имя рекурсивного представления дополнено схемой в этой команде <code class="command">CREATE</code>, внутренняя ссылка представления на себя же схемой не дополняется. Это связано с тем, что имя неявно создаваемого CTE не может дополняться схемой.</p></div><div class="refsect1" id="id-1.9.3.97.9"><h2>Совместимость</h2><p>Команда <code class="command">CREATE OR REPLACE VIEW</code> — языковое расширение <span class="productname">PostgreSQL</span>. Так же расширениями являются концепция временного представления, предложение <code class="literal">WITH ( ... )</code>, представления с барьером безопасности и представления с контекстом безопасности вызывающего.</p></div><div class="refsect1" id="id-1.9.3.97.10"><h2>См. также</h2><span class="simplelist"><a class="xref" href="sql-alterview.html" title="ALTER VIEW"><span class="refentrytitle">ALTER VIEW</span></a>, <a class="xref" href="sql-dropview.html" title="DROP VIEW"><span class="refentrytitle">DROP VIEW</span></a>, <a class="xref" href="sql-creatematerializedview.html" title="CREATE MATERIALIZED VIEW"><span class="refentrytitle">CREATE MATERIALIZED VIEW</span></a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-createusermapping.html" title="CREATE USER MAPPING">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-deallocate.html" title="DEALLOCATE">След.</a></td></tr><tr><td width="40%" align="left" valign="top">CREATE USER MAPPING </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> DEALLOCATE</td></tr></table></div></body></html>