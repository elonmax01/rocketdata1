<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>9.7. Поиск по шаблону</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="functions-bitstring.html" title="9.6. Функции и операторы для работы с битовыми строками" /><link rel="next" href="functions-formatting.html" title="9.8. Функции форматирования данных" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">9.7. Поиск по шаблону</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="functions-bitstring.html" title="9.6. Функции и операторы для работы с битовыми строками">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="functions.html" title="Глава 9. Функции и операторы">Наверх</a></td><th width="60%" align="center">Глава 9. Функции и операторы</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="functions-formatting.html" title="9.8. Функции форматирования данных">След.</a></td></tr></table><hr /></div><div class="sect1" id="FUNCTIONS-MATCHING"><div class="titlepage"><div><div><h2 class="title" style="clear: both">9.7. Поиск по шаблону <a href="#FUNCTIONS-MATCHING" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="functions-matching.html#FUNCTIONS-LIKE">9.7.1. <code class="function">LIKE</code></a></span></dt><dt><span class="sect2"><a href="functions-matching.html#FUNCTIONS-SIMILARTO-REGEXP">9.7.2. Регулярные выражения <code class="function">SIMILAR TO</code></a></span></dt><dt><span class="sect2"><a href="functions-matching.html#FUNCTIONS-POSIX-REGEXP">9.7.3. Регулярные выражения <acronym class="acronym">POSIX</acronym></a></span></dt></dl></div><a id="id-1.5.8.13.2" class="indexterm"></a><p><span class="productname">PostgreSQL</span> предлагает три разных способа поиска текста по шаблону: традиционный оператор <code class="function">LIKE</code> языка <acronym class="acronym">SQL</acronym>, более современный <code class="function">SIMILAR TO</code> (добавленный в SQL:1999) и регулярные выражения в стиле <acronym class="acronym">POSIX</acronym>. Помимо простых операторов, отвечающих на вопрос <span class="quote">«<span class="quote">соответствует ли строка этому шаблону?</span>»</span>, в <span class="productname">PostgreSQL</span> есть функции для извлечения или замены соответствующих подстрок и для разделения строки по заданному шаблону.</p><div class="tip"><h3 class="title">Подсказка</h3><p>Если этих встроенных возможностей оказывается недостаточно, вы можете написать собственные функции на языке Perl или Tcl.</p></div><div class="caution"><h3 class="title">Внимание</h3><p>Хотя чаще всего поиск по регулярному выражению бывает очень быстрым, регулярные выражения бывают и настолько сложными, что их обработка может занять приличное время и объём памяти. Поэтому опасайтесь шаблонов регулярных выражений, поступающих из недоверенных источников. Если у вас нет другого выхода, рекомендуется ввести тайм-аут для операторов.</p><p>Поиск с шаблонами <code class="function">SIMILAR TO</code> несёт те же риски безопасности, так как конструкция <code class="function">SIMILAR TO</code> предоставляет во многом те же возможности, что и регулярные выражения в стиле <acronym class="acronym">POSIX</acronym>.</p><p>Поиск с <code class="function">LIKE</code> гораздо проще, чем два другие варианта, поэтому его безопаснее использовать с недоверенными источниками шаблонов поиска.</p></div><p>Все три вида операторов поиска по шаблону не поддерживают недетерминированные правила сортировки. В случае необходимости это ограничение можно обойти, применив к выражению другое правило сортировки.</p><div class="sect2" id="FUNCTIONS-LIKE"><div class="titlepage"><div><div><h3 class="title">9.7.1. <code class="function">LIKE</code> <a href="#FUNCTIONS-LIKE" class="id_link">#</a></h3></div></div></div><a id="id-1.5.8.13.7.2" class="indexterm"></a><pre class="synopsis"><em class="replaceable"><code>строка</code></em> LIKE <em class="replaceable"><code>шаблон</code></em> [<span class="optional">ESCAPE <em class="replaceable"><code>спецсимвол</code></em></span>]
<em class="replaceable"><code>строка</code></em> NOT LIKE <em class="replaceable"><code>шаблон</code></em> [<span class="optional">ESCAPE <em class="replaceable"><code>спецсимвол</code></em></span>]</pre><p>Выражение <code class="function">LIKE</code> возвращает true, если <em class="replaceable"><code>строка</code></em> соответствует заданному <em class="replaceable"><code>шаблону</code></em>. (Как можно было ожидать, выражение <code class="function">NOT LIKE</code> возвращает false, когда <code class="function">LIKE</code> возвращает true, и наоборот. Этому выражению равносильно выражение <code class="literal">NOT (<em class="replaceable"><code>строка</code></em> LIKE <em class="replaceable"><code>шаблон</code></em>)</code>.)</p><p>Если <em class="replaceable"><code>шаблон</code></em> не содержит знаков процента и подчёркиваний, тогда шаблон представляет в точности строку и <code class="function">LIKE</code> работает как оператор сравнения. Подчёркивание (<code class="literal">_</code>) в <em class="replaceable"><code>шаблоне</code></em> подменяет (вместо него подходит) любой символ; а знак процента (<code class="literal">%</code>) подменяет любую (в том числе и пустую) последовательность символов.</p><p>Несколько примеров: </p><pre class="programlisting">'abc' LIKE 'abc'    <em class="lineannotation"><span class="lineannotation">true</span></em>
'abc' LIKE 'a%'     <em class="lineannotation"><span class="lineannotation">true</span></em>
'abc' LIKE '_b_'    <em class="lineannotation"><span class="lineannotation">true</span></em>
'abc' LIKE 'c'      <em class="lineannotation"><span class="lineannotation">false</span></em></pre><p>При проверке по шаблону <code class="function">LIKE</code> всегда рассматривается вся строка. Поэтому, если нужно найти последовательность символов где-то в середине строки, шаблон должен начинаться и заканчиваться знаками процента.</p><p>Чтобы найти в строке буквальное вхождение знака процента или подчёркивания, перед соответствующим символом в <em class="replaceable"><code>шаблоне</code></em> нужно добавить спецсимвол. По умолчанию в качестве спецсимвола выбрана обратная косая черта, но с помощью предложения <code class="literal">ESCAPE</code> можно выбрать и другой. Чтобы включить спецсимвол в шаблон поиска, продублируйте его.</p><div class="note"><h3 class="title">Примечание</h3><p>Если параметр <a class="xref" href="runtime-config-compatible.html#GUC-STANDARD-CONFORMING-STRINGS">standard_conforming_strings</a> выключен, каждый символ обратной косой черты, записываемый в текстовой константе, нужно дублировать. Подробнее это описано в <a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-STRINGS" title="4.1.2.1. Строковые константы">Подразделе 4.1.2.1</a>.</p></div><p>Также можно отказаться от спецсимвола, написав <code class="literal">ESCAPE ''</code>. При этом механизм спецпоследовательностей фактически отключается и использовать знаки процента и подчёркивания буквально в шаблоне нельзя.</p><p>Согласно стандарту SQL, отсутствие указания <code class="literal">ESCAPE</code> означает, что спецсимвол не определён (то есть спецсимволом не будет обратная косая черта), а пустое значение в <code class="literal">ESCAPE</code> не допускается. Таким образом, в этом поведение <span class="productname">PostgreSQL</span> несколько отличается от оговорённого в стандарте.</p><p>Вместо <code class="token">LIKE</code> можно использовать ключевое слово <code class="token">ILIKE</code>, чтобы поиск был регистр-независимым с учётом текущей языковой среды. Этот оператор не описан в стандарте <acronym class="acronym">SQL</acronym>; это расширение <span class="productname">PostgreSQL</span>.</p><p>Кроме того, в <span class="productname">PostgreSQL</span> есть оператор <code class="literal">~~</code>, равнозначный <code class="function">LIKE</code>, и <code class="literal">~~*</code>, соответствующий <code class="function">ILIKE</code>. Есть также два оператора <code class="literal">!~~</code> и <code class="literal">!~~*</code>, представляющие <code class="function">NOT LIKE</code> и <code class="function">NOT ILIKE</code>, соответственно. Все эти операторы относятся к особенностям <span class="productname">PostgreSQL</span>. Вы можете увидеть их, например, в выводе команды <code class="command">EXPLAIN</code>, так как при разборе запроса проверка <code class="function">LIKE</code> и подобные заменяются ими.</p><p>Фразы <code class="function">LIKE</code>, <code class="function">ILIKE</code>, <code class="function">NOT LIKE</code> и <code class="function">NOT ILIKE</code> в синтаксисе <span class="productname">PostgreSQL</span> обычно обрабатываются как операторы; например, их можно использовать в конструкциях <em class="replaceable"><code>выражение</code></em> <em class="replaceable"><code>оператор</code></em> ANY (<em class="replaceable"><code>подвыражение</code></em>), хотя предложение <code class="literal">ESCAPE</code> здесь добавить нельзя. В некоторых особых случаях всё же может потребоваться использовать вместо них нижележащие операторы.</p><p>Также обратите внимание на оператор проверки начала строки <code class="literal">^@</code> и соответствующую функцию <code class="function">starts_with()</code>, которые полезны в случаях, когда нужно произвести сопоставление только с началом строки.</p></div><div class="sect2" id="FUNCTIONS-SIMILARTO-REGEXP"><div class="titlepage"><div><div><h3 class="title">9.7.2. Регулярные выражения <code class="function">SIMILAR TO</code> <a href="#FUNCTIONS-SIMILARTO-REGEXP" class="id_link">#</a></h3></div></div></div><a id="id-1.5.8.13.8.2" class="indexterm"></a><a id="id-1.5.8.13.8.3" class="indexterm"></a><a id="id-1.5.8.13.8.4" class="indexterm"></a><pre class="synopsis"><em class="replaceable"><code>строка</code></em> SIMILAR TO <em class="replaceable"><code>шаблон</code></em> [<span class="optional">ESCAPE <em class="replaceable"><code>спецсимвол</code></em></span>]
<em class="replaceable"><code>строка</code></em> NOT SIMILAR TO <em class="replaceable"><code>шаблон</code></em> [<span class="optional">ESCAPE <em class="replaceable"><code>спецсимвол</code></em></span>]</pre><p>Оператор <code class="function">SIMILAR TO</code> возвращает true или false в зависимости от того, соответствует ли данная строка шаблону или нет. Он работает подобно оператору <code class="function">LIKE</code>, только его шаблоны соответствуют определению регулярных выражений в стандарте SQL. Регулярные выражения SQL представляют собой любопытный гибрид синтаксиса <code class="function">LIKE</code> с синтаксисом обычных регулярных выражений (POSIX).</p><p>Как и <code class="function">LIKE</code>, условие <code class="function">SIMILAR TO</code> истинно, только если шаблон соответствует всей строке; это отличается от условий с регулярными выражениями, в которых шаблон может соответствовать любой части строки. Также подобно <code class="function">LIKE</code>, <code class="function">SIMILAR TO</code> воспринимает символы <code class="literal">_</code> и <code class="literal">%</code> как знаки подстановки, подменяющие любой один символ или любую подстроку, соответственно (в регулярных выражениях POSIX им аналогичны символы <code class="literal">.</code> и <code class="literal">.*</code>).</p><p>Помимо средств описания шаблонов, позаимствованных от <code class="function">LIKE</code>, <code class="function">SIMILAR TO</code> поддерживает следующие метасимволы, унаследованные от регулярных выражений POSIX: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">|</code> означает выбор (одного из двух вариантов).</p></li><li class="listitem"><p><code class="literal">*</code> означает повторение предыдущего элемента 0 и более раз.</p></li><li class="listitem"><p><code class="literal">+</code> означает повторение предыдущего элемента 1 и более раз.</p></li><li class="listitem"><p><code class="literal">?</code> означает вхождение предыдущего элемента 0 или 1 раз.</p></li><li class="listitem"><p><code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">}</code> означает повторяет предыдущего элемента ровно <em class="replaceable"><code>m</code></em> раз.</p></li><li class="listitem"><p><code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">,}</code> означает повторение предыдущего элемента <em class="replaceable"><code>m</code></em> или более раз.</p></li><li class="listitem"><p><code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">,</code><em class="replaceable"><code>n</code></em><code class="literal">}</code> означает повторение предыдущего элемента не менее чем <em class="replaceable"><code>m</code></em> и не более чем <em class="replaceable"><code>n</code></em> раз.</p></li><li class="listitem"><p>Скобки <code class="literal">()</code> объединяют несколько элементов в одну логическую группу.</p></li><li class="listitem"><p>Квадратные скобки <code class="literal">[...]</code> обозначают класс символов так же, как и в регулярных выражениях POSIX.</p></li></ul></div><p> Обратите внимание, точка (<code class="literal">.</code>) не является метасимволом для оператора <code class="function">SIMILAR TO</code>.</p><p>Как и с <code class="function">LIKE</code>, обратная косая черта отменяет специальное значение любого из этих метасимволов. Предложение <code class="literal">ESCAPE</code> позволяет выбрать другой спецсимвол, а запись <code class="literal">ESCAPE ''</code> — отказаться от использования спецсимвола.</p><p>Согласно стандарту SQL, отсутствие указания <code class="literal">ESCAPE</code> означает, что спецсимвол не определён (то есть спецсимволом не будет обратная косая черта), а пустое значение в <code class="literal">ESCAPE</code> не допускается. Таким образом, в этом поведение <span class="productname">PostgreSQL</span> несколько отличается от оговорённого в стандарте.</p><p>Ещё одно отклонение от стандарта состоит в том, что следующая за спецсимволом буква или цифра открывает возможности спецпоследовательностей, определённых для регулярных выражений POSIX; см. <a class="xref" href="functions-matching.html#POSIX-CHARACTER-ENTRY-ESCAPES-TABLE" title="Таблица 9.20. Спецобозначения символов в регулярных выражениях">Таблицу 9.20</a>, <a class="xref" href="functions-matching.html#POSIX-CLASS-SHORTHAND-ESCAPES-TABLE" title="Таблица 9.21. Спецкоды классов в регулярных выражениях">Таблицу 9.21</a> и <a class="xref" href="functions-matching.html#POSIX-CONSTRAINT-ESCAPES-TABLE" title="Таблица 9.22. Спецсимволы ограничений в регулярных выражений">Таблицу 9.22</a>.</p><p>Несколько примеров: </p><pre class="programlisting">'abc' SIMILAR TO 'abc'          <em class="lineannotation"><span class="lineannotation">true</span></em>
'abc' SIMILAR TO 'a'            <em class="lineannotation"><span class="lineannotation">false</span></em>
'abc' SIMILAR TO '%(b|d)%'      <em class="lineannotation"><span class="lineannotation">true</span></em>
'abc' SIMILAR TO '(b|c)%'       <em class="lineannotation"><span class="lineannotation">false</span></em>
'-abc-' SIMILAR TO '%\mabc\M%'  <em class="lineannotation"><span class="lineannotation">true</span></em>
'xabcy' SIMILAR TO '%\mabc\M%'  <em class="lineannotation"><span class="lineannotation">false</span></em></pre><p>Функция <code class="function">substring</code> с тремя параметрами производит извлечение подстроки, соответствующей шаблону регулярного выражения SQL. Эту функцию можно вызвать в стандартном синтаксисе SQL: </p><pre class="synopsis">
substring(<em class="replaceable"><code>строка</code></em> similar <em class="replaceable"><code>шаблон</code></em> escape <em class="replaceable"><code>спецсимвол</code></em>)
</pre><p> или используя синтаксис уже устаревшего стандарта SQL:1999: </p><pre class="synopsis">
substring(<em class="replaceable"><code>строка</code></em> from <em class="replaceable"><code>шаблон</code></em> for <em class="replaceable"><code>спецсимвол</code></em>)
</pre><p> или в виде обычной функции с тремя аргументами: </p><pre class="synopsis">
substring(<em class="replaceable"><code>строка</code></em>, <em class="replaceable"><code>шаблон</code></em>, <em class="replaceable"><code>спецсимвол</code></em>)
</pre><p> Как и с <code class="literal">SIMILAR TO</code>, указанному шаблону должна соответствовать вся строка; в противном случае функция не найдёт ничего и вернёт NULL. Для выделения в шаблоне границ подстроки, которая представляет интерес в соответствующей этому шаблону входной строке, шаблон может содержать два спецсимвола с кавычками (<code class="literal">"</code>) после каждого. В случае успешного обнаружения шаблона эта функция возвращает часть строки, заключённую между этими разделителями.</p><p>Разделители «спецсимвол+кавычки» фактически разделяют шаблон <code class="function">substring</code> на три независимых регулярных выражения, так что, например, вертикальная черта (<code class="literal">|</code>) в любой из этих трёх частей действует только в рамках этой части. Кроме того, в случае неоднозначности в выборе подстрок, соответствующих этим частям, первое и третье регулярные выражения считаются захватывающими наименьшие возможные подстроки. (На языке POSIX можно сказать, что первое и третье регулярные выражения — «нежадные».)</p><p>В качестве расширения стандарта SQL в <span class="productname">PostgreSQL</span> допускается указание только одного разделителя, в этом случае третье регулярное выражение считается пустым; также разделители могут отсутствовать вовсе, в этом случае пустыми считаются первое и третье регулярные выражения.</p><p>Несколько примеров с маркерами <code class="literal">#"</code>, выделяющими возвращаемую строку: </p><pre class="programlisting">substring('foobar' similar '%#"o_b#"%' escape '#')   <em class="lineannotation"><span class="lineannotation">oob</span></em>
substring('foobar' similar '#"o_b#"%' escape '#')    <em class="lineannotation"><span class="lineannotation">NULL</span></em></pre></div><div class="sect2" id="FUNCTIONS-POSIX-REGEXP"><div class="titlepage"><div><div><h3 class="title">9.7.3. Регулярные выражения <acronym class="acronym">POSIX</acronym> <a href="#FUNCTIONS-POSIX-REGEXP" class="id_link">#</a></h3></div></div></div><a id="id-1.5.8.13.9.2" class="indexterm"></a><a id="id-1.5.8.13.9.3" class="indexterm"></a><a id="id-1.5.8.13.9.4" class="indexterm"></a><a id="id-1.5.8.13.9.5" class="indexterm"></a><a id="id-1.5.8.13.9.6" class="indexterm"></a><a id="id-1.5.8.13.9.7" class="indexterm"></a><a id="id-1.5.8.13.9.8" class="indexterm"></a><a id="id-1.5.8.13.9.9" class="indexterm"></a><a id="id-1.5.8.13.9.10" class="indexterm"></a><a id="id-1.5.8.13.9.11" class="indexterm"></a><a id="id-1.5.8.13.9.12" class="indexterm"></a><p>В <a class="xref" href="functions-matching.html#FUNCTIONS-POSIX-TABLE" title="Таблица 9.16. Операторы регулярных выражений">Таблице 9.16</a> перечислены все существующие операторы для проверки строк регулярными выражениями POSIX.</p><div class="table" id="FUNCTIONS-POSIX-TABLE"><p class="title"><strong>Таблица 9.16. Операторы регулярных выражений</strong></p><div class="table-contents"><table class="table" summary="Операторы регулярных выражений" border="1"><colgroup><col /></colgroup><thead><tr><th class="func_table_entry"><p class="func_signature">Оператор</p>
       <p>Описание</p>
       <p>Пример(ы)</p></th></tr></thead><tbody><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">text</code> <code class="literal">~</code> <code class="type">text</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>Проверка соответствия строки регулярному выражению с учётом регистра</p>
       <p>
        <code class="literal">'thomas' ~ 't.*ma'</code>
        → <code class="returnvalue">t</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">text</code> <code class="literal">~*</code> <code class="type">text</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>Проверка соответствия строки регулярному выражению без учёта регистра</p>
       <p>
        <code class="literal">'thomas' ~* 'T.*ma'</code>
        → <code class="returnvalue">t</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">text</code> <code class="literal">!~</code> <code class="type">text</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>Проверка несоответствия строки регулярному выражению с учётом регистра</p>
       <p>
        <code class="literal">'thomas' !~ 't.*max'</code>
        → <code class="returnvalue">t</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">text</code> <code class="literal">!~*</code> <code class="type">text</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>Проверка несоответствия строки регулярному выражению без учёта регистра</p>
       <p>
        <code class="literal">'thomas' !~* 'T.*ma'</code>
        → <code class="returnvalue">f</code>
       </p></td></tr></tbody></table></div></div><br class="table-break" /><p>Регулярные выражения <acronym class="acronym">POSIX</acronym> предоставляют более мощные средства поиска по шаблонам, чем операторы <code class="function">LIKE</code> и <code class="function">SIMILAR TO</code>. Во многих командах Unix, таких как <code class="command">egrep</code>, <code class="command">sed</code> и <code class="command">awk</code> используется язык шаблонов, похожий на описанный здесь.</p><p>Регулярное выражение — это последовательность символов, представляющая собой краткое определение набора строк (<em class="firstterm">регулярное множество</em>). Строка считается соответствующей регулярному выражению, если она является членом регулярного множества, описываемого регулярным выражением. Как и для <code class="function">LIKE</code>, символы шаблона непосредственно соответствуют символам строки, за исключением специальных символов языка регулярных выражений. При этом спецсимволы регулярных выражений отличается от спецсимволов <code class="function">LIKE</code>. В отличие от шаблонов <code class="function">LIKE</code>, регулярное выражение может совпадать с любой частью строки, если только оно не привязано явно к началу и/или концу строки.</p><p>Несколько примеров: </p><pre class="programlisting">'abcd' ~ 'bc'     <em class="lineannotation"><span class="lineannotation">true</span></em>
'abcd' ~ 'a.c'    <em class="lineannotation"><span class="lineannotation">true — точке соответствует любой символ</span></em>
'abcd' ~ 'a.*d'   <em class="lineannotation"><span class="lineannotation">true — <code class="literal">*</code> обозначает повторение предыдущего элемента шаблона</span></em>
'abcd' ~ '(b|x)'  <em class="lineannotation"><span class="lineannotation">true — <code class="literal">|</code> означает ИЛИ для группы в скобках</span></em>
'abcd' ~ '^a'     <em class="lineannotation"><span class="lineannotation">true — <code class="literal">^</code> привязывает шаблон к началу строки</span></em>
'abcd' ~ '^(b|c)' <em class="lineannotation"><span class="lineannotation">false — совпадение не найдено по причине привязки к началу</span></em></pre><p>Более подробно язык шаблонов в стиле <acronym class="acronym">POSIX</acronym> описан ниже.</p><p>Функция <code class="function">substring</code> с двумя параметрами, <code class="function">substring(<em class="replaceable"><code>строка</code></em> from <em class="replaceable"><code>шаблон</code></em>)</code>, извлекает подстроку, соответствующую шаблону регулярного выражения POSIX. Она возвращает первый фрагмент текста, подходящий шаблону, если таковой находится в строке, либо NULL в противном случае. Но если шаблон содержит скобки, она возвращает первое подвыражение, заключённое в скобки (то, которое начинается с самой первой открывающей скобки). Если вы хотите использовать скобки, но не в таком особом режиме, можно просто заключить в них всё выражение. Если же вам нужно включить скобки в шаблон до подвыражения, которое вы хотите извлечь, это можно сделать, используя группы без захвата, которые будут описаны ниже.</p><p>Несколько примеров: </p><pre class="programlisting">substring('foobar' from 'o.b')     <em class="lineannotation"><span class="lineannotation">oob</span></em>
substring('foobar' from 'o(.)b')   <em class="lineannotation"><span class="lineannotation">o</span></em></pre><p>Функция <code class="function">regexp_count</code> подсчитывает количество мест, где шаблон регулярного выражения POSIX соответствует строке. Она имеет синтаксис <code class="function">regexp_count</code>(<em class="replaceable"><code>строка</code></em>, <em class="replaceable"><code>шаблон</code></em> [<span class="optional">, <em class="replaceable"><code>начало</code></em> [<span class="optional">, <em class="replaceable"><code>флаги</code></em></span>]</span>]). <em class="replaceable"><code>Шаблон</code></em> ищется в <em class="replaceable"><code>строке</code></em> обычно с начала строки, но если указан параметр <em class="replaceable"><code>начало</code></em>, то начиная с этого индекса. В параметре <em class="replaceable"><code>флаги</code></em> может передаваться текстовая строка, содержащая ноль или более однобуквенных флагов, меняющих поведение функции. Например, буква <code class="literal">i</code> во <em class="replaceable"><code>флагах</code></em> выбирает регистронезависимый режим поиска. Поддерживаемые флаги описаны в <a class="xref" href="functions-matching.html#POSIX-EMBEDDED-OPTIONS-TABLE" title="Таблица 9.24. Буквы встроенных параметров ARE">Таблице 9.24</a>.</p><p>Несколько примеров: </p><pre class="programlisting">regexp_count('ABCABCAXYaxy', 'A.')          <em class="lineannotation"><span class="lineannotation">3</span></em>
regexp_count('ABCABCAXYaxy', 'A.', 1, 'i')  <em class="lineannotation"><span class="lineannotation">4</span></em></pre><p>Функция <code class="function">regexp_instr</code> возвращает начальную или конечную позицию <em class="replaceable"><code>N</code></em>-го вхождения шаблона регулярного выражения POSIX в строке или ноль, если такого вхождения нет. Она имеет синтаксис <code class="function">regexp_instr</code>(<em class="replaceable"><code>строка</code></em>, <em class="replaceable"><code>шаблон</code></em> [<span class="optional">, <em class="replaceable"><code>начало</code></em> [<span class="optional">, <em class="replaceable"><code>N</code></em> [<span class="optional">, <em class="replaceable"><code>выбор_конца</code></em> [<span class="optional">, <em class="replaceable"><code>флаги</code></em> [<span class="optional">, <em class="replaceable"><code>подвыражение</code></em></span>]</span>]</span>]</span>]</span>]). <em class="replaceable"><code>Шаблон</code></em> ищется в <em class="replaceable"><code>строке</code></em> обычно с начала строки, но если указан параметр <em class="replaceable"><code>начало</code></em>, то начиная с этого индекса. Если указано <em class="replaceable"><code>N</code></em>, то ищется <em class="replaceable"><code>N</code></em>-е вхождение шаблона, иначе ищется первое вхождение. Если параметр <em class="replaceable"><code>выбор_конца</code></em> опущен или равен нулю, функция возвращает позицию первого символа вхождения. Иначе <em class="replaceable"><code>выбор_конца</code></em> должен быть равен одному и функция возвращает позицию символа, следующего за вхождением. В параметре <em class="replaceable"><code>флаги</code></em> может передаваться текстовая строка, содержащая ноль или более однобуквенных флагов, меняющих поведение функции. Например, буква <code class="literal">i</code> во <em class="replaceable"><code>флагах</code></em> выбирает регистронезависимый режим поиска. Поддерживаемые флаги описаны в <a class="xref" href="functions-matching.html#POSIX-EMBEDDED-OPTIONS-TABLE" title="Таблица 9.24. Буквы встроенных параметров ARE">Таблице 9.24</a>. Для шаблона, содержащего подвыражения в скобках, <em class="replaceable"><code>подвыражение</code></em> — целое число, которое выбирает представляющее интерес подвыражение: в результате выдаётся позиция подстроки, соответствующей этому подвыражению. Подвыражения нумеруются по порядку открывающих их скобок. Когда <em class="replaceable"><code>подвыражение</code></em> опущено или равно нулю, в результате выдаётся позиция всего вхождения независимо от подвыражений в скобках.</p><p>Несколько примеров: </p><pre class="programlisting">regexp_instr('number of your street, town zip, FR', '[^,]+', 1, 2)
                                   <em class="lineannotation"><span class="lineannotation">23</span></em>
regexp_instr('ABCDEFGHI', '(c..)(...)', 1, 1, 0, 'i', 2)
                                   <em class="lineannotation"><span class="lineannotation">6</span></em></pre><p>Функция <code class="function">regexp_like</code> проверяет, встречается ли в строке вхождение шаблона регулярного выражения POSIX, возвращая логическое значение true или false. Она имеет синтаксис <code class="function">regexp_like</code>(<em class="replaceable"><code>строка</code></em>, <em class="replaceable"><code>шаблон</code></em> [<span class="optional">, <em class="replaceable"><code>флаги</code></em></span>]). В параметре <em class="replaceable"><code>флаги</code></em> передаётся необязательная текстовая строка, содержащая ноль или более однобуквенных флагов, меняющих поведение функции. Поддерживаемые флаги описаны в <a class="xref" href="functions-matching.html#POSIX-EMBEDDED-OPTIONS-TABLE" title="Таблица 9.24. Буквы встроенных параметров ARE">Таблица 9.24</a>. Если флаги не указаны, эта функция выдаёт те же результаты, что и оператор <code class="literal">~</code>. Если указан только флаг <code class="literal">i</code>, она выдаёт те же результаты, что и оператор <code class="literal">~*</code>.</p><p>Несколько примеров: </p><pre class="programlisting">regexp_like('Hello World', 'world')       <em class="lineannotation"><span class="lineannotation">false</span></em>
regexp_like('Hello World', 'world', 'i')  <em class="lineannotation"><span class="lineannotation">true</span></em></pre><p>Функция <code class="function">regexp_match</code> возвращает текстовый массив с совпавшими подстроками из первого вхождения шаблона регулярного выражения POSIX в строке. Она имеет синтаксис <code class="function">regexp_match</code>(<em class="replaceable"><code>строка</code></em>, <em class="replaceable"><code>шаблон</code></em> [<span class="optional">, <em class="replaceable"><code>флаги</code></em></span>]). Если вхождение не находится, результатом будет <code class="literal">NULL</code>. Если вхождение находится и <em class="replaceable"><code>шаблон</code></em> не содержит подвыражений в скобках, результатом будет текстовый массив с одним элементом, содержащим подстроку, которая соответствует всему шаблону. Если вхождение находится и <em class="replaceable"><code>шаблон</code></em> содержит подвыражения в скобках, результатом будет текстовый массив, в котором <em class="replaceable"><code>n</code></em>-м элементом будет <em class="replaceable"><code>n</code></em>-е заключённое в скобки подвыражение <em class="replaceable"><code>шаблона</code></em> (не считая <span class="quote">«<span class="quote">незахватывающих</span>»</span> скобок; подробнее см. ниже). В параметре <em class="replaceable"><code>флаги</code></em> передаётся необязательная текстовая строка, содержащая ноль или более однобуквенных флагов, меняющих поведение функции. Допустимые флаги описаны в <a class="xref" href="functions-matching.html#POSIX-EMBEDDED-OPTIONS-TABLE" title="Таблица 9.24. Буквы встроенных параметров ARE">Таблице 9.24</a>.</p><p>Несколько примеров: </p><pre class="programlisting">SELECT regexp_match('foobarbequebaz', 'bar.*que');
 regexp_match
--------------
 {barbeque}
(1 row)

SELECT regexp_match('foobarbequebaz', '(bar)(beque)');
 regexp_match
--------------
 {bar,beque}
(1 row)</pre><div class="tip"><h3 class="title">Подсказка</h3><p>В общем случае, когда нужно просто получить всю найденную подстроку или <code class="literal">NULL</code> при отсутствии вхождений, лучше использовать <code class="function">regexp_substr()</code>. Однако функция <code class="function">regexp_substr()</code> есть только в <span class="productname">PostgreSQL</span> версии 15 и выше. В предыдущих версиях для этого можно извлечь первый элемент результата <code class="function">regexp_match()</code>, например: </p><pre class="programlisting">SELECT (regexp_match('foobarbequebaz', 'bar.*que'))[1];
 regexp_match
--------------
 barbeque
(1 row)</pre></div><p>Функция <code class="function">regexp_matches</code> возвращает набор текстовых массивов с совпавшими подстроками из вхождений шаблона регулярного выражения POSIX в строке. Она имеет тот же синтаксис, что и <code class="function">regexp_match</code>. Эта функция не возвращает никаких строк, если вхождений нет; возвращает одну строку, если найдено одно вхождение и не передан флаг <code class="literal">g</code>, или <em class="replaceable"><code>N</code></em> строк, если найдено <em class="replaceable"><code>N</code></em> вхождений и передан флаг <code class="literal">g</code>. Каждая возвращаемая строка представляет собой текстовый массив, содержащий всю найденную подстроку или подстроки, соответствующие заключённым в скобки подвыражениям <em class="replaceable"><code>шаблона</code></em>, как и описанный выше результат <code class="function">regexp_match</code>. Функция <code class="function">regexp_matches</code> принимает все флаги, показанные в <a class="xref" href="functions-matching.html#POSIX-EMBEDDED-OPTIONS-TABLE" title="Таблица 9.24. Буквы встроенных параметров ARE">Таблице 9.24</a>, а также флаг <code class="literal">g</code>, указывающий ей выдать все вхождения, а не только первое.</p><p>Несколько примеров: </p><pre class="programlisting">SELECT regexp_matches('foo', 'not there');
 regexp_matches
----------------
(0 rows)

SELECT regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g');
 regexp_matches
----------------
 {bar,beque}
 {bazil,barf}
(2 rows)</pre><div class="tip"><h3 class="title">Подсказка</h3><p>В большинстве случаев <code class="function">regexp_matches()</code> должна применяться с флагом <code class="literal">g</code>, так как если вас интересует только первое вхождение, проще и эффективнее использовать функцию <code class="function">regexp_match()</code>. Однако <code class="function">regexp_match()</code> существует только в <span class="productname">PostgreSQL</span> версии 10 и выше. В старых версиях обычно помещали вызов <code class="function">regexp_matches()</code> во вложенный SELECT, например, так: </p><pre class="programlisting">SELECT col1, (SELECT regexp_matches(col2, '(bar)(beque)')) FROM tab;</pre><p> В результате выдаётся текстовый массив, если вхождение найдено, или <code class="literal">NULL</code> в противном случае, так же как с <code class="function">regexp_match()</code>. Без вложенного SELECT этот запрос не возвращает никакие строки, если соответствие не находится, а это обычно не то, что нужно.</p></div><p>Функция <code class="function">regexp_replace</code> подставляет другой текст вместо подстрок, соответствующих шаблонам регулярных выражений POSIX. Она имеет синтаксис <code class="function">regexp_replace</code>(<em class="replaceable"><code>исходная_строка</code></em>, <em class="replaceable"><code>шаблон</code></em>, <em class="replaceable"><code>замена</code></em> [<span class="optional">, <em class="replaceable"><code>начало</code></em> [<span class="optional">, <em class="replaceable"><code>N</code></em></span>]</span>] [<span class="optional">, <em class="replaceable"><code>флаги</code></em></span>]). (Заметьте, что если не задано <em class="replaceable"><code>начало</code></em>, указывать <em class="replaceable"><code>N</code></em> нельзя, но <em class="replaceable"><code>флаги</code></em> можно указывать в любом случае.) Если <em class="replaceable"><code>исходная_строка</code></em> не содержит фрагмента, подходящего под <em class="replaceable"><code>шаблон</code></em>, она возвращается неизменной. Если же соответствие находится, возвращается <em class="replaceable"><code>исходная_строка</code></em>, в которой вместо соответствующего фрагмента подставляется <em class="replaceable"><code>замена</code></em>. Строка <em class="replaceable"><code>замена</code></em> может содержать <code class="literal">\</code><em class="replaceable"><code>n</code></em>, где <em class="replaceable"><code>n</code></em> — число от 1 до 9, указывающее на исходную подстроку, соответствующую <em class="replaceable"><code>n</code></em>-му подвыражению в скобках, и может содержать обозначение <code class="literal">\&amp;</code>, указывающее, что будет вставлена подстрока, соответствующая всему шаблону. Если же в текст замены нужно включить обратную косую черту буквально, следует написать <code class="literal">\\</code>. <em class="replaceable"><code>Шаблон</code></em> ищется в <em class="replaceable"><code>строке</code></em> обычно с начала строки, но если указан параметр <em class="replaceable"><code>начало</code></em>, то начиная с этого индекса. По умолчанию заменяется только первое вхождение шаблона. Если <em class="replaceable"><code>N</code></em> указано и больше нуля, заменяется <em class="replaceable"><code>N</code></em>-е вхождение шаблона. Если передан флаг <code class="literal">g</code> или заданное <em class="replaceable"><code>N</code></em> равно нулю, заменяются все вхождения с позиции <em class="replaceable"><code>начало</code></em> и далее. (Флаг <code class="literal">g</code> игнорируется, когда задано <em class="replaceable"><code>N</code></em>.) В необязательном параметре <em class="replaceable"><code>флаги</code></em> передаётся текстовая строка, содержащая ноль или более однобуквенных флагов, меняющих поведение функции. Допустимые флаги (кроме <code class="literal">g</code>) описаны в <a class="xref" href="functions-matching.html#POSIX-EMBEDDED-OPTIONS-TABLE" title="Таблица 9.24. Буквы встроенных параметров ARE">Таблице 9.24</a>.</p><p>Несколько примеров: </p><pre class="programlisting">regexp_replace('foobarbaz', 'b..', 'X')
                                   <em class="lineannotation"><span class="lineannotation">fooXbaz</span></em>
regexp_replace('foobarbaz', 'b..', 'X', 'g')
                                   <em class="lineannotation"><span class="lineannotation">fooXX</span></em>
regexp_replace('foobarbaz', 'b(..)', 'X\1Y', 'g')
                                   <em class="lineannotation"><span class="lineannotation">fooXarYXazY</span></em>
regexp_replace('A PostgreSQL function', 'a|e|i|o|u', 'X', 1, 0, 'i')
                                   <em class="lineannotation"><span class="lineannotation">X PXstgrXSQL fXnctXXn</span></em>
regexp_replace('A PostgreSQL function', 'a|e|i|o|u', 'X', 1, 3, 'i')
                                   <em class="lineannotation"><span class="lineannotation">A PostgrXSQL function</span></em></pre><p>Функция <code class="function">regexp_split_to_table</code> разделяет строку, используя в качестве разделителя шаблон регулярного выражения POSIX. Она имеет синтаксис <code class="function">regexp_split_to_table</code>(<em class="replaceable"><code>строка</code></em>, <em class="replaceable"><code>шаблон</code></em> [<span class="optional">, <em class="replaceable"><code>флаги</code></em></span>]). Если <em class="replaceable"><code>шаблон</code></em> не находится в переданной строке, возвращается вся <em class="replaceable"><code>строка</code></em> целиком. Если находится минимум одно вхождение, для каждого такого вхождения возвращается текст от конца предыдущего вхождения (или начала строки) до начала вхождения. После последнего найденного вхождения возвращается фрагмент от его конца до конца строки. В необязательном параметре <em class="replaceable"><code>флаги</code></em> передаётся текстовая строка, содержащая ноль или более однобуквенных флагов, меняющих поведение функции. Флаги, которые поддерживает <code class="function">regexp_split_to_table</code>, описаны в <a class="xref" href="functions-matching.html#POSIX-EMBEDDED-OPTIONS-TABLE" title="Таблица 9.24. Буквы встроенных параметров ARE">Таблице 9.24</a>.</p><p>Функция <code class="function">regexp_split_to_array</code> ведёт себя подобно <code class="function">regexp_split_to_table</code>, за исключением того, что <code class="function">regexp_split_to_array</code> возвращает результат в массиве элементов типа <code class="type">text</code>. Она имеет синтаксис <code class="function">regexp_split_to_array</code>(<em class="replaceable"><code>строка</code></em>, <em class="replaceable"><code>шаблон</code></em> [<span class="optional">, <em class="replaceable"><code>флаги</code></em></span>]). Параметры у этой функции те же, что и у <code class="function">regexp_split_to_table</code>.</p><p>Несколько примеров: </p><pre class="programlisting">SELECT foo FROM regexp_split_to_table('the quick brown fox jumps over the lazy dog', '\s+') AS foo;
  foo
-------
 the
 quick
 brown
 fox
 jumps
 over
 the
 lazy
 dog
(9 rows)

SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', '\s+');
              regexp_split_to_array
-----------------------------------------------
 {the,quick,brown,fox,jumps,over,the,lazy,dog}
(1 row)

SELECT foo FROM regexp_split_to_table('the quick brown fox', '\s*') AS foo;
 foo
-----
 t
 h
 e
 q
 u
 i
 c
 k
 b
 r
 o
 w
 n
 f
 o
 x
(16 rows)</pre><p>Как показывает последний пример, функции разделения по регулярным выражениям игнорируют вхождения нулевой длины, идущие в начале и в конце строки, а также непосредственно за предыдущим вхождением. Это поведение противоречит строгому определению поиска по регулярным выражениям, который реализуют другие функции, но обычно более удобно на практике. Подобное поведение наблюдается и в других программных средах, например в Perl.</p><p>Функция <code class="function">regexp_substr</code> возвращает подстроку, соответствующую шаблону регулярного выражения POSIX, или <code class="literal">NULL</code>, если такого соответствия нет. Она имеет синтаксис <code class="function">regexp_substr</code>(<em class="replaceable"><code>строка</code></em>, <em class="replaceable"><code>шаблон</code></em> [<span class="optional">, <em class="replaceable"><code>начало</code></em> [<span class="optional">, <em class="replaceable"><code>N</code></em> [<span class="optional">, <em class="replaceable"><code>флаги</code></em> [<span class="optional">, <em class="replaceable"><code>подвыражение</code></em></span>]</span>]</span>]</span>]). <em class="replaceable"><code>Шаблон</code></em> ищется в <em class="replaceable"><code>строке</code></em> обычно с начала строки, но если указан параметр <em class="replaceable"><code>начало</code></em>, то начиная с этого индекса. Если указано <em class="replaceable"><code>N</code></em>, возвращается <em class="replaceable"><code>N</code></em>-е вхождение шаблона, в противном случае возвращается первое вхождение. В параметре <em class="replaceable"><code>флаги</code></em> передаётся необязательная текстовая строка, содержащая ноль или более однобуквенных флагов, меняющих поведение функции. Поддерживаемые флаги описаны в <a class="xref" href="functions-matching.html#POSIX-EMBEDDED-OPTIONS-TABLE" title="Таблица 9.24. Буквы встроенных параметров ARE">Таблица 9.24</a>. Для шаблона, содержащего подвыражения в скобках, <em class="replaceable"><code>подвыражение</code></em> — целое число, которое выбирает представляющее интерес подвыражение: в результате выдаётся подстрока, соответствующая этому подвыражению. Подвыражения нумеруются по порядку открывающих их скобок. Когда <em class="replaceable"><code>подвыражение</code></em> опущено или равно нулю, в результате выдаётся всё вхождение независимо от подвыражений в скобках.</p><p>Несколько примеров: </p><pre class="programlisting">regexp_substr('number of your street, town zip, FR', '[^,]+', 1, 2)
                                   <em class="lineannotation"><span class="lineannotation"> town zip</span></em>
regexp_substr('ABCDEFGHI', '(c..)(...)', 1, 1, 'i', 2)
                                   <em class="lineannotation"><span class="lineannotation">FGH</span></em></pre><div class="sect3" id="POSIX-SYNTAX-DETAILS"><div class="titlepage"><div><div><h4 class="title">9.7.3.1. Подробное описание регулярных выражений <a href="#POSIX-SYNTAX-DETAILS" class="id_link">#</a></h4></div></div></div><p>Регулярные выражения в <span class="productname">PostgreSQL</span> реализованы с использованием программного пакета, который разработал Генри Спенсер (Henry Spencer). Практически всё следующее описание регулярных выражений дословно скопировано из его руководства.</p><p>Регулярное выражение (Regular expression, <acronym class="acronym">RE</acronym>), согласно определению в <acronym class="acronym">POSIX</acronym> 1003.2, может иметь две формы: <em class="firstterm">расширенное</em> <acronym class="acronym">RE</acronym> или <acronym class="acronym">ERE</acronym> (грубо говоря, это выражения, которые понимает <code class="command">egrep</code>) и <em class="firstterm">простое</em> <acronym class="acronym">RE</acronym> или <acronym class="acronym">BRE</acronym> (грубо говоря, это выражения для <code class="command">ed</code>). <span class="productname">PostgreSQL</span> поддерживает обе формы, а кроме того реализует некоторые расширения, не предусмотренные стандартом POSIX, но широко используемые вследствие их доступности в некоторых языках программирования, например в Perl и Tcl. Регулярные выражения, использующие эти несовместимые с POSIX расширения, здесь называются <em class="firstterm">усовершенствованными</em> <acronym class="acronym">RE</acronym> или <acronym class="acronym">ARE</acronym>. ARE практически представляют собой надмножество ERE, тогда как BRE отличаются некоторой несовместимостью в записи (помимо того, что они гораздо более ограничены). Сначала мы опишем формы ARE и ERE, отметив особенности, присущие только ARE, а затем расскажем, чем от них отличаются BRE.</p><div class="note"><h3 class="title">Примечание</h3><p><span class="productname">PostgreSQL</span> изначально всегда предполагает, что регулярное выражение следует правилам ARE. Однако можно переключиться на более ограниченные правила ERE или BRE, добавив в шаблон RE <em class="firstterm">встроенный параметр</em>, как описано в <a class="xref" href="functions-matching.html#POSIX-METASYNTAX" title="9.7.3.4. Метасинтаксис регулярных выражений">Подразделе 9.7.3.4</a>. Это может быть полезно для совместимости с приложениями, ожидающими от СУБД строгого следования правилам <acronym class="acronym">POSIX</acronym> 1003.2.</p></div><p>Регулярное выражение определяется как одна или более <em class="firstterm">ветвей</em>, разделённых символами <code class="literal">|</code>. Оно считается соответствующим всему, что соответствует одной из этих ветвей.</p><p>Ветвь — это ноль или несколько <em class="firstterm">количественных атомов</em> или <em class="firstterm">ограничений</em>, соединённых вместе. Соответствие ветви в целом образуется из соответствия первой части, за которым следует соответствие второй части и т. д.; пустой ветви соответствует пустая строка.</p><p>Количественный атом — это <em class="firstterm">атом</em>, за которым может следовать <em class="firstterm">определитель количества</em>. Без этого определителя ему соответствует одно вхождение атома. С определителем количества ему может соответствовать некоторое число вхождений этого атома. Все возможные <em class="firstterm">атомы</em> перечислены в <a class="xref" href="functions-matching.html#POSIX-ATOMS-TABLE" title="Таблица 9.17. Атомы регулярных выражений">Таблице 9.17</a>. Варианты определителей количества и их значения перечислены в <a class="xref" href="functions-matching.html#POSIX-QUANTIFIERS-TABLE" title="Таблица 9.18. Определители количества в регулярных выражениях">Таблице 9.18</a>.</p><p><em class="firstterm">Ограничению</em> соответствует пустая строка, но это соответствие возможно только при выполнении определённых условий. Ограничения могут использоваться там же, где и атомы, за исключением того, что их нельзя дополнять определителями количества. Простые ограничения показаны в <a class="xref" href="functions-matching.html#POSIX-CONSTRAINTS-TABLE" title="Таблица 9.19. Ограничения в регулярных выражениях">Таблице 9.19</a>; некоторые дополнительные ограничения описаны ниже.</p><div class="table" id="POSIX-ATOMS-TABLE"><p class="title"><strong>Таблица 9.17. Атомы регулярных выражений</strong></p><div class="table-contents"><table class="table" summary="Атомы регулярных выражений" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Атом</th><th>Описание</th></tr></thead><tbody><tr><td> <code class="literal">(</code><em class="replaceable"><code>re</code></em><code class="literal">)</code> </td><td>(где <em class="replaceable"><code>re</code></em> — любое регулярное выражение) описывает соответствие <em class="replaceable"><code>re</code></em>, при этом данное соответствие захватывается для последующей обработки</td></tr><tr><td> <code class="literal">(?:</code><em class="replaceable"><code>re</code></em><code class="literal">)</code> </td><td>подобно предыдущему, но соответствие не захватывается (т. е. это набор скобок <span class="quote">«<span class="quote">без захвата</span>»</span>) (применимо только к ARE)</td></tr><tr><td> <code class="literal">.</code> </td><td>соответствует любому символу</td></tr><tr><td> <code class="literal">[</code><em class="replaceable"><code>символы</code></em><code class="literal">]</code> </td><td><em class="firstterm">выражение в квадратных скобках</em>, соответствует любому из <em class="replaceable"><code>символов</code></em> (подробнее это описано в <a class="xref" href="functions-matching.html#POSIX-BRACKET-EXPRESSIONS" title="9.7.3.2. Выражения в квадратных скобках">Подразделе 9.7.3.2</a>)</td></tr><tr><td> <code class="literal">\</code><em class="replaceable"><code>k</code></em> </td><td>(где <em class="replaceable"><code>k</code></em> — не алфавитно-цифровой символ) соответствует обычному символу буквально, т. е. <code class="literal">\\</code> соответствует обратной косой черте</td></tr><tr><td> <code class="literal">\</code><em class="replaceable"><code>c</code></em> </td><td>где <em class="replaceable"><code>c</code></em> — алфавитно-цифровой символ (за которым могут следовать другие символы), это <em class="firstterm">спецсимвол</em>, см. <a class="xref" href="functions-matching.html#POSIX-ESCAPE-SEQUENCES" title="9.7.3.3. Спецсимволы регулярных выражений">Подраздел 9.7.3.3</a> (применим только к ARE; в ERE и BRE этому атому соответствует <em class="replaceable"><code>c</code></em>)</td></tr><tr><td> <code class="literal">{</code> </td><td>когда за этим символом следует любой символ, кроме цифры, этот атом соответствует левой фигурной скобке (<code class="literal">{</code>), если же за ним следует цифра, это обозначает начало <em class="replaceable"><code>границы</code></em> (см. ниже)</td></tr><tr><td> <em class="replaceable"><code>x</code></em> </td><td>(где <em class="replaceable"><code>x</code></em> — один символ, не имеющий специального значения) соответствует этому символу</td></tr></tbody></table></div></div><br class="table-break" /><p>Выражение RE не может заканчиваться обратной косой чертой (<code class="literal">\</code>).</p><div class="note"><h3 class="title">Примечание</h3><p>Если параметр <a class="xref" href="runtime-config-compatible.html#GUC-STANDARD-CONFORMING-STRINGS">standard_conforming_strings</a> выключен, каждый символ обратной косой черты, записываемый в текстовой константе, нужно дублировать. Подробнее это описано в <a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-STRINGS" title="4.1.2.1. Строковые константы">Подразделе 4.1.2.1</a>.</p></div><div class="table" id="POSIX-QUANTIFIERS-TABLE"><p class="title"><strong>Таблица 9.18. Определители количества в регулярных выражениях</strong></p><div class="table-contents"><table class="table" summary="Определители количества в регулярных выражениях" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Определитель</th><th>Соответствует</th></tr></thead><tbody><tr><td> <code class="literal">*</code> </td><td>0 или более вхождений атома</td></tr><tr><td> <code class="literal">+</code> </td><td>1 или более вхождений атома</td></tr><tr><td> <code class="literal">?</code> </td><td>0 или 1 вхождение атома</td></tr><tr><td> <code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">}</code> </td><td>ровно <em class="replaceable"><code>m</code></em> вхождений атома</td></tr><tr><td> <code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">,}</code> </td><td><em class="replaceable"><code>m</code></em> или более вхождений атома</td></tr><tr><td>
       <code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">,</code><em class="replaceable"><code>n</code></em><code class="literal">}</code> </td><td>от <em class="replaceable"><code>m</code></em> до <em class="replaceable"><code>n</code></em> (включая границы) вхождений атома; <em class="replaceable"><code>m</code></em> не может быть больше <em class="replaceable"><code>n</code></em></td></tr><tr><td> <code class="literal">*?</code> </td><td>не жадная версия <code class="literal">*</code></td></tr><tr><td> <code class="literal">+?</code> </td><td>не жадная версия <code class="literal">+</code></td></tr><tr><td> <code class="literal">??</code> </td><td>не жадная версия <code class="literal">?</code></td></tr><tr><td> <code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">}?</code> </td><td>не жадная версия <code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">}</code></td></tr><tr><td> <code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">,}?</code> </td><td>не жадная версия <code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">,}</code></td></tr><tr><td>
       <code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">,</code><em class="replaceable"><code>n</code></em><code class="literal">}?</code> </td><td>не жадная версия <code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">,</code><em class="replaceable"><code>n</code></em><code class="literal">}</code></td></tr></tbody></table></div></div><br class="table-break" /><p>В формах с <code class="literal">{</code><em class="replaceable"><code>...</code></em><code class="literal">}</code> числа <em class="replaceable"><code>m</code></em> и <em class="replaceable"><code>n</code></em> определяют так называемые <em class="firstterm">границы</em> количества. Эти числа должны быть беззнаковыми десятичными целыми в диапазоне от 0 до 255 включительно.</p><p><em class="firstterm">Не жадные</em> определители (допустимые только в ARE) описывают те же возможные соответствия, что и аналогичные им обычные («<em class="firstterm">жадные</em>»), но предпочитают выбирать наименьшее, а не наибольшее количество вхождений. Подробнее это описано в <a class="xref" href="functions-matching.html#POSIX-MATCHING-RULES" title="9.7.3.5. Правила соответствия регулярным выражениям">Подразделе 9.7.3.5</a>.</p><div class="note"><h3 class="title">Примечание</h3><p>Определители количества не могут следовать один за другим, например запись <code class="literal">**</code> будет ошибочной. Кроме того, определители не могут стоять в начале выражения или подвыражения и идти сразу после <code class="literal">^</code> или <code class="literal">|</code>.</p></div><div class="table" id="POSIX-CONSTRAINTS-TABLE"><p class="title"><strong>Таблица 9.19. Ограничения в регулярных выражениях</strong></p><div class="table-contents"><table class="table" summary="Ограничения в регулярных выражениях" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Ограничение</th><th>Описание</th></tr></thead><tbody><tr><td> <code class="literal">^</code> </td><td>соответствует началу строки</td></tr><tr><td> <code class="literal">$</code> </td><td>соответствует концу строки</td></tr><tr><td> <code class="literal">(?=</code><em class="replaceable"><code>re</code></em><code class="literal">)</code> </td><td><em class="firstterm">позитивный просмотр вперёд</em> находит соответствие там, где начинается подстрока, соответствующая <em class="replaceable"><code>re</code></em> (только для ARE)</td></tr><tr><td> <code class="literal">(?!</code><em class="replaceable"><code>re</code></em><code class="literal">)</code> </td><td><em class="firstterm">негативный просмотр вперёд</em> находит соответствие там, где не начинается подстрока, соответствующая <em class="replaceable"><code>re</code></em> (только для ARE)</td></tr><tr><td> <code class="literal">(?&lt;=</code><em class="replaceable"><code>re</code></em><code class="literal">)</code> </td><td><em class="firstterm">позитивный просмотр назад</em> находит соответствие там, где заканчивается подстрока, соответствующая <em class="replaceable"><code>re</code></em> (только для ARE)</td></tr><tr><td> <code class="literal">(?&lt;!</code><em class="replaceable"><code>re</code></em><code class="literal">)</code> </td><td><em class="firstterm">негативный просмотр назад</em> находит соответствие там, где не заканчивается подстрока, соответствующая <em class="replaceable"><code>re</code></em> (только для ARE)</td></tr></tbody></table></div></div><br class="table-break" /><p>Ограничения просмотра вперёд и назад не могут содержать <em class="firstterm">ссылки назад</em> (см. <a class="xref" href="functions-matching.html#POSIX-ESCAPE-SEQUENCES" title="9.7.3.3. Спецсимволы регулярных выражений">Подраздел 9.7.3.3</a>), и все скобки в них считаются «скобками без захвата».</p></div><div class="sect3" id="POSIX-BRACKET-EXPRESSIONS"><div class="titlepage"><div><div><h4 class="title">9.7.3.2. Выражения в квадратных скобках <a href="#POSIX-BRACKET-EXPRESSIONS" class="id_link">#</a></h4></div></div></div><p><em class="firstterm">Выражение в квадратных скобках</em> содержит список символов, заключённый в <code class="literal">[]</code>. Обычно ему соответствует любой символ из списка (об исключении написано ниже). Если список начинается с <code class="literal">^</code>, ему соответствует любой символ, который <span class="emphasis"><em>не</em></span> перечисляется далее в этом списке. Если два символа в списке разделяются знаком <code class="literal">-</code>, это воспринимается как краткая запись полного интервала символов между двумя заданными (и включая их) в порядке сортировки; например выражению <code class="literal">[0-9]</code> в <acronym class="acronym">ASCII</acronym> соответствует любая десятичная цифра. Два интервала не могут разделять одну границу, т. е. выражение <code class="literal">a-c-e</code> недопустимо. Интервалы зависят от порядка сортировки, который может меняться, поэтому в переносимых программах их лучше не использовать.</p><p>Чтобы включить в список <code class="literal">]</code>, этот символ нужно написать первым (сразу за <code class="literal">^</code>, если он присутствует). Чтобы включить в список символ <code class="literal">-</code>, его нужно написать первым или последним, либо как вторую границу интервала. Указать <code class="literal">-</code> в качестве первой границы интервал можно, заключив его между <code class="literal">[.</code> и <code class="literal">.]</code>, чтобы он стал элементом сортировки (см. ниже). За исключением этих символов, некоторых комбинаций с <code class="literal">[</code> (см. следующие абзацы) и спецсимволов (в ARE), все остальные специальные символы в квадратных скобках теряют своё особое значение. В частности, символ <code class="literal">\</code> по правилам ERE или BRE воспринимается как обычный, хотя в ARE он экранирует символ, следующий за ним.</p><p>Выражения в квадратных скобках могут содержать элемент сортировки (символ или последовательность символов или имя такой последовательности), определение которого заключается между <code class="literal">[.</code> и <code class="literal">.]</code>. Определяющая его последовательность воспринимается в выражении в скобках как один элемент. Это позволяет включать в такие выражения элементы, соответствующие последовательности нескольких символов. Например, с элементом сортировки <code class="literal">ch</code> в квадратных скобках регулярному выражению <code class="literal">[[.ch.]]*c</code> будут соответствовать первые пять символов строки <code class="literal">chchcc</code>.</p><div class="note"><h3 class="title">Примечание</h3><p>В настоящее время <span class="productname">PostgreSQL</span> не поддерживает элементы сортировки, состоящие из нескольких символов. Эта информация относится к возможному в будущем поведению.</p></div><p>В квадратных скобках могут содержаться элементы сортировки, заключённые между <code class="literal">[=</code> и <code class="literal">=]</code>, обозначающие <em class="firstterm">классы эквивалентности</em>, т. е. последовательности символов из всех элементов сортировки, эквивалентных указанному, включая его самого. (Если для этого символа нет эквивалентных, он обрабатывается как заключённый между <code class="literal">[.</code> и <code class="literal">.]</code>.) Например, если <code class="literal">е</code> и <code class="literal">ё</code> — члены одного класса эквивалентности, выражения <code class="literal">[[=е=]]</code>, <code class="literal">[[=ё=]]</code> и <code class="literal">[её]</code> будут равнозначными. Класс эквивалентности нельзя указать в качестве границы интервала.</p><p>В квадратных скобках может также задаваться имя класса символов, заключённое между <code class="literal">[:</code> и <code class="literal">:]</code>, которое обозначает множество всех символов, принадлежащих этому классу. Класс символов не может представлять границу интервала. В стандарте <acronym class="acronym">POSIX</acronym> определены следующие имена классов: <code class="literal">alnum</code> (буквы и цифры), <code class="literal">alpha</code> (буквы), <code class="literal">blank</code> (пробел и табуляция), <code class="literal">cntrl</code> (управляющие символы), <code class="literal">digit</code> (десятичные цифры), <code class="literal">graph</code> (печатаемые символы, кроме пробела), <code class="literal">lower</code> (буквы в нижнем регистре), <code class="literal">print</code> (печатаемые символы, включая пробел), <code class="literal">punct</code> (знаки пунктуации), <code class="literal">space</code> (любые пробельные символы), <code class="literal">upper</code> (буквы в верхнем регистре) и <code class="literal">xdigit</code> (шестнадцатеричные цифры). На согласованное поведение этих стандартных классов символов на разных платформах можно рассчитывать в рамках 7-битного набора ASCII. Будет ли определённый не ASCII-символ считаться принадлежащим одному из этих классов, зависит от правила сортировки, используемого оператором или функцией регулярных выражений (см. <a class="xref" href="collation.html" title="24.2. Поддержка правил сортировки">Раздел 24.2</a>). По умолчанию это правило определяется свойством <code class="envar">LC_CTYPE</code> базы данных (см. <a class="xref" href="locale.html" title="24.1. Поддержка языковых стандартов">Раздел 24.1</a>). Классификация не ASCII-символов может меняться от платформы к платформе даже при выборе локалей с похожими названиями. (Но локаль <code class="literal">C</code> никогда не относит не ASCII-символы ни к одному из этих классов.) Помимо этих стандартных классов символов, в <span class="productname">PostgreSQL</span> определён класс символов <code class="literal">word</code>, отличающийся от класса <code class="literal">alnum</code> лишь тем, что включает ещё символ подчёркивания (<code class="literal">_</code>), и класс символов <code class="literal">ascii</code>, который содержит все 7-битные символы ASCII, но не какие-либо другие.</p><p>Есть два особых вида выражений в квадратных скобках: выражения <code class="literal">[[:&lt;:]]</code> и <code class="literal">[[:&gt;:]]</code>, представляющие собой ограничения, соответствующие пустым строкам в начале и конце слова. Слово в данном контексте определяется как последовательность словосоставляющих символов, перед или после которой нет словосоставляющих символов. Словосоставляющий символ — это любой символ, принадлежащий классу <code class="literal">word</code>, то есть любая буква, цифра или подчёркивание. Это расширение совместимо со стандартом <acronym class="acronym">POSIX</acronym> 1003.2, но не описано в нём, и поэтому его следует использовать с осторожностью там, где важна совместимость с другими системами. Обычно лучше использовать ограничивающие спецсимволы, описанные ниже; они также не совсем стандартны, но набрать их легче.</p></div><div class="sect3" id="POSIX-ESCAPE-SEQUENCES"><div class="titlepage"><div><div><h4 class="title">9.7.3.3. Спецсимволы регулярных выражений <a href="#POSIX-ESCAPE-SEQUENCES" class="id_link">#</a></h4></div></div></div><p><em class="firstterm">Спецсимволы</em> — это специальные команды, состоящие из <code class="literal">\</code> и последующего алфавитно-цифрового символа. Можно выделить следующие категории спецсимволов: обозначения символов, коды классов, ограничения и ссылки назад. Символ <code class="literal">\</code>, за которым идёт алфавитно-цифровой символ, не образующий допустимый спецсимвол, считается ошибочным в ARE. В ERE спецсимволов нет: вне квадратных скобок пара из <code class="literal">\</code> и последующего алфавитно-цифрового символа, воспринимается просто как данный символ, а в квадратных скобках и сам символ <code class="literal">\</code> воспринимается просто как обратная косая черта. (Последнее на самом деле нарушает совместимость между ERE и ARE.)</p><p><em class="firstterm">Спецобозначения символов</em> введены для того, чтобы облегчить ввод в RE непечатаемых и других неудобных символов. Они приведены в <a class="xref" href="functions-matching.html#POSIX-CHARACTER-ENTRY-ESCAPES-TABLE" title="Таблица 9.20. Спецобозначения символов в регулярных выражениях">Таблице 9.20</a>.</p><p><em class="firstterm">Коды классов</em> представляют собой краткий способ записи имён некоторых распространённых классов символов. Они перечислены в <a class="xref" href="functions-matching.html#POSIX-CLASS-SHORTHAND-ESCAPES-TABLE" title="Таблица 9.21. Спецкоды классов в регулярных выражениях">Таблице 9.21</a>.</p><p><em class="firstterm">Спецсимволы ограничений</em> обозначают ограничения, которым при совпадении определённых условий соответствует пустая строка. Они перечислены в <a class="xref" href="functions-matching.html#POSIX-CONSTRAINT-ESCAPES-TABLE" title="Таблица 9.22. Спецсимволы ограничений в регулярных выражений">Таблице 9.22</a>.</p><p><em class="firstterm">Ссылка назад</em> (<code class="literal">\</code><em class="replaceable"><code>n</code></em>) соответствует той же строке, какой соответствовало предыдущее подвыражение в скобках под номером <em class="replaceable"><code>n</code></em> (см. <a class="xref" href="functions-matching.html#POSIX-CONSTRAINT-BACKREF-TABLE" title="Таблица 9.23. Ссылки назад в регулярных выражениях">Таблицу 9.23</a>). Например, <code class="literal">([bc])\1</code> соответствует <code class="literal">bb</code> или <code class="literal">cc</code>, но не <code class="literal">bc</code> или <code class="literal">cb</code>. Это подвыражение должно полностью предшествовать ссылке назад в RE. Нумеруются подвыражения в порядке следования их открывающих скобок. При этом скобки без захвата исключаются из рассмотрения. Ссылка назад учитывает только строковые символы, совпадающие с указанным подвыражением, но не содержащиеся в нём ограничения. Например, выражению <code class="literal">(^\d)\1</code> будет соответствовать <code class="literal">22</code>).</p><div class="table" id="POSIX-CHARACTER-ENTRY-ESCAPES-TABLE"><p class="title"><strong>Таблица 9.20. Спецобозначения символов в регулярных выражениях</strong></p><div class="table-contents"><table class="table" summary="Спецобозначения символов в регулярных выражениях" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Спецсимвол</th><th>Описание</th></tr></thead><tbody><tr><td> <code class="literal">\a</code> </td><td>символ звонка, как в C</td></tr><tr><td> <code class="literal">\b</code> </td><td>символ «забой», как в C</td></tr><tr><td> <code class="literal">\B</code> </td><td>синоним для обратной косой черты (<code class="literal">\</code>), сокращающий потребность в дублировании этого символа</td></tr><tr><td> <code class="literal">\c</code><em class="replaceable"><code>X</code></em> </td><td>(где <em class="replaceable"><code>X</code></em> — любой символ) символ, младшие 5 бит которого те же, что и у <em class="replaceable"><code>X</code></em>, а остальные равны 0</td></tr><tr><td> <code class="literal">\e</code> </td><td>символ, определённый в последовательности сортировки с именем <code class="literal">ESC</code>, либо, если таковой не определён, символ с восьмеричным значением <code class="literal">033</code></td></tr><tr><td> <code class="literal">\f</code> </td><td>подача формы, как в C</td></tr><tr><td> <code class="literal">\n</code> </td><td>новая строка, как в C</td></tr><tr><td> <code class="literal">\r</code> </td><td>возврат каретки, как в C</td></tr><tr><td> <code class="literal">\t</code> </td><td>горизонтальная табуляция, как в C</td></tr><tr><td> <code class="literal">\u</code><em class="replaceable"><code>wxyz</code></em> </td><td>(где <em class="replaceable"><code>wxyz</code></em> ровно четыре шестнадцатеричные цифры) символ с шестнадцатеричным кодом <code class="literal">0x</code><em class="replaceable"><code>wxyz</code></em></td></tr><tr><td> <code class="literal">\U</code><em class="replaceable"><code>stuvwxyz</code></em> </td><td>(где <em class="replaceable"><code>stuvwxyz</code></em> ровно восемь шестнадцатеричных цифр) символ с шестнадцатеричным кодом <code class="literal">0x</code><em class="replaceable"><code>stuvwxyz</code></em></td></tr><tr><td> <code class="literal">\v</code> </td><td>вертикальная табуляция, как в C</td></tr><tr><td> <code class="literal">\x</code><em class="replaceable"><code>hhh</code></em> </td><td>(где <em class="replaceable"><code>hhh</code></em> — несколько шестнадцатеричных цифр) символ с шестнадцатеричным кодом <code class="literal">0x</code><em class="replaceable"><code>hhh</code></em> (символ всегда один вне зависимости от числа шестнадцатеричных цифр)</td></tr><tr><td> <code class="literal">\0</code> </td><td>символ с кодом <code class="literal">0</code> (нулевой байт)</td></tr><tr><td> <code class="literal">\</code><em class="replaceable"><code>xy</code></em> </td><td>(где <em class="replaceable"><code>xy</code></em> — ровно две восьмеричных цифры, не <em class="firstterm">ссылка назад</em>) символ с восьмеричным кодом <code class="literal">0</code><em class="replaceable"><code>xy</code></em></td></tr><tr><td> <code class="literal">\</code><em class="replaceable"><code>xyz</code></em> </td><td>(где <em class="replaceable"><code>xyz</code></em> — ровно три восьмеричных цифры, не <em class="firstterm">ссылка назад</em>) символ с восьмеричным кодом <code class="literal">0</code><em class="replaceable"><code>xyz</code></em></td></tr></tbody></table></div></div><br class="table-break" /><p>Шестнадцатеричные цифры записываются символами <code class="literal">0</code>-<code class="literal">9</code> и <code class="literal">a</code>-<code class="literal">f</code> или <code class="literal">A</code>-<code class="literal">F</code>. Восьмеричные цифры — цифры от <code class="literal">0</code> до <code class="literal">7</code>.</p><p>Спецпоследовательности с числовыми кодами, задающими значения вне диапазона ASCII (0–127), воспринимаются по-разному в зависимости от кодировки базы данных. Когда база данных имеет кодировку UTF-8, спецкод равнозначен позиции символа в Unicode, например, <code class="literal">\u1234</code> обозначает символ <code class="literal">U+1234</code>. Для других многобайтных кодировок спецпоследовательности обычно просто задают серию байт, определяющих символ. Если в кодировке базы данных отсутствует символ, заданный спецпоследовательностью, ошибки не будет, но и никакие данные не будут ей соответствовать.</p><p>Символы, переданные спецобозначением, всегда воспринимаются как обычные символы. Например, <code class="literal">\135</code> кодирует <code class="literal">]</code> в ASCII, но спецпоследовательность <code class="literal">\135</code> не будет закрывать выражение в квадратных скобках.</p><div class="table" id="POSIX-CLASS-SHORTHAND-ESCAPES-TABLE"><p class="title"><strong>Таблица 9.21. Спецкоды классов в регулярных выражениях</strong></p><div class="table-contents"><table class="table" summary="Спецкоды классов в регулярных выражениях" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Спецсимвол</th><th>Описание</th></tr></thead><tbody><tr><td> <code class="literal">\d</code> </td><td>соответствует любой цифре; равнозначно <code class="literal">[[:digit:]]</code></td></tr><tr><td> <code class="literal">\s</code> </td><td>соответствует любому пробельному символу; равнозначно <code class="literal">[[:space:]]</code></td></tr><tr><td> <code class="literal">\w</code> </td><td>соответствует любому буквенному символу; равнозначно <code class="literal">[[:word:]]</code></td></tr><tr><td> <code class="literal">\D</code> </td><td>соответствует любому нецифровому символу; равнозначно <code class="literal">[^[:digit:]]</code></td></tr><tr><td> <code class="literal">\S</code> </td><td>соответствует любому непробельному символу; равнозначно <code class="literal">[^[:space:]]</code></td></tr><tr><td> <code class="literal">\W</code> </td><td>соответствует любому небуквенному символу; равнозначно <code class="literal">[^[:word:]]</code></td></tr></tbody></table></div></div><br class="table-break" /><p>Коды классов также работают в выражениях в квадратных скобках, хотя определения, показанные выше, не совсем синтаксически верны в данном контексте. Например, выражение <code class="literal">[a-c\d]</code> равнозначно <code class="literal"> [a-c[:digit:]]</code>.</p><div class="table" id="POSIX-CONSTRAINT-ESCAPES-TABLE"><p class="title"><strong>Таблица 9.22. Спецсимволы ограничений в регулярных выражений</strong></p><div class="table-contents"><table class="table" summary="Спецсимволы ограничений в регулярных выражений" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Спецсимвол</th><th>Описание</th></tr></thead><tbody><tr><td> <code class="literal">\A</code> </td><td>соответствует только началу строки (чем это отличается от <code class="literal">^</code>, описано в <a class="xref" href="functions-matching.html#POSIX-MATCHING-RULES" title="9.7.3.5. Правила соответствия регулярным выражениям">Подразделе 9.7.3.5</a>)</td></tr><tr><td> <code class="literal">\m</code> </td><td>соответствует только началу слова</td></tr><tr><td> <code class="literal">\M</code> </td><td>соответствует только концу слова</td></tr><tr><td> <code class="literal">\y</code> </td><td>соответствует только началу или концу слова</td></tr><tr><td> <code class="literal">\Y</code> </td><td>соответствует только положению не в начале и не в конце слова</td></tr><tr><td> <code class="literal">\Z</code> </td><td>соответствует только концу строки (чем это отличается от <code class="literal">$</code>, описано в <a class="xref" href="functions-matching.html#POSIX-MATCHING-RULES" title="9.7.3.5. Правила соответствия регулярным выражениям">Подразделе 9.7.3.5</a>)</td></tr></tbody></table></div></div><br class="table-break" /><p>Определением слова здесь служит то же, что было приведено выше в описании <code class="literal">[[:&lt;:]]</code> и <code class="literal">[[:&gt;:]]</code>. В квадратных скобках спецсимволы ограничений не допускаются.</p><div class="table" id="POSIX-CONSTRAINT-BACKREF-TABLE"><p class="title"><strong>Таблица 9.23. Ссылки назад в регулярных выражениях</strong></p><div class="table-contents"><table class="table" summary="Ссылки назад в регулярных выражениях" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Спецсимвол</th><th>Описание</th></tr></thead><tbody><tr><td> <code class="literal">\</code><em class="replaceable"><code>m</code></em> </td><td>(где <em class="replaceable"><code>m</code></em> — цифра, отличная от 0) — ссылка назад на подвыражение под номером <em class="replaceable"><code>m</code></em></td></tr><tr><td> <code class="literal">\</code><em class="replaceable"><code>mnn</code></em> </td><td>(где <em class="replaceable"><code>m</code></em> — цифра, отличная от 0, а <em class="replaceable"><code>nn</code></em> — ещё несколько цифр с десятичным значением <em class="replaceable"><code>mnn</code></em>, не превышающим число закрытых до этого скобок с захватом) ссылка назад на подвыражение под номером <em class="replaceable"><code>mnn</code></em></td></tr></tbody></table></div></div><br class="table-break" /><div class="note"><h3 class="title">Примечание</h3><p>Регулярным выражениям присуща неоднозначность между восьмеричными кодами символов и ссылками назад, которая разрешается следующим образом (это упоминалось выше). Ведущий ноль всегда считается признаком восьмеричной последовательности. Единственная цифра, отличная от 0, за которой не следует ещё одна цифра, всегда воспринимается как ссылка назад. Последовательность из нескольких цифр, которая начинается не с 0, воспринимается как ссылка назад, если она идёт за подходящим подвыражением (т. е. число оказывается в диапазоне, допустимом для ссылки назад), в противном случае она воспринимается как восьмеричное число.</p></div></div><div class="sect3" id="POSIX-METASYNTAX"><div class="titlepage"><div><div><h4 class="title">9.7.3.4. Метасинтаксис регулярных выражений <a href="#POSIX-METASYNTAX" class="id_link">#</a></h4></div></div></div><p>В дополнение к основному синтаксису, описанному выше, можно использовать также несколько особых форм и разнообразные синтаксические удобства.</p><p>Регулярное выражение может начинаться с одного из двух специальных префиксов режима. Если RE начинается с <code class="literal">***:</code>, его продолжение рассматривается как ARE. (В <span class="productname">PostgreSQL</span> это обычно не имеет значения, так как регулярные выражения воспринимаются как ARE по умолчанию; но это может быть полезно, когда параметр <em class="replaceable"><code>флаги</code></em> функций regex включает режим ERE или BRE.) Если RE начинается с <code class="literal">***=</code>, его продолжение воспринимается как обычная текстовая строка, все его символы воспринимаются буквально.</p><p>ARE может начинаться со <em class="firstterm">встроенных параметров</em>: последовательности <code class="literal">(?</code><em class="replaceable"><code>xyz</code></em><code class="literal">)</code> (где <em class="replaceable"><code>xyz</code></em> — один или несколько алфавитно-цифровых символов), определяющих параметры остального регулярного выражения. Эти параметры переопределяют любые ранее определённые параметры, в частности они могут переопределить режим чувствительности к регистру, подразумеваемый для оператора regex, или параметр <em class="replaceable"><code>флаги</code></em> функции regex. Допустимые буквы параметров показаны в <a class="xref" href="functions-matching.html#POSIX-EMBEDDED-OPTIONS-TABLE" title="Таблица 9.24. Буквы встроенных параметров ARE">Таблице 9.24</a>. Заметьте, что те же буквы используются в параметре <em class="replaceable"><code>флаги</code></em> функций regex.</p><div class="table" id="POSIX-EMBEDDED-OPTIONS-TABLE"><p class="title"><strong>Таблица 9.24. Буквы встроенных параметров ARE</strong></p><div class="table-contents"><table class="table" summary="Буквы встроенных параметров ARE" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Параметр</th><th>Описание</th></tr></thead><tbody><tr><td> <code class="literal">b</code> </td><td>продолжение регулярного выражения — BRE</td></tr><tr><td> <code class="literal">c</code> </td><td>поиск соответствий с учётом регистра (переопределяет тип оператора)</td></tr><tr><td> <code class="literal">e</code> </td><td>продолжение RE — ERE</td></tr><tr><td> <code class="literal">i</code> </td><td>поиск соответствий без учёта регистра (см. <a class="xref" href="functions-matching.html#POSIX-MATCHING-RULES" title="9.7.3.5. Правила соответствия регулярным выражениям">Подраздел 9.7.3.5</a>) (переопределяет тип оператора)</td></tr><tr><td> <code class="literal">m</code> </td><td>исторически сложившийся синоним <code class="literal">n</code></td></tr><tr><td> <code class="literal">n</code> </td><td>поиск соответствий с учётом перевода строк (см. <a class="xref" href="functions-matching.html#POSIX-MATCHING-RULES" title="9.7.3.5. Правила соответствия регулярным выражениям">Подраздел 9.7.3.5</a>)</td></tr><tr><td> <code class="literal">p</code> </td><td>переводы строк учитываются частично (см. <a class="xref" href="functions-matching.html#POSIX-MATCHING-RULES" title="9.7.3.5. Правила соответствия регулярным выражениям">Подраздел 9.7.3.5</a>)</td></tr><tr><td> <code class="literal">q</code> </td><td>продолжение регулярного выражения — обычная строка (<span class="quote">«<span class="quote">в кавычках</span>»</span>), содержимое которой воспринимается буквально</td></tr><tr><td> <code class="literal">s</code> </td><td>поиск соответствий без учёта перевода строк (по умолчанию)</td></tr><tr><td> <code class="literal">t</code> </td><td>компактный синтаксис (по умолчанию; см. ниже)</td></tr><tr><td> <code class="literal">w</code> </td><td>переводы строк учитываются частично, но в другом, <span class="quote">«<span class="quote">странном</span>»</span> режиме (см. <a class="xref" href="functions-matching.html#POSIX-MATCHING-RULES" title="9.7.3.5. Правила соответствия регулярным выражениям">Подраздел 9.7.3.5</a>)</td></tr><tr><td> <code class="literal">x</code> </td><td>развёрнутый синтаксис (см. ниже)</td></tr></tbody></table></div></div><br class="table-break" /><p>Внедрённые параметры начинают действовать сразу после скобки <code class="literal">)</code>, завершающей их последовательность. Они могут находиться только в начале ARE (после указания <code class="literal">***:</code>, если оно присутствует).</p><p>Помимо обычного (<em class="firstterm">компактного</em>) синтаксиса RE, в котором имеют значение все символы, поддерживается также <em class="firstterm">развёрнутый</em> синтаксис, включить который можно с помощью встроенного параметра <code class="literal">x</code>. В развёрнутом синтаксисе игнорируются пробельные символы, а также все символы от <code class="literal">#</code> до конца строки (или конца RE). Это позволяет разделять RE на строки и добавлять в него комментарии. Но есть три исключения: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>пробельный символ или <code class="literal">#</code>, за которым следует <code class="literal">\</code>, сохраняется</p></li><li class="listitem"><p>пробельный символ или <code class="literal">#</code> внутри выражения в квадратных скобках сохраняется</p></li><li class="listitem"><p>пробельные символы и комментарии не могут присутствовать в составных символах, например, в <code class="literal">(?:</code></p></li></ul></div><p> В данном контексте пробельными символами считаются пробел, табуляция, перевод строки и любой другой символ, относящийся к классу символов <em class="replaceable"><code>space</code></em>.</p><p>И наконец, в ARE последовательность <code class="literal">(?#</code><em class="replaceable"><code>ttt</code></em><code class="literal">)</code> (где <em class="replaceable"><code>ttt</code></em> — любой текст, не содержащий <code class="literal">)</code>) вне квадратных скобок также считается комментарием и полностью игнорируется. При этом она так же не может находиться внутри составных символов, таких как <code class="literal">(?:</code>. Эти комментарии в большей степени историческое наследие, чем полезное средство; они считаются устаревшими, а вместо них рекомендуется использовать развёрнутый синтаксис.</p><p><span class="emphasis"><em>Ни одно</em></span> из этих расширений метасинтаксиса не будет работать, если выражение начинается с префикса <code class="literal">***=</code>, после которого строка воспринимается буквально, а не как RE.</p></div><div class="sect3" id="POSIX-MATCHING-RULES"><div class="titlepage"><div><div><h4 class="title">9.7.3.5. Правила соответствия регулярным выражениям <a href="#POSIX-MATCHING-RULES" class="id_link">#</a></h4></div></div></div><p>В случае, когда RE может соответствовать более чем одной подстроке в заданной строке, соответствующей RE считается подстрока, которая начинается в ней первой. Если к данной позиции подобных соответствующих подстрок оказывается несколько, из них выбирается либо самая длинная, либо самая короткая из возможных, в зависимости от того, какой режим выбран в RE: <em class="firstterm">жадный</em> или <em class="firstterm">не жадный</em>.</p><p>Где жадный или не жадный характер RE определяется по следующим правилам: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Большинство атомов и все ограничения не имеют признака жадности (так как они всё равно не могут соответствовать подстрокам разного состава).</p></li><li class="listitem"><p>Скобки, окружающие RE, не влияют на его «жадность».</p></li><li class="listitem"><p>Атом с определителем фиксированного количества (<code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">}</code> или <code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">}?</code>) имеет ту же характеристику жадности (или может не иметь её), как и сам атом.</p></li><li class="listitem"><p>Атом с другими обычными определителями количества (включая <code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">,</code><em class="replaceable"><code>n</code></em><code class="literal">}</code>, где <em class="replaceable"><code>m</code></em> равняется <em class="replaceable"><code>n</code></em>) считается жадным (предпочитает соответствие максимальной длины).</p></li><li class="listitem"><p>Атом с не жадным определителем количества (включая <code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">,</code><em class="replaceable"><code>n</code></em><code class="literal">}?</code>, где <em class="replaceable"><code>m</code></em> равно <em class="replaceable"><code>n</code></em>) считается не жадным (предпочитает соответствие минимальной длины).</p></li><li class="listitem"><p>Ветвь (RE без оператора <code class="literal">|</code> на верхнем уровне) имеет ту же характеристику жадности, что и первый количественный атом в нём, имеющий атрибут жадности.</p></li><li class="listitem"><p>RE, образованное из двух или более ветвей, соединённых оператором <code class="literal">|</code>, всегда считается жадным.</p></li></ul></div><p>Эти правила связывают характеристики жадности не только с отдельными количественными атомами, но и с ветвями и целыми RE, содержащими количественные атомы. Это означает, что при сопоставлении ветвь или целое RE может соответствовать максимально длинной или короткой подстроке <span class="emphasis"><em>в целом</em></span>. Когда определена длина всего соответствия, часть его, соответствующая конкретному подвыражению, определяется с учётом характеристики жадности для этого подвыражения, при этом подвыражения, начинающиеся в RE раньше, имеют больший приоритет, чем следующие за ними.</p><p>Это иллюстрирует следующий пример: </p><pre class="screen">
SELECT SUBSTRING('XY1234Z', 'Y*([0-9]{1,3})');
<em class="lineannotation"><span class="lineannotation">Результат: </span></em><code class="computeroutput">123</code>
SELECT SUBSTRING('XY1234Z', 'Y*?([0-9]{1,3})');
<em class="lineannotation"><span class="lineannotation">Результат: </span></em><code class="computeroutput">1</code>
</pre><p> В первом случае RE в целом жадное, так как жадным является атом <code class="literal">Y*</code>. Соответствие ему начинается с буквы <code class="literal">Y</code> и оно включает подстроку максимальной длины с этого места, т. е. подстроку <code class="literal">Y123</code>. Результат выражения — её часть, соответствующая подвыражению в скобках, т. е. <code class="literal">123</code>. Во втором случае, RE в целом наследует не жадный характер от атома <code class="literal">Y*?</code>. Соответствие ему так же начинается с <code class="literal">Y</code>, но включает оно подстроку минимальной длины с этого места, т. е. <code class="literal">Y1</code>. И хотя подвыражение <code class="literal">[0-9]{1,3}</code> имеет жадный характер, оно не может повлиять на выбор длины соответствия в целом, поэтому ему остаётся только подстрока <code class="literal">1</code>.</p><p>Другими словами, когда RE содержит и жадные, и не жадные подвыражения, всё соответствие будет максимально длинным или коротким в зависимости от характеристики всего RE. Характеристики, связанные с подвыражениями, влияют только на то, какую часть подстроки может <span class="quote">«<span class="quote">поглотить</span>»</span> одно подвыражение относительно другого.</p><p>Чтобы явно придать характеристику «жадности» или «нежадности» подвыражению или всему RE, можно использовать определители <code class="literal">{1,1}</code> и <code class="literal">{1,1}?</code>, соответственно. Это полезно, когда вам нужно, чтобы общая характеристика жадности RE отличалась от той, что вытекает из его элементов. Например, предположим, что вы пытаетесь выделить из строки, содержащей несколько цифр, эти цифры и части до и после них. Можно попытаться сделать это так: </p><pre class="screen">
SELECT regexp_match('abc01234xyz', '(.*)(\d+)(.*)');
<em class="lineannotation"><span class="lineannotation">Результат: </span></em><code class="computeroutput">{abc0123,4,xyz}</code>
</pre><p> Но это не будет работать: первая группа <code class="literal">.*</code> — «жадная», она <span class="quote">«<span class="quote">съест</span>»</span> всё, что сможет, оставляя для соответствия <code class="literal">\d+</code> только последнюю возможность, то есть последнюю цифру. Можно попытаться сделать запрос «нежадным»: </p><pre class="screen">
SELECT regexp_match('abc01234xyz', '(.*?)(\d+)(.*)');
<em class="lineannotation"><span class="lineannotation">Результат: </span></em><code class="computeroutput">{abc,0,""}</code>
</pre><p> И это не будет работать, так теперь весь RE в целом стал нежадным, и все соответствия завершаются как можно раньше. Но мы можем получить нужный результат, явно сделав жадным всё RE: </p><pre class="screen">
SELECT regexp_match('abc01234xyz', '(?:(.*?)(\d+)(.*)){1,1}');
<em class="lineannotation"><span class="lineannotation">Результат: </span></em><code class="computeroutput">{abc,01234,xyz}</code>
</pre><p> Управление общей характеристикой «жадности» RE независимо от «жадности» его компонентов даёт большую гибкость в описании шаблонов переменной длины.</p><p>При определении более длинного или более короткого соответствия длины соответствий определяются в символах, а не в элементах сортировки. Пустая строка считается длиннее, чем отсутствие соответствия. Например, выражению <code class="literal">bb*</code> соответствуют три символа в середине строки <code class="literal">abbbc</code>, выражению <code class="literal">(week|wee)(night|knights)</code> — все десять символов <code class="literal">weeknights</code>; когда выражение <code class="literal">(.*).*</code> сопоставляется со строкой <code class="literal">abc</code>, подвыражению в скобках соответствуют все три символа; а когда <code class="literal">(a*)*</code> сопоставляется со строкой <code class="literal">bc</code>, то и RE в целом, и подстроке в скобках соответствует пустая строка.</p><p>Игнорирование регистра символов даёт практически тот же эффект, как если бы в алфавите исчезли различия прописных и строчных букв. Если буква, существующая и в верхнем, и в нижнем регистре, фигурирует вне квадратных скобок как обычный символ, она по сути преобразуется в выражение в квадратных скобках, содержащее оба варианта, например <code class="literal">x</code> становится <code class="literal">[xX]</code>. Если же она фигурирует в выражении в квадратных скобках, в это выражение добавляются все её варианты, например <code class="literal">[x]</code> становится <code class="literal">[xX]</code>, а <code class="literal">[^x]</code> — <code class="literal">[^xX]</code>.</p><p>Когда включён многострочный режим поиска, атом <code class="literal">.</code> и выражения в квадратных скобках с <code class="literal">^</code> никогда не будут соответствовать символам конца строки (так что соответствия никогда не будут пересекать границы строк, если в RE нет явных указаний на эти символы), а <code class="literal">^</code> и <code class="literal">$</code> будут соответствовать пустой подстроке не только в начале и конце всего текста, но и в начале и конце каждой отдельной его строки. Однако спецсимволы ARE <code class="literal">\A</code> и <code class="literal">\Z</code> по-прежнему будут соответствовать <span class="emphasis"><em>только</em></span> началу и концу всего текста. Кроме того, коды классов символов <code class="literal">\D</code> и <code class="literal">\W</code> будут соответствовать концам строк независимо от этого режима. (До <span class="productname">PostgreSQL</span> 14 они не соответствовали концам строк в многострочном режиме. Для использования старого поведения напишите <code class="literal">[^[:digit:]]</code> или <code class="literal">[^[:word:]]</code>.)</p><p>В режиме, когда переводы строк учитываются частично, особый смысл перевод строк имеет для атома <code class="literal">.</code> и выражений в квадратных скобках, но не для <code class="literal">^</code> и <code class="literal">$</code>.</p><p>В обратном частичном режиме, перевод строк имеет особый смысл для <code class="literal">^</code> и <code class="literal">$</code>, как и в режиме с учётом перевода строк, но не для <code class="literal">.</code> и выражений в квадратных скобках. Данный режим не очень полезен, но существует для симметрии.</p></div><div class="sect3" id="POSIX-LIMITS-COMPATIBILITY"><div class="titlepage"><div><div><h4 class="title">9.7.3.6. Пределы и совместимость <a href="#POSIX-LIMITS-COMPATIBILITY" class="id_link">#</a></h4></div></div></div><p>В текущей реализации отсутствует какой-либо явно заданный предел длины RE. Однако, разрабатывая программы высокой степени переносимости, не следует применять RE длиннее 256 байт, так как другая POSIX-совместимая реализация может отказаться обрабатывать такие регулярные выражения.</p><p>Единственная особенность ARE, действительно несовместимая с ERE стандарта POSIX проявляется в том, что в ARE знак <code class="literal">\</code> не теряет своё специальное значение в квадратных скобках. Все другие расширения ARE используют синтаксические возможности, которые не определены, не допустимы или не поддерживаются в ERE; синтаксис переключения режимов (<code class="literal">***</code>) также выходит за рамки синтаксиса POSIX как для BRE, так и для ERE.</p><p>Многие расширения ARE заимствованы из языка Perl, но некоторые были изменены, оптимизированы, а несколько расширений Perl были исключены. В результате имеют место следующие несовместимости: атомы <code class="literal">\b</code> и <code class="literal">\B</code>, отсутствие специальной обработки завершающего перевода строки, добавление исключений в квадратных скобках в число случаев, когда учитывается перевод строк, особые условия для скобок и ссылок назад в ограничениях просмотра вперёд/назад и семантика <span class="quote">«<span class="quote">наиболее длинное/короткое соответствие</span>»</span> (вместо <span class="quote">«<span class="quote">первое соответствие</span>»</span>).</p></div><div class="sect3" id="POSIX-BASIC-REGEXES"><div class="titlepage"><div><div><h4 class="title">9.7.3.7. Простые регулярные выражения <a href="#POSIX-BASIC-REGEXES" class="id_link">#</a></h4></div></div></div><p>BRE имеют ряд отличий от ERE. В BRE знаки <code class="literal">|</code>, <code class="literal">+</code> и <code class="literal">?</code> теряют специальное значение, а замены им нет. Границы количества окружаются символами <code class="literal">\{</code> и <code class="literal">\}</code>, тогда как <code class="literal">{</code> и <code class="literal">}</code> рассматриваются как обычные символы. Вложенные подвыражения помещаются между <code class="literal">\(</code> и <code class="literal">\)</code>, а <code class="literal">(</code> и <code class="literal">)</code> представляют обычные символы. Символ <code class="literal">^</code> воспринимается как обычный, если только он не находится в начале RE или подвыражения в скобках, <code class="literal">$</code> — тоже обычный символ, если он находится не в конце RE или в конце подвыражения в скобках, и <code class="literal">*</code> — обычный символ, когда он находится в начале RE или подвыражения в скобках (возможно, после начального <code class="literal">^</code>). И, наконец, в BRE работают ссылки назад с одной цифрой, <code class="literal">\&lt;</code> и <code class="literal">\&gt;</code> — синонимы для <code class="literal">[[:&lt;:]]</code> и <code class="literal">[[:&gt;:]]</code>, соответственно; никакие другие спецсимволы в BRE не поддерживаются.</p></div><div class="sect3" id="POSIX-VS-XQUERY"><div class="titlepage"><div><div><h4 class="title">9.7.3.8. Отличия от XQuery и стандарта SQL <a href="#POSIX-VS-XQUERY" class="id_link">#</a></h4></div></div></div><a id="id-1.5.8.13.9.48.2" class="indexterm"></a><a id="id-1.5.8.13.9.48.3" class="indexterm"></a><a id="id-1.5.8.13.9.48.4" class="indexterm"></a><a id="id-1.5.8.13.9.48.5" class="indexterm"></a><a id="id-1.5.8.13.9.48.6" class="indexterm"></a><a id="id-1.5.8.13.9.48.7" class="indexterm"></a><p>Начиная с SQL:2008, в стандарт SQL входят операторы и функции регулярных выражений, которые выполняют сопоставление с шаблоном в соответствии со стандартом регулярных выражений XQuery: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">LIKE_REGEX</code></p></li><li class="listitem"><p><code class="literal">OCCURRENCES_REGEX</code></p></li><li class="listitem"><p><code class="literal">POSITION_REGEX</code></p></li><li class="listitem"><p><code class="literal">SUBSTRING_REGEX</code></p></li><li class="listitem"><p><code class="literal">TRANSLATE_REGEX</code></p></li></ul></div><p> В <span class="productname">PostgreSQL</span> эти операторы и функции на данный момент не реализованы. Но вы можете в каждом случае получить примерно тот же результат, как показано в <a class="xref" href="functions-matching.html#FUNCTIONS-REGEXP-SQL-TABLE" title="Таблица 9.25. Аналоги функций регулярных выражений">Таблице 9.25</a>. (В этой таблице опущены различные необязательные предложения с обеих сторон.)</p><div class="table" id="FUNCTIONS-REGEXP-SQL-TABLE"><p class="title"><strong>Таблица 9.25. Аналоги функций регулярных выражений</strong></p><div class="table-contents"><table class="table" summary="Аналоги функций регулярных выражений" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Стандарт SQL</th><th><span class="productname">PostgreSQL</span></th></tr></thead><tbody><tr><td><code class="literal"><em class="replaceable"><code>строка</code></em> LIKE_REGEX <em class="replaceable"><code>шаблон</code></em></code></td><td><code class="literal">regexp_like(<em class="replaceable"><code>строка</code></em>, <em class="replaceable"><code>шаблон</code></em>)</code> или <code class="literal"><em class="replaceable"><code>строка</code></em> ~ <em class="replaceable"><code>шаблон</code></em></code></td></tr><tr><td><code class="literal">OCCURRENCES_REGEX(<em class="replaceable"><code>шаблон</code></em> IN <em class="replaceable"><code>строка</code></em>)</code></td><td><code class="literal">regexp_count(<em class="replaceable"><code>строка</code></em>, <em class="replaceable"><code>шаблон</code></em>)</code></td></tr><tr><td><code class="literal">POSITION_REGEX(<em class="replaceable"><code>шаблон</code></em> IN <em class="replaceable"><code>строка</code></em>)</code></td><td><code class="literal">regexp_instr(<em class="replaceable"><code>строка</code></em>, <em class="replaceable"><code>шаблон</code></em>)</code></td></tr><tr><td><code class="literal">SUBSTRING_REGEX(<em class="replaceable"><code>шаблон</code></em> IN <em class="replaceable"><code>строка</code></em>)</code></td><td><code class="literal">regexp_substr(<em class="replaceable"><code>строка</code></em>, <em class="replaceable"><code>шаблон</code></em>)</code></td></tr><tr><td><code class="literal">TRANSLATE_REGEX(<em class="replaceable"><code>шаблон</code></em> IN <em class="replaceable"><code>строка</code></em> WITH <em class="replaceable"><code>замена</code></em>)</code></td><td><code class="literal">regexp_replace(<em class="replaceable"><code>строка</code></em>, <em class="replaceable"><code>шаблон</code></em>, <em class="replaceable"><code>замена</code></em>)</code></td></tr></tbody></table></div></div><br class="table-break" /><p>Функции регулярных выражений, подобные существующим в PostgreSQL, также имеются в ряде других реализаций SQL, в то время как функции стандарта SQL распространены не так широко. Некоторые детали синтаксиса регулярных выражений, скорее всего, будут различаться в каждой реализации.</p><p>В функциях и операторах стандарта SQL используются регулярные выражения XQuery, синтаксис которых похож на ARE, описанный выше. Регулярные выражения на базе POSIX в существующей реализации и регулярные выражения XQuery имеют ряд заметных отличий, в том числе: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Вычитание классов символов XQuery не поддерживается. Например, это вычитание позволяет извлекать только английские согласные так: <code class="literal">[a-z-[aeiou]]</code>.</p></li><li class="listitem"><p>Коды классов символов XQuery <code class="literal">\c</code>, <code class="literal">\C</code>, <code class="literal">\i</code> и <code class="literal">\I</code> не поддерживаются.</p></li><li class="listitem"><p>Элементы классов символов XQuery с обозначением <code class="literal">\p{UnicodeProperty}</code> или обратным, <code class="literal">\P{UnicodeProperty}</code>, не поддерживаются.</p></li><li class="listitem"><p>В POSIX классы символов, такие как <code class="literal">\w</code> (см. <a class="xref" href="functions-matching.html#POSIX-CLASS-SHORTHAND-ESCAPES-TABLE" title="Таблица 9.21. Спецкоды классов в регулярных выражениях">Таблицу 9.21</a>), интерпретируются согласно текущей локали (и вы можете управлять этим, добавив предложение <code class="literal">COLLATE</code> к оператору или вызову функции). В XQuery эти классы определяются по свойствам символов Unicode, поэтому одинаковое поведение возможно только с локалями, соответствующими требованиям Unicode.</p></li><li class="listitem"><p>Синтаксис стандарта SQL (не сам язык XQuery) стремится воспринять больше вариантов <span class="quote">«<span class="quote">перевода строки</span>»</span>, чем синтаксис POSIX. Для описанных выше вариантов сопоставления с учётом перевода строк переводом строки считается только символ ASCII NL (<code class="literal">\n</code>), тогда как SQL считает переводом строки также CR (<code class="literal">\r</code>), CRLF (<code class="literal">\r\n</code>) (перевод строки в стиле Windows) и некоторые присущие только Unicode символы, например, LINE SEPARATOR (U+2028). Стоит заметить, что согласно SQL коды шаблона <code class="literal">.</code> и <code class="literal">\s</code> должны считать последовательность <code class="literal">\r\n</code> одним символом, а не двумя.</p></li><li class="listitem"><p>Из спецкодов, определяющих символы, описанных в <a class="xref" href="functions-matching.html#POSIX-CHARACTER-ENTRY-ESCAPES-TABLE" title="Таблица 9.20. Спецобозначения символов в регулярных выражениях">Таблице 9.20</a>, XQuery поддерживает только <code class="literal">\n</code>, <code class="literal">\r</code> и <code class="literal">\t</code>.</p></li><li class="listitem"><p>XQuery не поддерживает синтаксис <code class="literal">[:<em class="replaceable"><code>имя</code></em>:]</code> для указания класса символов в квадратных скобках.</p></li><li class="listitem"><p>В XQuery отсутствуют условия с просмотром вперёд и назад, а также не поддерживаются спецсимволы ограничений, описанные в <a class="xref" href="functions-matching.html#POSIX-CONSTRAINT-ESCAPES-TABLE" title="Таблица 9.22. Спецсимволы ограничений в регулярных выражений">Таблице 9.22</a>.</p></li><li class="listitem"><p>Формы метасинтаксиса, описанные в <a class="xref" href="functions-matching.html#POSIX-METASYNTAX" title="9.7.3.4. Метасинтаксис регулярных выражений">Подразделе 9.7.3.4</a>, в XQuery не существуют.</p></li><li class="listitem"><p>Буквы флагов регулярных выражений, определённые в XQuery, имеют общее с буквами флагов в POSIX (см. <a class="xref" href="functions-matching.html#POSIX-EMBEDDED-OPTIONS-TABLE" title="Таблица 9.24. Буквы встроенных параметров ARE">Таблицу 9.24</a>), но не равнозначны им. Одинаково ведут себя только флаги <code class="literal">i</code> и <code class="literal">q</code>, а все остальные различаются: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>Флаги XQuery <code class="literal">s</code> (допускающий сопоставление точки с переводом строки) и <code class="literal">m</code> (допускающий сопоставление <code class="literal">^</code> и <code class="literal">$</code> с переводами строк) позволяют получить то же поведение, что и флаги <code class="literal">n</code>, <code class="literal">p</code> и <code class="literal">w</code> в POSIX, но они <span class="emphasis"><em>не</em></span> равнозначны флагам POSIX <code class="literal">s</code> и <code class="literal">m</code>. В частности, заметьте, что по умолчанию точка соответствует переводу строки в POSIX, но не в XQuery.</p></li><li class="listitem"><p>Флаг <code class="literal">x</code> (игнорировать пробельные символы в шаблоне) в XQuery значительно отличается от флага расширенного режима POSIX. В POSIX флаг <code class="literal">x</code> дополнительно позволяет написать комментарий в шаблоне (начиная с символа <code class="literal">#</code>), а пробельный символ после обратной косой черты не игнорируется.</p></li></ul></div></li></ul></div></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="functions-bitstring.html" title="9.6. Функции и операторы для работы с битовыми строками">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="functions.html" title="Глава 9. Функции и операторы">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="functions-formatting.html" title="9.8. Функции форматирования данных">След.</a></td></tr><tr><td width="40%" align="left" valign="top">9.6. Функции и операторы для работы с битовыми строками </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 9.8. Функции форматирования данных</td></tr></table></div></body></html>