<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>43.3. Объявления</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="plpgsql-structure.html" title="43.2. Структура PL/pgSQL" /><link rel="next" href="plpgsql-expressions.html" title="43.4. Выражения" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">43.3. Объявления</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="plpgsql-structure.html" title="43.2. Структура PL/pgSQL">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="plpgsql.html" title="Глава 43. PL/pgSQL — процедурный язык SQL">Наверх</a></td><th width="60%" align="center">Глава 43. <span class="application">PL/pgSQL</span> — процедурный язык <acronym class="acronym">SQL</acronym></th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="plpgsql-expressions.html" title="43.4. Выражения">След.</a></td></tr></table><hr /></div><div class="sect1" id="PLPGSQL-DECLARATIONS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">43.3. Объявления <a href="#PLPGSQL-DECLARATIONS" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="plpgsql-declarations.html#PLPGSQL-DECLARATION-PARAMETERS">43.3.1. Объявление параметров функции</a></span></dt><dt><span class="sect2"><a href="plpgsql-declarations.html#PLPGSQL-DECLARATION-ALIAS">43.3.2. <code class="literal">ALIAS</code></a></span></dt><dt><span class="sect2"><a href="plpgsql-declarations.html#PLPGSQL-DECLARATION-TYPE">43.3.3. Наследование типов данных</a></span></dt><dt><span class="sect2"><a href="plpgsql-declarations.html#PLPGSQL-DECLARATION-ROWTYPES">43.3.4. Типы кортежей</a></span></dt><dt><span class="sect2"><a href="plpgsql-declarations.html#PLPGSQL-DECLARATION-RECORDS">43.3.5. Тип <code class="type">record</code></a></span></dt><dt><span class="sect2"><a href="plpgsql-declarations.html#PLPGSQL-DECLARATION-COLLATION">43.3.6. Упорядочение переменных <span class="application">PL/pgSQL</span></a></span></dt></dl></div><p>Все переменные, используемые в блоке, должны быть определены в секции объявления. (За исключением переменной-счётчика цикла <code class="literal">FOR</code>, которая объявляется автоматически. Для цикла по диапазону чисел автоматически объявляется целочисленная переменная, а для цикла по результатам курсора - переменная типа <code class="literal">record</code>.)</p><p>Переменные <span class="application">PL/pgSQL</span> могут иметь любой тип данных SQL, такой как <code class="type">integer</code>, <code class="type">varchar</code>, <code class="type">char</code>.</p><p>Примеры объявления переменных: </p><pre class="programlisting">user_id integer;
quantity numeric(5);
url varchar;
myrow tablename%ROWTYPE;
myfield tablename.columnname%TYPE;
arow RECORD;</pre><p>Общий синтаксис объявления переменной: </p><pre class="synopsis">
<em class="replaceable"><code>имя</code></em> [<span class="optional"> CONSTANT </span>] <em class="replaceable"><code>тип</code></em> [<span class="optional"> COLLATE <em class="replaceable"><code>имя_правила_сортировки</code></em> </span>] [<span class="optional"> NOT NULL </span>] [<span class="optional"> { DEFAULT | := | = } <em class="replaceable"><code>выражение</code></em> </span>];
</pre><p> Предложение <code class="literal">DEFAULT</code>, если присутствует, задаёт начальное значение, которое присваивается переменной при входе в блок. Если отсутствует, то переменная инициализируется <acronym class="acronym">SQL</acronym>-значением <code class="literal">NULL</code>. Указание <code class="literal">CONSTANT</code> предотвращает изменение значения переменной после инициализации, таким образом, значение остаётся постоянным в течение всего блока. Параметр <code class="literal">COLLATE</code> определяет правило сортировки, которое будет использоваться для этой переменной (см. <a class="xref" href="plpgsql-declarations.html#PLPGSQL-DECLARATION-COLLATION" title="43.3.6. Упорядочение переменных PL/pgSQL">Подраздел 43.3.6</a>). Если указано <code class="literal">NOT NULL</code>, то попытка присвоить <code class="literal">NULL</code> во время выполнения приведёт к ошибке. Все переменные, объявленные как <code class="literal">NOT NULL</code>, должны иметь непустые значения по умолчанию. Можно использовать знак равенства (<code class="literal">=</code>) вместо совместимого с PL/SQL <code class="literal">:=</code>.</p><p>Значение по умолчанию вычисляется и присваивается переменной каждый раз при входе в блок (не только при первом вызове функции). Так, например, если переменная типа <code class="type">timestamp</code> имеет функцию <code class="literal">now()</code> в качестве значения по умолчанию, это приведёт к тому, что переменная всегда будет содержать время текущего вызова функции, а не время, когда функция была предварительно скомпилирована.</p><p>Примеры: </p><pre class="programlisting">quantity integer DEFAULT 32;
url varchar := 'http://mysite.com';
transaction_time CONSTANT timestamp with time zone := now();</pre><p>После объявления переменной её значение можно использовать в последующих выражениях инициализации в этом же блоке, например: </p><pre class="programlisting">DECLARE
  x integer := 1;
  y integer := x + 1;</pre><div class="sect2" id="PLPGSQL-DECLARATION-PARAMETERS"><div class="titlepage"><div><div><h3 class="title">43.3.1. Объявление параметров функции <a href="#PLPGSQL-DECLARATION-PARAMETERS" class="id_link">#</a></h3></div></div></div><p>Переданные в функцию параметры именуются идентификаторами <code class="literal">$1</code>, <code class="literal">$2</code> и т. д. Дополнительно, для улучшения читаемости, можно объявить псевдонимы для параметров <code class="literal">$<em class="replaceable"><code>n</code></em></code>. Либо псевдоним, либо цифровой идентификатор используются для обозначения параметра.</p><p>Создать псевдоним можно двумя способами. Предпочтительный способ это дать имя параметру в команде <code class="command">CREATE FUNCTION</code>, например: </p><pre class="programlisting">CREATE FUNCTION sales_tax(subtotal real) RETURNS real AS $$
BEGIN
    RETURN subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;</pre><p> Другой способ это явное объявление псевдонима при помощи синтаксиса: </p><pre class="synopsis">
<em class="replaceable"><code>имя</code></em> ALIAS FOR $<em class="replaceable"><code>n</code></em>;
</pre><p> Предыдущий пример для этого стиля выглядит так: </p><pre class="programlisting">CREATE FUNCTION sales_tax(real) RETURNS real AS $$
DECLARE
    subtotal ALIAS FOR $1;
BEGIN
    RETURN subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;</pre><div class="note"><h3 class="title">Примечание</h3><p>Эти два примера не полностью эквивалентны. В первом случае на <code class="literal">subtotal</code> можно ссылаться как <code class="literal">sales_tax.subtotal</code>, а во втором случае такая ссылка невозможна. (Если бы к внутреннему блоку была добавлена метка, то <code class="literal">subtotal</code> можно было бы дополнить этой меткой.)</p></div><p>Ещё несколько примеров: </p><pre class="programlisting">CREATE FUNCTION instr(varchar, integer) RETURNS integer AS $$
DECLARE
    v_string ALIAS FOR $1;
    index ALIAS FOR $2;
BEGIN
    -- вычисления, использующие v_string и index
END;
$$ LANGUAGE plpgsql;


CREATE FUNCTION concat_selected_fields(in_t sometablename) RETURNS text AS $$
BEGIN
    RETURN in_t.f1 || in_t.f3 || in_t.f5 || in_t.f7;
END;
$$ LANGUAGE plpgsql;</pre><p>Когда функция на <span class="application">PL/pgSQL</span> объявляется с выходными параметрами, им выдаются цифровые идентификаторы <code class="literal">$<em class="replaceable"><code>n</code></em></code> и для них можно создавать псевдонимы точно таким же способом, как и для обычных входных параметров. Выходной параметр это фактически переменная, стартующая с NULL и которой присваивается значение во время выполнения функции. Возвращается последнее присвоенное значение. Например, функция sales_tax может быть переписана так: </p><pre class="programlisting">CREATE FUNCTION sales_tax(subtotal real, OUT tax real) AS $$
BEGIN
    tax := subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;</pre><p> Обратите внимание, что мы опустили <code class="literal">RETURNS real</code> — хотя можно было и включить, но это было бы излишним.</p><p>Чтобы вызвать функцию с параметрами <code class="literal">OUT</code>, при вызове функции не указывайте выходные параметры: </p><pre class="programlisting">SELECT sales_tax(100.00);</pre><p>Выходные параметры наиболее полезны для возвращения нескольких значений. Простейший пример: </p><pre class="programlisting">CREATE FUNCTION sum_n_product(x int, y int, OUT sum int, OUT prod int) AS $$
BEGIN
    sum := x + y;
    prod := x * y;
END;
$$ LANGUAGE plpgsql;

SELECT * FROM sum_n_product(2, 4);
 sum | prod
-----+------
   6 |    8</pre><p> Как обсуждалось в <a class="xref" href="xfunc-sql.html#XFUNC-OUTPUT-PARAMETERS" title="38.5.4. Функции SQL с выходными параметрами">Подразделе 38.5.4</a>, здесь фактически создаётся анонимный тип <code class="literal">record</code> для возвращения результата функции. Если используется предложение <code class="literal">RETURNS</code>, то оно должно выглядеть как <code class="literal">RETURNS record</code>.</p><p>Выходные параметры поддерживаются и в процедурах, например: </p><pre class="programlisting">CREATE PROCEDURE sum_n_product(x int, y int, OUT sum int, OUT prod int) AS $$
BEGIN
    sum := x + y;
    prod := x * y;
END;
$$ LANGUAGE plpgsql;</pre><p> При вызове процедуры нужно указать все параметры. Вызывая процедуру на чистом SQL, вместо выходных параметров можно указать <code class="literal">NULL</code>: </p><pre class="programlisting">CALL sum_n_product(2, 4, NULL, NULL);
 sum | prod
-----+------
   6 |    8</pre><p> Однако в вызове процедуры из <span class="application">PL/pgSQL</span> для каждого выходного параметра нужно указать переменную; эта переменная будет получать результат вызова. За подробностями обратитесь к <a class="xref" href="plpgsql-control-structures.html#PLPGSQL-STATEMENTS-CALLING-PROCEDURE" title="43.6.3. Вызов процедуры">Подразделу 43.6.3</a>.</p><p>Есть ещё способ объявить функцию на <span class="application">PL/pgSQL</span> с использованием <code class="literal">RETURNS TABLE</code>, например: </p><pre class="programlisting">CREATE FUNCTION extended_sales(p_itemno int)
RETURNS TABLE(quantity int, total numeric) AS $$
BEGIN
    RETURN QUERY SELECT s.quantity, s.quantity * s.price FROM sales s
                 WHERE s.itemno = p_itemno;
END;
$$ LANGUAGE plpgsql;</pre><p> Это в точности соответствует объявлению одного или нескольких параметров <code class="literal">OUT</code> и указанию <code class="literal">RETURNS SETOF <em class="replaceable"><code>некий_тип</code></em></code>.</p><p>Для функции на <span class="application">PL/pgSQL</span>, возвращающей полиморфный тип (см. <a class="xref" href="extend-type-system.html#EXTEND-TYPES-POLYMORPHIC" title="38.2.5. Полиморфные типы">Подраздел 38.2.5</a>), создаётся специальный параметр <code class="literal">$0</code>. Его тип данных соответствует типу, фактически возвращаемому функцией, который устанавливается на основании фактических типов входных параметров. Это позволяет функции обращаться к фактически возвращаемому типу данных, как показано в <a class="xref" href="plpgsql-declarations.html#PLPGSQL-DECLARATION-TYPE" title="43.3.3. Наследование типов данных">Подразделе 43.3.3</a>. Параметр <code class="literal">$0</code> инициализируется в <code class="literal">NULL</code> и его можно изменять внутри функции. Таким образом, его можно использовать для хранения возвращаемого значения, хотя это необязательно. Параметру <code class="literal">$0</code> можно дать псевдоним. В следующем примере функция работает с любым типом данных, поддерживающим оператор <code class="literal">+</code>: </p><pre class="programlisting">CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement)
RETURNS anyelement AS $$
DECLARE
    result ALIAS FOR $0;
BEGIN
    result := v1 + v2 + v3;
    RETURN result;
END;
$$ LANGUAGE plpgsql;</pre><p>Такой же эффект получается при объявлении одного или нескольких выходных параметров полиморфного типа. При этом <code class="literal">$0</code> не создаётся; выходные параметры сами используются для этой цели. Например: </p><pre class="programlisting">CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement,
                                 OUT sum anyelement)
AS $$
BEGIN
    sum := v1 + v2 + v3;
END;
$$ LANGUAGE plpgsql;</pre><p>На практике может быть полезнее объявить полиморфную функцию, используя семейство типов <code class="type">anycompatible</code>, чтобы входные аргументы автоматически сводились к общему типу. Например: </p><pre class="programlisting">CREATE FUNCTION add_three_values(v1 anycompatible, v2 anycompatible, v3 anycompatible)
RETURNS anycompatible AS $$
BEGIN
    RETURN v1 + v2 + v3;
END;
$$ LANGUAGE plpgsql;</pre><p> Показанная функция позволяет выполнить такой вызов: </p><pre class="programlisting">SELECT add_three_values(1, 2, 4.7);</pre><p> В данном случае целочисленные аргументы будут автоматически приведены к numeric. В функции же, использующей <code class="type">anyelement</code>, вам нужно было бы преобразовать все три аргумента к одному вручную.</p></div><div class="sect2" id="PLPGSQL-DECLARATION-ALIAS"><div class="titlepage"><div><div><h3 class="title">43.3.2. <code class="literal">ALIAS</code> <a href="#PLPGSQL-DECLARATION-ALIAS" class="id_link">#</a></h3></div></div></div><pre class="synopsis"><em class="replaceable"><code>новое_имя</code></em> ALIAS FOR <em class="replaceable"><code>старое_имя</code></em>;</pre><p>Синтаксис <code class="literal">ALIAS</code> более общий, чем предполагалось в предыдущем разделе: псевдонимы можно объявлять для любых переменных, а не только для параметров функции. Основная практическая польза в том, чтобы назначить другие имена переменным с предопределёнными названиями, таким как <code class="varname">NEW</code> или <code class="varname">OLD</code> в триггерной функции.</p><p>Примеры: </p><pre class="programlisting">DECLARE
  prior ALIAS FOR old;
  updated ALIAS FOR new;</pre><p>Поскольку <code class="literal">ALIAS</code> даёт два различных способа именования одних и тех же объектов, то его неограниченное использование может привести к путанице. Лучше всего использовать <code class="literal">ALIAS</code> для переименования предопределённых имён.</p></div><div class="sect2" id="PLPGSQL-DECLARATION-TYPE"><div class="titlepage"><div><div><h3 class="title">43.3.3. Наследование типов данных <a href="#PLPGSQL-DECLARATION-TYPE" class="id_link">#</a></h3></div></div></div><pre class="synopsis"><em class="replaceable"><code>переменная</code></em>%TYPE</pre><p>Конструкция <code class="literal">%TYPE</code> предоставляет тип данных переменной или столбца таблицы. Её можно использовать для объявления переменных, содержащих значения из базы данных. Например, для объявления переменной с таким же типом, как и столбец <code class="literal">user_id</code> в таблице <code class="literal">users</code> нужно написать: </p><pre class="programlisting">user_id users.user_id%TYPE;</pre><p>Используя <code class="literal">%TYPE</code>, не нужно знать тип данных структуры, на которую вы ссылаетесь. И самое главное, если в будущем тип данных изменится (например: тип данных для <code class="literal">user_id</code> поменяется с <code class="type">integer</code> на <code class="type">real</code>), то вам может не понадобиться изменять определение функции.</p><p>Использование <code class="literal">%TYPE</code> особенно полезно в полиморфных функциях, поскольку типы данных, необходимые для внутренних переменных, могут меняться от одного вызова к другому. Соответствующие переменные могут быть созданы с применением <code class="literal">%TYPE</code> к аргументам и возвращаемому значению функции.</p></div><div class="sect2" id="PLPGSQL-DECLARATION-ROWTYPES"><div class="titlepage"><div><div><h3 class="title">43.3.4. Типы кортежей <a href="#PLPGSQL-DECLARATION-ROWTYPES" class="id_link">#</a></h3></div></div></div><pre class="synopsis"><em class="replaceable"><code>имя</code></em> <em class="replaceable"><code>имя_таблицы</code></em><code class="literal">%ROWTYPE</code>;
<em class="replaceable"><code>имя</code></em> <em class="replaceable"><code>имя_составного_типа</code></em>;</pre><p>Переменная составного типа называется <em class="firstterm">переменной-кортежем</em> (или переменной <em class="firstterm">типа кортежа</em>). Значением такой переменной может быть целый кортеж, полученный в результате выполнения запроса <code class="command">SELECT</code> или <code class="command">FOR</code>, при условии, что набор столбцов запроса соответствует заявленному типу переменной. Доступ к отдельным полям значения кортежа осуществляется как обычно, через точку, например <code class="literal">rowvar.field</code>.</p><p>Переменная-кортеж может быть объявлена с таким же типом, как и строка в существующей таблице или представлении, используя нотацию <em class="replaceable"><code>имя_таблицы</code></em><code class="literal">%ROWTYPE</code>; или с именем составного типа. (Поскольку каждая таблица имеет соответствующий составной тип с таким же именем, то на самом деле в <span class="productname">PostgreSQL</span> не имеет значения, пишете ли вы <code class="literal">%ROWTYPE</code> или нет. Но использование <code class="literal">%ROWTYPE</code> более переносимо.)</p><p>Параметры функции могут быть составного типа (строки таблицы). В этом случае соответствующий идентификатор <code class="literal">$<em class="replaceable"><code>n</code></em></code> будет переменной-кортежем, поля которой можно выбирать, например <code class="literal">$1.user_id</code>.</p><p>Ниже приведён пример использования составных типов. <code class="structname">table1</code> и <code class="structname">table2</code> это существующие таблицы, имеющие, по меньшей мере, перечисленные столбцы: </p><pre class="programlisting">CREATE FUNCTION merge_fields(t_row table1) RETURNS text AS $$
DECLARE
    t2_row table2%ROWTYPE;
BEGIN
    SELECT * INTO t2_row FROM table2 WHERE ... ;
    RETURN t_row.f1 || t2_row.f3 || t_row.f5 || t2_row.f7;
END;
$$ LANGUAGE plpgsql;

SELECT merge_fields(t.*) FROM table1 t WHERE ... ;</pre></div><div class="sect2" id="PLPGSQL-DECLARATION-RECORDS"><div class="titlepage"><div><div><h3 class="title">43.3.5. Тип <code class="type">record</code> <a href="#PLPGSQL-DECLARATION-RECORDS" class="id_link">#</a></h3></div></div></div><pre class="synopsis"><em class="replaceable"><code>имя</code></em> RECORD;</pre><p>Переменные типа <code class="type">record</code> похожи на переменные-кортежи, но они не имеют предопределённой структуры. Они приобретают фактическую структуру от строки, которая им присваивается командами <code class="command">SELECT</code> или <code class="command">FOR</code>. Структура переменной типа <code class="type">record</code> может меняться каждый раз при присваивании значения. Следствием этого является то, что пока значение не присвоено первый раз, переменная типа <code class="type">record</code> не имеет структуры и любая попытка получить доступ к отдельному полю приведёт к ошибке во время выполнения.</p><p>Обратите внимание, что <code class="literal">RECORD</code> это не подлинный тип данных, а только лишь заполнитель. Также следует понимать, что функция на <span class="application">PL/pgSQL</span>, имеющая тип возвращаемого значения <code class="type">record</code>, это не то же самое, что и переменная типа <code class="type">record</code>, хотя такая функция может использовать переменную типа <code class="type">record</code> для хранения своего результата. В обоих случаях фактическая структура строки неизвестна во время создания функции, но для функции, возвращающей <code class="type">record</code>, фактическая структура определяется во время разбора вызывающего запроса, в то время как переменная типа <code class="type">record</code> может менять свою структуру на лету.</p></div><div class="sect2" id="PLPGSQL-DECLARATION-COLLATION"><div class="titlepage"><div><div><h3 class="title">43.3.6. Упорядочение переменных <span class="application">PL/pgSQL</span> <a href="#PLPGSQL-DECLARATION-COLLATION" class="id_link">#</a></h3></div></div></div><a id="id-1.8.8.5.14.2" class="indexterm"></a><p>Когда функция на <span class="application">PL/pgSQL</span> имеет один или несколько параметров сортируемых типов данных, правило сортировки определяется при каждом вызове функции в зависимости от правил сортировки фактических аргументов, как описано в <a class="xref" href="collation.html" title="24.2. Поддержка правил сортировки">Разделе 24.2</a>. Если оно определено успешно (т. е. среди аргументов нет конфликтов между неявными правилами сортировки), то все соответствующие параметры неявно трактуются как имеющее это правило сортировки. Внутри функции это будет влиять на поведение операторов, зависящих от используемого правила сортировки. Рассмотрим пример: </p><pre class="programlisting">CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$
BEGIN
    RETURN a &lt; b;
END;
$$ LANGUAGE plpgsql;

SELECT less_than(text_field_1, text_field_2) FROM table1;
SELECT less_than(text_field_1, text_field_2 COLLATE "C") FROM table1;</pre><p> В первом случае <code class="function">less_than</code> будет использовать для сравнения общее правило сортировки для <code class="structfield">text_field_1</code> и <code class="structfield">text_field_2</code>, в то время как во втором случае будет использоваться правило <code class="literal">C</code>.</p><p>Кроме того, определённое для вызова функции правило сортировки также будет использоваться для любых локальных переменных соответствующего типа. Таким образом, функция не станет работать по-другому, если её переписать так: </p><pre class="programlisting">CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$
DECLARE
    local_a text := a;
    local_b text := b;
BEGIN
    RETURN local_a &lt; local_b;
END;
$$ LANGUAGE plpgsql;</pre><p>Если параметров с типами данных, поддерживающими сортировку, нет, или для параметров невозможно определить общее правило сортировки, тогда для параметров и локальных переменных применяются правила, принятые для их типа данных по умолчанию (которые обычно совпадают с правилами сортировки по умолчанию, принятыми для базы данных, но могут отличаться для переменных доменных типов).</p><p>Локальная переменная может иметь правило сортировки, отличное от правила по умолчанию. Для этого используется параметр <code class="literal">COLLATE</code> в объявлении переменной, например: </p><pre class="programlisting">DECLARE
    local_a text COLLATE "en_US";</pre><p> Этот параметр переопределяет правило сортировки, которое получила бы переменная в соответствии с вышеуказанными правилами.</p><p>И, конечно же, можно явно указывать параметр <code class="literal">COLLATE</code> для конкретных операций внутри функции, если к ним требуется применить конкретное правило сортировки. Например: </p><pre class="programlisting">CREATE FUNCTION less_than_c(a text, b text) RETURNS boolean AS $$
BEGIN
    RETURN a &lt; b COLLATE "C";
END;
$$ LANGUAGE plpgsql;</pre><p> Как и в обычной SQL-команде, это переопределяет правила сортировки, связанные с полями таблицы, параметрами и локальными переменными, которые используются в данном выражении.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="plpgsql-structure.html" title="43.2. Структура PL/pgSQL">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="plpgsql.html" title="Глава 43. PL/pgSQL — процедурный язык SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="plpgsql-expressions.html" title="43.4. Выражения">След.</a></td></tr><tr><td width="40%" align="left" valign="top">43.2. Структура <span class="application">PL/pgSQL</span> </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 43.4. Выражения</td></tr></table></div></body></html>