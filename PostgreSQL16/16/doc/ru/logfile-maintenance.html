<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>25.3. Обслуживание журнала</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="routine-reindex.html" title="25.2. Регулярная переиндексация" /><link rel="next" href="backup.html" title="Глава 26. Резервное копирование и восстановление" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">25.3. Обслуживание журнала</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="routine-reindex.html" title="25.2. Регулярная переиндексация">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="maintenance.html" title="Глава 25. Регламентные задачи обслуживания базы данных">Наверх</a></td><th width="60%" align="center">Глава 25. Регламентные задачи обслуживания базы данных</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="backup.html" title="Глава 26. Резервное копирование и восстановление">След.</a></td></tr></table><hr /></div><div class="sect1" id="LOGFILE-MAINTENANCE"><div class="titlepage"><div><div><h2 class="title" style="clear: both">25.3. Обслуживание журнала <a href="#LOGFILE-MAINTENANCE" class="id_link">#</a></h2></div></div></div><a id="id-1.6.12.12.2" class="indexterm"></a><p>Журнал сервера базы данных желательно сохранять где-либо, а не просто сбрасывать его в <code class="filename">/dev/null</code>. Этот журнал бесценен при диагностике проблем.</p><div class="note"><h3 class="title">Примечание</h3><p>Журнал сервера может содержать конфиденциальную информацию и должен быть защищён, где бы он ни хранился и куда бы ни передавался. Например, операторы DDL могут содержать незашифрованные пароли или другие данные аутентификации. В операторах, выводимых на уровне <code class="literal">ERROR</code>, может отображаться исходный код SQL для приложений, а также могут содержаться фрагменты строк данных. Так как журнал собственно предназначен для записи данных, событий и связанной с ними информации, это не является уязвимостью или дефектом. Вам следует позаботиться о том, чтобы к журналам сервера получали доступ только лица с соответствующими полномочиями.</p></div><p>Журнал сервера может быть очень объёмным (особенно при высоких уровнях отладки), так что хранить его неограниченно долго вы вряд ли захотите. Поэтому необходимо организовать <span class="emphasis"><em>ротацию</em></span> журнальных файлов так, чтобы новые файлы создавались, а старые удалялись через разумный промежуток времени.</p><p>Если просто направить <span class="systemitem">stderr</span> команды <code class="command">postgres</code> в файл, вы получите в нём журнал сообщений, но очистить этот файл можно будет, только если остановить и перезапустить сервер. Это может быть допустимо при использовании <span class="productname">PostgreSQL</span> в среде разработки, но вряд ли такой вариант будет приемлемым в производственной среде.</p><p>Лучшим подходом будет перенаправление вывода сервера <span class="systemitem">stderr</span> в какую-либо программу ротации журнальных файлов. Существует и встроенное средство ротации журнальных файлов, которое можно использовать, установив для параметра <code class="varname">logging_collector</code> значение <code class="literal">true</code> в <code class="filename">postgresql.conf</code>. Параметры, управляющие этой программой, описаны в <a class="xref" href="runtime-config-logging.html#RUNTIME-CONFIG-LOGGING-WHERE" title="20.8.1. Куда протоколировать">Подразделе 20.8.1</a>. Этот подход также можно использовать для получения содержимого журнала в формате <acronym class="acronym">CSV</acronym> (значения, разделённые запятыми).</p><p>Вы также можете использовать внешнюю программу для ротации журнальных файлов, если уже применяете такое приложение для других серверных приложений. Например, утилиту <span class="application">rotatelogs</span>, включённую в дистрибутив <span class="productname">Apache</span>, можно использовать и с <span class="productname">PostgreSQL</span>. Один из вариантов — направить вывод <span class="systemitem">stderr</span> сервера в желаемую программу. Если вы запускаете сервер, используя <code class="command">pg_ctl</code>, то <span class="systemitem">stderr</span> уже будет перенаправлен в <span class="systemitem">stdout</span>, так что будет достаточно просто применить конвейер, например: </p><pre class="programlisting">pg_ctl start | rotatelogs /var/log/pgsql_log 86400</pre><p>Вы можете скомбинировать эти подходы, настроив программу <span class="application">logrotate</span> так, чтобы она собирала файлы журналов, которые записывает встроенный в <span class="productname">PostgreSQL</span> сборщик сообщений. В этом случае имена и расположение файлов журналов определяет сборщик сообщений, а <span class="application">logrotate</span> периодически архивирует эти файлы. Когда <span class="application">logrotate</span> производит ротацию журналов, важно, чтобы приложение выводило дальнейшие сообщения в новый файл. Обычно это делает скрипт <code class="literal">postrotate</code>, передающий сигнал <code class="literal">SIGHUP</code> приложению, которое в свою очередь заново открывает файл журнала. В <span class="productname">PostgreSQL</span> вместо этого вы можете выполнить <code class="command">pg_ctl</code> с указанием <code class="literal">logrotate</code>. Когда выполняется эта команда, сервер либо переключается на новый файл журнала, либо заново открывает существующий, в зависимости от конфигурации журналирования (см. <a class="xref" href="runtime-config-logging.html#RUNTIME-CONFIG-LOGGING-WHERE" title="20.8.1. Куда протоколировать">Подраздел 20.8.1</a>).</p><div class="note"><h3 class="title">Примечание</h3><p>Когда используются статические имена файлов журналов, сервер может столкнуться с ошибкой при открытии файла, если будет достигнуто ограничение на максимальное число открытых файлов или переполнится таблица файлов. В этом случае сообщения будут продолжать выводиться в старый журнал пока не произойдёт успешное переключение. Если программа <span class="application">logrotate</span> сжимает файл журнала и затем удаляет его, сообщения сервера, выводимые в этом интервале времени, могут быть потеряны. Чтобы избежать этого, можно сделать так, чтобы сборщик сообщений выбирал динамические имена файлов, а скрипт <code class="literal">prerotate</code> игнорировал открытые файлы журналов.</p></div><p>Ещё одно решение промышленного уровня заключается в передаче журнала в <span class="application">syslog</span>, чтобы ротацией файлов занималась уже служба <span class="application">syslog</span>. Для этого присвойте параметру конфигурации <code class="varname">log_destination</code> значение <code class="literal">syslog</code> (для вывода журнала только в <span class="application">syslog</span>) в <code class="filename">postgresql.conf</code>. Затем вы сможете посылать сигнал <code class="literal">SIGHUP</code> службе <span class="application">syslog</span>, когда захотите принудительно начать запись нового журнального файла. Если вы хотите автоматизировать ротацию журнальных файлов, программу <span class="application">logrotate</span> можно настроить и для работы с журнальными файлами, которые формирует <span class="application">syslog</span>.</p><p>Однако во многих системах, а особенно c большими сообщениями, <span class="application">syslog</span> работает не очень надёжно; он может обрезать или терять сообщения как раз тогда, когда они вам нужны. Кроме того, в <span class="productname">Linux</span>, <span class="application">syslog</span>&gt; сбрасывает каждое сообщение на диск, от чего страдает производительность. (Для отключения этой синхронной записи можно добавить <span class="quote">«<span class="quote"><code class="literal">-</code></span>»</span> перед именем файла в файле конфигурации <span class="application">syslog</span>.)</p><p>Обратите внимание, что все описанные выше решения обеспечивают создание новых журнальных файлов через задаваемые промежутки времени, но не удаление старых, ставших бесполезными файлов журналов. Возможно, вы захотите создать задание для периодического удаления старых файлов. Кроме того, вы можете настроить программу ротации файлов так, чтобы старые файлы журналов циклически перезаписывались.</p><p>Также вам может быть полезен <a class="ulink" href="https://pgbadger.darold.net/" target="_top"><span class="productname">pgBadger</span></a> — инструмент для сложного анализа файлов журнала. Кроме того, <a class="ulink" href="https://bucardo.org/check_postgres/" target="_top"><span class="productname">check_postgres</span></a> может посылать уведомления в Nagios, когда в журнале появляются важные сообщения, а также при обнаружении других нестандартных ситуаций.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="routine-reindex.html" title="25.2. Регулярная переиндексация">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="maintenance.html" title="Глава 25. Регламентные задачи обслуживания базы данных">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="backup.html" title="Глава 26. Резервное копирование и восстановление">След.</a></td></tr><tr><td width="40%" align="left" valign="top">25.2. Регулярная переиндексация </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> Глава 26. Резервное копирование и восстановление</td></tr></table></div></body></html>