<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>2.6. Соединения таблиц</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="tutorial-select.html" title="2.5. Выполнение запроса" /><link rel="next" href="tutorial-agg.html" title="2.7. Агрегатные функции" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">2.6. Соединения таблиц</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="tutorial-select.html" title="2.5. Выполнение запроса">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="tutorial-sql.html" title="Глава 2. Язык SQL">Наверх</a></td><th width="60%" align="center">Глава 2. Язык <acronym class="acronym">SQL</acronym></th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="tutorial-agg.html" title="2.7. Агрегатные функции">След.</a></td></tr></table><hr /></div><div class="sect1" id="TUTORIAL-JOIN"><div class="titlepage"><div><div><h2 class="title" style="clear: both">2.6. Соединения таблиц <a href="#TUTORIAL-JOIN" class="id_link">#</a></h2></div></div></div><a id="id-1.4.4.7.2" class="indexterm"></a><p>До этого все наши запросы обращались только к одной таблице. Однако запросы могут также обращаться сразу к нескольким таблицам или обращаться к той же таблице так, что одновременно будут обрабатываться разные наборы её строк. Запросы, обращающиеся к разным таблицам (или нескольким экземплярам одной таблицы), называются <em class="firstterm">соединениями</em> (JOIN). Такие запросы содержат выражение, указывающее, какие строки одной таблицы нужно объединить со строками другой таблицы. Например, чтобы вернуть все погодные события вместе с координатами соответствующих городов, база данных должна сравнить столбец <code class="structfield">city</code> каждой строки таблицы <code class="structname">weather</code> со столбцом <code class="structfield">name</code> всех строк таблицы <code class="structname">cities</code> и выбрать пары строк, для которых эти значения совпадают. <a href="#ftn.id-1.4.4.7.3.6" class="footnote"><sup class="footnote" id="id-1.4.4.7.3.6">[4]</sup></a> Это можно сделать с помощью следующего запроса: </p><pre class="programlisting">SELECT * FROM weather JOIN cities ON city = name;</pre><p> </p><pre class="screen">
     city     |temp_lo|temp_hi| prcp|    date   |     name     | location
--------------+-------+-------+-----+-----------+--------------+----------
 San Francisco|     46|     50| 0.25| 1994-11-27| San Francisco| (-194,53)
 San Francisco|     43|     57|    0| 1994-11-29| San Francisco| (-194,53)
(2 rows)
</pre><p>Обратите внимание на две особенности полученных данных: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>В результате нет строки с городом Хейуорд (Hayward). Так получилось потому, что в таблице <code class="structname">cities</code> нет строки для данного города, а при соединении все строки таблицы <code class="structname">weather</code>, для которых не нашлось соответствие, опускаются. Вскоре мы увидим, как это можно исправить.</p></li><li class="listitem"><p>Название города оказалось в двух столбцах. Это правильно и объясняется тем, что столбцы таблиц <code class="structname">weather</code> и <code class="structname">cities</code> были объединены. Хотя на практике это нежелательно, поэтому лучше перечислить нужные столбцы явно, а не использовать <code class="literal">*</code>: </p><pre class="programlisting">SELECT city, temp_lo, temp_hi, prcp, date, location
    FROM weather JOIN cities ON city = name;</pre></li></ul></div><p>Так как все столбцы имеют разные имена, анализатор запроса автоматически понимает, к какой таблице они относятся. Если бы имена столбцов в двух таблицах повторялись, вам пришлось бы <em class="firstterm">дополнить</em> имена столбцов, конкретизируя, что именно вы имели в виду: </p><pre class="programlisting">SELECT weather.city, weather.temp_lo, weather.temp_hi,
       weather.prcp, weather.date, cities.location
    FROM weather JOIN cities ON weather.city = cities.name;</pre><p> Вообще хорошим стилем считается указывать полные имена столбцов в запросе соединения, чтобы запрос не поломался, если позже в таблицы будут добавлены столбцы с повторяющимися именами.</p><p>Запросы соединения, которые вы видели до этого, можно также записать в другом виде: </p><pre class="programlisting">SELECT *
    FROM weather, cities
    WHERE city = name;</pre><p> Этот синтаксис появился до синтаксиса <code class="literal">JOIN</code>/<code class="literal">ON</code>, принятого в SQL-92. Таблицы просто перечисляются в предложении <code class="literal">FROM</code>, а выражение сравнения добавляется в предложение <code class="literal">WHERE</code>. Результаты, получаемые с использованием старого неявного синтаксиса и нового явного синтаксиса <code class="literal">JOIN</code>/<code class="literal">ON</code>, будут одинаковыми. Однако, читая запрос, понять явный синтаксис проще: условие соединения вводится с помощью специального ключевого слова, а раньше это условие включалось в предложение <code class="literal">WHERE</code> наряду с другими условиями.</p><a id="id-1.4.4.7.7" class="indexterm"></a><p>Сейчас мы выясним, как вернуть записи о погоде в городе Хейуорд. Мы хотим, чтобы запрос просканировал таблицу <code class="structname">weather</code> и для каждой её строки нашёл соответствующую строку в таблице <code class="structname">cities</code>. Если же такая строка не будет найдена, мы хотим, чтобы вместо значений столбцов из таблицы <code class="structname">cities</code> были подставлены <span class="quote">«<span class="quote">пустые значения</span>»</span>. Запросы такого типа называются <em class="firstterm">внешними соединениями</em>. (Соединения, которые мы видели до этого, называются <em class="firstterm">внутренними</em>.) Эта команда будет выглядеть так: </p><pre class="programlisting">SELECT *
    FROM weather LEFT OUTER JOIN cities ON weather.city = cities.name;</pre><p> </p><pre class="screen">
     city      | temp_lo | temp_hi | prcp |    date    |     name      | location
---------------+---------+---------+------+------------+---------------+-----------
 Hayward       |      37 |      54 |      | 1994-11-29 |               |
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)
 San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)
(3 rows)
</pre><p> Этот запрос называется <em class="firstterm">левым внешним соединением</em>, потому что из таблицы в левой части оператора будут выбраны все строки, а из таблицы справа только те, которые удалось сопоставить каким-нибудь строкам из левой. При выводе строк левой таблицы, для которых не удалось найти соответствия в правой, вместо столбцов правой таблицы подставляются пустые значения (NULL).</p><p><strong>Упражнение: </strong>Существуют также правые внешние соединения и полные внешние соединения. Попробуйте выяснить, что они собой представляют.</p><a id="id-1.4.4.7.10" class="indexterm"></a><a id="id-1.4.4.7.11" class="indexterm"></a><p>В соединении мы также можем замкнуть таблицу на себя. Это называется <em class="firstterm">замкнутым соединением</em>. Например, представьте, что мы хотим найти все записи погоды, в которых температура лежит в диапазоне температур других записей. Для этого мы должны сравнить столбцы <code class="structfield">temp_lo</code> и <code class="structfield">temp_hi</code> каждой строки таблицы <code class="structname">weather</code> со столбцами <code class="structfield">temp_lo</code> и <code class="structfield">temp_hi</code> другого набора строк <code class="structname">weather</code>. Это можно сделать с помощью следующего запроса: </p><pre class="programlisting">SELECT w1.city, w1.temp_lo AS low, w1.temp_hi AS high,
       w2.city, w2.temp_lo AS low, w2.temp_hi AS high
    FROM weather w1 JOIN weather w2
        ON w1.temp_lo &lt; w2.temp_lo AND w1.temp_hi &gt; w2.temp_hi;</pre><p> </p><pre class="screen">
     city      | low | high |     city      | low | high
---------------+-----+------+---------------+-----+------
 San Francisco |  43 |   57 | San Francisco |  46 |   50
 Hayward       |  37 |   54 | San Francisco |  46 |   50
(2 rows)
</pre><p> Здесь мы ввели новые обозначения таблицы weather: <code class="literal">W1</code> и <code class="literal">W2</code>, чтобы можно было различить левую и правую стороны соединения. Вы можете использовать подобные псевдонимы и в других запросах для сокращения: </p><pre class="programlisting">SELECT *
    FROM weather w JOIN cities c ON w.city = c.name;</pre><p> Вы будете встречать сокращения такого рода довольно часто.</p><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.id-1.4.4.7.3.6" class="footnote"><p><a href="#id-1.4.4.7.3.6" class="para"><sup class="para">[4] </sup></a>Это не совсем точная модель. Обычно соединения выполняются эффективнее (сравниваются не все возможные пары строк), но это скрыто от пользователя.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="tutorial-select.html" title="2.5. Выполнение запроса">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="tutorial-sql.html" title="Глава 2. Язык SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="tutorial-agg.html" title="2.7. Агрегатные функции">След.</a></td></tr><tr><td width="40%" align="left" valign="top">2.5. Выполнение запроса </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 2.7. Агрегатные функции</td></tr></table></div></body></html>