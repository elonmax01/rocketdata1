<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>INSERT</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sql-importforeignschema.html" title="IMPORT FOREIGN SCHEMA" /><link rel="next" href="sql-listen.html" title="LISTEN" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">INSERT</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-importforeignschema.html" title="IMPORT FOREIGN SCHEMA">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><th width="60%" align="center">Команды SQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-listen.html" title="LISTEN">След.</a></td></tr></table><hr /></div><div class="refentry" id="SQL-INSERT"><div class="titlepage"></div><a id="id-1.9.3.152.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">INSERT</span></h2><p>INSERT — добавить строки в таблицу</p></div><div class="refsynopsisdiv"><h2>Синтаксис</h2><pre class="synopsis">[ WITH [ RECURSIVE ] <em class="replaceable"><code>запрос_WITH</code></em> [, ...] ]
INSERT INTO <em class="replaceable"><code>имя_таблицы</code></em> [ AS <em class="replaceable"><code>псевдоним</code></em> ] [ ( <em class="replaceable"><code>имя_столбца</code></em> [, ...] ) ]
    [ OVERRIDING { SYSTEM | USER } VALUE ]
    { DEFAULT VALUES | VALUES ( { <em class="replaceable"><code>выражение</code></em> | DEFAULT } [, ...] ) [, ...] | <em class="replaceable"><code>запрос</code></em> }
    [ ON CONFLICT [ <em class="replaceable"><code>объект_конфликта</code></em> ] <em class="replaceable"><code>действие_при_конфликте</code></em> ]
    [ RETURNING * | <em class="replaceable"><code>выражение_результата</code></em> [ [ AS ] <em class="replaceable"><code>имя_результата</code></em> ] [, ...] ]

<span class="phrase">Здесь допускается <em class="replaceable"><code>объект_конфликта</code></em>:</span>

    ( { <em class="replaceable"><code>имя_столбца_индекса</code></em> | ( <em class="replaceable"><code>выражение_индекса</code></em> ) } [ COLLATE <em class="replaceable"><code>правило_сортировки</code></em> ] [ <em class="replaceable"><code>класс_операторов</code></em> ] [, ...] ) [ WHERE <em class="replaceable"><code>предикат_индекса</code></em> ]
    ON CONSTRAINT <em class="replaceable"><code>имя_ограничения</code></em>

<span class="phrase">и <em class="replaceable"><code>действие_при_конфликте</code></em> может быть следующим:</span>

    DO NOTHING
    DO UPDATE SET { <em class="replaceable"><code>имя_столбца</code></em> = { <em class="replaceable"><code>выражение</code></em> | DEFAULT } |
                    ( <em class="replaceable"><code>имя_столбца</code></em> [, ...] ) = [ ROW ] ( { <em class="replaceable"><code>выражение</code></em> | DEFAULT } [, ...] ) |
                    ( <em class="replaceable"><code>имя_столбца</code></em> [, ...] ) = ( <em class="replaceable"><code>вложенный_SELECT</code></em> )
                  } [, ...]
              [ WHERE <em class="replaceable"><code>условие</code></em> ]</pre></div><div class="refsect1" id="id-1.9.3.152.5"><h2>Описание</h2><p><code class="command">INSERT</code> добавляет строки в таблицу. Эта команда может добавить одну или несколько строк, сформированных выражениями значений, либо ноль или более строк, выданных дополнительным запросом.</p><p>Имена целевых столбцов могут перечисляться в любом порядке. Если список с именами столбцов отсутствует, по умолчанию целевыми столбцами становятся все столбцы заданной таблицы; либо первые <em class="replaceable"><code>N</code></em> из них, если только <em class="replaceable"><code>N</code></em> столбцов поступает от предложения <code class="literal">VALUES</code> или <em class="replaceable"><code>запроса</code></em>. Значения, получаемые от предложения <code class="literal">VALUES</code> или <em class="replaceable"><code>запроса</code></em>, связываются с явно или неявно определённым списком столбцов слева направо.</p><p>Все столбцы, не представленные в явном или неявном списке столбцов, получат значения по умолчанию, если для них заданы эти значения, либо NULL в противном случае.</p><p>Если выражение для любого столбца выдаёт другой тип данных, система попытается автоматически привести его к нужному.</p><p>Операция <code class="command">INSERT</code> с таблицами без уникальных индексов не блокируется параллельно выполняемыми операциями. В таблицах с уникальными индексами эта операция может блокироваться, если в параллельных сеансах выполняются действия, которые блокируют или изменяют строки, совпадающие с вставляемыми значениями в уникальном индексе; подробнее см. <a class="xref" href="index-unique-checks.html" title="64.5. Проверки уникальности в индексе">Раздел 64.5</a>. Предложение <code class="literal">ON CONFLICT</code> позволяет задать действие, заменяющее возникновение ошибки при нарушении ограничения уникальности или ограничения-исключения. (См. описание <a class="xref" href="sql-insert.html#SQL-ON-CONFLICT" title="Предложение ON CONFLICT">Предложение ON CONFLICT</a> ниже.)</p><p>С необязательным предложением <code class="literal">RETURNING</code> команда <code class="command">INSERT</code> вычислит и возвратит значения для каждой фактически добавленной строки (или изменённой, если применялось предложение <code class="literal">ON CONFLICT DO UPDATE</code>). В основном это полезно для получения значений, присвоенных по умолчанию, например, последовательного номера записи. Однако в этом предложении можно задать любое выражение со столбцами таблицы. Список <code class="literal">RETURNING</code> имеет тот же синтаксис, что и список результатов <code class="command">SELECT</code>. В результате будут возвращены те строки, которые были успешно вставлены или изменены. Например, если строка была заблокирована, но не изменена, из-за того, что <em class="replaceable"><code>условие</code></em> в предложении <code class="literal">ON CONFLICT DO UPDATE ... WHERE</code> не удовлетворено, эта строка возвращена не будет.</p><p>Чтобы добавлять строки в таблицу, необходимо иметь право <code class="literal">INSERT</code> для неё. Если присутствует предложение <code class="literal">ON CONFLICT DO UPDATE</code>, также требуется иметь право <code class="literal">UPDATE</code> для этой таблицы.</p><p>Если указывается список столбцов, достаточно иметь право <code class="literal">INSERT</code> только для перечисленных столбцов. Аналогично, с предложением <code class="literal">ON CONFLICT DO UPDATE</code> достаточно иметь право <code class="literal">UPDATE</code> только для столбцов, которые будут изменены. Однако предложение <code class="literal">ON CONFLICT DO UPDATE</code> также требует наличия права <code class="literal">SELECT</code> для всех столбцов, значения которых считываются в выражениях <code class="literal">ON CONFLICT DO UPDATE</code> или в <em class="replaceable"><code>условии</code></em>.</p><p>Для применения предложения <code class="literal">RETURNING</code> требуется право <code class="literal">SELECT</code> для всех столбцов, перечисленных в <code class="literal">RETURNING</code>. Если для добавления строк применяется <em class="replaceable"><code>запрос</code></em>, для всех таблиц или столбцов, задействованных в этом запросе, разумеется, необходимо иметь право <code class="literal">SELECT</code>.</p></div><div class="refsect1" id="id-1.9.3.152.6"><h2>Параметры</h2><div class="refsect2" id="id-1.9.3.152.6.2"><h3>Добавление</h3><p>В этом разделе рассматриваются параметры, применяемые только при добавлении новых строк. Параметры, применяемые <span class="emphasis"><em>исключительно</em></span> с предложением <code class="literal">ON CONFLICT</code>, описываются отдельно.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>запрос_WITH</code></em></span></dt><dd><p>Предложение <code class="literal">WITH</code> позволяет задать один или несколько подзапросов, на которые затем можно ссылаться по имени в запросе <code class="command">INSERT</code>. Подробнее об этом см. <a class="xref" href="queries-with.html" title="7.8. Запросы WITH (Общие табличные выражения)">Раздел 7.8</a> и <a class="xref" href="sql-select.html" title="SELECT"><span class="refentrytitle">SELECT</span></a>.</p><p>Заданный <em class="replaceable"><code>запрос</code></em> (оператор <code class="command">SELECT</code>) также может содержать предложение <code class="literal">WITH</code>. В этом случае в <em class="replaceable"><code>запросе</code></em> можно обращаться к обоим <em class="replaceable"><code>запросам_WITH</code></em>, но второй будет иметь приоритет, так как он вложен ближе.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_таблицы</code></em></span></dt><dd><p>Имя существующей таблицы (возможно, дополненное схемой).</p></dd><dt><span class="term"><em class="replaceable"><code>псевдоним</code></em></span></dt><dd><p>Альтернативное имя, заменяющее <em class="replaceable"><code>имя_таблицы</code></em>. Когда указывается этот псевдоним, он полностью скрывает реальное имя таблицы. Это особенно полезно, когда в предложении <code class="literal">ON CONFLICT DO UPDATE</code> фигурирует таблица с именем <code class="varname">excluded</code>, так как без определения псевдонима это имя будет отдано специальной таблице, представляющей строку, предназначенную для добавления.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_столбца</code></em></span></dt><dd><p>Имя столбца в таблице <em class="replaceable"><code>имя_таблицы</code></em>. Это имя столбца при необходимости может быть дополнено именем вложенного поля или индексом в массиве. (Когда данные вставляются только в некоторые поля столбца составного типа, в другие поля записывается NULL.) Обращаясь к столбцу в предложении <code class="literal">ON CONFLICT DO UPDATE</code>, включать имя таблицы в ссылку на целевой столбец не нужно. Например, запись <code class="literal">INSERT INTO table_name ... ON CONFLICT DO UPDATE SET table_name.col = 1</code> некорректна (это согласуется с общим поведением команды <code class="command">UPDATE</code>).</p></dd><dt><span class="term"><code class="literal">OVERRIDING SYSTEM VALUE</code></span></dt><dd><p>Если указывается это предложение, то значения, предоставляемые для столбцов идентификации, переопределяют значения, выдаваемые последовательностью по умолчанию.</p><p>Для столбца идентификации, определённого со свойством <code class="literal">GENERATED ALWAYS</code>, считается ошибкой присваивание явного значения (кроме DEFAULT) без указания <code class="literal">OVERRIDING SYSTEM VALUE</code> или <code class="literal">OVERRIDING USER VALUE</code>. (Для столбца идентификации, определённого со свойством <code class="literal">GENERATED BY DEFAULT</code>, указание <code class="literal">OVERRIDING SYSTEM VALUE</code> соответствует обычному поведению и ни на что не влияет, но <span class="productname">PostgreSQL</span> допускает его как дополнение.)</p></dd><dt><span class="term"><code class="literal">OVERRIDING USER VALUE</code></span></dt><dd><p>Если указывается это предложение, то значения, предоставляемые для столбцов идентификации, игнорируются и вместо них применяются значения, выдаваемые последовательностью по умолчанию.</p><p>Это предложение полезно, например, при копировании значений между таблицами. Команда <code class="literal">INSERT INTO tbl2 OVERRIDING USER VALUE SELECT * FROM tbl1</code> скопирует из <code class="literal">tbl1</code> все столбцы, кроме столбцов идентификации в <code class="literal">tbl2</code>, а значения столбцов идентификации в <code class="literal">tbl2</code> будут сгенерированы последовательностями в <code class="literal">tbl2</code>.</p></dd><dt><span class="term"><code class="literal">DEFAULT VALUES</code></span></dt><dd><p>Все столбцы получат значения по умолчанию, как в случая явного указания <code class="literal">DEFAULT</code> для каждого столбца. (Предложение <code class="literal">OVERRIDING</code> в этой форме не допускается.)</p></dd><dt><span class="term"><em class="replaceable"><code>выражение</code></em></span></dt><dd><p>Выражение или значение, которое будет присвоено соответствующему столбцу.</p></dd><dt><span class="term"><code class="literal">DEFAULT</code></span></dt><dd><p>Соответствующий столбец получит значение по умолчанию. Столбец идентификации получит новое значение, выданное связанной последовательностью. Для генерируемого столбца это указание допускается, но не меняет обычное поведение, то есть значение столбца вычисляется генерирующим выражением.</p></dd><dt><span class="term"><em class="replaceable"><code>запрос</code></em></span></dt><dd><p>Запрос (оператор <code class="command">SELECT</code>), который выдаст строки для добавления в таблицу. Его синтаксис описан в справке оператора <a class="xref" href="sql-select.html" title="SELECT"><span class="refentrytitle">SELECT</span></a>.</p></dd><dt><span class="term"><em class="replaceable"><code>выражение_результата</code></em></span></dt><dd><p>Выражение, которое будет вычисляться и возвращаться командой <code class="command">INSERT</code> после добавления или изменения каждой строки. В этом выражении можно использовать имена любых столбцов таблицы <em class="replaceable"><code>имя_таблицы</code></em>. Чтобы получить все столбцы, достаточно написать <code class="literal">*</code>.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_результата</code></em></span></dt><dd><p>Имя, назначаемое возвращаемому столбцу.</p></dd></dl></div></div><div class="refsect2" id="SQL-ON-CONFLICT"><h3>Предложение <code class="literal">ON CONFLICT</code></h3><a id="id-1.9.3.152.6.3.2" class="indexterm"></a><a id="id-1.9.3.152.6.3.3" class="indexterm"></a><p>Необязательное предложение <code class="literal">ON CONFLICT</code> задаёт действие, заменяющее возникновение ошибки при нарушении ограничения уникальности или ограничения-исключения. Для каждой отдельной строки, предложенной для добавления, добавление либо выполняется успешно, либо, если нарушается <span class="emphasis"><em>решающее</em></span> ограничение или индекс, задаваемые как <em class="parameter"><code>объект_конфликта</code></em>, выполняется альтернативное <em class="parameter"><code>действие_конфликта</code></em>. Вариант <code class="literal">ON CONFLICT DO NOTHING</code> в качестве альтернативного действия просто отменяет добавление строки. Вариант <code class="literal">ON CONFLICT DO UPDATE</code> изменяет существующую строку, вызвавшую конфликт со строкой, предложенной для добавления.</p><p>Задаваемый <em class="parameter"><code>объект_конфликта</code></em> может <span class="emphasis"><em>выбирать уникальный индекс</em></span>. Определение объекта, позволяющее выбрать индекс, включает один или несколько столбцов (их определяет <em class="replaceable"><code>имя_столбца_индекса</code></em>) и/или <em class="replaceable"><code>выражение_индекса</code></em> и необязательный <em class="replaceable"><code>предикат_индекса</code></em>. Все уникальные индексы в таблице <em class="replaceable"><code>имя_таблицы</code></em>, которые, без учёта порядка столбцов, содержат в точности столбцы/выражения, определяющие <em class="parameter"><code>объект_конфликта</code></em>, выбираются как решающие индексы. Если указывается <em class="replaceable"><code>предикат_индекса</code></em>, он должен, в качестве дополнительного требования выбора, удовлетворять индексам. Заметьте, что это означает, что не частичный уникальный индекс (уникальный индекс без предиката) будет выбран (и будет использоваться в <code class="literal">ON CONFLICT</code>), если такой индекс удовлетворяет всем остальным критериям. Если попытка выбрать индекс оказывается неудачной, выдаётся ошибка.</p><p><code class="literal">ON CONFLICT DO UPDATE</code> гарантирует атомарный результат команды <code class="command">INSERT</code> или <code class="command">UPDATE</code>; при отсутствии внешних ошибок гарантируется один из двух этих исходов, даже при большой параллельной активности. Эта операция также известна как <em class="firstterm">UPSERT</em> — <span class="quote">«<span class="quote">UPDATE или INSERT</span>»</span>.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>объект_конфликта</code></em></span></dt><dd><p>Определяет, для какого именно конфликта в <code class="literal">ON CONFLICT</code> будет предпринято альтернативное действие, устанавливая <em class="firstterm">решающие индексы</em>. Это указание позволяет осуществить <span class="emphasis"><em>выбор уникального индекса</em></span> или явно задаёт имя ограничения. Для <code class="literal">ON CONFLICT DO NOTHING</code> <em class="parameter"><code>объект_конфликта</code></em> может не указываться; в этом случае игнорироваться будут все конфликты с любыми ограничениями (и уникальными индексами). Для <code class="literal">ON CONFLICT DO UPDATE</code> <em class="parameter"><code>объект_конфликта</code></em> <span class="emphasis"><em>должен</em></span> указываться.</p></dd><dt><span class="term"><em class="replaceable"><code>действие_при_конфликте</code></em></span></dt><dd><p>Параметр <em class="parameter"><code>действие_при_конфликте</code></em> задаёт альтернативное действие в случае конфликта. Это может быть либо <code class="literal">DO NOTHING</code> (не делать ничего), либо предложение <code class="literal">DO UPDATE</code> (произвести изменение), в котором указываются точные детали операции <code class="literal">UPDATE</code>, выполняемой в случае конфликта. Предложения <code class="literal">SET</code> и <code class="literal">WHERE</code> в <code class="literal">ON CONFLICT DO UPDATE</code> могут обращаться к существующей строке по имени таблицы (или псевдониму) или к строке, предлагаемой для добавления, используя специальную таблицу <code class="varname">excluded</code>. Для чтения столбцов <code class="varname">excluded</code> необходимо иметь право <code class="literal">SELECT</code> для соответствующих столбцов в целевой таблице.</p><p>Заметьте, что эффект действий всех триггеров уровня строк <code class="literal">BEFORE INSERT</code> отражается в значениях <code class="varname">excluded</code>, так как в результате этих действий строка может быть исключена из множества добавляемых.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_столбца_индекса</code></em></span></dt><dd><p>Имя столбца в таблице <em class="replaceable"><code>имя_таблицы</code></em>. Используется для выбора решающих индексов. Задаётся в формате <code class="command">CREATE INDEX</code>. Чтобы запрос выполнился, для столбца <em class="replaceable"><code>имя_столбца_индекса</code></em> требуется право <code class="literal">SELECT</code>.</p></dd><dt><span class="term"><em class="replaceable"><code>выражение_индекса</code></em></span></dt><dd><p>Подобно указанию <em class="replaceable"><code>имя_столбца_индекса</code></em>, но применяется для выбора индекса по выражениям со столбцами таблицы <em class="replaceable"><code>имя_таблицы</code></em>, фигурирующим в определениях индексов (не по простым столбцам). Задаётся в формате <code class="command">CREATE INDEX</code>. Для всех столбцов, к которым обращается <em class="replaceable"><code>выражение_индекса</code></em>, необходимо иметь право <code class="literal">SELECT</code>.</p></dd><dt><span class="term"><em class="replaceable"><code>правило_сортировки</code></em></span></dt><dd><p>Когда задаётся, устанавливает, что соответствующие <em class="replaceable"><code>имя_столбца_индекса</code></em> или <em class="replaceable"><code>выражение_индекса</code></em> должны использовать определённый порядок сортировки, чтобы этот индекс мог быть выбран. Обычно это указание опускается, так как от правил сортировки чаще всего не зависит, произойдёт ли нарушение ограничений или нет. Задаётся в формате <code class="command">CREATE INDEX</code>.</p></dd><dt><span class="term"><em class="replaceable"><code>класс_операторов</code></em></span></dt><dd><p>Когда задаётся, устанавливает, что соответствующие <em class="replaceable"><code>имя_столбца_индекса</code></em> или <em class="replaceable"><code>выражение_индекса</code></em> должны использовать определённый класс, чтобы индекс мог быть выбран. Обычно это указание опускается, потому что семантика <span class="emphasis"><em>равенства</em></span> часто всё равно одна и та же в разных классах операторов типа, или потому что достаточно рассчитывать на то, что заданные уникальные индексы имеют адекватное определение равенства. Задаётся в формате <code class="command">CREATE INDEX</code>.</p></dd><dt><span class="term"><em class="replaceable"><code>предикат_индекса</code></em></span></dt><dd><p>Используется для выбора частичных уникальных индексов. Выбраны могут быть любые индексы, удовлетворяющие предикату (при этом они могут не быть собственно частичными индексами). Задаётся в формате <code class="command">CREATE INDEX</code>. Для всех столбцов, задействованных в <em class="replaceable"><code>предикате_индекса</code></em>, требуется право <code class="literal">SELECT</code>.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_ограничения</code></em></span></dt><dd><p>Явно задаёт решающее <span class="emphasis"><em>ограничение</em></span> по имени, что заменяет неявный выбор ограничения или индекса.</p></dd><dt><span class="term"><em class="replaceable"><code>условие</code></em></span></dt><dd><p>Выражение, выдающее значение типа <code class="type">boolean</code>. Изменены будут только те строки, для которых это выражение выдаст <code class="literal">true</code>, хотя при выборе действия <code class="literal">ON CONFLICT DO UPDATE</code> заблокируются все строки. Заметьте, что <em class="replaceable"><code>условие</code></em> вычисляется в конце, после того как конфликт был признан претендующим на выполнение изменения.</p></dd></dl></div><p>Заметьте, что ограничения-исключения не могут быть решающими в <code class="literal">ON CONFLICT DO UPDATE</code>. Во всех случаях в качестве решающих поддерживаются только неоткладываемые (<code class="literal">NOT DEFERRABLE</code>) ограничения и уникальные индексы.</p><p>Команда <code class="command">INSERT</code> с предложением <code class="literal">ON CONFLICT DO UPDATE</code> является <span class="quote">«<span class="quote">детерминированной</span>»</span>. Это означает, что этой команде не разрешено воздействовать на любую существующую строку больше одного раза; в случае такой ситуации возникнет ошибка нарушения мощности множества. Строки, предлагаемые для добавления, не должны дублироваться с точки зрения атрибутов, ограничиваемых решающим индексом или ограничением.</p><p>Заметьте, что в настоящий момент не поддерживается ситуация, когда конструкция <code class="literal">ON CONFLICT DO UPDATE</code> команды <code class="command">INSERT</code>, применяемой к секционированной таблице, изменяет ключ разбиения в конфликтующей строке так, что эта строка должна быть перенесена в новую секцию.</p><div class="tip"><h3 class="title">Подсказка</h3><p>Часто предпочтительнее использовать неявный выбор уникального индекса вместо непосредственного указания ограничения в виде <code class="literal">ON CONFLICT ON CONSTRAINT</code> <em class="replaceable"><code>имя_ограничения</code></em>. Выбор продолжит корректно работать, когда нижележащий индекс будет заменён другим более или менее равнозначным индексом методом наложения, например, с использованием <code class="literal">CREATE UNIQUE INDEX ... CONCURRENTLY</code> и последующим удалением заменяемого индекса.</p></div></div></div><div class="refsect1" id="id-1.9.3.152.7"><h2>Выводимая информация</h2><p>В случае успешного завершения <code class="command">INSERT</code> возвращает метку команды в виде </p><pre class="screen">
INSERT <em class="replaceable"><code>oid</code></em> <em class="replaceable"><code>число</code></em>
</pre><p> Здесь <em class="replaceable"><code>число</code></em> представляет количество добавленных или изменённых строк. Поле <em class="replaceable"><code>oid</code></em> всегда содержит 0 (раньше в нём выводился <acronym class="acronym">OID</acronym>, присвоенный добавленной строке, когда <em class="replaceable"><code>число</code></em> равнялось 1 и целевая таблица была создана с указанием <code class="literal">WITH OIDS</code>, а в противном случае — 0; теперь же создание таблицы с характеристикой <code class="literal">WITH OIDS</code> не поддерживается).</p><p>Если команда <code class="command">INSERT</code> содержит предложение <code class="literal">RETURNING</code>, её результат будет похож на результат оператора <code class="command">SELECT</code> (с теми же столбцами и значениями, что содержатся в списке <code class="literal">RETURNING</code>), полученный для строк, добавленных или изменённых этой командой.</p></div><div class="refsect1" id="id-1.9.3.152.8"><h2>Замечания</h2><p>Если целевая таблица является секционированной, каждая строка перенаправляется в соответствующую секцию и вставляется в неё. Если целевая таблица является секцией и какая-либо из входных строк нарушает ограничение этой секции, происходит ошибка.</p><p>Вы также можете использовать команду <code class="command">MERGE</code>, так как она позволяет объединить команды <code class="command">INSERT</code>, <code class="command">UPDATE</code> и <code class="command">DELETE</code> в одном операторе. См. <a class="xref" href="sql-merge.html" title="MERGE"><span class="refentrytitle">MERGE</span></a>.</p></div><div class="refsect1" id="id-1.9.3.152.9"><h2>Примеры</h2><p>Добавление одной строки в таблицу <code class="literal">films</code>: </p><pre class="programlisting">INSERT INTO films VALUES
    ('UA502', 'Bananas', 105, '1971-07-13', 'Comedy', '82 minutes');</pre><p>В этом примере столбец <code class="literal">len</code> опускается и, таким образом, получает значение по умолчанию: </p><pre class="programlisting">INSERT INTO films (code, title, did, date_prod, kind)
    VALUES ('T_601', 'Yojimbo', 106, '1961-06-16', 'Drama');</pre><p>В этом примере для столбца с датой задаётся указание <code class="literal">DEFAULT</code>, а не явное значение: </p><pre class="programlisting">INSERT INTO films VALUES
    ('UA502', 'Bananas', 105, DEFAULT, 'Comedy', '82 minutes');
INSERT INTO films (code, title, did, date_prod, kind)
    VALUES ('T_601', 'Yojimbo', 106, DEFAULT, 'Drama');</pre><p>Добавление строки, полностью состоящей из значений по умолчанию: </p><pre class="programlisting">INSERT INTO films DEFAULT VALUES;</pre><p>Добавление нескольких строк с использованием многострочного синтаксиса <code class="command">VALUES</code>: </p><pre class="programlisting">INSERT INTO films (code, title, did, date_prod, kind) VALUES
    ('B6717', 'Tampopo', 110, '1985-02-10', 'Comedy'),
    ('HG120', 'The Dinner Game', 140, DEFAULT, 'Comedy');</pre><p>В этом примере в таблицу <code class="literal">films</code> вставляются некоторые строки из таблицы <code class="literal">tmp_films</code>, имеющей ту же структуру столбцов, что и <code class="literal">films</code>: </p><pre class="programlisting">INSERT INTO films SELECT * FROM tmp_films WHERE date_prod &lt; '2004-05-07';</pre><p>Этот пример демонстрирует добавление данных в столбцы с типом массива: </p><pre class="programlisting">-- Создание пустого поля 3x3 для игры в крестики-нолики
INSERT INTO tictactoe (game, board[1:3][1:3])
    VALUES (1, '{{" "," "," "},{" "," "," "},{" "," "," "}}');
-- Указания индексов в предыдущей команда могут быть опущены
INSERT INTO tictactoe (game, board)
    VALUES (2, '{{X," "," "},{" ",O," "},{" ",X," "}}');</pre><p>Добавление одной строки в таблицу <code class="literal">distributors</code> и получение последовательного номера, сгенерированного благодаря указанию <code class="literal">DEFAULT</code>: </p><pre class="programlisting">INSERT INTO distributors (did, dname) VALUES (DEFAULT, 'XYZ Widgets')
   RETURNING did;</pre><p>Увеличение счётчика продаж для продавца, занимающегося компанией Acme Corporation, и сохранение всей изменённой строки вместе с текущим временем в таблице журнала: </p><pre class="programlisting">WITH upd AS (
  UPDATE employees SET sales_count = sales_count + 1 WHERE id =
    (SELECT sales_person FROM accounts WHERE name = 'Acme Corporation')
    RETURNING *
)
INSERT INTO employees_log SELECT *, current_timestamp FROM upd;</pre><p>Добавить дистрибьюторов или изменить существующие данные должным образом. Предполагается, что в таблице определён уникальный индекс, ограничивающий значения в столбце <code class="literal">did</code>. Заметьте, что для обращения к значениям, изначально предлагаемым для добавления, используется специальная таблица <code class="varname">excluded</code>: </p><pre class="programlisting">INSERT INTO distributors (did, dname)
    VALUES (5, 'Gizmo Transglobal'), (6, 'Associated Computing, Inc')
    ON CONFLICT (did) DO UPDATE SET dname = EXCLUDED.dname;</pre><p>Добавить дистрибьютора или не делать ничего для строк, предложенных для добавления, если уже есть существующая исключающая строка (строка, содержащая конфликтующие значения в столбце или столбцах после срабатывания триггеров перед добавлением строки). В данном примере предполагается, что определён уникальный индекс, ограничивающий значения в столбце <code class="literal">did</code>: </p><pre class="programlisting">INSERT INTO distributors (did, dname) VALUES (7, 'Redline GmbH')
    ON CONFLICT (did) DO NOTHING;</pre><p>Добавить дистрибьюторов или изменить существующие данные должным образом. В данном примере предполагается, что в таблице определён уникальный индекс, ограничивающий значения в столбце <code class="literal">did</code>. Предложение <code class="literal">WHERE</code> позволяет ограничить набор фактически изменяемых строк (однако любая существующая строка, не подлежащая изменению, всё же будет заблокирована): </p><pre class="programlisting">-- Не менять данные существующих дистрибьюторов в зависимости от почтового индекса
INSERT INTO distributors AS d (did, dname) VALUES (8, 'Anvil Distribution')
    ON CONFLICT (did) DO UPDATE
    SET dname = EXCLUDED.dname || ' (formerly ' || d.dname || ')'
    WHERE d.zipcode &lt;&gt; '21201';

-- Указать имя ограничения непосредственно в операторе (связанный индекс
-- применяется для принятия решения о выполнении действия DO NOTHING)
INSERT INTO distributors (did, dname) VALUES (9, 'Antwerp Design')
    ON CONFLICT ON CONSTRAINT distributors_pkey DO NOTHING;</pre><p>Добавить дистрибьютора, если возможно; в противном случае не делать ничего (<code class="literal">DO NOTHING</code>). В данном примере предполагается, что в таблице определён уникальный индекс, ограничивающий значения в столбце <code class="literal">did</code> по подмножеству строк, в котором логический столбец <code class="literal">is_active</code> содержит <code class="literal">true</code>: </p><pre class="programlisting">-- Этот оператор может выбрать частичный уникальный индекс по "did"
-- с предикатом "WHERE is_active", а может и просто использовать
-- обычное ограничение уникальности по столбцу "did"
INSERT INTO distributors (did, dname) VALUES (10, 'Conrad International')
    ON CONFLICT (did) WHERE is_active DO NOTHING;</pre></div><div class="refsect1" id="id-1.9.3.152.10"><h2>Совместимость</h2><p><code class="command">INSERT</code> соответствует стандарту SQL, но предложение <code class="literal">RETURNING</code> относится к расширениям <span class="productname">PostgreSQL</span>, как и возможность применять <code class="literal">WITH</code> с <code class="command">INSERT</code> и возможность задавать альтернативное действие с <code class="literal">ON CONFLICT</code>. Кроме того, ситуация, когда список столбцов опущен, но не все столбцы получают значения из предложения <code class="literal">VALUES</code> или <em class="replaceable"><code>запроса</code></em>, стандартом не допускается. Если вы предпочитаете конструкции <code class="literal">ON CONFLICT</code> оператор, более соответствующий стандарту SQL, см. <a class="xref" href="sql-merge.html" title="MERGE"><span class="refentrytitle">MERGE</span></a>.</p><p>В стандарте SQL говорится, что предложение <code class="literal">OVERRIDING SYSTEM VALUE</code> может присутствовать, только если существует столбец идентификации, для которого всегда генерируется значение. PostgreSQL допускает это предложение в любом случае и игнорирует его в случае неприменимости.</p><p>Возможные ограничения предложения <em class="replaceable"><code>запрос</code></em> описаны в справке <a class="xref" href="sql-select.html" title="SELECT"><span class="refentrytitle">SELECT</span></a>.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-importforeignschema.html" title="IMPORT FOREIGN SCHEMA">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-listen.html" title="LISTEN">След.</a></td></tr><tr><td width="40%" align="left" valign="top">IMPORT FOREIGN SCHEMA </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> LISTEN</td></tr></table></div></body></html>