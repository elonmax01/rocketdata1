<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>31.3. Фильтры строк</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="logical-replication-subscription.html" title="31.2. Подписка" /><link rel="next" href="logical-replication-col-lists.html" title="31.4. Списки столбцов" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">31.3. Фильтры строк</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="logical-replication-subscription.html" title="31.2. Подписка">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="logical-replication.html" title="Глава 31. Логическая репликация">Наверх</a></td><th width="60%" align="center">Глава 31. Логическая репликация</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="logical-replication-col-lists.html" title="31.4. Списки столбцов">След.</a></td></tr></table><hr /></div><div class="sect1" id="LOGICAL-REPLICATION-ROW-FILTER"><div class="titlepage"><div><div><h2 class="title" style="clear: both">31.3. Фильтры строк <a href="#LOGICAL-REPLICATION-ROW-FILTER" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="logical-replication-row-filter.html#LOGICAL-REPLICATION-ROW-FILTER-RULES">31.3.1. Правила фильтров строк</a></span></dt><dt><span class="sect2"><a href="logical-replication-row-filter.html#LOGICAL-REPLICATION-ROW-FILTER-RESTRICTIONS">31.3.2. Ограничения выражений</a></span></dt><dt><span class="sect2"><a href="logical-replication-row-filter.html#LOGICAL-REPLICATION-ROW-FILTER-TRANSFORMATIONS">31.3.3. Преобразования UPDATE</a></span></dt><dt><span class="sect2"><a href="logical-replication-row-filter.html#LOGICAL-REPLICATION-ROW-FILTER-PARTITIONED-TABLE">31.3.4. Секционированные таблицы</a></span></dt><dt><span class="sect2"><a href="logical-replication-row-filter.html#LOGICAL-REPLICATION-ROW-FILTER-INITIAL-DATA-SYNC">31.3.5. Начальная синхронизация данных</a></span></dt><dt><span class="sect2"><a href="logical-replication-row-filter.html#LOGICAL-REPLICATION-ROW-FILTER-COMBINING">31.3.6. Объединение нескольких фильтров строк</a></span></dt><dt><span class="sect2"><a href="logical-replication-row-filter.html#LOGICAL-REPLICATION-ROW-FILTER-EXAMPLES">31.3.7. Примеры</a></span></dt></dl></div><p>По умолчанию подписчикам передаются все данные из всех опубликованных таблиц. Однако множество реплицируемых данных можно ограничить, используя <em class="firstterm">фильтр строк</em>. Потребность использовать фильтры строк может быть вызвана соображениями безопасности, производительности или требованиями к поведению. Если для опубликованной таблицы устанавливается фильтр строк, строка реплицируется, только если её данные удовлетворяют выражению этого фильтра. Это позволяет организовать частичную репликацию данных набора таблиц. Определяются фильтры строк на уровне отдельных таблиц. Для каждой публикуемой таблицы, данные которой требуется отфильтровать, нужно добавить предложение <code class="literal">WHERE</code> после её имени, при этом выражение условия <code class="literal">WHERE</code> нужно заключить в круглые скобки. За подробностями обратитесь к <a class="xref" href="sql-createpublication.html" title="CREATE PUBLICATION"><span class="refentrytitle">CREATE PUBLICATION</span></a>.</p><div class="sect2" id="LOGICAL-REPLICATION-ROW-FILTER-RULES"><div class="titlepage"><div><div><h3 class="title">31.3.1. Правила фильтров строк <a href="#LOGICAL-REPLICATION-ROW-FILTER-RULES" class="id_link">#</a></h3></div></div></div><p>Фильтры строк применяются <span class="emphasis"><em>перед</em></span> публикацией изменений. Если результатом выражения фильтра для строки является <code class="literal">false</code> или <code class="literal">NULL</code>, эта строка не реплицируется. Выражение условия <code class="literal">WHERE</code> вычисляется от имени роли, которая используется для подключения репликации (т. е. роли, указанной в предложении <a class="link" href="sql-createsubscription.html#SQL-CREATESUBSCRIPTION-CONNECTION"><code class="literal">CONNECTION</code></a> <a class="xref" href="sql-createsubscription.html" title="CREATE SUBSCRIPTION"><span class="refentrytitle">CREATE SUBSCRIPTION</span></a>). На команду <code class="command">TRUNCATE</code> фильтры строк не распространяются.</p></div><div class="sect2" id="LOGICAL-REPLICATION-ROW-FILTER-RESTRICTIONS"><div class="titlepage"><div><div><h3 class="title">31.3.2. Ограничения выражений <a href="#LOGICAL-REPLICATION-ROW-FILTER-RESTRICTIONS" class="id_link">#</a></h3></div></div></div><p>В предложении <code class="literal">WHERE</code> допускаются только простые выражения, в которых нельзя использовать определяемые пользователем функции, операторы, типы и параметры сортировки, а также ссылки на системные столбцы и непостоянные встроенные функции.</p><p>Если через публикацию реплицируются операции <code class="command">UPDATE</code> или <code class="command">DELETE</code>, предложение <code class="literal">WHERE</code> фильтра строк должно содержать только те столбцы, которые входят в идентификатор реплики (см. <a class="xref" href="sql-altertable.html#SQL-ALTERTABLE-REPLICA-IDENTITY"><code class="literal">REPLICA IDENTITY</code></a>). Если же через публикацию реплицируются только операции <code class="command">INSERT</code>, в фильтре строк <code class="literal">WHERE</code> можно использовать любой столбец.</p></div><div class="sect2" id="LOGICAL-REPLICATION-ROW-FILTER-TRANSFORMATIONS"><div class="titlepage"><div><div><h3 class="title">31.3.3. Преобразования UPDATE <a href="#LOGICAL-REPLICATION-ROW-FILTER-TRANSFORMATIONS" class="id_link">#</a></h3></div></div></div><p>При выполнении каждой операции <code class="command">UPDATE</code> выражение фильтра строк вычисляется и для старой, и для новой строки (т. е. проверяются данные до и после изменения). Если оба результата положительные (<code class="literal">true</code>), изменение <code class="command">UPDATE</code> реплицируется. Если оба результата отрицательные (<code class="literal">false</code>), изменение не реплицируется. Если же выражению фильтра удовлетворяет только одна строка, старая или новая, операция <code class="command">UPDATE</code> преобразуется в <code class="command">INSERT</code> или <code class="command">DELETE</code>, чтобы не нарушилась согласованность данных. Строка на стороне подписки должна соответствовать выражению фильтра строк, определённого на публикующем сервере.</p><p>Если старая строка соответствует выражению фильтра строк (она была передана подписчику), а новая строка — нет, то для обеспечения согласованности данных старую строку нужно удалить у подписчика. Таким образом, <code class="command">UPDATE</code> преобразуется в <code class="command">DELETE</code>.</p><p>Если старая строка не соответствует выражению фильтра строк (она не была передана подписчику), а новая строка соответствует, то для обеспечения согласованности данных новую строку нужно добавить в таблицу подписчика. Таким образом, <code class="command">UPDATE</code> преобразуется в <code class="command">INSERT</code>.</p><p>Производимые преобразования показаны в <a class="xref" href="logical-replication-row-filter.html#LOGICAL-REPLICATION-ROW-FILTER-TRANSFORMATIONS-SUMMARY" title="Таблица 31.1. Краткая схема преобразования UPDATE">Таблице 31.1</a>.</p><div class="table" id="LOGICAL-REPLICATION-ROW-FILTER-TRANSFORMATIONS-SUMMARY"><p class="title"><strong>Таблица 31.1. Краткая схема преобразования <code class="command">UPDATE</code></strong></p><div class="table-contents"><table class="table" summary="Краткая схема преобразования UPDATE" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Старая строка</th><th>Новая строка</th><th>Преобразование</th></tr></thead><tbody><tr><td>не соответствует</td><td>не соответствует</td><td>не реплицировать</td></tr><tr><td>не соответствует</td><td>соответствует</td><td><code class="literal">INSERT</code></td></tr><tr><td>соответствует</td><td>не соответствует</td><td><code class="literal">DELETE</code></td></tr><tr><td>соответствует</td><td>соответствует</td><td><code class="literal">UPDATE</code></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect2" id="LOGICAL-REPLICATION-ROW-FILTER-PARTITIONED-TABLE"><div class="titlepage"><div><div><h3 class="title">31.3.4. Секционированные таблицы <a href="#LOGICAL-REPLICATION-ROW-FILTER-PARTITIONED-TABLE" class="id_link">#</a></h3></div></div></div><p>Если публикация содержит секционированную таблицу, параметр публикации <a class="link" href="sql-createpublication.html#SQL-CREATEPUBLICATION-WITH-PUBLISH-VIA-PARTITION-ROOT"><code class="literal">publish_via_partition_root</code></a> определяет, какой фильтр строк использовать. Если <code class="literal">publish_via_partition_root</code> имеет значение <code class="literal">true</code>, используется фильтр строк <span class="emphasis"><em>корневой секционированной таблицы</em></span>. В противном случае, если <code class="literal">publish_via_partition_root</code> имеет значение <code class="literal">false</code> (по умолчанию), используются фильтры строк каждой <span class="emphasis"><em>секции</em></span>.</p></div><div class="sect2" id="LOGICAL-REPLICATION-ROW-FILTER-INITIAL-DATA-SYNC"><div class="titlepage"><div><div><h3 class="title">31.3.5. Начальная синхронизация данных <a href="#LOGICAL-REPLICATION-ROW-FILTER-INITIAL-DATA-SYNC" class="id_link">#</a></h3></div></div></div><p>Если подписка требует копирования уже существующих данных, а публикация содержит предложения <code class="literal">WHERE</code>, подписчику копируются только данные, удовлетворяющие выражениям фильтров строк.</p><p>Если подписка связана с несколькими публикациями, в которых одна таблица опубликована с разными предложениями <code class="literal">WHERE</code>, будут скопированы строки, удовлетворяющие <span class="emphasis"><em>любому</em></span> из фильтров. За подробностями обратитесь к <a class="xref" href="logical-replication-row-filter.html#LOGICAL-REPLICATION-ROW-FILTER-COMBINING" title="31.3.6. Объединение нескольких фильтров строк">Подразделу 31.3.6</a>.</p><div class="warning"><h3 class="title">Предупреждение</h3><p>Так как при начальной синхронизации данных не учитывается параметр <a class="link" href="sql-createpublication.html#SQL-CREATEPUBLICATION-WITH-PUBLISH"><code class="literal">publish</code></a>, когда копируются существующие данные таблиц, подписчику могут быть переданы строки, которые не реплицировались бы при выполнении операций DML. Примеры приведены в <a class="xref" href="logical-replication-architecture.html#LOGICAL-REPLICATION-SNAPSHOT" title="31.7.1. Начальный снимок">Подразделе 31.7.1</a> и <a class="xref" href="logical-replication-subscription.html#LOGICAL-REPLICATION-SUBSCRIPTION-EXAMPLES" title="31.2.2. Примеры: настройка логической репликации">Подразделе 31.2.2</a>.</p></div><div class="note"><h3 class="title">Примечание</h3><p>Если на стороне подписчика используется версия ниже 15, при копировании существующих данных фильтры строк не обрабатываются, даже если они определены в публикации. Это связано с тем, что старые версии могут копировать только все данные таблицы.</p></div></div><div class="sect2" id="LOGICAL-REPLICATION-ROW-FILTER-COMBINING"><div class="titlepage"><div><div><h3 class="title">31.3.6. Объединение нескольких фильтров строк <a href="#LOGICAL-REPLICATION-ROW-FILTER-COMBINING" class="id_link">#</a></h3></div></div></div><p>Если подписка связана с несколькими публикациями, в которых одна и та же таблица опубликована с разными фильтрами строк (для одной и той же операции <a class="link" href="sql-createpublication.html#SQL-CREATEPUBLICATION-WITH-PUBLISH"><code class="literal">publish</code></a>), эти выражения объединяются вместе, так что реплицироваться будут строки, удовлетворяющие <span class="emphasis"><em>любому</em></span> из выражений. Это означает, что все остальные фильтры строк для той же таблицы становятся избыточными, если: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>У одной из публикаций нет фильтра строк.</p></li><li class="listitem"><p>Одна из публикаций была создана с предложением <a class="link" href="sql-createpublication.html#SQL-CREATEPUBLICATION-FOR-ALL-TABLES"><code class="literal">FOR ALL TABLES</code></a>. Это предложение не позволяет использовать фильтры строк.</p></li><li class="listitem"><p>Одна из публикаций была создана с предложением <a class="link" href="sql-createpublication.html#SQL-CREATEPUBLICATION-FOR-TABLES-IN-SCHEMA"><code class="literal">FOR TABLES IN SCHEMA</code></a>, и целевая таблица принадлежит указанной схеме. Это предложение не позволяет использовать фильтры строк.</p></li></ul></div></div><div class="sect2" id="LOGICAL-REPLICATION-ROW-FILTER-EXAMPLES"><div class="titlepage"><div><div><h3 class="title">31.3.7. Примеры <a href="#LOGICAL-REPLICATION-ROW-FILTER-EXAMPLES" class="id_link">#</a></h3></div></div></div><p>Создайте несколько таблиц, которые будут использоваться в следующих примерах. </p><pre class="programlisting">test_pub=# CREATE TABLE t1(a int, b int, c text, PRIMARY KEY(a,c));
CREATE TABLE
test_pub=# CREATE TABLE t2(d int, e int, f int, PRIMARY KEY(d));
CREATE TABLE
test_pub=# CREATE TABLE t3(g int, h int, i int, PRIMARY KEY(g));
CREATE TABLE</pre><p>Создайте несколько публикаций. Публикация <code class="literal">p1</code> содержит одну таблицу (<code class="literal">t1</code>), и для неё определяется фильтр строк. Публикация <code class="literal">p2</code> содержит две таблицы, и фильтр строк определён для <code class="literal">t2</code>, но отсутствует для <code class="literal">t1</code>. Публикация <code class="literal">p3</code> содержит две таблицы, и фильтр строк определён для обеих. </p><pre class="programlisting">test_pub=# CREATE PUBLICATION p1 FOR TABLE t1 WHERE (a &gt; 5 AND c = 'NSW');
CREATE PUBLICATION
test_pub=# CREATE PUBLICATION p2 FOR TABLE t1, t2 WHERE (e = 99);
CREATE PUBLICATION
test_pub=# CREATE PUBLICATION p3 FOR TABLE t2 WHERE (d = 10), t3 WHERE (g = 10);
CREATE PUBLICATION</pre><p>Выражения фильтров строк для каждой публикации можно просмотреть в <code class="command">psql</code>. </p><pre class="programlisting">test_pub=# \dRp+
                               Publication p1
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Via root
----------+------------+---------+---------+---------+-----------+----------
 postgres | f          | t       | t       | t       | t         | f
Tables:
    "public.t1" WHERE ((a &gt; 5) AND (c = 'NSW'::text))

                               Publication p2
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Via root
----------+------------+---------+---------+---------+-----------+----------
 postgres | f          | t       | t       | t       | t         | f
Tables:
    "public.t1"
    "public.t2" WHERE (e = 99)

                               Publication p3
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Via root
----------+------------+---------+---------+---------+-----------+----------
 postgres | f          | t       | t       | t       | t         | f
Tables:
    "public.t2" WHERE (d = 10)
    "public.t3" WHERE (g = 10)</pre><p>Также в <code class="command">psql</code> можно просмотреть выражения фильтров строк для каждой таблицы. Обратите внимание: таблица <code class="literal">t1</code> является членом двух публикаций, но имеет фильтр строк только в <code class="literal">p1</code>, а таблица <code class="literal">t2</code> является членом двух публикаций и имеет в них разные фильтры строк. </p><pre class="programlisting">test_pub=# \d t1
                 Table "public.t1"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 a      | integer |           | not null |
 b      | integer |           |          |
 c      | text    |           | not null |
Indexes:
    "t1_pkey" PRIMARY KEY, btree (a, c)
Publications:
    "p1" WHERE ((a &gt; 5) AND (c = 'NSW'::text))
    "p2"

test_pub=# \d t2
                 Table "public.t2"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 d      | integer |           | not null |
 e      | integer |           |          |
 f      | integer |           |          |
Indexes:
    "t2_pkey" PRIMARY KEY, btree (d)
Publications:
    "p2" WHERE (e = 99)
    "p3" WHERE (d = 10)

test_pub=# \d t3
                 Table "public.t3"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 g      | integer |           | not null |
 h      | integer |           |          |
 i      | integer |           |          |
Indexes:
    "t3_pkey" PRIMARY KEY, btree (g)
Publications:
    "p3" WHERE (g = 10)</pre><p>Создайте на сервере подписчика таблицу <code class="literal">t1</code> с тем же определением, что и на публикующем сервере, а также создайте подписку <code class="literal">s1</code>, связанную с публикацией <code class="literal">p1</code>. </p><pre class="programlisting">test_sub=# CREATE TABLE t1(a int, b int, c text, PRIMARY KEY(a,c));
CREATE TABLE
test_sub=# CREATE SUBSCRIPTION s1
test_sub-# CONNECTION 'host=localhost dbname=test_pub application_name=s1'
test_sub-# PUBLICATION p1;
CREATE SUBSCRIPTION</pre><p>Вставьте несколько строк. Реплицироваться будут только строки, соответствующие предложению <code class="literal">t1 WHERE</code> публикации <code class="literal">p1</code>. </p><pre class="programlisting">test_pub=# INSERT INTO t1 VALUES (2, 102, 'NSW');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (3, 103, 'QLD');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (4, 104, 'VIC');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (5, 105, 'ACT');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (6, 106, 'NSW');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (7, 107, 'NT');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (8, 108, 'QLD');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (9, 109, 'NSW');
INSERT 0 1

test_pub=# SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 2 | 102 | NSW
 3 | 103 | QLD
 4 | 104 | VIC
 5 | 105 | ACT
 6 | 106 | NSW
 7 | 107 | NT
 8 | 108 | QLD
 9 | 109 | NSW
(8 rows)</pre><p> </p><pre class="programlisting">test_sub=# SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 6 | 106 | NSW
 9 | 109 | NSW
(2 rows)</pre><p>Измените некоторые данные, в которых и старое, и новое значения строки соответствуют условию <code class="literal">t1 WHERE</code> публикации <code class="literal">p1</code>. Операция <code class="command">UPDATE</code> будет реплицировать изменения как обычно. </p><pre class="programlisting">test_pub=# UPDATE t1 SET b = 999 WHERE a = 6;
UPDATE 1

test_pub=# SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 2 | 102 | NSW
 3 | 103 | QLD
 4 | 104 | VIC
 5 | 105 | ACT
 7 | 107 | NT
 8 | 108 | QLD
 9 | 109 | NSW
 6 | 999 | NSW
(8 rows)</pre><p> </p><pre class="programlisting">test_sub=# SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 9 | 109 | NSW
 6 | 999 | NSW
(2 rows)</pre><p>Измените некоторые данные, в которых старые значения строк не соответствуют условию <code class="literal">t1 WHERE</code> публикации <code class="literal">p1</code>, а новые значения строк — соответствуют. Операция <code class="command">UPDATE</code> будет преобразована в <code class="command">INSERT</code> и реплицируется в таком виде. Посмотрите на новую строку в таблице подписчика. </p><pre class="programlisting">test_pub=# UPDATE t1 SET a = 555 WHERE a = 2;
UPDATE 1

test_pub=# SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   3 | 103 | QLD
   4 | 104 | VIC
   5 | 105 | ACT
   7 | 107 | NT
   8 | 108 | QLD
   9 | 109 | NSW
   6 | 999 | NSW
 555 | 102 | NSW
(8 rows)</pre><p> </p><pre class="programlisting">test_sub=# SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   9 | 109 | NSW
   6 | 999 | NSW
 555 | 102 | NSW
(3 rows)</pre><p>Измените некоторые данные, в которых старые значения строк соответствуют условию <code class="literal">t1 WHERE</code> публикации <code class="literal">p1</code>, а новые значения — не соответствуют. Операция <code class="command">UPDATE</code> будет преобразована в <code class="command">DELETE</code> и реплицируется в таком виде. Обратите внимание, строка была удалена из таблицы подписчика. </p><pre class="programlisting">test_pub=# UPDATE t1 SET c = 'VIC' WHERE a = 9;
UPDATE 1

test_pub=# SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   3 | 103 | QLD
   4 | 104 | VIC
   5 | 105 | ACT
   7 | 107 | NT
   8 | 108 | QLD
   6 | 999 | NSW
 555 | 102 | NSW
   9 | 109 | VIC
(8 rows)</pre><p> </p><pre class="programlisting">test_sub=# SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   6 | 999 | NSW
 555 | 102 | NSW
(2 rows)</pre><p>Следующие примеры показывают, как в зависимости от параметра публикации <a class="link" href="sql-createpublication.html#SQL-CREATEPUBLICATION-WITH-PUBLISH-VIA-PARTITION-ROOT"><code class="literal">publish_via_partition_root</code></a> для секционированных таблиц используется фильтр строк родительской или дочерней таблицы.</p><p>Создайте секционированную таблицу на публикующем сервере. </p><pre class="programlisting">test_pub=# CREATE TABLE parent(a int PRIMARY KEY) PARTITION BY RANGE(a);
CREATE TABLE
test_pub=# CREATE TABLE child PARTITION OF parent DEFAULT;
CREATE TABLE</pre><p> Создайте такую же конфигурацию таблиц на подписчике. </p><pre class="programlisting">test_sub=# CREATE TABLE parent(a int PRIMARY KEY) PARTITION BY RANGE(a);
CREATE TABLE
test_sub=# CREATE TABLE child PARTITION OF parent DEFAULT;
CREATE TABLE</pre><p>Создайте публикацию <code class="literal">p4</code>, а затем подпишитесь на неё. Параметр публикации <code class="literal">publish_via_partition_root</code> имеет значение true. При этом определяются фильтры строк для секционированной таблицы (<code class="literal">parent</code>) и для её секции (<code class="literal">child</code>). </p><pre class="programlisting">test_pub=# CREATE PUBLICATION p4 FOR TABLE parent WHERE (a &lt; 5), child WHERE (a &gt;= 5)
test_pub-# WITH (publish_via_partition_root=true);
CREATE PUBLICATION</pre><p> </p><pre class="programlisting">test_sub=# CREATE SUBSCRIPTION s4
test_sub-# CONNECTION 'host=localhost dbname=test_pub application_name=s4'
test_sub-# PUBLICATION p4;
CREATE SUBSCRIPTION</pre><p>Вставьте некоторые значения непосредственно в таблицы <code class="literal">parent</code> и <code class="literal">child</code>. При их репликации будет использоваться фильтр строк <code class="literal">parent</code> (так как <code class="literal">publish_via_partition_root</code> имеет значение true). </p><pre class="programlisting">test_pub=# INSERT INTO parent VALUES (2), (4), (6);
INSERT 0 3
test_pub=# INSERT INTO child VALUES (3), (5), (7);
INSERT 0 3

test_pub=# SELECT * FROM parent ORDER BY a;
 a
---
 2
 3
 4
 5
 6
 7
(6 rows)</pre><p> </p><pre class="programlisting">test_sub=# SELECT * FROM parent ORDER BY a;
 a
---
 2
 3
 4
(3 rows)</pre><p>Повторите ту же проверку с другим значением <code class="literal">publish_via_partition_root</code>. Теперь параметр публикации <code class="literal">publish_via_partition_root</code> будет иметь значение false, а фильтр строк будет определён в секции (<code class="literal">child</code>). </p><pre class="programlisting">test_pub=# DROP PUBLICATION p4;
DROP PUBLICATION
test_pub=# CREATE PUBLICATION p4 FOR TABLE parent, child WHERE (a &gt;= 5)
test_pub-# WITH (publish_via_partition_root=false);
CREATE PUBLICATION</pre><p> </p><pre class="programlisting">test_sub=# ALTER SUBSCRIPTION s4 REFRESH PUBLICATION;
ALTER SUBSCRIPTION</pre><p>Выполните на публикующем сервере те же операции INSERT. Они реплицируются с использованием фильтра строк в таблице <code class="literal">child</code> (так как <code class="literal">publish_via_partition_root</code> имеет значение false). </p><pre class="programlisting">test_pub=# TRUNCATE parent;
TRUNCATE TABLE
test_pub=# INSERT INTO parent VALUES (2), (4), (6);
INSERT 0 3
test_pub=# INSERT INTO child VALUES (3), (5), (7);
INSERT 0 3

test_pub=# SELECT * FROM parent ORDER BY a;
 a
---
 2
 3
 4
 5
 6
 7
(6 rows)</pre><p> </p><pre class="programlisting">test_sub=# SELECT * FROM child ORDER BY a;
 a
---
 5
 6
 7
(3 rows)</pre></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="logical-replication-subscription.html" title="31.2. Подписка">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="logical-replication.html" title="Глава 31. Логическая репликация">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="logical-replication-col-lists.html" title="31.4. Списки столбцов">След.</a></td></tr><tr><td width="40%" align="left" valign="top">31.2. Подписка </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 31.4. Списки столбцов</td></tr></table></div></body></html>