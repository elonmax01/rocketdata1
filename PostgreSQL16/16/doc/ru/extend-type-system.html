<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>38.2. Система типов PostgreSQL</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="extend-how.html" title="38.1. Как реализована расширяемость" /><link rel="next" href="xfunc.html" title="38.3. Пользовательские функции" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">38.2. Система типов <span class="productname">PostgreSQL</span></th></tr><tr><td width="10%" align="left"><a accesskey="p" href="extend-how.html" title="38.1. Как реализована расширяемость">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="extend.html" title="Глава 38. Расширение SQL">Наверх</a></td><th width="60%" align="center">Глава 38. Расширение <acronym class="acronym">SQL</acronym></th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="xfunc.html" title="38.3. Пользовательские функции">След.</a></td></tr></table><hr /></div><div class="sect1" id="EXTEND-TYPE-SYSTEM"><div class="titlepage"><div><div><h2 class="title" style="clear: both">38.2. Система типов <span class="productname">PostgreSQL</span> <a href="#EXTEND-TYPE-SYSTEM" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="extend-type-system.html#EXTEND-TYPE-SYSTEM-BASE">38.2.1. Базовые типы</a></span></dt><dt><span class="sect2"><a href="extend-type-system.html#EXTEND-TYPE-SYSTEM-CONTAINER">38.2.2. Типы-контейнеры</a></span></dt><dt><span class="sect2"><a href="extend-type-system.html#EXTEND-TYPE-SYSTEM-DOMAINS">38.2.3. Домены</a></span></dt><dt><span class="sect2"><a href="extend-type-system.html#EXTEND-TYPE-SYSTEM-PSEUDO">38.2.4. Псевдотипы</a></span></dt><dt><span class="sect2"><a href="extend-type-system.html#EXTEND-TYPES-POLYMORPHIC">38.2.5. Полиморфные типы</a></span></dt></dl></div><a id="id-1.8.3.5.2" class="indexterm"></a><a id="id-1.8.3.5.3" class="indexterm"></a><a id="id-1.8.3.5.4" class="indexterm"></a><a id="id-1.8.3.5.5" class="indexterm"></a><a id="id-1.8.3.5.6" class="indexterm"></a><a id="id-1.8.3.5.7" class="indexterm"></a><p>Типы данных <span class="productname">PostgreSQL</span> делятся на базовые, типы-контейнеры, составные, доменные и псевдотипы.</p><div class="sect2" id="EXTEND-TYPE-SYSTEM-BASE"><div class="titlepage"><div><div><h3 class="title">38.2.1. Базовые типы <a href="#EXTEND-TYPE-SYSTEM-BASE" class="id_link">#</a></h3></div></div></div><p>Базовые типы — это типы, такие как <code class="type">integer</code>, которые реализуются ниже уровня языка <acronym class="acronym">SQL</acronym> (обычно на низкоуровневом языке, например C). В общих чертах они соответствуют так называемым абстрактным типам данных. <span class="productname">PostgreSQL</span> может работать с такими типами только через функции, предоставленные пользователем, и понимать их поведение только в той степени, в какой его опишет пользователь. Встроенные базовые типы описываются в <a class="xref" href="datatype.html" title="Глава 8. Типы данных">Главе 8</a>.</p><p>Типы-перечисления (enum) можно считать подкатегорией базовых типов. Они отличаются от других типов тем, что их можно создавать просто командами <acronym class="acronym">SQL</acronym>, обходясь без низкоуровневого программирования. За подробностями обратитесь к <a class="xref" href="datatype-enum.html" title="8.7. Типы перечислений">Разделу 8.7</a>.</p></div><div class="sect2" id="EXTEND-TYPE-SYSTEM-CONTAINER"><div class="titlepage"><div><div><h3 class="title">38.2.2. Типы-контейнеры <a href="#EXTEND-TYPE-SYSTEM-CONTAINER" class="id_link">#</a></h3></div></div></div><p>В <span class="productname">PostgreSQL</span> есть три вида <span class="quote">«<span class="quote">типов-контейнеров</span>»</span>, то есть типов, которые могут содержать в себе несколько значений других типов. Это массивы, составные типы и диапазоны.</p><p>Массивы могут содержать множество значений, имеющих один тип. Тип массива автоматически создаётся для каждого базового и составного типа, диапазона и домена, но не для массивов — массивы массивов не существуют. Для системы типов многомерные массивы не отличаются от одномерных. За дополнительными сведениями обратитесь к <a class="xref" href="arrays.html" title="8.15. Массивы">Разделу 8.15</a>.</p><p>Составные типы, или типы строк, образуются при создании любой таблицы. С помощью команды <a class="xref" href="sql-createtype.html" title="CREATE TYPE"><span class="refentrytitle">CREATE TYPE</span></a> также можно определить <span class="quote">«<span class="quote">независимый</span>»</span> составной тип, не связанный с таблицей. Составной тип представляет собой просто список типов с определёнными именами полей. Значением составного типа является строка таблицы или запись из значений полей. За дополнительными сведениями обратитесь к <a class="xref" href="rowtypes.html" title="8.16. Составные типы">Разделу 8.16</a>.</p><p>Диапазонный тип может содержать два значения одного типа, которые определяют нижнюю и верхнюю границу диапазона. Диапазонные типы создаются пользователем, хотя существует и несколько встроенных. За дополнительными сведениями обратитесь к <a class="xref" href="rangetypes.html" title="8.17. Диапазонные типы">Разделу 8.17</a>.</p></div><div class="sect2" id="EXTEND-TYPE-SYSTEM-DOMAINS"><div class="titlepage"><div><div><h3 class="title">38.2.3. Домены <a href="#EXTEND-TYPE-SYSTEM-DOMAINS" class="id_link">#</a></h3></div></div></div><p>Домен основывается на определённом нижележащем типе и во многих аспектах взаимозаменяем с ним. Однако домен может иметь ограничения, уменьшающие множество допустимых для него значений относительно нижележащего типа. Домены создаются <acronym class="acronym">SQL</acronym>-командой <a class="xref" href="sql-createdomain.html" title="CREATE DOMAIN"><span class="refentrytitle">CREATE DOMAIN</span></a>. За дополнительными сведениями обратитесь к <a class="xref" href="domains.html" title="8.18. Типы доменов">Разделу 8.18</a>.</p></div><div class="sect2" id="EXTEND-TYPE-SYSTEM-PSEUDO"><div class="titlepage"><div><div><h3 class="title">38.2.4. Псевдотипы <a href="#EXTEND-TYPE-SYSTEM-PSEUDO" class="id_link">#</a></h3></div></div></div><p>Для специальных целей существует также несколько <span class="quote">«<span class="quote">псевдотипов</span>»</span>. Псевдотипы нельзя задействовать в столбцах таблицы или в типах-контейнерах, но их можно использовать в объявлениях аргументов и результатов функций. Это даёт возможность выделить в системе типов специальные классы функций. Все существующие псевдотипы перечислены в <a class="xref" href="datatype-pseudo.html#DATATYPE-PSEUDOTYPES-TABLE" title="Таблица 8.27. Псевдотипы">Таблице 8.27</a>.</p></div><div class="sect2" id="EXTEND-TYPES-POLYMORPHIC"><div class="titlepage"><div><div><h3 class="title">38.2.5. Полиморфные типы <a href="#EXTEND-TYPES-POLYMORPHIC" class="id_link">#</a></h3></div></div></div><a id="id-1.8.3.5.13.2" class="indexterm"></a><a id="id-1.8.3.5.13.3" class="indexterm"></a><a id="id-1.8.3.5.13.4" class="indexterm"></a><a id="id-1.8.3.5.13.5" class="indexterm"></a><p>Особый интерес представляет подмножество псевдотипов, <em class="firstterm">полиморфные типы</em>, которые применяются в объявлениях <em class="firstterm">полиморфных функций</em>. Используя такие типы, можно объявить всего одну функцию, которая будет работать с разными типами данных, определяя конкретные типы в зависимости от того, значения каких типов были переданы ей при вызове. Полиморфные типы перечислены в <a class="xref" href="extend-type-system.html#EXTEND-TYPES-POLYMORPHIC-TABLE" title="Таблица 38.1. Полиморфные типы">Таблице 38.1</a>. Некоторые примеры их использования показаны в <a class="xref" href="xfunc-sql.html#XFUNC-SQL-POLYMORPHIC-FUNCTIONS" title="38.5.11. Полиморфные функции SQL">Подразделе 38.5.11</a>.</p><div class="table" id="EXTEND-TYPES-POLYMORPHIC-TABLE"><p class="title"><strong>Таблица 38.1. Полиморфные типы</strong></p><div class="table-contents"><table class="table" summary="Полиморфные типы" border="1"><colgroup><col class="col1" /><col class="col2" /><col class="col3" /></colgroup><thead><tr><th>Name</th><th>Семейство</th><th>Описание</th></tr></thead><tbody><tr><td><code class="type">anyelement</code></td><td>Простое</td><td>Указывает, что функция принимает любой тип</td></tr><tr><td><code class="type">anyarray</code></td><td>Простое</td><td>Указывает, что функция принимает любой тип массива</td></tr><tr><td><code class="type">anynonarray</code></td><td>Простое</td><td>Указывает, что функция принимает любой тип, отличный от массива</td></tr><tr><td><code class="type">anyenum</code></td><td>Простое</td><td>Указывает, что функция принимает любой тип-перечисление (см. <a class="xref" href="datatype-enum.html" title="8.7. Типы перечислений">Раздел 8.7</a>)</td></tr><tr><td><code class="type">anyrange</code></td><td>Простое</td><td>Указывает, что функция принимает любой диапазонный тип (см. <a class="xref" href="rangetypes.html" title="8.17. Диапазонные типы">Раздел 8.17</a>)</td></tr><tr><td><code class="type">anymultirange</code></td><td>Простое</td><td>Указывает, что функция принимает любой мультидиапазонный тип (см. <a class="xref" href="rangetypes.html" title="8.17. Диапазонные типы">Раздел 8.17</a>)</td></tr><tr><td><code class="type">anycompatible</code></td><td>Общее</td><td>Указывает, что функция принимает любой тип, с автоматическим приведением нескольких аргументов к общему типу</td></tr><tr><td><code class="type">anycompatiblearray</code></td><td>Общее</td><td>Указывает, что функция принимает любой тип массива, с автоматическим приведением нескольких аргументов к общему типу</td></tr><tr><td><code class="type">anycompatiblenonarray</code></td><td>Общее</td><td>Указывает, что функция принимает любой тип, отличный от массива, с автоматическим приведением нескольких аргументов к общему типу</td></tr><tr><td><code class="type">anycompatiblerange</code></td><td>Общее</td><td>Указывает, что функция принимает любой диапазонный тип, с автоматическим приведением нескольких аргументов к общему типу</td></tr><tr><td><code class="type">anycompatiblemultirange</code></td><td>Общее</td><td>Указывает, что функция принимает любой мультидиапазонный тип данных и может автоматически приводить различные аргументы к общему типу данных</td></tr></tbody></table></div></div><br class="table-break" /><p>Полиморфные аргументы и результаты связаны друг с другом и сводятся к конкретным типам данным при разборе запроса, вызывающего полиморфную функцию. Когда полиморфных аргументов несколько, фактические типы данных входных значений должны совмещаться, как описано далее. Если тип результата функции полиморфный или у неё имеются выходные параметры полиморфных типов, фактические типы этих результатов выводятся из типов полиморфных входных значений, как описано ниже.</p><p>Для <span class="quote">«<span class="quote">простого</span>»</span> семейства полиморфных типов действуют следующие правила совмещения и выведения типов:</p><p>В каждой позиции (в аргументах или возвращаемом значении), объявленной как <code class="type">anyelement</code>, может передаваться любой фактический тип данных, но в каждом конкретном вызове все эти фактические типы должны быть <span class="emphasis"><em>одинаковыми</em></span>. Аналогичным образом, в каждой позиции, объявленной как <code class="type">anyarray</code>, может передаваться любой тип данных массива, но все фактические типы должны совпадать. Так же и во всех позициях, объявленных как <code class="type">anyrange</code>, должен передаваться одинаковый диапазонный тип, а в объявленных как <code class="type">anymultirange</code> — одинаковый мультидиапазонный тип.</p><p>Более того, если некоторые позиции объявлены как <code class="type">anyarray</code>, а другие как <code class="type">anyelement</code>, то фактическим типом в позициях <code class="type">anyarray</code> должен быть массив, элементы которого имеют тот же тип, что и значения в позициях <code class="type">anyelement</code>. Псевдотип <code class="type">anynonarray</code> обрабатывается так же, как <code class="type">anyelement</code>, но с дополнительным ограничением — фактический тип не должен быть типом массива. Псевдотип <code class="type">anyenum</code> тоже обрабатывается как <code class="type">anyelement</code>, но его фактические типы ограничиваются перечислениями.</p><p>Подобным образом, если одни позиции объявлены как <code class="type">anyrange</code>, а другие как <code class="type">anyelement</code> или <code class="type">anyarray</code>, фактическим типом в позициях <code class="type">anyrange</code> должен быть диапазон, подтип которого совпадает с типом элементов в позициях <code class="type">anyelement</code> и с типом, передаваемым в позициях <code class="type">anyarray</code>. Если есть позиции, объявленные <code class="type">anymultirange</code>, их фактический мультидиапазонный тип должен содержать диапазоны, соответствующие объявленным параметрам <code class="type">anyrange</code>, и базовые элементы, соответствующие параметрам, объявленным <code class="type">anyelement</code> и <code class="type">anyarray</code>.</p><p>Таким образом, когда с полиморфным типом объявлено несколько аргументов, в итоге допускаются только определённые комбинации фактических типов. Например, функция, объявленная как <code class="literal">equal(anyelement, anyelement)</code>, примет в аргументах любые два значения, но только если их типы данных совпадают.</p><p>Когда с полиморфным типом объявлено возвращаемое значение функции, так же полиморфным должен быть минимум один аргумент, и фактический тип результата при конкретном вызове определится по типу фактически переданного полиморфного аргумента (или аргументов). Например, если бы отсутствовал механизм обращения к элементам массива, его можно было бы реализовать, создав функцию <code class="literal">subscript(anyarray, integer) returns anyelement</code>. С таким объявлением первым фактическим аргументом должен быть массив, и из него будет выведен правильный тип результата при разборе запроса. В качестве другого примера можно привести функцию <code class="literal">f(anyarray) returns anyenum</code>, которая будет принимать только массивы перечислений.</p><p>В большинстве случаев при разборе функции фактический тип данных для полиморфного результата может быть выведен из аргументов, имеющих другой полиморфный тип из того же семейства; например, подтип <code class="type">anyarray</code> может выводиться из <code class="type">anyelement</code> и наоборот. Исключение представляет полиморфный результат типа <code class="type">anyrange</code> — для него требуется аргумент типа <code class="type">anyrange</code>; вывести его фактический тип из типа аргументов <code class="type">anyarray</code> или <code class="type">anyelement</code> нельзя. Это объясняется тем, что на одном подтипе могут базироваться несколько диапазонных типов.</p><p>Заметьте, что <code class="type">anynonarray</code> и <code class="type">anyenum</code> представляют не отдельные типы переменных; это те же типы, что и <code class="type">anyelement</code>, но с дополнительными ограничениями. Например, объявление функции <code class="literal">f(anyelement, anyenum)</code> равнозначно объявлению <code class="literal">f(anyenum, anyenum)</code>: оба фактических аргумента должны быть одинаковыми типами-перечислениями.</p><p>Для <span class="quote">«<span class="quote">общего</span>»</span> семейства полиморфных типов работают примерно те же правила совмещения и выведения типов, что и для <span class="quote">«<span class="quote">простого</span>»</span> семейства, но есть одно важно отличие: фактические типы аргументов не должны совпадать, если они могут быть неявно приведены к некоторому общему типу. Этот общий тип выбирается по тем же правилам, что применяются в <code class="literal">UNION</code> и подобных конструкциях (см. <a class="xref" href="typeconv-union-case.html" title="10.5. UNION, CASE и связанные конструкции">Раздел 10.5</a>). При выборе общего типа учитываются фактические типы аргументов <code class="type">anycompatible</code> и <code class="type">anycompatiblenonarray</code>, типы элементов в аргументах <code class="type">anycompatiblearray</code>, подтипы диапазонов в аргументах <code class="type">anycompatiblerange</code> и подтипы мультидиапазонов в аргументах <code class="type">anycompatiblemultirange</code>. Если присутствует тип <code class="type">anycompatiblenonarray</code>, общим типом не должен быть тип массива. После того как общий тип определён, аргументы <code class="type">anycompatible</code> и <code class="type">anycompatiblenonarray</code> автоматически приводятся к этому типу, а аргументы <code class="type">anycompatiblearray</code> приводятся к типу-массиву с элементами этого типа.</p><p>Так как невозможно выбрать диапазонный тип, зная только его подтип, при использовании <code class="type">anycompatiblerange</code> и/или <code class="type">anycompatiblemultirange</code> необходимо, чтобы все аргументы, объявленные с этим типом, имели один диапазонный и/или мультидиапазонный тип, а его подтип соответствовал выбранному общему типу, что позволяет обойтись без приведения типов для диапазонных значений. Как и в случае с типами <code class="type">anyrange</code> и <code class="type">anymultirange</code>, типы <code class="type">anycompatiblerange</code> и <code class="type">anycompatiblemultirange</code> можно использовать в качестве типа результата функции, только если у неё имеется аргумент того же типа (<code class="type">anycompatiblerange</code> или <code class="type">anycompatiblemultirange</code>).</p><p>Заметьте, что типа <code class="type">anycompatibleenum</code> не существует. Такой тип был бы не очень полезным, так как никаких неявных приведений к типам-перечислениям обычно нет, то есть не существует способа найти общий тип для двух различных перечислений.</p><p>Полиморфные семейства <span class="quote">«<span class="quote">простое</span>»</span> и <span class="quote">«<span class="quote">общее</span>»</span> представляют два независимых набора переменных типов. Рассмотрите, например, объявление: </p><pre class="programlisting">CREATE FUNCTION myfunc(a anyelement, b anyelement,
                       c anycompatible, d anycompatible)
RETURNS anycompatible AS ...</pre><p> Когда эта функция вызывается, первые два аргумента обязательно должны иметь один и тот же тип. Последние два аргумента должны быть приводимыми к общему типу, причём этот тип может не совпадать с типом первых двух аргументов. Этот общий тип станет типом результата.</p><p>Функции с переменным числом аргументом (описанные в <a class="xref" href="xfunc-sql.html#XFUNC-SQL-VARIADIC-FUNCTIONS" title="38.5.6. Функции SQL с переменным числом аргументов">Подразделе 38.5.6</a>) тоже могут быть полиморфными: для этого их последний параметр описывается как <code class="literal">VARIADIC</code> <code class="type">anyarray</code> или <code class="literal">VARIADIC</code> <code class="type">anycompatiblearray</code>. Для целей сопоставления аргументов и определения фактического типа результата такая функция представляется так же, как если бы в ней явно объявлялось нужное число параметров <code class="type">anynonarray</code> или <code class="type">anycompatiblenonarray</code>.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="extend-how.html" title="38.1. Как реализована расширяемость">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="extend.html" title="Глава 38. Расширение SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="xfunc.html" title="38.3. Пользовательские функции">След.</a></td></tr><tr><td width="40%" align="left" valign="top">38.1. Как реализована расширяемость </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 38.3. Пользовательские функции</td></tr></table></div></body></html>