<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>15.2. Когда может применяться распараллеливание запросов?</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="how-parallel-query-works.html" title="15.1. Как работают параллельно выполняемые запросы" /><link rel="next" href="parallel-plans.html" title="15.3. Параллельные планы" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">15.2. Когда может применяться распараллеливание запросов?</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="how-parallel-query-works.html" title="15.1. Как работают параллельно выполняемые запросы">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="parallel-query.html" title="Глава 15. Параллельный запрос">Наверх</a></td><th width="60%" align="center">Глава 15. Параллельный запрос</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="parallel-plans.html" title="15.3. Параллельные планы">След.</a></td></tr></table><hr /></div><div class="sect1" id="WHEN-CAN-PARALLEL-QUERY-BE-USED"><div class="titlepage"><div><div><h2 class="title" style="clear: both">15.2. Когда может применяться распараллеливание запросов? <a href="#WHEN-CAN-PARALLEL-QUERY-BE-USED" class="id_link">#</a></h2></div></div></div><p>Планировщик запросов может отказаться от построения параллельных планов запросов в любом случае под влиянием нескольких параметров. Чтобы он строил параллельные планы запросов при каких-бы то ни было условиях, описанные далее параметры необходимо настроить указанным образом.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS-PER-GATHER">max_parallel_workers_per_gather</a> должен иметь значение, большее нуля. Это особый вариант более общего ограничения на суммарное число используемых рабочих процессов, задаваемого параметром <code class="varname">max_parallel_workers_per_gather</code>.</p></li></ul></div><p>В дополнение к этому, система должна работать не в однопользовательском режиме. Так как в этом режиме вся СУБД работает как один процесс, фоновые рабочие процессы в нём недоступны.</p><p>Даже если принципиально возможно построить параллельные планы выполнения, планировщик не будет строить такой план для определённого запроса, если имеет место одно из следующих обстоятельств:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Запрос выполняет запись данных или блокирует строки в базе данных. Если запрос содержит операцию, изменяющую данные либо на верхнем уровне, либо внутри CTE, для такого запроса не будут строиться параллельные планы. Исключение составляют следующие команды, которые создают новую таблицу, наполняют её и при этом могут использовать параллельный план для команды <code class="literal">SELECT</code>, выполняемой внутри запроса: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><code class="command">CREATE TABLE ... AS</code></p></li><li class="listitem"><p><code class="command">SELECT INTO</code></p></li><li class="listitem"><p><code class="command">CREATE MATERIALIZED VIEW</code></p></li><li class="listitem"><p><code class="command">REFRESH MATERIALIZED VIEW</code></p></li></ul></div></li><li class="listitem"><p>Запрос может быть приостановлен в процессе выполнения. В ситуациях, когда система решает, что может иметь место частичное или дополнительное выполнение, план параллельного выполнения не строится. Например, курсор, созданный предложением <a class="link" href="sql-declare.html" title="DECLARE">DECLARE CURSOR</a>, никогда не будет использовать параллельный план. Подобным образом, цикл PL/pgSQL вида <code class="literal">FOR x IN query LOOP .. END LOOP</code> никогда не будет использовать параллельный план, так как система параллельных запросов не сможет определить, может ли безопасно выполняться код внутри цикла во время параллельного выполнения запроса.</p></li><li class="listitem"><p>В запросе используются функции, помеченные как <code class="literal">PARALLEL UNSAFE</code>. Большинство системных функций безопасны для параллельного выполнения (<code class="literal">PARALLEL SAFE</code>), но пользовательские функции по умолчанию помечаются как небезопасные (<code class="literal">PARALLEL UNSAFE</code>). Эта характеристика функции рассматривается в <a class="xref" href="parallel-safety.html" title="15.4. Безопасность распараллеливания">Разделе 15.4</a>.</p></li><li class="listitem"><p>Запрос работает внутри другого запроса, уже параллельного. Например, если функция, вызываемая в параллельном запросе, сама выполняет SQL-запрос, последний запрос никогда не будет выполняться параллельно. Это ограничение текущей реализации, но убирать его вряд ли следует, так как это может привести к использованию одним запросом чрезмерного количества процессов.</p></li></ul></div><p>Даже когда для определённого запроса построен параллельный план, возможны различные обстоятельства, при которых этот план нельзя будет выполнить в параллельном режиме. В этих случаях ведущий процесс выполнит часть плана ниже узла <code class="literal">Gather</code> полностью самостоятельно, как если бы узла <code class="literal">Gather</code> вовсе не было. Это произойдёт только при выполнении одного из следующих условий:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Невозможно получить ни одного фонового рабочего процесса из-за ограничения общего числа этих процессов значением <a class="xref" href="runtime-config-resource.html#GUC-MAX-WORKER-PROCESSES">max_worker_processes</a>.</p></li><li class="listitem"><p>Невозможно получить ни одного фонового рабочего процесса из-за ограничения общего числа таких процессов для параллельного выполнения значением <a class="xref" href="runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS">max_parallel_workers</a>.</p></li><li class="listitem"><p>Клиент передаёт сообщение Execute с ненулевым количеством выбираемых кортежей. За подробностями обратитесь к описанию <a class="link" href="protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY" title="55.2.3. Расширенное выполнение запросов">расширенного протокола запросов</a>. Так как <a class="link" href="libpq.html" title="Глава 34. libpq — библиотека для языка C">libpq</a> в настоящее время не позволяет передавать такие сообщения, это возможно только с клиентом, задействующим не libpq. Если это происходит часто, имеет смысл установить в <a class="xref" href="runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS-PER-GATHER">max_parallel_workers_per_gather</a> 0 в сеансах, для которых это актуально, чтобы система не пыталась строить планы, которые могут быть неэффективны при последовательном выполнении.</p></li></ul></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="how-parallel-query-works.html" title="15.1. Как работают параллельно выполняемые запросы">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="parallel-query.html" title="Глава 15. Параллельный запрос">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="parallel-plans.html" title="15.3. Параллельные планы">След.</a></td></tr><tr><td width="40%" align="left" valign="top">15.1. Как работают параллельно выполняемые запросы </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 15.3. Параллельные планы</td></tr></table></div></body></html>