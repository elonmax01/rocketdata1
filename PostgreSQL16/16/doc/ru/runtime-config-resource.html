<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>20.4. Потребление ресурсов</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="runtime-config-connection.html" title="20.3. Подключения и аутентификация" /><link rel="next" href="runtime-config-wal.html" title="20.5. Журнал предзаписи" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">20.4. Потребление ресурсов</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="runtime-config-connection.html" title="20.3. Подключения и аутентификация">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="runtime-config.html" title="Глава 20. Настройка сервера">Наверх</a></td><th width="60%" align="center">Глава 20. Настройка сервера</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="runtime-config-wal.html" title="20.5. Журнал предзаписи">След.</a></td></tr></table><hr /></div><div class="sect1" id="RUNTIME-CONFIG-RESOURCE"><div class="titlepage"><div><div><h2 class="title" style="clear: both">20.4. Потребление ресурсов <a href="#RUNTIME-CONFIG-RESOURCE" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-MEMORY">20.4.1. Память</a></span></dt><dt><span class="sect2"><a href="runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-DISK">20.4.2. Диск</a></span></dt><dt><span class="sect2"><a href="runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-KERNEL">20.4.3. Использование ресурсов ядра</a></span></dt><dt><span class="sect2"><a href="runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-VACUUM-COST">20.4.4. Задержка очистки по стоимости</a></span></dt><dt><span class="sect2"><a href="runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-BACKGROUND-WRITER">20.4.5. Фоновая запись</a></span></dt><dt><span class="sect2"><a href="runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-ASYNC-BEHAVIOR">20.4.6. Асинхронное поведение</a></span></dt></dl></div><div class="sect2" id="RUNTIME-CONFIG-RESOURCE-MEMORY"><div class="titlepage"><div><div><h3 class="title">20.4.1. Память <a href="#RUNTIME-CONFIG-RESOURCE-MEMORY" class="id_link">#</a></h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt id="GUC-SHARED-BUFFERS"><span class="term"><code class="varname">shared_buffers</code> (<code class="type">integer</code>) <a id="id-1.6.7.7.2.2.1.1.3" class="indexterm"></a></span> <a href="#GUC-SHARED-BUFFERS" class="id_link">#</a></dt><dd><p>Задаёт объём памяти, который будет использовать сервер баз данных для буферов в разделяемой памяти. По умолчанию это обычно 128 мегабайт (<code class="literal">128MB</code>), но может быть и меньше, если конфигурация вашего ядра накладывает дополнительные ограничения (это определяется в процессе <span class="application">initdb</span>). Это значение не должно быть меньше 128 килобайт. Однако для хорошей производительности обычно требуются гораздо большие значения. Если это значение задаётся без единиц измерения, оно считается заданным в блоках (размер которых равен <code class="symbol">BLCKSZ</code> байт, обычно это 8 КБ). Минимальное допустимое значение зависит от величины <code class="symbol">BLCKSZ</code>. Задать этот параметр можно только при запуске сервера.</p><p>Если вы используете выделенный сервер с объёмом ОЗУ 1 ГБ и более, разумным начальным значением <code class="varname">shared_buffers</code> будет 25% от объёма памяти. Существуют варианты нагрузки, при которых эффективны будут и ещё большие значения <code class="varname">shared_buffers</code>, но так как <span class="productname">PostgreSQL</span> использует и кеш операционной системы, выделять для <code class="varname">shared_buffers</code> более 40% ОЗУ вряд ли будет полезно. При увеличении <code class="varname">shared_buffers</code> обычно требуется соответственно увеличить <code class="varname">max_wal_size</code>, чтобы растянуть процесс записи большого объёма новых или изменённых данных на более продолжительное время.</p><p>В системах с объёмом ОЗУ меньше 1 ГБ стоит ограничиться меньшим процентом ОЗУ, чтобы оставить достаточно места операционной системе.</p></dd><dt id="GUC-HUGE-PAGES"><span class="term"><code class="varname">huge_pages</code> (<code class="type">enum</code>) <a id="id-1.6.7.7.2.2.2.1.3" class="indexterm"></a></span> <a href="#GUC-HUGE-PAGES" class="id_link">#</a></dt><dd><p>Определяет, будут ли огромные страницы запрашиваться из основной области общей памяти. Допустимые значения: <code class="literal">try</code> (по умолчанию), <code class="literal">on</code> и <code class="literal">off</code>. Когда параметр <code class="varname">huge_pages</code> равен <code class="literal">try</code>, сервер будет пытаться запрашивать огромные страницы, но если это ему не удастся, вернётся к стандартному поведению. Со значением <code class="literal">on</code>, если получить огромные страницы не удастся, сервер не будет запущен. Со значением <code class="literal">off</code> большие страницы не будут запрашиваться.</p><p>В настоящее время это поддерживается в Linux и в Windows. В других системах значение <code class="literal">try</code> просто игнорируется. В Linux эта поддержка обеспечивается, только когда параметр <code class="varname">shared_memory_type</code> имеет значение <code class="literal">mmap</code> (по умолчанию).</p><p>В результате использования огромных страниц уменьшаются таблицы страниц, и процессор тратит меньше времени на управление памятью, что приводит к увеличению быстродействия. За более подробной информацией об использовании огромных страниц в Linux обратитесь к <a class="xref" href="kernel-resources.html#LINUX-HUGE-PAGES" title="19.4.5. Огромные страницы в Linux">Подразделу 19.4.5</a>.</p><p>Огромные страницы в Windows называются большими страницами. Чтобы использовать их, необходимо дать пользователю Windows, от имени которого работает <span class="productname">PostgreSQL</span>, право блокировать страницы. Для назначения пользователю этого права вы можете воспользоваться средством управления групповой политикой Windows (gpedit.msc). Чтобы сервер баз данных запускался в командной строке как отдельный процесс, а не как служба Windows, приглашение командной строки должно запускаться от имени администратора или должен быть отключён механизм UAC (User Access Control, Контроль учётных записей пользователей). Когда UAC включён, в обычном командном приглашении пользователь лишается права блокировать большие страницы в памяти.</p><p>Заметьте, что этот параметр влияет только на основную область общей памяти. В операционных системах, таких как Linux, FreeBSD и Illumos огромные страницы (также называемые <span class="quote">«<span class="quote">суперстраницами</span>»</span> или <span class="quote">«<span class="quote">большими</span>»</span> страницами) могут также автоматически использоваться при обычном выделении памяти, без явного запроса со стороны <span class="productname">PostgreSQL</span>. В Linux это называется <span class="quote">«<span class="quote">прозрачными огромными страницами</span>»</span><a id="id-1.6.7.7.2.2.2.2.5.5" class="indexterm"></a> (Transparent Huge Pages, THP). Известно, что это приводит к снижению быстродействия <span class="productname">PostgreSQL</span> в некоторых системах Linux у ряда пользователей, поэтому использовать этот механизм в настоящее время не рекомендуется (в отличие от явного использования <code class="varname">huge_pages</code>).</p></dd><dt id="GUC-HUGE-PAGE-SIZE"><span class="term"><code class="varname">huge_page_size</code> (<code class="type">integer</code>) <a id="id-1.6.7.7.2.2.3.1.3" class="indexterm"></a></span> <a href="#GUC-HUGE-PAGE-SIZE" class="id_link">#</a></dt><dd><p>Задаёт размер огромных страниц, если их использование включено параметром <a class="xref" href="runtime-config-resource.html#GUC-HUGE-PAGES">huge_pages</a>. Значение по умолчанию — ноль (<code class="literal">0</code>). При таком значении будет использоваться размер огромных страниц, заданный в системе по умолчанию. Этот параметр можно установить только при запуске сервера.</p><p>На современных 64-битных серверных платформах доступны, в частности, следующие размеры страниц: <code class="literal">2MB</code> и <code class="literal">1GB</code> (Intel и AMD), <code class="literal">16MB</code> и <code class="literal">16GB</code> (IBM POWER), и <code class="literal">64kB</code>, <code class="literal">2MB</code>, <code class="literal">32MB</code> и <code class="literal">1GB</code> (ARM). Подробнее использование и администрирование огромных страниц освещается в <a class="xref" href="kernel-resources.html#LINUX-HUGE-PAGES" title="19.4.5. Огромные страницы в Linux">Подразделе 19.4.5</a>.</p><p>Отличные от нуля значения в настоящее время поддерживаются только в Linux.</p></dd><dt id="GUC-TEMP-BUFFERS"><span class="term"><code class="varname">temp_buffers</code> (<code class="type">integer</code>) <a id="id-1.6.7.7.2.2.4.1.3" class="indexterm"></a></span> <a href="#GUC-TEMP-BUFFERS" class="id_link">#</a></dt><dd><p>Задаёт максимальный объём памяти, выделяемой для временных буферов в каждом сеансе. Эти существующие только в рамках сеанса буферы используются исключительно для работы с временными таблицами. Если это значение задаётся без единиц измерения, оно считается заданным в блоках (размер которых равен <code class="symbol">BLCKSZ</code> байт, обычно это 8 КБ). Значение по умолчанию — 8 мегабайт (<code class="literal">8MB</code>). (Если <code class="symbol">BLCKSZ</code> отличен от 8 КБ, значение по умолчанию корректируется пропорционально.) Этот параметр можно изменить в отдельном сеансе, но только до первого обращения к временным таблицам; после этого изменения его значения не будут влиять на текущий сеанс.</p><p>Сеанс выделяет временные буферы по мере необходимости до достижения предела, заданного параметром <code class="varname">temp_buffers</code>. Если сеанс не задействует временные буферы, то для него хранятся только дескрипторы буферов, которые занимают около 64 байт (в количестве <code class="varname">temp_buffers</code>). Однако если буфер действительно используется, он будет дополнительно занимать 8192 байта (или <code class="symbol">BLCKSZ</code> байт, в общем случае).</p></dd><dt id="GUC-MAX-PREPARED-TRANSACTIONS"><span class="term"><code class="varname">max_prepared_transactions</code> (<code class="type">integer</code>) <a id="id-1.6.7.7.2.2.5.1.3" class="indexterm"></a></span> <a href="#GUC-MAX-PREPARED-TRANSACTIONS" class="id_link">#</a></dt><dd><p>Задаёт максимальное число транзакций, которые могут одновременно находиться в <span class="quote">«<span class="quote">подготовленном</span>»</span> состоянии (см. <a class="xref" href="sql-prepare-transaction.html" title="PREPARE TRANSACTION"><span class="refentrytitle">PREPARE TRANSACTION</span></a>). При нулевом значении (по умолчанию) механизм подготовленных транзакций отключается. Задать этот параметр можно только при запуске сервера.</p><p>Если использовать транзакции не планируется, этот параметр следует обнулить, чтобы не допустить непреднамеренного создания подготовленных транзакций. Если же подготовленные транзакции применяются, то <code class="varname">max_prepared_transactions</code>, вероятно, должен быть не меньше, чем <a class="xref" href="runtime-config-connection.html#GUC-MAX-CONNECTIONS">max_connections</a>, чтобы подготовить транзакцию можно было в каждом сеансе.</p><p>Для ведомого сервера значение этого параметра должно быть больше или равно значению на ведущем. В противном случае на ведомом сервере не будут разрешены запросы.</p></dd><dt id="GUC-WORK-MEM"><span class="term"><code class="varname">work_mem</code> (<code class="type">integer</code>) <a id="id-1.6.7.7.2.2.6.1.3" class="indexterm"></a></span> <a href="#GUC-WORK-MEM" class="id_link">#</a></dt><dd><p>Задаёт базовый максимальный объём памяти, который будет использоваться во внутренних операциях при обработке запросов (например, для сортировки или хеш-таблиц), прежде чем будут задействованы временные файлы на диске. Если это значение задаётся без единиц измерения, оно считается заданным в килобайтах. Значение по умолчанию — четыре мегабайта (<code class="literal">4MB</code>). Заметьте, что в сложных запросах одновременно могут выполняться несколько операций сортировки и хеширования, и при этом примерно этот объём памяти может использоваться в каждой операции, прежде чем данные начнут вытесняться во временные файлы. Кроме того, такие операции могут выполняться одновременно в разных сеансах. Таким образом, общий объём памяти может многократно превосходить значение <code class="varname">work_mem</code>; это следует учитывать, выбирая подходящее значение. Операции сортировки используются для <code class="literal">ORDER BY</code>, <code class="literal">DISTINCT</code> и соединений слиянием. Хеш-таблицы используются при соединениях и агрегировании по хешу, мемоизации узлов, а также обработке подзапросов <code class="literal">IN</code> с применением хеша.</p><p>Операции вычисления хеша обычно более требовательны к памяти, чем равнозначные им операции сортировки. Поэтому ограничение памяти для хеш-таблиц определяется произведением <code class="varname">work_mem</code> и <code class="varname">hash_mem_multiplier</code> и может превышать обычный базовый объём <code class="varname">work_mem</code>.</p></dd><dt id="GUC-HASH-MEM-MULTIPLIER"><span class="term"><code class="varname">hash_mem_multiplier</code> (<code class="type">floating point</code>) <a id="id-1.6.7.7.2.2.7.1.3" class="indexterm"></a></span> <a href="#GUC-HASH-MEM-MULTIPLIER" class="id_link">#</a></dt><dd><p>Используется для определения максимального объёма памяти, который может выделяться для операций с хешированием. Итоговый объём определяется произведением <code class="varname">work_mem</code> и <code class="varname">hash_mem_multiplier</code>. Значение по умолчанию равно 2.0, то есть для операций с хешированием может использоваться объём, вдвое превышающий базовое значение <code class="varname">work_mem</code>.</p><p>Значение <code class="varname">hash_mem_multiplier</code> имеет смысл увеличить, когда постоянно наблюдается вытеснение данных на диск при выполнении запросов, а прямолинейное увеличение <code class="varname">work_mem</code> приводит к дефициту памяти (обычно проявляющемуся в ошибках «нехватка памяти»). В этих случаях действующее по умолчанию значение 2.0 обычно является оптимальным при смешанной нагрузке, а значения 2.0–8.0 могут быть эффективны там, где <code class="varname">work_mem</code> уже увеличено до 40 Мбайт или более.</p></dd><dt id="GUC-MAINTENANCE-WORK-MEM"><span class="term"><code class="varname">maintenance_work_mem</code> (<code class="type">integer</code>) <a id="id-1.6.7.7.2.2.8.1.3" class="indexterm"></a></span> <a href="#GUC-MAINTENANCE-WORK-MEM" class="id_link">#</a></dt><dd><p>Задаёт максимальный объём памяти для операций обслуживания БД, в частности <code class="command">VACUUM</code>, <code class="command">CREATE INDEX</code> и <code class="command">ALTER TABLE ADD FOREIGN KEY</code>. Если это значение задаётся без единиц измерения, оно считается заданным в килобайтах. Значение по умолчанию — 64 мегабайта (<code class="literal">64MB</code>). Так как в один момент времени в сеансе может выполняться только одна такая операция и обычно они не запускаются параллельно, это значение вполне может быть гораздо больше <code class="varname">work_mem</code>. Увеличение этого значения может привести к ускорению операций очистки и восстановления БД из копии.</p><p>Учтите, что когда выполняется автоочистка, этот объём может быть выделен <a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-MAX-WORKERS">autovacuum_max_workers</a> раз, поэтому не стоит устанавливать значение по умолчанию слишком большим. Возможно, будет лучше управлять объёмом памяти для автоочистки отдельно, изменяя <a class="xref" href="runtime-config-resource.html#GUC-AUTOVACUUM-WORK-MEM">autovacuum_work_mem</a>.</p><p>Заметьте, что для сбора идентификаторов мёртвых кортежей <code class="command">VACUUM</code> может использовать не более <code class="literal">1GB</code> памяти.</p></dd><dt id="GUC-AUTOVACUUM-WORK-MEM"><span class="term"><code class="varname">autovacuum_work_mem</code> (<code class="type">integer</code>) <a id="id-1.6.7.7.2.2.9.1.3" class="indexterm"></a></span> <a href="#GUC-AUTOVACUUM-WORK-MEM" class="id_link">#</a></dt><dd><p>Задаёт максимальный объём памяти, который будет использовать каждый рабочий процесс автоочистки. Если это значение задаётся без единиц измерения, оно считается заданным в килобайтах. При действующем по умолчанию значении <code class="literal">-1</code> этот объём определяется значением <a class="xref" href="runtime-config-resource.html#GUC-MAINTENANCE-WORK-MEM">maintenance_work_mem</a>. Этот параметр не влияет на поведение команды <code class="command">VACUUM</code>, выполняемой в других контекстах. Задать этот параметр можно только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера.</p><p>Для сбора идентификаторов мёртвых кортежей автоочистка может использовать максимум <code class="literal">1GB</code> памяти, поэтому увеличение <code class="varname">autovacuum_work_mem</code> до большего значения не повлияет на количество мёртвых кортежей, которые автоочистка может собрать при сканировании таблицы.</p></dd><dt id="GUC-VACUUM-BUFFER-USAGE-LIMIT"><span class="term"><code class="varname">vacuum_buffer_usage_limit</code> (<code class="type">integer</code>) <a id="id-1.6.7.7.2.2.10.1.3" class="indexterm"></a></span> <a href="#GUC-VACUUM-BUFFER-USAGE-LIMIT" class="id_link">#</a></dt><dd><p>Указывает размер <a class="glossterm" href="glossary.html#GLOSSARY-BUFFER-ACCESS-STRATEGY"><em class="glossterm"><a class="glossterm" href="glossary.html#GLOSSARY-BUFFER-ACCESS-STRATEGY" title="Стратегия доступа к буферу">стратегии доступа к буферам</a></em></a>, используемой командами <code class="command">VACUUM</code> и <code class="command">ANALYZE</code>. Значение <code class="literal">0</code> позволит операции использовать любое количество <code class="varname">shared_buffers</code>. В противном случае допустимые размеры варьируются от <code class="literal">128 kB</code> до <code class="literal">16 GB</code>. Если указанный размер превышает 1/8 размера <code class="varname">shared_buffers</code>, он автоматически ограничивается этим значением. Значение по умолчанию: <code class="literal">256 kB</code>. Если это значение задаётся без единиц измерения, оно считается заданным в килобайтах. Этот параметр можно задать в любой момент. Его также можно переопределить для <a class="xref" href="sql-vacuum.html" title="VACUUM"><span class="refentrytitle">VACUUM</span></a> и <a class="xref" href="sql-analyze.html" title="ANALYZE"><span class="refentrytitle">ANALYZE</span></a> при передаче параметра <code class="option">BUFFER_USAGE_LIMIT</code>. С большим значением параметра команды <code class="command">VACUUM</code> и <code class="command">ANALYZE</code> могут выполняться быстрее, но при слишком большом значении многие полезные страницы могут вытесняться из общих буферов.</p></dd><dt id="GUC-LOGICAL-DECODING-WORK-MEM"><span class="term"><code class="varname">logical_decoding_work_mem</code> (<code class="type">integer</code>) <a id="id-1.6.7.7.2.2.11.1.3" class="indexterm"></a></span> <a href="#GUC-LOGICAL-DECODING-WORK-MEM" class="id_link">#</a></dt><dd><p>Задаёт максимальный объём памяти, используемой для логического декодирования, после превышения которого некоторые декодированные изменения будут вымещаться на локальный диск. Тем самым ограничивается объём памяти, используемой подключениями потоковой логической репликации. По умолчанию его значение — 64 мегабайта (<code class="literal">64MB</code>). Так как каждое подключение репликации использует один буфер заданного размера, а количество таких подключений к одному серверу обычно невелико (оно ограничивается значением <code class="varname">max_wal_senders</code>), значение данного параметра вполне можно сделать достаточно большим, намного превышающим <code class="varname">work_mem</code>, чтобы минимизировать объём вымещаемых на диск декодируемых изменений.</p></dd><dt id="GUC-MAX-STACK-DEPTH"><span class="term"><code class="varname">max_stack_depth</code> (<code class="type">integer</code>) <a id="id-1.6.7.7.2.2.12.1.3" class="indexterm"></a></span> <a href="#GUC-MAX-STACK-DEPTH" class="id_link">#</a></dt><dd><p>Задаёт максимальную безопасную глубину стека для исполнителя. В идеале это значение должно равняться предельному размеру стека, ограниченному ядром (который устанавливается командой <code class="literal">ulimit -s</code> или аналогичной), за вычетом запаса примерно в мегабайт. Этот запас необходим, потому что сервер проверяет глубину стека не в каждой процедуре, а только в потенциально рекурсивных процедурах, например, при вычислении выражений. Если это значение задаётся без единиц измерения, оно считается заданным в килобайтах. Значение по умолчанию — два мегабайта (<code class="literal">2MB</code>) — выбрано с большим запасом, так что риск переполнения стека минимален. Но с другой стороны, его может быть недостаточно для выполнения сложных функций. Изменить этот параметр могут только суперпользователи и пользователи с соответствующим правом <code class="literal">SET</code>.</p><p>Если <code class="varname">max_stack_depth</code> будет превышать фактический предел ядра, то функция с неограниченной рекурсией сможет вызвать крах отдельного процесса сервера. В системах, где <span class="productname">PostgreSQL</span> может определить предел, установленный ядром, он не позволит установить для этого параметра небезопасное значение. Однако эту информацию выдают не все системы, поэтому выбирать это значение следует с осторожностью.</p></dd><dt id="GUC-SHARED-MEMORY-TYPE"><span class="term"><code class="varname">shared_memory_type</code> (<code class="type">enum</code>) <a id="id-1.6.7.7.2.2.13.1.3" class="indexterm"></a></span> <a href="#GUC-SHARED-MEMORY-TYPE" class="id_link">#</a></dt><dd><p>Выбирает механизм разделяемой памяти, используя который сервер будет работать с основной областью общей памяти, содержащей общие буферы <span class="productname">PostgreSQL</span> и другие общие данные. Допустимые варианты: <code class="literal">mmap</code> (для выделения анонимных блоков разделяемой памяти с помощью <code class="function">mmap</code>), <code class="literal">sysv</code> (для выделения разделяемой памяти System V функцией <code class="function">shmget</code>) и <code class="literal">windows</code> (для выделения разделяемой памяти в Windows). Не все варианты поддерживаются на разных платформах; первый из поддерживаемых данной платформой вариантов становится для неё вариантом по умолчанию. Применять <code class="literal">sysv</code>, который нигде не выбирается по умолчанию, вообще не рекомендуется, так как для выделения большого объёма памяти (см. <a class="xref" href="kernel-resources.html#SYSVIPC" title="19.4.1. Разделяемая память и семафоры">Подраздел 19.4.1</a>) обычно требуется нестандартная настройка ядра.</p></dd><dt id="GUC-DYNAMIC-SHARED-MEMORY-TYPE"><span class="term"><code class="varname">dynamic_shared_memory_type</code> (<code class="type">enum</code>) <a id="id-1.6.7.7.2.2.14.1.3" class="indexterm"></a></span> <a href="#GUC-DYNAMIC-SHARED-MEMORY-TYPE" class="id_link">#</a></dt><dd><p>Выбирает механизм динамической разделяемой памяти, который будет использоваться сервером. Допустимые варианты: <code class="literal">posix</code> (для выделения разделяемой памяти POSIX функцией <code class="literal">shm_open</code>), <code class="literal">sysv</code> (для выделения разделяемой памяти System V функцией <code class="literal">shmget</code>), <code class="literal">windows</code> (для выделения разделяемой памяти в Windows) и <code class="literal">mmap</code> (для эмуляции разделяемой памяти через отображение в память файлов, хранящихся в каталоге данных). Не все варианты поддерживаются на разных платформах; по умолчанию обычно выбирается первый из поддерживаемых данной платформой вариантов. Применять <code class="literal">mmap</code>, который нигде не выбирается по умолчанию, вообще не рекомендуется, так как операционная система может периодически записывать на диск изменённые страницы, что создаст дополнительную нагрузку; однако это может быть полезно для отладки, когда каталог <code class="literal">pg_dynshmem</code> находится на RAM-диске или когда другие механизмы разделяемой памяти недоступны.</p></dd><dt id="GUC-MIN-DYNAMIC-SHARED-MEMORY"><span class="term"><code class="varname">min_dynamic_shared_memory</code> (<code class="type">integer</code>) <a id="id-1.6.7.7.2.2.15.1.3" class="indexterm"></a></span> <a href="#GUC-MIN-DYNAMIC-SHARED-MEMORY" class="id_link">#</a></dt><dd><p>Задаёт объём памяти, который должен быть выделен при запуске сервера для параллельных запросов. Если выделен недостаточный объём памяти или она уже занята одновременно выполняющимися запросами, новые параллельные запросы временно запрашивают дополнительную разделяемую память у операционной системы согласно значению <code class="varname">dynamic_shared_memory_type</code> (это может приводить к замедлению вследствие накладных расходов на управление памятью). На выделение памяти в соответствии с указанием <code class="varname">min_dynamic_shared_memory</code> влияет параметр <code class="varname">huge_pages</code> в тех операционных системах, где он поддерживается; в системе, поддерживающей автоматическое управление большими страницами, их использование вероятнее всего даст положительный эффект. Значение по умолчанию — <code class="literal">0</code> (память не выделяется). Этот параметр можно установить только при запуске сервера.</p></dd></dl></div></div><div class="sect2" id="RUNTIME-CONFIG-RESOURCE-DISK"><div class="titlepage"><div><div><h3 class="title">20.4.2. Диск <a href="#RUNTIME-CONFIG-RESOURCE-DISK" class="id_link">#</a></h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt id="GUC-TEMP-FILE-LIMIT"><span class="term"><code class="varname">temp_file_limit</code> (<code class="type">integer</code>) <a id="id-1.6.7.7.3.2.1.1.3" class="indexterm"></a></span> <a href="#GUC-TEMP-FILE-LIMIT" class="id_link">#</a></dt><dd><p>Задаёт максимальный объём дискового пространства, который сможет использовать один процесс для временных файлов, например, при сортировке и хешировании, или для сохранения удерживаемого курсора. Транзакция, которая попытается превысить этот предел, будет отменена. Если это значение задаётся без единиц измерения, оно считается заданным в килобайтах. Значение <code class="literal">-1</code> (по умолчанию) означает, что предел отсутствует. Изменить этот параметр могут только суперпользователи и пользователи с соответствующим правом <code class="literal">SET</code>.</p><p>Этот параметр ограничивает общий объём, который могут занимать в момент времени все временные файлы, задействованные в данном процессе <span class="productname">PostgreSQL</span>. Следует отметить, что это <span class="emphasis"><em>не</em></span> касается файлов явно создаваемых временных таблиц; ограничивается только объём временных файлов, которые создаются неявно при выполнении запросов.</p></dd></dl></div></div><div class="sect2" id="RUNTIME-CONFIG-RESOURCE-KERNEL"><div class="titlepage"><div><div><h3 class="title">20.4.3. Использование ресурсов ядра <a href="#RUNTIME-CONFIG-RESOURCE-KERNEL" class="id_link">#</a></h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt id="GUC-MAX-FILES-PER-PROCESS"><span class="term"><code class="varname">max_files_per_process</code> (<code class="type">integer</code>) <a id="id-1.6.7.7.4.2.1.1.3" class="indexterm"></a></span> <a href="#GUC-MAX-FILES-PER-PROCESS" class="id_link">#</a></dt><dd><p>Задаёт максимальное число файлов, которые могут быть одновременно открыты каждым серверным подпроцессом. Значение по умолчанию — 1000 файлов. Если ядро реализует безопасное ограничение по процессам, об этом параметре можно не беспокоиться. Но на некоторых платформах (а именно, в большинстве систем BSD) ядро позволяет отдельному процессу открыть больше файлов, чем могут открыть несколько процессов одновременно. Если вы столкнётесь с ошибками <span class="quote">«<span class="quote">Too many open files</span>»</span> (Слишком много открытых файлов), попробуйте уменьшить это число. Задать этот параметр можно только при запуске сервера.</p></dd></dl></div></div><div class="sect2" id="RUNTIME-CONFIG-RESOURCE-VACUUM-COST"><div class="titlepage"><div><div><h3 class="title">20.4.4. Задержка очистки по стоимости <a href="#RUNTIME-CONFIG-RESOURCE-VACUUM-COST" class="id_link">#</a></h3></div></div></div><p>Во время выполнения команд <a class="xref" href="sql-vacuum.html" title="VACUUM"><span class="refentrytitle">VACUUM</span></a> и <a class="xref" href="sql-analyze.html" title="ANALYZE"><span class="refentrytitle">ANALYZE</span></a> система ведёт внутренний счётчик, в котором суммирует оцениваемую стоимость различных выполняемых операций ввода/вывода. Когда накопленная стоимость превышает предел (<code class="varname">vacuum_cost_limit</code>), процесс, выполняющий эту операцию, засыпает на некоторое время (<code class="varname">vacuum_cost_delay</code>). Затем счётчик сбрасывается и процесс продолжается.</p><p>Данный подход реализован для того, чтобы администраторы могли снизить влияние этих команд на параллельную работу с базой, за счёт уменьшения нагрузки на подсистему ввода-вывода. Очень часто не имеет значения, насколько быстро выполнятся команды обслуживания (например, <code class="command">VACUUM</code> и <code class="command">ANALYZE</code>), но очень важно, чтобы они как можно меньше влияли на выполнение других операций с базой данных. Администраторы имеют возможность управлять этим, настраивая задержку очистки по стоимости.</p><p>По умолчанию этот режим отключён для выполняемых вручную команд <code class="command">VACUUM</code>. Чтобы включить его, нужно установить в <code class="varname">vacuum_cost_delay</code> ненулевое значение.</p><div class="variablelist"><dl class="variablelist"><dt id="GUC-VACUUM-COST-DELAY"><span class="term"><code class="varname">vacuum_cost_delay</code> (<code class="type">floating point</code>) <a id="id-1.6.7.7.5.5.1.1.3" class="indexterm"></a></span> <a href="#GUC-VACUUM-COST-DELAY" class="id_link">#</a></dt><dd><p>Продолжительность времени, в течение которого будет простаивать процесс, превысивший предел стоимости. Если это значение задаётся без единиц измерения, оно считается заданным в миллисекундах. Значение по умолчанию равно нулю, то есть задержка очистки отсутствует. При положительных значениях интенсивность очистки будет зависеть от стоимости.</p><p>При настройке интенсивности очистки для <code class="varname">vacuum_cost_delay</code> обычно выбираются довольно небольшие значения, вплоть до 1 миллисекунды и меньше. Хотя в <code class="varname">vacuum_cost_delay</code> можно задавать дробные значения в миллисекундах, такие задержки могут быть неточными на старых платформах. На таких платформах для увеличения интенсивности <code class="command">VACUUM</code> по сравнению с уровнем, обеспечиваемым при задержке 1 мс, потребуется настраивать другие параметры стоимости очистки. Тем не менее имеет смысл выбирать настолько малую задержку <code class="varname">vacuum_cost_delay</code>, насколько может обеспечить платформа; большие задержки не будут полезны.</p></dd><dt id="GUC-VACUUM-COST-PAGE-HIT"><span class="term"><code class="varname">vacuum_cost_page_hit</code> (<code class="type">integer</code>) <a id="id-1.6.7.7.5.5.2.1.3" class="indexterm"></a></span> <a href="#GUC-VACUUM-COST-PAGE-HIT" class="id_link">#</a></dt><dd><p>Примерная стоимость очистки буфера, оказавшегося в общем кеше. Это подразумевает блокировку пула буферов, поиск в хеш-таблице и сканирование содержимого страницы. По умолчанию этот параметр равен одному.</p></dd><dt id="GUC-VACUUM-COST-PAGE-MISS"><span class="term"><code class="varname">vacuum_cost_page_miss</code> (<code class="type">integer</code>) <a id="id-1.6.7.7.5.5.3.1.3" class="indexterm"></a></span> <a href="#GUC-VACUUM-COST-PAGE-MISS" class="id_link">#</a></dt><dd><p>Примерная стоимость очистки буфера, который нужно прочитать с диска. Это подразумевает блокировку пула буферов, поиск в хеш-таблице, чтение требуемого блока с диска и сканирование его содержимого. По умолчанию этот параметр равен 2.</p></dd><dt id="GUC-VACUUM-COST-PAGE-DIRTY"><span class="term"><code class="varname">vacuum_cost_page_dirty</code> (<code class="type">integer</code>) <a id="id-1.6.7.7.5.5.4.1.3" class="indexterm"></a></span> <a href="#GUC-VACUUM-COST-PAGE-DIRTY" class="id_link">#</a></dt><dd><p>Примерная стоимость очистки, при которой изменяется блок, не модифицированный ранее. В неё включается дополнительная стоимость ввода/вывода, связанная с записью изменённого блока на диск. По умолчанию этот параметр равен 20.</p></dd><dt id="GUC-VACUUM-COST-LIMIT"><span class="term"><code class="varname">vacuum_cost_limit</code> (<code class="type">integer</code>) <a id="id-1.6.7.7.5.5.5.1.3" class="indexterm"></a></span> <a href="#GUC-VACUUM-COST-LIMIT" class="id_link">#</a></dt><dd><p>Общая стоимость, при накоплении которой процесс очистки будет засыпать. По умолчанию этот параметр равен 200.</p></dd></dl></div><div class="note"><h3 class="title">Примечание</h3><p>Некоторые операции устанавливают критические блокировки и поэтому должны завершаться как можно быстрее. Во время таких операций задержка очистки по стоимости не осуществляется, так что накопленная за это время стоимость может намного превышать установленный предел. Во избежание ненужных длительных задержек в таких случаях, фактическая задержка вычисляется по формуле <code class="varname">vacuum_cost_delay</code> * <code class="varname">accumulated_balance</code> / <code class="varname">vacuum_cost_limit</code> и ограничивается максимумом, равным <code class="varname">vacuum_cost_delay</code> * 4.</p></div></div><div class="sect2" id="RUNTIME-CONFIG-RESOURCE-BACKGROUND-WRITER"><div class="titlepage"><div><div><h3 class="title">20.4.5. Фоновая запись <a href="#RUNTIME-CONFIG-RESOURCE-BACKGROUND-WRITER" class="id_link">#</a></h3></div></div></div><p>В числе специальных процессов сервера есть процесс <em class="firstterm">фоновой записи</em>, задача которого — осуществлять запись <span class="quote">«<span class="quote">грязных</span>»</span> (новых или изменённых) общих буферов на диск. Когда количество чистых общих буферов считается недостаточным, данный процесс записывает грязные буферы в файловую систему и помечает их как чистые. Это снижает вероятность того, что серверные процессы, выполняющие запросы пользователей, не смогут найти чистые буферы и им придётся сбрасывать грязные буферы самостоятельно. Однако процесс фоновой записи увеличивает общую нагрузку на подсистему ввода/вывода, так как он может записывать неоднократно изменяемую страницу несколько раз, тогда как её можно было бы записать всего один раз в контрольной точке. Параметры, рассматриваемые в данном подразделе, позволяют настроить поведение фоновой записи для конкретных нужд.</p><div class="variablelist"><dl class="variablelist"><dt id="GUC-BGWRITER-DELAY"><span class="term"><code class="varname">bgwriter_delay</code> (<code class="type">integer</code>) <a id="id-1.6.7.7.6.3.1.1.3" class="indexterm"></a></span> <a href="#GUC-BGWRITER-DELAY" class="id_link">#</a></dt><dd><p>Задаёт задержку между раундами активности процесса фоновой записи. Во время раунда этот процесс осуществляет запись некоторого количества загрязнённых буферов (это настраивается следующими параметрами). Затем он засыпает на время <code class="varname">bgwriter_delay</code>, и всё повторяется снова. Однако если в пуле не остаётся загрязнённых буферов, он может быть неактивен более длительное время. Если это значение задаётся без единиц измерения, оно считается заданным в миллисекундах. По умолчанию этот параметр равен 200 миллисекундам (<code class="literal">200ms</code>). Заметьте, что во многих системах разрешение таймера составляет 10 мс, поэтому если задать в <code class="varname">bgwriter_delay</code> значение, не кратное 10, фактически будет получен тот же результат, что и со следующим за ним кратным 10. Задать этот параметр можно только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера.</p></dd><dt id="GUC-BGWRITER-LRU-MAXPAGES"><span class="term"><code class="varname">bgwriter_lru_maxpages</code> (<code class="type">integer</code>) <a id="id-1.6.7.7.6.3.2.1.3" class="indexterm"></a></span> <a href="#GUC-BGWRITER-LRU-MAXPAGES" class="id_link">#</a></dt><dd><p>Задаёт максимальное число буферов, которое сможет записать процесс фоновой записи за раунд активности. При нулевом значении фоновая запись отключается. (Учтите, что на контрольные точки, которые управляются отдельным вспомогательным процессом, это не влияет.) По умолчанию значение этого параметра — 100 буферов. Задать этот параметр можно только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера.</p></dd><dt id="GUC-BGWRITER-LRU-MULTIPLIER"><span class="term"><code class="varname">bgwriter_lru_multiplier</code> (<code class="type">floating point</code>) <a id="id-1.6.7.7.6.3.3.1.3" class="indexterm"></a></span> <a href="#GUC-BGWRITER-LRU-MULTIPLIER" class="id_link">#</a></dt><dd><p>Число загрязнённых буферов, записываемых в очередном раунде, зависит от того, сколько новых буферов требовалось серверным процессам в предыдущих раундах. Средняя недавняя потребность умножается на <code class="varname">bgwriter_lru_multiplier</code> и предполагается, что именно столько буферов потребуется на следующем раунде. Процесс фоновой записи будет записывать на диск и освобождать буферы, пока число свободных буферов не достигнет целевого значения. (При этом число буферов, записываемых за раунд, ограничивается сверху параметром <code class="varname">bgwriter_lru_maxpages</code>.) Таким образом, со множителем, равным 1.0, записывается ровно столько буферов, сколько требуется по предположению (<span class="quote">«<span class="quote">точно по плану</span>»</span>). Увеличение этого множителя даёт некоторую страховку от резких скачков потребностей, тогда как уменьшение отражает намерение оставить некоторый объём записи для серверных процессов. По умолчанию он равен 2.0. Этот параметр можно установить только в файле <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера.</p></dd><dt id="GUC-BGWRITER-FLUSH-AFTER"><span class="term"><code class="varname">bgwriter_flush_after</code> (<code class="type">integer</code>) <a id="id-1.6.7.7.6.3.4.1.3" class="indexterm"></a></span> <a href="#GUC-BGWRITER-FLUSH-AFTER" class="id_link">#</a></dt><dd><p>Когда процессом фоновой записи записывается больше заданного объёма данных, сервер даёт указание ОС произвести запись этих данных в нижележащее хранилище. Это ограничивает объём «грязных» данных в страничном кеше ядра и уменьшает вероятность затормаживания при выполнении <code class="function">fsync</code> в конце контрольной точки или когда ОС сбрасывает данные на диск большими порциями в фоне. Часто это значительно уменьшает задержки транзакций, но бывают ситуации (особенно когда объём рабочей нагрузки больше <a class="xref" href="runtime-config-resource.html#GUC-SHARED-BUFFERS">shared_buffers</a>, но меньше страничного кеша ОС), когда производительность может упасть. Этот параметр действует не на всех платформах. Если значение параметра задаётся без единиц измерения, оно считается заданным в блоках (размер которых равен <code class="symbol">BLCKSZ</code> байт, обычно это 8 КБ). Он может принимать значение от <code class="literal">0</code> (при этом управление отложенной записью отключается) до 2 мегабайт (<code class="literal">2MB</code>). Значение по умолчанию — <code class="literal">512kB</code> в Linux и <code class="literal">0</code> в других ОС. (Если <code class="symbol">BLCKSZ</code> отличен от 8 КБ, значение по умолчанию и максимум корректируются пропорционально.) Задать этот параметр можно только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера.</p></dd></dl></div><p>С маленькими значениями <code class="varname">bgwriter_lru_maxpages</code> и <code class="varname">bgwriter_lru_multiplier</code> уменьшается активность ввода/вывода со стороны процесса фоновой записи, но увеличивается вероятность того, что запись придётся производить непосредственно серверным процессам, что замедлит выполнение запросов.</p></div><div class="sect2" id="RUNTIME-CONFIG-RESOURCE-ASYNC-BEHAVIOR"><div class="titlepage"><div><div><h3 class="title">20.4.6. Асинхронное поведение <a href="#RUNTIME-CONFIG-RESOURCE-ASYNC-BEHAVIOR" class="id_link">#</a></h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt id="GUC-BACKEND-FLUSH-AFTER"><span class="term"><code class="varname">backend_flush_after</code> (<code class="type">integer</code>) <a id="id-1.6.7.7.7.2.1.1.3" class="indexterm"></a></span> <a href="#GUC-BACKEND-FLUSH-AFTER" class="id_link">#</a></dt><dd><p>Когда одним обслуживающим процессом записывается больше заданного объёма данных, сервер даёт указание ОС произвести запись этих данных в нижележащее хранилище. Это ограничивает объём «грязных» данных в страничном кеше ядра и уменьшает вероятность затормаживания при выполнении <code class="function">fsync</code> в конце контрольной точки или когда ОС сбрасывает данные на диск большими порциями в фоне. Часто это значительно сокращает задержки транзакций, но бывают ситуации (особенно когда объём рабочей нагрузки больше <a class="xref" href="runtime-config-resource.html#GUC-SHARED-BUFFERS">shared_buffers</a>, но меньше страничного кеша ОС), когда производительность может упасть. Этот параметр действует не на всех платформах. Если значение параметра задаётся без единиц измерения, оно считается заданным в блоках (размер которых равен <code class="symbol">BLCKSZ</code> байт, обычно это 8 КБ). Он может принимать значение от <code class="literal">0</code> (при этом управление отложенной записью отключается) до 2 мегабайт (<code class="literal">2MB</code>). По умолчанию он имеет значение <code class="literal">0</code>, то есть это поведение отключено. (Если <code class="symbol">BLCKSZ</code> отличен от 8 КБ, максимальное значение корректируется пропорционально.)</p></dd><dt id="GUC-EFFECTIVE-IO-CONCURRENCY"><span class="term"><code class="varname">effective_io_concurrency</code> (<code class="type">integer</code>) <a id="id-1.6.7.7.7.2.2.1.3" class="indexterm"></a></span> <a href="#GUC-EFFECTIVE-IO-CONCURRENCY" class="id_link">#</a></dt><dd><p>Задаёт допустимое число параллельных операций ввода/вывода, которое говорит <span class="productname">PostgreSQL</span> о том, сколько операций ввода/вывода могут быть выполнены одновременно. Чем больше это число, тем больше операций ввода/вывода будет пытаться выполнить параллельно <span class="productname">PostgreSQL</span> в отдельном сеансе. Допустимые значения лежат в интервале от 1 до 1000, а нулевое значение отключает асинхронные запросы ввода/вывода. В настоящее время этот параметр влияет только на сканирование по битовой карте.</p><p>Для магнитных носителей хорошим начальным значением этого параметра будет число отдельных дисков, составляющих массив RAID 0 или RAID 1, в котором размещена база данных. (Для RAID 5 следует исключить один диск (как диск с чётностью).) Однако если база данных часто обрабатывает множество запросов в различных сеансах, и при небольших значениях дисковый массив может быть полностью загружен. Если продолжать увеличивать это значение при полной загрузке дисков, это приведёт только к увеличению нагрузки на процессор. Диски SSD и другие виды хранилища в памяти часто могут обрабатывать множество параллельных запросов, так что оптимальным числом может быть несколько сотен.</p><p>Асинхронный ввод/вывод зависит от эффективности функции <code class="function">posix_fadvise</code>, которая отсутствует в некоторых операционных системах. В случае её отсутствия попытка задать для этого параметра любое ненулевое значение приведёт к ошибке. В некоторых системах (например, в Solaris), эта функция присутствует, но на самом деле ничего не делает.</p><p>Значение по умолчанию равно 1 в системах, где это поддерживается, и 0 в остальных. Это значение можно переопределить для таблиц в определённом табличном пространстве, установив одноимённый параметр табличного пространства (см. <a class="xref" href="sql-altertablespace.html" title="ALTER TABLESPACE"><span class="refentrytitle">ALTER TABLESPACE</span></a>).</p></dd><dt id="GUC-MAINTENANCE-IO-CONCURRENCY"><span class="term"><code class="varname">maintenance_io_concurrency</code> (<code class="type">integer</code>) <a id="id-1.6.7.7.7.2.3.1.3" class="indexterm"></a></span> <a href="#GUC-MAINTENANCE-IO-CONCURRENCY" class="id_link">#</a></dt><dd><p>Этот параметр подобен <code class="varname">effective_io_concurrency</code>, но используется для операций обслуживания, которые выполняются в различных клиентских сеансах.</p><p>Значение по умолчанию равно 10 в системах, где это поддерживается, и 0 в остальных. Это значение можно переопределить для таблиц в определённом табличном пространстве, установив одноимённый параметр табличного пространства (см. <a class="xref" href="sql-altertablespace.html" title="ALTER TABLESPACE"><span class="refentrytitle">ALTER TABLESPACE</span></a>).</p></dd><dt id="GUC-MAX-WORKER-PROCESSES"><span class="term"><code class="varname">max_worker_processes</code> (<code class="type">integer</code>) <a id="id-1.6.7.7.7.2.4.1.3" class="indexterm"></a></span> <a href="#GUC-MAX-WORKER-PROCESSES" class="id_link">#</a></dt><dd><p>Задаёт максимальное число фоновых процессов, которое можно запустить в текущей системе. Этот параметр можно задать только при запуске сервера. Значение по умолчанию — 8.</p><p>Для ведомого сервера значение этого параметра должно быть больше или равно значению на ведущем. В противном случае на ведомом сервере не будут разрешены запросы.</p><p>Одновременно с изменением этого значения также может быть полезно изменить <a class="xref" href="runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS">max_parallel_workers</a>, <a class="xref" href="runtime-config-resource.html#GUC-MAX-PARALLEL-MAINTENANCE-WORKERS">max_parallel_maintenance_workers</a>, и <a class="xref" href="runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS-PER-GATHER">max_parallel_workers_per_gather</a>.</p></dd><dt id="GUC-MAX-PARALLEL-WORKERS-PER-GATHER"><span class="term"><code class="varname">max_parallel_workers_per_gather</code> (<code class="type">integer</code>) <a id="id-1.6.7.7.7.2.5.1.3" class="indexterm"></a></span> <a href="#GUC-MAX-PARALLEL-WORKERS-PER-GATHER" class="id_link">#</a></dt><dd><p>Задаёт максимальное число рабочих процессов, которые могут запускаться одним узлом <code class="literal">Gather</code> или <code class="literal">Gather Merge</code>. Параллельные рабочие процессы берутся из пула процессов, контролируемого параметром <a class="xref" href="runtime-config-resource.html#GUC-MAX-WORKER-PROCESSES">max_worker_processes</a>, в количестве, ограничиваемом значением <a class="xref" href="runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS">max_parallel_workers</a>. Учтите, что запрошенное количество рабочих процессов может быть недоступно во время выполнения. В этом случае план будет выполняться с меньшим числом процессов, что может быть неэффективно. Значение по умолчанию — 2. Значение 0 отключает параллельное выполнение запросов.</p><p>Учтите, что параллельные запросы могут потреблять значительно больше ресурсов, чем не параллельные, так как каждый рабочий процесс является отдельным процессом и оказывает на систему примерно такое же влияние, как дополнительный пользовательский сеанс. Это следует учитывать, выбирая значение этого параметра, а также настраивая другие параметры, управляющие использованием ресурсов, например <a class="xref" href="runtime-config-resource.html#GUC-WORK-MEM">work_mem</a>. Ограничения ресурсов, такие как <code class="varname">work_mem</code>, применяются к каждому рабочему процессу отдельно, что означает, что общая нагрузка для всех процессов может оказаться гораздо больше, чем при обычном использовании одного процесса. Например, параллельный запрос, задействующий 4 рабочих процесса, может использовать в 5 раз больше времени процессора, объёма памяти, ввода/вывода и т. д., по сравнению с запросом, не задействующим рабочие процессы вовсе.</p><p>За дополнительными сведениями о параллельных запросах обратитесь к <a class="xref" href="parallel-query.html" title="Глава 15. Параллельный запрос">Главе 15</a>.</p></dd><dt id="GUC-MAX-PARALLEL-MAINTENANCE-WORKERS"><span class="term"><code class="varname">max_parallel_maintenance_workers</code> (<code class="type">integer</code>) <a id="id-1.6.7.7.7.2.6.1.3" class="indexterm"></a></span> <a href="#GUC-MAX-PARALLEL-MAINTENANCE-WORKERS" class="id_link">#</a></dt><dd><p>Задаёт максимальное число рабочих процессов, которые могут запускаться одной служебной командой. В настоящее время параллельные процессы может использовать только <code class="command">CREATE INDEX</code> при построении индекса-B-дерева и <code class="command">VACUUM</code> без указания <code class="literal">FULL</code>. Параллельные рабочие процессы берутся из пула процессов, контролируемого параметром <a class="xref" href="runtime-config-resource.html#GUC-MAX-WORKER-PROCESSES">max_worker_processes</a>, в количестве, ограничиваемом значением <a class="xref" href="runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS">max_parallel_workers</a>. Учтите, что запрошенное количество рабочих процессов может быть недоступно во время выполнения. В этом случае служебная операция будет выполняться с меньшим числом процессов, чем ожидалось. Значение по умолчанию — 2. Значение 0 отключает использование параллельных исполнителей служебными командами.</p><p>Заметьте, что параллельно выполняемые служебные команды не должны потреблять значительно больше памяти, чем равнозначные непараллельные операции. Это отличает их от параллельных запросов, при выполнении которых ограничения ресурсов действуют на отдельные рабочие процессы. Для параллельных служебных команд ограничение ресурсов <code class="varname">maintenance_work_mem</code> считается действующим на команду в целом, вне зависимости от числа параллельных рабочих процессов. Тем не менее параллельные служебные команды могут гораздо больше нагружать процессор и каналы ввода/вывода.</p></dd><dt id="GUC-MAX-PARALLEL-WORKERS"><span class="term"><code class="varname">max_parallel_workers</code> (<code class="type">integer</code>) <a id="id-1.6.7.7.7.2.7.1.3" class="indexterm"></a></span> <a href="#GUC-MAX-PARALLEL-WORKERS" class="id_link">#</a></dt><dd><p>Задаёт максимальное число рабочих процессов, которое система сможет поддерживать для параллельных операций. Значение по умолчанию — 8. При увеличении или уменьшения этого значения также может иметь смысл скорректировать <a class="xref" href="runtime-config-resource.html#GUC-MAX-PARALLEL-MAINTENANCE-WORKERS">max_parallel_maintenance_workers</a> и <a class="xref" href="runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS-PER-GATHER">max_parallel_workers_per_gather</a>. Заметьте, что значение данного параметра, превышающее <a class="xref" href="runtime-config-resource.html#GUC-MAX-WORKER-PROCESSES">max_worker_processes</a>, не будет действовать, так как параллельные рабочие процессы берутся из пула рабочих процессов, ограничиваемого этим параметром.</p></dd><dt id="GUC-PARALLEL-LEADER-PARTICIPATION"><span class="term"><code class="varname">parallel_leader_participation</code> (<code class="type">boolean</code>) <a id="id-1.6.7.7.7.2.8.1.3" class="indexterm"></a></span> <a href="#GUC-PARALLEL-LEADER-PARTICIPATION" class="id_link">#</a></dt><dd><p>Позволяет ведущему процессу выполнять план запроса ниже узлов <code class="literal">Gather</code> и <code class="literal">Gather Merge</code>, не ожидая рабочие процессы. По умолчанию этот параметр включён (<code class="literal">on</code>). Значение <code class="literal">off</code> снижает вероятность блокировки рабочих процессов в случае, если ведущий процесс будет читать кортежи недостаточно быстро, но тогда ведущему приходится дожидаться запуска рабочих процессов, и только затем выдавать первые кортежи. Степень положительного или отрицательного влияния ведущего зависит от типа плана, числа рабочих процессов и длительности запроса.</p></dd><dt id="GUC-OLD-SNAPSHOT-THRESHOLD"><span class="term"><code class="varname">old_snapshot_threshold</code> (<code class="type">integer</code>) <a id="id-1.6.7.7.7.2.9.1.3" class="indexterm"></a></span> <a href="#GUC-OLD-SNAPSHOT-THRESHOLD" class="id_link">#</a></dt><dd><p>Задаёт минимальное время, в течение которого можно пользоваться снимком состояния для запроса без риска получить ошибку <code class="literal">снимок слишком стар</code>. Данные, потерявшие актуальность и пребывающие в этом состоянии дольше заданного времени, могут быть вычищены. Это предотвращает раздувание из-за снимков, которые остаются задействованными долгое время. Во избежание получения некорректных результатов из-за очистки данных, которые должны были бы наблюдаться в таком снимке, клиенту будет выдана ошибка, если возраст снимка превысит заданный предел и из этого снимка будет запрошена страница, изменённая со времени его создания.</p><p>Если это значение задаётся без единиц измерения, оно считается заданным в минутах. Значение <code class="literal">-1</code> (по умолчанию) отключает это поведение, фактически делая предельный срок снимков бесконечным. Этот параметр можно задать только при запуске сервера.</p><p>Полезные для производственной среды значения могут лежать в интервале от нескольких часов до нескольких дней. Минимальные значения (как например, <code class="literal">0</code> или <code class="literal">1min</code>) допускаются только потому, что они могут быть полезны при тестировании. Хотя допустимым будет и значение <code class="literal">60d</code> (60 дней), учтите, что при многих видах нагрузки критичное раздувание базы или зацикливание идентификаторов транзакций может происходить в намного меньших временных отрезках.</p><p>Когда это ограничение действует, освобождённое пространство в конце отношения не может быть отдано операционной системе, так как при этом будет удалена информация, необходимая для выявления условия <span class="quote">«<span class="quote">снимок слишком стар</span>»</span>. Всё пространство, выделенное отношению, останется связанным с ним до тех пор, пока не будет освобождено явно (например, с помощью команды <code class="command">VACUUM FULL</code>).</p><p>Установка этого параметра не гарантирует, что обозначенная ошибка будет выдаваться при всех возможных обстоятельствах. На самом деле, если можно получить корректные результаты, например, из курсора, материализовавшего результирующий набор, ошибка не будет выдана, даже если нижележащие строки в целевой таблице были ликвидированы при очистке. Некоторые таблицы, например системные каталоги, не могут быть безопасно очищены в сжатые сроки, так что на них этот параметр не распространяется. Для таких таблиц этот параметр не сокращает раздувание, но и не чреват ошибкой <span class="quote">«<span class="quote">снимок слишком стар</span>»</span> при сканировании.</p></dd></dl></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="runtime-config-connection.html" title="20.3. Подключения и аутентификация">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="runtime-config.html" title="Глава 20. Настройка сервера">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="runtime-config-wal.html" title="20.5. Журнал предзаписи">След.</a></td></tr><tr><td width="40%" align="left" valign="top">20.3. Подключения и аутентификация </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 20.5. Журнал предзаписи</td></tr></table></div></body></html>