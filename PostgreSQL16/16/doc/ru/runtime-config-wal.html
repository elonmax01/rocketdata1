<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>20.5. Журнал предзаписи</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="runtime-config-resource.html" title="20.4. Потребление ресурсов" /><link rel="next" href="runtime-config-replication.html" title="20.6. Репликация" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">20.5. Журнал предзаписи</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="runtime-config-resource.html" title="20.4. Потребление ресурсов">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="runtime-config.html" title="Глава 20. Настройка сервера">Наверх</a></td><th width="60%" align="center">Глава 20. Настройка сервера</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="runtime-config-replication.html" title="20.6. Репликация">След.</a></td></tr></table><hr /></div><div class="sect1" id="RUNTIME-CONFIG-WAL"><div class="titlepage"><div><div><h2 class="title" style="clear: both">20.5. Журнал предзаписи <a href="#RUNTIME-CONFIG-WAL" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="runtime-config-wal.html#RUNTIME-CONFIG-WAL-SETTINGS">20.5.1. Параметры</a></span></dt><dt><span class="sect2"><a href="runtime-config-wal.html#RUNTIME-CONFIG-WAL-CHECKPOINTS">20.5.2. Контрольные точки</a></span></dt><dt><span class="sect2"><a href="runtime-config-wal.html#RUNTIME-CONFIG-WAL-ARCHIVING">20.5.3. Архивация</a></span></dt><dt><span class="sect2"><a href="runtime-config-wal.html#RUNTIME-CONFIG-WAL-RECOVERY">20.5.4. Восстановление</a></span></dt><dt><span class="sect2"><a href="runtime-config-wal.html#RUNTIME-CONFIG-WAL-ARCHIVE-RECOVERY">20.5.5. Восстановление из архива</a></span></dt><dt><span class="sect2"><a href="runtime-config-wal.html#RUNTIME-CONFIG-WAL-RECOVERY-TARGET">20.5.6. Цель восстановления</a></span></dt></dl></div><p>За дополнительной информацией о настройке этих параметров обратитесь к <a class="xref" href="wal-configuration.html" title="30.5. Настройка WAL">Разделу 30.5</a>.</p><div class="sect2" id="RUNTIME-CONFIG-WAL-SETTINGS"><div class="titlepage"><div><div><h3 class="title">20.5.1. Параметры <a href="#RUNTIME-CONFIG-WAL-SETTINGS" class="id_link">#</a></h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt id="GUC-WAL-LEVEL"><span class="term"><code class="varname">wal_level</code> (<code class="type">enum</code>) <a id="id-1.6.7.8.3.2.1.1.3" class="indexterm"></a></span> <a href="#GUC-WAL-LEVEL" class="id_link">#</a></dt><dd><p>Параметр <code class="varname">wal_level</code> определяет, как много информации записывается в WAL. Со значением <code class="literal">replica</code> (по умолчанию) в журнал записываются данные, необходимые для поддержки архивирования WAL и репликации, включая запросы только на чтение на ведомом сервере. Вариант <code class="literal">minimal</code> оставляет только информацию, необходимую для восстановления после сбоя или аварийного отключения. Наконец, <code class="literal">logical</code> добавляет информацию, требующуюся для поддержки логического декодирования. Каждый последующий уровень включает информацию, записываемую на всех уровнях ниже. Задать этот параметр можно только при запуске сервера.</p><p>На уровне <code class="literal">minimal</code> генерируется минимальный объём WAL. В журнал не записывается информация о производимых до конца транзакции операциях с постоянными отношениями, созданными или перезаписанными в данной транзакции. Это позволяет значительно ускорить такие операции (см. <a class="xref" href="populate.html#POPULATE-PITR" title="14.4.7. Отключите архивацию WAL и потоковую репликацию">Подраздел 14.4.7</a>). Такая оптимизация включается после следующих команд: </p><table border="0" summary="Simple list" class="simplelist"><tr><td><code class="command">ALTER ... SET TABLESPACE</code></td></tr><tr><td><code class="command">CLUSTER</code></td></tr><tr><td><code class="command">CREATE TABLE</code></td></tr><tr><td><code class="command">REFRESH MATERIALIZED VIEW</code> (без <code class="option">CONCURRENTLY</code>)</td></tr><tr><td><code class="command">REINDEX</code></td></tr><tr><td><code class="command">TRUNCATE</code></td></tr></table><p> Однако минимальный журнал не будет содержать достаточно информации для восстановления на момент времени, поэтому для включения непрерывной архивации (<a class="xref" href="runtime-config-wal.html#GUC-ARCHIVE-MODE">archive_mode</a>) и потоковой двоичной репликации необходимо использовать уровень не ниже <code class="literal">replica</code>. Фактически сервер даже не запустится в этом режиме, если значение <code class="varname">max_wal_senders</code> отлично от нуля. Заметьте, что в случае изменения значения <code class="varname">wal_level</code> на <code class="literal">minimal</code> сделанные ранее базовые копии становятся непригодными для восстановления на момент времени и для резервных серверов.</p><p>На уровне <code class="literal">logical</code> в журнал записывается та же информация, что и на уровне <code class="literal">replica</code>, плюс информация, необходимая для извлечения из журнала наборов логических изменений. Повышение уровня до <code class="literal">logical</code> приводит к значительному увеличению объёма WAL, особенно если многие таблицы имеют характеристику <code class="literal">REPLICA IDENTITY FULL</code> и выполняется множество команд <code class="command">UPDATE</code> и <code class="command">DELETE</code>.</p><p>В выпусках до 9.6 для этого параметра допускались значения <code class="literal">archive</code> и <code class="literal">hot_standby</code>. Эти значения по-прежнему принимаются, но теперь отображаются в значение <code class="literal">replica</code>.</p></dd><dt id="GUC-FSYNC"><span class="term"><code class="varname">fsync</code> (<code class="type">boolean</code>) <a id="id-1.6.7.8.3.2.2.1.3" class="indexterm"></a></span> <a href="#GUC-FSYNC" class="id_link">#</a></dt><dd><p>Если этот параметр установлен, сервер <span class="productname">PostgreSQL</span> старается добиться, чтобы изменения были записаны на диск физически, выполняя системные вызовы <code class="function">fsync()</code> или другими подобными методами (см. <a class="xref" href="runtime-config-wal.html#GUC-WAL-SYNC-METHOD">wal_sync_method</a>). Это даёт гарантию, что кластер баз данных сможет вернуться в согласованное состояние после сбоя оборудования или операционной системы.</p><p>Хотя отключение <code class="varname">fsync</code> часто даёт выигрыш в скорости, это может привести к неисправимой порче данных в случае отключения питания или сбоя системы. Поэтому отключать <code class="varname">fsync</code> рекомендуется, только если вы легко сможете восстановить всю базу из внешнего источника.</p><p>В качестве примеров, когда отключение <code class="varname">fsync</code> неопасно, можно привести начальное наполнение нового кластера данными из копии, обработку массива данных, после которой базу данных можно удалить и создать заново, либо эксплуатацию копии базы данных только для чтения, которая регулярно пересоздаётся и не используется для отработки отказа. Качественное оборудование само по себе не является достаточной причиной для отключения <code class="varname">fsync</code>.</p><p>При смене значения <code class="varname">fsync</code> с off на on для надёжного восстановления также необходимо сбросить все изменённые буферы из ядра в надёжное хранилище. Это можно сделать, когда сервер остановлен или когда режим <code class="varname">fsync</code> включён, с помощью команды <code class="command">initdb --sync-only</code>, либо выполнить команду <code class="command">sync</code>, размонтировать файловую систему или перезагрузить сервер.</p><p>Во многих случаях отключение <a class="xref" href="runtime-config-wal.html#GUC-SYNCHRONOUS-COMMIT">synchronous_commit</a> для некритичных транзакций может дать больший выигрыш в скорости, чем отключение <code class="varname">fsync</code>, при этом не добавляя риски повреждения данных.</p><p>Параметр <code class="varname">fsync</code> можно задать только в файле <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера. Если вы отключаете этот параметр, возможно, имеет смысл отключить также и <a class="xref" href="runtime-config-wal.html#GUC-FULL-PAGE-WRITES">full_page_writes</a>.</p></dd><dt id="GUC-SYNCHRONOUS-COMMIT"><span class="term"><code class="varname">synchronous_commit</code> (<code class="type">enum</code>) <a id="id-1.6.7.8.3.2.3.1.3" class="indexterm"></a></span> <a href="#GUC-SYNCHRONOUS-COMMIT" class="id_link">#</a></dt><dd><p>Определяет, после завершения какого уровня обработки WAL сервер будет сообщать об успешном выполнении операции. Допустимые значения: <code class="literal">remote_apply</code> (применено удалённо), <code class="literal">on</code> (вкл., по умолчанию), <code class="literal">remote_write</code> (записано удалённо), <code class="literal">local</code> (локально) и <code class="literal">off</code> (выкл.).</p><p>Если значение <code class="varname">synchronous_standby_names</code> не задано, для данного параметра имеют смысл только значения <code class="literal">on</code> и <code class="literal">off</code>; с вариантами <code class="literal">remote_apply</code>, <code class="literal">remote_write</code> и <code class="literal">local</code> будет выбран тот же уровень синхронизации, что и с <code class="literal">on</code>. Локальное действие всех отличных от <code class="literal">off</code> режимов заключается в ожидании локального сброса WAL на диск. В режиме <code class="literal">off</code> ожидание отсутствует, поэтому может образоваться окно от момента, когда клиент узнаёт об успешном завершении, до момента, когда транзакция действительно гарантированно защищена от сбоя. (Максимальный размер окна равен тройному значению <a class="xref" href="runtime-config-wal.html#GUC-WAL-WRITER-DELAY">wal_writer_delay</a>.) В отличие от <a class="xref" href="runtime-config-wal.html#GUC-FSYNC">fsync</a>, значение <code class="literal">off</code> этого параметра не угрожает целостности данных: сбой операционной системы или базы данных может привести к потере последних транзакций, считавшихся зафиксированными, но состояние базы данных будет точно таким же, как и в случае штатного прерывания этих транзакций. Поэтому выключение режима <code class="varname">synchronous_commit</code> может быть полезной альтернативой отключению <a class="xref" href="runtime-config-wal.html#GUC-FSYNC">fsync</a>, когда производительность важнее, чем надёжная гарантия сохранности каждой транзакции. Подробнее это обсуждается в <a class="xref" href="wal-async-commit.html" title="30.4. Асинхронное подтверждение транзакций">Разделе 30.4</a>.</p><p>Если значение <a class="xref" href="runtime-config-replication.html#GUC-SYNCHRONOUS-STANDBY-NAMES">synchronous_standby_names</a> не пустое, параметр <code class="varname">synchronous_commit</code> также определяет, должен ли сервер при фиксировании транзакции ждать, пока соответствующие записи WAL будут обработаны на ведомом сервере (серверах).</p><p>Со значением <code class="literal">remote_apply</code> фиксирование завершается только после получения ответов от текущих синхронных ведомых серверов, говорящих, что они получили запись о фиксировании транзакции, сохранили её в надёжном хранилище, а также применили транзакцию, так что она стала видна для запросов на этих серверах. С таким вариантом задержка при фиксировании оказывается больше, так как необходимо дожидаться воспроизведения WAL. Со значением <code class="literal">on</code> фиксирование завершается только после получения ответов от текущих синхронных ведомых серверов, подтверждающих, что они получили запись о фиксировании транзакции и передали её в надёжном хранилище. Это гарантирует, что транзакция не будет потеряна, если только база данных не будет повреждена и на ведущем, и на всех синхронных ведомых серверах. Со значением <code class="literal">remote_write</code> фиксирование завершается после получения ответов от текущих синхронных серверов, говорящих, что они получили запись о фиксировании транзакции и сохранили её в своих ФС. Этот вариант позволяет гарантировать сохранность данных в случае отказа ведомого сервера <span class="productname">PostgreSQL</span>, но не в случае сбоя на уровне ОС, так как данные могут ещё не достичь надёжного хранилища на этом сервере. Со значением <code class="literal">local</code> фиксирование завершается после локального сброса данных, не дожидаясь репликации. Обычно это нежелательный вариант при синхронной репликации, но он представлен для полноты.</p><p>Этот параметр можно изменить в любое время; поведение каждой конкретной транзакции определяется значением, действующим в момент её фиксирования. Таким образом, есть возможность и смысл фиксировать некоторые транзакции синхронно, а другие — асинхронно. Например, чтобы зафиксировать одну транзакцию из нескольких команд асинхронно, когда по умолчанию выбран противоположный вариант, выполните в этой транзакции <code class="command">SET LOCAL synchronous_commit TO OFF</code>.</p><p>Характеристики различных значений <code class="varname">synchronous_commit</code> сведены в <a class="xref" href="runtime-config-wal.html#SYNCHRONOUS-COMMIT-MATRIX" title="Таблица 20.1. Режимы synchronous_commit">Таблице 20.1</a>.</p><div class="table" id="SYNCHRONOUS-COMMIT-MATRIX"><p class="title"><strong>Таблица 20.1. Режимы synchronous_commit</strong></p><div class="table-contents"><table class="table" summary="Режимы synchronous_commit" border="1"><colgroup><col class="col1" /><col class="col2" /><col class="col3" /><col class="col4" /><col class="col5" /></colgroup><thead><tr><th>значение synchronous_commit</th><th>гарантированная локальная фиксация</th><th>гарантированная фиксация на ведомом после сбоя PG</th><th>гарантированная фиксация на ведомом после сбоя ОС</th><th>согласованность запросов на ведомом</th></tr></thead><tbody><tr><td>remote_apply</td><td align="center">•</td><td align="center">•</td><td align="center">•</td><td align="center">•</td></tr><tr><td>on</td><td align="center">•</td><td align="center">•</td><td align="center">•</td><td align="center"> </td></tr><tr><td>remote_write</td><td align="center">•</td><td align="center">•</td><td align="center"> </td><td align="center"> </td></tr><tr><td>local</td><td align="center">•</td><td align="center"> </td><td align="center"> </td><td align="center"> </td></tr><tr><td>off</td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center"> </td></tr></tbody></table></div></div><br class="table-break" /></dd><dt id="GUC-WAL-SYNC-METHOD"><span class="term"><code class="varname">wal_sync_method</code> (<code class="type">enum</code>) <a id="id-1.6.7.8.3.2.4.1.3" class="indexterm"></a></span> <a href="#GUC-WAL-SYNC-METHOD" class="id_link">#</a></dt><dd><p>Метод, применяемый для принудительного сохранения изменений WAL на диске. Если режим <code class="varname">fsync</code> отключён, данный параметр не действует, так как принудительное сохранение изменений WAL не производится вовсе. Возможные значения этого параметра:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">open_datasync</code> (для сохранения файлов WAL открывать их функцией <code class="function">open()</code> с параметром <code class="symbol">O_DSYNC</code>)</p></li><li class="listitem"><p><code class="literal">fdatasync</code> (вызывать <code class="function">fdatasync()</code> при каждом фиксировании)</p></li><li class="listitem"><p><code class="literal">fsync</code> (вызывать <code class="function">fsync()</code> при каждом фиксировании)</p></li><li class="listitem"><p><code class="literal">fsync_writethrough</code> (вызывать <code class="function">fsync()</code> при каждом фиксировании, форсируя сквозную запись кеша)</p></li><li class="listitem"><p><code class="literal">open_sync</code> (для сохранения файлов WAL открывать их функцией <code class="function">open()</code> с параметром <code class="symbol">O_SYNC</code>)</p></li></ul></div><p>Не все эти методы поддерживаются в разных системах. По умолчанию выбирается первый метод из списка, который поддерживается текущей системой, с одним исключением — в Linux и FreeBSD по умолчанию выбирается <code class="literal">fdatasync</code>. Выбираемый по умолчанию вариант не обязательно будет идеальным — в зависимости от требований к отказоустойчивости или производительности может потребоваться скорректировать выбранное значение или внести другие изменения в конфигурацию вашей системы. Соответствующие аспекты конфигурации рассматриваются в <a class="xref" href="wal-reliability.html" title="30.1. Надёжность">Разделе 30.1</a>. Этот параметр можно задать только в файле <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера.</p></dd><dt id="GUC-FULL-PAGE-WRITES"><span class="term"><code class="varname">full_page_writes</code> (<code class="type">boolean</code>) <a id="id-1.6.7.8.3.2.5.1.3" class="indexterm"></a></span> <a href="#GUC-FULL-PAGE-WRITES" class="id_link">#</a></dt><dd><p>Когда этот параметр включён, сервер <span class="productname">PostgreSQL</span> записывает в WAL всё содержимое каждой страницы при первом изменении этой страницы после контрольной точки. Это необходимо, потому что запись страницы, прерванная при сбое операционной системы, может выполниться частично, и на диске окажется страница, содержащая смесь старых данных с новыми. При этом информации об изменениях на уровне строк, которая обычно сохраняется в WAL, будет недостаточно для получения согласованного содержимого такой страницы при восстановлении после сбоя. Сохранение образа всей страницы гарантирует, что страницу можно восстановить корректно, ценой увеличения объёма данных, которые будут записываться в WAL. (Так как воспроизведение WAL всегда начинается от контрольной точки, достаточно сделать это при первом изменении каждой страницы после контрольной точки. Таким образом, уменьшить затраты на запись полных страниц можно, увеличив интервалы контрольных точек.)</p><p>Отключение этого параметра ускоряет обычные операции, но может привести к неисправимому повреждению или незаметной порче данных после сбоя системы. Так как при этом возникают практически те же риски, что и при отключении <code class="varname">fsync</code>, хотя и в меньшей степени, отключать его следует только при тех же обстоятельствах, которые перечислялись в рекомендациях для вышеописанного параметра.</p><p>Отключение этого параметра не влияет на возможность применения архивов WAL для восстановления состояния на момент времени (см. <a class="xref" href="continuous-archiving.html" title="26.3. Непрерывное архивирование и восстановление на момент времени (Point-in-Time Recovery, PITR)">Раздел 26.3</a>).</p><p>Этот параметр можно задать только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера. По умолчанию этот параметр имеет значение <code class="literal">on</code>.</p></dd><dt id="GUC-WAL-LOG-HINTS"><span class="term"><code class="varname">wal_log_hints</code> (<code class="type">boolean</code>) <a id="id-1.6.7.8.3.2.6.1.3" class="indexterm"></a></span> <a href="#GUC-WAL-LOG-HINTS" class="id_link">#</a></dt><dd><p>Когда этот параметр имеет значение <code class="literal">on</code>, сервер <span class="productname">PostgreSQL</span> записывает в WAL всё содержимое каждой страницы при первом изменении этой страницы после контрольной точки, даже при второстепенных изменениях так называемых вспомогательных битов.</p><p>Если включён расчёт контрольных сумм данных, изменения вспомогательных битов всегда проходят через WAL и этот параметр игнорируется. С помощью этого параметра можно проверить, насколько больше дополнительной информации записывалось бы в журнал, если бы для базы данных был включён подсчёт контрольных сумм.</p><p>Этот параметр можно задать только при запуске сервера. По умолчанию он имеет значение <code class="literal">off</code>.</p></dd><dt id="GUC-WAL-COMPRESSION"><span class="term"><code class="varname">wal_compression</code> (<code class="type">enum</code>) <a id="id-1.6.7.8.3.2.7.1.3" class="indexterm"></a></span> <a href="#GUC-WAL-COMPRESSION" class="id_link">#</a></dt><dd><p>Этот параметр включает сжатие WAL указанным методом. Если этот параметр имеет значение <code class="literal">on</code>, сервер <span class="productname">PostgreSQL</span> сжимает образ полной страницы, записываемый в WAL, когда включён режим <a class="xref" href="runtime-config-wal.html#GUC-FULL-PAGE-WRITES">full_page_writes</a> или при создании базовой копии. Сжатый образ страницы будет развёрнут при воспроизведении WAL. Поддерживаемые методы: <code class="literal">pglz</code>, <code class="literal">lz4</code> (если <span class="productname">PostgreSQL</span> скомпилирован с параметром <code class="option">--with-lz4</code>) и <code class="literal">zstd</code> (если <span class="productname">PostgreSQL</span> скомпилирован с параметром <code class="option">--with-zstd</code>). Значение по умолчанию — <code class="literal">off</code>. Изменить этот параметр могут только суперпользователи и пользователи с соответствующим правом <code class="literal">SET</code>.</p><p>Включив сжатие, вы можете без дополнительных рисков повреждения данных уменьшить объём WAL, ценой дополнительной нагрузки на процессор, связанной со сжатием данных при записи в WAL и разворачиванием их при воспроизведении WAL.</p></dd><dt id="GUC-WAL-INIT-ZERO"><span class="term"><code class="varname">wal_init_zero</code> (<code class="type">boolean</code>) <a id="id-1.6.7.8.3.2.8.1.3" class="indexterm"></a></span> <a href="#GUC-WAL-INIT-ZERO" class="id_link">#</a></dt><dd><p>Если этот параметр включён (<code class="literal">on</code>), создаваемые файлы WAL заполняются нулями. В ряде файловых систем благодаря этому заранее выделяется пространство, которое потребуется для записи WAL. Однако с файловыми системами, работающими по принципу COW (<em class="firstterm">Copy-On-Write</em>, Копирование при записи), это может быть бессмысленно, поэтому данный параметр позволяет отключить в данном случае неэффективное поведение. Со значением <code class="literal">off</code> в создаваемый файл записывается только последний байт, чтобы файл WAL сразу обрёл желаемый размер.</p></dd><dt id="GUC-WAL-RECYCLE"><span class="term"><code class="varname">wal_recycle</code> (<code class="type">boolean</code>) <a id="id-1.6.7.8.3.2.9.1.3" class="indexterm"></a></span> <a href="#GUC-WAL-RECYCLE" class="id_link">#</a></dt><dd><p>Если этот параметр имеет значение <code class="literal">on</code> (по умолчанию), файлы WAL используются повторно (для этого они переименовываются), что избавляет от необходимости создавать новые файлы. В файловых системах COW может быть быстрее создать новые файлы, поэтому данный параметр позволяет отключить это поведение.</p></dd><dt id="GUC-WAL-BUFFERS"><span class="term"><code class="varname">wal_buffers</code> (<code class="type">integer</code>) <a id="id-1.6.7.8.3.2.10.1.3" class="indexterm"></a></span> <a href="#GUC-WAL-BUFFERS" class="id_link">#</a></dt><dd><p>Объём разделяемой памяти, который будет использоваться для буферизации данных WAL, ещё не записанных на диск. Значение по умолчанию, равное -1, задаёт размер, равный 1/32 (около 3%) от <a class="xref" href="runtime-config-resource.html#GUC-SHARED-BUFFERS">shared_buffers</a>, но не меньше чем <code class="literal">64 КБ</code> и не больше чем размер одного сегмента WAL (обычно <code class="literal">16 МБ</code>). Это значение можно задать вручную, если выбираемое автоматически слишком мало или велико, но при этом любое положительное число меньше <code class="literal">32 КБ</code> будет восприниматься как <code class="literal">32 КБ</code>. Если это значение задаётся без единиц измерения, оно считается заданным в блоках WAL (размер которых равен <code class="symbol">XLOG_BLCKSZ</code> байт, обычно это 8 КБ). Этот параметр можно задать только при запуске сервера.</p><p>Содержимое буферов WAL записывается на диск при фиксировании каждой транзакции, так что очень большие значения вряд ли принесут значительную пользу. Однако значение как минимум в несколько мегабайт может увеличить быстродействие при записи на нагруженном сервере, когда сразу множество клиентов фиксируют транзакции. Автонастройка, действующая при значении по умолчанию (-1), в большинстве случаев выбирает разумные значения.</p></dd><dt id="GUC-WAL-WRITER-DELAY"><span class="term"><code class="varname">wal_writer_delay</code> (<code class="type">integer</code>) <a id="id-1.6.7.8.3.2.11.1.3" class="indexterm"></a></span> <a href="#GUC-WAL-WRITER-DELAY" class="id_link">#</a></dt><dd><p>Определяет, с какой периодичностью процесс записи WAL будет сбрасывать WAL на диск. После очередного сброса WAL он делает паузу, длительность которой задаётся параметром <code class="varname">wal_writer_delay</code>, но может быть пробуждён асинхронно фиксируемой транзакцией. Если предыдущая операция сброса имела место в течение заданного параметром <code class="varname">wal_writer_delay</code> времени и полученный за это время объём WAL не достиг значения <code class="varname">wal_writer_flush_after</code>, данные WAL только передаются ОС, но не сбрасываются на диск. Если это значение задаётся без единиц измерения, оно считается заданным в миллисекундах. Значение по умолчанию — 200 миллисекунд (<code class="literal">200ms</code>). Заметьте, что во многих системах разрешение таймера паузы составляет 10 мс; если задать в <code class="varname">wal_writer_delay</code> значение, не кратное 10, может быть получен тот же результат, что и со следующим за ним кратным 10. Задать этот параметр можно только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера.</p></dd><dt id="GUC-WAL-WRITER-FLUSH-AFTER"><span class="term"><code class="varname">wal_writer_flush_after</code> (<code class="type">integer</code>) <a id="id-1.6.7.8.3.2.12.1.3" class="indexterm"></a></span> <a href="#GUC-WAL-WRITER-FLUSH-AFTER" class="id_link">#</a></dt><dd><p>Определяет, при каком объёме процесс записи WAL будет сбрасывать WAL на диск. Если предыдущая операция сброса имела место в течение заданного параметром <code class="varname">wal_writer_delay</code> времени и полученный после неё объём WAL не достиг значения <code class="varname">wal_writer_flush_after</code>, данные WAL только передаются ОС, но не сбрасываются на диск. Если <code class="varname">wal_writer_flush_after</code> равен <code class="literal">0</code>, WAL сбрасывается на диск немедленно. Если это значение задаётся без единиц измерения, оно считается заданным в блоках WAL (размер которых равен <code class="symbol">XLOG_BLCKSZ</code> байт, обычно это 8 КБ). Значение по умолчанию — 1 мегабайт (<code class="literal">1MB</code>). Задать этот параметр можно только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера.</p></dd><dt id="GUC-WAL-SKIP-THRESHOLD"><span class="term"><code class="varname">wal_skip_threshold</code> (<code class="type">integer</code>) <a id="id-1.6.7.8.3.2.13.1.3" class="indexterm"></a></span> <a href="#GUC-WAL-SKIP-THRESHOLD" class="id_link">#</a></dt><dd><p>Когда выбран <code class="varname">wal_level</code> <code class="literal">minimal</code> и фиксируется транзакция, которая создавала или перезаписывала постоянное отношение, этот параметр определяет, как будут сохраняться новые данные. Если объём данных меньше заданного значения, они будут записываться в журнал WAL; в противном случае затронутые файлы просто синхронизируются с ФС. Изменение этого параметра в зависимости от характеристик вашего хранилища может быть полезным, если при фиксировании такой транзакции наблюдается замедление других транзакций. Если это значение задаётся без единиц измерения, оно считается заданным в килобайтах. Значение по умолчанию — два мегабайта (<code class="literal">2MB</code>).</p></dd><dt id="GUC-COMMIT-DELAY"><span class="term"><code class="varname">commit_delay</code> (<code class="type">integer</code>) <a id="id-1.6.7.8.3.2.14.1.3" class="indexterm"></a></span> <a href="#GUC-COMMIT-DELAY" class="id_link">#</a></dt><dd><p>Параметр <code class="varname">commit_delay</code> добавляет паузу перед собственно выполнением сохранения WAL. Эта задержка может увеличить быстродействие при фиксировании множества транзакций, позволяя зафиксировать большее число транзакций за одну операцию сохранения WAL, если система нагружена достаточно сильно и за заданное время успевают зафиксироваться другие транзакции. Однако этот параметр также увеличивает задержку максимум до <code class="varname">commit_delay</code> при каждом сохранении WAL. Эта задержка окажется бесполезной, если никакие другие транзакции не будут зафиксированы за это время, поэтому она добавляется, только если в момент запроса сохранения WAL активны как минимум <code class="varname">commit_siblings</code> других транзакций. Кроме того, эти задержки не добавляются при выключенном <code class="varname">fsync</code>. Если это значение задаётся без единиц измерения, оно считается заданным в микросекундах. По умолчанию значение <code class="varname">commit_delay</code> равно нулю (задержка отсутствует). Изменить этот параметр могут только суперпользователи и пользователи с соответствующим правом <code class="literal">SET</code>.</p><p>В <span class="productname">PostgreSQL</span> до версии 9.3, параметр <code class="varname">commit_delay</code> работал по-другому и не так эффективно: он задерживал только фиксирование транзакций, а не все операции сохранения WAL, и заданная пауза выдерживалась полностью, даже если WAL удавалось сохранить быстрее. Начиная с версии 9.3, заданное время ожидает только первый процесс, готовый произвести сохранение, тогда как все последующие процессы ждут только, когда он закончит эту операцию.</p></dd><dt id="GUC-COMMIT-SIBLINGS"><span class="term"><code class="varname">commit_siblings</code> (<code class="type">integer</code>) <a id="id-1.6.7.8.3.2.15.1.3" class="indexterm"></a></span> <a href="#GUC-COMMIT-SIBLINGS" class="id_link">#</a></dt><dd><p>Минимальное число одновременно открытых транзакций, при котором будет добавляться задержка <code class="varname">commit_delay</code>. Чем больше это значение, тем больше вероятность, что минимум одна транзакция окажется готовой к фиксированию за время задержки. По умолчанию это число равно пяти.</p></dd></dl></div></div><div class="sect2" id="RUNTIME-CONFIG-WAL-CHECKPOINTS"><div class="titlepage"><div><div><h3 class="title">20.5.2. Контрольные точки <a href="#RUNTIME-CONFIG-WAL-CHECKPOINTS" class="id_link">#</a></h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt id="GUC-CHECKPOINT-TIMEOUT"><span class="term"><code class="varname">checkpoint_timeout</code> (<code class="type">integer</code>) <a id="id-1.6.7.8.4.2.1.1.3" class="indexterm"></a></span> <a href="#GUC-CHECKPOINT-TIMEOUT" class="id_link">#</a></dt><dd><p>Максимальное время между автоматическими контрольными точками в WAL. Если это значение задаётся без единиц измерения, оно считается заданным в секундах. Допускаются значения от 30 секунд до одного дня. Значение по умолчанию — пять минут (<code class="literal">5min</code>). Увеличение этого параметра может привести к увеличению времени, которое потребуется для восстановления после сбоя. Задать этот параметр можно только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера.</p></dd><dt id="GUC-CHECKPOINT-COMPLETION-TARGET"><span class="term"><code class="varname">checkpoint_completion_target</code> (<code class="type">floating point</code>) <a id="id-1.6.7.8.4.2.2.1.3" class="indexterm"></a></span> <a href="#GUC-CHECKPOINT-COMPLETION-TARGET" class="id_link">#</a></dt><dd><p>Задаёт целевое время для завершения процедуры контрольной точки, как долю общего времени между контрольными точками. Значение по умолчанию — 0.9, что распределяет контрольную точку почти по всему доступному интервалу, обеспечивая достаточно стабильную нагрузку ввода-вывода, а также оставляя некоторое время для издержек на завершение процедуры контрольной точки. Уменьшать значение этого параметра не рекомендуется, так как это ускорит данную процедуру, что нежелательно, поскольку приведёт к ускорению ввода-вывода в процессе контрольной точки, и, следовательно, к меньшему объёму ввода-вывода в промежуток времени между завершением процедуры контрольной точки и следующей запланированной контрольной точкой. Этот параметр можно установить только в файле <code class="filename">postgresql.conf</code> или в командной строке сервера.</p></dd><dt id="GUC-CHECKPOINT-FLUSH-AFTER"><span class="term"><code class="varname">checkpoint_flush_after</code> (<code class="type">integer</code>) <a id="id-1.6.7.8.4.2.3.1.3" class="indexterm"></a></span> <a href="#GUC-CHECKPOINT-FLUSH-AFTER" class="id_link">#</a></dt><dd><p>Когда в процессе контрольной точки записывается больше заданного объёма данных, сервер даёт указание ОС произвести запись этих данных в нижележащее хранилище. Это ограничивает объём «грязных» данных в страничном кеше ядра и уменьшает вероятность затормаживания при выполнении <code class="function">fsync</code> в конце контрольной точки или когда ОС сбрасывает данные на диск большими порциями в фоне. Часто это значительно уменьшает задержки транзакций, но бывают ситуации (особенно когда объём рабочей нагрузки больше <a class="xref" href="runtime-config-resource.html#GUC-SHARED-BUFFERS">shared_buffers</a>, но меньше страничного кеша ОС), когда производительность может упасть. Этот параметр действует не на всех платформах. Если значение параметра задаётся без единиц измерения, оно считается заданным в блоках (размер которых равен <code class="symbol">BLCKSZ</code> байт, обычно это 8 КБ). Он может принимать значение от <code class="literal">0</code> (при этом управление отложенной записью отключается) до 2 мегабайт (<code class="literal">2MB</code>). Значение по умолчанию — <code class="literal">256kB</code> в Linux и <code class="literal">0</code> в других ОС. (Если <code class="symbol">BLCKSZ</code> отличен от 8 КБ, значение по умолчанию и максимум корректируются пропорционально.) Задать этот параметр можно только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера.</p></dd><dt id="GUC-CHECKPOINT-WARNING"><span class="term"><code class="varname">checkpoint_warning</code> (<code class="type">integer</code>) <a id="id-1.6.7.8.4.2.4.1.3" class="indexterm"></a></span> <a href="#GUC-CHECKPOINT-WARNING" class="id_link">#</a></dt><dd><p>Записывать в журнал сервера сообщение в случае, если контрольные точки, вызванные заполнением файлов сегментов WAL, выполняются быстрее, чем через заданное время (что говорит о том, что нужно увеличить <code class="varname">max_wal_size</code>). Если это значение задаётся без единиц измерения, оно считается заданным в секундах. Значение по умолчанию равно 30 секундам (<code class="literal">30s</code>). При нуле это предупреждение отключается. Если <code class="varname">checkpoint_timeout</code> меньше чем <code class="varname">checkpoint_warning</code>, предупреждения так же не будут выводиться. Задать этот параметр можно только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера.</p></dd><dt id="GUC-MAX-WAL-SIZE"><span class="term"><code class="varname">max_wal_size</code> (<code class="type">integer</code>) <a id="id-1.6.7.8.4.2.5.1.3" class="indexterm"></a></span> <a href="#GUC-MAX-WAL-SIZE" class="id_link">#</a></dt><dd><p>Максимальный размер, до которого может вырастать WAL во время автоматических контрольных точек. Это мягкий предел; размер WAL может превышать <code class="varname">max_wal_size</code> при особых обстоятельствах, например при большой нагрузке, сбое в <code class="varname">archive_command</code>/<code class="varname">archive_library</code> или при большом значении <code class="varname">wal_keep_size</code>. Если это значение задаётся без единиц измерения, оно считается заданным в мегабайтах. Значение по умолчанию — 1 ГБ. Увеличение этого параметра может привести к увеличению времени, которое потребуется для восстановления после сбоя. Задать этот параметр можно только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера.</p></dd><dt id="GUC-MIN-WAL-SIZE"><span class="term"><code class="varname">min_wal_size</code> (<code class="type">integer</code>) <a id="id-1.6.7.8.4.2.6.1.3" class="indexterm"></a></span> <a href="#GUC-MIN-WAL-SIZE" class="id_link">#</a></dt><dd><p>Пока WAL занимает на диске меньше этого объёма, старые файлы WAL в контрольных точках всегда перерабатываются, а не удаляются. Это позволяет зарезервировать достаточно места для WAL, чтобы справиться с резкими скачками использования WAL, например, при выполнении больших пакетных заданий. Если это значение задаётся без единиц измерения, оно считается заданным в мегабайтах. Значение по умолчанию — 80 МБ. Этот параметр можно установить только в <code class="filename">postgresql.conf</code> или в командной строке сервера.</p></dd></dl></div></div><div class="sect2" id="RUNTIME-CONFIG-WAL-ARCHIVING"><div class="titlepage"><div><div><h3 class="title">20.5.3. Архивация <a href="#RUNTIME-CONFIG-WAL-ARCHIVING" class="id_link">#</a></h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt id="GUC-ARCHIVE-MODE"><span class="term"><code class="varname">archive_mode</code> (<code class="type">enum</code>) <a id="id-1.6.7.8.5.2.1.1.3" class="indexterm"></a></span> <a href="#GUC-ARCHIVE-MODE" class="id_link">#</a></dt><dd><p>Когда параметр <code class="varname">archive_mode</code> включён, полные сегменты WAL передаются в хранилище архива командой <a class="xref" href="runtime-config-wal.html#GUC-ARCHIVE-COMMAND">archive_command</a> или функциями <a class="xref" href="runtime-config-wal.html#GUC-ARCHIVE-LIBRARY">archive_library</a>. Помимо значения <code class="literal">off</code> (выключающего архивацию) есть ещё два: <code class="literal">on</code> (вкл.) и <code class="literal">always</code> (всегда). В обычном состоянии эти два режима не различаются, но в режиме <code class="literal">always</code> архивация WAL активна и во время восстановления архива, и при использовании ведомого сервера. В этом режиме все файлы, восстановленные из архива или полученные при потоковой репликации, будут архивироваться (снова). За подробностями обратитесь к <a class="xref" href="warm-standby.html#CONTINUOUS-ARCHIVING-IN-STANDBY" title="27.2.9. Непрерывное архивирование на резервном сервере">Подразделу 27.2.9</a>.</p><p>Параметры <code class="varname">archive_mode</code> и <code class="varname">archive_command</code>/<code class="varname">archive_library</code> разделены, чтобы команду <code class="varname">archive_command</code> и библиотеку <code class="varname">archive_library</code> можно было изменять, не отключая режим архивации. Этот параметр можно задать только при запуске сервера. Режим архивации нельзя включить, когда установлен минимальный уровень WAL (<code class="varname">wal_level</code> имеет значение <code class="literal">minimal</code>).</p></dd><dt id="GUC-ARCHIVE-COMMAND"><span class="term"><code class="varname">archive_command</code> (<code class="type">string</code>) <a id="id-1.6.7.8.5.2.2.1.3" class="indexterm"></a></span> <a href="#GUC-ARCHIVE-COMMAND" class="id_link">#</a></dt><dd><p>Команда локальной оболочки, которая будет выполняться для архивации завершённого сегмента WAL. Любое вхождение <code class="literal">%p</code> в этой строке заменяется путём архивируемого файла, а вхождение <code class="literal">%f</code> заменяется только его именем. (Путь задаётся относительно рабочего каталога сервера, то есть каталога данных кластера.) Чтобы вставить в команду символ <code class="literal">%</code>, его нужно записать как <code class="literal">%%</code>. Важно, чтобы команда возвращала нулевой код, только если она завершается успешно. За дополнительной информацией обратитесь к <a class="xref" href="continuous-archiving.html#BACKUP-ARCHIVING-WAL" title="26.3.1. Настройка архивирования WAL">Подразделу 26.3.1</a>.</p><p>Этот параметр можно задать только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера. Данный параметр используется, только если <code class="varname">archive_mode</code> был включён при запуске или параметр <code class="varname">archive_library</code> содержит пустую строку. Если указаны и <code class="varname">archive_command</code>, и <code class="varname">archive_library</code>, возникнет ошибка. Если значение <code class="varname">archive_command</code> — пустая строка (по умолчанию), но <code class="varname">archive_mode</code> включён (и при этом значение <code class="varname">archive_library</code> — тоже пустая строка), архивация WAL временно отключается, но сервер продолжает накапливать файлы сегментов WAL в ожидании, что команда будет вскоре определена. Если в качестве <code class="varname">archive_command</code> задать команду, которая ничего не делает, но сообщает об успешном завершении, например <code class="literal">/bin/true</code> (или <code class="literal">REM</code> в Windows), архивация по сути отключается, но при этом нарушается цепочка файлов WAL, необходимых для восстановления архива, поэтому такой вариант следует использовать только в особых случаях.</p></dd><dt id="GUC-ARCHIVE-LIBRARY"><span class="term"><code class="varname">archive_library</code> (<code class="type">string</code>) <a id="id-1.6.7.8.5.2.3.1.3" class="indexterm"></a></span> <a href="#GUC-ARCHIVE-LIBRARY" class="id_link">#</a></dt><dd><p>Библиотека, используемая для архивирования завершённых сегментов файла WAL. Если задана пустая строка (по умолчанию), применяется метод архивирования посредством оболочки и используется <a class="xref" href="runtime-config-wal.html#GUC-ARCHIVE-COMMAND">archive_command</a>. Если заданы оба параметра <code class="varname">archive_command</code> и <code class="varname">archive_library</code>, возникнет ошибка. В противном случае для архивирования используется указанная общая библиотека. При изменении этого параметра postmaster перезапускает процесс архивирования WAL. За дополнительными сведениями обратитесь к разделам <a class="xref" href="continuous-archiving.html#BACKUP-ARCHIVING-WAL" title="26.3.1. Настройка архивирования WAL">Подраздел 26.3.1</a> и <a class="xref" href="archive-modules.html" title="Глава 51. Модули архивирования">Глава 51</a>.</p><p>Задать этот параметр можно только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера.</p></dd><dt id="GUC-ARCHIVE-TIMEOUT"><span class="term"><code class="varname">archive_timeout</code> (<code class="type">integer</code>) <a id="id-1.6.7.8.5.2.4.1.3" class="indexterm"></a></span> <a href="#GUC-ARCHIVE-TIMEOUT" class="id_link">#</a></dt><dd><p>Команда <a class="xref" href="runtime-config-wal.html#GUC-ARCHIVE-COMMAND">archive_command</a> или функции <a class="xref" href="runtime-config-wal.html#GUC-ARCHIVE-LIBRARY">archive_library</a> вызываются только для завершённых сегментов WAL. Поэтому, если ваш сервер записывает мало данных WAL (или это наблюдается в некоторые периоды времени), от завершения транзакции до надёжного сохранения её в архивном хранилище может пройти довольно много времени. Для ограничения времени существования неархивированных данных можно установить значение <code class="varname">archive_timeout</code>, чтобы сервер периодически переключался на новый файл сегмента WAL. Когда этот параметр больше нуля, сервер будет переключаться на новый файл сегмента, если с момента последнего переключения на новый файл прошло заданное время и наблюдалась какая-то активность базы данных, даже если это была просто контрольная точка. (Контрольные точки пропускаются, если в базе отсутствует активность). Заметьте, что архивируемые файлы, закрываемые досрочно из-за принудительного переключения, всё равно будут иметь тот же размер, что и полностью заполненные. Поэтому устанавливать для <code class="varname">archive_timeout</code> очень маленькое значение неразумно — это ведёт к раздуванию архивного хранилища. Обычно для <code class="varname">archive_timeout</code> имеет смысл задавать значение около минуты. Если вам нужно, чтобы данные копировались с главного сервера быстрее, вам следует подумать о переходе от архивации к потоковой репликации. Если это значение задаётся без единиц измерения, оно считается заданным в секундах. Этот параметр можно задать только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера.</p></dd></dl></div></div><div class="sect2" id="RUNTIME-CONFIG-WAL-RECOVERY"><div class="titlepage"><div><div><h3 class="title">20.5.4. Восстановление <a href="#RUNTIME-CONFIG-WAL-RECOVERY" class="id_link">#</a></h3></div></div></div><a id="id-1.6.7.8.6.2" class="indexterm"></a><p>В этом разделе описываются общие параметры, связанные с восстановлением, которые влияют на восстановление после сбоя, потоковую репликацию и репликацию с использованием архива.</p><div class="variablelist"><dl class="variablelist"><dt id="GUC-RECOVERY-PREFETCH"><span class="term"><code class="varname">recovery_prefetch</code> (<code class="type">enum</code>) <a id="id-1.6.7.8.6.4.1.1.3" class="indexterm"></a></span> <a href="#GUC-RECOVERY-PREFETCH" class="id_link">#</a></dt><dd><p>Определяет, выполнять ли во время восстановления предварительную выборку блоков, на которые есть ссылки в WAL и которых ещё нет в пуле буферов. Допустимые значения: <code class="literal">off</code> (выкл.), <code class="literal">on</code> (вкл.) и <code class="literal">try</code> (пробовать), выбираемое по умолчанию. Значение <code class="literal">try</code> включает предвыборку, только если операционная система предоставляет функцию <code class="function">posix_fadvise</code>, которая в настоящее время используется для реализации предварительной выборки. Обратите внимание, что некоторые операционные системы предоставляют эту функцию, но она ничего не делает.</p><p>Благодаря предвыборке блоков, которые вскоре потребуются, может уменьшиться время ожидания ввода/вывода во время восстановления при определённой нагрузке. См. также параметры <a class="xref" href="runtime-config-wal.html#GUC-WAL-DECODE-BUFFER-SIZE">wal_decode_buffer_size</a> и <a class="xref" href="runtime-config-resource.html#GUC-MAINTENANCE-IO-CONCURRENCY">maintenance_io_concurrency</a>, ограничивающие активность предварительной выборки.</p></dd><dt id="GUC-WAL-DECODE-BUFFER-SIZE"><span class="term"><code class="varname">wal_decode_buffer_size</code> (<code class="type">integer</code>) <a id="id-1.6.7.8.6.4.2.1.3" class="indexterm"></a></span> <a href="#GUC-WAL-DECODE-BUFFER-SIZE" class="id_link">#</a></dt><dd><p>Ограничение объёма WAL, который сервер будет читать наперёд, чтобы определить блоки для предварительной выборки. Если это значение указано без единиц измерения, оно считается заданным в байтах. По умолчанию 512 КБ.</p></dd></dl></div></div><div class="sect2" id="RUNTIME-CONFIG-WAL-ARCHIVE-RECOVERY"><div class="titlepage"><div><div><h3 class="title">20.5.5. Восстановление из архива <a href="#RUNTIME-CONFIG-WAL-ARCHIVE-RECOVERY" class="id_link">#</a></h3></div></div></div><a id="id-1.6.7.8.7.2" class="indexterm"></a><p>В этом разделе описываются параметры, действующие только в процессе восстановления. Они должны сбрасываться для любой последующей операции восстановления.</p><p>Под <span class="quote">«<span class="quote">восстановлением</span>»</span> здесь понимается и использование сервера в качестве ведомого, и выполнение целевого восстановления данных. Обычно ведомые серверы используется для обеспечения высокой степени доступности и/или масштабируемости чтения, тогда как целевое восстановление производится в случае потери данных.</p><p>Чтобы запустить сервер в режиме ведомого, создайте в каталоге данных файл <code class="filename">standby.signal</code><a id="id-1.6.7.8.7.5.2" class="indexterm"></a>. Сервер перейдёт к восстановлению и останется в этом состоянии и по достижении конца заархивированного WAL, чтобы осуществлять восстановление дальше. Для этого он подключится к передающему серверу, используя параметры в <code class="varname">primary_conninfo</code>, или будет получать новые сегменты WAL с помощью команды <code class="varname">restore_command</code>. Применительно к данному режиму представляют интерес параметры, описанные в этом разделе и в <a class="xref" href="runtime-config-replication.html#RUNTIME-CONFIG-REPLICATION-STANDBY" title="20.6.3. Ведомые серверы">Подразделе 20.6.3</a>. Параметры, описанные в <a class="xref" href="runtime-config-wal.html#RUNTIME-CONFIG-WAL-RECOVERY-TARGET" title="20.5.6. Цель восстановления">Подраздел 20.5.6</a>, также будут действовать, хотя для данного режима они вряд ли будут полезными.</p><p>Чтобы запустить сервер в режиме целевого восстановления, создайте в каталоге данных <code class="filename">recovery.signal</code><a id="id-1.6.7.8.7.6.2" class="indexterm"></a>. В случае одновременного существования файлов <code class="filename">standby.signal</code> и <code class="filename">recovery.signal</code> предпочтение отдаётся режиму ведомого. Режим целевого восстановления завершается после полного воспроизведения WAL из архива или при достижении целевой точки (<code class="varname">recovery_target</code>). В данном режиме используются параметры, описанные в этом разделе и в <a class="xref" href="runtime-config-wal.html#RUNTIME-CONFIG-WAL-RECOVERY-TARGET" title="20.5.6. Цель восстановления">Подразделе 20.5.6</a>.</p><div class="variablelist"><dl class="variablelist"><dt id="GUC-RESTORE-COMMAND"><span class="term"><code class="varname">restore_command</code> (<code class="type">string</code>) <a id="id-1.6.7.8.7.7.1.1.3" class="indexterm"></a></span> <a href="#GUC-RESTORE-COMMAND" class="id_link">#</a></dt><dd><p>Команда оболочки ОС, которая выполняется для извлечения архивного сегмента из набора файлов WAL. Этот параметр требуется для восстановления из архива, но необязателен для потоковой репликации. Любое вхождение <code class="literal">%f</code> в строке заменяется именем извлекаемого из архива файла, а <code class="literal">%p</code> заменяется на путь назначения на сервере. (Путь указывается относительно текущего рабочего каталога, т. е. относительно каталога хранения данных кластера.) Любое вхождение <code class="literal">%r</code> заменяется на имя файла, в котором содержится последняя действительная точка восстановления. Это самый ранний файл, который требуется хранить для возможности восстановления; зная его имя, размер архива можно уменьшить до минимально необходимого. <code class="literal">%r</code> обычно используется при организации тёплого резерва (см. <a class="xref" href="warm-standby.html" title="27.2. Трансляция журналов на резервные серверы">Раздел 27.2</a>). Для того чтобы указать символ <code class="literal">%</code>, продублируйте его (<code class="literal">%%</code>).</p><p>Обратите внимание, что команда должна возвращать ноль на выходе лишь в случае успешного выполнения. Команде <span class="emphasis"><em>будут</em></span> поступать имена файлов, отсутствующих в архиве; в этом случае она должна возвращать ненулевой статус. Примеры: </p><pre class="programlisting">restore_command = 'cp /mnt/server/archivedir/%f "%p"'
restore_command = 'copy "C:\\server\\archivedir\\%f" "%p"'  # Windows</pre><p> В случае прерывания команды сигналом (отличным от <span class="systemitem">SIGTERM</span>, который используется для остановки сервера баз данных) или при возникновении ошибки оболочки (например, если команда не найдена), процесс восстановления будет остановлен и сервер не запустится.</p><p>Задать этот параметр можно только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера.</p></dd><dt id="GUC-ARCHIVE-CLEANUP-COMMAND"><span class="term"><code class="varname">archive_cleanup_command</code> (<code class="type">string</code>) <a id="id-1.6.7.8.7.7.2.1.3" class="indexterm"></a></span> <a href="#GUC-ARCHIVE-CLEANUP-COMMAND" class="id_link">#</a></dt><dd><p>Этот необязательный параметр указывает команду оболочки ОС, которая будет вызываться при каждой точке перезапуска. Назначение команды <code class="varname">archive_cleanup_command</code> — предоставить механизм очистки от старых архивных файлов WAL, которые более не нужны на ведомом сервере. Любое вхождение <code class="literal">%r</code> заменяется на имя файла, содержащего последнюю действительную точку перезапуска. Это самый ранний файл, который необходимо <span class="emphasis"><em>хранить</em></span> для возможности восстановления, а более старые файлы вполне можно удалить. Эта информация может быть использована для усечения архива с целью его минимизации при сохранении возможности последующего восстановления из заданной точки. Модуль <a class="xref" href="pgarchivecleanup.html" title="pg_archivecleanup"><span class="refentrytitle"><span class="application">pg_archivecleanup</span></span></a> часто используется в качестве <code class="varname">archive_cleanup_command</code> в конфигурациях с одним ведомым сервером, например: </p><pre class="programlisting">archive_cleanup_command = 'pg_archivecleanup /mnt/server/archivedir %r'</pre><p> Стоит обратить внимание, что в конфигурациях с множеством ведомых серверов, использующих общий архивный каталог для восстановления, необходимо контролировать удаление файлов WAL, так как они могут ещё быть нужны некоторым серверам. Поэтому <code class="varname">archive_cleanup_command</code> обычно используется при организации тёплого резерва (см. <a class="xref" href="warm-standby.html" title="27.2. Трансляция журналов на резервные серверы">Раздел 27.2</a>). Чтобы указать символ <code class="literal">%</code> в команде, продублируйте его (<code class="literal">%%</code>).</p><p>В случаях, когда команда возвращает ненулевой статус завершения, в журнал записывается предупреждающее сообщение. Если же команда прерывается сигналом или оболочка ОС выдаёт ошибку (например, команда не найдена), вызывается критическая ошибка.</p><p>Задать этот параметр можно только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера.</p></dd><dt id="GUC-RECOVERY-END-COMMAND"><span class="term"><code class="varname">recovery_end_command</code> (<code class="type">string</code>) <a id="id-1.6.7.8.7.7.3.1.3" class="indexterm"></a></span> <a href="#GUC-RECOVERY-END-COMMAND" class="id_link">#</a></dt><dd><p>Этот параметр задаёт команду оболочки, которая будет выполнена единожды в конце процесса восстановления. Назначение параметра <code class="varname">recovery_end_command</code> — предоставить механизм для очистки после репликации или восстановления. Любое вхождение <code class="literal">%r</code> заменяется именем файла, содержащим последнюю действительную точку восстановления, например, как в <a class="xref" href="runtime-config-wal.html#GUC-ARCHIVE-CLEANUP-COMMAND">archive_cleanup_command</a>.</p><p>В случаях, когда команда возвращает ненулевой статус завершения, в журнал записывается предупреждающее сообщение, но сервер, несмотря на это, продолжает запускаться. Если же команда прерывается сигналом или оболочка ОС выдаёт ошибку (например, команда не найдена), кластер баз данных не запускается.</p><p>Задать этот параметр можно только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера.</p></dd></dl></div></div><div class="sect2" id="RUNTIME-CONFIG-WAL-RECOVERY-TARGET"><div class="titlepage"><div><div><h3 class="title">20.5.6. Цель восстановления <a href="#RUNTIME-CONFIG-WAL-RECOVERY-TARGET" class="id_link">#</a></h3></div></div></div><p>По умолчанию восстановление производится вплоть до окончания журнала WAL. Чтобы остановить процесс восстановления в более ранней точке, можно использовать один из следующих параметров: <code class="varname">recovery_target</code>, <code class="varname">recovery_target_lsn</code>, <code class="varname">recovery_target_name</code>, <code class="varname">recovery_target_time</code> или <code class="varname">recovery_target_xid</code>. Если в конфигурационном файле устанавливаются сразу несколько этих параметров, выдаётся ошибка. Задать эти параметры можно только при запуске сервера.</p><div class="variablelist"><dl class="variablelist"><dt id="GUC-RECOVERY-TARGET"><span class="term"><code class="varname">recovery_target</code><code class="literal">= 'immediate'</code>
      <a id="id-1.6.7.8.8.3.1.1.3" class="indexterm"></a>
      </span> <a href="#GUC-RECOVERY-TARGET" class="id_link">#</a></dt><dd><p>Данный параметр указывает, что процесс восстановления должен завершиться, как только будет достигнуто целостное состояние, т. е. как можно раньше. При восстановлении из оперативной резервной копии, это будет точкой, в которой завершился процесс резервного копирования.</p><p>Технически это строковый параметр, но значение <code class="literal">'immediate'</code> — единственно допустимое в данный момент.</p></dd><dt id="GUC-RECOVERY-TARGET-NAME"><span class="term"><code class="varname">recovery_target_name</code> (<code class="type">string</code>) <a id="id-1.6.7.8.8.3.2.1.3" class="indexterm"></a></span> <a href="#GUC-RECOVERY-TARGET-NAME" class="id_link">#</a></dt><dd><p>Этот параметр указывает именованную точку восстановления (созданную с помощью <code class="function">pg_create_restore_point()</code>), до которой будет производиться восстановление.</p></dd><dt id="GUC-RECOVERY-TARGET-TIME"><span class="term"><code class="varname">recovery_target_time</code> (<code class="type">timestamp</code>) <a id="id-1.6.7.8.8.3.3.1.3" class="indexterm"></a></span> <a href="#GUC-RECOVERY-TARGET-TIME" class="id_link">#</a></dt><dd><p>Данный параметр указывает точку времени, вплоть до которой будет производиться восстановление. Окончательно точка останова определяется в зависимости от значения <a class="xref" href="runtime-config-wal.html#GUC-RECOVERY-TARGET-INCLUSIVE">recovery_target_inclusive</a>.</p><p>Значение этого параметра задаётся в том же формате, что принимается типом данных <code class="type">timestamp with time zone</code>, за исключением того, что в нём нельзя использовать сокращённое название часового пояса (если только переменная <a class="xref" href="runtime-config-client.html#GUC-TIMEZONE-ABBREVIATIONS">timezone_abbreviations</a> не была установлена в файле конфигурации выше). Поэтому рекомендуется задавать числовое смещение от UTC или записывать название часового пояса полностью, например <code class="literal">Europe/Helsinki</code> (но не <code class="literal">EEST</code>).</p></dd><dt id="GUC-RECOVERY-TARGET-XID"><span class="term"><code class="varname">recovery_target_xid</code> (<code class="type">string</code>) <a id="id-1.6.7.8.8.3.4.1.3" class="indexterm"></a></span> <a href="#GUC-RECOVERY-TARGET-XID" class="id_link">#</a></dt><dd><p>Параметр указывает идентификатор транзакции, вплоть до которой необходимо произвести процедуру восстановления. Имейте в виду, что числовое значение идентификатора отражает последовательность именно старта транзакций, а фиксироваться они могут в ином порядке. Восстановлению будут подлежать все транзакции, что были зафиксированы до указанной (и, возможно, включая её). Точность точки останова также зависит от <a class="xref" href="runtime-config-wal.html#GUC-RECOVERY-TARGET-INCLUSIVE">recovery_target_inclusive</a>.</p></dd><dt id="GUC-RECOVERY-TARGET-LSN"><span class="term"><code class="varname">recovery_target_lsn</code> (<code class="type">pg_lsn</code>) <a id="id-1.6.7.8.8.3.5.1.3" class="indexterm"></a></span> <a href="#GUC-RECOVERY-TARGET-LSN" class="id_link">#</a></dt><dd><p>Данный параметр указывает LSN позиции в журнале предзаписи, до которой должно выполняться восстановление. Точная позиция остановки зависит также от параметра <a class="xref" href="runtime-config-wal.html#GUC-RECOVERY-TARGET-INCLUSIVE">recovery_target_inclusive</a>. Этот параметр принимает значение системного типа данных <a class="link" href="datatype-pg-lsn.html" title="8.20. Тип pg_lsn"><code class="type">pg_lsn</code></a>.</p></dd></dl></div><p>Следующие параметры уточняют целевую точку восстановления и определяют, что будет происходить при её достижении:</p><div class="variablelist"><dl class="variablelist"><dt id="GUC-RECOVERY-TARGET-INCLUSIVE"><span class="term"><code class="varname">recovery_target_inclusive</code> (<code class="type">boolean</code>) <a id="id-1.6.7.8.8.5.1.1.3" class="indexterm"></a></span> <a href="#GUC-RECOVERY-TARGET-INCLUSIVE" class="id_link">#</a></dt><dd><p>Указывает на необходимость остановки сразу после (<code class="literal">on</code>) либо до (<code class="literal">off</code>) достижения целевой точки. Применяется одновременно с <a class="xref" href="runtime-config-wal.html#GUC-RECOVERY-TARGET-LSN">recovery_target_lsn</a>, <a class="xref" href="runtime-config-wal.html#GUC-RECOVERY-TARGET-TIME">recovery_target_time</a> или <a class="xref" href="runtime-config-wal.html#GUC-RECOVERY-TARGET-XID">recovery_target_xid</a>. Этот параметр определяет, нужно ли восстанавливать транзакции, у которых позиция в WAL (LSN), время фиксации либо идентификатор в точности совпадает с заданным соответствующим значением. По умолчанию выбирается вариант <code class="literal">on</code>.</p></dd><dt id="GUC-RECOVERY-TARGET-TIMELINE"><span class="term"><code class="varname">recovery_target_timeline</code> (<code class="type">string</code>) <a id="id-1.6.7.8.8.5.2.1.3" class="indexterm"></a></span> <a href="#GUC-RECOVERY-TARGET-TIMELINE" class="id_link">#</a></dt><dd><p>Указывает линию времени для восстановления. Значение может задаваться числовым идентификатором линии времени или ключевым словом. С ключевым словом <code class="literal">current</code> восстанавливается та линия времени, которая была активной при создании базовой резервной копии. С ключевым словом <code class="literal">latest</code> восстанавливаться будет последняя линия времени, найденная в архиве, что полезно для ведомого сервера. По умолчанию подразумевается <code class="literal">latest</code>.</p><p>Чтобы указать идентификатор линии времени в шестнадцатеричном формате (например, если он извлечён из имени файла WAL или файла истории), добавьте к нему префикс <code class="literal">0x</code>. Например, если имя файла WAL — <code class="filename">00000011000000A10000004F</code>, то идентификатор линии времени — <code class="literal">0x11</code> (или десятичное число 17).</p><p>Задавать этот параметр обычно требуется только в сложных ситуациях с повторами восстановления, когда необходимо вернуться к состоянию, которое само было достигнуто после восстановления на момент времени. Это обсуждается в <a class="xref" href="continuous-archiving.html#BACKUP-TIMELINES" title="26.3.5. Линии времени">Подразделе 26.3.5</a>.</p></dd><dt id="GUC-RECOVERY-TARGET-ACTION"><span class="term"><code class="varname">recovery_target_action</code> (<code class="type">enum</code>) <a id="id-1.6.7.8.8.5.3.1.3" class="indexterm"></a></span> <a href="#GUC-RECOVERY-TARGET-ACTION" class="id_link">#</a></dt><dd><p>Указывает, какое действие должен предпринять сервер после достижения цели восстановления. Вариант по умолчанию — <code class="literal">pause</code>, что означает приостановку восстановления. Второй вариант, <code class="literal">promote</code>, означает, что процесс восстановления завершится, и сервер начнёт принимать подключения. Наконец, с вариантом <code class="literal">shutdown</code> сервер остановится, как только цель восстановления будет достигнута.</p><p>Вариант <code class="literal">pause</code> позволяет выполнить запросы к базе данных и убедиться в том, что достигнутая цель оказалась желаемой точкой восстановления. Для снятия с паузы нужно вызвать <code class="function">pg_wal_replay_resume()</code> (см. <a class="xref" href="functions-admin.html#FUNCTIONS-RECOVERY-CONTROL-TABLE" title="Таблица 9.93. Функции управления восстановлением">Таблицу 9.93</a>), что в итоге приведёт к завершению восстановления. Если же окажется, что мы ещё не достигли желаемой точки восстановления, нужно остановить сервер, установить более позднюю цель и перезапустить сервер для продолжения восстановления.</p><p>Вариант <code class="literal">shutdown</code> полезен для получения готового экземпляра сервера в желаемой точке. При этом данный экземпляр сможет воспроизводить дополнительные записи WAL (а при перезапуске ему придётся воспроизводить записи WAL после последней контрольной точки).</p><p>Заметьте, что так как <code class="filename">recovery.signal</code> не переименовывается, когда в <code class="varname">recovery_target_action</code> выбран вариант <code class="literal">shutdown</code>, при последующем запуске будет происходить немедленная остановка, пока вы не измените конфигурацию или не удалите файл <code class="filename">recovery.signal</code> вручную.</p><p>Этот параметр не действует, если цель восстановления не установлена. Если не включён режим <a class="xref" href="runtime-config-replication.html#GUC-HOT-STANDBY">hot_standby</a>, значение <code class="literal">pause</code> действует так же, как и <code class="literal">shutdown</code>. Если цель восстановления достигается в процессе повышения, <code class="literal">pause</code> действует как <code class="literal">promote</code>.</p><p>В любом случае, если задана цель восстановления, но восстановление архива завершается до её завершения, сервер завершит работу с критической ошибкой.</p></dd></dl></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="runtime-config-resource.html" title="20.4. Потребление ресурсов">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="runtime-config.html" title="Глава 20. Настройка сервера">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="runtime-config-replication.html" title="20.6. Репликация">След.</a></td></tr><tr><td width="40%" align="left" valign="top">20.4. Потребление ресурсов </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 20.6. Репликация</td></tr></table></div></body></html>