<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>39.3. Триггерные функции на языке C</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="trigger-datachanges.html" title="39.2. Видимость изменений в данных" /><link rel="next" href="trigger-example.html" title="39.4. Полный пример триггера" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">39.3. Триггерные функции на языке C</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="trigger-datachanges.html" title="39.2. Видимость изменений в данных">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="triggers.html" title="Глава 39. Триггеры">Наверх</a></td><th width="60%" align="center">Глава 39. Триггеры</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="trigger-example.html" title="39.4. Полный пример триггера">След.</a></td></tr></table><hr /></div><div class="sect1" id="TRIGGER-INTERFACE"><div class="titlepage"><div><div><h2 class="title" style="clear: both">39.3. Триггерные функции на языке C <a href="#TRIGGER-INTERFACE" class="id_link">#</a></h2></div></div></div><a id="id-1.8.4.7.2" class="indexterm"></a><a id="id-1.8.4.7.3" class="indexterm"></a><p>В этом разделе описываются низкоуровневые детали интерфейса для триггерных функций. Эта информация необходима только при разработке триггерных функций на языке C. При использовании языка более высокого уровня эти детали обрабатываются не видны. В большинстве случаев стоит рассмотреть возможность использования процедурного языка, прежде чем начать разрабатывать триггеры на C. В документации по каждому процедурному языку объясняется, как создавать триггеры на этом языке.</p><p>Триггерные функции должны использовать интерфейс функций <span class="quote">«<span class="quote">версии 1</span>»</span>.</p><p>Когда функция вызывается диспетчером триггеров, ей не передаются обычные аргументы, но передаётся указатель <span class="quote">«<span class="quote">context</span>»</span>, ссылающийся на структуру <code class="structname">TriggerData</code>. Функции на C могут проверить, вызваны ли они диспетчером триггеров или нет, выполнив макрос: </p><pre class="programlisting">CALLED_AS_TRIGGER(fcinfo)</pre><p> который разворачивается в: </p><pre class="programlisting">((fcinfo)-&gt;context != NULL &amp;&amp; IsA((fcinfo)-&gt;context, TriggerData))</pre><p> Если возвращается истина, то <code class="literal">fcinfo-&gt;context</code> можно безопасно привести к типу <code class="literal">TriggerData *</code> и использовать указатель на структуру <code class="structname">TriggerData</code>. Функция <span class="emphasis"><em>не</em></span> должна изменять структуру <code class="structname">TriggerData</code> или любые данные, которые на неё указывают.</p><p><code class="structname">struct TriggerData</code> определяется в <code class="filename">commands/trigger.h</code>: </p><pre class="programlisting">typedef struct TriggerData
{
    NodeTag          type;
    TriggerEvent     tg_event;
    Relation         tg_relation;
    HeapTuple        tg_trigtuple;
    HeapTuple        tg_newtuple;
    Trigger         *tg_trigger;
    TupleTableSlot  *tg_trigslot;
    TupleTableSlot  *tg_newslot;
    Tuplestorestate *tg_oldtable;
    Tuplestorestate *tg_newtable;
    const Bitmapset *tg_updatedcols;
} TriggerData;</pre><p> где элементы определяются следующим образом: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="structfield">type</code></span></dt><dd><p>Всегда <code class="literal">T_TriggerData</code>.</p></dd><dt><span class="term"><code class="structfield">tg_event</code></span></dt><dd><p>Описывает событие, для которого вызывается функция. Можно использовать следующие макросы для получения информации о <code class="literal">tg_event</code>: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">TRIGGER_FIRED_BEFORE(tg_event)</code></span></dt><dd><p>Возвращает истину, если триггер сработал до операции.</p></dd><dt><span class="term"><code class="literal">TRIGGER_FIRED_AFTER(tg_event)</code></span></dt><dd><p>Возвращает истину, если триггер сработал после операции.</p></dd><dt><span class="term"><code class="literal">TRIGGER_FIRED_INSTEAD(tg_event)</code></span></dt><dd><p>Возвращает истину, если триггер сработал вместо операции.</p></dd><dt><span class="term"><code class="literal">TRIGGER_FIRED_FOR_ROW(tg_event)</code></span></dt><dd><p>Возвращает истину, если триггер сработал на уровне строки.</p></dd><dt><span class="term"><code class="literal">TRIGGER_FIRED_FOR_STATEMENT(tg_event)</code></span></dt><dd><p>Возвращает истину, если триггер сработал на уровне оператора.</p></dd><dt><span class="term"><code class="literal">TRIGGER_FIRED_BY_INSERT(tg_event)</code></span></dt><dd><p>Возвращает истину, если триггер сработал для операции <code class="command">INSERT</code>.</p></dd><dt><span class="term"><code class="literal">TRIGGER_FIRED_BY_UPDATE(tg_event)</code></span></dt><dd><p>Возвращает истину, если триггер сработал для операции <code class="command">UPDATE</code>.</p></dd><dt><span class="term"><code class="literal">TRIGGER_FIRED_BY_DELETE(tg_event)</code></span></dt><dd><p>Возвращает истину, если триггер сработал для операции <code class="command">DELETE</code>.</p></dd><dt><span class="term"><code class="literal">TRIGGER_FIRED_BY_TRUNCATE(tg_event)</code></span></dt><dd><p>Возвращает истину, если триггер сработал для операции <code class="command">TRUNCATE</code>.</p></dd></dl></div></dd><dt><span class="term"><code class="structfield">tg_relation</code></span></dt><dd><p>Указатель на структуру, описывающую таблицу, для которой сработал триггер. Подробнее об этой структуре в <code class="filename">utils/rel.h</code>. Самое интересное здесь это <code class="literal">tg_relation-&gt;rd_att</code> (дескриптор записей таблицы) и <code class="literal">tg_relation-&gt;rd_rel-&gt;relname</code> (имя таблицы; имеет тип <code class="type">NameData</code>, а не <code class="type">char*</code>; используйте <code class="literal">SPI_getrelname(tg_relation)</code>, чтобы получить тип <code class="type">char*</code> если потребуется копия имени).</p></dd><dt><span class="term"><code class="structfield">tg_trigtuple</code></span></dt><dd><p>Указатель на строку, для которой сработал триггер. Это строка, которая вставляется, обновляется или удаляется. При срабатывании триггера для <code class="command">INSERT</code> или <code class="command">DELETE</code> это значение нужно вернуть из функции, только если не планируется изменять строку (в случае <code class="command">INSERT</code>) или пропускать операцию для этой строки.</p></dd><dt><span class="term"><code class="structfield">tg_newtuple</code></span></dt><dd><p>Для триггера на <code class="command">UPDATE</code> это указатель на новую версию строки либо <code class="symbol">NULL</code>, если триггер на <code class="command">INSERT</code> или <code class="command">DELETE</code>. Это значение нужно вернуть из функции в случае <code class="command">UPDATE</code>, если не планируется изменять строку или пропускать операцию для этой строки.</p></dd><dt><span class="term"><code class="structfield">tg_trigger</code></span></dt><dd><p>Указатель на структуру с типом <code class="structname">Trigger</code>, определённую в <code class="filename">utils/reltrigger.h</code>: </p><pre class="programlisting">typedef struct Trigger
{
    Oid         tgoid;
    char       *tgname;
    Oid         tgfoid;
    int16       tgtype;
    char        tgenabled;
    bool        tgisinternal;
    bool        tgisclone;
    Oid         tgconstrrelid;
    Oid         tgconstrindid;
    Oid         tgconstraint;
    bool        tgdeferrable;
    bool        tginitdeferred;
    int16       tgnargs;
    int16       tgnattr;
    int16      *tgattr;
    char      **tgargs;
    char       *tgqual;
    char       *tgoldtable;
    char       *tgnewtable;
} Trigger;</pre><p> где <code class="structfield">tgname</code> — имя триггера, <code class="structfield">tgnargs</code> — количество аргументов в <code class="structfield">tgargs</code>, и <code class="structfield">tgargs</code> — массив указателей на аргументы, указанные в команде <code class="command">CREATE TRIGGER</code>. Остальные члены структуры предназначены для внутреннего использования.</p></dd><dt><span class="term"><code class="structfield">tg_trigslot</code></span></dt><dd><p>Слот, содержащий <code class="structfield">tg_trigtuple</code>, или указатель <code class="symbol">NULL</code>, если такой строки нет.</p></dd><dt><span class="term"><code class="structfield">tg_newslot</code></span></dt><dd><p>Слот, содержащий <code class="structfield">tg_newtuple</code>, или указатель <code class="symbol">NULL</code>, если такой строки нет.</p></dd><dt><span class="term"><code class="structfield">tg_oldtable</code></span></dt><dd><p>Указатель на структуру типа <code class="structname">Tuplestorestate</code>, содержащую ноль или несколько строк в формате, определяемом содержимым <code class="structfield">tg_relation</code>, или указатель <code class="symbol">NULL</code>, если переходное отношение <code class="literal">OLD TABLE</code> отсутствует.</p></dd><dt><span class="term"><code class="structfield">tg_newtable</code></span></dt><dd><p>Указатель на структуру типа <code class="structname">Tuplestorestate</code>, содержащую ноль или несколько строк в формате, определяемом содержимым <code class="structfield">tg_relation</code>, или указатель <code class="symbol">NULL</code>, если переходное отношение <code class="literal">NEW TABLE</code> отсутствует.</p></dd><dt><span class="term"><code class="structfield">tg_updatedcols</code></span></dt><dd><p>Для триггеров <code class="literal">UPDATE</code> — битовая карта, в которой отмечается, какие столбцы изменила команда, вызвавшая срабатывание триггера. Используя её, универсальные триггерные функции могут оптимизировать свои действия, не обращая внимания на столбцы, которые не были изменены.</p><p>Определить, вошёл ли в битовую карту столбец с атрибутом под номером <code class="varname">attnum</code> (считая с 1), можно так: <code class="literal">bms_is_member(attnum - FirstLowInvalidHeapAttributeNumber, trigdata-&gt;tg_updatedcols))</code>.</p><p>Для всех остальных триггеров содержит <code class="symbol">NULL</code>.</p></dd></dl></div><p>Чтобы обращаться к переходным таблицам в запросах, выполняемых через SPI, используйте <a class="xref" href="spi-spi-register-trigger-data.html" title="SPI_register_trigger_data"><span class="refentrytitle">SPI_register_trigger_data</span></a>.</p><p>Триггерная функция должна возвращать указатель <code class="structname">HeapTuple</code> или указатель <code class="symbol">NULL</code> (но <span class="emphasis"><em>не</em></span> SQL значение <code class="literal">null</code>, то есть не нужно устанавливать <em class="parameter"><code>isNull</code></em> в истину). Не забудьте, что если не планируете менять обрабатываемую триггером строку, то нужно вернуть либо <code class="structfield">tg_trigtuple</code>, либо <code class="structfield">tg_newtuple</code>.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="trigger-datachanges.html" title="39.2. Видимость изменений в данных">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="triggers.html" title="Глава 39. Триггеры">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="trigger-example.html" title="39.4. Полный пример триггера">След.</a></td></tr><tr><td width="40%" align="left" valign="top">39.2. Видимость изменений в данных </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 39.4. Полный пример триггера</td></tr></table></div></body></html>