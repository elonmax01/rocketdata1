<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>15.1. Как работают параллельно выполняемые запросы</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="parallel-query.html" title="Глава 15. Параллельный запрос" /><link rel="next" href="when-can-parallel-query-be-used.html" title="15.2. Когда может применяться распараллеливание запросов?" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">15.1. Как работают параллельно выполняемые запросы</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="parallel-query.html" title="Глава 15. Параллельный запрос">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="parallel-query.html" title="Глава 15. Параллельный запрос">Наверх</a></td><th width="60%" align="center">Глава 15. Параллельный запрос</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="when-can-parallel-query-be-used.html" title="15.2. Когда может применяться распараллеливание запросов?">След.</a></td></tr></table><hr /></div><div class="sect1" id="HOW-PARALLEL-QUERY-WORKS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">15.1. Как работают параллельно выполняемые запросы <a href="#HOW-PARALLEL-QUERY-WORKS" class="id_link">#</a></h2></div></div></div><p>Когда оптимизатор определяет, что параллельное выполнение будет наилучшей стратегией для конкретного запроса, он создаёт план запроса, включающий <em class="firstterm">узел Gather</em> (Сбор) или <em class="firstterm">Gather Merge</em> (Сбор со слиянием). Взгляните на простой пример: </p><pre class="screen">
EXPLAIN SELECT * FROM pgbench_accounts WHERE filler LIKE '%x%';
                                     QUERY PLAN
-------------------------------------------------------------------​------------------
 Gather  (cost=1000.00..217018.43 rows=1 width=97)
   Workers Planned: 2
   -&gt;  Parallel Seq Scan on pgbench_accounts  (cost=0.00..216018.33 rows=1 width=97)
         Filter: (filler ~~ '%x%'::text)
(4 rows)
</pre><p>Во всех случаях узел <code class="literal">Gather</code> или <code class="literal">Gather Merge</code> будет иметь ровно один дочерний план, представляющий часть общего плана, выполняемую в параллельном режиме. Если узел <code class="literal">Gather</code> или <code class="literal">Gather Merge</code> располагается на самом верху дерева плана, в параллельном режиме будет выполняться весь запрос. Если он находится где-то в другом месте плана, параллельно будет выполняться только часть плана ниже него. В приведённом выше примере запрос обращается только к одной таблице, так что помимо узла <code class="literal">Gather</code> есть только ещё один узел плана; и так как этот узел является потомком узла <code class="literal">Gather</code>, он будет выполняться в параллельном режиме.</p><p><a class="link" href="using-explain.html" title="14.1. Использование EXPLAIN">Используя EXPLAIN</a>, вы можете узнать количество исполнителей, выбранное планировщиком для данного запроса. Когда при выполнении запроса достигается узел <code class="literal">Gather</code>, процесс, обслуживающий сеанс пользователя, запрашивает <a class="link" href="bgworker.html" title="Глава 48. Фоновые рабочие процессы">фоновые рабочие процессы</a> в этом количестве. Количество исполнителей, которое может попытаться задействовать планировщик, ограничивается значением <a class="xref" href="runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS-PER-GATHER">max_parallel_workers_per_gather</a>. Общее число фоновых рабочих процессов, которые могут существовать одновременно, ограничивается параметрами <a class="xref" href="runtime-config-resource.html#GUC-MAX-WORKER-PROCESSES">max_worker_processes</a> и <a class="xref" href="runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS">max_parallel_workers</a>. Таким образом, вполне возможно, что параллельный запрос будет выполняться меньшим числом рабочих процессов, чем планировалось, либо вообще без дополнительных рабочих процессов. Оптимальность плана может зависеть от числа доступных рабочих процессов, так что их нехватка может повлечь значительное снижение производительности. Если это наблюдается часто, имеет смысл увеличить <code class="varname">max_worker_processes</code> и <code class="varname">max_parallel_workers</code>, чтобы одновременно могло работать больше процессов, либо наоборот уменьшить <code class="varname">max_parallel_workers_per_gather</code>, чтобы планировщик запрашивал их в меньшем количестве.</p><p>Каждый фоновый рабочий процесс, успешно запущенный для данного параллельного запроса, будет выполнять параллельную часть плана. Ведущий процесс также будет выполнять эту часть плана, но он несёт дополнительную ответственность: он должен также прочитать все кортежи, выданные рабочими процессами. Когда параллельная часть плана выдаёт лишь небольшое количество кортежей, ведущий часто ведёт себя просто как один из рабочих процессов, ускоряя выполнение запроса. И напротив, когда параллельная часть плана выдаёт множество кортежей, ведущий может быть почти всё время занят чтением кортежей, выдаваемых другими рабочими процессами, и выполнять другие шаги обработки, связанные с узлами плана выше узла <code class="literal">Gather</code> или <code class="literal">Gather Merge</code>. В таких случаях ведущий процесс может вносить лишь минимальный вклад в выполнение параллельной части плана.</p><p>Когда над параллельной частью плана оказывается узел <code class="literal">Gather Merge</code>, а не <code class="literal">Gather</code>, это означает, что все процессы, выполняющие части параллельного плана, выдают кортежи в отсортированном порядке, и что ведущий процесс выполняет слияние с сохранением порядка. Узел же <code class="literal">Gather</code>, напротив, получает кортежи от подчинённых процессов в произвольном удобном ему порядке, нарушая порядок сортировки, который мог существовать.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="parallel-query.html" title="Глава 15. Параллельный запрос">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="parallel-query.html" title="Глава 15. Параллельный запрос">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="when-can-parallel-query-be-used.html" title="15.2. Когда может применяться распараллеливание запросов?">След.</a></td></tr><tr><td width="40%" align="left" valign="top">Глава 15. Параллельный запрос </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 15.2. Когда может применяться распараллеливание запросов?</td></tr></table></div></body></html>