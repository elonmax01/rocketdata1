<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Глава 58. Написание обработчика процедурного языка</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="nls-programmer.html" title="57.2. Программисту" /><link rel="next" href="fdwhandler.html" title="Глава 59. Написание обёртки сторонних данных" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">Глава 58. Написание обработчика процедурного языка</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="nls-programmer.html" title="57.2. Программисту">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="internals.html" title="Часть VII. Внутреннее устройство">Наверх</a></td><th width="60%" align="center">Часть VII. Внутреннее устройство</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="fdwhandler.html" title="Глава 59. Написание обёртки сторонних данных">След.</a></td></tr></table><hr /></div><div class="chapter" id="PLHANDLER"><div class="titlepage"><div><div><h2 class="title">Глава 58. Написание обработчика процедурного языка</h2></div></div></div><a id="id-1.10.9.2" class="indexterm"></a><p>Все функции, написанные на языке, вызываемом не через текущий интерфейс <span class="quote">«<span class="quote">версии 1</span>»</span> для компилируемых языков (а именно, это функции на процедурных языках и функции, написанные на SQL) выполняются через <em class="firstterm">обработчик вызова</em> для заданного языка. Задача такого обработчика вызова — выполнить функцию должным образом, например, интерпретируя для этого её исходный текст. В этой главе в общих чертах рассказывается, как можно написать обработчик нового процедурного языка.</p><p>Обработчик вызова процедурного языка — это <span class="quote">«<span class="quote">обычная</span>»</span> функция, которая разрабатывается на компилируемом языке, таком как C, вызывается через интерфейс версии 1, и регистрируется в <span class="productname">PostgreSQL</span> как не принимающая аргументы и возвращающая тип <code class="type">language_handler</code>. Этот специальный псевдотип помечает функцию как обработчик вызова и препятствует её вызову непосредственно из команд SQL. Более подробно соглашение о вызовах и динамическая загрузка кода на C описывается в <a class="xref" href="xfunc-c.html" title="38.10. Функции на языке C">Разделе 38.10</a>.</p><p>Обработчик вызова вызывается так же, как и любая другая функция: он получает указатель на переменную <code class="type">struct</code> <code class="structname">FunctionCallInfoBaseData</code>, содержащую значения аргументов и информацию о вызываемой функции, и должен вернуть результат типа <code class="type">Datum</code> (и, возможно, установить признак <code class="structfield">isnull</code> в структуре <code class="structname">FunctionCallInfoBaseData</code>, если нужно вернуть результат SQL NULL). Отличие обработчика вызова от обычной вызываемой функции состоит в том, что поле <code class="structfield">flinfo-&gt;fn_oid</code> структуры <code class="structname">FunctionCallInfoBaseData</code> для него будет содержать OID вызываемой функции, а не самого обработчика. По этому OID обработчик вызова должен понять, какую функцию вызывать. Кроме того, список передаваемых аргументов для него формируется в соответствии с объявлением целевой функции, а не обработчика вызова.</p><p>Обработчик вызова сам должен выбрать запись функции из системного каталога <code class="classname">pg_proc</code> и проанализировать типы аргументов и результата вызываемой функции. Содержимое предложения <code class="literal">AS</code> команды <code class="command">CREATE FUNCTION</code> для этой функции будет находиться в столбце <code class="literal">prosrc</code> строки в <code class="classname">pg_proc</code>. Обычно это исходный текст на процедурном языке, но в принципе это может быть и что-то другое, например, путь к файлу или иные данные, говорящие обработчику вызова, что именно делать.</p><p>Часто функция многократно вызывается в одном SQL-операторе. Чтобы в таких случаях избежать повторных обращений за информацией о вызываемой функции, обработчик вызова может воспользоваться полем <code class="structfield">flinfo-&gt;fn_extra</code>. Изначально оно содержит <code class="symbol">NULL</code>, но обработчик вызова может поместить в него указатель на требуемую информацию. При последующих вызовах, если поле <code class="structfield">flinfo-&gt;fn_extra</code> будет отлично от <code class="symbol">NULL</code>, им можно воспользоваться и пропустить шаг получения этой информации. Обработчик вызова должен позаботиться о том, чтобы указатель в <code class="structfield">flinfo-&gt;fn_extra</code> указывал на блок памяти, который не будет освобождён раньше, чем завершится запрос (именно столько может существовать структура <code class="structname">FmgrInfo</code>). В качестве одного из вариантов, этого можно добиться, разместив дополнительные данные в контексте памяти, заданном в <code class="structfield">flinfo-&gt;fn_mcxt</code>; срок жизни таких данных обычно совпадает со сроком жизни самой структуры <code class="structname">FmgrInfo</code>. С другой стороны, обработчик может выбрать и более долгоживущий контекст памяти с тем, чтобы кешировать определения функций и между запросами.</p><p>Когда функция на процедурном языке вызывается как триггер, ей не передаются аргументы обычным способом; вместо этого поле <code class="structfield">context</code> в <code class="structname">FunctionCallInfoBaseData</code> указывает на структуру <code class="structname">TriggerData</code>, тогда как при обычном вызове функции оно содержит <code class="symbol">NULL</code>. Обработчик языка, в свою очередь, должен каким-либо образом предоставить эту информацию функциям на этом процедурном языке.</p><p>Шаблон обработчика процедурного языка, написанный как расширение на C, представлен в <code class="literal">src/test/modules/plsample</code>. Это рабочий пример, показывающий, как можно создать обработчик процедурного языка, который будет принимать параметры и возвращать результат.</p><p>Хотя обработчика вызова достаточно для создания простейшего процедурного языка, есть ещё две функции, которые можно реализовать дополнительно, чтобы пользоваться языком было удобнее: функция <em class="firstterm">проверки</em> и <em class="firstterm">обработчик внедрённого кода</em>. Функцию проверки можно реализовать, чтобы производить проверку синтаксиса языка во время <a class="xref" href="sql-createfunction.html" title="CREATE FUNCTION"><span class="refentrytitle">CREATE FUNCTION</span></a>. Если же реализован обработчик внедрённого кода, этот язык будет поддерживать выполнение анонимных блоков кода командой <a class="xref" href="sql-do.html" title="DO"><span class="refentrytitle">DO</span></a>.</p><p>Если для процедурного языка предоставляется функция проверки, она должна быть объявлена как функция, принимающая один параметр типа <code class="type">oid</code>. Результат функции проверки игнорируется, так что она обычно объявляется как возвращающая тип <code class="type">void</code>. Эта функция будет вызываться в конце выполнения команды <code class="command">CREATE FUNCTION</code>, создающей или изменяющей функцию, написанную на процедурном языке. Переданный ей OID указывает на строку в <code class="classname">pg_proc</code> для этой функции. Функция проверки должна выбрать эту строку обычным образом и произвести все необходимые проверки. Прежде всего нужно вызвать <code class="function">CheckFunctionValidatorAccess()</code>, чтобы отличить явные вызовы этой функции от происходящих при выполнении команды <code class="command">CREATE FUNCTION</code>. Затем обычно проверяется, например, что типы аргументов и результата функции поддерживаются языком и что тело функции синтаксически правильно для данного языка. Если функция проверки заключает, что всё в порядке, она должна просто завершиться. Если же она обнаруживает ошибку, она должна сообщить о ней через обычный механизм <code class="function">ereport()</code>. Выданная таким образом ошибка приведёт к откату транзакции, так что определение некорректной функции зафиксировано не будет.</p><p>Функции проверки обычно должны учитывать параметр <a class="xref" href="runtime-config-client.html#GUC-CHECK-FUNCTION-BODIES">check_function_bodies</a>: если он отключён, то дорогостоящие или зависящие от контекста проверки содержимого функции выполнять не следует. Если язык подразумевает выполнение кода в процессе компиляции, проверяющая функция должна избегать проверок, которые влекут за собой такое выполнение. В частности, указанный параметр отключает утилита <span class="application">pg_dump</span>, чтобы она могла загружать функции на процедурных языках, не заботясь о побочных эффектах или зависимостях содержимого функций от других объектов базы. (Вследствие этого требования, обработчик языка не должен полагать, что функция прошла полную проверку. Смысл существования функции проверки не в том, чтобы убрать эти проверки из обработчика вызова, а в том, чтобы немедленно уведомить пользователя об очевидных ошибках при выполнении <code class="command">CREATE FUNCTION</code>.) Хотя выбор, что именно должно проверяться, по большому счёту остаётся за функцией проверки, заметьте, что основной код <code class="command">CREATE FUNCTION</code> выполняет присваивания <code class="literal">SET</code>, связанные с функцией, только когда <code class="varname">check_function_bodies</code> включён. Таким образом, проверки, результаты которых могут зависеть от параметров GUC, определённо должны опускаться, когда <code class="varname">check_function_bodies</code> отключён, во избежание ложных ошибок при восстановлении базы из копии.</p><p>Если для процедурного языка предоставляется обработчик встроенного кода, он должен объявляться в виде функции, принимающей один параметр типа <code class="type">internal</code>. Результат такого обработчика игнорируется, поэтому обычно он объявляется как возвращающий тип <code class="type">void</code>. Обработчик встроенного кода будет вызываться при выполнении оператора <code class="command">DO</code> с данным процедурным языком. В качестве параметра ему на самом деле передаётся указатель на структуру <code class="structname">InlineCodeBlock</code>, содержащую информацию о параметрах <code class="command">DO</code>, в частности, текст выполняемого анонимного блока внедрённого кода.</p><p>Все подобные объявления функций, а также саму команду <code class="command">CREATE LANGUAGE</code>, рекомендуется упаковывать в <em class="firstterm">расширение</em> так, чтобы для установки языка было достаточно простой команды <code class="command">CREATE EXTENSION</code>. За информацией о разработке расширений обратитесь к <a class="xref" href="extend-extensions.html" title="38.17. Упаковывание связанных объектов в расширение">Разделу 38.17</a>.</p><p>Реализация процедурных языков, включённых в стандартный дистрибутив, может послужить хорошим примером при написании собственных обработчиков языков. Её вы можете найти в подкаталоге <code class="filename">src/pl</code> дерева исходного кода. Некоторые полезные детали также можно узнать на странице справки <a class="xref" href="sql-createlanguage.html" title="CREATE LANGUAGE"><span class="refentrytitle">CREATE LANGUAGE</span></a>.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="nls-programmer.html" title="57.2. Программисту">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="internals.html" title="Часть VII. Внутреннее устройство">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="fdwhandler.html" title="Глава 59. Написание обёртки сторонних данных">След.</a></td></tr><tr><td width="40%" align="left" valign="top">57.2. Программисту </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> Глава 59. Написание обёртки сторонних данных</td></tr></table></div></body></html>