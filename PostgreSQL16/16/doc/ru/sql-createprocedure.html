<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CREATE PROCEDURE</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sql-createpolicy.html" title="CREATE POLICY" /><link rel="next" href="sql-createpublication.html" title="CREATE PUBLICATION" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">CREATE PROCEDURE</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-createpolicy.html" title="CREATE POLICY">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><th width="60%" align="center">Команды SQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-createpublication.html" title="CREATE PUBLICATION">След.</a></td></tr></table><hr /></div><div class="refentry" id="SQL-CREATEPROCEDURE"><div class="titlepage"></div><a id="id-1.9.3.76.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">CREATE PROCEDURE</span></h2><p>CREATE PROCEDURE — создать процедуру</p></div><div class="refsynopsisdiv"><h2>Синтаксис</h2><pre class="synopsis">CREATE [ OR REPLACE ] PROCEDURE
    <em class="replaceable"><code>имя</code></em> ( [ [ <em class="replaceable"><code>режим_аргумента</code></em> ] [ <em class="replaceable"><code>имя_аргумента</code></em> ] <em class="replaceable"><code>тип_аргумента</code></em> [ { DEFAULT | = } <em class="replaceable"><code>выражение_по_умолчанию</code></em> ] [, ...] ] )
  { LANGUAGE <em class="replaceable"><code>имя_языка</code></em>
    | TRANSFORM { FOR TYPE <em class="replaceable"><code>имя_типа</code></em> } [, ... ]
    | [ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER
    | SET <em class="replaceable"><code>параметр_конфигурации</code></em> { TO <em class="replaceable"><code>значение</code></em> | = <em class="replaceable"><code>значение</code></em> | FROM CURRENT }
    | AS '<em class="replaceable"><code>определение</code></em>'
    | AS '<em class="replaceable"><code>объектный_файл</code></em>', '<em class="replaceable"><code>объектный_символ</code></em>'
    | <em class="replaceable"><code>тело_sql</code></em>
  } ...</pre></div><div class="refsect1" id="SQL-CREATEPROCEDURE-DESCRIPTION"><h2>Описание</h2><p>Команда <code class="command">CREATE PROCEDURE</code> определяет новую процедуру. <code class="command">CREATE OR REPLACE PROCEDURE</code> создаёт новую процедуру либо заменяет определение уже существующей. Чтобы определить процедуру, необходимо иметь право <code class="literal">USAGE</code> для соответствующего языка.</p><p>Если указано имя схемы, процедура создаётся в заданной схеме, в противном случае — в текущей. Имя новой процедуры должно отличаться от имён существующих процедур и функций с такими же типами аргументов в этой схеме. Однако процедуры и функции с аргументами разных типов могут иметь одно имя (это называется <em class="firstterm">перегрузкой</em>).</p><p>Команда <code class="command">CREATE OR REPLACE PROCEDURE</code> предназначена для изменения текущего определения существующей процедуры. С её помощью нельзя изменить имя или типы аргументов (если попытаться сделать это, будет создана новая отдельная процедура).</p><p>Когда команда <code class="command">CREATE OR REPLACE PROCEDURE</code> заменяет существующую процедуру, владелец и права доступа к этой процедуре не меняются. Все другие свойства процедуры получают значения, задаваемые командой явно или по умолчанию. Чтобы заменить процедуру, необходимо быть её владельцем (или быть членом роли-владельца).</p><p>Владельцем процедуры становится создавший её пользователь.</p><p>Чтобы создать процедуру, необходимо иметь право <code class="literal">USAGE</code> для типов её аргументов.</p><p>За дополнительной информацией о разработке процедур обратитесь к <a class="xref" href="xproc.html" title="38.4. Пользовательские процедуры">Разделу 38.4</a>.</p></div><div class="refsect1" id="id-1.9.3.76.6"><h2>Параметры</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>имя</code></em></span></dt><dd><p>Имя создаваемой процедуры (возможно, дополненное схемой).</p></dd><dt><span class="term"><em class="replaceable"><code>режим_аргумента</code></em></span></dt><dd><p>Режим аргумента: <code class="literal">IN</code>, <code class="literal">OUT</code>, <code class="literal">INOUT</code> или <code class="literal">VARIADIC</code>. По умолчанию подразумевается <code class="literal">IN</code>.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_аргумента</code></em></span></dt><dd><p>Имя аргумента.</p></dd><dt><span class="term"><em class="replaceable"><code>тип_аргумента</code></em></span></dt><dd><p>Тип данных аргумента процедуры (возможно, дополненный схемой), при наличии аргументов. Тип аргументов может быть базовым, составным или доменным, либо это может быть ссылка на столбец таблицы.</p><p>В зависимости от языка реализации также может допускаться указание <span class="quote">«<span class="quote">псевдотипов</span>»</span>, например, <code class="type">cstring</code>. Псевдотипы показывают, что фактический тип аргумента либо определён не полностью, либо существует вне множества обычных типов SQL.</p><p>Ссылка на тип столбца записывается в виде <code class="literal"><em class="replaceable"><code>имя_таблицы</code></em>.<em class="replaceable"><code>имя_столбца</code></em>%TYPE</code>. Иногда такое указание бывает полезно, так как позволяет создать процедуру, независящую от изменений в определении таблицы.</p></dd><dt><span class="term"><em class="replaceable"><code>выражение_по_умолчанию</code></em></span></dt><dd><p>Выражение, используемое для вычисления значения по умолчанию, если параметр не задан явно. Результат выражения должен сводиться к типу соответствующего параметра. Для всех входных параметров, следующих за параметром с определённым значением по умолчанию, также должны быть определены значения по умолчанию.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_языка</code></em></span></dt><dd><p>Имя языка, на котором реализована процедура. Это может быть <code class="literal">sql</code>, <code class="literal">c</code>, <code class="literal">internal</code> либо имя процедурного языка, определённого пользователем, например, <code class="literal">plpgsql</code>. Если присутствует <em class="replaceable"><code>тело_sql</code></em>, подразумевается язык <code class="literal">sql</code>. Вариант написания этого имени в апострофах считается устаревшим и требует точного совпадения регистра.</p></dd><dt><span class="term"><code class="literal">TRANSFORM { FOR TYPE <em class="replaceable"><code>имя_типа</code></em> } [, ... ] }</code></span></dt><dd><p>Устанавливает список трансформаций, которые должны применяться при вызове процедуры. Трансформации выполняют преобразования между типами SQL и типами данных, специфичными для языков; см. <a class="xref" href="sql-createtransform.html" title="CREATE TRANSFORM"><span class="refentrytitle">CREATE TRANSFORM</span></a>. Преобразования встроенных типов обычно жёстко предопределены в реализациях процедурных языков, так что их здесь указывать не нужно. Если реализация процедурного языка не может обработать тип и трансформация для него отсутствует, будет выполнено преобразование типов по умолчанию, но это зависит от реализации.</p></dd><dt><span class="term"><code class="literal">[<span class="optional">EXTERNAL</span>] SECURITY INVOKER</code><br /></span><span class="term"><code class="literal">[<span class="optional">EXTERNAL</span>] SECURITY DEFINER</code></span></dt><dd><p>Характеристика <code class="literal">SECURITY INVOKER</code> (безопасность вызывающего) показывает, что процедура будет выполняться с правами пользователя, вызвавшего её. Этот вариант подразумевается по умолчанию. Вариант <code class="literal">SECURITY DEFINER</code> (безопасность определившего) обозначает, что процедура выполняется с правами пользователя, владеющего ей.</p><p>Ключевое слово <code class="literal">EXTERNAL</code> (внешняя) допускается для соответствия стандарту SQL, но является необязательным, так как, в отличие от SQL, эта характеристика распространяется на все процедуры, а не только внешние.</p><p>В процедуре с характеристикой <code class="literal">SECURITY DEFINER</code> не могут выполняться операторы управления транзакциями (например, <code class="command">COMMIT</code> и <code class="command">ROLLBACK</code> в некоторых языках).</p></dd><dt><span class="term"><em class="replaceable"><code>параметр_конфигурации</code></em><br /></span><span class="term"><em class="replaceable"><code>значение</code></em></span></dt><dd><p>Предложение <code class="literal">SET</code> определяет, что при вызове процедуры указанный параметр конфигурации должен принять заданное значение, а затем восстановить своё предыдущее значение при завершении процедуры. Предложение <code class="literal">SET FROM CURRENT</code> сохраняет в качестве значения, которое будет применено при входе в процедуру, значение, действующее в момент выполнения <code class="command">CREATE PROCEDURE</code>.</p><p>Если в определение процедуры добавлено <code class="literal">SET</code>, то действие команды <code class="command">SET LOCAL</code>, выполняемой внутри процедуры для того же параметра, ограничивается телом процедуры: предыдущее значение параметра так же будет восстановлено при завершении процедуры. Однако обычная команда <code class="command">SET</code> (без <code class="literal">LOCAL</code>) переопределяет предложение <code class="literal">SET</code>, как и предыдущую команду <code class="command">SET LOCAL</code>: действие такой команды будет сохранено и после завершения процедуры, если только не произойдёт откат транзакции.</p><p>Если к определению процедуры добавлено <code class="literal">SET</code>, то в этой процедуре не могут выполняться операторы управления транзакциями (например, <code class="command">COMMIT</code> и <code class="command">ROLLBACK</code> в некоторых языках).</p><p>За подробными сведениями об именах и значениях параметров обратитесь к <a class="xref" href="sql-set.html" title="SET"><span class="refentrytitle">SET</span></a> и <a class="xref" href="runtime-config.html" title="Глава 20. Настройка сервера">Главе 20</a>.</p></dd><dt><span class="term"><em class="replaceable"><code>определение</code></em></span></dt><dd><p>Строковая константа, определяющая реализацию процедуры; её значение зависит от языка. Это может быть имя внутренней процедуры, путь к объектному файлу, команда SQL или код на процедурном языке.</p><p>Часто бывает полезно заключать определение процедуры в доллары (см. <a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-DOLLAR-QUOTING" title="4.1.2.4. Строковые константы, заключённые в доллары">Подраздел 4.1.2.4</a>), а не в традиционные апострофы. Если не использовать доллары, все апострофы и обратные косые черты в определении процедуры придётся экранировать, дублируя их.</p></dd><dt><span class="term"><code class="literal"><em class="replaceable"><code>объектный_файл</code></em>, <em class="replaceable"><code>объектный_символ</code></em></code></span></dt><dd><p>Эта форма предложения <code class="literal">AS</code> применяется для динамически загружаемых процедур на языке C, когда имя процедуры в коде C не совпадает с именем процедуры в SQL. Строка <em class="replaceable"><code>объектный_файл</code></em> задаёт имя файла, содержащего скомпилированную процедуру на C (данная команда воспринимает эту строку так же, как и <a class="link" href="sql-load.html" title="LOAD"><code class="command">LOAD</code></a>). Строка <em class="replaceable"><code>объектный_символ</code></em> задаёт символ скомпонованной процедуры, то есть имя процедуры в исходном коде на языке C. Если объектный символ не указан, предполагается, что он совпадает с именем определяемой SQL-процедуры.</p><p>Если повторные вызовы <code class="command">CREATE PROCEDURE</code> ссылаются на один и тот же объектный файл, он загружается в рамках сеанса только один раз. Чтобы выгрузить и загрузить этот файл снова (например, в процессе разработки), начните новый сеанс.</p></dd><dt><span class="term"><em class="replaceable"><code>тело_sql</code></em></span></dt><dd><p>Тело процедуры в стиле <code class="literal">LANGUAGE SQL</code>. Это должен быть блок вида </p><pre class="programlisting">BEGIN ATOMIC
  <em class="replaceable"><code>оператор</code></em>;
  <em class="replaceable"><code>оператор</code></em>;
  ...
  <em class="replaceable"><code>оператор</code></em>;
END</pre><p>Оно определяется подобно телу, задаваемому строковой константой (см. <em class="replaceable"><code>определение</code></em> выше), но есть и некоторые различия. Эта форма работает только с функциями в стиле <code class="literal">LANGUAGE SQL</code>, тогда как форма со строковой константой поддерживается для всех языков. Она разбирается во время определения процедуры, тогда как форма со строковой константой — во время выполнения; как следствие, эта форма не поддерживает полиморфные типы аргументов и другие конструкции, которые нельзя обработать во время определения процедуры. С данной формой отслеживаются зависимости процедуры от объектов, используемых в её теле, так что команда <code class="literal">DROP ... CASCADE</code> выполнится корректно, тогда как в случае определения тела в строковой константе после такого удаления могут остаться неполноценные процедуры. Наконец, данная форма в большей степени соответствует стандарту SQL и совместима с другими реализациями SQL.</p></dd></dl></div></div><div class="refsect1" id="SQL-CREATEPROCEDURE-NOTES"><h2>Замечания</h2><p>Дополнительные детали создания функций, которые применимы и к процедурам, описываются в <a class="xref" href="sql-createfunction.html" title="CREATE FUNCTION"><span class="refentrytitle">CREATE FUNCTION</span></a>.</p><p>Чтобы выполнить процедуру, воспользуйтесь командой <a class="xref" href="sql-call.html" title="CALL"><span class="refentrytitle">CALL</span></a>.</p></div><div class="refsect1" id="SQL-CREATEPROCEDURE-EXAMPLES"><h2>Примеры</h2><pre class="programlisting">CREATE PROCEDURE insert_data(a integer, b integer)
LANGUAGE SQL
AS $$
INSERT INTO tbl VALUES (a);
INSERT INTO tbl VALUES (b);
$$;</pre><p> или </p><pre class="programlisting">CREATE PROCEDURE insert_data(a integer, b integer)
LANGUAGE SQL
BEGIN ATOMIC
  INSERT INTO tbl VALUES (a);
  INSERT INTO tbl VALUES (b);
END;</pre><p> и пример вызова: </p><pre class="programlisting">CALL insert_data(1, 2);</pre></div><div class="refsect1" id="SQL-CREATEPROCEDURE-COMPAT"><h2>Совместимость</h2><p>Команда <code class="command">CREATE FUNCTION</code> определена в стандарте SQL. Её реализация в <span class="productname">PostgreSQL</span> может использоваться совместимым образом, но дополнена множеством расширений. За подробностями обратитесь также к <a class="xref" href="sql-createfunction.html" title="CREATE FUNCTION"><span class="refentrytitle">CREATE FUNCTION</span></a>.</p></div><div class="refsect1" id="id-1.9.3.76.10"><h2>См. также</h2><span class="simplelist"><a class="xref" href="sql-alterprocedure.html" title="ALTER PROCEDURE"><span class="refentrytitle">ALTER PROCEDURE</span></a>, <a class="xref" href="sql-dropprocedure.html" title="DROP PROCEDURE"><span class="refentrytitle">DROP PROCEDURE</span></a>, <a class="xref" href="sql-call.html" title="CALL"><span class="refentrytitle">CALL</span></a>, <a class="xref" href="sql-createfunction.html" title="CREATE FUNCTION"><span class="refentrytitle">CREATE FUNCTION</span></a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-createpolicy.html" title="CREATE POLICY">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-createpublication.html" title="CREATE PUBLICATION">След.</a></td></tr><tr><td width="40%" align="left" valign="top">CREATE POLICY </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> CREATE PUBLICATION</td></tr></table></div></body></html>