<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>64.6. Функции оценки стоимости индекса</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="index-unique-checks.html" title="64.5. Проверки уникальности в индексе" /><link rel="next" href="generic-wal.html" title="Глава 65. Унифицированные записи WAL" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">64.6. Функции оценки стоимости индекса</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="index-unique-checks.html" title="64.5. Проверки уникальности в индексе">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="indexam.html" title="Глава 64. Определение интерфейса для индексных методов доступа">Наверх</a></td><th width="60%" align="center">Глава 64. Определение интерфейса для индексных методов доступа</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="generic-wal.html" title="Глава 65. Унифицированные записи WAL">След.</a></td></tr></table><hr /></div><div class="sect1" id="INDEX-COST-ESTIMATION"><div class="titlepage"><div><div><h2 class="title" style="clear: both">64.6. Функции оценки стоимости индекса <a href="#INDEX-COST-ESTIMATION" class="id_link">#</a></h2></div></div></div><p>Функции <code class="function">amcostestimate</code> даётся информация, описывающая возможное сканирование индекса, включая списки предложений WHERE и ORDER BY, которые были выбраны как применимые с данным индексом. Она должна вернуть оценки стоимости обращения к индексу и избирательность предложений WHERE (то есть, процент строк основной таблицы, который будет получен в ходе сканирования индекса). Для простых случаев почти всю работу оценщика стоимости можно произвести, вызывая стандартные процедуры оптимизатора; смысл существования функции <code class="function">amcostestimate</code> в том, чтобы индексные методы доступа могли поделиться знаниями, специфичными для типа индекса, когда это может помочь улучшить стандартные оценки.</p><p>Каждая функция <code class="function">amcostestimate</code> должна иметь такую сигнатуру: </p><pre class="programlisting">void
amcostestimate (PlannerInfo *root,
                IndexPath *path,
                double loop_count,
                Cost *indexStartupCost,
                Cost *indexTotalCost,
                Selectivity *indexSelectivity,
                double *indexCorrelation,
                double *indexPages);</pre><p> Первые три параметра передают входные значения: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>root</code></em></span></dt><dd><p>Информация планировщика о выполняемом запросе.</p></dd><dt><span class="term"><em class="parameter"><code>path</code></em></span></dt><dd><p>Рассматриваемый путь доступа к индексу. В нём действительны все поля, кроме значений стоимости и избирательности.</p></dd><dt><span class="term"><em class="parameter"><code>loop_count</code></em></span></dt><dd><p>Число повторений сканирования индекса, которое должно приниматься во внимание при оценке стоимости. Обычно оно будет больше одного, когда при соединении со вложенным циклом планируется параметризованное сканирование. Заметьте, что оценки стоимости тем не менее должны рассчитываться для всего одного сканирования; большие значения <em class="parameter"><code>loop_count</code></em> лишь дают основания предположить, что при многократном сканировании положительное влияние может оказать кеширование.</p></dd></dl></div><p>Последние пять параметров — указатели на переменные для выходных значений: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>*indexStartupCost</code></em></span></dt><dd><p>Стоимость выполнения запуска индекса</p></dd><dt><span class="term"><em class="parameter"><code>*indexTotalCost</code></em></span></dt><dd><p>Общая стоимость использования индекса</p></dd><dt><span class="term"><em class="parameter"><code>*indexSelectivity</code></em></span></dt><dd><p>Избирательность индекса</p></dd><dt><span class="term"><em class="parameter"><code>*indexCorrelation</code></em></span></dt><dd><p>Коэффициент корреляции между порядком сканирования индекса и порядком записей в нижележащей таблице</p></dd><dt><span class="term"><em class="parameter"><code>*indexPages</code></em></span></dt><dd><p>Количество страниц индекса на уровне листьев</p></dd></dl></div><p>Заметьте, что функции оценки стоимости должны разрабатываться на C, а не на SQL или другом доступном процедурном языке, так как они должны обращаться к внутренним структурам данным планировщика/оптимизатора.</p><p>Стоимости обращения к индексу следует вычислять с использованием параметров, объявленных в <code class="filename">src/backend/optimizer/path/costsize.c</code>: последовательная выборка дискового блока имеет стоимость <code class="varname">seq_page_cost</code>, непоследовательная выборка — <code class="varname">random_page_cost</code>, а стоимость обработки одной строки индекса обычно принимается равной <code class="varname">cpu_index_tuple_cost</code>. Кроме того, за каждый оператор сравнения, вызываемый при обработке индекса, должна взиматься цена <code class="varname">cpu_operator_cost</code> (особенно за вычисление собственно условий индекса).</p><p>Стоимость доступа должна включать стоимости всех дисковых и процессорных ресурсов, требующихся для сканирования самого индекса, <span class="emphasis"><em>но</em></span> не стоимости извлечения или обработки строк основной таблицы, с которой связан индекс.</p><p><span class="quote">«<span class="quote">Стоимость запуска</span>»</span> составляет часть общей стоимости сканирования, которая должна быть потрачена, прежде чем можно будет начать чтение первой строки. Для большинства индексов она может считаться нулевой, но для типов индексов с высокими затратами на запуск она может быть больше нуля.</p><p>Значение в <em class="parameter"><code>indexSelectivity</code></em> должно показывать, какой процент строк основной таблицы ожидается получить при сканировании таблицы. В случае неточного запроса это обычно будет больше процента строк, действительно удовлетворяющих заданным ограничивающим условиям.</p><p>В <em class="parameter"><code>indexCorrelation</code></em> записывается корреляция (в диапазоне от -1.0 до 1.0) между порядком записей в индексе и в таблице. Это значение будет корректировать оценку стоимости выборки строк из основной таблицы.</p><p>В <em class="parameter"><code>indexPages</code></em> записывается число страниц на уровне листьев. Это помогает выбрать число исполнителей для параллельного сканирования индекса.</p><p>Когда <em class="parameter"><code>loop_count</code></em> больше нуля, возвращаться должны средние значения, ожидаемые для одного сканирования индекса.</p><div class="procedure" id="id-1.10.15.12.13"><p class="title"><strong>Оценка стоимости</strong></p><p>Типичная процедура оценки выглядит следующим образом:</p><ol class="procedure" type="1"><li class="step"><p>Рассчитать и вернуть процент строк родительской таблицы, которые будут посещены при заданных ограничивающих условиях. В отсутствие каких-либо знаний, специфичных для типа индекса, использовать стандартную функцию оптимизатора <code class="function">clauselist_selectivity()</code>: </p><pre class="programlisting">*indexSelectivity = clauselist_selectivity(root, path-&gt;indexquals,
                                           path-&gt;indexinfo-&gt;rel-&gt;relid,
                                           JOIN_INNER, NULL);</pre></li><li class="step"><p>Оценить число строк индекса, которые будут посещены при сканировании. Для многих типов индексов это будет произведение <em class="parameter"><code>indexSelectivity</code></em> и числа строк в индексе, но оно может быть и больше. (Заметьте, что размер индекса в страницах и строках можно узнать из структуры <code class="literal">path-&gt;indexinfo</code>.)</p></li><li class="step"><p>Рассчитать число страниц индекса, которые будут получены при сканировании. Это может быть просто произведение <em class="parameter"><code>indexSelectivity</code></em> и размера индекса в страницах.</p></li><li class="step"><p>Вычислить стоимость обращения к индексу. Универсальный оценщик может сделать следующее: </p><pre class="programlisting">/*
 * Вообще предполагается, что страницы индекса будут считываться последовательно,
 * так что стоимость их чтения cost seq_page_cost, а не random_page_cost.
 * Также мы добавляем стоимость за вычисление условия индекса для каждой строки.
 * Все стоимости считаются пропорционально возрастающими при сканировании.
 */
cost_qual_eval(&amp;index_qual_cost, path-&gt;indexquals, root);
*indexStartupCost = index_qual_cost.startup;
*indexTotalCost = seq_page_cost * numIndexPages +
    (cpu_index_tuple_cost + index_qual_cost.per_tuple) * numIndexTuples;</pre><p> Однако при таком расчёте не учитывается амортизация чтения индекса при повторном сканировании.</p></li><li class="step"><p>Оценить корреляцию индекса. Для простого упорядоченного индекса по одному полю её можно получить из pg_statistic. Если корреляция неизвестна, вернуть консервативную оценку — ноль (корреляция отсутствует).</p></li></ol></div><p>Примеры функций оценки стоимости можно найти в <code class="filename">src/backend/utils/adt/selfuncs.c</code>.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="index-unique-checks.html" title="64.5. Проверки уникальности в индексе">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="indexam.html" title="Глава 64. Определение интерфейса для индексных методов доступа">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="generic-wal.html" title="Глава 65. Унифицированные записи WAL">След.</a></td></tr><tr><td width="40%" align="left" valign="top">64.5. Проверки уникальности в индексе </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> Глава 65. Унифицированные записи WAL</td></tr></table></div></body></html>