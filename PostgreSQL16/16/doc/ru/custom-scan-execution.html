<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>61.3. Выполнение нестандартного сканирования</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="custom-scan-plan.html" title="61.2. Создание нестандартных планов сканирования" /><link rel="next" href="geqo.html" title="Глава 62. Генетический оптимизатор запросов" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">61.3. Выполнение нестандартного сканирования</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="custom-scan-plan.html" title="61.2. Создание нестандартных планов сканирования">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="custom-scan.html" title="Глава 61. Написание провайдера нестандартного сканирования">Наверх</a></td><th width="60%" align="center">Глава 61. Написание провайдера нестандартного сканирования</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="geqo.html" title="Глава 62. Генетический оптимизатор запросов">След.</a></td></tr></table><hr /></div><div class="sect1" id="CUSTOM-SCAN-EXECUTION"><div class="titlepage"><div><div><h2 class="title" style="clear: both">61.3. Выполнение нестандартного сканирования <a href="#CUSTOM-SCAN-EXECUTION" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="custom-scan-execution.html#CUSTOM-SCAN-EXECUTION-CALLBACKS">61.3.1. Обработчики выполнения нестандартного сканирования</a></span></dt></dl></div><p>Когда выполняется узел <code class="structfield">CustomScan</code>, его состояние представляется структурой <code class="structfield">CustomScanState</code>, объявленной следующим образом: </p><pre class="programlisting">typedef struct CustomScanState
{
    ScanState ss;
    uint32    flags;
    const CustomExecMethods *methods;
} CustomScanState;</pre><p>Поле <code class="structfield">ss</code> инициализируется как и для состояния любого другого сканирования, за исключением того, что когда это сканирование для соединения, а не для базового отношения, в <code class="literal">ss.ss_currentRelation</code> остаётся NULL. Поле <code class="structfield">flags</code> содержит битовую маску с тем же значением, что и в <code class="structname">CustomPath</code> и <code class="structname">CustomScan</code>. Поле <code class="structfield">methods</code> должно указывать на объект (обычно статически размещённый), реализующий требуемые методы состояния нестандартного сканирования, подробнее описанные ниже. Обычно структура <code class="structname">CustomScanState</code>, которой не нужно поддерживать <code class="function">copyObject</code>, фактически включается в расширенную структуру в качестве её первого члена.</p><div class="sect2" id="CUSTOM-SCAN-EXECUTION-CALLBACKS"><div class="titlepage"><div><div><h3 class="title">61.3.1. Обработчики выполнения нестандартного сканирования <a href="#CUSTOM-SCAN-EXECUTION-CALLBACKS" class="id_link">#</a></h3></div></div></div><pre class="programlisting">void (*BeginCustomScan) (CustomScanState *node,
                         EState *estate,
                         int eflags);</pre><p> Завершает инициализацию переданного объекта <code class="structname">CustomScanState</code>. Стандартные поля инициализируются в <code class="function">ExecInitCustomScan</code>, но все внутренние поля должны инициализироваться здесь.</p><pre class="programlisting">TupleTableSlot *(*ExecCustomScan) (CustomScanState *node);</pre><p> Считывает следующий кортеж. В случае наличия кортежей эта функция должна записать в <code class="literal">ps_ResultTupleSlot</code> следующий кортеж в текущем направлении сканирования и вернуть слот с кортежем. Если же кортежей больше нет, она должна вернуть <code class="literal">NULL</code> или пустой слот.</p><pre class="programlisting">void (*EndCustomScan) (CustomScanState *node);</pre><p> Очищает все внутренние данные, связанные с <code class="literal">CustomScanState</code>. Этот метод является обязательным, но он может ничего не делать, если такие данные отсутствуют или они будут очищены автоматически.</p><pre class="programlisting">void (*ReScanCustomScan) (CustomScanState *node);</pre><p> Возвращает позицию текущего сканирования в начало и подготавливает повторное сканирование отношения.</p><pre class="programlisting">void (*MarkPosCustomScan) (CustomScanState *node);</pre><p> Сохраняет текущую позицию сканирования, чтобы к ней впоследствии можно было вернуться, вызвав обработчик <code class="function">RestrPosCustomScan</code>. Данный обработчик является необязательным и должен присутствовать, только если установлен флаг <code class="literal">CUSTOMPATH_SUPPORT_MARK_RESTORE</code>.</p><pre class="programlisting">void (*RestrPosCustomScan) (CustomScanState *node);</pre><p> Восстанавливает предыдущую позицию сканирования, сохранённую обработчиком <code class="function">MarkPosCustomScan</code>. Данный обработчик является необязательным и должен присутствовать, только если установлен флаг <code class="literal">CUSTOMPATH_SUPPORT_MARK_RESTORE</code>.</p><pre class="programlisting">Size (*EstimateDSMCustomScan) (CustomScanState *node,
                               ParallelContext *pcxt);</pre><p> Оценивает объём динамической разделяемой памяти, которая потребуется для параллельной операции. Это значение может превышать объём, который будет занят фактически, но не должно быть меньше. Возвращаемое значение задаётся в байтах. Этот обработчик не является обязательным и должен устанавливаться, только если провайдер нестандартного сканирования поддерживает параллельное выполнение.</p><pre class="programlisting">void (*InitializeDSMCustomScan) (CustomScanState *node,
                                 ParallelContext *pcxt,
                                 void *coordinate);</pre><p> Инициализирует динамическую разделяемую память, которая потребуется для параллельной операции; <code class="literal">coordinate</code> указывает на область разделяемой памяти размера, равного возвращаемому значению <code class="function">EstimateDSMCustomScan</code>. Этот обработчик является необязательным и должен устанавливаться, только если провайдер нестандартного сканирования поддерживает параллельное выполнение.</p><pre class="programlisting">void (*ReInitializeDSMCustomScan) (CustomScanState *node,
                                   ParallelContext *pcxt,
                                   void *coordinate);</pre><p> Заново инициализирует динамическую разделяемую память, требуемую для параллельной операции, перед тем как будет повторно просканирован узел нестандартного сканирования. Этот обработчик является необязательным и должен устанавливаться, только если провайдер нестандартного сканирования поддерживает параллельное выполнение. В этом обработчике рекомендуется сбрасывать только общее состояние, а в обработчике <code class="function">ReScanCustomScan</code> сбрасывать только локальное. В настоящее время этот обработчик будет вызываться перед <code class="function">ReScanCustomScan</code>, но лучше на этот порядок не рассчитывать.</p><pre class="programlisting">void (*InitializeWorkerCustomScan) (CustomScanState *node,
                                    shm_toc *toc,
                                    void *coordinate);</pre><p> Инициализирует локальное состояние параллельного исполнителя на основе общего состояния, заданного ведущим исполнителем во время <code class="function">InitializeDSMCustomScan</code>. Этот обработчик является необязательным и должен устанавливаться, только если провайдер нестандартного сканирования поддерживает параллельное выполнение.</p><pre class="programlisting">void (*ShutdownCustomScan) (CustomScanState *node);</pre><p> Освобождает ресурсы, когда становится понятно, что этот узел больше не будет выполняться. Этот обработчик вызывается не во всех случаях; иногда может вызываться только <code class="literal">EndCustomScan</code>. Так как сегмент DSM, используемый параллельным запросом, освобождается сразу после вызова этого обработчика, провайдеры нестандартного сканирования, которым нужно выполнять некоторые действия до ликвидации сегмента DSM, должны реализовывать этот метод.</p><pre class="programlisting">void (*ExplainCustomScan) (CustomScanState *node,
                           List *ancestors,
                           ExplainState *es);</pre><p> Выводит дополнительную информацию для <code class="command">EXPLAIN</code> об узле нестандартного сканирования. Этот обработчик является необязательным. Общие данные, сохранённые в <code class="structname">ScanState</code>, такие как целевой список и сканируемое отношение, будут выводиться и без этого обработчика, но с помощью этого обработчика можно выдать дополнительные, внутренние сведения.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="custom-scan-plan.html" title="61.2. Создание нестандартных планов сканирования">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="custom-scan.html" title="Глава 61. Написание провайдера нестандартного сканирования">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="geqo.html" title="Глава 62. Генетический оптимизатор запросов">След.</a></td></tr><tr><td width="40%" align="left" valign="top">61.2. Создание нестандартных планов сканирования </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> Глава 62. Генетический оптимизатор запросов</td></tr></table></div></body></html>