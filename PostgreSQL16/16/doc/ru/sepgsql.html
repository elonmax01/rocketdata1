<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>F.40. sepgsql — проверка безопасности на базе политик SELinux для мандатного управления доступом (MAC, Mandatory Access Control) с метками</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="seg.html" title="F.39. seg — тип данных для отрезков или интервалов чисел с плавающей точкой" /><link rel="next" href="contrib-spi.html" title="F.41. spi — особенности/примеры использования интерфейса программирования сервера" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">F.40. sepgsql — проверка безопасности на базе политик SELinux для мандатного управления доступом (MAC, Mandatory Access Control) с метками</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="seg.html" title="F.39. seg — тип данных для отрезков или интервалов чисел с плавающей точкой">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="contrib.html" title="Приложение F. Дополнительно поставляемые модули и расширения">Наверх</a></td><th width="60%" align="center">Приложение F. Дополнительно поставляемые модули и расширения</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="contrib-spi.html" title="F.41. spi — особенности/примеры использования интерфейса программирования сервера">След.</a></td></tr></table><hr /></div><div class="sect1" id="SEPGSQL"><div class="titlepage"><div><div><h2 class="title" style="clear: both">F.40. sepgsql — проверка безопасности на базе политик SELinux для мандатного управления доступом (MAC, Mandatory Access Control) с метками <a href="#SEPGSQL" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="sepgsql.html#SEPGSQL-OVERVIEW">F.40.1. Обзор</a></span></dt><dt><span class="sect2"><a href="sepgsql.html#SEPGSQL-INSTALLATION">F.40.2. Установка</a></span></dt><dt><span class="sect2"><a href="sepgsql.html#SEPGSQL-REGRESSION">F.40.3. Регрессионные тесты</a></span></dt><dt><span class="sect2"><a href="sepgsql.html#SEPGSQL-PARAMETERS">F.40.4. Параметры GUC</a></span></dt><dt><span class="sect2"><a href="sepgsql.html#SEPGSQL-FEATURES">F.40.5. Функциональные возможности</a></span></dt><dt><span class="sect2"><a href="sepgsql.html#SEPGSQL-FUNCTIONS">F.40.6. Функции sepgsql</a></span></dt><dt><span class="sect2"><a href="sepgsql.html#SEPGSQL-LIMITATIONS">F.40.7. Ограничения</a></span></dt><dt><span class="sect2"><a href="sepgsql.html#SEPGSQL-RESOURCES">F.40.8. Внешние ресурсы</a></span></dt><dt><span class="sect2"><a href="sepgsql.html#SEPGSQL-AUTHOR">F.40.9. Автор</a></span></dt></dl></div><a id="id-1.11.7.50.2" class="indexterm"></a><p>Загружаемый модуль <code class="filename">sepgsql</code> поддерживает мандатное управление доступом (MAC, Mandatory Access Control) с метками, построенное на базе политик безопасности <span class="productname">SELinux</span>.</p><div class="warning"><h3 class="title">Предупреждение</h3><p>Текущая реализация имеет существенные ограничения и контролирует не все действия. См. <a class="xref" href="sepgsql.html#SEPGSQL-LIMITATIONS" title="F.40.7. Ограничения">Подраздел F.40.7</a>.</p></div><div class="sect2" id="SEPGSQL-OVERVIEW"><div class="titlepage"><div><div><h3 class="title">F.40.1. Обзор <a href="#SEPGSQL-OVERVIEW" class="id_link">#</a></h3></div></div></div><p>Этот модуль интегрируется в <span class="productname">SELinux</span> и обеспечивает дополнительный уровень проверок безопасности, расширяющий и дополняющий обычные средства <span class="productname">PostgreSQL</span>. С точки зрения <span class="productname">SELinux</span>, данный модуль позволяет <span class="productname">PostgreSQL</span> выполнять роль менеджера объектов в пространстве пользователя. При выполнении запроса DML обращение к каждой таблице или функции в нём будет контролироваться согласно системной политике безопасности. Эта проверка дополняет штатную проверку разрешений SQL, которую производит <span class="productname">PostgreSQL</span>.</p><p>Механизм <span class="productname">SELinux</span> принимает решения о разрешении доступа на основе меток безопасности, представляемых строками вида <code class="literal">system_u:object_r:sepgsql_table_t:s0</code>. В каждом решении учитываются две метки: метка субъекта, пытающегося выполнить действие, и метка объекта, над которым должно совершаться это действие. Так как эти метки могут применяться к объекту любого вида, решения о разрешении доступа к объектам внутри базы данных могут подчиняться (и с этим модулем фактически подчиняются) общим критериям, применяемым к объектам любого другого типа, например, к файлам. Эта схема позволяет организовать централизованную политику безопасности для защиты информационных активов, не зависящую от того, как именно хранятся эти активы.</p><p>Назначить метку безопасности объекту баз данных позволяет команда <a class="link" href="sql-security-label.html" title="SECURITY LABEL"><code class="command">SECURITY LABEL</code></a>.</p></div><div class="sect2" id="SEPGSQL-INSTALLATION"><div class="titlepage"><div><div><h3 class="title">F.40.2. Установка <a href="#SEPGSQL-INSTALLATION" class="id_link">#</a></h3></div></div></div><p>Модуль <code class="filename">sepgsql</code> может работать только в <span class="productname">Linux</span> 2.6.28 и новее с включённым <span class="productname">SELinux</span>. На остальных платформах он не поддерживается. Вам также понадобится <span class="productname">libselinux</span> 2.1.10 или новее и <span class="productname">selinux-policy</span> 3.9.13 или новее (хотя в некоторых дистрибутивах необходимые правила могут быть адаптированы к политике старой версии).</p><p>Команда <code class="command">sestatus</code> позволяет проверить состояние <span class="productname">SELinux</span>. Типичный её вывод выглядит так: </p><pre class="screen">
$ sestatus
SELinux status:                 enabled
SELinuxfs mount:                /selinux
Current mode:                   enforcing
Mode from config file:          enforcing
Policy version:                 24
Policy from config file:        targeted
</pre><p> Если <span class="productname">SELinux</span> отключён или не установлен, его необходимо привести в рабочее состояние, прежде чем устанавливать этот модуль.</p><p>Чтобы собрать этот модуль, добавьте параметр <code class="literal">--with-selinux</code> в команду PostgreSQL <code class="literal">configure</code>. Убедитесь в том, что в момент сборки установлен RPM-пакет <code class="filename">libselinux-devel</code>.</p><p>Чтобы использовать этот модуль, вы должны включить <code class="literal">sepgsql</code> в <a class="xref" href="runtime-config-client.html#GUC-SHARED-PRELOAD-LIBRARIES">shared_preload_libraries</a> в <code class="filename">postgresql.conf</code>. Этот модуль не будет корректно работать, если загрузить его каким-либо другим способом. Загрузив его, нужно выполнить <code class="filename">sepgsql.sql</code> в каждой базе данных. Этот скрипт установит функции, необходимые для управления метками безопасности, и назначит начальные метки безопасности.</p><p>Следующий пример показывает, как инициализировать новый кластер баз данных и установить в него функции и метки безопасности <code class="filename">sepgsql</code>. Измените пути в соответствии с размещением вашей инсталляции:</p><pre class="screen">$ export PGDATA=/path/to/data/directory
$ initdb
$ vi $PGDATA/postgresql.conf
  изменить
    #shared_preload_libraries = ''                # (после изменения требуется перезапуск)
  на
    shared_preload_libraries = 'sepgsql'          # (после изменения требуется перезапуск)
$ for DBNAME in template0 template1 postgres; do
    postgres --single -F -c exit_on_error=true $DBNAME \
      &lt;/usr/local/pgsql/share/contrib/sepgsql.sql &gt;/dev/null
  done</pre><p>Заметьте, что вы можете увидеть следующие уведомления, в зависимости от конкретных установленных версий <span class="productname">libselinux</span> и <span class="productname">selinux-policy</span>: </p><pre class="screen">
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 33 has invalid object type db_blobs
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 36 has invalid object type db_language
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 37 has invalid object type db_language
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 38 has invalid object type db_language
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 39 has invalid object type db_language
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 40 has invalid object type db_language
</pre><p> Эти сообщения не критичны и их можно игнорировать.</p><p>Если процесс установки завершается без ошибок, вы можете запустить сервер обычным образом.</p></div><div class="sect2" id="SEPGSQL-REGRESSION"><div class="titlepage"><div><div><h3 class="title">F.40.3. Регрессионные тесты <a href="#SEPGSQL-REGRESSION" class="id_link">#</a></h3></div></div></div><p>Природа <span class="productname">SELinux</span> такова, что для проведения регрессионных тестов <code class="filename">sepgsql</code> требуются дополнительные действия по настройке и некоторые из них должен выполнять root. Регрессионные тесты не будут запускаться обычной командой <code class="literal">make check</code> или <code class="literal">make installcheck</code>; вы должны настроить конфигурацию и затем вызвать тестовый скрипт вручную. Тесты должны запускаться в каталоге <code class="filename">contrib/sepgsql</code> настроенного дерева сборки PostgreSQL. Хотя им требуется дерево сборки, эти тесты рассчитаны на использование установленного сервера, то есть они примерно соответствуют <code class="literal">make installcheck</code>, но не <code class="literal">make check</code>.</p><p>Сначала установите <code class="filename">sepgsql</code> в рабочую базу данных по инструкциям, приведённым в <a class="xref" href="sepgsql.html#SEPGSQL-INSTALLATION" title="F.40.2. Установка">Подразделе F.40.2</a>. Заметьте, что для этого текущий пользователь операционной системы должен подключаться к базе данных как суперпользователь без аутентификации по паролю.</p><p>На втором шаге соберите и установите пакет политики для регрессионного теста. Политика <code class="filename">sepgsql-regtest</code> представляет собой политику особого назначения, предоставляющую набор правил, включаемых во время регрессионных тестов. Её следует скомпилировать из исходного файла <code class="filename">sepgsql-regtest.te</code>, что можно сделать командой <code class="command">make</code> со скриптом Makefile, поставляемым с SELinux. Вам нужно будет найти нужный Makefile в своей системе; путь, показанный ниже, приведён только в качестве примера. (Этот Makefile обычно распространяется в RPM-пакете <code class="filename">selinux-policy-devel</code> или <code class="filename">selinux-policy</code>.) Скомпилировав пакет политики, его нужно установить с помощью команды <code class="command">semodule</code>, которая загружает переданные ей пакеты в ядро. Если пакет установлен корректно, команда <code class="literal"><code class="command">semodule</code> -l</code> должна вывести <code class="literal">sepgsql-regtest</code> в списке доступных пакетов политик:</p><pre class="screen">$ cd .../contrib/sepgsql
$ make -f /usr/share/selinux/devel/Makefile
$ sudo semodule -u sepgsql-regtest.pp
$ sudo semodule -l | grep sepgsql
sepgsql-regtest 1.07</pre><p>На третьем шаге включите параметр <code class="literal">sepgsql_regression_test_mode</code>. По соображениям безопасности, правила в <code class="filename">sepgsql-regtest</code> по умолчанию неактивны; параметр <code class="literal">sepgsql_regression_test_mode</code> активирует правила, необходимые для проведения регрессионных тестов. Включить этот параметр можно командой <code class="command">setsebool</code>:</p><pre class="screen">$ sudo setsebool sepgsql_regression_test_mode on
$ getsebool sepgsql_regression_test_mode
sepgsql_regression_test_mode --&gt; on</pre><p>На четвёртом шаге убедитесь в том, что ваша оболочка работает в домене <code class="literal">unconfined_t</code>:</p><pre class="screen">$ id -Z
unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</pre><p>Если необходимо сменить рабочий домен, в подробностях это описывается в <a class="xref" href="sepgsql.html#SEPGSQL-RESOURCES" title="F.40.8. Внешние ресурсы">Подразделе F.40.8</a>.</p><p>Наконец, запустите скрипт регрессионного теста:</p><pre class="screen">$ ./test_sepgsql</pre><p>Этот скрипт попытается проверить, все ли шаги по настройке конфигурации выполнены корректно, а затем запустит регрессионные тесты для модуля <code class="filename">sepgsql</code>.</p><p>Завершив тесты, рекомендуется отключить параметр <code class="literal">sepgsql_regression_test_mode</code>:</p><pre class="screen">$ sudo setsebool sepgsql_regression_test_mode off</pre><p>Другой, возможно, более предпочтительный вариант — удалить политику <code class="filename">sepgsql-regtest</code> полностью:</p><pre class="screen">$ sudo semodule -r sepgsql-regtest</pre></div><div class="sect2" id="SEPGSQL-PARAMETERS"><div class="titlepage"><div><div><h3 class="title">F.40.4. Параметры GUC <a href="#SEPGSQL-PARAMETERS" class="id_link">#</a></h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt id="GUC-SEPGSQL-PERMISSIVE"><span class="term"><code class="varname">sepgsql.permissive</code> (<code class="type">boolean</code>) <a id="id-1.11.7.50.8.2.1.1.3" class="indexterm"></a></span> <a href="#GUC-SEPGSQL-PERMISSIVE" class="id_link">#</a></dt><dd><p>Этот параметр переводит <code class="filename">sepgsql</code> в разрешительный режим, вне зависимости от режима системы. По умолчанию он имеет значение off (отключён). Задать этот параметр можно только в <code class="filename">postgresql.conf</code> или в командной строке при запуске сервера.</p><p>Когда этот параметр включён, <code class="filename">sepgsql</code> действует в разрешительном режиме, даже если SELinux в целом находится в ограничительном режиме. Этот параметр полезен в первую очередь для тестирования.</p></dd><dt id="GUC-SEPGSQL-DEBUG-AUDIT"><span class="term"><code class="varname">sepgsql.debug_audit</code> (<code class="type">boolean</code>) <a id="id-1.11.7.50.8.2.2.1.3" class="indexterm"></a></span> <a href="#GUC-SEPGSQL-DEBUG-AUDIT" class="id_link">#</a></dt><dd><p>Этот параметр включает вывод сообщений аудита вне зависимости от параметров системной политики. По умолчанию он отключён (имеет значение off), что означает, что сообщения будут выводиться согласно параметрам системы.</p><p>Политики безопасности <span class="productname">SELinux</span> также содержит правила, определяющие, будут ли фиксироваться в журнале определённые события. По умолчанию фиксируются нарушения доступа, а успешный доступ — нет.</p><p>Этот параметр принудительно включает фиксирование в журнале всех возможных событий, вне зависимости от системной политики.</p></dd></dl></div></div><div class="sect2" id="SEPGSQL-FEATURES"><div class="titlepage"><div><div><h3 class="title">F.40.5. Функциональные возможности <a href="#SEPGSQL-FEATURES" class="id_link">#</a></h3></div></div></div><div class="sect3" id="SEPGSQL-FEATURES-CONTROLLED-OBJ-CLASSES"><div class="titlepage"><div><div><h4 class="title">F.40.5.1. Управляемые классы объектов <a href="#SEPGSQL-FEATURES-CONTROLLED-OBJ-CLASSES" class="id_link">#</a></h4></div></div></div><p>Модель безопасности <span class="productname">SELinux</span> описывает все правила доступа в виде отношений между сущностью субъекта (обычно, это клиент базы данных) и сущностью объекта (например, объектом базы данных), каждая из которых определяется меткой безопасности. Если осуществляется попытка доступа к непомеченному объекту, он обрабатывается как объект, имеющий метку <code class="literal">unlabeled_t</code>.</p><p>В настоящее время <code class="filename">sepgsql</code> позволяет назначать метки безопасности схемам, таблицам, столбцам, последовательностям, представлениям и функциям. Когда <code class="filename">sepgsql</code> активен, метки безопасности автоматически назначаются поддерживаемым объектам базы в момент создания. Такая метка называется меткой безопасности по умолчанию и устанавливается согласно политике безопасности системы, которая учитывает метку создателя, метку, назначенную родительскому объекту создаваемого объекта и, возможно, имя создаваемого объекта.</p><p>Новый объект базы, как правило, наследует метку безопасности, назначенную родительскому объекту, если только в политике безопасности не заданы специальные правила, называемые правилами перехода типов (в этом случае может быть назначена другая метка). Для схем родительским объектом является текущая база данных; для таблиц, последовательностей, представлений и функций — схема, содержащая эти объекты; для столбцов — таблица.</p></div><div class="sect3" id="SEPGSQL-FEATURES-DML-PERMISSIONS"><div class="titlepage"><div><div><h4 class="title">F.40.5.2. Разрешения для DML <a href="#SEPGSQL-FEATURES-DML-PERMISSIONS" class="id_link">#</a></h4></div></div></div><p>Для таблиц, задействованных в запросе в качестве целевых, проверяются разрешения <code class="literal">db_table:select</code>, <code class="literal">db_table:insert</code>, <code class="literal">db_table:update</code> или <code class="literal">db_table:delete</code> в зависимости от типа оператора; кроме того, для всех таблиц, содержащих столбцы, фигурирующие в предложении <code class="literal">WHERE</code> или <code class="literal">RETURNING</code>, или служащих источником данных для <code class="literal">UPDATE</code> и т. п., также проверяется разрешение <code class="literal">db_table:select</code>.</p><p>Для всех задействованных столбцов также проверяются разрешения на уровне столбцов. Разрешение <code class="literal">db_column:select</code> проверяется не только для столбцов, которые считываются оператором <code class="literal">SELECT</code>, но и для тех, к которым обращаются другие операторы DML; <code class="literal">db_column:update</code> или <code class="literal">db_column:insert</code> также проверяется для столбцов, изменяемых операторами <code class="literal">UPDATE</code> или <code class="literal">INSERT</code>.</p><p>Например, рассмотрим запрос: </p><pre class="synopsis">
UPDATE t1 SET x = 2, y = func1(y) WHERE z = 100;
</pre><p> В данном случае <code class="literal">db_column:update</code> будет проверяться для столбца <code class="literal">t1.x</code>, так как он изменяется, <code class="literal">db_column:{select update}</code> будет проверяться для <code class="literal">t1.y</code>, так как он и считывается, и изменяется, а <code class="literal">db_column:select</code> — для столбца <code class="literal">t1.z</code>, так как он только считывается. На уровне таблицы также будет проверяться разрешение <code class="literal">db_table:{select update}</code>.</p><p>Для последовательностей проверяется разрешение <code class="literal">db_sequence:get_value</code>, когда имеет место обращение к объекту последовательности в <code class="literal">SELECT</code>; заметьте, однако, что в настоящее время разрешения на выполнение связанных функций, таких как, <code class="literal">lastval()</code>, не проверяются.</p><p>Для представлений проверяется <code class="literal">db_view:expand</code>, а затем все другие соответствующие разрешения для объектов, развёрнутых из определения представления, в индивидуальном порядке.</p><p>Для функций проверяется <code class="literal">db_procedure:{execute}</code>, когда пользователь пытается выполнить функцию в составе запроса, либо при вызове по быстрому пути. Если эта функция является доверенной процедурой, также проверяется разрешение <code class="literal">db_procedure:{entrypoint}</code>, чтобы удостовериться, что эта функция может быть точкой входа в доверенную процедуру.</p><p>При обращении к любому объекту схемы необходимо иметь разрешение <code class="literal">db_schema:search</code> для содержащей его схемы. Когда имя целевого объекта не дополняется схемой, схемы, для которых данное разрешение отсутствует, не будут просматриваться (то же происходит, если у пользователя нет права <code class="literal">USAGE</code> для этой схемы). Когда схема указывается явно, пользователь получит ошибку, если он не имеет требуемого разрешения для доступа к указанной схеме.</p><p>Клиенту должен быть разрешён доступ ко всем задействованным в запросе таблицам и столбцам, даже если они проявились в нём в результате разворачивания представлений, так что правила применяются согласованно вне зависимости от варианта обращения к содержимому таблиц.</p><p>Стандартная система привилегий позволяет суперпользователям баз данных изменять системные каталоги с помощью команд DML и обращаться к таблицам TOAST или модифицировать их. Когда модуль <code class="filename">sepgsql</code> активен, эти операции запрещаются.</p></div><div class="sect3" id="SEPGSQL-FEATURES-DDL-PERMISSIONS"><div class="titlepage"><div><div><h4 class="title">F.40.5.3. Разрешения для DDL <a href="#SEPGSQL-FEATURES-DDL-PERMISSIONS" class="id_link">#</a></h4></div></div></div><p><span class="productname">SELinux</span> определяет набор разрешений для управления стандартными операциями для каждого типа объекта: создание, изменение определения, удаление и смена метки безопасности. В дополнение к ним для некоторых типов объектов предусмотрены специальные разрешения для управления их специфическими операциями, как например, добавление или удаление объектов в определённой схеме.</p><p>Для создания нового объекта базы данных требуется разрешение <code class="literal">create</code>. <span class="productname">SELinux</span> разрешает или запрещает выполнение этой операции в зависимости от метки безопасности клиента и предполагаемой метки безопасности нового объекта. В некоторых случаях требуются дополнительные разрешения:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="sql-createdatabase.html" title="CREATE DATABASE"><code class="command">CREATE DATABASE</code></a> дополнительно требует разрешения <code class="literal">getattr</code> в исходной или шаблонной базе данных.</p></li><li class="listitem"><p>Создание объекта схемы дополнительно требует разрешения <code class="literal">add_name</code> в родительской схеме.</p></li><li class="listitem"><p>Создание таблицы дополнительно требует разрешения на создание каждой отдельного столбца таблицы, как если бы каждый столбец таблицы был отдельным объектом верхнего уровня.</p></li><li class="listitem"><p>Создание функции с атрибутом <code class="literal">LEAKPROOF</code> дополнительно требует разрешения <code class="literal">install</code>. (Это разрешение также проверяется, когда атрибут <code class="literal">LEAKPROOF</code> устанавливается для существующей функции.)</p></li></ul></div><p>Когда выполняется команда <code class="literal">DROP</code>, для удаляемого объекта будет проверяться разрешение <code class="literal">drop</code>. Разрешения будут также проверяться и для объектов, удаляемых косвенно, вследствие указания <code class="literal">CASCADE</code>. Для удаления объектов, содержащихся в определённой схеме, (таблиц, представления, последовательностей и процедур) дополнительно нужно иметь разрешение <code class="literal">remove_name</code> в этой схеме.</p><p>Когда выполняется команда <code class="literal">ALTER</code>, для каждого модифицируемого объекта проверяется разрешение <code class="literal">setattr</code>, кроме подчинённых объектов, таких как индексы или триггеры таблиц (на них распространяются разрешения родительского объекта). В некоторых случаях требуются дополнительные разрешения:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>При перемещении объекта в новую схему дополнительно требуется разрешение <code class="literal">remove_name</code> в старой схеме и <code class="literal">add_name</code> в новой.</p></li><li class="listitem"><p>Для установки атрибута <code class="literal">LEAKPROOF</code> для функции требуется разрешение <code class="literal">install</code>.</p></li><li class="listitem"><p>Для использования <a class="link" href="sql-security-label.html" title="SECURITY LABEL"><code class="command">SECURITY LABEL</code></a> дополнительно требуется разрешение <code class="literal">relabelfrom</code> для объекта с его старой меткой безопасности и <code class="literal">relabelto</code> для этого объекта с новой меткой безопасности. (В случаях, когда установлено несколько поставщиков меток и пользователь пытается задать метку, неподконтрольную <span class="productname">SELinux</span>, должно проверяться только разрешение <code class="literal">setattr</code>. В настоящее время этого не происходит из-за ограничений реализации.)</p></li></ul></div></div><div class="sect3" id="SEPGSQL-FEATURES-TRUSTED-PROCEDURES"><div class="titlepage"><div><div><h4 class="title">F.40.5.4. Доверенные процедуры <a href="#SEPGSQL-FEATURES-TRUSTED-PROCEDURES" class="id_link">#</a></h4></div></div></div><p>Доверенные процедуры похожи на функции, определяющие контекст безопасности, или команды setuid. В <span class="productname">SELinux</span> реализована возможность запускать доверенный код с меткой безопасности, отличной от метки клиента, как правило, для предоставления чётко контролируемого доступа к важным данным (при этом например, могут отсеиваться строки или хранимые значения могут выводиться с меньшей точностью). Будет ли функция вызываться как доверенная процедура, определяется её меткой безопасности и политикой операционной системы. Например:</p><pre class="screen">postgres=# CREATE TABLE customer (
               cid     int primary key,
               cname   text,
               credit  text
           );
CREATE TABLE
postgres=# SECURITY LABEL ON COLUMN customer.credit
               IS 'system_u:object_r:sepgsql_secret_table_t:s0';
SECURITY LABEL
postgres=# CREATE FUNCTION show_credit(int) RETURNS text
             AS 'SELECT regexp_replace(credit, ''-[0-9]+$'', ''-xxxx'', ''g'')
                        FROM customer WHERE cid = $1'
           LANGUAGE sql;
CREATE FUNCTION
postgres=# SECURITY LABEL ON FUNCTION show_credit(int)
               IS 'system_u:object_r:sepgsql_trusted_proc_exec_t:s0';
SECURITY LABEL</pre><p>Показанные выше операции должен выполнять пользователь с правами администратора.</p><pre class="screen">postgres=# SELECT * FROM customer;
ERROR:  SELinux: security policy violation
postgres=# SELECT cid, cname, show_credit(cid) FROM customer;
 cid | cname  |     show_credit
-----+--------+---------------------
   1 | taro   | 1111-2222-3333-xxxx
   2 | hanako | 5555-6666-7777-xxxx
(2 rows)</pre><p>В данном случае обычный пользователь не может обращаться к <code class="literal">customer.credit</code> напрямую, но доверенная процедура <code class="literal">show_credit</code> позволяет ему получить номера кредитных карт клиентов, в которых будут скрыты некоторые цифры.</p></div><div class="sect3" id="SEPGSQL-FEATURES-DYNAMIC-DOMAIN-TRANSITIONS"><div class="titlepage"><div><div><h4 class="title">F.40.5.5. Динамические переключения домена <a href="#SEPGSQL-FEATURES-DYNAMIC-DOMAIN-TRANSITIONS" class="id_link">#</a></h4></div></div></div><p>Возможность динамического перехода из домена в домен SELinux позволяет переводить метку безопасности клиентского процесса, клиентский домен в новый контекст, если это допускается политикой безопасности. Для этого клиент должен иметь разрешение <code class="literal">setcurrent</code>, а также разрешение <code class="literal">dyntransition</code> для перехода из старого в новый домен.</p><p>Динамические переключения домена следует тщательно продумывать, так как таким образом пользователи могут менять свои метки, а значит и привилегии, по собственному желанию, а не (как в случае с доверенными процедурами) по правилам, диктуемым системой. Таким образом, разрешение <code class="literal">dyntransition</code> считается безопасным, только когда применяется для переключения в домен с более ограниченным набором привилегий, чем текущий. Например:</p><pre class="screen">regression=# select sepgsql_getcon();
                    sepgsql_getcon
-------------------------------------------------------
 unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
(1 row)

regression=# SELECT sepgsql_setcon('unconfined_u:unconfined_r:unconfined_t:s0-s0:c1.c4');
 sepgsql_setcon
----------------
 t
(1 row)

regression=# SELECT sepgsql_setcon('unconfined_u:unconfined_r:unconfined_t:s0-s0:c1.c1023');
ERROR:  SELinux: security policy violation</pre><p>В показанном выше примере мы смогли переключиться из более широкого диапазона MCS <code class="literal">c1.c1023</code> в более узкий <code class="literal">c1.c4</code>, но переключение в обратную сторону было запрещено.</p><p>Сочетание динамического переключения домена с доверенными процедурами позволяет получить интересное решение, подходящее для реализации жизненного цикла процессов с пулом соединений. Даже если вашему менеджеру пула соединений не разрешается запускать многие команды SQL, вы можете разрешить ему сменить метку безопасности клиента, вызвав функцию <code class="literal">sepgsql_setcon()</code> из доверенной процедуры; для этого может передаваться удостоверение для авторизации запроса на смену метки клиента. После этого сеанс получит привилегии целевого пользователя, а не пользователя пула соединений. Позднее менеджер пула может отменить смену контекста безопасности, вызвав <code class="literal">sepgsql_setcon()</code> с аргументом <code class="literal">NULL</code>, так же из доверенной процедуры с необходимыми проверками разрешений. Идея этого подхода в том, что только этой доверенной процедуре будет разрешено менять действующую метку безопасности и только в том случае, когда ей передаётся правильное удостоверение. Разумеется, чтобы это решение было безопасным, хранилище удостоверений (таблица, определение процедуры или что-то другое) не должно быть общедоступным.</p></div><div class="sect3" id="SEPGSQL-FEATURES-MISC"><div class="titlepage"><div><div><h4 class="title">F.40.5.6. Разное <a href="#SEPGSQL-FEATURES-MISC" class="id_link">#</a></h4></div></div></div><p>Выполнение команды <a class="link" href="sql-load.html" title="LOAD"><code class="command">LOAD</code></a> в активном режиме запрещается, так как любой загруженный модуль может легко обойти ограничения политики безопасности.</p></div></div><div class="sect2" id="SEPGSQL-FUNCTIONS"><div class="titlepage"><div><div><h3 class="title">F.40.6. Функции sepgsql <a href="#SEPGSQL-FUNCTIONS" class="id_link">#</a></h3></div></div></div><p>В <a class="xref" href="sepgsql.html#SEPGSQL-FUNCTIONS-TABLE" title="Таблица F.31. Функции sepgsql">Таблице F.31</a> перечислены все доступные функции.</p><div class="table" id="SEPGSQL-FUNCTIONS-TABLE"><p class="title"><strong>Таблица F.31. Функции sepgsql</strong></p><div class="table-contents"><table class="table" summary="Функции sepgsql" border="1"><colgroup><col /></colgroup><thead><tr><th class="func_table_entry"><p class="func_signature">Функция</p>
       <p>Описание</p></th></tr></thead><tbody><tr><td class="func_table_entry"><p class="func_signature"><code class="function">sepgsql_getcon</code> () → <code class="returnvalue">text</code></p>
       <p>Возвращает клиентский домен, текущую метку безопасности клиента.</p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">sepgsql_setcon</code> ( <code class="type">text</code> ) → <code class="returnvalue">boolean</code></p>
       <p>Переключает домен клиента текущего сеанса в новый домен, если это допускает политика безопасности. Эта функция также принимает в аргументе <code class="literal">NULL</code> как запрос на переход в начальный домен клиента.</p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">sepgsql_mcstrans_in</code> ( <code class="type">text</code> ) → <code class="returnvalue">text</code></p>
       <p>Переводит заданный диапазон MLS/MCS из полной записи в низкоуровневый формат, если работает демон mcstrans.</p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">sepgsql_mcstrans_out</code> ( <code class="type">text</code> ) → <code class="returnvalue">text</code></p>
       <p>Переводит заданный диапазон MLS/MCS из низкоуровневого формата в полную запись, если работает демон mcstrans.</p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">sepgsql_restorecon</code> ( <code class="type">text</code> ) → <code class="returnvalue">boolean</code></p>
       <p>Устанавливает начальные метки безопасности для всех объектов в текущей базе данных. В аргументе может передаваться <code class="literal">NULL</code> или имя файла со спецификациями контекстов, который будет применяться вместо стандартного системного.</p></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect2" id="SEPGSQL-LIMITATIONS"><div class="titlepage"><div><div><h3 class="title">F.40.7. Ограничения <a href="#SEPGSQL-LIMITATIONS" class="id_link">#</a></h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">Разрешения для языка определения данных (DDL, Data Definition Language)</span></dt><dd><p>Вследствие ограничений реализации, для некоторых операций DDL разрешения не проверяются.</p></dd><dt><span class="term">Разрешения для языка управления данными (DCL, Data Control Language)</span></dt><dd><p>Вследствие ограничений реализации, для операций DCL разрешения не проверяются.</p></dd><dt><span class="term">Управление доступом на уровне строк</span></dt><dd><p><span class="productname">PostgreSQL</span> поддерживает ограничение доступа на уровне строк, а <code class="filename">sepgsql</code> — нет.</p></dd><dt><span class="term">Скрытые каналы</span></dt><dd><p>Модуль <code class="filename">sepgsql</code> не пытается скрыть существование определённого объекта, даже если пользователю не разрешено обращаться к нему. Например, возможно догадаться о существовании невидимого объекта по конфликтам первичного ключа, нарушениям внешних ключей и т. д., даже когда нельзя получить содержимое этого объекта. Существование совершенно секретной таблицы невозможно скрыть; надеяться можно только на то, что будет защищено её содержимое.</p></dd></dl></div></div><div class="sect2" id="SEPGSQL-RESOURCES"><div class="titlepage"><div><div><h3 class="title">F.40.8. Внешние ресурсы <a href="#SEPGSQL-RESOURCES" class="id_link">#</a></h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term"><a class="ulink" href="https://wiki.postgresql.org/wiki/SEPostgreSQL" target="_top">SE-PostgreSQL Introduction</a>, Введение в SE-PostgreSQL</span></dt><dd><p>На этой вики-странице даётся краткий обзор этого решения и рассказывается об архитектуре и конструкции безопасности, администрировании и ожидаемых в будущем возможностях.</p></dd><dt><span class="term"><a class="ulink" href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/selinux_users_and_administrators_guide/index" target="_top">SELinux User's and Administrator's Guide</a>, Руководство пользователя и администратора SELinux</span></dt><dd><p>В этом документе представлен широкий спектр знаний по администрированию <span class="productname">SELinux</span> в ОС. В первую очередь он ориентирован на системы Red Hat, но его область применения не ограничена ими.</p></dd><dt><span class="term"><a class="ulink" href="https://fedoraproject.org/wiki/SELinux_FAQ" target="_top">Fedora SELinux FAQ</a>, Часто задаваемые вопросы по SELinux в ОС Fedora</span></dt><dd><p>В этом документе даются ответы на часто задаваемые вопросы по <span class="productname">SELinux</span>. В первую очередь он ориентирован на ОС Fedora, но его область применения не ограничена ей.</p></dd></dl></div></div><div class="sect2" id="SEPGSQL-AUTHOR"><div class="titlepage"><div><div><h3 class="title">F.40.9. Автор <a href="#SEPGSQL-AUTHOR" class="id_link">#</a></h3></div></div></div><p>КайГай Кохэй <code class="email">&lt;<a class="email" href="mailto:kaigai@ak.jp.nec.com">kaigai@ak.jp.nec.com</a>&gt;</code></p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="seg.html" title="F.39. seg — тип данных для отрезков или интервалов чисел с плавающей точкой">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="contrib.html" title="Приложение F. Дополнительно поставляемые модули и расширения">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="contrib-spi.html" title="F.41. spi — особенности/примеры использования интерфейса программирования сервера">След.</a></td></tr><tr><td width="40%" align="left" valign="top">F.39. seg — тип данных для отрезков или интервалов чисел с плавающей точкой </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> F.41. spi — особенности/примеры использования интерфейса программирования сервера</td></tr></table></div></body></html>