<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>76.1. Примеры оценки количества строк</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="planner-stats-details.html" title="Глава 76. Как планировщик использует статистику" /><link rel="next" href="multivariate-statistics-examples.html" title="76.2. Примеры многовариантной статистики" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">76.1. Примеры оценки количества строк</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="planner-stats-details.html" title="Глава 76. Как планировщик использует статистику">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="planner-stats-details.html" title="Глава 76. Как планировщик использует статистику">Наверх</a></td><th width="60%" align="center">Глава 76. Как планировщик использует статистику</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="multivariate-statistics-examples.html" title="76.2. Примеры многовариантной статистики">След.</a></td></tr></table><hr /></div><div class="sect1" id="ROW-ESTIMATION-EXAMPLES"><div class="titlepage"><div><div><h2 class="title" style="clear: both">76.1. Примеры оценки количества строк <a href="#ROW-ESTIMATION-EXAMPLES" class="id_link">#</a></h2></div></div></div><a id="id-1.10.27.4.2" class="indexterm"></a><p>В приведённых ниже примерах используются таблицы базы данных регрессионного тестирования <span class="productname">PostgreSQL</span>. Приведённые листинги получены в версии 8.3. Поведение более ранних (или поздних) версий может отличаться. Заметьте также, что поскольку команда <code class="command">ANALYZE</code> использует случайную выборку при формировании статистики, после любого нового выполнения команды <code class="command">ANALYZE</code> результаты незначительно изменятся.</p><p>Давайте начнём с очень простого запроса: </p><pre class="programlisting">EXPLAIN SELECT * FROM tenk1;

                         QUERY PLAN
-------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..458.00 rows=10000 width=244)</pre><p> Как планировщик определяет мощность <code class="structname">tenk1</code>, рассматривается выше (см. <a class="xref" href="planner-stats.html" title="14.2. Статистика, используемая планировщиком">Раздел 14.2</a>), но для полноты здесь говорится об этом ещё раз. Количество страниц и строк берётся в <code class="structname">pg_class</code>: </p><pre class="programlisting">SELECT relpages, reltuples FROM pg_class WHERE relname = 'tenk1';

 relpages | reltuples
----------+-----------
      358 |     10000</pre><p>Это текущие цифры, полученные при последнем выполнении команд <code class="command">VACUUM</code> или <code class="command">ANALYZE</code>, применённых к этой таблице. Затем планировщик выполняет выборку фактического текущего числа страниц в таблице (это недорогая операция, для которой не требуется сканирование таблицы). Если оно отличается от <code class="structfield">relpages</code>, то <code class="structfield">reltuples</code> изменяется для того, чтобы привести это значение к текущей оценке количества строк. В показанном выше примере значение <code class="structfield">relpages</code> является актуальным, поэтому количество строк берётся равным <code class="structfield">reltuples</code>.</p><p>Давайте обратимся к примеру с диапазонным условием в предложении <code class="literal">WHERE</code>: </p><pre class="programlisting">EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 1000;

                                   QUERY PLAN
-------------------------------------------------------------------​-------------
 Bitmap Heap Scan on tenk1  (cost=24.06..394.64 rows=1007 width=244)
   Recheck Cond: (unique1 &lt; 1000)
   -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..23.80 rows=1007 width=0)
         Index Cond: (unique1 &lt; 1000)</pre><p> Планировщик рассматривает условие предложения <code class="literal">WHERE</code> и находит в справочнике функцию избирательности для оператора <code class="literal">&lt;</code> в <code class="structname">pg_operator</code>. Это значение содержится в столбце <code class="structfield">oprrest</code>, и в данном случае значением является <code class="function">scalarltsel</code>. Функция <code class="function">scalarltsel</code> извлекает гистограмму для <code class="structfield">unique1</code> из <code class="structname">pg_statistic</code>. Для вводимых вручную запросов удобнее просматривать более простое представление <code class="structname">pg_stats</code>: </p><pre class="programlisting">SELECT histogram_bounds FROM pg_stats
WHERE tablename='tenk1' AND attname='unique1';

                   histogram_bounds
------------------------------------------------------
 {0,993,1997,3050,4040,5036,5957,7057,8029,9016,9995}</pre><p> Затем обрабатывается часть гистограммы, которая соответствует условию <span class="quote">«<span class="quote">&lt; 1000</span>»</span>. Таким образом и определяется избирательность. Гистограмма делит диапазон на равные частотные группы, поэтому нужно лишь определить группу, содержащую наше значение, и подсчитать её <span class="emphasis"><em>долю</em></span> и <span class="emphasis"><em>долю групп</em></span>, предшествующих данной. Очевидно, что значение 1000 находится во второй группе (993–1997). Если предположить, что внутри каждой группы распределение значений линейное, мы можем вычислить избирательность следующим образом: </p><pre class="programlisting">selectivity = (1 + (1000 - bucket[2].min)/(bucket[2].max - bucket[2].min))/num_buckets
            = (1 + (1000 - 993)/(1997 - 993))/10
            = 0.100697</pre><p> т. е. сумма элементов одной целой группы и пропорциональной части элементов второй, делённая на число групп. Теперь примерное число строк может быть рассчитано как произведение избирательности и мощности <code class="structname">tenk1</code>: </p><pre class="programlisting">rows = rel_cardinality * selectivity
     = 10000 * 0.100697
     = 1007  (округлённо)</pre><p>Далее, давайте рассмотрим пример с условием на равенство в предложении <code class="literal">WHERE</code>: </p><pre class="programlisting">EXPLAIN SELECT * FROM tenk1 WHERE stringu1 = 'CRAAAA';

                        QUERY PLAN
----------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..483.00 rows=30 width=244)
   Filter: (stringu1 = 'CRAAAA'::name)</pre><p> Планировщик вновь проверяет условие в предложении <code class="literal">WHERE</code> и определяет функцию избирательности для <code class="literal">=</code>, и этой функцией является <code class="function">eqsel</code>. Для оценки равенства гистограмма бесполезна, вместо неё для оценки избирательности используется список <em class="firstterm">самых частых значений</em> (Most Common Values, <acronym class="acronym">MCV</acronym>). Давайте рассмотрим MCV и соответствующие дополнительные столбцы, которые пригодятся позже: </p><pre class="programlisting">SELECT null_frac, n_distinct, most_common_vals, most_common_freqs FROM pg_stats
WHERE tablename='tenk1' AND attname='stringu1';

null_frac         | 0
n_distinct        | 676
most_common_vals  | {EJAAAA,BBAAAA,CRAAAA,FCAAAA,FEAAAA,GSAAAA,​JOAAAA,MCAAAA,NAAAAA,WGAAAA}
most_common_freqs | {0.00333333,0.003,0.003,0.003,0.003,0.003,​0.003,0.003,0.003,0.003}</pre><p> Так как значение <code class="literal">CRAAAA</code> оказалось в списке MCV, избирательность будет определяться просто соответствующим элементом в списке частот самых частых значений (Most Common Frequencies, MCF): </p><pre class="programlisting">selectivity = mcf[3]
            = 0.003</pre><p> Как и в предыдущем примере, оценка числа строк берётся как произведение мощности и избирательности <code class="structname">tenk1</code>: </p><pre class="programlisting">rows = 10000 * 0.003
     = 30</pre><p>Теперь рассмотрим тот же самый запрос, но с константой, которой нет в списке <acronym class="acronym">MCV</acronym>: </p><pre class="programlisting">EXPLAIN SELECT * FROM tenk1 WHERE stringu1 = 'xxx';

                        QUERY PLAN
----------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..483.00 rows=15 width=244)
   Filter: (stringu1 = 'xxx'::name)</pre><p> Это совершенно другая задача — как оценить избирательность значения, которого <span class="emphasis"><em>нет</em></span> в списке <acronym class="acronym">MCV</acronym>. При её решении используется факт отсутствия данного значения в списке в сочетании с частотой для каждого значения из списка <acronym class="acronym">MCV</acronym>. </p><pre class="programlisting">selectivity = (1 - sum(mcv_freqs))/(num_distinct - num_mcv)
            = (1 - (0.00333333 + 0.003 + 0.003 + 0.003 + 0.003 + 0.003 +
                    0.003 + 0.003 + 0.003 + 0.003))/(676 - 10)
            = 0.0014559</pre><p> Т. е. нужно сложить частоты значений из списка <acronym class="acronym">MCV</acronym>, отнять полученное число от единицы, и полученное значение разделить на количество <span class="emphasis"><em>остальных</em></span> уникальных значений. Эти вычисления основаны на предположении, что значения, которые не входят в список MCV, имеют равномерное распределение. Заметьте, что в данном примере нет неопределённых значений, поэтому о них беспокоиться не нужно (иначе их долю также пришлось бы вычитать из числителя). Оценка числа строк затем производится как обычно: </p><pre class="programlisting">rows = 10000 * 0.0014559
     = 15  (округлённо)</pre><p>Предыдущий пример с <code class="literal">unique1 &lt; 1000</code> был большим упрощением того, что в действительности делает <code class="function">scalarltsel</code>. Но после того, как мы увидели пример использования списка MCV, мы можем внести некоторые дополнения. Что касается самого примера, в нём все было правильно, поскольку <code class="structfield">unique1</code> — это уникальный столбец, у него нет значений в списке MCV (очевидно, в данном случае нет значения, которое встречается чаще, чем какое-либо другое). Для неуникального столбца обычно создаётся как гистограмма, так и список MCV, при этом <span class="emphasis"><em>гистограмма не включает значения, представленные в списке MCV</em></span>. Данный способ позволяет выполнить более точный подсчёт. В этой ситуации <code class="function">scalarltsel</code> напрямую применяет условие <span class="quote">«<span class="quote">&lt; 1000</span>»</span> к каждому значению списка MCV и суммирует частоты значений MCV, для которых условие является верным. Это даёт точную оценку избирательности для той части таблицы, которая содержит значения из списка MCV. Подобным же образом используется гистограмма для оценки избирательности для той части таблицы, которая не содержит значения из списка MCV, а затем эти две цифры складываются для оценки общей избирательности. Например, рассмотрим </p><pre class="programlisting">EXPLAIN SELECT * FROM tenk1 WHERE stringu1 &lt; 'IAAAAA';

                         QUERY PLAN
------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..483.00 rows=3077 width=244)
   Filter: (stringu1 &lt; 'IAAAAA'::name)</pre><p> Мы уже видели данные списка MCV для <code class="structfield">stringu1</code>, а это его гистограмма: </p><pre class="programlisting">SELECT histogram_bounds FROM pg_stats
WHERE tablename='tenk1' AND attname='stringu1';

                                histogram_bounds
-------------------------------------------------------------------​-------------
 {AAAAAA,CQAAAA,FRAAAA,IBAAAA,KRAAAA,NFAAAA,PSAAAA,SGAAAA,VAAAAA,​XLAAAA,ZZAAAA}</pre><p> Проверяя список MCV, находим, что условие <code class="literal">stringu1 &lt; 'IAAAAA'</code> соответствует первым шести записям, но не соответствует последним четырём, поэтому избирательность для значений, соответствующих значениям в списке MCV, такова: </p><pre class="programlisting">selectivity = sum(relevant mvfs)
            = 0.00333333 + 0.003 + 0.003 + 0.003 + 0.003 + 0.003
            = 0.01833333</pre><p> Сумма всех частот из списка MCF также сообщает нам, что общая часть представленной списком MCV совокупности записей равняется 0.03033333, и поэтому представленная гистограммой часть равняется 0.96966667 (в этом случае тоже нет неопределённых значений, иначе их пришлось бы также исключить). Видно, что значение <code class="literal">IAAAAA</code> попадает почти в конец третьего столбца гистограммы. Основываясь на простых предположениях относительно частоты различных символов, планировщик получает число 0.298387 для части значений, представленных в гистограмме, которые меньше чем <code class="literal">IAAAAA</code>. Затем объединяем оценки части значений из списка MCV и значений, не содержащихся в нём: </p><pre class="programlisting">selectivity = mcv_selectivity + histogram_selectivity * histogram_fraction
            = 0.01833333 + 0.298387 * 0.96966667
            = 0.307669

rows        = 10000 * 0.307669
            = 3077  (округлённо)</pre><p> В этом конкретном примере, корректировка со стороны списка MCV достаточно мала, потому что распределение значений столбца довольно плоское (статистика, показывающая конкретные значения как более распространённые, чаще всего получается вследствие статистической погрешности). В более типичном случае, когда некоторые значения являются значительно более распространёнными по сравнению с другими, этот более сложный метод повышает точность вследствие точного определения избирательности наиболее распространённых значений.</p><p>Теперь давайте рассмотрим случай с более чем одним условием в предложении <code class="literal">WHERE</code>: </p><pre class="programlisting">EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 1000 AND stringu1 = 'xxx';

                                   QUERY PLAN
-------------------------------------------------------------------​-------------
 Bitmap Heap Scan on tenk1  (cost=23.80..396.91 rows=1 width=244)
   Recheck Cond: (unique1 &lt; 1000)
   Filter: (stringu1 = 'xxx'::name)
   -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..23.80 rows=1007 width=0)
         Index Cond: (unique1 &lt; 1000)</pre><p> Планировщик исходит из того, что два условия независимы, таким образом, отдельные значения избирательности можно перемножить: </p><pre class="programlisting">selectivity = selectivity(unique1 &lt; 1000) * selectivity(stringu1 = 'xxx')
            = 0.100697 * 0.0014559
            = 0.0001466

rows        = 10000 * 0.0001466
            = 1  (округлённо)</pre><p> Заметьте, что число строк, которые предполагается вернуть через сканирование битового индекса, соответствует условию, используемому при работе индекса; это важно, так как влияет на оценку стоимости для последующих выборок из таблицы.</p><p>В заключение исследуем запрос, выполняющий соединение: </p><pre class="programlisting">EXPLAIN SELECT * FROM tenk1 t1, tenk2 t2
WHERE t1.unique1 &lt; 50 AND t1.unique2 = t2.unique2;

                                      QUERY PLAN
-------------------------------------------------------------------​-------------------
 Nested Loop  (cost=4.64..456.23 rows=50 width=488)
   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.64..142.17 rows=50 width=244)
         Recheck Cond: (unique1 &lt; 50)
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.63 rows=50 width=0)
               Index Cond: (unique1 &lt; 50)
   -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.00..6.27 rows=1 width=244)
         Index Cond: (unique2 = t1.unique2)</pre><p> Ограничение, накладываемое на <code class="structname">tenk1</code>, <code class="literal">unique1 &lt; 50</code>, производится до соединения вложенным циклом. Это обрабатывается аналогично предыдущему примеру с диапазонным условием. На этот раз значение 50 попадает в первый столбец гистограммы <code class="structfield">unique1</code>: </p><pre class="programlisting">selectivity = (0 + (50 - bucket[1].min)/(bucket[1].max - bucket[1].min))/num_buckets
            = (0 + (50 - 0)/(993 - 0))/10
            = 0.005035

rows        = 10000 * 0.005035
            = 50  (округлённо)</pre><p> Ограничение для соединения следующее <code class="literal">t2.unique2 = t1.unique2</code>. Здесь используется уже известный нам оператор <code class="literal">=</code>, однако функцию избирательности получаем из столбца <code class="structfield">oprjoin</code> представления <code class="structname">pg_operator</code>, и эта функция — <code class="function">eqjoinsel</code>. Функция <code class="function">eqjoinsel</code> находит статистические данные как для <code class="structname">tenk2</code>, так и для <code class="structname">tenk1</code>: </p><pre class="programlisting">SELECT tablename, null_frac,n_distinct, most_common_vals FROM pg_stats
WHERE tablename IN ('tenk1', 'tenk2') AND attname='unique2';

tablename  | null_frac | n_distinct | most_common_vals
-----------+-----------+------------+------------------
 tenk1     |         0 |         -1 |
 tenk2     |         0 |         -1 |</pre><p> В этом случае нет данных <acronym class="acronym">MCV</acronym> для <code class="structfield">unique2</code>, потому что все значения будут уникальными. Таким образом, используется алгоритм, зависящий только от числа различающихся значений для обеих таблиц и от данных с неопределёнными значениями: </p><pre class="programlisting">selectivity = (1 - null_frac1) * (1 - null_frac2) * min(1/num_distinct1, 1/num_distinct2)
            = (1 - 0) * (1 - 0) / max(10000, 10000)
            = 0.0001</pre><p> Т. е., вычитаем долю неопределённых значений из единицы для каждой таблицы и делим на максимальное из чисел различающихся значений. Количество строк, которое соединение, вероятно, сгенерирует, вычисляется как мощность декартова произведения двух входных значений, умноженная на избирательность: </p><pre class="programlisting">rows = (outer_cardinality * inner_cardinality) * selectivity
     = (50 * 10000) * 0.0001
     = 50</pre><p>Если бы имелись списки MCV для двух столбцов, функцией <code class="function">eqjoinsel</code> использовалось бы прямое сравнение со списками MCV для определения общей избирательности той части данных, которая содержит значения списка MCV. Оценка остальной части данных при этом выполнялась бы представленным выше способом.</p><p>Заметьте, что здесь выводится для <code class="literal">inner_cardinality</code> значение 10000, то есть исходный размер <code class="structname">tenk2</code>. Если изучить вывод <code class="command">EXPLAIN</code>, может показаться, что оценка количества строк вычисляется как 50 * 1, то есть число внешних строк умножается на ориентировочное число строк, получаемых при каждом внутреннем сканировании индекса в <code class="structname">tenk2</code>. Но это не так, ведь размер результата соединения оценивается до того, как выбирается конкретный план соединения. Если всё работает корректно, оба варианта вычисления этого размера должны давать один и тот же ответ, но из-за ошибок округления и других факторов иногда они значительно различаются.</p><p>Для интересующихся более подробной информацией: оценка размера таблицы (до выполнения условий в предложении <code class="literal">WHERE</code>) реализована в файле <code class="filename">src/backend/optimizer/util/plancat.c</code>. Основная логика для вычисления избирательности предложений находится в <code class="filename">src/backend/optimizer/path/clausesel.c</code>. Специфичные для отдельных операторов функции избирательности, в основном, расположены в <code class="filename">src/backend/utils/adt/selfuncs.c</code>.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="planner-stats-details.html" title="Глава 76. Как планировщик использует статистику">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="planner-stats-details.html" title="Глава 76. Как планировщик использует статистику">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="multivariate-statistics-examples.html" title="76.2. Примеры многовариантной статистики">След.</a></td></tr><tr><td width="40%" align="left" valign="top">Глава 76. Как планировщик использует статистику </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 76.2. Примеры многовариантной статистики</td></tr></table></div></body></html>