<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>8.16. Составные типы</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="arrays.html" title="8.15. Массивы" /><link rel="next" href="rangetypes.html" title="8.17. Диапазонные типы" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">8.16. Составные типы</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="arrays.html" title="8.15. Массивы">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="datatype.html" title="Глава 8. Типы данных">Наверх</a></td><th width="60%" align="center">Глава 8. Типы данных</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="rangetypes.html" title="8.17. Диапазонные типы">След.</a></td></tr></table><hr /></div><div class="sect1" id="ROWTYPES"><div class="titlepage"><div><div><h2 class="title" style="clear: both">8.16. Составные типы <a href="#ROWTYPES" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="rowtypes.html#ROWTYPES-DECLARING">8.16.1. Объявление составных типов</a></span></dt><dt><span class="sect2"><a href="rowtypes.html#ROWTYPES-CONSTRUCTING">8.16.2. Конструирование составных значений</a></span></dt><dt><span class="sect2"><a href="rowtypes.html#ROWTYPES-ACCESSING">8.16.3. Обращение к составным типам</a></span></dt><dt><span class="sect2"><a href="rowtypes.html#ROWTYPES-MODIFYING">8.16.4. Изменение составных типов</a></span></dt><dt><span class="sect2"><a href="rowtypes.html#ROWTYPES-USAGE">8.16.5. Использование составных типов в запросах</a></span></dt><dt><span class="sect2"><a href="rowtypes.html#ROWTYPES-IO-SYNTAX">8.16.6. Синтаксис вводимых и выводимых значений составного типа</a></span></dt></dl></div><a id="id-1.5.7.24.2" class="indexterm"></a><a id="id-1.5.7.24.3" class="indexterm"></a><p><em class="firstterm">Составной тип</em> представляет структуру табличной строки или записи; по сути это просто список имён полей и соответствующих типов данных. <span class="productname">PostgreSQL</span> позволяет использовать составные типы во многом так же, как и простые типы. Например, в определении таблицы можно объявить столбец составного типа.</p><div class="sect2" id="ROWTYPES-DECLARING"><div class="titlepage"><div><div><h3 class="title">8.16.1. Объявление составных типов <a href="#ROWTYPES-DECLARING" class="id_link">#</a></h3></div></div></div><p>Ниже приведены два простых примера определения составных типов: </p><pre class="programlisting">CREATE TYPE complex AS (
    r       double precision,
    i       double precision
);

CREATE TYPE inventory_item AS (
    name            text,
    supplier_id     integer,
    price           numeric
);</pre><p> Синтаксис очень похож на <code class="command">CREATE TABLE</code>, за исключением того, что он допускает только названия полей и их типы, какие-либо ограничения (такие как <code class="literal">NOT NULL</code>) в настоящее время не поддерживаются. Заметьте, что ключевое слово <code class="literal">AS</code> здесь имеет значение; без него система будет считать, что подразумевается другой тип команды <code class="command">CREATE TYPE</code>, и выдаст неожиданную синтаксическую ошибку.</p><p>Определив такие типы, мы можем использовать их в таблицах: </p><pre class="programlisting">CREATE TABLE on_hand (
    item      inventory_item,
    count     integer
);

INSERT INTO on_hand VALUES (ROW('fuzzy dice', 42, 1.99), 1000);</pre><p> или функциях: </p><pre class="programlisting">CREATE FUNCTION price_extension(inventory_item, integer) RETURNS numeric
AS 'SELECT $1.price * $2' LANGUAGE SQL;

SELECT price_extension(item, 10) FROM on_hand;</pre><p>Всякий раз, когда создаётся таблица, вместе с ней автоматически создаётся составной тип. Этот тип представляет тип строки таблицы, и его именем становится имя таблицы. Например, при выполнении команды: </p><pre class="programlisting">CREATE TABLE inventory_item (
    name            text,
    supplier_id     integer REFERENCES suppliers,
    price           numeric CHECK (price &gt; 0)
);</pre><p> в качестве побочного эффекта будет создан составной тип <code class="literal">inventory_item</code>, в точности соответствующий тому, что был показан выше, и использовать его можно так же. Однако заметьте, что в текущей реализации есть один недостаток: так как с составным типом не могут быть связаны ограничения, то описанные в определении таблицы ограничения <span class="emphasis"><em>не применяются</em></span> к значениям составного типа вне таблицы. (Чтобы обойти этот недостаток, создайте <a class="glossterm" href="glossary.html#GLOSSARY-DOMAIN"><em class="glossterm"><a class="glossterm" href="glossary.html#GLOSSARY-DOMAIN" title="Домен">домен</a></em></a> поверх составного типа и добавьте желаемые ограничения в виде ограничений <code class="literal">CHECK</code> для данного домена.)</p></div><div class="sect2" id="ROWTYPES-CONSTRUCTING"><div class="titlepage"><div><div><h3 class="title">8.16.2. Конструирование составных значений <a href="#ROWTYPES-CONSTRUCTING" class="id_link">#</a></h3></div></div></div><a id="id-1.5.7.24.6.2" class="indexterm"></a><p>Чтобы записать значение составного типа в виде текстовой константы, его поля нужно заключить в круглые скобки и разделить их запятыми. Значение любого поля можно заключить в кавычки, а если оно содержит запятые или скобки, это делать обязательно. (Подробнее об этом говорится <a class="link" href="rowtypes.html#ROWTYPES-IO-SYNTAX" title="8.16.6. Синтаксис вводимых и выводимых значений составного типа">ниже</a>.) Таким образом, в общем виде константа составного типа записывается так: </p><pre class="synopsis">
'( <em class="replaceable"><code>значение1</code></em> , <em class="replaceable"><code>значение2</code></em> , ... )'
</pre><p> Например, эта запись: </p><pre class="programlisting">'("fuzzy dice",42,1.99)'</pre><p> будет допустимой для описанного выше типа <code class="literal">inventory_item</code>. Чтобы присвоить NULL одному из полей, в соответствующем месте в списке нужно оставить пустое место. Например, эта константа задаёт значение NULL для третьего поля: </p><pre class="programlisting">'("fuzzy dice",42,)'</pre><p> Если же вместо NULL требуется вставить пустую строку, нужно записать пару кавычек: </p><pre class="programlisting">'("",42,)'</pre><p> Здесь в первом поле окажется пустая строка, а в третьем — NULL.</p><p>(Такого рода константы массивов на самом деле представляют собой всего лишь частный случай констант, описанных в <a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-CONSTANTS-GENERIC" title="4.1.2.7. Константы других типов">Подразделе 4.1.2.7</a>. Константа изначально воспринимается как строка и передаётся процедуре преобразования составного типа. При этом может потребоваться явно указать тип, к которому будет приведена константа.)</p><p>Значения составных типов также можно конструировать, используя синтаксис выражения <code class="literal">ROW</code>. В большинстве случаев это значительно проще, чем записывать значения в строке, так как при этом не нужно беспокоиться о вложенности кавычек. Мы уже обсуждали этот метод ранее: </p><pre class="programlisting">ROW('fuzzy dice', 42, 1.99)
ROW('', 42, NULL)</pre><p> Ключевое слово ROW на самом деле может быть необязательным, если в выражении определяются несколько полей, так что эту запись можно упростить до: </p><pre class="programlisting">('fuzzy dice', 42, 1.99)
('', 42, NULL)</pre><p> Синтаксис выражения <code class="literal">ROW</code> более подробно рассматривается в <a class="xref" href="sql-expressions.html#SQL-SYNTAX-ROW-CONSTRUCTORS" title="4.2.13. Конструкторы табличных строк">Подразделе 4.2.13</a>.</p></div><div class="sect2" id="ROWTYPES-ACCESSING"><div class="titlepage"><div><div><h3 class="title">8.16.3. Обращение к составным типам <a href="#ROWTYPES-ACCESSING" class="id_link">#</a></h3></div></div></div><p>Чтобы обратиться к полю столбца составного типа, после имени столбца нужно добавить точку и имя поля, подобно тому, как указывается столбец после имени таблицы. На самом деле, эти обращения неотличимы, так что часто бывает необходимо использовать скобки, чтобы команда была разобрана правильно. Например, можно попытаться выбрать поле столбца из тестовой таблицы <code class="literal">on_hand</code> таким образом: </p><pre class="programlisting">SELECT item.name FROM on_hand WHERE item.price &gt; 9.99;</pre><p> Но это не будет работать, так как согласно правилам SQL имя <code class="literal">item</code> здесь воспринимается как имя таблицы, а не столбца в таблице <code class="literal">on_hand</code>. Поэтому этот запрос нужно переписать так: </p><pre class="programlisting">SELECT (item).name FROM on_hand WHERE (item).price &gt; 9.99;</pre><p> либо указать также и имя таблицы (например, в запросе с многими таблицами), примерно так: </p><pre class="programlisting">SELECT (on_hand.item).name FROM on_hand WHERE (on_hand.item).price &gt; 9.99;</pre><p> В результате объект в скобках будет правильно интерпретирован как ссылка на столбец <code class="literal">item</code>, из которого выбирается поле.</p><p>При выборке поля из значения составного типа также возможны подобные синтаксические казусы. Например, чтобы выбрать одно поле из результата функции, возвращающей составное значение, потребуется написать что-то подобное: </p><pre class="programlisting">SELECT (my_func(...)).field FROM ...</pre><p> Без дополнительных скобок в этом запросе произойдёт синтаксическая ошибка.</p><p>Специальное имя поля <code class="literal">*</code> означает <span class="quote">«<span class="quote">все поля</span>»</span>; подробнее об этом рассказывается в <a class="xref" href="rowtypes.html#ROWTYPES-USAGE" title="8.16.5. Использование составных типов в запросах">Подразделе 8.16.5</a>.</p></div><div class="sect2" id="ROWTYPES-MODIFYING"><div class="titlepage"><div><div><h3 class="title">8.16.4. Изменение составных типов <a href="#ROWTYPES-MODIFYING" class="id_link">#</a></h3></div></div></div><p>Ниже приведены примеры правильных команд добавления и изменения значений составных столбцов. Первые команды иллюстрируют добавление или изменение всего столбца: </p><pre class="programlisting">INSERT INTO mytab (complex_col) VALUES((1.1,2.2));

UPDATE mytab SET complex_col = ROW(1.1,2.2) WHERE ...;</pre><p> В первом примере опущено ключевое слово <code class="literal">ROW</code>, а во втором оно есть; присутствовать или отсутствовать оно может в обоих случаях.</p><p>Мы можем изменить также отдельное поле составного столбца: </p><pre class="programlisting">UPDATE mytab SET complex_col.r = (complex_col).r + 1 WHERE ...;</pre><p> Заметьте, что при этом не нужно (и на самом деле даже нельзя) заключать в скобки имя столбца, следующее сразу за предложением <code class="literal">SET</code>, но в ссылке на тот же столбец в выражении, находящемся по правую сторону знака равенства, скобки обязательны.</p><p>И мы также можем указать поля в качестве цели команды <code class="command">INSERT</code>: </p><pre class="programlisting">INSERT INTO mytab (complex_col.r, complex_col.i) VALUES(1.1, 2.2);</pre><p> Если при этом мы не укажем значения для всех полей столбца, оставшиеся поля будут заполнены значениями NULL.</p></div><div class="sect2" id="ROWTYPES-USAGE"><div class="titlepage"><div><div><h3 class="title">8.16.5. Использование составных типов в запросах <a href="#ROWTYPES-USAGE" class="id_link">#</a></h3></div></div></div><p>С составными типами в запросах связаны особые правила синтаксиса и поведение. Эти правила образуют полезные конструкции, но они могут быть неочевидными, если не понимать стоящую за ними логику.</p><p>В <span class="productname">PostgreSQL</span> ссылка на имя таблицы (или её псевдоним) в запросе по сути является ссылкой на составное значение текущей строки в этой таблице. Например, имея таблицу <code class="structname">inventory_item</code>, показанную <a class="link" href="rowtypes.html#ROWTYPES-DECLARING" title="8.16.1. Объявление составных типов">выше</a>, мы можем написать: </p><pre class="programlisting">SELECT c FROM inventory_item c;</pre><p> Этот запрос выдаёт один столбец с составным значением, и его результат может быть таким: </p><pre class="programlisting">           c
------------------------
 ("fuzzy dice",42,1.99)
(1 row)</pre><p> Заметьте, однако, что простые имена сопоставляются сначала с именами столбцов, и только потом с именами таблиц, так что такой результат получается только потому, что в таблицах запроса не оказалось столбца с именем <code class="structfield">c</code>.</p><p>Обычную запись полного имени столбца вида <em class="replaceable"><code>имя_таблицы</code></em><code class="literal">.</code><em class="replaceable"><code>имя_столбца</code></em> можно понимать как применение <a class="link" href="sql-expressions.html#FIELD-SELECTION" title="4.2.4. Выбор поля">выбора поля</a> к составному значению текущей строки таблицы. (Из соображений эффективности на самом деле это реализовано по-другому.)</p><p>Когда мы пишем </p><pre class="programlisting">SELECT c.* FROM inventory_item c;</pre><p> то, согласно стандарту SQL, мы должны получить содержимое таблицы, развёрнутое в отдельные столбцы: </p><pre class="programlisting">    name    | supplier_id | price
------------+-------------+-------
 fuzzy dice |          42 |  1.99
(1 row)</pre><p> как с запросом </p><pre class="programlisting">SELECT c.name, c.supplier_id, c.price FROM inventory_item c;</pre><p> <span class="productname">PostgreSQL</span> применяет такое развёртывание для любых выражений с составными значениями, хотя как показано <a class="link" href="rowtypes.html#ROWTYPES-ACCESSING" title="8.16.3. Обращение к составным типам">выше</a>, необходимо заключить в скобки значение, к которому применяется <code class="literal">.*</code>, если только это не простое имя таблицы. Например, если <code class="function">myfunc()</code> — функция, возвращающая составной тип со столбцами <code class="structfield">a</code>, <code class="structfield">b</code> и <code class="structfield">c</code>, то эти два запроса выдадут одинаковый результат: </p><pre class="programlisting">SELECT (myfunc(x)).* FROM some_table;
SELECT (myfunc(x)).a, (myfunc(x)).b, (myfunc(x)).c FROM some_table;</pre><div class="tip"><h3 class="title">Подсказка</h3><p><span class="productname">PostgreSQL</span> осуществляет развёртывание столбцов фактически переводя первую форму во вторую. Таким образом, в данном примере <code class="function">myfunc()</code> будет вызываться три раза для каждой строки и с одним, и с другим синтаксисом. Если это дорогостоящая функция, и вы хотите избежать лишних вызовов, можно использовать такой запрос: </p><pre class="programlisting">SELECT m.* FROM some_table, LATERAL myfunc(x) AS m;</pre><p> Размещение вызова функции в элементе <code class="literal">FROM</code> <code class="literal">LATERAL</code> гарантирует, что она будет вызываться для строки не более одного раза. Конструкция <code class="literal">m.*</code> так же разворачивается в <code class="literal">m.a, m.b, m.c</code>, но теперь эти переменные просто ссылаются на выходные значения <code class="literal">FROM</code>. (Ключевое слово <code class="literal">LATERAL</code> здесь является необязательным, но мы добавили его, чтобы подчеркнуть, что функция получает <code class="structfield">x</code> из <code class="structname">some_table</code>.)</p></div><p>Запись <em class="replaceable"><code>составное_значение</code></em><code class="literal">.*</code> приводит к такому развёртыванию столбцов, когда она фигурирует на верхнем уровне <a class="link" href="queries-select-lists.html" title="7.3. Списки выборки">выходного списка <code class="command">SELECT</code></a>, в <a class="link" href="dml-returning.html" title="6.4. Возврат данных из изменённых строк">списке <code class="literal">RETURNING</code></a> команд <code class="command">INSERT</code>/<code class="command">UPDATE</code>/<code class="command">DELETE</code>, в <a class="link" href="queries-values.html" title="7.7. Списки VALUES"><code class="literal">предложении VALUES</code></a> или в <a class="link" href="sql-expressions.html#SQL-SYNTAX-ROW-CONSTRUCTORS" title="4.2.13. Конструкторы табличных строк">конструкторе строки</a>. Во всех других контекстах (включая вложенные в одну из этих конструкций), добавление <code class="literal">.*</code> к составному значению не меняет это значение, так как это воспринимается как <span class="quote">«<span class="quote">все столбцы</span>»</span> и поэтому выдаётся то же составное значение. Например, если функция <code class="function">somefunc()</code> принимает в качестве аргумента составное значение, эти запросы равносильны: </p><pre class="programlisting">SELECT somefunc(c.*) FROM inventory_item c;
SELECT somefunc(c) FROM inventory_item c;</pre><p> В обоих случаях текущая строка таблицы <code class="structname">inventory_item</code> передаётся функции как один аргумент с составным значением. И хотя дополнение <code class="literal">.*</code> в этих случаях не играет роли, использовать его считается хорошим стилем, так как это ясно указывает на использование составного значения. В частности анализатор запроса воспримет <code class="literal">c</code> в записи <code class="literal">c.*</code> как ссылку на имя или псевдоним таблицы, а не имя столбца, что избавляет от неоднозначности; тогда как без <code class="literal">.*</code> неясно, означает ли <code class="literal">c</code> имя таблицы или имя столбца, и на самом деле при наличии столбца с именем <code class="literal">c</code> будет выбрано второе прочтение.</p><p>Эту концепцию демонстрирует и следующий пример, все запросы в котором действуют одинаково: </p><pre class="programlisting">SELECT * FROM inventory_item c ORDER BY c;
SELECT * FROM inventory_item c ORDER BY c.*;
SELECT * FROM inventory_item c ORDER BY ROW(c.*);</pre><p> Все эти предложения <code class="literal">ORDER BY</code> обращаются к составному значению строки, вследствие чего строки сортируются по правилам, описанным в <a class="xref" href="functions-comparisons.html#COMPOSITE-TYPE-COMPARISON" title="9.24.6. Сравнение составных типов">Подразделе 9.24.6</a>. Однако если в <code class="structname">inventory_item</code> содержится столбец с именем <code class="structfield">c</code>, первый запрос будет отличаться от других, так как в нём выполнится сортировка только по данному столбцу. С показанными выше именами столбцов предыдущим запросам также равнозначны следующие: </p><pre class="programlisting">SELECT * FROM inventory_item c ORDER BY ROW(c.name, c.supplier_id, c.price);
SELECT * FROM inventory_item c ORDER BY (c.name, c.supplier_id, c.price);</pre><p> (В последнем случае используется конструктор строки, в котором опущено ключевое слово <code class="literal">ROW</code>.)</p><p>Другая особенность синтаксиса, связанная с составными значениями, состоит в том, что мы можем использовать <em class="firstterm">функциональную запись</em> для извлечения поля составного значения. Это легко можно объяснить тем, что записи <code class="literal"><em class="replaceable"><code>поле</code></em>(<em class="replaceable"><code>таблица</code></em>)</code> и <code class="literal"><em class="replaceable"><code>таблица</code></em>.<em class="replaceable"><code>поле</code></em></code> взаимозаменяемы. Например, следующие запросы равнозначны: </p><pre class="programlisting">SELECT c.name FROM inventory_item c WHERE c.price &gt; 1000;
SELECT name(c) FROM inventory_item c WHERE price(c) &gt; 1000;</pre><p> Более того, если у нас есть функция, принимающая один аргумент составного типа, мы можем вызвать её в любой записи. Все эти запросы равносильны: </p><pre class="programlisting">SELECT somefunc(c) FROM inventory_item c;
SELECT somefunc(c.*) FROM inventory_item c;
SELECT c.somefunc FROM inventory_item c;</pre><p>Эта равнозначность записи с полем и функциональной записи позволяет использовать с составными типами функции, реализующие <span class="quote">«<span class="quote">вычисляемые поля</span>»</span>. <a id="id-1.5.7.24.9.10.2" class="indexterm"></a> <a id="id-1.5.7.24.9.10.3" class="indexterm"></a> При этом приложению, использующему последний из предыдущих запросов, не нужно знать, что фактически <code class="literal">somefunc</code> — не настоящий столбец таблицы.</p><div class="tip"><h3 class="title">Подсказка</h3><p>Учитывая такое поведение, будет неразумно давать функции, принимающей один аргумент составного типа, то же имя, что и одному из полей данного составного типа. В случае неоднозначности прочтение имени поля будет выбрано при использовании синтаксиса обращения к полю, а прочтение имени функции — если используется синтаксис вызова функции. Однако в <span class="productname">PostgreSQL</span> до 11 версии всегда выбиралось прочтение имени поля, если только синтаксис вызова не подталкивал к прочтению имени функции. Чтобы принудительно выбрать прочтение имени функции, в предыдущих версиях надо было дополнить это имя схемой, то есть написать <code class="literal"><em class="replaceable"><code>схема</code></em>.<em class="replaceable"><code>функция</code></em>(<em class="replaceable"><code>составное_значение</code></em>)</code>.</p></div></div><div class="sect2" id="ROWTYPES-IO-SYNTAX"><div class="titlepage"><div><div><h3 class="title">8.16.6. Синтаксис вводимых и выводимых значений составного типа <a href="#ROWTYPES-IO-SYNTAX" class="id_link">#</a></h3></div></div></div><p>Внешнее текстовое представление составного значения состоит из записи элементов, интерпретируемых по правилам ввода/вывода для соответствующих типов полей, и оформления структуры составного типа. Оформление состоит из круглых скобок (<code class="literal">(</code> и <code class="literal">)</code>) окружающих всё значение, и запятых (<code class="literal">,</code>) между его элементами. Пробельные символы вне скобок игнорируются, но внутри они считаются частью соответствующего элемента и могут учитываться или не учитываться в зависимости от правил преобразования вводимых данных для типа этого элемента. Например, в записи: </p><pre class="programlisting">'(  42)'</pre><p> пробелы будут игнорироваться, если соответствующее поле имеет целочисленный тип, но не текстовый.</p><p>Как было показано ранее, записывая составное значение, любой его элемент можно заключить в кавычки. Это <span class="emphasis"><em>нужно</em></span> делать, если при разборе этого значения без кавычек возможна неоднозначность. Например, в кавычки нужно заключать элементы, содержащие скобки, кавычки, запятую или обратную косую черту. Чтобы включить в поле составного значения, заключённое в кавычки, такие символы, как кавычки или обратная косая черта, перед ними нужно добавить обратную косую черту. (Кроме того, продублированные кавычки в значении поля, заключённого в кавычки, воспринимаются как одинарные, подобно апострофам в строках SQL.) С другой стороны, можно обойтись без кавычек, защитив все символы в данных, которые могут быть восприняты как часть синтаксиса составного значения, с помощью спецпоследовательностей.</p><p>Значение NULL в этой записи представляется пустым местом (когда между запятыми или скобками нет никаких символов). Чтобы ввести именно пустую строку, а не NULL, нужно написать <code class="literal">""</code>.</p><p>Функция вывода составного значения заключает значения полей в кавычки, если они представляют собой пустые строки, либо содержат скобки, запятые, кавычки или обратную косую черту, либо состоят из одних пробелов. (В последнем случае можно обойтись без кавычек, но они добавляются для удобочитаемости.) Кавычки и обратная косая черта, заключённые в значения полей, при выводе дублируются.</p><div class="note"><h3 class="title">Примечание</h3><p>Помните, что написанная SQL-команда прежде всего интерпретируется как текстовая строка, а затем как составное значение. Вследствие этого число символов обратной косой черты удваивается (если используются спецпоследовательности). Например, чтобы ввести в поле составного столбца значение типа <code class="type">text</code> с обратной косой чертой и кавычками, команду нужно будет записать так: </p><pre class="programlisting">INSERT ... VALUES ('("\"\\")');</pre><p> Сначала обработчик спецпоследовательностей удаляет один уровень обратной косой черты, так что анализатор составного значения получает на вход <code class="literal">("\"\\")</code>. В свою очередь, он передаёт эту строку процедуре ввода значения типа <code class="type">text</code>, где она преобразуются в <code class="literal">"\</code>. (Если бы мы работали с типом данных, процедура ввода которого также интерпретирует обратную косую черту особым образом, например <code class="type">bytea</code>, нам могло бы понадобиться уже восемь таких символов, чтобы сохранить этот символ в поле составного значения.) Во избежание такого дублирования спецсимволов строки можно заключать в доллары (см. <a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-DOLLAR-QUOTING" title="4.1.2.4. Строковые константы, заключённые в доллары">Подраздел 4.1.2.4</a>).</p></div><div class="tip"><h3 class="title">Подсказка</h3><p>Записывать составные значения в командах SQL часто бывает удобнее с помощью конструктора <code class="literal">ROW</code>. В <code class="literal">ROW</code> отдельные значения элементов записываются так же, как если бы они не были членами составного выражения.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="arrays.html" title="8.15. Массивы">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="datatype.html" title="Глава 8. Типы данных">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="rangetypes.html" title="8.17. Диапазонные типы">След.</a></td></tr><tr><td width="40%" align="left" valign="top">8.15. Массивы </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 8.17. Диапазонные типы</td></tr></table></div></body></html>