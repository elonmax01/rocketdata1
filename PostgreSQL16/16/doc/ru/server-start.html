<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>19.3. Запуск сервера баз данных</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="creating-cluster.html" title="19.2. Создание кластера баз данных" /><link rel="next" href="kernel-resources.html" title="19.4. Управление ресурсами ядра" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">19.3. Запуск сервера баз данных</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="creating-cluster.html" title="19.2. Создание кластера баз данных">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="runtime.html" title="Глава 19. Подготовка к работе и сопровождение сервера">Наверх</a></td><th width="60%" align="center">Глава 19. Подготовка к работе и сопровождение сервера</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="kernel-resources.html" title="19.4. Управление ресурсами ядра">След.</a></td></tr></table><hr /></div><div class="sect1" id="SERVER-START"><div class="titlepage"><div><div><h2 class="title" style="clear: both">19.3. Запуск сервера баз данных <a href="#SERVER-START" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="server-start.html#SERVER-START-FAILURES">19.3.1. Сбои при запуске сервера</a></span></dt><dt><span class="sect2"><a href="server-start.html#CLIENT-CONNECTION-PROBLEMS">19.3.2. Проблемы с подключениями клиентов</a></span></dt></dl></div><p>Чтобы кто-либо смог обратиться к базе данных, необходимо сначала запустить сервер баз данных. Программа сервера называется <code class="command">postgres</code>.<a id="id-1.6.6.6.2.2" class="indexterm"></a></p><p>Если вы используете <span class="productname">PostgreSQL</span> в виде готового продукта, в нём наверняка реализована возможность запуска сервера в виде фонового задания так, как это принято в вашей операционной системе. Использовать предоставленную продуктом инфраструктуру для запуска сервера гораздо проще, чем пытаться разобраться, как это сделать самостоятельно. За подробностями обратитесь к документации используемого вами продукта.</p><p>Самый прямолинейный вариант запуска сервера вручную — просто выполнить непосредственно <code class="command">postgres</code>, указав расположение каталога данных в ключе <code class="option">-D</code>, например: </p><pre class="screen">
$ <strong class="userinput"><code>postgres -D /usr/local/pgsql/data</code></strong>
</pre><p> В результате сервер продолжит работу на переднем плане. Запускать эту команду следует под именем учётной записи <span class="productname">PostgreSQL</span>. Без параметра <code class="option">-D</code> сервер попытается использовать каталог данных, указанный в переменной окружения <code class="envar">PGDATA</code>. Если и эта переменная не определена, сервер не запустится.</p><p>Однако обычно лучше запускать <code class="command">postgres</code> в фоновом режиме. Для этого можно применить обычный синтаксис, принятый в оболочке Unix: </p><pre class="screen">
$ <strong class="userinput"><code>postgres -D /usr/local/pgsql/data &gt;logfile 2&gt;&amp;1 &amp;</code></strong>
</pre><p> Важно где-либо сохранять информацию, которую выводит сервер в каналы <span class="systemitem">stdout</span> и <span class="systemitem">stderr</span>, как показано выше. Это полезно и для целей аудита, и для диагностики проблем. (Более глубоко работа с файлами журналов рассматривается в <a class="xref" href="logfile-maintenance.html" title="25.3. Обслуживание журнала">Разделе 25.3</a>.)</p><p>Программа <code class="command">postgres</code> также принимает несколько других параметров командной строки. За дополнительными сведениями обратитесь к справочной странице <a class="xref" href="app-postgres.html" title="postgres"><span class="refentrytitle"><span class="application">postgres</span></span></a> и к следующей <a class="xref" href="runtime-config.html" title="Глава 20. Настройка сервера">Главе 20</a>.</p><p>Такой вариант запуска довольно быстро может оказаться неудобным. Поэтому для упрощения подобных задач предлагается вспомогательная программа <a class="xref" href="app-pg-ctl.html" title="pg_ctl"><span class="refentrytitle"><span class="application">pg_ctl</span></span></a><a id="id-1.6.6.6.7.2" class="indexterm"></a>. Например: </p><pre class="programlisting">pg_ctl start -l logfile</pre><p> запустит сервер в фоновом режиме и направит выводимые сообщения сервера в указанный файл журнала. Параметр <code class="option">-D</code> для неё имеет то же значение, что и для программы <code class="command">postgres</code>. С помощью <code class="command">pg_ctl</code> также можно остановить сервер.</p><p>Обычно возникает желание, чтобы сервер баз данных сам запускался при загрузке операционной системы.<a id="id-1.6.6.6.8.1" class="indexterm"></a> Скрипты автозапуска для разных систем разные, но в составе <span class="productname">PostgreSQL</span> предлагается несколько типовых скриптов в каталоге <code class="filename">contrib/start-scripts</code>. Для установки такого скрипта в систему требуются права root.</p><p>В различных системах приняты разные соглашения о порядке запуска служб в процессе загрузки. Во многих системах для этого используется файл <code class="filename">/etc/rc.local</code> или <code class="filename">/etc/rc.d/rc.local</code>. В других применяются каталоги <code class="filename">init.d</code> или <code class="filename">rc.d</code>. Однако при любом варианте запускаться сервер должен от имени пользователя <span class="productname">PostgreSQL</span>, но <span class="emphasis"><em>не root</em></span> или какого-либо другого пользователя. Поэтому команду запуска обычно следует записывать в форме <code class="literal">su postgres -c '...'</code>. Например: </p><pre class="programlisting">su postgres -c 'pg_ctl start -D /usr/local/pgsql/data -l serverlog'</pre><p>Ниже приведены более конкретные предложения для нескольких основных ОС. (Вместо указанных нами шаблонных значений необходимо подставить правильный путь к каталогу данных и фактическое имя пользователя.) </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Для запуска во <span class="productname">FreeBSD</span> воспользуйтесь файлом <code class="filename">contrib/start-scripts/freebsd</code> в дереве исходного кода <span class="productname">PostgreSQL</span>. <a id="id-1.6.6.6.10.1.1.1.4" class="indexterm"></a></p></li><li class="listitem"><p>В <span class="productname">OpenBSD</span>, добавьте в файл <code class="filename">/etc/rc.local</code> следующие строки: <a id="id-1.6.6.6.10.1.2.1.3" class="indexterm"></a> </p><pre class="programlisting">if [ -x /usr/local/pgsql/bin/pg_ctl -a -x /usr/local/pgsql/bin/postgres ]; then
    su -l postgres -c '/usr/local/pgsql/bin/pg_ctl start -s -l /var/postgresql/log -D /usr/local/pgsql/data'
    echo -n ' postgresql'
fi</pre></li><li class="listitem"><p>В системах <span class="productname">Linux</span> вы можете либо добавить <a id="id-1.6.6.6.10.1.3.1.2" class="indexterm"></a> </p><pre class="programlisting">/usr/local/pgsql/bin/pg_ctl start -l logfile -D /usr/local/pgsql/data</pre><p> в <code class="filename">/etc/rc.d/rc.local</code> или в <code class="filename">/etc/rc.local</code>, либо воспользоваться файлом <code class="filename">contrib/start-scripts/linux</code> в дереве исходного кода <span class="productname">PostgreSQL</span>.</p><p>Используя <span class="application">systemd</span>, вы можете применить следующий файл описания службы (например, <code class="filename">/etc/systemd/system/postgresql.service</code>):<a id="id-1.6.6.6.10.1.3.2.3" class="indexterm"></a> </p><pre class="programlisting">[Unit]
Description=PostgreSQL database server
Documentation=man:postgres(1)
After=network-online.target
Wants=network-online.target

[Service]
Type=notify
User=postgres
ExecStart=/usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data
ExecReload=/bin/kill -HUP $MAINPID
KillMode=mixed
KillSignal=SIGINT
TimeoutSec=infinity

[Install]
WantedBy=multi-user.target</pre><p> Для использования <code class="literal">Type=notify</code> требуется, чтобы сервер был скомпилирован с указанием <code class="literal">configure --with-systemd</code>.</p><p>Особого внимания заслуживает значение тайм-аута. На момент написания этой документации по умолчанию в <span class="application">systemd</span> принят тайм-аут 90 секунд, так что процесс, не сообщивший о своей готовности за это время, будет уничтожен. Но серверу <span class="productname">PostgreSQL</span> при запуске может потребоваться выполнить восстановление после сбоя, так что переход в состояние готовности может занять гораздо больше времени. Предлагаемое значение <code class="literal">infinity</code> отключает логику тайм-аута.</p></li><li class="listitem"><p>В <span class="productname">NetBSD</span> можно использовать скрипт запуска для <span class="productname">FreeBSD</span> или для <span class="productname">Linux</span>, в зависимости от предпочтений. <a id="id-1.6.6.6.10.1.4.1.4" class="indexterm"></a></p></li><li class="listitem"><p>В <span class="productname">Solaris</span>, создайте файл с именем <code class="filename">/etc/init.d/postgresql</code>, содержащий следующую стоку: <a id="id-1.6.6.6.10.1.5.1.3" class="indexterm"></a> </p><pre class="programlisting">su - postgres -c "/usr/local/pgsql/bin/pg_ctl start -l logfile -D /usr/local/pgsql/data"</pre><p> Затем создайте символическую ссылку на него в каталоге <code class="filename">/etc/rc3.d</code> с именем <code class="filename">S99postgresql</code>.</p></li></ul></div><p>Когда сервер работает, идентификатор его процесса (<acronym class="acronym">PID</acronym>) сохраняется в файле <code class="filename">postmaster.pid</code> в каталоге данных. Это позволяет исключить запуск нескольких экземпляров сервера с одним каталогом данных, а также может быть полезно для выключения сервера.</p><div class="sect2" id="SERVER-START-FAILURES"><div class="titlepage"><div><div><h3 class="title">19.3.1. Сбои при запуске сервера <a href="#SERVER-START-FAILURES" class="id_link">#</a></h3></div></div></div><p>Есть несколько распространённых причин, по которым сервер может не запуститься. Чтобы понять, чем вызван сбой, просмотрите файл журнала сервера или запустите сервер вручную (не перенаправляя его потоки стандартного вывода и ошибок) и проанализируйте выводимые сообщения. Ниже мы рассмотрим некоторые из наиболее частых сообщений об ошибках более подробно.</p><pre class="screen">
LOG:  could not bind IPv4 address "127.0.0.1": Address already in use
HINT:  Is another postmaster already running on port 5432? If not, wait a few seconds and retry.
FATAL:  could not create any TCP/IP sockets
</pre><p> Это обычно означает именно то, что написано: вы пытаетесь запустить сервер на том же порту, на котором уже работает другой. Однако если сообщение ядра не <code class="computeroutput">Address
     already in use</code> или подобное, возможна и другая проблема. Например, при попытке запустить сервер с номером зарезервированного порта будут выданы такие сообщения: </p><pre class="screen">
$ <strong class="userinput"><code>postgres -p 666</code></strong>
LOG:  could not bind IPv4 address "127.0.0.1": Permission denied
HINT:  Is another postmaster already running on port 666? If not, wait a few seconds and retry.
FATAL:  could not create any TCP/IP sockets
</pre><p>Следующее сообщение: </p><pre class="screen">
FATAL:  could not create shared memory segment: Invalid argument
DETAIL:  Failed system call was shmget(key=5440001, size=4011376640, 03600).
</pre><p> может означать, что установленный для вашего ядра предельный размер разделяемой памяти слишком мал для рабочей области, которую пытается создать <span class="productname">PostgreSQL</span> (в данном примере 4011376640 байт). Такая ситуация возможна, только если в <code class="literal">shared_memory_type</code> выбран вариант <code class="literal">sysv</code>. В этом случае можно попытаться запустить сервер с меньшим числом буферов (<a class="xref" href="runtime-config-resource.html#GUC-SHARED-BUFFERS">shared_buffers</a>) или переконфигурировать ядро и увеличить допустимый размер разделяемой памяти. Вы также можете увидеть это сообщение при попытке запустить несколько серверов на одном компьютере, если запрошенный ими объём памяти в сумме превышает установленный в ядре предел.</p><p>Сообщение: </p><pre class="screen">
FATAL:  could not create semaphores: No space left on device
DETAIL:  Failed system call was semget(5440126, 17, 03600).
</pre><p> <span class="emphasis"><em>не</em></span> означает, что у вас закончилось место на диске. Это значит, что установленное в вашем ядре предельное число семафоров <span class="systemitem">System V</span> меньше, чем количество семафоров, которое пытается создать <span class="productname">PostgreSQL</span>. Как и в предыдущем случае можно попытаться обойти эту проблему, запустив сервер с меньшим числом допустимых подключений (<a class="xref" href="runtime-config-connection.html#GUC-MAX-CONNECTIONS">max_connections</a>), но в конце концов вам придётся увеличить этот предел в ядре.</p><p>Настройка средств <acronym class="acronym">IPC</acronym> в стиле <span class="systemitem">System V</span> описывается в <a class="xref" href="kernel-resources.html#SYSVIPC" title="19.4.1. Разделяемая память и семафоры">Подразделе 19.4.1</a>.</p></div><div class="sect2" id="CLIENT-CONNECTION-PROBLEMS"><div class="titlepage"><div><div><h3 class="title">19.3.2. Проблемы с подключениями клиентов <a href="#CLIENT-CONNECTION-PROBLEMS" class="id_link">#</a></h3></div></div></div><p>Хотя ошибки подключений, возможные на стороне клиента, довольно разнообразны и зависят от приложений, всё же несколько проблем могут быть связаны непосредственно с тем, как был запущен сервер. Описание ошибок, отличных от описанных ниже, следует искать в документации соответствующего клиентского приложения.</p><pre class="screen">
psql: ошибка: не удалось подключиться к серверу "server.joe.com" (123.123.123.123) по порту 5432: Connection refused
        Он действительно работает по адресу "server.joe.com" (123.123.123.123) и принимает TCP-соединения (порт 5432)?
</pre><p> Это общая проблема <span class="quote">«<span class="quote">я не могу найти сервер и начать взаимодействие с ним</span>»</span>. Показанное выше сообщение говорит о попытке установить подключение по TCP/IP. Очень часто объясняется это тем, что сервер просто забыли настроить для работы по протоколу TCP/IP.</p><p>Кроме того, при попытке установить подключение к локальному серверу через Unix-сокет можно получить такое сообщение: </p><pre class="screen">
psql: ошибка: не удалось подключиться к серверу через сокет "/tmp/.s.PGSQL.5432": No such file or directory
        Он действительно работает локально и принимает соединения через этот сокет?
</pre><p> Если сервер действительно работает, проверьте, что указываемый клиентом путь сокета (здесь <code class="literal">/tmp</code>) соответствует значению <a class="xref" href="runtime-config-connection.html#GUC-UNIX-SOCKET-DIRECTORIES">unix_socket_directories</a>.</p><p>Сообщение об ошибке подключения всегда содержит адрес сервера или путь к сокету, что помогает понять, куда именно подключается клиент. Если сервер на самом деле не принимает подключения по этому адресу, обычно выдаётся сообщение ядра <code class="computeroutput">Connection refused</code> (В соединении отказано) или <code class="computeroutput">No such file or directory</code> (Нет такого файла или каталога), приведённое выше. (Важно понимать, что <code class="computeroutput">Connection refused</code> в данном контексте <span class="emphasis"><em>не</em></span> означает, что сервер получил запрос на подключение и отверг его. В этом случае были бы выданы другие сообщения, например, показанные в <a class="xref" href="client-authentication-problems.html" title="21.15. Проблемы аутентификации">Разделе 21.15</a>.) Другие сообщения об ошибках, например <code class="computeroutput">Connection timed out</code> (Тайм-аут соединения) могут сигнализировать о более фундаментальных проблемах, например, о нарушениях сетевых соединений или о блокировании подключения брандмауэром.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="creating-cluster.html" title="19.2. Создание кластера баз данных">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="runtime.html" title="Глава 19. Подготовка к работе и сопровождение сервера">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="kernel-resources.html" title="19.4. Управление ресурсами ядра">След.</a></td></tr><tr><td width="40%" align="left" valign="top">19.2. Создание кластера баз данных </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 19.4. Управление ресурсами ядра</td></tr></table></div></body></html>