<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>9.16. Функции и операторы JSON</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="functions-xml.html" title="9.15. XML-функции" /><link rel="next" href="functions-sequence.html" title="9.17. Функции для работы с последовательностями" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">9.16. Функции и операторы JSON</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="functions-xml.html" title="9.15. XML-функции">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="functions.html" title="Глава 9. Функции и операторы">Наверх</a></td><th width="60%" align="center">Глава 9. Функции и операторы</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="functions-sequence.html" title="9.17. Функции для работы с последовательностями">След.</a></td></tr></table><hr /></div><div class="sect1" id="FUNCTIONS-JSON"><div class="titlepage"><div><div><h2 class="title" style="clear: both">9.16. Функции и операторы JSON <a href="#FUNCTIONS-JSON" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="functions-json.html#FUNCTIONS-JSON-PROCESSING">9.16.1. Обработка и создание данных JSON</a></span></dt><dt><span class="sect2"><a href="functions-json.html#FUNCTIONS-SQLJSON-PATH">9.16.2. Язык путей SQL/JSON</a></span></dt></dl></div><a id="id-1.5.8.22.2" class="indexterm"></a><a id="id-1.5.8.22.3" class="indexterm"></a><p>В этом разделе описываются: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>функции и операторы, предназначенные для работы с данными JSON</p></li><li class="listitem"><p>язык путей SQL/JSON</p></li></ul></div><p><span class="productname">PostgreSQL</span> реализует <em class="firstterm">модель данных SQL/JSON</em>, обеспечивая встроенную поддержку типов данных JSON в среде SQL. В этой модели данные представляются последовательностями элементов. Каждый элемент может содержать скалярные значения SQL, дополнительно определённое в SQL/JSON значение null и составные структуры данных, образуемые объектами и массивами JSON. Данная модель по сути формализует модель данных, описанную в спецификации JSON <a class="ulink" href="https://datatracker.ietf.org/doc/html/rfc7159" target="_top">RFC 7159</a>.</p><p>Поддержка SQL/JSON позволяет обрабатывать данные JSON наряду с обычными данными SQL, используя при этом транзакции, например: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Загружать данные JSON в базу и сохранять их в обычных столбцах SQL в виде символьных или двоичных строк.</p></li><li class="listitem"><p>Создавать объекты и массивы JSON из реляционных данных.</p></li><li class="listitem"><p>Обращаться к данным JSON, используя функции запросов SQL/JSON и выражения языка путей SQL/JSON.</p></li></ul></div><p>Чтобы узнать больше о стандарте SQL/JSON, обратитесь к <a class="xref" href="biblio.html#SQLTR-19075-6" title="SQL Technical Report">[sqltr-19075-6]</a>. Типы JSON, поддерживаемые в <span class="productname">PostgreSQL</span>, описаны в <a class="xref" href="datatype-json.html" title="8.14. Типы JSON">Разделе 8.14</a>.</p><div class="sect2" id="FUNCTIONS-JSON-PROCESSING"><div class="titlepage"><div><div><h3 class="title">9.16.1. Обработка и создание данных JSON <a href="#FUNCTIONS-JSON-PROCESSING" class="id_link">#</a></h3></div></div></div><p>В <a class="xref" href="functions-json.html#FUNCTIONS-JSON-OP-TABLE" title="Таблица 9.45. Операторы для типов json и jsonb">Таблице 9.45</a> показаны имеющиеся операторы для работы с данными JSON (см. <a class="xref" href="datatype-json.html" title="8.14. Типы JSON">Раздел 8.14</a>). Кроме них для типа <code class="type">jsonb</code>, но не для <code class="type">json</code>, определены обычные операторы сравнения, показанные в <a class="xref" href="functions-comparison.html#FUNCTIONS-COMPARISON-OP-TABLE" title="Таблица 9.1. Операторы сравнения">Таблице 9.1</a>. Они следуют правилам упорядочивания для операций B-дерева, описанным в <a class="xref" href="datatype-json.html#JSON-INDEXING" title="8.14.4. Индексация jsonb">Подразделе 8.14.4</a>. В <a class="xref" href="functions-aggregate.html" title="9.21. Агрегатные функции">Разделе 9.21</a> вы также можете узнать об агрегатной функции <code class="function">json_agg</code>, которая агрегирует значения записи в виде JSON, и агрегатной функции <code class="function">json_object_agg</code>, агрегирующей пары значений в объект JSON, а также их аналогах для <code class="type">jsonb</code>, функциях <code class="function">jsonb_agg</code> и <code class="function">jsonb_object_agg</code>.</p><div class="table" id="FUNCTIONS-JSON-OP-TABLE"><p class="title"><strong>Таблица 9.45. Операторы для типов <code class="type">json</code> и <code class="type">jsonb</code></strong></p><div class="table-contents"><table class="table" summary="Операторы для типов json и jsonb" border="1"><colgroup><col /></colgroup><thead><tr><th class="func_table_entry"><p class="func_signature">Оператор</p>
       <p>Описание</p>
       <p>Пример(ы)</p></th></tr></thead><tbody><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">json</code> <code class="literal">-&gt;</code> <code class="type">integer</code>
        → <code class="returnvalue">json</code>
       </p>
       <p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">-&gt;</code> <code class="type">integer</code>
        → <code class="returnvalue">jsonb</code>
       </p>
       <p>Извлекает <em class="parameter"><code>n</code></em>-ый элемент JSON-массива (элементы массива нумеруются с 0, а отрицательные числа задают позиции с конца).</p>
       <p>
        <code class="literal">'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json -&gt; 2</code>
        → <code class="returnvalue">{"c":"baz"}</code>
       </p>
       <p>
        <code class="literal">'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json -&gt; -3</code>
        → <code class="returnvalue">{"a":"foo"}</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">json</code> <code class="literal">-&gt;</code> <code class="type">text</code>
        → <code class="returnvalue">json</code>
       </p>
       <p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">-&gt;</code> <code class="type">text</code>
        → <code class="returnvalue">jsonb</code>
       </p>
       <p>Извлекает поле JSON-объекта по заданному ключу.</p>
       <p>
        <code class="literal">'{"a": {"b":"foo"}}'::json -&gt; 'a'</code>
        → <code class="returnvalue">{"b":"foo"}</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">json</code> <code class="literal">-&gt;&gt;</code> <code class="type">integer</code>
        → <code class="returnvalue">text</code>
       </p>
       <p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">-&gt;&gt;</code> <code class="type">integer</code>
        → <code class="returnvalue">text</code>
       </p>
       <p>Извлекает <em class="parameter"><code>n</code></em>-ый элемент из JSON-массива, в виде значения <code class="type">text</code>.</p>
       <p>
        <code class="literal">'[1,2,3]'::json -&gt;&gt; 2</code>
        → <code class="returnvalue">3</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">json</code> <code class="literal">-&gt;&gt;</code> <code class="type">text</code>
        → <code class="returnvalue">text</code>
       </p>
       <p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">-&gt;&gt;</code> <code class="type">text</code>
        → <code class="returnvalue">text</code>
       </p>
       <p>Извлекает поле JSON-объекта по заданному ключу, в виде значения <code class="type">text</code>.</p>
       <p>
        <code class="literal">'{"a":1,"b":2}'::json -&gt;&gt; 'b'</code>
        → <code class="returnvalue">2</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">json</code> <code class="literal">#&gt;</code> <code class="type">text[]</code>
        → <code class="returnvalue">json</code>
       </p>
       <p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">#&gt;</code> <code class="type">text[]</code>
        → <code class="returnvalue">jsonb</code>
       </p>
       <p>Извлекает внутренний JSON-объект по заданному пути, элементами которого могут быть индексы массивов или ключи.</p>
       <p>
        <code class="literal">'{"a": {"b": ["foo","bar"]}}'::json #&gt; '{a,b,1}'</code>
        → <code class="returnvalue">"bar"</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">json</code> <code class="literal">#&gt;&gt;</code> <code class="type">text[]</code>
        → <code class="returnvalue">text</code>
       </p>
       <p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">#&gt;&gt;</code> <code class="type">text[]</code>
        → <code class="returnvalue">text</code>
       </p>
       <p>Извлекает внутренний JSON-объект по заданному пути в виде значения <code class="type">text</code>.</p>
       <p>
        <code class="literal">'{"a": {"b": ["foo","bar"]}}'::json #&gt;&gt; '{a,b,1}'</code>
        → <code class="returnvalue">bar</code>
       </p></td></tr></tbody></table></div></div><br class="table-break" /><div class="note"><h3 class="title">Примечание</h3><p>Если структура входного JSON не соответствует запросу, например указанный ключ или элемент массива отсутствует, операторы извлечения поля/элемента/пути не выдают ошибку, а возвращают NULL.</p></div><p>Некоторые из следующих операторов существуют только для <code class="type">jsonb</code>, как показано в <a class="xref" href="functions-json.html#FUNCTIONS-JSONB-OP-TABLE" title="Таблица 9.46. Дополнительные операторы jsonb">Таблице 9.46</a>. В <a class="xref" href="datatype-json.html#JSON-INDEXING" title="8.14.4. Индексация jsonb">Подразделе 8.14.4</a> описано, как эти операторы могут использоваться для эффективного поиска в индексированных данных <code class="type">jsonb</code>.</p><div class="table" id="FUNCTIONS-JSONB-OP-TABLE"><p class="title"><strong>Таблица 9.46. Дополнительные операторы <code class="type">jsonb</code></strong></p><div class="table-contents"><table class="table" summary="Дополнительные операторы jsonb" border="1"><colgroup><col /></colgroup><thead><tr><th class="func_table_entry"><p class="func_signature">Оператор</p>
       <p>Описание</p>
       <p>Пример(ы)</p></th></tr></thead><tbody><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">@&gt;</code> <code class="type">jsonb</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>Первое значение JSON содержит второе? (Что означает «содержит», подробно описывается в <a class="xref" href="datatype-json.html#JSON-CONTAINMENT" title="8.14.3. Проверки на вхождение и существование jsonb">Подразделе 8.14.3</a>.)</p>
       <p>
        <code class="literal">'{"a":1, "b":2}'::jsonb @&gt; '{"b":2}'::jsonb</code>
        → <code class="returnvalue">t</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">&lt;@</code> <code class="type">jsonb</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>Первое значение JSON содержится во втором?</p>
       <p>
        <code class="literal">'{"b":2}'::jsonb &lt;@ '{"a":1, "b":2}'::jsonb</code>
        → <code class="returnvalue">t</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">?</code> <code class="type">text</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>Текстовая строка присутствует в значении JSON в качестве ключа верхнего уровня или элемента массива?</p>
       <p>
        <code class="literal">'{"a":1, "b":2}'::jsonb ? 'b'</code>
        → <code class="returnvalue">t</code>
       </p>
       <p>
        <code class="literal">'["a", "b", "c"]'::jsonb ? 'b'</code>
        → <code class="returnvalue">t</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">?|</code> <code class="type">text[]</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>Какие-либо текстовые строки из массива присутствуют в качестве ключей верхнего уровня или элементов массива?</p>
       <p>
        <code class="literal">'{"a":1, "b":2, "c":3}'::jsonb ?| array['b', 'd']</code>
        → <code class="returnvalue">t</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">?&amp;</code> <code class="type">text[]</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>Все текстовые строки из массива присутствуют в качестве ключей верхнего уровня или элементов массива?</p>
       <p>
        <code class="literal">'["a", "b", "c"]'::jsonb ?&amp; array['a', 'b']</code>
        → <code class="returnvalue">t</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">||</code> <code class="type">jsonb</code>
        → <code class="returnvalue">jsonb</code>
       </p>
       <p>Соединяет два значения <code class="type">jsonb</code>. При соединении двух массивов получается массив, содержащий все их элементы. При соединении двух объектов получается объект с объединённым набором ключей и значений, при этом в случае совпадения ключей выбирается значение из второго объекта. Все другие варианты соединения реализуются путём преобразования аргументов, отличных от массивов, в массивы с одним элементом, которые затем как массивы и соединяются. Эта операция не рекурсивна — объединение производится только на верхнем уровне структуры объекта или массива.</p>
       <p>
        <code class="literal">'["a", "b"]'::jsonb || '["a", "d"]'::jsonb</code>
        → <code class="returnvalue">["a", "b", "a", "d"]</code>
       </p>
       <p>
        <code class="literal">'{"a": "b"}'::jsonb || '{"c": "d"}'::jsonb</code>
        → <code class="returnvalue">{"a": "b", "c": "d"}</code>
       </p>
       <p>
        <code class="literal">'[1, 2]'::jsonb || '3'::jsonb</code>
        → <code class="returnvalue">[1, 2, 3]</code>
       </p>
       <p>
        <code class="literal">'{"a": "b"}'::jsonb || '42'::jsonb</code>
        → <code class="returnvalue">[{"a": "b"}, 42]</code>
       </p>
       <p>Чтобы вставить один массив в другой в качестве массива, поместите его в дополнительный массив, например:</p>
       <p>
        <code class="literal">'[1, 2]'::jsonb || jsonb_build_array('[3, 4]'::jsonb)</code>
        → <code class="returnvalue">[1, 2, [3, 4]]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">-</code> <code class="type">text</code>
        → <code class="returnvalue">jsonb</code>
       </p>
       <p>Удаляет ключ (и его значение) из JSON-объекта или соответствующие строковые значения из JSON-массива.</p>
       <p>
        <code class="literal">'{"a": "b", "c": "d"}'::jsonb - 'a'</code>
        → <code class="returnvalue">{"c": "d"}</code>
       </p>
       <p>
        <code class="literal">'["a", "b", "c", "b"]'::jsonb - 'b'</code>
        → <code class="returnvalue">["a", "c"]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">-</code> <code class="type">text[]</code>
        → <code class="returnvalue">jsonb</code>
       </p>
       <p>Удаляет из левого операнда все перечисленные ключи или элементы массива.</p>
       <p>
        <code class="literal">'{"a": "b", "c": "d"}'::jsonb - '{a,c}'::text[]</code>
        → <code class="returnvalue">{}</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">-</code> <code class="type">integer</code>
        → <code class="returnvalue">jsonb</code>
       </p>
       <p>Удаляет из массива элемент в заданной позиции (отрицательные номера позиций отсчитываются от конца). Выдаёт ошибку, если переданное значение JSON — не массив.</p>
       <p>
        <code class="literal">'["a", "b"]'::jsonb - 1</code>
        → <code class="returnvalue">["a"]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">#-</code> <code class="type">text[]</code>
        → <code class="returnvalue">jsonb</code>
       </p>
       <p>Удаляет поле или элемент массива с заданным путём, в составе которого могут быть индексы массивов или ключи.</p>
       <p>
        <code class="literal">'["a", {"b":1}]'::jsonb #- '{1,b}'</code>
        → <code class="returnvalue">["a", {}]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">@?</code> <code class="type">jsonpath</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>Выдаёт ли путь JSON какой-либо элемент для заданного значения JSON?</p>
       <p>
        <code class="literal">'{"a":[1,2,3,4,5]}'::jsonb @? '$.a[*] ? (@ &gt; 2)'</code>
        → <code class="returnvalue">t</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">@@</code> <code class="type">jsonpath</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>Возвращает результат проверки предиката пути JSON для заданного значения JSON. При этом учитывается только первый элемент результата. Если результат не является логическим, возвращается <code class="literal">NULL</code>.</p>
       <p>
        <code class="literal">'{"a":[1,2,3,4,5]}'::jsonb @@ '$.a[*] &gt; 2'</code>
        → <code class="returnvalue">t</code>
       </p></td></tr></tbody></table></div></div><br class="table-break" /><div class="note"><h3 class="title">Примечание</h3><p>Операторы <code class="type">jsonpath</code> <code class="literal">@?</code> и <code class="literal">@@</code> подавляют следующие ошибки: отсутствие поля объекта или элемента массива, несовпадение типа элемента JSON и ошибки в числах и дате/времени. Описанные ниже функции, связанные с <code class="type">jsonpath</code>, тоже могут подавлять ошибки такого рода. Это может быть полезно, когда нужно произвести поиск по набору документов JSON, имеющих различную структуру.</p></div><p>В <a class="xref" href="functions-json.html#FUNCTIONS-JSON-CREATION-TABLE" title="Таблица 9.47. Функции для создания JSON">Таблице 9.47</a> показаны функции, позволяющие создавать значения типов <code class="type">json</code> и <code class="type">jsonb</code>. Для некоторых функций в этой таблице имеется предложение <code class="literal">RETURNING</code>, которое определяет возвращаемый тип данных. Это должен быть <code class="type">json</code>, <code class="type">jsonb</code>, <code class="type">bytea</code>, тип символьной строки (<code class="type">text</code>, <code class="type">char</code> или <code class="type">varchar</code>) или тип, для которого существует приведение из <code class="type">json</code> к этому типу. По умолчанию возвращается тип <code class="type">json</code>.</p><div class="table" id="FUNCTIONS-JSON-CREATION-TABLE"><p class="title"><strong>Таблица 9.47. Функции для создания JSON</strong></p><div class="table-contents"><table class="table" summary="Функции для создания JSON" border="1"><colgroup><col /></colgroup><thead><tr><th class="func_table_entry"><p class="func_signature">Функция</p>
       <p>Описание</p>
       <p>Пример(ы)</p></th></tr></thead><tbody><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.9.2.2.1.1.1.1" class="indexterm"></a> <code class="function">to_json</code> ( <code class="type">anyelement</code> ) → <code class="returnvalue">json</code></p>
       <p class="func_signature"><a id="id-1.5.8.22.8.9.2.2.1.1.2.1" class="indexterm"></a> <code class="function">to_jsonb</code> ( <code class="type">anyelement</code> ) → <code class="returnvalue">jsonb</code></p>
       <p>Преобразует произвольное SQL-значение в <code class="type">json</code> или <code class="type">jsonb</code>. Массивы и составные структуры преобразуются рекурсивно в массивы и объекты (многомерные массивы становятся в JSON массивами массивов). Для других типов, для которых определено приведение к <code class="type">json</code>, применяется эта функция приведения;<a href="#ftn.id-1.5.8.22.8.9.2.2.1.1.3.4" class="footnote"><sup class="footnote" id="id-1.5.8.22.8.9.2.2.1.1.3.4">[a]</sup></a> для всех остальных выдаётся скалярное значение. Значения всех скалярных типов, кроме числового, логического и NULL, представляются в текстовом виде; при этом может добавляться экранирование символов, необходимое для получения допустимых строковых значений <code class="type">json</code> или <code class="type">jsonb</code>.</p>
       <p>
        <code class="literal">to_json('Fred said "Hi."'::text)</code>
        → <code class="returnvalue">"Fred said \"Hi.\""</code>
       </p>
       <p>
        <code class="literal">to_jsonb(row(42, 'Fred said "Hi."'::text))</code>
        → <code class="returnvalue">{"f1": 42, "f2": "Fred said \"Hi.\""}</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.9.2.2.2.1.1.1" class="indexterm"></a> <code class="function">array_to_json</code> ( <code class="type">anyarray</code> [<span class="optional">, <code class="type">boolean</code></span>] ) → <code class="returnvalue">json</code></p>
       <p>Преобразует массив SQL в JSON-массив. Эта функция работает так же, как <code class="function">to_json</code>, но если в необязательном логическом параметре передаётся true, между элементами массива верхнего уровня дополнительно добавляются переводы строк.</p>
       <p>
        <code class="literal">array_to_json('{{1,5},{99,100}}'::int[])</code>
        → <code class="returnvalue">[[1,5],[99,100]]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.9.2.2.3.1.1.1" class="indexterm"></a> <code class="function">json_array</code> ( [<span class="optional"> { <em class="replaceable"><code>выражение_значения</code></em> [<span class="optional"><code class="literal">FORMAT JSON</code></span>] } [<span class="optional">, ...</span>]</span>] [<span class="optional"> { <code class="literal">NULL</code> | <code class="literal">ABSENT</code> } <code class="literal">ON NULL</code></span>] [<span class="optional"><code class="literal">RETURNING</code> <em class="replaceable"><code>тип_данных</code></em> [<span class="optional"><code class="literal">FORMAT JSON</code> [<span class="optional"><code class="literal">ENCODING UTF8</code></span>]</span>]</span>])</p>
        <p class="func_signature"><code class="function">json_array</code> ( [<span class="optional"><em class="replaceable"><code>выражение_запроса</code></em></span>] [<span class="optional"><code class="literal">RETURNING</code> <em class="replaceable"><code>тип_данных</code></em> [<span class="optional"><code class="literal">FORMAT JSON</code> [<span class="optional"><code class="literal">ENCODING UTF8</code></span>]</span>]</span>])</p>
        <p>Создаёт массив JSON либо из набора параметров <em class="replaceable"><code>выражения_значения</code></em>, либо из результатов <em class="replaceable"><code>выражения_запроса</code></em>, которое должно быть запросом SELECT, возвращающим один столбец. С указанием <code class="literal">ABSENT ON NULL</code> значения NULL игнорируются. Такие значения всегда игнорируются, если используется <em class="replaceable"><code>выражение_запроса</code></em>.</p>
        <p>
         <code class="literal">json_array(1,true,json '{"a":null}')</code>
         → <code class="returnvalue">[1, true, {"a":null}]</code>
        </p>
        <p>
         <code class="literal">json_array(SELECT * FROM (VALUES(1),(2)) t)</code>
         → <code class="returnvalue">[1, 2]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.9.2.2.4.1.1.1" class="indexterm"></a> <code class="function">row_to_json</code> ( <code class="type">record</code> [<span class="optional">, <code class="type">boolean</code></span>] ) → <code class="returnvalue">json</code></p>
       <p>Преобразует составное значение SQL в JSON-объект. Эта функция работает так же, как <code class="function">to_json</code>, но если в необязательном логическом параметре передаётся true, между элементами верхнего уровня дополнительно добавляются переводы строк.</p>
       <p>
        <code class="literal">row_to_json(row(1,'foo'))</code>
        → <code class="returnvalue">{"f1":1,"f2":"foo"}</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.9.2.2.5.1.1.1" class="indexterm"></a> <code class="function">json_build_array</code> ( <code class="literal">VARIADIC</code> <code class="type">"any"</code> ) → <code class="returnvalue">json</code></p>
       <p class="func_signature"><a id="id-1.5.8.22.8.9.2.2.5.1.2.1" class="indexterm"></a> <code class="function">jsonb_build_array</code> ( <code class="literal">VARIADIC</code> <code class="type">"any"</code> ) → <code class="returnvalue">jsonb</code></p>
       <p>Формирует JSON-массив (возможно, разнородный) из переменного списка аргументов. Каждый аргумент преобразуется методом <code class="function">to_json</code> или <code class="function">to_jsonb</code>.</p>
       <p>
        <code class="literal">json_build_array(1, 2, 'foo', 4, 5)</code>
        → <code class="returnvalue">[1, 2, "foo", 4, 5]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.9.2.2.6.1.1.1" class="indexterm"></a> <code class="function">json_build_object</code> ( <code class="literal">VARIADIC</code> <code class="type">"any"</code> ) → <code class="returnvalue">json</code></p>
       <p class="func_signature"><a id="id-1.5.8.22.8.9.2.2.6.1.2.1" class="indexterm"></a> <code class="function">jsonb_build_object</code> ( <code class="literal">VARIADIC</code> <code class="type">"any"</code> ) → <code class="returnvalue">jsonb</code></p>
       <p>Формирует JSON-объект из переменного списка аргументов. По соглашению в этом списке перечисляются по очереди ключи и значения. Аргументы, задающие ключи, приводятся к текстовому типу, а аргументы-значения преобразуются методом <code class="function">to_json</code> или <code class="function">to_jsonb</code>.</p>
       <p>
        <code class="literal">json_build_object('foo', 1, 2, row(3,'bar'))</code>
        → <code class="returnvalue">{"foo" : 1, "2" : {"f1":3,"f2":"bar"}}</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.9.2.2.7.1.1.1" class="indexterm"></a> <code class="function">json_object</code> ( [<span class="optional"> { <em class="replaceable"><code>выражение_ключа</code></em> { <code class="literal">VALUE</code> | ':' } <em class="replaceable"><code>выражение_значения</code></em> [<span class="optional"><code class="literal">FORMAT JSON</code> [<span class="optional"><code class="literal">ENCODING UTF8</code></span>]</span>] }[<span class="optional">, ...</span>]</span>] [<span class="optional"> { <code class="literal">NULL</code> | <code class="literal">ABSENT</code> } <code class="literal">ON NULL</code></span>] [<span class="optional"> { <code class="literal">WITH</code> | <code class="literal">WITHOUT</code> } <code class="literal">UNIQUE</code> [<span class="optional"><code class="literal">KEYS</code></span>]</span>] [<span class="optional"><code class="literal">RETURNING</code> <em class="replaceable"><code>тип_данных</code></em> [<span class="optional"><code class="literal">FORMAT JSON</code> [<span class="optional"><code class="literal">ENCODING UTF8</code></span>]</span>]</span>])</p>
        <p>Создаёт объект JSON из всех заданных пар ключ/значение или пустой объект, если ни одна пара не задана. В аргументе <em class="replaceable"><code>выражение_ключа</code></em> передаётся скалярное выражение, определяющее ключ <acronym class="acronym">JSON</acronym>, который преобразуется в тип <code class="type">text</code>. Этот параметр не может быть <code class="literal">NULL</code> и не должен иметь тип, приводимый к <code class="type">json</code>. С указанием <code class="literal">WITH UNIQUE KEYS</code> в <em class="replaceable"><code>выражении_ключа</code></em> не должно быть дублирующихся значений. С указанием <code class="literal">ABSENT ON NULL</code> вся пара пропускается, если <em class="replaceable"><code>выражение_значения</code></em> равно <code class="literal">NULL</code>. Если указать <code class="literal">NULL ON NULL</code> или опустить предложение, ключ определяется со значением <code class="literal">NULL</code>.</p>
        <p>
         <code class="literal">json_object('code' VALUE 'P123', 'title': 'Jaws')</code>
         → <code class="returnvalue">{"code" : "P123", "title" : "Jaws"}</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.9.2.2.8.1.1.1" class="indexterm"></a> <code class="function">json_object</code> ( <code class="type">text[]</code> ) → <code class="returnvalue">json</code></p>
       <p class="func_signature"><a id="id-1.5.8.22.8.9.2.2.8.1.2.1" class="indexterm"></a> <code class="function">jsonb_object</code> ( <code class="type">text[]</code> ) → <code class="returnvalue">jsonb</code></p>
       <p>Формирует объект JSON из текстового массива. Этот массив должен иметь либо одну размерность с чётным числом элементов (в этом случае они воспринимаются как чередующиеся ключи/значения), либо две размерности и при этом каждый внутренний массив содержит ровно два элемента, которые воспринимаются как пара ключ/значение. Все значения преобразуются в строки JSON.</p>
       <p>
        <code class="literal">json_object('{a, 1, b, "def", c, 3.5}')</code>
        → <code class="returnvalue">{"a" : "1", "b" : "def", "c" : "3.5"}</code>
       </p>
        <p><code class="literal">json_object('{{a, 1}, {b, "def"}, {c, 3.5}}')</code>
        → <code class="returnvalue">{"a" : "1", "b" : "def", "c" : "3.5"}</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><code class="function">json_object</code> ( <em class="parameter"><code>keys</code></em> <code class="type">text[]</code>, <em class="parameter"><code>values</code></em> <code class="type">text[]</code> ) → <code class="returnvalue">json</code></p>
       <p class="func_signature"><code class="function">jsonb_object</code> ( <em class="parameter"><code>keys</code></em> <code class="type">text[]</code>, <em class="parameter"><code>values</code></em> <code class="type">text[]</code> ) → <code class="returnvalue">jsonb</code></p>
       <p>Эта форма <code class="function">json_object</code> принимает ключи и значения по парам из двух отдельных текстовых массивов. В остальных отношениях она не отличается от вариации с одним аргументом.</p>
       <p>
        <code class="literal">json_object('{a,b}', '{1,2}')</code>
        → <code class="returnvalue">{"a": "1", "b": "2"}</code>
       </p></td></tr></tbody><tbody class="footnotes"><tr><td colspan="1"><div id="ftn.id-1.5.8.22.8.9.2.2.1.1.3.4" class="footnote"><p><a href="#id-1.5.8.22.8.9.2.2.1.1.3.4" class="para"><sup class="para">[a] </sup></a>Например, в расширении <a class="xref" href="hstore.html" title="F.18. hstore — тип данных hstore для хранения пар ключ-значение">hstore</a> определено преобразование из <code class="type">hstore</code> в <code class="type">json</code>, так что значения <code class="type">hstore</code>, преобразуемые функциями создания JSON, будут представлены в виде объектов JSON, а не как примитивные строковые значения.</p></div></td></tr></tbody></table></div></div><br class="table-break" /><p>В <a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-MISC" title="Таблица 9.48. Функции проверки SQL/JSON">Таблице 9.48</a> описаны средства SQL/JSON для проверки JSON.</p><div class="table" id="FUNCTIONS-SQLJSON-MISC"><p class="title"><strong>Таблица 9.48. Функции проверки SQL/JSON</strong></p><div class="table-contents"><table class="table" summary="Функции проверки SQL/JSON" border="1"><colgroup><col /></colgroup><thead><tr><th class="func_table_entry"><p class="func_signature">Сигнатура функции</p>
       <p>Описание</p>
       <p>Пример(ы)</p></th></tr></thead><tbody><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.22.8.11.2.2.1.1.1.1" class="indexterm"></a>
        <em class="replaceable"><code>выражение</code></em> <code class="literal">IS</code> [<span class="optional"> <code class="literal">NOT</code> </span>] <code class="literal">JSON</code>
        [<span class="optional">{ <code class="literal">VALUE</code> | <code class="literal">SCALAR</code> | <code class="literal">ARRAY</code> | <code class="literal">OBJECT</code> }</span>]
        [<span class="optional">{ <code class="literal">WITH</code> | <code class="literal">WITHOUT</code> } <code class="literal">UNIQUE</code> [<span class="optional"><code class="literal">KEYS</code></span>]</span>]
       </p>
       <p>Этот предикат проверяет, может ли аргумент <em class="replaceable"><code>выражение</code></em> представлять собой JSON (возможно, указанного типа). Если указано <code class="literal">SCALAR</code>, <code class="literal">ARRAY</code> или <code class="literal">OBJECT</code>, проверяется, относится ли JSON к этому конкретному типу. С указанием <code class="literal">WITH UNIQUE KEYS</code> все объекты в <em class="replaceable"><code>выражении</code></em> также проверяются на наличие дубликатов ключей.</p>
       <p>
</p><pre class="programlisting">SELECT js,
  js IS JSON "json?",
  js IS JSON SCALAR "scalar?",
  js IS JSON OBJECT "object?",
  js IS JSON ARRAY "array?"
FROM (VALUES
      ('123'), ('"abc"'), ('{"a": "b"}'), ('[1,2]'),('abc')) foo(js);
     js     | json? | scalar? | object? | array?
------------+-------+---------+---------+--------
 123        | t     | t       | f       | f
 "abc"      | t     | t       | f       | f
 {"a": "b"} | t     | f       | t       | f
 [1,2]      | t     | f       | f       | t
 abc        | f     | f       | f       | f</pre><p>
       </p>
       <p>
</p><pre class="programlisting">SELECT js,
  js IS JSON OBJECT "object?",
  js IS JSON ARRAY "array?",
  js IS JSON ARRAY WITH UNIQUE KEYS "array w. UK?",
  js IS JSON ARRAY WITHOUT UNIQUE KEYS "array w/o UK?"
FROM (VALUES ('[{"a":"1"},
 {"b":"2","b":"3"}]')) foo(js);
-[ RECORD 1 ]-+--------------------
js            | [{"a":"1"},        +
              |  {"b":"2","b":"3"}]
object?       | f
array?        | t
array w. UK?  | f
array w/o UK? | t</pre><p>
      </p></td></tr></tbody></table></div></div><br class="table-break" /><p>В <a class="xref" href="functions-json.html#FUNCTIONS-JSON-PROCESSING-TABLE" title="Таблица 9.49. Функции для обработки JSON">Таблице 9.49</a> показаны функции, предназначенные для работы со значениями <code class="type">json</code> и <code class="type">jsonb</code>.</p><div class="table" id="FUNCTIONS-JSON-PROCESSING-TABLE"><p class="title"><strong>Таблица 9.49. Функции для обработки JSON</strong></p><div class="table-contents"><table class="table" summary="Функции для обработки JSON" border="1"><colgroup><col /></colgroup><thead><tr><th class="func_table_entry"><p class="func_signature">Функция</p>
       <p>Описание</p>
       <p>Пример(ы)</p></th></tr></thead><tbody><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.1.1.1.1" class="indexterm"></a> <code class="function">json_array_elements</code> ( <code class="type">json</code> ) → <code class="returnvalue">setof json</code></p>
       <p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.1.1.2.1" class="indexterm"></a> <code class="function">jsonb_array_elements</code> ( <code class="type">jsonb</code> ) → <code class="returnvalue">setof jsonb</code></p>
       <p>Разворачивает JSON-массив верхнего уровня в набор значений JSON.</p>
       <p>
        <code class="literal">select * from json_array_elements('[1,true, [2,false]]')</code>
        → <code class="returnvalue"></code>
</p><pre class="programlisting">   value
-----------
 1
 true
 [2,false]</pre><p>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.2.1.1.1" class="indexterm"></a> <code class="function">json_array_elements_text</code> ( <code class="type">json</code> ) → <code class="returnvalue">setof text</code></p>
       <p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.2.1.2.1" class="indexterm"></a> <code class="function">jsonb_array_elements_text</code> ( <code class="type">jsonb</code> ) → <code class="returnvalue">setof text</code></p>
       <p>Разворачивает JSON-массив верхнего уровня в набор значений <code class="type">text</code>.</p>
       <p>
        <code class="literal">select * from json_array_elements_text('["foo", "bar"]')</code>
        → <code class="returnvalue"></code>
</p><pre class="programlisting">   value
-----------
 foo
 bar</pre><p>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.3.1.1.1" class="indexterm"></a> <code class="function">json_array_length</code> ( <code class="type">json</code> ) → <code class="returnvalue">integer</code></p>
       <p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.3.1.2.1" class="indexterm"></a> <code class="function">jsonb_array_length</code> ( <code class="type">jsonb</code> ) → <code class="returnvalue">integer</code></p>
       <p>Возвращает число элементов во внешнем JSON-массиве верхнего уровня.</p>
       <p>
        <code class="literal">json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]')</code>
        → <code class="returnvalue">5</code>
       </p>
       <p>
        <code class="literal">jsonb_array_length('[]')</code>
        → <code class="returnvalue">0</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.4.1.1.1" class="indexterm"></a> <code class="function">json_each</code> ( <code class="type">json</code> ) → <code class="returnvalue">setof record</code> ( <em class="parameter"><code>key</code></em> <code class="type">text</code>, <em class="parameter"><code>value</code></em> <code class="type">json</code> )</p>
       <p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.4.1.2.1" class="indexterm"></a> <code class="function">jsonb_each</code> ( <code class="type">jsonb</code> ) → <code class="returnvalue">setof record</code> ( <em class="parameter"><code>key</code></em> <code class="type">text</code>, <em class="parameter"><code>value</code></em> <code class="type">jsonb</code> )</p>
       <p>Разворачивает JSON-объект верхнего уровня в набор пар ключ/значение (key/value).</p>
       <p>
        <code class="literal">select * from json_each('{"a":"foo", "b":"bar"}')</code>
        → <code class="returnvalue"></code>
</p><pre class="programlisting"> key | value
-----+-------
 a   | "foo"
 b   | "bar"</pre><p>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.5.1.1.1" class="indexterm"></a> <code class="function">json_each_text</code> ( <code class="type">json</code> ) → <code class="returnvalue">setof record</code> ( <em class="parameter"><code>key</code></em> <code class="type">text</code>, <em class="parameter"><code>value</code></em> <code class="type">text</code> )</p>
       <p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.5.1.2.1" class="indexterm"></a> <code class="function">jsonb_each_text</code> ( <code class="type">jsonb</code> ) → <code class="returnvalue">setof record</code> ( <em class="parameter"><code>key</code></em> <code class="type">text</code>, <em class="parameter"><code>value</code></em> <code class="type">text</code> )</p>
       <p>Разворачивает JSON-объект верхнего уровня в набор пар ключ/значение (key/value). Возвращаемые значения будут иметь тип <code class="type">text</code>.</p>
       <p>
        <code class="literal">select * from json_each_text('{"a":"foo", "b":"bar"}')</code>
        → <code class="returnvalue"></code>
</p><pre class="programlisting"> key | value
-----+-------
 a   | foo
 b   | bar</pre><p>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.6.1.1.1" class="indexterm"></a> <code class="function">json_extract_path</code> ( <em class="parameter"><code>from_json</code></em> <code class="type">json</code>, <code class="literal">VARIADIC</code> <em class="parameter"><code>path_elems</code></em> <code class="type">text[]</code> ) → <code class="returnvalue">json</code></p>
       <p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.6.1.2.1" class="indexterm"></a> <code class="function">jsonb_extract_path</code> ( <em class="parameter"><code>from_json</code></em> <code class="type">jsonb</code>, <code class="literal">VARIADIC</code> <em class="parameter"><code>path_elems</code></em> <code class="type">text[]</code> ) → <code class="returnvalue">jsonb</code></p>
       <p>Извлекает внутренний JSON-объект по заданному пути. (То же самое делает оператор <code class="literal">#&gt;</code>, но в некоторых случаях может быть удобнее записать путь в виде списка отдельных аргументов.)</p>
       <p>
        <code class="literal">json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}', 'f4', 'f6')</code>
        → <code class="returnvalue">"foo"</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.7.1.1.1" class="indexterm"></a> <code class="function">json_extract_path_text</code> ( <em class="parameter"><code>from_json</code></em> <code class="type">json</code>, <code class="literal">VARIADIC</code> <em class="parameter"><code>path_elems</code></em> <code class="type">text[]</code> ) → <code class="returnvalue">text</code></p>
       <p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.7.1.2.1" class="indexterm"></a> <code class="function">jsonb_extract_path_text</code> ( <em class="parameter"><code>from_json</code></em> <code class="type">jsonb</code>, <code class="literal">VARIADIC</code> <em class="parameter"><code>path_elems</code></em> <code class="type">text[]</code> ) → <code class="returnvalue">text</code></p>
       <p>Извлекает внутренний JSON-объект по заданному пути в виде значения <code class="type">text</code>. (То же самое делает оператор <code class="literal">#&gt;&gt;</code>.)</p>
       <p>
        <code class="literal">json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}', 'f4', 'f6')</code>
        → <code class="returnvalue">foo</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.8.1.1.1" class="indexterm"></a> <code class="function">json_object_keys</code> ( <code class="type">json</code> ) → <code class="returnvalue">setof text</code></p>
       <p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.8.1.2.1" class="indexterm"></a> <code class="function">jsonb_object_keys</code> ( <code class="type">jsonb</code> ) → <code class="returnvalue">setof text</code></p>
       <p>Выдаёт множество ключей в JSON-объекте верхнего уровня.</p>
       <p>
        <code class="literal">select * from json_object_keys('{"f1":"abc","f2":{"f3":"a", "f4":"b"}}')</code>
        → <code class="returnvalue"></code>
</p><pre class="programlisting"> json_object_keys
-----------------
 f1
 f2</pre><p>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.9.1.1.1" class="indexterm"></a> <code class="function">json_populate_record</code> ( <em class="parameter"><code>base</code></em> <code class="type">anyelement</code>, <em class="parameter"><code>from_json</code></em> <code class="type">json</code> ) → <code class="returnvalue">anyelement</code></p>
       <p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.9.1.2.1" class="indexterm"></a> <code class="function">jsonb_populate_record</code> ( <em class="parameter"><code>base</code></em> <code class="type">anyelement</code>, <em class="parameter"><code>from_json</code></em> <code class="type">jsonb</code> ) → <code class="returnvalue">anyelement</code></p>
       <p>Разворачивает JSON-объект верхнего уровня в строку, имеющую составной тип аргумента <em class="parameter"><code>base</code></em>. В JSON-объекте просматриваются поля, имена которых соответствуют именам столбцов выходного типа, и их значения вставляются в эти столбцы результата. (Поля, не соответствующие именам никаких выходных столбцов, пропускаются.) Обычно в <em class="parameter"><code>base</code></em> просто передаётся <code class="literal">NULL</code>, что означает, что выходные столбцы, которым не нашлось соответствие в объекте, получат значения <code class="literal">NULL</code>. Однако если в аргументе <em class="parameter"><code>base</code></em> передаётся не <code class="literal">NULL</code>, то для таких столбцов будут использованы значения из этого аргумента.</p>
       <p>Для преобразования значения JSON в SQL-тип выходного столбца последовательно применяются следующие правила: </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: disc; "><li class="listitem"><p>Значение NULL в JSON всегда преобразуется в SQL NULL.</p></li><li class="listitem"><p>Если выходной столбец имеет тип <code class="type">json</code> или <code class="type">jsonb</code>, значение JSON воспроизводится без изменений.</p></li><li class="listitem"><p>Если выходной столбец имеет составной тип (тип кортежа) и значение JSON является объектом JSON, поля этого объекта преобразуются в столбцы типа выходного кортежа в результате рекурсивного применения этих правил.</p></li><li class="listitem"><p>Подобным образом, если выходной столбец имеет тип-массив и значение JSON представляет массив JSON, элементы данного массива преобразуются в элементы выходного массива в результате рекурсивного применения этих правил.</p></li><li class="listitem"><p>Если же значение JSON является строкой, содержимое этой строки передаётся входной функции преобразования для типа данных целевого столбца.</p></li><li class="listitem"><p>В противном случае функции преобразования для типа данных целевого столбца передаётся обычное текстовое представление значения JSON.</p></li></ul></div>
       <p>В следующем примере значение JSON фиксировано, но обычно такая функция обращается с использованием <code class="literal">LATERAL</code> к столбцу <code class="type">json</code> или <code class="type">jsonb</code> из другой таблицы, фигурирующей в предложении <code class="literal">FROM</code>. Функция <code class="function">json_populate_record</code> в предложении <code class="literal">FROM</code> будет работать эффективно, так как все извлечённые столбцы можно использовать, не выполняя повторные вызовы функции.</p>
       <p>
        <code class="literal">create type subrowtype as (d int, e text);</code>
        <code class="literal">create type myrowtype as (a int, b text[], c subrowtype);</code>
       </p>
       <p>
        <code class="literal">select * from json_populate_record(null::myrowtype, '{"a": 1, "b": ["2", "a b"], "c": {"d": 4, "e": "a b c"}, "x": "foo"}')</code>
        → <code class="returnvalue"></code>
</p><pre class="programlisting"> a |   b       |      c
---+-----------+-------------
 1 | {2,"a b"} | (4,"a b c")</pre><p>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.10.1.1.1" class="indexterm"></a> <code class="function">json_populate_recordset</code> ( <em class="parameter"><code>base</code></em> <code class="type">anyelement</code>, <em class="parameter"><code>from_json</code></em> <code class="type">json</code> ) → <code class="returnvalue">setof anyelement</code></p>
       <p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.10.1.2.1" class="indexterm"></a> <code class="function">jsonb_populate_recordset</code> ( <em class="parameter"><code>base</code></em> <code class="type">anyelement</code>, <em class="parameter"><code>from_json</code></em> <code class="type">jsonb</code> ) → <code class="returnvalue">setof anyelement</code></p>
       <p>Разворачивает JSON-массив верхнего уровня с объектами в набор строк, имеющих составной тип аргумента <em class="parameter"><code>base</code></em>. Каждый элемент JSON-массива обрабатывается так же, как было описано выше для <code class="function">json[b]_populate_record</code>.</p>
       <p>
        <code class="literal">create type twoints as (a int, b int);</code>
       </p>
       <p>
        <code class="literal">select * from json_populate_recordset(null::twoints, '[{"a":1,"b":2}, {"a":3,"b":4}]')</code>
        → <code class="returnvalue"></code>
</p><pre class="programlisting"> a | b
---+---
 1 | 2
 3 | 4</pre><p>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.11.1.1.1" class="indexterm"></a> <code class="function">json_to_record</code> ( <code class="type">json</code> ) → <code class="returnvalue">record</code></p>
       <p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.11.1.2.1" class="indexterm"></a> <code class="function">jsonb_to_record</code> ( <code class="type">jsonb</code> ) → <code class="returnvalue">record</code></p>
       <p>Разворачивает JSON-объект верхнего уровня в строку, имеющую составной тип, определённый в предложении <code class="literal">AS</code>. (Как и со всеми функциями, возвращающими значение <code class="type">record</code>, вызывающий запрос должен явно определять структуру записи в <code class="literal">AS</code>.) Выходная запись заполняется полями JSON-объекта так же, как было описано выше для <code class="function">json[b]_populate_record</code>. Так как этой функции не передаётся запись, столбцы, для которых не находится соответствие, всегда получают значения <code class="literal">NULL</code>.</p>
       <p>
        <code class="literal">create type myrowtype as (a int, b text);</code>
       </p>
       <p>
        <code class="literal">select * from json_to_record('{"a":1,"b":[1,2,3],"c":[1,2,3],"e":"bar","r": {"a": 123, "b": "a b c"}}') as x(a int, b text, c int[], d text, r myrowtype)</code>
        → <code class="returnvalue"></code>
</p><pre class="programlisting"> a |    b    |    c    | d |       r
---+---------+---------+---+---------------
 1 | [1,2,3] | {1,2,3} |   | (123,"a b c")</pre><p>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.12.1.1.1" class="indexterm"></a> <code class="function">json_to_recordset</code> ( <code class="type">json</code> ) → <code class="returnvalue">setof record</code></p>
       <p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.12.1.2.1" class="indexterm"></a> <code class="function">jsonb_to_recordset</code> ( <code class="type">jsonb</code> ) → <code class="returnvalue">setof record</code></p>
       <p>Разворачивает JSON-массив верхнего уровня с объектами в набор строк, имеющих составной тип, определённый в предложении <code class="literal">AS</code>. (Как и со всеми функциями, возвращающими значение <code class="type">record</code>, вызывающий запрос должен явно определять структуру записи в <code class="literal">AS</code>.) Каждый элемент JSON-массива обрабатывается так же, как было описано выше для <code class="function">json[b]_populate_record</code>.</p>
       <p>
        <code class="literal">select * from json_to_recordset('[{"a":1,"b":"foo"}, {"a":"2","c":"bar"}]') as x(a int, b text)</code>
        → <code class="returnvalue"></code>
</p><pre class="programlisting"> a |  b
---+-----
 1 | foo
 2 |</pre><p>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.13.1.1.1" class="indexterm"></a> <code class="function">jsonb_set</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">text[]</code>, <em class="parameter"><code>new_value</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>create_if_missing</code></em> <code class="type">boolean</code></span>] ) → <code class="returnvalue">jsonb</code></p>
       <p>Возвращает объект <em class="parameter"><code>target</code></em>, в котором элемент, на который указывает путь <em class="parameter"><code>path</code></em>, заменяется значением <em class="parameter"><code>new_value</code></em> либо значение <em class="parameter"><code>new_value</code></em> добавляется, когда параметр <em class="parameter"><code>create_if_missing</code></em> равен true (это значение по умолчанию) и элемент, на который указывает <em class="parameter"><code>path</code></em>, не существует. Чтобы это изменение произошло, все предыдущие элементы, на которые указывает путь, должны существовать. В противном случае <em class="parameter"><code>target</code></em> возвращается без изменений. Как и с операторами, принимающими пути, отрицательные целые числа, фигурирующие в <em class="parameter"><code>path</code></em>, отсчитывают элементы с конца JSON-массива. Если на последнем шаге пути указывается индекс, выходящий за границы массива, и параметр <em class="parameter"><code>create_if_missing</code></em> равен true, новое значение добавляется в начало массива, когда индекс отрицательный, или в конец, когда он положительный.</p>
       <p>
        <code class="literal">jsonb_set('[{"f1":1,"f2":null},2,null,3]', '{0,f1}', '[2,3,4]', false)</code>
        → <code class="returnvalue">[{"f1": [2, 3, 4], "f2": null}, 2, null, 3]</code>
       </p>
       <p>
        <code class="literal">jsonb_set('[{"f1":1,"f2":null},2]', '{0,f3}', '[2,3,4]')</code>
        → <code class="returnvalue">[{"f1": 1, "f2": null, "f3": [2, 3, 4]}, 2]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.14.1.1.1" class="indexterm"></a> <code class="function">jsonb_set_lax</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">text[]</code>, <em class="parameter"><code>new_value</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>create_if_missing</code></em> <code class="type">boolean</code> [<span class="optional">, <em class="parameter"><code>null_value_treatment</code></em> <code class="type">text</code></span>]</span>] ) → <code class="returnvalue">jsonb</code></p>
       <p>Если значение <em class="parameter"><code>new_value</code></em> отлично от <code class="literal">NULL</code>, эта функция действует так же, как и <code class="literal">jsonb_set</code>. В противном случае она действует согласно значению <em class="parameter"><code>null_value_treatment</code></em>, которое может принимать значение <code class="literal">'raise_exception'</code>, <code class="literal">'use_json_null'</code>, <code class="literal">'delete_key'</code> или <code class="literal">'return_target'</code>. Значение по умолчанию: <code class="literal">'use_json_null'</code>.</p>
       <p>
        <code class="literal">jsonb_set_lax('[{"f1":1,"f2":null},2,null,3]', '{0,f1}', null)</code>
        → <code class="returnvalue">[{"f1": null, "f2": null}, 2, null, 3]</code>
       </p>
       <p>
        <code class="literal">jsonb_set_lax('[{"f1":99,"f2":null},2]', '{0,f3}', null, true, 'return_target')</code>
        → <code class="returnvalue">[{"f1": 99, "f2": null}, 2]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.15.1.1.1" class="indexterm"></a> <code class="function">jsonb_insert</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">text[]</code>, <em class="parameter"><code>new_value</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>insert_after</code></em> <code class="type">boolean</code></span>] ) → <code class="returnvalue">jsonb</code></p>
       <p>Возвращает объект <em class="parameter"><code>target</code></em> с вставленном в него значением <em class="parameter"><code>new_value</code></em>. Когда элемент, на который указывает путь <em class="parameter"><code>path</code></em>, является элементом массива, <em class="parameter"><code>new_value</code></em> вставляется перед этим элементом, если параметр <em class="parameter"><code>insert_after</code></em> равен false (по умолчанию), либо после него, если <em class="parameter"><code>insert_after</code></em> равен true. Когда элемент, на который указывает <em class="parameter"><code>path</code></em>, является полем объекта, <em class="parameter"><code>new_value</code></em> будет вставлено только если у объекта ещё нет такого ключа. Чтобы это изменение произошло, все предыдущие элементы, на которые указывает путь, должны существовать. В противном случае <em class="parameter"><code>target</code></em> возвращается без изменений. Как и с операторами, принимающими пути, отрицательные целые числа, фигурирующие в <em class="parameter"><code>path</code></em>, отсчитывают элементы с конца JSON-массива. Если на последнем шаге пути указывается индекс, выходящий за границы массива, новое значение добавляется в начало массива, когда индекс отрицательный, или в конец, когда он положительный.</p>
       <p>
        <code class="literal">jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"')</code>
        → <code class="returnvalue">{"a": [0, "new_value", 1, 2]}</code>
       </p>
       <p>
        <code class="literal">jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"', true)</code>
        → <code class="returnvalue">{"a": [0, 1, "new_value", 2]}</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.16.1.1.1" class="indexterm"></a> <code class="function">json_strip_nulls</code> ( <code class="type">json</code> ) → <code class="returnvalue">json</code></p>
       <p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.16.1.2.1" class="indexterm"></a> <code class="function">jsonb_strip_nulls</code> ( <code class="type">jsonb</code> ) → <code class="returnvalue">jsonb</code></p>
       <p>Удаляет из данного значения JSON все поля объектов, имеющие значения null, на всех уровнях вложенности. Значения null, не относящиеся к полям объектов, сохраняются без изменений.</p>
       <p>
        <code class="literal">json_strip_nulls('[{"f1":1, "f2":null}, 2, null, 3]')</code>
        → <code class="returnvalue">[{"f1":1},2,null,3]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.17.1.1.1" class="indexterm"></a> <code class="function">jsonb_path_exists</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">jsonpath</code> [<span class="optional">, <em class="parameter"><code>vars</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>silent</code></em> <code class="type">boolean</code></span>]</span>] ) → <code class="returnvalue">boolean</code></p>
       <p>Проверяет, есть ли в заданном значении JSON какой-либо элемент, соответствующий пути JSON. В случае присутствия аргумента <em class="parameter"><code>vars</code></em>, он должен содержать JSON-объект, поля которого будут подставляться в выражение <code class="type">jsonpath</code> под их именами. Если передаётся аргумент <em class="parameter"><code>silent</code></em> и он равен <code class="literal">true</code>, функция подавляет те же ошибки, что и операторы <code class="literal">@?</code> и <code class="literal">@@</code>.</p>
       <p>
        <code class="literal">jsonb_path_exists('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ &gt;= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</code>
        → <code class="returnvalue">t</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.18.1.1.1" class="indexterm"></a> <code class="function">jsonb_path_match</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">jsonpath</code> [<span class="optional">, <em class="parameter"><code>vars</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>silent</code></em> <code class="type">boolean</code></span>]</span>] ) → <code class="returnvalue">boolean</code></p>
       <p>Возвращает результат проверки предиката пути JSON для заданного значения JSON. При этом учитывается только первый элемент результата. Если результат не является логическим, возвращается <code class="literal">NULL</code>. Дополнительные аргументы <em class="parameter"><code>vars</code></em> и <em class="parameter"><code>silent</code></em> действуют так же, как и для <code class="function">jsonb_path_exists</code>.</p>
       <p>
        <code class="literal">jsonb_path_match('{"a":[1,2,3,4,5]}', 'exists($.a[*] ? (@ &gt;= $min &amp;&amp; @ &lt;= $max))', '{"min":2, "max":4}')</code>
        → <code class="returnvalue">t</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.19.1.1.1" class="indexterm"></a> <code class="function">jsonb_path_query</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">jsonpath</code> [<span class="optional">, <em class="parameter"><code>vars</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>silent</code></em> <code class="type">boolean</code></span>]</span>] ) → <code class="returnvalue">setof jsonb</code></p>
       <p>Возвращает все элементы JSON, полученные по указанному пути для заданного значения JSON. Дополнительные аргументы <em class="parameter"><code>vars</code></em> и <em class="parameter"><code>silent</code></em> действуют так же, как и для <code class="function">jsonb_path_exists</code>.</p>
       <p>
        <code class="literal">select * from jsonb_path_query('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ &gt;= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</code>
        → <code class="returnvalue"></code>
</p><pre class="programlisting"> jsonb_path_query
------------------
 2
 3
 4</pre><p>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.20.1.1.1" class="indexterm"></a> <code class="function">jsonb_path_query_array</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">jsonpath</code> [<span class="optional">, <em class="parameter"><code>vars</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>silent</code></em> <code class="type">boolean</code></span>]</span>] ) → <code class="returnvalue">jsonb</code></p>
       <p>Возвращает все элементы JSON, полученные по указанному пути для заданного значения JSON, в виде JSON-массива. Дополнительные аргументы <em class="parameter"><code>vars</code></em> и <em class="parameter"><code>silent</code></em> действуют так же, как и для <code class="function">jsonb_path_exists</code>.</p>
       <p>
        <code class="literal">jsonb_path_query_array('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ &gt;= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</code>
        → <code class="returnvalue">[2, 3, 4]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.21.1.1.1" class="indexterm"></a> <code class="function">jsonb_path_query_first</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">jsonpath</code> [<span class="optional">, <em class="parameter"><code>vars</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>silent</code></em> <code class="type">boolean</code></span>]</span>] ) → <code class="returnvalue">jsonb</code></p>
       <p>Возвращает первый элемент JSON, полученный по указанному пути для заданного значения JSON, либо NULL, если этому пути не соответствуют никакие элементы. Дополнительные аргументы <em class="parameter"><code>vars</code></em> и <em class="parameter"><code>silent</code></em> действуют так же, как и для <code class="function">jsonb_path_exists</code>.</p>
       <p>
        <code class="literal">jsonb_path_query_first('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ &gt;= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</code>
        → <code class="returnvalue">2</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.22.1.1.1" class="indexterm"></a> <code class="function">jsonb_path_exists_tz</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">jsonpath</code> [<span class="optional">, <em class="parameter"><code>vars</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>silent</code></em> <code class="type">boolean</code></span>]</span>] ) → <code class="returnvalue">boolean</code></p>
       <p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.22.1.2.1" class="indexterm"></a> <code class="function">jsonb_path_match_tz</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">jsonpath</code> [<span class="optional">, <em class="parameter"><code>vars</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>silent</code></em> <code class="type">boolean</code></span>]</span>] ) → <code class="returnvalue">boolean</code></p>
       <p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.22.1.3.1" class="indexterm"></a> <code class="function">jsonb_path_query_tz</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">jsonpath</code> [<span class="optional">, <em class="parameter"><code>vars</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>silent</code></em> <code class="type">boolean</code></span>]</span>] ) → <code class="returnvalue">setof jsonb</code></p>
       <p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.22.1.4.1" class="indexterm"></a> <code class="function">jsonb_path_query_array_tz</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">jsonpath</code> [<span class="optional">, <em class="parameter"><code>vars</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>silent</code></em> <code class="type">boolean</code></span>]</span>] ) → <code class="returnvalue">jsonb</code></p>
       <p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.22.1.5.1" class="indexterm"></a> <code class="function">jsonb_path_query_first_tz</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">jsonpath</code> [<span class="optional">, <em class="parameter"><code>vars</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>silent</code></em> <code class="type">boolean</code></span>]</span>] ) → <code class="returnvalue">jsonb</code></p>
       <p>Эти функции работают подобно их двойникам без суффикса <code class="literal">_tz</code>, описанным выше, за исключением того, что данные функции поддерживают сравнение значений с датой/временем, для которых должны учитываться часовые пояса. В следующем примере дата без указания времени <code class="literal">2015-08-02</code> должна преобразоваться в дату/время с часовым поясом, поэтому результат будет зависеть от текущего значения <a class="xref" href="runtime-config-client.html#GUC-TIMEZONE">TimeZone</a>. Вследствие этой зависимости данные функции помечены как стабильные (не постоянные), и поэтому их нельзя использовать в индексах. Их двойники являются постоянными и могут использоваться в индексах, но при попытке выполнить такое сравнение они будут выдавать ошибку.</p>
       <p>
        <code class="literal">jsonb_path_exists_tz('["2015-08-01 12:00:00 -05"]', '$[*] ? (@.datetime() &lt; "2015-08-02".datetime())')</code>
        → <code class="returnvalue">t</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.23.1.1.1" class="indexterm"></a> <code class="function">jsonb_pretty</code> ( <code class="type">jsonb</code> ) → <code class="returnvalue">text</code></p>
       <p>Преобразует данное значение JSON в визуально улучшенное текстовое представление с отступами.</p>
       <p>
        <code class="literal">jsonb_pretty('[{"f1":1,"f2":null}, 2]')</code>
        → <code class="returnvalue"></code>
</p><pre class="programlisting">[
    {
        "f1": 1,
        "f2": null
    },
    2
]</pre><p>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.24.1.1.1" class="indexterm"></a> <code class="function">json_typeof</code> ( <code class="type">json</code> ) → <code class="returnvalue">text</code></p>
       <p class="func_signature"><a id="id-1.5.8.22.8.13.2.2.24.1.2.1" class="indexterm"></a> <code class="function">jsonb_typeof</code> ( <code class="type">jsonb</code> ) → <code class="returnvalue">text</code></p>
       <p>Возвращает тип значения на верхнем уровне JSON в виде текстовой строки. Возможные типы: <code class="literal">object</code>, <code class="literal">array</code>, <code class="literal">string</code>, <code class="literal">number</code>, <code class="literal">boolean</code> и <code class="literal">null</code>. (Не следует путать эту строку <code class="literal">null</code> с SQL-значением NULL; см. примеры.)</p>
       <p>
        <code class="literal">json_typeof('-123.4')</code>
        → <code class="returnvalue">number</code>
       </p>
       <p>
        <code class="literal">json_typeof('null'::json)</code>
        → <code class="returnvalue">null</code>
       </p>
       <p>
        <code class="literal">json_typeof(NULL::json) IS NULL</code>
        → <code class="returnvalue">t</code>
       </p></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect2" id="FUNCTIONS-SQLJSON-PATH"><div class="titlepage"><div><div><h3 class="title">9.16.2. Язык путей SQL/JSON <a href="#FUNCTIONS-SQLJSON-PATH" class="id_link">#</a></h3></div></div></div><a id="id-1.5.8.22.9.2" class="indexterm"></a><p>Выражения путей SQL/JSON определяют элементы, извлекаемые из данных JSON, подобно тому, как выражения XPath позволяют обращаться из SQL к XML. В <span class="productname">PostgreSQL</span> выражения путей представляются в виде типа данных <code class="type">jsonpath</code> и могут использовать любые элементы, описанные в <a class="xref" href="datatype-json.html#DATATYPE-JSONPATH" title="8.14.7. Тип jsonpath">Подразделе 8.14.7</a>.</p><p>Операторы и функции запросов к JSON передают поступившее им выражение <em class="firstterm">обработчику путей</em> для вычисления. Если выражению соответствуют фигурирующие в запросе данные JSON, в результате выдаётся соответствующий элемент JSON или набор элементов. Выражения путей записываются на языке путей SQL/JSON и могут включать сложные арифметические выражения и функции.</p><p>Выражение пути состоит из последовательности элементов, допустимых для типа <code class="type">jsonpath</code>. Обычно оно вычисляется слева направо, но при необходимости порядок операций можно изменить, добавив скобки. В случае успешного вычисления выдаётся последовательность элементов JSON, и результат вычисления возвращается в функцию JSON-запроса, которая завершает обработку выражения.</p><p>Для обращения к поступившему в запрос значению JSON (<em class="firstterm">элементу контекста</em>) в выражении пути используется переменная <code class="literal">$</code>. Затем могут следовать один или более <a class="link" href="datatype-json.html#TYPE-JSONPATH-ACCESSORS" title="Таблица 8.25. Операторы обращения в jsonpath">операторов обращения</a>, которые, опускаясь в структуре JSON с одного уровня на другой, извлекают элементы, вложенные в текущий элемент контекста. При этом каждый последующий оператор имеет дело с результатом вычисления, полученным на предыдущем шаге.</p><p>Например, предположим, что у вас есть данные JSON, полученные от GPS-трекера, которые вы хотели бы проанализировать: </p><pre class="programlisting">{
  "track": {
    "segments": [
      {
        "location":   [ 47.763, 13.4034 ],
        "start time": "2018-10-14 10:05:14",
        "HR": 73
      },
      {
        "location":   [ 47.706, 13.2635 ],
        "start time": "2018-10-14 10:39:21",
        "HR": 135
      }
    ]
  }
}</pre><p>Чтобы получить имеющиеся сегменты треков, воспользуйтесь оператором обращения <code class="literal">.<em class="replaceable"><code>ключ</code></em></code>, который позволяет погрузиться внутрь JSON-объектов: </p><pre class="programlisting">$.track.segments</pre><p>Для получения содержимого массива обычно используется оператор <code class="literal">[*]</code>. Например, следующий путь выдаст координаты концов всех имеющихся сегментов треков: </p><pre class="programlisting">$.track.segments[*].location</pre><p>Чтобы получить координаты только первого сегмента, можно задать соответствующий индекс в операторе обращения <code class="literal">[]</code>. Заметьте, что индексы в JSON-массивах отсчитываются с 0: </p><pre class="programlisting">$.track.segments[0].location</pre><p>Результат каждого шага вычисления выражения может быть обработан операторами и методами <code class="type">jsonpath</code>, перечисленными в <a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-PATH-OPERATORS" title="9.16.2.2. Операторы и методы SQL/JSON">Подразделе 9.16.2.2</a>. Перед именем метода должна стоять точка. Например, так можно получить размер массива: </p><pre class="programlisting">$.track.segments.size()</pre><p> Другие примеры использования операторов и методов <code class="type">jsonpath</code> в выражениях пути приведены ниже в <a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-PATH-OPERATORS" title="9.16.2.2. Операторы и методы SQL/JSON">Подразделе 9.16.2.2</a>.</p><p>Определяя путь, также можно использовать <em class="firstterm">выражения фильтра</em>, работающие подобно предложению <code class="literal">WHERE</code> в SQL. Выражение фильтра начинается со знака вопроса и содержит условие в скобках: </p><pre class="programlisting">? (<em class="replaceable"><code>условие</code></em>)</pre><p>Выражения фильтра указываются сразу после шага вычисления пути, к которому они должны применяться. Результаты шага проходят через фильтр, и на выходе остаются только те элементы, которые удовлетворяют заданному условию. В SQL/JSON действует троичная логика, то есть результатом выражения может быть <code class="literal">true</code>, <code class="literal">false</code> или <code class="literal">unknown</code> (неизвестность). Значение <code class="literal">unknown</code> играет ту же роль, что и <code class="literal">NULL</code> в SQL, и может быть проверено предикатом <code class="literal">is unknown</code>. На последующих шагах вычисления пути будут обрабатываться только те элементы, для которых выражение фильтра выдало <code class="literal">true</code>.</p><p>Функции и операторы, которые можно использовать в выражениях фильтра, перечислены в <a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-FILTER-EX-TABLE" title="Таблица 9.51. Элементы выражения фильтра jsonpath">Таблице 9.51</a>. Переменная <code class="literal">@</code> в выражении фильтра представляет фильтруемое значение (результат предыдущего шага в пути). Для получения внутренних элементов этого значения вы можете добавить после <code class="literal">@</code> операторы обращения.</p><p>Например, предположим, что вы хотите получить все показатели пульса, превышающие 130. Это можно сделать с помощью следующего выражения: </p><pre class="programlisting">$.track.segments[*].HR ? (@ &gt; 130)</pre><p>Чтобы получить в результате время начала соответствующих сегментов, вы должны отфильтровать ненужные сегменты, а затем выбрать время, так что фильтр будет применяться к предыдущему шагу и путь окажется другим: </p><pre class="programlisting">$.track.segments[*] ? (@.HR &gt; 130)."start time"</pre><p>Можно также использовать несколько выражений фильтра по очереди, когда это требуется. Например, следующее выражение выбирает время начала всех сегментов с определёнными координатами и высоким показателем пульса: </p><pre class="programlisting">$.track.segments[*] ? (@.location[1] &lt; 13.4) ? (@.HR &gt; 130)."start time"</pre><p>Также возможно использовать фильтры на разных уровнях вложенности. В следующем примере сначала сегменты фильтруются по координатам, а затем для подходящих сегментов, если они находятся, выбираются значения высокого пульса: </p><pre class="programlisting">$.track.segments[*] ? (@.location[1] &lt; 13.4).HR ? (@ &gt; 130)</pre><p>Можно также вкладывать выражения фильтра одно в другое: </p><pre class="programlisting">$.track ? (exists(@.segments[*] ? (@.HR &gt; 130))).segments.size()</pre><p> Данное выражение возвращает количество сегментов в треке, если он содержит сегменты с высокими показателями пульса, или пустую последовательность, если таких сегментов нет.</p><p>Реализация языка путей SQL/JSON в <span class="productname">PostgreSQL</span> имеет следующие отличия от стандарта SQL/JSON:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Выражение пути может быть булевым предикатом, хотя стандарт SQL/JSON допускает предикаты только в фильтрах. Это необходимо для реализации оператора <code class="literal">@@</code>. Например, следующее выражение <code class="type">jsonpath</code> допускается в <span class="productname">PostgreSQL</span>: </p><pre class="programlisting">$.track.segments[*].HR &lt; 70</pre></li><li class="listitem"><p>Есть небольшие различия в интерпретации шаблонов регулярных выражений, используемых в фильтрах <code class="literal">like_regex</code>; имеющиеся особенности описаны в <a class="xref" href="functions-json.html#JSONPATH-REGULAR-EXPRESSIONS" title="9.16.2.3. Регулярные выражения SQL/JSON">Подразделе 9.16.2.3</a>.</p></li></ul></div><div class="sect3" id="STRICT-AND-LAX-MODES"><div class="titlepage"><div><div><h4 class="title">9.16.2.1. Строгий и нестрогий режимы <a href="#STRICT-AND-LAX-MODES" class="id_link">#</a></h4></div></div></div><p>Когда вы обращаетесь к данным JSON, выражение пути может не соответствовать фактической структуре данных JSON. Попытка обратиться к несуществующему члену объекта или элементу массива приводит к ошибке структурного типа. Для обработки такого рода ошибок в выражениях путей SQL/JSON предусмотрены два режима:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>lax (по умолчанию) — нестрогий режим, в котором обработчик путей неявно адаптирует обрабатываемые данные к указанному пути. Любые возникающие структурные ошибки подавляются и заменяются пустыми последовательностями SQL/JSON.</p></li><li class="listitem"><p>strict — строгий режим, в котором структурные ошибки выдаются как есть.</p></li></ul></div><p>Нестрогий режим упрощает сопоставление структуры документа JSON с выражением пути в случаях, когда данные JSON не соответствуют ожидаемой схеме. Если операнд не удовлетворяет требованиям определённой операции, он может перед выполнением этой операции автоматически оборачиваться в массив SQL/JSON или наоборот, разворачиваться так, чтобы его элементы образовали последовательность SQL/JSON. Помимо этого, в нестрогом режиме операторы сравнения автоматически разворачивают свои операнды, что позволяет легко сравнивать массивы SQL/JSON. Массив с одним элементом в таком режиме считается равным своему элементу. Автоматическое разворачивание не выполняется только в следующих случаях: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>В выражении пути фигурируют методы <code class="literal">size()</code> и <code class="literal">type()</code>, возвращающие соответственно число элементов в массиве и тип.</p></li><li class="listitem"><p>Обрабатываемые данные JSON содержат вложенные массивы. В этом случае разворачивается только массив верхнего уровня, а внутренние массивы остаются без изменений. Таким образом, неявное разворачивание может опускаться на каждом шаге вычисления пути только на один уровень.</p></li></ul></div><p>Например, обрабатывая данные GPS, показанные выше, в нестрогом режиме можно не обращать внимание на то, что в них содержится массив сегментов: </p><pre class="programlisting">lax $.track.segments.location</pre><p>В строгом режиме указанный путь должен в точности соответствовать структуре обрабатываемого документа JSON и выдавать элемент SQL/JSON, поэтому использование такого выражения пути приведёт к ошибке. Чтобы получить такой же результат, как в нестрогом режиме, необходимо явно развернуть массив <code class="literal">segments</code>: </p><pre class="programlisting">strict $.track.segments[*].location</pre><p>Оператор обращения <code class="literal">.**</code> в нестрогом режиме может выдавать несколько неожиданные результаты. Например, следующий запрос выберет каждое значение <code class="literal">HR</code> дважды: </p><pre class="programlisting">lax $.**.HR</pre><p> Это происходит потому, что оператор <code class="literal">.**</code> выбирает и массив <code class="literal">segments</code>, и каждый из его элементов, а обращение <code class="literal">.HR</code> в нестрогом режиме автоматически разворачивает массивы. Во избежание подобных сюрпризов мы рекомендуем использовать оператор обращения <code class="literal">.**</code> только в строгом режиме. Следующий запрос выбирает каждое значение <code class="literal">HR</code> в единственном экземпляре: </p><pre class="programlisting">strict $.**.HR</pre></div><div class="sect3" id="FUNCTIONS-SQLJSON-PATH-OPERATORS"><div class="titlepage"><div><div><h4 class="title">9.16.2.2. Операторы и методы SQL/JSON <a href="#FUNCTIONS-SQLJSON-PATH-OPERATORS" class="id_link">#</a></h4></div></div></div><p>В <a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-OP-TABLE" title="Таблица 9.50. Операторы и методы jsonpath">Таблице 9.50</a> показаны операторы и методы, поддерживаемые в значениях <code class="type">jsonpath</code>. Заметьте, что унарные операторы и методы могут применяться к множеству значений, полученных на предыдущем шаге пути, тогда как бинарные операторы (сложение и т. п.) применяются только к отдельным значениям.</p><div class="table" id="FUNCTIONS-SQLJSON-OP-TABLE"><p class="title"><strong>Таблица 9.50. Операторы и методы <code class="type">jsonpath</code></strong></p><div class="table-contents"><table class="table" summary="Операторы и методы jsonpath" border="1"><colgroup><col /></colgroup><thead><tr><th class="func_table_entry"><p class="func_signature">Оператор/Метод</p>
       <p>Описание</p>
       <p>Пример(ы)</p></th></tr></thead><tbody><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>число</code></em> <code class="literal">+</code> <em class="replaceable"><code>число</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>число</code></em></code>
       </p>
       <p>Сложение</p>
       <p>
        <code class="literal">jsonb_path_query('[2]', '$[0] + 3')</code>
        → <code class="returnvalue">5</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="literal">+</code> <em class="replaceable"><code>число</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>число</code></em></code>
       </p>
       <p>Унарный плюс (нет операции); в отличие от сложения, он может итерационно применяться к множеству значений</p>
       <p>
        <code class="literal">jsonb_path_query_array('{"x": [2,3,4]}', '+ $.x')</code>
        → <code class="returnvalue">[2, 3, 4]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>число</code></em> <code class="literal">-</code> <em class="replaceable"><code>число</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>число</code></em></code>
       </p>
       <p>Вычитание</p>
       <p>
        <code class="literal">jsonb_path_query('[2]', '7 - $[0]')</code>
        → <code class="returnvalue">5</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="literal">-</code> <em class="replaceable"><code>число</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>число</code></em></code>
       </p>
       <p>Смена знака; в отличие от вычитания, этот оператор может итерационно применяться к множеству значений</p>
       <p>
        <code class="literal">jsonb_path_query_array('{"x": [2,3,4]}', '- $.x')</code>
        → <code class="returnvalue">[-2, -3, -4]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>число</code></em> <code class="literal">*</code> <em class="replaceable"><code>число</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>число</code></em></code>
       </p>
       <p>Умножение</p>
       <p>
        <code class="literal">jsonb_path_query('[4]', '2 * $[0]')</code>
        → <code class="returnvalue">8</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>число</code></em> <code class="literal">/</code> <em class="replaceable"><code>число</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>число</code></em></code>
       </p>
       <p>Деление</p>
       <p>
        <code class="literal">jsonb_path_query('[8.5]', '$[0] / 2')</code>
        → <code class="returnvalue">4.2500000000000000</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>число</code></em> <code class="literal">%</code> <em class="replaceable"><code>число</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>число</code></em></code>
       </p>
       <p>Остаток от деления</p>
       <p>
        <code class="literal">jsonb_path_query('[32]', '$[0] % 10')</code>
        → <code class="returnvalue">2</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>значение</code></em> <code class="literal">.</code> <code class="literal">type()</code>
        → <code class="returnvalue"><em class="replaceable"><code>строка</code></em></code>
       </p>
       <p>Тип элемента JSON (см. <code class="function">json_typeof</code>)</p>
       <p>
        <code class="literal">jsonb_path_query_array('[1, "2", {}]', '$[*].type()')</code>
        → <code class="returnvalue">["number", "string", "object"]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>значение</code></em> <code class="literal">.</code> <code class="literal">size()</code>
        → <code class="returnvalue"><em class="replaceable"><code>число</code></em></code>
       </p>
       <p>Размер элемента JSON (число элементов в массиве либо 1, если это не массив)</p>
       <p>
        <code class="literal">jsonb_path_query('{"m": [11, 15]}', '$.m.size()')</code>
        → <code class="returnvalue">2</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>значение</code></em> <code class="literal">.</code> <code class="literal">double()</code>
        → <code class="returnvalue"><em class="replaceable"><code>число</code></em></code>
       </p>
       <p>Приблизительное число с плавающей точкой, преобразованное из строки или числа JSON</p>
       <p>
        <code class="literal">jsonb_path_query('{"len": "1.9"}', '$.len.double() * 2')</code>
        → <code class="returnvalue">3.8</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>число</code></em> <code class="literal">.</code> <code class="literal">ceiling()</code>
        → <code class="returnvalue"><em class="replaceable"><code>число</code></em></code>
       </p>
       <p>Ближайшее целое, большее или равное заданному числу</p>
       <p>
        <code class="literal">jsonb_path_query('{"h": 1.3}', '$.h.ceiling()')</code>
        → <code class="returnvalue">2</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>число</code></em> <code class="literal">.</code> <code class="literal">floor()</code>
        → <code class="returnvalue"><em class="replaceable"><code>число</code></em></code>
       </p>
       <p>Ближайшее целое, меньшее или равное заданному числу</p>
       <p>
        <code class="literal">jsonb_path_query('{"h": 1.7}', '$.h.floor()')</code>
        → <code class="returnvalue">1</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>число</code></em> <code class="literal">.</code> <code class="literal">abs()</code>
        → <code class="returnvalue"><em class="replaceable"><code>число</code></em></code>
       </p>
       <p>Модуль заданного числа (абсолютное значение)</p>
       <p>
        <code class="literal">jsonb_path_query('{"z": -0.3}', '$.z.abs()')</code>
        → <code class="returnvalue">0.3</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><em class="replaceable"><code>строка</code></em> <code class="literal">.</code> <code class="literal">datetime()</code> → <code class="returnvalue"><em class="replaceable"><code>тип_даты_времени</code></em></code> (см. примечание)</p>
       <p>Значение даты/времени, полученное из строки</p>
       <p>
        <code class="literal">jsonb_path_query('["2015-8-1", "2015-08-12"]', '$[*] ? (@.datetime() &lt; "2015-08-2".datetime())')</code>
        → <code class="returnvalue">"2015-8-1"</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature"><em class="replaceable"><code>string</code></em> <code class="literal">.</code> <code class="literal">datetime(<em class="replaceable"><code>шаблон</code></em>)</code> → <code class="returnvalue"><em class="replaceable"><code>тип_даты_времени</code></em></code> (см. примечание)</p>
       <p>Значение даты/времени, преобразованное из строки по шаблону <code class="function">to_timestamp</code></p>
       <p>
        <code class="literal">jsonb_path_query_array('["12:30", "18:40"]', '$[*].datetime("HH24:MI")')</code>
        → <code class="returnvalue">["12:30:00", "18:40:00"]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>объект</code></em> <code class="literal">.</code> <code class="literal">keyvalue()</code>
        → <code class="returnvalue"><em class="replaceable"><code>массив</code></em></code>
       </p>
       <p>Пары ключ-значение, представленные в виде массива объектов со следующими тремя полями: <code class="literal">"key"</code>, <code class="literal">"value"</code> и <code class="literal">"id"</code>; в <code class="literal">"id"</code> содержится уникальный идентификатор объекта, к которому относится данная пара ключ-значение</p>
       <p>
        <code class="literal">jsonb_path_query_array('{"x": "20", "y": 32}', '$.keyvalue()')</code>
        → <code class="returnvalue">[{"id": 0, "key": "x", "value": "20"}, {"id": 0, "key": "y", "value": 32}]</code>
       </p></td></tr></tbody></table></div></div><br class="table-break" /><div class="note"><h3 class="title">Примечание</h3><p>Результирующим типом методов <code class="literal">datetime()</code> и <code class="literal">datetime(<em class="replaceable"><code>шаблон</code></em>)</code> может быть <code class="type">date</code>, <code class="type">timetz</code>, <code class="type">time</code>, <code class="type">timestamptz</code> или <code class="type">timestamp</code>. Эти два метода определяют тип своего результата автоматически.</p><p>Метод <code class="literal">datetime()</code> пытается последовательно сопоставить поступившую на вход строку с ISO-форматами типов <code class="type">date</code>, <code class="type">timetz</code>, <code class="type">time</code>, <code class="type">timestamptz</code> и <code class="type">timestamp</code>. Встретив первый подходящий формат, он останавливается и возвращает соответствующий тип данных.</p><p>Метод <code class="literal">datetime(<em class="replaceable"><code>шаблон</code></em>)</code> определяет результирующий тип в соответствии с полями заданного шаблона.</p><p>Методы <code class="literal">datetime()</code> и <code class="literal">datetime(<em class="replaceable"><code>шаблон</code></em>)</code> применяют те же правила разбора строки, что и SQL-функция <code class="literal">to_timestamp</code> (см. <a class="xref" href="functions-formatting.html" title="9.8. Функции форматирования данных">Раздел 9.8</a>), но с тремя исключениями. Во-первых, эти методы не позволяют использовать в шаблоне поля, которым не находится соответствие. Во-вторых, в шаблоне допускаются только следующие разделители: знак минуса, точка, косая черта, запятая, апостроф, точка с запятой, запятая и пробел. В-третьих, разделители в шаблоне должны в точности соответствовать входной строке.</p><p>Если требуется сравнить значения разных типов даты/времени, применяется неявное приведение типа. Значение <code class="type">date</code> может быть приведено к типу <code class="type">timestamp</code> или <code class="type">timestamptz</code>; <code class="type">timestamp</code> — к типу <code class="type">timestamptz</code>, а <code class="type">time</code> — к <code class="type">timetz</code>. Однако все эти приведения, кроме первого, зависят от текущего значения <a class="xref" href="runtime-config-client.html#GUC-TIMEZONE">TimeZone</a> и поэтому не могут выполняться в функциях <code class="type">jsonpath</code>, не учитывающих часовой пояс.</p></div><p>В <a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-FILTER-EX-TABLE" title="Таблица 9.51. Элементы выражения фильтра jsonpath">Таблице 9.51</a> перечислены допустимые элементы выражения фильтра.</p><div class="table" id="FUNCTIONS-SQLJSON-FILTER-EX-TABLE"><p class="title"><strong>Таблица 9.51. Элементы выражения фильтра <code class="type">jsonpath</code></strong></p><div class="table-contents"><table class="table" summary="Элементы выражения фильтра jsonpath" border="1"><colgroup><col /></colgroup><thead><tr><th class="func_table_entry"><p class="func_signature">Предикат/значение</p>
       <p>Описание</p>
       <p>Пример(ы)</p></th></tr></thead><tbody><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>значение</code></em> <code class="literal">==</code> <em class="replaceable"><code>значение</code></em>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>Проверка равенства (все операторы сравнения, включая этот, работают с любыми скалярными значениями JSON)</p>
       <p>
        <code class="literal">jsonb_path_query_array('[1, "a", 1, 3]', '$[*] ? (@ == 1)')</code>
        → <code class="returnvalue">[1, 1]</code>
       </p>
       <p>
        <code class="literal">jsonb_path_query_array('[1, "a", 1, 3]', '$[*] ? (@ == "a")')</code>
        → <code class="returnvalue">["a"]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>значение</code></em> <code class="literal">!=</code> <em class="replaceable"><code>значение</code></em>
        → <code class="returnvalue">boolean</code>
       </p>
       <p class="func_signature">
        <em class="replaceable"><code>значение</code></em> <code class="literal">&lt;&gt;</code> <em class="replaceable"><code>значение</code></em>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>Проверка неравенства</p>
       <p>
        <code class="literal">jsonb_path_query_array('[1, 2, 1, 3]', '$[*] ? (@ != 1)')</code>
        → <code class="returnvalue">[2, 3]</code>
       </p>
       <p>
        <code class="literal">jsonb_path_query_array('["a", "b", "c"]', '$[*] ? (@ &lt;&gt; "b")')</code>
        → <code class="returnvalue">["a", "c"]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>значение</code></em> <code class="literal">&lt;</code> <em class="replaceable"><code>значение</code></em>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>Проверка «меньше»</p>
       <p>
        <code class="literal">jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &lt; 2)')</code>
        → <code class="returnvalue">[1]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>значение</code></em> <code class="literal">&lt;=</code> <em class="replaceable"><code>значение</code></em>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>Проверка «меньше или равно»</p>
       <p>
        <code class="literal">jsonb_path_query_array('["a", "b", "c"]', '$[*] ? (@ &lt;= "b")')</code>
        → <code class="returnvalue">["a", "b"]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>значение</code></em> <code class="literal">&gt;</code> <em class="replaceable"><code>значение</code></em>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>Проверка «больше»</p>
       <p>
        <code class="literal">jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &gt; 2)')</code>
        → <code class="returnvalue">[3]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>значение</code></em> <code class="literal">&gt;=</code> <em class="replaceable"><code>значение</code></em>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>Проверка «больше или равно»</p>
       <p>
        <code class="literal">jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &gt;= 2)')</code>
        → <code class="returnvalue">[2, 3]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="literal">true</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>JSON-константа <code class="literal">true</code></p>
       <p>
        <code class="literal">jsonb_path_query('[{"name": "John", "parent": false}, {"name": "Chris", "parent": true}]', '$[*] ? (@.parent == true)')</code>
        → <code class="returnvalue">{"name": "Chris", "parent": true}</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="literal">false</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>JSON-константа <code class="literal">false</code></p>
       <p>
        <code class="literal">jsonb_path_query('[{"name": "John", "parent": false}, {"name": "Chris", "parent": true}]', '$[*] ? (@.parent == false)')</code>
        → <code class="returnvalue">{"name": "John", "parent": false}</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="literal">null</code>
        → <code class="returnvalue"><em class="replaceable"><code>значение</code></em></code>
       </p>
       <p>JSON-константа <code class="literal">null</code> (заметьте, что в отличие от SQL сравнение с <code class="literal">null</code> работает традиционным образом)</p>
       <p>
        <code class="literal">jsonb_path_query('[{"name": "Mary", "job": null}, {"name": "Michael", "job": "driver"}]', '$[*] ? (@.job == null) .name')</code>
        → <code class="returnvalue">"Mary"</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>логическое_значение</code></em> <code class="literal">&amp;&amp;</code> <em class="replaceable"><code>логическое_значение</code></em>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>Логическое И</p>
       <p>
        <code class="literal">jsonb_path_query('[1, 3, 7]', '$[*] ? (@ &gt; 1 &amp;&amp; @ &lt; 5)')</code>
        → <code class="returnvalue">3</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>логическое_значение</code></em> <code class="literal">||</code> <em class="replaceable"><code>логическое_значение</code></em>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>Логическое ИЛИ</p>
       <p>
        <code class="literal">jsonb_path_query('[1, 3, 7]', '$[*] ? (@ &lt; 1 || @ &gt; 5)')</code>
        → <code class="returnvalue">7</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="literal">!</code> <em class="replaceable"><code>логическое_значение</code></em>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>Логическое НЕ</p>
       <p>
        <code class="literal">jsonb_path_query('[1, 3, 7]', '$[*] ? (!(@ &lt; 5))')</code>
        → <code class="returnvalue">7</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>логическое_значение</code></em> <code class="literal">is unknown</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>Проверяет, является ли <code class="literal">unknown</code> результатом логического условия.</p>
       <p>
        <code class="literal">jsonb_path_query('[-1, 2, 7, "foo"]', '$[*] ? ((@ &gt; 0) is unknown)')</code>
        → <code class="returnvalue">"foo"</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>строка</code></em> <code class="literal">like_regex</code> <em class="replaceable"><code>строка</code></em> [<span class="optional"> <code class="literal">flag</code> <em class="replaceable"><code>строка</code></em> </span>]
        → <code class="returnvalue">boolean</code>
       </p>
       <p>Проверяет, соответствует ли первый операнд регулярному выражению, которое задаёт второй операнд с необязательным аргументом <code class="literal">flag</code>, влияющим на поведение выражения (см. <a class="xref" href="functions-json.html#JSONPATH-REGULAR-EXPRESSIONS" title="9.16.2.3. Регулярные выражения SQL/JSON">Подраздел 9.16.2.3</a>).</p>
       <p>
        <code class="literal">jsonb_path_query_array('["abc", "abd", "aBdC", "abdacb", "babc"]', '$[*] ? (@ like_regex "^ab.*c")')</code>
        → <code class="returnvalue">["abc", "abdacb"]</code>
       </p>
       <p>
        <code class="literal">jsonb_path_query_array('["abc", "abd", "aBdC", "abdacb", "babc"]', '$[*] ? (@ like_regex "^ab.*c" flag "i")')</code>
        → <code class="returnvalue">["abc", "aBdC", "abdacb"]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>строка</code></em> <code class="literal">starts with</code> <em class="replaceable"><code>строка</code></em>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>Проверяет, является ли второй операнд начальной подстрокой первого.</p>
       <p>
        <code class="literal">jsonb_path_query('["John Smith", "Mary Stone", "Bob Johnson"]', '$[*] ? (@ starts with "John")')</code>
        → <code class="returnvalue">"John Smith"</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="literal">exists</code> <code class="literal">(</code> <em class="replaceable"><code>выражение_пути</code></em> <code class="literal">)</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>Проверяет, соответствует ли выражению пути минимум один элемент SQL/JSON. Возвращает <code class="literal">unknown</code>, если вычисление выражения пути могло привести к ошибке; это используется во втором примере для недопущения ошибки «ключ не найден» в строгом режиме.</p>
       <p>
        <code class="literal">jsonb_path_query('{"x": [1, 2], "y": [2, 4]}', 'strict $.* ? (exists (@ ? (@[*] &gt; 2)))')</code>
        → <code class="returnvalue">[2, 4]</code>
       </p>
       <p>
        <code class="literal">jsonb_path_query_array('{"value": 41}', 'strict $ ? (exists (@.name)) .name')</code>
        → <code class="returnvalue">[]</code>
       </p></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect3" id="JSONPATH-REGULAR-EXPRESSIONS"><div class="titlepage"><div><div><h4 class="title">9.16.2.3. Регулярные выражения SQL/JSON <a href="#JSONPATH-REGULAR-EXPRESSIONS" class="id_link">#</a></h4></div></div></div><a id="id-1.5.8.22.9.24.2" class="indexterm"></a><p>Выражения путей SQL/JSON могут содержать фильтры <code class="literal">like_regex</code>, позволяющие сопоставлять текст с регулярным выражением. Например, следующий запрос пути SQL/JSON выберет все строки в массиве, которые начинаются с английской гласной в любом регистре: </p><pre class="programlisting">$[*] ? (@ like_regex "^[aeiou]" flag "i")</pre><p>Необязательная строка <code class="literal">flag</code> может содержать один или несколько следующих символов: <code class="literal">i</code>, делающий поиск регистронезависимым, <code class="literal">m</code>, допускающий сопоставление <code class="literal">^</code> и <code class="literal">$</code> с переводами строк, <code class="literal">s</code>, допускающий сопоставление <code class="literal">.</code> с символом новой строки, и <code class="literal">q</code>, берущий в кавычки весь шаблон (в результате производится простой поиск подстроки).</p><p>Стандарт SQL/JSON заимствует определение регулярных выражений от оператора <code class="literal">LIKE_REGEX</code>, который, в свою очередь, реализуется по стандарту XQuery. Однако в PostgreSQL оператор <code class="literal">LIKE_REGEX</code> в настоящее время отсутствует. Поэтому фильтр <code class="literal">like_regex</code> реализован с использованием механизма регулярных выражений POSIX, который описан в <a class="xref" href="functions-matching.html#FUNCTIONS-POSIX-REGEXP" title="9.7.3. Регулярные выражения POSIX">Подразделе 9.7.3</a>. Вследствие этого наблюдается ряд небольших отклонений от описанного в стандарте поведения SQL/JSON, о которых рассказывается в <a class="xref" href="functions-matching.html#POSIX-VS-XQUERY" title="9.7.3.8. Отличия от XQuery и стандарта SQL">Подразделе 9.7.3.8</a>. Заметьте однако, что описанная там несовместимость букв флагов не проявляется на уровне SQL/JSON, так как заданные в SQL/JSON флаги XQuery переводятся во флаги, воспринимаемые механизмом POSIX.</p><p>Помните, что аргумент, задающий шаблон для <code class="literal">like_regex</code>, является строкой пути JSON и записывается по правилам, описанным в <a class="xref" href="datatype-json.html#DATATYPE-JSONPATH" title="8.14.7. Тип jsonpath">Подразделе 8.14.7</a>. Это в частности означает, что каждую косую черту в регулярном выражении надо дублировать. Например, чтобы отобрать строковые значения, находящиеся на уровне корня документа и содержащие только цифры, нужно написать: </p><pre class="programlisting">$.* ? (@ like_regex "^\\d+$")</pre></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="functions-xml.html" title="9.15. XML-функции">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="functions.html" title="Глава 9. Функции и операторы">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="functions-sequence.html" title="9.17. Функции для работы с последовательностями">След.</a></td></tr><tr><td width="40%" align="left" valign="top">9.15. XML-функции </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 9.17. Функции для работы с последовательностями</td></tr></table></div></body></html>