<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>13.2. Изоляция транзакций</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="mvcc-intro.html" title="13.1. Введение" /><link rel="next" href="explicit-locking.html" title="13.3. Явные блокировки" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">13.2. Изоляция транзакций</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="mvcc-intro.html" title="13.1. Введение">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="mvcc.html" title="Глава 13. Управление конкурентным доступом">Наверх</a></td><th width="60%" align="center">Глава 13. Управление конкурентным доступом</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="explicit-locking.html" title="13.3. Явные блокировки">След.</a></td></tr></table><hr /></div><div class="sect1" id="TRANSACTION-ISO"><div class="titlepage"><div><div><h2 class="title" style="clear: both">13.2. Изоляция транзакций <a href="#TRANSACTION-ISO" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="transaction-iso.html#XACT-READ-COMMITTED">13.2.1. Уровень изоляции Read Committed</a></span></dt><dt><span class="sect2"><a href="transaction-iso.html#XACT-REPEATABLE-READ">13.2.2. Уровень изоляции Repeatable Read</a></span></dt><dt><span class="sect2"><a href="transaction-iso.html#XACT-SERIALIZABLE">13.2.3. Уровень изоляции Serializable</a></span></dt></dl></div><a id="id-1.5.12.5.2" class="indexterm"></a><p>Стандарт <acronym class="acronym">SQL</acronym> определяет четыре уровня изоляции транзакций. Наиболее строгий из них — сериализуемый, определяется одним абзацем, говорящем, что при параллельном выполнении несколько сериализуемых транзакций должны гарантированно выдавать такой же результат, как если бы они запускались по очереди в некотором порядке. Остальные три уровня определяются через описания особых явлений, которые возможны при взаимодействии параллельных транзакций, но не допускаются на определённом уровне. Как отмечается в стандарте, из определения сериализуемого уровня вытекает, что на этом уровне ни одно из этих явлений не возможно. (В самом деле — если эффект транзакций должен быть тем же, что и при их выполнении по очереди, как можно было бы увидеть особые явления, связанные с другими транзакциями?)</p><p>Стандарт описывает следующие особые условия, недопустимые для различных уровней изоляции: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">«грязное» чтение<a id="id-1.5.12.5.4.1.1.1.1" class="indexterm"></a></span></dt><dd><p>Транзакция читает данные, записанные параллельной незавершённой транзакцией.</p></dd><dt><span class="term">неповторяемое чтение<a id="id-1.5.12.5.4.1.2.1.1" class="indexterm"></a></span></dt><dd><p>Транзакция повторно читает те же данные, что и раньше, и обнаруживает, что они были изменены другой транзакцией (которая завершилась после первого чтения).</p></dd><dt><span class="term">фантомное чтение<a id="id-1.5.12.5.4.1.3.1.1" class="indexterm"></a></span></dt><dd><p>Транзакция повторно выполняет запрос, возвращающий набор строк для некоторого условия, и обнаруживает, что набор строк, удовлетворяющих условию, изменился из-за транзакции, завершившейся за это время.</p></dd><dt><span class="term">аномалия сериализации <a id="id-1.5.12.5.4.1.4.1.1" class="indexterm"></a></span></dt><dd><p>Результат успешной фиксации группы транзакций оказывается несогласованным при всевозможных вариантах исполнения этих транзакций по очереди.</p></dd></dl></div><p><a id="id-1.5.12.5.5.1" class="indexterm"></a> Уровни изоляции транзакций, описанные в стандарте SQL и реализованные в PostgreSQL, описываются в <a class="xref" href="transaction-iso.html#MVCC-ISOLEVEL-TABLE" title="Таблица 13.1. Уровни изоляции транзакций">Таблице 13.1</a>.</p><div class="table" id="MVCC-ISOLEVEL-TABLE"><p class="title"><strong>Таблица 13.1. Уровни изоляции транзакций</strong></p><div class="table-contents"><table class="table" summary="Уровни изоляции транзакций" border="1"><colgroup><col /><col /><col /><col /><col /></colgroup><thead><tr><th>Уровень изоляции</th><th>«Грязное» чтение</th><th>Неповторяемое чтение</th><th>Фантомное чтение</th><th>Аномалия сериализации</th></tr></thead><tbody><tr><td>Read uncommited (Чтение незафиксированных данных)</td><td>Допускается, но не в PG</td><td>Возможно</td><td>Возможно</td><td>Возможно</td></tr><tr><td>Read committed (Чтение зафиксированных данных)</td><td>Невозможно</td><td>Возможно</td><td>Возможно</td><td>Возможно</td></tr><tr><td>Repeatable read (Повторяемое чтение)</td><td>Невозможно</td><td>Невозможно</td><td>Допускается, но не в PG</td><td>Возможно</td></tr><tr><td>Serializable (Сериализуемость)</td><td>Невозможно</td><td>Невозможно</td><td>Невозможно</td><td>Невозможно</td></tr></tbody></table></div></div><br class="table-break" /><p>В <span class="productname">PostgreSQL</span> вы можете запросить любой из четырёх уровней изоляции транзакций, однако внутри реализованы только три различных уровня, то есть режим Read Uncommitted в PostgreSQL действует как Read Committed. Причина этого в том, что только так можно сопоставить стандартные уровни изоляции с реализованной в PostgreSQL архитектурой многоверсионного управления конкурентным доступом.</p><p>В этой таблице также показано, что реализация Repeatable Read в PostgreSQL не допускает фантомного чтения. Это соответствует стандарту SQL, поскольку он устанавливает, каких аномалий <span class="emphasis"><em>не</em></span> должно быть на определённых уровнях изоляции, но допускает и более строгие ограничения. Поведение имеющихся уровней изоляции подробно описывается в следующих подразделах.</p><p>Для выбора нужного уровня изоляции транзакций используется команда <a class="xref" href="sql-set-transaction.html" title="SET TRANSACTION"><span class="refentrytitle">SET TRANSACTION</span></a>.</p><div class="important"><h3 class="title">Важно</h3><p>Поведение некоторых функций и типов данных <span class="productname">PostgreSQL</span> в транзакциях подчиняется особым правилам. В частности, изменения последовательностей (и следовательно, счётчика в столбце, объявленному как <code class="type">serial</code>) немедленно видны во всех остальных транзакциях и не откатываются назад, если выполнившая их транзакция прерывается. См. <a class="xref" href="functions-sequence.html" title="9.17. Функции для работы с последовательностями">Раздел 9.17</a> и <a class="xref" href="datatype-numeric.html#DATATYPE-SERIAL" title="8.1.4. Последовательные типы">Подраздел 8.1.4</a>.</p></div><div class="sect2" id="XACT-READ-COMMITTED"><div class="titlepage"><div><div><h3 class="title">13.2.1. Уровень изоляции Read Committed <a href="#XACT-READ-COMMITTED" class="id_link">#</a></h3></div></div></div><a id="id-1.5.12.5.11.2" class="indexterm"></a><a id="id-1.5.12.5.11.3" class="indexterm"></a><p><em class="firstterm">Read Committed</em> — уровень изоляции транзакции, выбираемый в <span class="productname">PostgreSQL</span> по умолчанию. В транзакции, работающей на этом уровне, запрос <code class="command">SELECT</code> (без предложения <code class="literal">FOR UPDATE/SHARE</code>) видит только те данные, которые были зафиксированы до начала запроса; он никогда не увидит незафиксированных данных или изменений, внесённых параллельными транзакциями в процессе выполнения запроса. По сути запрос <code class="command">SELECT</code> видит снимок базы данных в момент начала выполнения запроса. Однако <code class="command">SELECT</code> видит результаты изменений, внесённых ранее в этой же транзакции, даже если они ещё не зафиксированы. Также заметьте, что два последовательных оператора <code class="command">SELECT</code> могут видеть разные данные даже в рамках одной транзакции, если какие-то другие транзакции зафиксируют изменения после запуска первого <code class="command">SELECT</code>, но до запуска второго.</p><p>Команды <code class="command">UPDATE</code>, <code class="command">DELETE</code>, <code class="command">SELECT FOR UPDATE</code> и <code class="command">SELECT FOR SHARE</code> ведут себя подобно <code class="command">SELECT</code> при поиске целевых строк: они найдут только те целевые строки, которые были зафиксированы на момент начала команды. Однако к моменту, когда они будут найдены, эти целевые строки могут быть уже изменены (а также удалены или заблокированы) другой параллельной транзакцией. В этом случае запланированное изменение будет отложено до фиксирования или отката первой изменяющей данные транзакции (если она ещё выполняется). Если первая изменяющая транзакция откатывается, её результат отбрасывается и вторая изменяющая транзакция может продолжить изменение изначально полученной строки. Если первая транзакция зафиксировалась, но в результате удалила эту строку, вторая будет игнорировать её, а в противном случае попытается выполнить свою операцию с изменённой версией строки. Условие поиска в команде (предложение <code class="literal">WHERE</code>) вычисляется повторно для выяснения, соответствует ли по-прежнему этому условию изменённая версия строки. Если да, вторая изменяющая транзакция продолжают свою работу с изменённой версией строки. Применительно к командам <code class="command">SELECT FOR UPDATE</code> и <code class="command">SELECT FOR SHARE</code> это означает, что изменённая версия строки блокируется и возвращается клиенту.</p><p>Похожим образом ведёт себя <code class="command">INSERT</code> с предложением <code class="literal">ON CONFLICT DO UPDATE</code>. В режиме Read Committed каждая строка, предлагаемая для добавления, будет либо вставлена, либо изменена. Если не возникнет несвязанных ошибок, гарантируется один из этих двух исходов. Если конфликт будет вызван другой транзакцией, результат которой ещё не видим для <code class="command">INSERT</code>, предложение <code class="command">UPDATE</code> подействует на эту строку, даже несмотря на то, что эта команда обычным образом может не видеть <span class="emphasis"><em>никакую</em></span> версию этой строки.</p><p>При выполнении <code class="command">INSERT</code> с предложением <code class="literal">ON CONFLICT DO NOTHING</code> строка может не добавиться в результате действия другой транзакции, эффект которой не виден в снимке команды <code class="command">INSERT</code>. Это опять же имеет место только в режиме Read Committed.</p><p><code class="command">MERGE</code> позволяет пользователю указать различные комбинации подкоманд <code class="command">INSERT</code>, <code class="command">UPDATE</code> и <code class="command">DELETE</code>. Команда <code class="command">MERGE</code> с подкомандами <code class="command">INSERT</code> и <code class="command">UPDATE</code> работает аналогично <code class="command">INSERT</code> с <code class="literal">ON CONFLICT DO UPDATE</code>, но не гарантирует, что какая-либо из команд <code class="command">INSERT</code> или <code class="command">UPDATE</code> будет выполнена. Если <code class="command">MERGE</code> пытается выполнить <code class="command">UPDATE</code> или <code class="command">DELETE</code>, и строка одновременно изменяется, но условие соединения по-прежнему выполняется для текущего целевого и текущего исходного кортежа, то <code class="command">MERGE</code> будет работать так же, как команды <code class="command">UPDATE</code> или <code class="command">DELETE</code>, и выполнит свои действия с изменённой версией строки. Однако поскольку в <code class="command">MERGE</code> могут указываться несколько действий, и они могут быть условными, условия для всех действий заново вычисляются для изменённой версии строки, начиная с первого действия, даже если действие, которое первоначально оказалось подходящим, идёт в списке действий позже. С другой стороны, если строка одновременно изменяется или удаляется так, что условие соединения не выполняется, <code class="command">MERGE</code> будет вычислять следующие условия действий <code class="literal">NOT MATCHED</code> и выполнит действие с первым подходящим условием. Если <code class="command">MERGE</code> пытается выполнить <code class="command">INSERT</code> при наличии уникального индекса, и одновременно добавляется повторяющаяся строка, возникает ошибка нарушения уникальности; <code class="command">MERGE</code> не пытается избежать таких ошибок, заново вычисляя условия <code class="literal">MATCHED</code>.</p><p>Вследствие описанных выше правил, изменяющая команда может увидеть несогласованное состояние: она может видеть результаты параллельных команд, изменяющих те же строки, что пытается изменить она, но при этом она не видит результаты этих команд в других строках таблиц. Из-за этого поведения уровень Read Committed не подходит для команд со сложными условиями поиска; однако он вполне пригоден для простых случаев. Например, рассмотрим изменение баланса счёта в таких транзакциях: </p><pre class="screen">
BEGIN;
UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 12345;
UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 7534;
COMMIT;
</pre><p> Если две такие транзакции пытаются параллельно изменить баланс счёта 12345, мы, естественно, хотим, чтобы вторая транзакция работала с изменённой версией строки счёта. Так как каждая команда влияет только на определённую строку, если она будет видеть изменённую версию строки, это не приведёт к проблемам несогласованности.</p><p>В более сложных ситуациях уровень Read Committed может приводить к нежелательным результатам. Например, рассмотрим команду <code class="command">DELETE</code>, работающую со строками, которые параллельно добавляет и удаляет из множества, определённого её условием, другая команда. Например, предположим, что <code class="literal">website</code> — таблица из двух строк, в которых <code class="literal">website.hits</code> равны <code class="literal">9</code> и <code class="literal">10</code>: </p><pre class="screen">
BEGIN;
UPDATE website SET hits = hits + 1;
-- выполняется параллельно:  DELETE FROM website WHERE hits = 10;
COMMIT;
</pre><p> Команда <code class="command">DELETE</code> не сделает ничего, даже несмотря на то, что строка с <code class="literal">website.hits = 10</code> была в таблице и до, и после выполнения <code class="command">UPDATE</code>. Это происходит потому, что строка со значением <code class="literal">9</code> до изменения пропускается, а когда команда <code class="command">UPDATE</code> завершается и <code class="command">DELETE</code> получает освободившуюся блокировку, строка с <code class="literal">10</code> теперь содержит <code class="literal">11</code>, а это значение уже не соответствует условию.</p><p>Так как в режиме Read Committed каждая команда начинается с нового снимка состояния, который включает результаты всех транзакций, зафиксированных к этому моменту, последующие команды в одной транзакции будут в любом случае видеть эффекты всех параллельных зафиксированных транзакций. Вопрос здесь состоит в том, видит ли <span class="emphasis"><em>одна</em></span> команда абсолютно согласованное состояние базы данных.</p><p>Частичная изоляция транзакций, обеспечиваемая в режиме Read Committed, приемлема для множества приложений. Этот режим быстр и прост в использовании, однако он подходит не для всех случаев. Приложениям, выполняющим сложные запросы и изменения, могут потребоваться более строго согласованное представление данных, чем то, что даёт Read Committed.</p></div><div class="sect2" id="XACT-REPEATABLE-READ"><div class="titlepage"><div><div><h3 class="title">13.2.2. Уровень изоляции Repeatable Read <a href="#XACT-REPEATABLE-READ" class="id_link">#</a></h3></div></div></div><a id="id-1.5.12.5.12.2" class="indexterm"></a><a id="id-1.5.12.5.12.3" class="indexterm"></a><p>В режиме <em class="firstterm">Repeatable Read</em> видны только те данные, которые были зафиксированы до начала транзакции, но не видны незафиксированные данные и изменения, произведённые другими транзакциями в процессе выполнения данной транзакции. (Однако каждый запрос будет видеть эффекты предыдущих изменений в своей транзакции, несмотря на то, что они не зафиксированы.) Это самое строгое требование, которое стандарт <acronym class="acronym">SQL</acronym> вводит для этого уровня изоляции, и при его выполнении предотвращаются все явления, описанные в <a class="xref" href="transaction-iso.html#MVCC-ISOLEVEL-TABLE" title="Таблица 13.1. Уровни изоляции транзакций">Таблице 13.1</a>, за исключением аномалий сериализации. Как было сказано выше, это не противоречит стандарту, так как он определяет только <span class="emphasis"><em>минимальную</em></span> защиту, которая должна обеспечиваться на каждом уровне изоляции.</p><p>Этот уровень отличается от Read Committed тем, что запрос в транзакции данного уровня видит снимок данных на момент начала первого оператора в <span class="emphasis"><em>транзакции</em></span> (не считая команд управления транзакциями), а не начала текущего оператора. Таким образом, последовательные команды <code class="command">SELECT</code> в <span class="emphasis"><em>одной</em></span> транзакции видят одни и те же данные; они не видят изменений, внесённых и зафиксированных другими транзакциями после начала их текущей транзакции.</p><p>Приложения, использующие этот уровень, должны быть готовы повторить транзакции в случае сбоев сериализации.</p><p>Команды <code class="command">UPDATE</code>, <code class="command">DELETE</code>, <code class="command">MERGE</code>, <code class="command">SELECT FOR UPDATE</code> и <code class="command">SELECT FOR SHARE</code> ведут себя подобно <code class="command">SELECT</code> при поиске целевых строк: они найдут только те целевые строки, которые были зафиксированы на момент начала транзакции. Однако к моменту, когда они будут найдены, эти целевые строки могут быть уже изменены (а также удалены или заблокированы) другой параллельной транзакцией. В этом случае транзакция в режиме Repeatable Read будет ожидать фиксирования или отката первой изменяющей данные транзакции (если она ещё выполняется). Если первая изменяющая транзакция откатывается, её результат отбрасывается и текущая транзакция может продолжить изменение изначально полученной строки. Если же первая транзакция зафиксировалась и в результате изменила или удалила эту строку, а не просто заблокировала её, произойдёт откат текущей транзакции с сообщением </p><pre class="screen">
ОШИБКА: не удалось сериализовать доступ из-за параллельного изменения
</pre><p> так как транзакция уровня Repeatable Read не может изменять или блокировать строки, изменённые другими транзакциями с момента её начала.</p><p>Когда приложение получает это сообщение об ошибке, оно должна прервать текущую транзакцию и попытаться повторить её с самого начала. Во второй раз транзакция увидит внесённое до этого изменение как часть начального снимка базы данных, так что новая версия строки вполне может использоваться в качестве отправной точки для изменения в повторной транзакции.</p><p>Заметьте, что потребность в повторении транзакции может возникнуть, только если эта транзакция изменяет данные; в транзакциях, которые только читают данные, конфликтов сериализации не бывает.</p><p>Режим Repeatable Read строго гарантирует, что каждая транзакция видит полностью стабильное представление базы данных. Однако это представление не обязательно будет согласовано с некоторым последовательным выполнением транзакций одного уровня. Например, даже транзакция, которая только читает данные, в этом режиме может видеть строку, показывающую, что некоторое задание завершено, но <span class="emphasis"><em>не</em></span> видеть одну из строк логических частей задания, так как эта транзакция может прочитать более раннюю версию строки задания, чем ту, для которой параллельно добавлялась очередная логическая часть. Строго исполнить бизнес-правила в транзакциях, работающих на этом уровне изоляции, скорее всего не удастся без явных блокировок конфликтующих транзакций.</p><p>Для реализации уровня изоляции Repeatable Read применяется подход, который называется в академической литературе по базам данных и в других СУБД <em class="firstterm">Изоляция снимков</em> (Snapshot Isolation). По сравнению с системами, использующими традиционный метод блокировок, затрудняющий параллельное выполнение, при этом подходе наблюдается другое поведение и другая производительность. В некоторых СУБД могут существовать даже два отдельных уровня Repeatable Read и Snapshot Isolation с различным поведением. Допускаемые особые условия, представляющие отличия двух этих подходов, не были формализованы разработчиками теории БД до развития стандарта SQL и их рассмотрение выходит за рамки данного руководства. В полном объёме эта тема освещается в <a class="xref" href="biblio.html#BERENSON95">[berenson95]</a>.</p><div class="note"><h3 class="title">Примечание</h3><p>До версии 9.1 в <span class="productname">PostgreSQL</span> при запросе режима Serializable поведение системы в точности соответствовало вышеописанному. Таким образом, чтобы сейчас получить старое поведение Serializable, нужно запрашивать режим Repeatable Read.</p></div></div><div class="sect2" id="XACT-SERIALIZABLE"><div class="titlepage"><div><div><h3 class="title">13.2.3. Уровень изоляции Serializable <a href="#XACT-SERIALIZABLE" class="id_link">#</a></h3></div></div></div><a id="id-1.5.12.5.13.2" class="indexterm"></a><a id="id-1.5.12.5.13.3" class="indexterm"></a><a id="id-1.5.12.5.13.4" class="indexterm"></a><a id="id-1.5.12.5.13.5" class="indexterm"></a><p>Уровень <em class="firstterm">Serializable</em> обеспечивает самую строгую изоляцию транзакций. На этом уровне моделируется последовательное выполнение всех зафиксированных транзакций, как если бы транзакции выполнялись одна за другой, последовательно, а не параллельно. Однако, как и на уровне Repeatable Read, на этом уровне приложения должны быть готовы повторять транзакции из-за сбоев сериализации. Фактически этот режим изоляции работает так же, как и Repeatable Read, только он дополнительно отслеживает условия, при которых результат параллельно выполняемых сериализуемых транзакций может не согласовываться с результатом этих же транзакций, выполняемых по очереди. Это отслеживание не привносит дополнительных препятствий для выполнения, кроме тех, что присущи режиму Repeatable Read, но тем не менее создаёт некоторую добавочную нагрузку, а при выявлении исключительных условий регистрируется <em class="firstterm">аномалия сериализации</em> и происходит <em class="firstterm">сбой сериализации</em>.</p><p>Например, рассмотрим таблицу <code class="structname">mytab</code>, изначально содержащую: </p><pre class="screen">
 class | value
-------+-------
     1 |    10
     1 |    20
     2 |   100
     2 |   200
</pre><p> Предположим, что сериализуемая транзакция A вычисляет: </p><pre class="screen">
SELECT SUM(value) FROM mytab WHERE class = 1;
</pre><p> а затем вставляет результат (30) в поле <code class="structfield">value</code> в новую строку со значением <code class="structfield">class</code><code class="literal"> = 2</code>. В это же время сериализуемая транзакция B вычисляет: </p><pre class="screen">
SELECT SUM(value) FROM mytab WHERE class = 2;
</pre><p> получает результат 300 и вставляет его в новую строку со значением <code class="structfield">class</code><code class="literal"> = 1</code>. Затем обе транзакции пытаются зафиксироваться. Если бы одна из этих транзакций работала в режиме Repeatable Read, зафиксироваться могли бы обе; но так как полученный результат не соответствовал бы последовательному порядку, в режиме Serializable будет зафиксирована только одна транзакция, а вторая закончится откатом с сообщением: </p><pre class="screen">
ОШИБКА: не удалось сериализовать доступ из-за зависимостей чтения/записи между
  транзакциями
</pre><p> Это объясняется тем, что при выполнении A перед B транзакция B вычислила бы сумму 330, а не 300, а при выполнении в обратном порядке A вычислила бы другую сумму.</p><p>Рассчитывая, что сериализуемые транзакции предотвратят аномалии, важно понимать, что любые данные, полученные из постоянной таблицы пользователя, не должны считаться действительными, пока транзакция, прочитавшая их, не будет успешно зафиксирована. Это верно даже для транзакций, не модифицирующих данные, за исключением случая, когда данные считываются в <em class="firstterm">откладываемой</em> транзакции такого типа. В этом случае данные могут считаться действительными, так как такая транзакция ждёт, пока не сможет получить снимок, гарантированно предотвращающий подобные проблемы. Во всех остальных случаях приложения не должны полагаться на результаты чтения данных в транзакции, которая не была зафиксирована; в случае ошибки и отката приложения должны повторять транзакцию, пока она не будет завершена успешно.</p><p>Для полной гарантии сериализуемости в <span class="productname">PostgreSQL</span> применяются <em class="firstterm">предикатные блокировки</em>, то есть блокировки, позволяющие определить, когда запись могла бы повлиять на результат предыдущего чтения параллельной транзакции, если бы эта запись выполнялась сначала. В <span class="productname">PostgreSQL</span> эти блокировки не приводят к фактическим блокировкам данных и, следовательно, никоим образом <span class="emphasis"><em>не</em></span> могут повлечь взаимоблокировки транзакций. Они помогают выявить и отметить зависимости между параллельными транзакциями уровня Serializable, которые в определённых сочетаниях могут приводить к аномалиям сериализации. Транзакции Read Committed или Repeatable Read для обеспечения целостности данных, напротив, должны либо блокировать таблицы целиком, что помешает пользователям обращаться к этим таблицам, либо применять <code class="literal">SELECT FOR UPDATE</code> или <code class="literal">SELECT FOR SHARE</code>, что не только заблокирует другие транзакции, но и создаст дополнительную нагрузку на диск.</p><p>Предикатные блокировки в <span class="productname">PostgreSQL</span>, как и в большинстве других СУБД, устанавливаются для данных, фактически используемых в транзакции. Они отображаются в системном представлении <a class="link" href="view-pg-locks.html" title="54.12. pg_locks"><code class="structname">pg_locks</code></a> со значением <code class="literal">mode</code> равным <code class="literal">SIReadLock</code>. Какие именно блокировки будут затребованы при выполнении запроса, зависит от плана запроса, при этом детализированные блокировки (например, блокировки строк) могут объединяться в более общие (например, в блокировки страниц) в процессе транзакции для экономии памяти, расходуемой для отслеживания блокировок. Транзакция <code class="literal">READ ONLY</code> может даже освободить свои блокировки SIRead до завершения, если обнаруживается, что конфликты, которые могли бы привести к аномалии сериализации, исключены. На самом деле для транзакций <code class="literal">READ ONLY</code> этот факт чаще всего устанавливается в самом начале, так что они обходятся без предикатных блокировок. Если же вы явно запросите транзакцию <code class="literal">SERIALIZABLE READ ONLY DEFERRABLE</code>, она будет заблокирована до тех пор, пока не сможет установить этот факт. (Это <span class="emphasis"><em>единственный</em></span> случай, когда транзакции уровня Serializable блокируются, а транзакции Repeatable Read — нет.) С другой стороны, блокировки SIRead часто должны сохраняться и после фиксирования транзакции, пока не будут завершены другие, наложившиеся на неё транзакции.</p><p>При правильном использовании сериализуемые транзакции могут значительно упростить разработку приложений. Гарантия того, что любое сочетание успешно зафиксированных параллельных сериализуемых транзакций даст тот же результат, что и последовательность этих транзакций, выполненных по очереди, означает, что если вы уверены, что единственная транзакция определённого содержания работает правильно, когда она запускается отдельно, вы можете быть уверены, что она будет работать так же правильно в любом сочетании сериализуемых транзакций, вне зависимости от того, что они делают, либо же она не будет зафиксирована успешно. При этом важно, чтобы в среде, где применяется этот подход, была реализована общая обработка сбоев сериализации (которые можно определить по значению SQLSTATE '40001'), так как заведомо определить, какие именно транзакции могут стать жертвами зависимостей чтения/записи и не будут зафиксированы для предотвращения аномалий сериализации, обычно очень сложно. Отслеживание зависимостей чтения-записи неизбежно создаёт дополнительную нагрузку, как и перезапуск транзакций, не зафиксированных из-за сбоев сериализации, но если на другую чашу весов положить нагрузку и блокирование, связанные с применением явных блокировок и <code class="literal">SELECT FOR UPDATE</code> или <code class="literal">SELECT FOR SHARE</code>, использовать сериализуемые транзакции в ряде случаев окажется выгоднее.</p><p>Тогда как уровень изоляции транзакций Serializable в <span class="productname">PostgreSQL</span> позволяет фиксировать параллельные транзакции, только если есть уверенность, что тот же результат будет получен при последовательном их выполнении, он не всегда предотвращает ошибки, которые не возникли бы при действительно последовательном выполнении. В частности, можно столкнуться с нарушениями ограничений уникальности, вызванными наложением сериализуемых транзакций, даже после явной проверки отсутствия ключа перед добавлением его. Этого можно избежать, если <span class="emphasis"><em>все</em></span> сериализуемые транзакции, добавляющие потенциально конфликтующие ключи, будут предварительно явно проверять, можно ли вставить ключ. Например, приложение, добавляющее новый ключ, может запрашивать его у пользователя и затем проверять, существует ли он, сначала пытаясь найти его, либо генерировать новый ключ, выбирая максимальное существующее значение и увеличивая его на один. Если некоторые сериализуемые транзакции добавляют новые ключи сразу, не следуя этому протоколу, возможны нарушения ограничений уникальности, даже когда они не наблюдались бы при последовательном выполнении этих транзакций.</p><p>Применяя сериализуемые транзакции для управления конкурентным доступом, примите к сведению следующие рекомендации: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Объявляйте транзакции как <code class="literal">READ ONLY</code>, если это отражает их суть.</p></li><li class="listitem"><p>Управляйте числом активных подключений, при необходимости используя пул соединений. Это всегда полезно для увеличения производительности, но особенно важно это в загруженной системе с сериализуемыми транзакциями.</p></li><li class="listitem"><p>Заключайте в одну транзакцию не больше команд, чем необходимо для обеспечения целостности.</p></li><li class="listitem"><p>Не оставляйте соединения <span class="quote">«<span class="quote">простаивающими в транзакции</span>»</span> дольше, чем необходимо. Для автоматического отключения затянувшихся транзакций можно применить параметр конфигурации <a class="xref" href="runtime-config-client.html#GUC-IDLE-IN-TRANSACTION-SESSION-TIMEOUT">idle_in_transaction_session_timeout</a>.</p></li><li class="listitem"><p>Исключите явные блокировки, <code class="literal">SELECT FOR UPDATE</code> и <code class="literal">SELECT FOR SHARE</code> там, где они не нужны благодаря защите, автоматически предоставляемой сериализуемыми транзакциями.</p></li><li class="listitem"><p>Когда система вынуждена объединять предикатные блокировки уровня страницы в одну предикатную блокировку уровня таблицы из-за нехватки памяти, может возрасти частота сбоев сериализации. Избежать этого можно, увеличив параметр <a class="xref" href="runtime-config-locks.html#GUC-MAX-PRED-LOCKS-PER-TRANSACTION">max_pred_locks_per_transaction</a>, <a class="xref" href="runtime-config-locks.html#GUC-MAX-PRED-LOCKS-PER-RELATION">max_pred_locks_per_relation</a> и/или <a class="xref" href="runtime-config-locks.html#GUC-MAX-PRED-LOCKS-PER-PAGE">max_pred_locks_per_page</a>.</p></li><li class="listitem"><p>Последовательное сканирование всегда влечёт за собой предикатную блокировку на уровне таблицы. Это приводит к увеличению сбоев сериализации. В таких ситуациях бывает полезно склонить систему к использованию индексов, уменьшая <a class="xref" href="runtime-config-query.html#GUC-RANDOM-PAGE-COST">random_page_cost</a> и/или увеличивая <a class="xref" href="runtime-config-query.html#GUC-CPU-TUPLE-COST">cpu_tuple_cost</a>. Однако тут важно сопоставить выигрыш от уменьшения числа откатов и перезапусков транзакций с проигрышем от возможного менее эффективного выполнения запросов.</p></li></ul></div><p>Для реализации уровня изоляции Serializable применяется подход, который называется в академической литературе по базам данных <em class="firstterm">Изоляция снимков</em> (Snapshot Isolation), с дополнительными проверками на предмет аномалий сериализации. По сравнению с другими системами, использующими традиционный метод блокировок, при этом подходе наблюдается другое поведение и другая производительность. Подробнее это освещается в <a class="xref" href="biblio.html#PORTS12">[ports12]</a>.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="mvcc-intro.html" title="13.1. Введение">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="mvcc.html" title="Глава 13. Управление конкурентным доступом">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="explicit-locking.html" title="13.3. Явные блокировки">След.</a></td></tr><tr><td width="40%" align="left" valign="top">13.1. Введение </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 13.3. Явные блокировки</td></tr></table></div></body></html>