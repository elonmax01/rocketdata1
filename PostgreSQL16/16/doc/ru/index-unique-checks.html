<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>64.5. Проверки уникальности в индексе</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="index-locking.html" title="64.4. Замечания о блокировке с индексами" /><link rel="next" href="index-cost-estimation.html" title="64.6. Функции оценки стоимости индекса" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">64.5. Проверки уникальности в индексе</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="index-locking.html" title="64.4. Замечания о блокировке с индексами">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="indexam.html" title="Глава 64. Определение интерфейса для индексных методов доступа">Наверх</a></td><th width="60%" align="center">Глава 64. Определение интерфейса для индексных методов доступа</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="index-cost-estimation.html" title="64.6. Функции оценки стоимости индекса">След.</a></td></tr></table><hr /></div><div class="sect1" id="INDEX-UNIQUE-CHECKS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">64.5. Проверки уникальности в индексе <a href="#INDEX-UNIQUE-CHECKS" class="id_link">#</a></h2></div></div></div><p><span class="productname">PostgreSQL</span> реализует ограничения уникальности SQL, применяя <em class="firstterm">уникальные индексы</em>, то есть такие индексы, которые не принимают несколько записей с одинаковыми ключами. Для метода доступа, поддерживающего это свойство, устанавливается признак <code class="structfield">amcanunique</code>. (В настоящее время это поддерживают только В-деревья.) Столбцы, указанные в предложении <code class="literal">INCLUDE</code>, не учитываются при контроле уникальности.</p><p>Вследствие особенностей MVCC, всегда необходимо допускать физическое сосуществование в индексе дублирующихся записей: такие записи могут относиться к последовательным версиям одной логической строки. На самом деле мы хотим добиться только того, чтобы никакой снимок MVCC не мог содержать две строки с одинаковыми ключами индекса. Из этого вытекают следующие ситуации, которые необходимо отследить, добавляя новую строку в уникальный индекс: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Если конфликтующая строка была удалена текущей транзакцией, это не проблема. (В частности из-за того, что UPDATE всегда удаляет старую версию строки, прежде чем вставлять новую, операцию UPDATE можно выполнять со строкой, не меняя её ключ.)</p></li><li class="listitem"><p>Если конфликтующая строка была добавлена ещё не зафиксированной транзакцией, запрос, претендующий на добавление новой строки, должен подождать, пока эта транзакция не будет зафиксирована. Если она откатывается, конфликт исчезает. Если она фиксируется и при этом оставляет конфликтующую строку, возникает нарушение уникальности. (На практике мы просто ждём завершения другой транзакции и затем пересматриваем проверку видимости.)</p></li><li class="listitem"><p>Подобным образом, если конфликтующая строка была удалена ещё не зафиксированной транзакцией, запрос, претендующий на добавление новой строки, должен дождаться фиксации или отката этой транзакции, а затем повторить проверку.</p></li></ul></div><p>Более того, непосредственно перед тем как сообщать о нарушении уникальности согласно вышеприведённым правилам, метод доступа должен перепроверить, продолжает ли существовать добавляемая строка. Если она признана «мёртвой», о предвиденном нарушении он сообщать не должен. (Такого не должно быть при обычном сценарии добавления строки текущей транзакцией, однако это может произойти в процессе <code class="command">CREATE UNIQUE INDEX CONCURRENTLY</code>.)</p><p>Мы требуем, чтобы метод доступа выполнял эти проверки сам, и это означает, что он должен обратиться к основным данным и проверить состояние фиксации всех строк, которые согласно содержимого индекса содержат дублирующиеся ключи. Это без сомнения некрасивый и немодульный подход, но он избавляет от излишней работы: если бы мы делали отдельную пробу, то поиск конфликтующей строки по индексу пришлось бы по сути повторять, пытаясь найти место, куда вставить запись для новой строки. Более того, не представляется возможным избежать условий гонки, если проверка конфликта не будет неотъемлемой частью процедуры добавления новой записи индекса.</p><p>Если ограничение уникальности откладываемое, возникает дополнительная сложность: нам нужна возможность добавлять запись индекса для новой строки, но отложить выводы о нарушении уникальности до конца оператора или даже позже. Чтобы избежать ненужного повторного поиска по индексу, метод доступа должен произвести предварительную проверку уникальности во время изначального добавления строк. Если при этом окажется, что никакие кортежи не конфликтуют, на этом проверка заканчивается. В противном случае мы планируем перепроверку на время, когда это ограничение начинает действовать. Если во время перепроверки продолжают существовать и вставленный кортеж, и какой-либо другой с тем же ключом, должна выдаваться ошибка. (Заметьте, что в данном случае под <span class="quote">«<span class="quote">существованием</span>»</span> понимается <span class="quote">«<span class="quote">существование любого кортежа в цепочке HOT записей индекса</span>»</span>.) Для реализации этой схемы в <code class="function">aminsert</code> передаётся параметр <code class="literal">checkUnique</code>, принимающий одно из следующих значений: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">UNIQUE_CHECK_NO</code> указывает, что проверка уникальности не должна выполняться (это не уникальный индекс).</p></li><li class="listitem"><p><code class="literal">UNIQUE_CHECK_YES</code> указывает, что это неоткладываемый уникальный индекс и проверку уникальности нужно выполнить немедленно, как описано выше.</p></li><li class="listitem"><p><code class="literal">UNIQUE_CHECK_PARTIAL</code> указывает, что это откладываемое ограничение уникальности. <span class="productname">PostgreSQL</span> выбирает этот режим для добавления записи индекса для каждой строки. Метод доступа должен допускать добавление в индекс дублирующихся записей и сообщать о возможных конфликтах, возвращая false из <code class="function">aminsert</code>. Для каждой такой строки (для которой возвращается false) будет запланирована отложенная перепроверка.</p><p>Метод доступа должен отметить все строки, которые могут нарушать ограничение уникальности, но не будет ошибкой, если он допустит ложное срабатывание. Это позволяет произвести проверку, не дожидаясь завершения других транзакций; конфликты, выявленные на этой стадии, не считаются ошибками и будут перепроверены позже, когда они могут быть уже исчерпаны.</p></li><li class="listitem"><p><code class="literal">UNIQUE_CHECK_EXISTING</code> указывает, что это отложенная перепроверка строки, которая была отмечена как возможно нарушающая ограничение. Хотя для этой проверки вызывается <code class="function">aminsert</code>, метод доступа <span class="emphasis"><em>не</em></span> должен добавлять новую запись индекса в данном случае, так как эта запись уже существует. Вместо этого, метод доступа должен проверить, нет ли в индексе другой такой же записи. Если она находится и соответствующая ей строка продолжает существовать, должна выдаваться ошибка.</p><p>Для варианта <code class="literal">UNIQUE_CHECK_EXISTING</code> в методе доступа рекомендуется дополнительно проверить, что для целевой строки действительно имеется запись в индексе и сообщить об ошибке, если это не так. Это хорошая идея, так как значения кортежа индекса, передаваемые в <code class="function">aminsert</code>, будут рассчитаны заново. Если в определении индекса задействованы функции, которые на самом деле не постоянные, мы можем проверять неправильную область индекса. Дополнительно убедившись в существовании целевой строки при перепроверке, мы можем быть уверены, что сканируются те же значения кортежа, что передавались при изначальном добавлении строки.</p></li></ul></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="index-locking.html" title="64.4. Замечания о блокировке с индексами">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="indexam.html" title="Глава 64. Определение интерфейса для индексных методов доступа">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="index-cost-estimation.html" title="64.6. Функции оценки стоимости индекса">След.</a></td></tr><tr><td width="40%" align="left" valign="top">64.4. Замечания о блокировке с индексами </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 64.6. Функции оценки стоимости индекса</td></tr></table></div></body></html>