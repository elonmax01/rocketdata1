<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>36.5. Динамический SQL</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="ecpg-variables.html" title="36.4. Использование переменных среды" /><link rel="next" href="ecpg-pgtypes.html" title="36.6. Библиотека pgtypes" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">36.5. Динамический SQL</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="ecpg-variables.html" title="36.4. Использование переменных среды">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="ecpg.html" title="Глава 36. ECPG — Встраиваемый SQL в C">Наверх</a></td><th width="60%" align="center">Глава 36. <span class="application">ECPG</span> — Встраиваемый <acronym class="acronym">SQL</acronym> в C</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="ecpg-pgtypes.html" title="36.6. Библиотека pgtypes">След.</a></td></tr></table><hr /></div><div class="sect1" id="ECPG-DYNAMIC"><div class="titlepage"><div><div><h2 class="title" style="clear: both">36.5. Динамический SQL <a href="#ECPG-DYNAMIC" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="ecpg-dynamic.html#ECPG-DYNAMIC-WITHOUT-RESULT">36.5.1. Выполнение операторов без набора результатов</a></span></dt><dt><span class="sect2"><a href="ecpg-dynamic.html#ECPG-DYNAMIC-INPUT">36.5.2. Выполнение оператора с входными параметрами</a></span></dt><dt><span class="sect2"><a href="ecpg-dynamic.html#ECPG-DYNAMIC-WITH-RESULT">36.5.3. Выполнение оператора с набором результатов</a></span></dt></dl></div><p>Во многих случаях конкретные SQL-операторы, которые должно выполнять приложение, известны в момент написания приложения. В некоторых случаях, однако, SQL-операторы формируются во время выполнения или поступают из внешнего источника. В этих случаях SQL-операторы нельзя внедрить непосредственно в исходный код C, но есть средство, позволяющее вызывать произвольные SQL-операторы, передаваемые в строковой переменной.</p><div class="sect2" id="ECPG-DYNAMIC-WITHOUT-RESULT"><div class="titlepage"><div><div><h3 class="title">36.5.1. Выполнение операторов без набора результатов <a href="#ECPG-DYNAMIC-WITHOUT-RESULT" class="id_link">#</a></h3></div></div></div><p>Самый простой способ выполнить произвольный SQL-оператор — применить команду <code class="command">EXECUTE IMMEDIATE</code>. Например: </p><pre class="programlisting">EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "CREATE TABLE test1 (...);";
EXEC SQL END DECLARE SECTION;

EXEC SQL EXECUTE IMMEDIATE :stmt;</pre><p> <code class="command">EXECUTE IMMEDIATE</code> можно применять для SQL-операторов, которые не возвращают набор результатов (например, DDL, <code class="command">INSERT</code>, <code class="command">UPDATE</code>, <code class="command">DELETE</code>). Выполнять операторы, которые получают данные, (например, <code class="command">SELECT</code>) таким образом нельзя. Как выполнять такие операторы, рассказывается в следующем разделе.</p></div><div class="sect2" id="ECPG-DYNAMIC-INPUT"><div class="titlepage"><div><div><h3 class="title">36.5.2. Выполнение оператора с входными параметрами <a href="#ECPG-DYNAMIC-INPUT" class="id_link">#</a></h3></div></div></div><p>Более эффективно выполнять произвольный SQL-оператор можно, подготовив его один раз, а затем запуская подготовленный оператор столько, сколько нужно. Также можно подготовить обобщённую версию оператора, а затем выполнять специализированные его версии, подставляя в него параметры. Подготавливая оператор, поставьте знаки вопроса там, где позже хотите подставить параметры. Например: </p><pre class="programlisting">EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "INSERT INTO test1 VALUES(?, ?);";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE mystmt FROM :stmt;
 ...
EXEC SQL EXECUTE mystmt USING 42, 'foobar';</pre><p>Когда подготовленный оператор больше не нужен, его следует освободить: </p><pre class="programlisting">EXEC SQL DEALLOCATE PREPARE <em class="replaceable"><code>имя</code></em>;</pre></div><div class="sect2" id="ECPG-DYNAMIC-WITH-RESULT"><div class="titlepage"><div><div><h3 class="title">36.5.3. Выполнение оператора с набором результатов <a href="#ECPG-DYNAMIC-WITH-RESULT" class="id_link">#</a></h3></div></div></div><p>Для выполнения SQL-оператора с одной строкой результата можно применить команду <code class="command">EXECUTE</code>. Чтобы сохранить результат, добавьте предложение <code class="literal">INTO</code>. </p><pre class="programlisting">
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "SELECT a, b, c FROM test1 WHERE a &gt; ?";
int v1, v2;
VARCHAR v3[50];
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE mystmt FROM :stmt;
 ...
EXEC SQL EXECUTE mystmt INTO :v1, :v2, :v3 USING 37;

</pre><p> Команда <code class="command">EXECUTE</code> может содержать предложение <code class="literal">INTO</code> и/или предложение <code class="literal">USING</code>, либо не содержать ни того, ни другого.</p><p>Если ожидается, что запрос вернёт более одной строки результата, следует применять курсор, как показано в следующем примере. (Подробно курсоры описываются в <a class="xref" href="ecpg-commands.html#ECPG-CURSORS" title="36.3.2. Использование курсоров">Подразделе 36.3.2</a>.) </p><pre class="programlisting">EXEC SQL BEGIN DECLARE SECTION;
char dbaname[128];
char datname[128];
char *stmt = "SELECT u.usename as dbaname, d.datname "
             "  FROM pg_database d, pg_user u "
             "  WHERE d.datdba = u.usesysid";
EXEC SQL END DECLARE SECTION;

EXEC SQL CONNECT TO testdb AS con1 USER testuser;
EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;

EXEC SQL PREPARE stmt1 FROM :stmt;

EXEC SQL DECLARE cursor1 CURSOR FOR stmt1;
EXEC SQL OPEN cursor1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH cursor1 INTO :dbaname,:datname;
    printf("dbaname=%s, datname=%s\n", dbaname, datname);
}

EXEC SQL CLOSE cursor1;

EXEC SQL COMMIT;
EXEC SQL DISCONNECT ALL;</pre></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ecpg-variables.html" title="36.4. Использование переменных среды">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="ecpg.html" title="Глава 36. ECPG — Встраиваемый SQL в C">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="ecpg-pgtypes.html" title="36.6. Библиотека pgtypes">След.</a></td></tr><tr><td width="40%" align="left" valign="top">36.4. Использование переменных среды </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 36.6. Библиотека pgtypes</td></tr></table></div></body></html>