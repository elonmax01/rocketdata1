<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>38.17. Упаковывание связанных объектов в расширение</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="xindex.html" title="38.16. Интерфейсы расширений для индексов" /><link rel="next" href="extend-pgxs.html" title="38.18. Инфраструктура сборки расширений" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">38.17. Упаковывание связанных объектов в расширение</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="xindex.html" title="38.16. Интерфейсы расширений для индексов">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="extend.html" title="Глава 38. Расширение SQL">Наверх</a></td><th width="60%" align="center">Глава 38. Расширение <acronym class="acronym">SQL</acronym></th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="extend-pgxs.html" title="38.18. Инфраструктура сборки расширений">След.</a></td></tr></table><hr /></div><div class="sect1" id="EXTEND-EXTENSIONS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">38.17. Упаковывание связанных объектов в расширение <a href="#EXTEND-EXTENSIONS" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="extend-extensions.html#EXTEND-EXTENSIONS-FILES">38.17.1. Файлы расширений</a></span></dt><dt><span class="sect2"><a href="extend-extensions.html#EXTEND-EXTENSIONS-RELOCATION">38.17.2. Перемещаемость расширений</a></span></dt><dt><span class="sect2"><a href="extend-extensions.html#EXTEND-EXTENSIONS-CONFIG-TABLES">38.17.3. Конфигурационные таблицы расширений</a></span></dt><dt><span class="sect2"><a href="extend-extensions.html#EXTEND-EXTENSIONS-UPDATES">38.17.4. Обновление расширений</a></span></dt><dt><span class="sect2"><a href="extend-extensions.html#EXTEND-EXTENSIONS-UPDATE-SCRIPTS">38.17.5. Установка расширений скриптами обновления</a></span></dt><dt><span class="sect2"><a href="extend-extensions.html#EXTEND-EXTENSIONS-SECURITY">38.17.6. Замечания о безопасности расширений</a></span></dt><dt><span class="sect2"><a href="extend-extensions.html#EXTEND-EXTENSIONS-EXAMPLE">38.17.7. Пример расширения</a></span></dt></dl></div><a id="id-1.8.3.20.2" class="indexterm"></a><p>Полезное расширение <span class="productname">PostgreSQL</span> обычно включает несколько объектов SQL; например, с появлением нового типа данных могут потребоваться новые функции, новые операторы и новые классы операторов. Все эти объекты удобно собрать в один пакет, с тем чтобы упростить управление базой данных. В <span class="productname">PostgreSQL</span> такие пакеты называются <em class="firstterm">расширениями</em>. Чтобы определить расширение, вам понадобится как минимум <em class="firstterm">файл скрипта</em> с командами <acronym class="acronym">SQL</acronym>, создающими объекты расширения, и <em class="firstterm">управляющий файл</em>, в котором определяются несколько базовых свойств самого расширения. Если расширение написано на C, в него обычно также включается файл разделяемой библиотеки, содержащий скомпилированный код. Обеспечив наличие этих файлов, загрузить их в базу данных можно простой командой <a class="link" href="sql-createextension.html" title="CREATE EXTENSION"><code class="command">CREATE EXTENSION</code></a>.</p><p>Основное преимущество расширений по сравнению с обычным <acronym class="acronym">SQL</acronym>-скриптом, загружающим множество <span class="quote">«<span class="quote">разрозненных</span>»</span> объектов в базу данных, состоит в том, что <span class="productname">PostgreSQL</span> будет понимать, что объекты расширения связаны вместе. Вы можете удалить все объекты одной командой <a class="link" href="sql-dropextension.html" title="DROP EXTENSION"><code class="command">DROP EXTENSION</code></a> (разрабатывать отдельный скрипт <span class="quote">«<span class="quote">uninstall</span>»</span> не требуется). Ещё полезнее то, что утилита <span class="application">pg_dump</span> знает, что не нужно выгружать отдельные объекты, составляющие расширение — вместо этого она просто включит в архивный файл команду <code class="command">CREATE EXTENSION</code>. Это кардинально упрощает миграцию на новую версию расширения, которая может содержать новые или другие объекты по сравнению с предыдущей версией. Заметьте, однако, что при загрузке такого архива в базу данных обязательно наличие скрипта, управляющего файла и других файлов расширения.</p><p><span class="productname">PostgreSQL</span> не позволит удалить отдельный объект, содержащийся в расширении, кроме как при удалении всего расширения. Также имейте в виду, что вы можете изменить определение объекта, относящегося к расширению (например, командой <code class="command">CREATE OR REPLACE FUNCTION</code> для функции), но изменённое определение не будет выгружено утилитой <span class="application">pg_dump</span>. Такие изменения обычно разумны, только если они параллельно отражаются в файле скрипта расширения. (Для таблиц, содержащих конфигурационные данные, предусмотрены специальные средства; см. <a class="xref" href="extend-extensions.html#EXTEND-EXTENSIONS-CONFIG-TABLES" title="38.17.3. Конфигурационные таблицы расширений">Подраздел 38.17.3</a>.) В производственной среде обычно лучше создавать скрипт обновления расширения, который будет изменять относящиеся к расширению объекты.</p><p>Скрипт расширения может устанавливать права доступа для объектов, являющихся частью расширения, выполняя команды <code class="command">GRANT</code> и <code class="command">REVOKE</code>. Окончательный набор прав для каждого объекта (если они заданы) будет сохранён в системном каталоге <a class="link" href="catalog-pg-init-privs.html" title="53.28. pg_init_privs"><code class="structname">pg_init_privs</code></a>. При использовании <span class="application">pg_dump</span> в выгружаемый скрипт будет выведена команда <code class="command">CREATE EXTENSION</code> с последующими операторами <code class="command">GRANT</code> и <code class="command">REVOKE</code>, которые установят права, имевшие место в момент выгрузки.</p><p><span class="productname">PostgreSQL</span> в настоящее время не поддерживает скрипты расширений, выполняющие операторы <code class="command">CREATE POLICY</code> или <code class="command">SECURITY LABEL</code>. Ожидается, что такие команды будут выполняться после того, как расширение будет создано. Выгружая данные, <span class="application">pg_dump</span> будет также включать в вывод все политики RLS и метки безопасности.</p><p>Механизм расширений также предоставляет средства для поддержки дополнительных скриптов, призванных изменять определение объектов SQL, содержащихся в расширении. Например, если версия расширения 1.1, по сравнению с версией 1.0, добавляет одну функцию и изменяет тело другой функции, автор расширения может предоставить <em class="firstterm">скрипт обновления</em>, который произведёт именно эти два изменения. Затем, воспользовавшись командой <code class="command">ALTER EXTENSION UPDATE</code>, можно будет применить эти изменения и отследить, какая версия расширения фактически установлена в заданной базе данных.</p><p>Типы SQL-объектов, которые могут быть членами расширения, перечислены в описании <a class="link" href="sql-alterextension.html" title="ALTER EXTENSION"><code class="command">ALTER EXTENSION</code></a>. Не могут быть его членами, в частности, объекты уровня кластера, такие как базы данных, роли и табличные пространства, так как расширение существует только в рамках одной базы данных. (Скрипту расширения не запрещается создавать такие объекты, но если он сделает это, они не будут считаться частью расширения.) Также заметьте, что несмотря на то, что таблица может быть членом расширения, её подчинённые объекты, такие как индексы, непосредственными членами расширения считаться не будут. Ещё один важный момент — схемы могут принадлежать расширениям, но не наоборот; поэтому расширение имеет неполное имя и не существует <span class="quote">«<span class="quote">внутри</span>»</span> какой-либо схемы. Однако объекты-члены расширения, будут относиться к схемам, если это уместно для их типов. Сами расширения могут иметь, а могут не иметь основания владеть схемами, к которым относятся объекты-члены расширения.</p><p>Если скрипт расширения создаёт какие-либо временные объекты (например, временные таблицы), эти объекты будут считаться членами расширения до конца текущего сеанса, но удалятся автоматически в конце сеанса, как и должны временные объекты. Это является исключением из правила, запрещающего удаление объектов-членов расширения без удаления всего расширения.</p><div class="sect2" id="EXTEND-EXTENSIONS-FILES"><div class="titlepage"><div><div><h3 class="title">38.17.1. Файлы расширений <a href="#EXTEND-EXTENSIONS-FILES" class="id_link">#</a></h3></div></div></div><a id="id-1.8.3.20.11.2" class="indexterm"></a><p>Команда <code class="command">CREATE EXTENSION</code> задействует управляющий файл расширения, который должен называться по имени расширения, с суффиксом <code class="literal">.control</code>, и должен быть помещён в каталог сервера <code class="literal">SHAREDIR/extension</code>. Должен быть также ещё минимум один <acronym class="acronym">SQL</acronym>-скрипт, с именем, соответствующим шаблону <code class="literal"><em class="replaceable"><code>расширение</code></em>--<em class="replaceable"><code>версия</code></em>.sql</code> (например, <code class="literal">foo--1.0.sql</code> для версии <code class="literal">1.0</code> расширения <code class="literal">foo</code>). По умолчанию скрипт(ы) также помещается в каталог <code class="literal">SHAREDIR/extension</code>; но в управляющем файле можно задать и другой каталог.</p><p>Формат управляющего файла расширения не отличается от формата <code class="filename">postgresql.conf</code>, а именно представляет собой список присваиваний <em class="replaceable"><code>имя_параметра</code></em> <code class="literal">=</code> <em class="replaceable"><code>значение</code></em>, по одному в строке. В нём также допускаются пустые строки и комментарии, начинающиеся с <code class="literal">#</code>. Все значения, отличные от единственного слова или числа, в нём должны заключаться в кавычки.</p><p>В управляющем файле могут устанавливаться следующие параметры:</p><div class="variablelist"><dl class="variablelist"><dt id="EXTEND-EXTENSIONS-FILES-DIRECTORY"><span class="term"><code class="varname">directory</code> (<code class="type">string</code>)</span> <a href="#EXTEND-EXTENSIONS-FILES-DIRECTORY" class="id_link">#</a></dt><dd><p>Каталог, содержащий <acronym class="acronym">SQL</acronym>-скрипт(ы) расширения. Если только не задан абсолютный путь, это имя рассматривается относительно каталога сервера <code class="literal">SHAREDIR</code>. По умолчанию подразумевается указание <code class="literal">directory = 'extension'</code>.</p></dd><dt id="EXTEND-EXTENSIONS-FILES-DEFAULT-VERSION"><span class="term"><code class="varname">default_version</code> (<code class="type">string</code>)</span> <a href="#EXTEND-EXTENSIONS-FILES-DEFAULT-VERSION" class="id_link">#</a></dt><dd><p>Версия расширения по умолчанию (та, которая будет установлена, если в <code class="command">CREATE EXTENSION</code> не будет указана никакая версия). Хотя этот параметр можно опустить, это приведёт к ошибке в <code class="command">CREATE EXTENSION</code> без явного указания <code class="literal">VERSION</code>, что вряд ли будет желаемым поведением.</p></dd><dt id="EXTEND-EXTENSIONS-FILES-COMMENT"><span class="term"><code class="varname">comment</code> (<code class="type">string</code>)</span> <a href="#EXTEND-EXTENSIONS-FILES-COMMENT" class="id_link">#</a></dt><dd><p>Комментарий (произвольная строка) к расширению. Комментарий применяется при изначальном создании расширения, но не при обновлениях расширения (так как при этом мог бы заменяться комментарий, заданный пользователем). Комментарий расширения также можно задать посредством команды <a class="xref" href="sql-comment.html" title="COMMENT"><span class="refentrytitle">COMMENT</span></a> в файле скрипта.</p></dd><dt id="EXTEND-EXTENSIONS-FILES-ENCODING"><span class="term"><code class="varname">encoding</code> (<code class="type">string</code>)</span> <a href="#EXTEND-EXTENSIONS-FILES-ENCODING" class="id_link">#</a></dt><dd><p>Кодировка символов, используемая в файлах скриптов. Её следует указать, если эти файлы содержат символы не из набора ASCII. По умолчанию предполагается, что эти файлы содержат текст в кодировке базы данных.</p></dd><dt id="EXTEND-EXTENSIONS-FILES-MODULE-PATHNAME"><span class="term"><code class="varname">module_pathname</code> (<code class="type">string</code>)</span> <a href="#EXTEND-EXTENSIONS-FILES-MODULE-PATHNAME" class="id_link">#</a></dt><dd><p>Значение этого параметра будет подставляться вместо каждого вхождения <code class="literal">MODULE_PATHNAME</code> в скриптах. Если этот параметр не задан, подстановка не производится. Обычно для этого параметра устанавливается значение <code class="literal">$libdir/<em class="replaceable"><code>имя_разделяемой_библиотеки</code></em></code>, а затем в командах <code class="command">CREATE FUNCTION</code> для функций на языке C указывается <code class="literal">MODULE_PATHNAME</code>, чтобы в скриптах не приходилось жёстко задавать имя разделяемой библиотеки.</p></dd><dt id="EXTEND-EXTENSIONS-FILES-REQUIRES"><span class="term"><code class="varname">requires</code> (<code class="type">string</code>)</span> <a href="#EXTEND-EXTENSIONS-FILES-REQUIRES" class="id_link">#</a></dt><dd><p>Список имён расширений, от которых зависит данное, например, <code class="literal">requires = 'foo, bar'</code>. Эти расширения должны быть уже установлены, прежде чем можно будет установить данное.</p></dd><dt id="EXTEND-EXTENSIONS-FILES-NO-RELOCATE"><span class="term"><code class="varname">no_relocate</code> (<code class="type">string</code>)</span> <a href="#EXTEND-EXTENSIONS-FILES-NO-RELOCATE" class="id_link">#</a></dt><dd><p>Список имён расширений, от которых зависит данное расширение и которым следует запретить изменение своих схем командой <code class="command">ALTER EXTENSION ... SET SCHEMA</code>. Это необходимо, если скрипт данного расширения ссылается на имя требуемой схемы расширения (используя синтаксис <code class="literal">@extschema:<em class="replaceable"><code>имя</code></em>@</code>) таким образом, что не может отслеживать переименования.</p></dd><dt id="EXTEND-EXTENSIONS-FILES-SUPERUSER"><span class="term"><code class="varname">superuser</code> (<code class="type">boolean</code>)</span> <a href="#EXTEND-EXTENSIONS-FILES-SUPERUSER" class="id_link">#</a></dt><dd><p>Если этот параметр имеет значение <code class="literal">true</code> (по умолчанию), только суперпользователи смогут создать это расширение или обновить его до новой версии. (Однако обратите внимание на свойство <code class="varname">trusted</code>, описанное ниже). Если он имеет значение <code class="literal">false</code>, для этого будет достаточно прав, необходимых для выполнения команд в установочном скрипте или скрипте обновления. Обычно значение <code class="literal">true</code> должно устанавливаться, если для выполнения какой-либо из команд в этих скриптах требуются права суперпользователя. Такие команды в любом случае не будут выполнены успешно, но лучше сообщить пользователю об ошибке заранее.</p></dd><dt id="EXTEND-EXTENSIONS-FILES-TRUSTED"><span class="term"><code class="varname">trusted</code> (<code class="type">boolean</code>)</span> <a href="#EXTEND-EXTENSIONS-FILES-TRUSTED" class="id_link">#</a></dt><dd><p>Если этот параметр имеет значение <code class="literal">true</code> (по умолчанию это не так), то расширение, для которого свойство <code class="varname">superuser</code> равно <code class="literal">true</code>, смогут устанавливать не только суперпользователи. А именно, установить его смогут любые пользователи, имеющие право <code class="literal">CREATE</code> в текущей базе данных. Когда пользователь, выполняющий <code class="command">CREATE EXTENSION</code>, не является суперпользователем, но ему разрешена установка этого расширения посредством этого параметра, скрипт установки или обновления запускается от имени начального суперпользователя, а не от имени вызывающего пользователя. Этот параметр не играет роли, если свойство <code class="varname">superuser</code> равно <code class="literal">false</code>. Вообще говоря, этот параметр не следует устанавливать для расширений, которые могут открыть возможности, иначе доступные только суперпользователям, например, предоставить доступ к файловой системе. Кроме того, если расширение помечается как доверенное, написание безопасных скриптов установки и обновления для него требует дополнительных усилий; см. <a class="xref" href="extend-extensions.html#EXTEND-EXTENSIONS-SECURITY" title="38.17.6. Замечания о безопасности расширений">Подраздел 38.17.6</a>.</p></dd><dt id="EXTEND-EXTENSIONS-FILES-RELOCATABLE"><span class="term"><code class="varname">relocatable</code> (<code class="type">boolean</code>)</span> <a href="#EXTEND-EXTENSIONS-FILES-RELOCATABLE" class="id_link">#</a></dt><dd><p>Расширение является <em class="firstterm">перемещаемым</em>, если относящиеся к нему объекты после создания расширения можно переместить в другую схему. По умолчанию подразумевается <code class="literal">false</code>, то есть расширение не считается перемещаемым. Подробнее об этом рассказывается в <a class="xref" href="extend-extensions.html#EXTEND-EXTENSIONS-RELOCATION" title="38.17.2. Перемещаемость расширений">Подразделе 38.17.2</a>.</p></dd><dt id="EXTEND-EXTENSIONS-FILES-SCHEMA"><span class="term"><code class="varname">schema</code> (<code class="type">string</code>)</span> <a href="#EXTEND-EXTENSIONS-FILES-SCHEMA" class="id_link">#</a></dt><dd><p>Этот параметр может задаваться только для неперемещаемых расширений. Если он задан, расширение можно будет загрузить только в указанную схему и не в какую другую. Подробнее об этом рассказывается ниже. Параметр <code class="varname">schema</code> учитывается только при изначальном создании расширения, но не при его обновлении. Подробнее об этом рассказывается в <a class="xref" href="extend-extensions.html#EXTEND-EXTENSIONS-RELOCATION" title="38.17.2. Перемещаемость расширений">Подразделе 38.17.2</a>.</p></dd></dl></div><p>Помимо главного управляющего файла <code class="literal"><em class="replaceable"><code>расширение</code></em>.control</code>, расширение может включать дополнительные управляющие файлы с именами вида <code class="literal"><em class="replaceable"><code>расширение</code></em>--<em class="replaceable"><code>версия</code></em>.control</code>. Если они присутствуют, они должны находиться в том же каталоге, что и основной скрипт. Дополнительные управляющие файлы имеют тот же формат, что и основной. Любые параметры, заданные в дополнительном управляющем файле, переопределяют параметры основного файла, когда выполняется установка этой версии расширения или обновление до неё. Однако параметры <code class="varname">directory</code> и <code class="varname">default_version</code> в дополнительных управляющих файлах задать нельзя.</p><p><acronym class="acronym">SQL</acronym>-скрипты расширений могут содержать любые команды SQL, за исключением команд управления транзакциями (<code class="command">BEGIN</code>, <code class="command">COMMIT</code> и т. д.) и команд, которые не могут выполняться внутри блока транзакции (например, <code class="command">VACUUM</code>). Это объясняется тем, что эти скрипты неявно выполняются в блоке транзакции.</p><p><acronym class="acronym">SQL</acronym>-скрипты расширений также могут содержать строки, начинающиеся с <code class="literal">\echo</code>, и они будут игнорироваться (восприниматься как комментарии) механизмом расширений. Это часто используется для вывода ошибки в случае, если этот скрипт выполняется в <span class="application">psql</span>, а не загружается командой <code class="command">CREATE EXTENSION</code> (см. пример скрипта в <a class="xref" href="extend-extensions.html#EXTEND-EXTENSIONS-EXAMPLE" title="38.17.7. Пример расширения">Подразделе 38.17.7</a>). Если такое выполнение не предотвратить, пользователи могут случайно загрузить содержимое расширения как <span class="quote">«<span class="quote">разрозненные</span>»</span> объекты, а не как собственно расширение, и получить состояние, которое довольно сложно исправить.</p><p>Если скрипт расширения содержит строку <code class="literal">@extowner@</code>, она будет заменена именем (если требуется, заключённым в кавычки) пользователя, выполняющего команду <code class="command">CREATE EXTENSION</code> или <code class="command">ALTER EXTENSION</code>. Обычно это полезно для доверенных расширений, в которых владельцем внутренних объектов назначается не начальный суперпользователь, а вызывающий пользователь. (Однако это следует делать с осторожностью. Например, если назначить обычного пользователя владельцем функции на языке C, это позволит ему повысить свои привилегии.)</p><p>Тогда как файлы скриптов могут содержать любые символы, допустимые в указанной кодировке, управляющие файлы могут содержать только ASCII-символы, так как указать кодировку этих файлов в <span class="productname">PostgreSQL</span> нет никакой возможности. На практике это представляет проблему, только если вы хотите использовать символы не из набора ASCII в комментарии расширения. В таких случаях рекомендуется не использовать параметр <code class="varname">comment</code> в управляющем файле, а вместо этого задать комментарий командой <code class="command">COMMENT ON EXTENSION</code> в файле скрипта.</p></div><div class="sect2" id="EXTEND-EXTENSIONS-RELOCATION"><div class="titlepage"><div><div><h3 class="title">38.17.2. Перемещаемость расширений <a href="#EXTEND-EXTENSIONS-RELOCATION" class="id_link">#</a></h3></div></div></div><p>У пользователей часто возникает желание загрузить объекты, содержащиеся в расширении, в схему, отличную от той, что выбрал автор расширения. Насколько это поддерживает расширение, описывается одним из трёх уровней:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Полностью перемещаемое расширение может быть перемещено в другую схему в любое время, даже после того, как оно загружено в базу данных. Это осуществляется командой <code class="command">ALTER EXTENSION SET SCHEMA</code>, которая автоматически переименовывает все объекты-члены расширения, перенося их в новую схему. Обычно это возможно, только если в расширении нет никаких внутренних предположений о том, в какой схеме находятся все его объекты. Кроме того, все объекты расширения должны находиться в одной исходной схеме (за исключением объектов, не принадлежащих схемам, как например, процедурные языки). Чтобы пометить расширение как полностью перемещаемое, установите <code class="literal">relocatable = true</code> в его управляющем файле.</p></li><li class="listitem"><p>Расширение может быть перемещаемым в момент установки, но не после. Обычно это имеет место, когда скрипту расширения необходимо явно ссылаться на целевую схему, например, устанавливая свойства <code class="literal">search_path</code> для функций SQL. Для такого расширения нужно задать <code class="literal">relocatable = false</code> в его управляющем файле и обращаться к целевой схеме в скрипте по псевдоимени <code class="literal">@extschema@</code>. Все вхождения этого псевдоимени будут заменены именем выбранной целевой схемы (при необходимости заключённым в двойные кавычки) перед выполнением скрипта. Пользователь может выбрать целевую схему в указании <code class="literal">SCHEMA</code> команды <code class="command">CREATE EXTENSION</code>.</p></li><li class="listitem"><p>Если расширение вовсе не поддерживает перемещение, установите в его управляющем файле <code class="literal">relocatable = false</code>, и также задайте в параметре <code class="literal">schema</code> имя предполагаемой целевой схемы. Это предотвратит использование указания <code class="literal">SCHEMA</code> команды <code class="command">CREATE EXTENSION</code>, если только оно задаёт не то же имя, что определено в управляющем файле. Этот выбор обычно необходим, если в расширении делаются внутренние предположения об имени схемы расширения, которое нельзя свести к использованию псевдоимени <code class="literal">@extschema@</code>. Механизм подстановки <code class="literal">@extschema@</code> будет работать и в этом случае, хотя польза от него будет ограниченной, так как имя схемы определяется управляющим файлом.</p></li></ul></div><p>В любом случае при выполнении файла скрипта параметр <a class="xref" href="runtime-config-client.html#GUC-SEARCH-PATH">search_path</a> изначально будет указывать на целевую схему; то есть, <code class="command">CREATE EXTENSION</code> делает то же, что и: </p><pre class="programlisting">SET LOCAL search_path TO @extschema@, pg_temp;</pre><p> Это позволяет направить объекты, создаваемые скриптом, в целевую схему. Скрипт может изменить <code class="varname">search_path</code>, если пожелает, но обычно это нежелательно. Параметр <code class="varname">search_path</code> восстанавливает предыдущее значение по завершении <code class="command">CREATE EXTENSION</code>.</p><p>Целевая схема определяется параметром <code class="varname">schema</code> (если он задан) в управляющем файле, либо указанием <code class="literal">SCHEMA</code> команды <code class="command">CREATE EXTENSION</code> (если оно присутствует), а в противном случае выбирается текущая схема для создания объектов по умолчанию (первая указанная в параметре <code class="varname">search_path</code> вызывающего). Когда используется параметр управляющего файла <code class="varname">schema</code>, целевая схема будет создана, если она ещё не существует, но в двух других случаях она должна уже существовать.</p><p>Если в параметре <code class="varname">requires</code> в управляющем файле расширения указаны какие-либо расширения, необходимые для данного, их целевые схемы добавляются к начальному значению <code class="varname">search_path</code> после целевой схемы нового расширения. Благодаря этому их объекты видны для скрипта нового расширения.</p><p>В целях безопасности схема <code class="literal">pg_temp</code> всегда автоматически добавляется в конец <code class="varname">search_path</code>.</p><p>Хотя неперемещаемое расширение может содержать объекты, распределяемые по нескольким схемам, обычно желательно поместить все объекты, предназначенные для внешнего использования, в одну схему, назначенную целевой схемой расширения. Такой порядок будет хорошо согласовываться со значением <code class="varname">search_path</code> по умолчанию в процессе создания зависимых расширений.</p><p>Если расширение ссылается на объекты, принадлежащие другому расширению, рекомендуется дополнить эти ссылки именами схем. Для этого напишите <code class="literal">@extschema:<em class="replaceable"><code>имя</code></em>@</code> в файле скрипта расширения, где <em class="replaceable"><code>имя</code></em> — это имя другого расширения (которое должно быть в списке <code class="literal">requires</code> этого расширения). Эта строка будет заменена именем (при необходимости заключённым в двойные кавычки) целевой схемы этого расширения. Хотя такая запись избавляет от необходимости делать запрограммированные предположения об именах схем в файле скрипта расширения, при её использовании имя схемы другого расширения может встраиваться в установленные объекты. (Обычно это происходит, когда <code class="literal">@extschema:<em class="replaceable"><code>имя</code></em>@</code> используется внутри строкового литерала, такого как тело функции или параметр <code class="varname">search_path</code>. В других случаях ссылка на объект сокращается до OID во время синтаксического анализа и не требует последующего поиска.) Если имя схемы расширения встраивается таким образом, следует запретить перемещение такого расширения, добавив его имя в список <code class="literal">no_relocate</code> после установки пользовательского расширения.</p></div><div class="sect2" id="EXTEND-EXTENSIONS-CONFIG-TABLES"><div class="titlepage"><div><div><h3 class="title">38.17.3. Конфигурационные таблицы расширений <a href="#EXTEND-EXTENSIONS-CONFIG-TABLES" class="id_link">#</a></h3></div></div></div><p>Некоторые расширения включают конфигурационные таблицы, содержащие данные, которые могут быть добавлены или изменены пользователем после установки расширения. Обычно, если таблица является частью расширения, ни определение таблицы, ни её содержимое не будет выгружаться утилитой <span class="application">pg_dump</span>. Но это поведение нежелательно для конфигурационных таблиц — изменения, внесённые в них пользователем, должны выгружаться; в противном случае расширение будет вести себя по-другому, когда будет загружено вновь.</p><a id="id-1.8.3.20.13.3" class="indexterm"></a><p>Чтобы решить эту проблему, скрипт расширения может пометить созданную им таблицу или последовательность как конфигурационное отношение, в результате чего <span class="application">pg_dump</span> включит в выгружаемые данные содержимое (но не определение) этой таблицы или последовательности. Для этого нужно вызвать функцию <code class="function">pg_extension_config_dump(regclass, text)</code> после создания таблицы или последовательности, например так: </p><pre class="programlisting">CREATE TABLE my_config (key text, value text);
CREATE SEQUENCE my_config_seq;

SELECT pg_catalog.pg_extension_config_dump('my_config', '');
SELECT pg_catalog.pg_extension_config_dump('my_config_seq', '');</pre><p> Так можно пометить любое число таблиц или последовательностей, в том числе последовательности, связанные со столбцами <code class="type">serial</code> или <code class="type">bigserial</code>.</p><p>Когда второй аргумент <code class="function">pg_extension_config_dump</code> — пустая строка, <span class="application">pg_dump</span> выгружает всё содержимое таблицы. Обычно это правильно, только если после создания скриптом расширения эта таблица изначально пуста. Если же в таблице оказывается смесь начальных данных и данных, добавленных пользователем, во втором аргументе <code class="function">pg_extension_config_dump</code> передаётся условие <code class="literal">WHERE</code>, которое отфильтровывает данные, подлежащие выгрузке. Например, имея таблицу, созданную таким образом: </p><pre class="programlisting">CREATE TABLE my_config (key text, value text, standard_entry boolean);

SELECT pg_catalog.pg_extension_config_dump('my_config', 'WHERE NOT standard_entry');</pre><p> можно сделать так, чтобы поле <code class="structfield">standard_entry</code> содержало true только для строк, создаваемых скриптом расширения.</p><p>Для последовательностей второй аргумент функции <code class="function">pg_extension_config_dump</code> не имеет значения.</p><p>В более сложных ситуациях, когда пользователи могут модифицировать и изначально существовавшие строки, можно создать триггеры для конфигурационной таблицы, которые корректно пометят изменённые строки.</p><p>Условие фильтра, связанное с конфигурационной таблицей, можно изменить, повторно вызвав <code class="function">pg_extension_config_dump</code>. (Обычно это находит применение в скрипте обновления расширения.) Единственный способ обозначить, что некоторая таблица более не является конфигурационной — разорвать её связь с расширением командой <code class="command">ALTER EXTENSION ... DROP TABLE</code>.</p><p>Заметьте, что отношения внешних ключей между таблицами определяют порядок, в котором эти таблицы будет выгружать pg_dump. В частности, pg_dump попытается выгрузить сначала основную таблицу, а затем подчинённую. Так как отношения внешних ключей устанавливаются во время выполнения CREATE EXTENSION (до загрузки данных в таблицы), циклические зависимости не поддерживаются. Когда образуются циклические зависимости, данные тем не менее будут выгружены, но полученный архив нельзя будет восстановить обычным образом, потребуется вмешательство пользователя.</p><p>Чтобы сохранить состояние последовательностей, связанных со столбцами <code class="type">serial</code> или <code class="type">bigserial</code>, их нужно помечать непосредственно. Для этой цели недостаточно пометить только их родительское отношение.</p></div><div class="sect2" id="EXTEND-EXTENSIONS-UPDATES"><div class="titlepage"><div><div><h3 class="title">38.17.4. Обновление расширений <a href="#EXTEND-EXTENSIONS-UPDATES" class="id_link">#</a></h3></div></div></div><p>Один из плюсов механизма расширений заключается в том, что он предоставляет удобные способы управления обновлениями SQL-команд, определяющих объекты расширения. В частности, каждой выпускаемой версии установочного скрипта расширения назначается имя или номер версии. Кроме того, если вы хотите, чтобы пользователи могли динамически обновлять одну версию расширения до другой, вы должны предоставить <em class="firstterm">скрипты обновления</em>, которые внесут необходимые изменения для перехода от старой версии к новой. Скриптам обновлений назначаются имена, соответствующие шаблону <code class="literal"><em class="replaceable"><code>расширение</code></em>--<em class="replaceable"><code>старая_версия</code></em>--<em class="replaceable"><code>новая_версия</code></em>.sql</code> (например, <code class="literal">foo--1.0--1.1.sql</code> будет содержать команды, меняющие версию <code class="literal">1.0</code> расширения <code class="literal">foo</code> на версию <code class="literal">1.1</code>).</p><p>С условием, что имеется подходящий скрипт расширения, команда <code class="command">ALTER EXTENSION UPDATE</code> обновит установленное расширение до указанной новой версии. Скрипт обновления запускается в том же окружении, которое организует команда <code class="command">CREATE EXTENSION</code> для установочных скриптов: в частности, <code class="varname">search_path</code> устанавливается таким же образом, а любые новые объекты, созданные скриптом, автоматически добавляются в расширение. И если скрипт решит удалить объекты-члены расширения, они будут автоматически исключены из его состава.</p><p>Если у расширения есть дополнительные управляющие файлы, для скрипта обновления применяются те параметры, которые связаны с целевой (новой) версией скрипта.</p><p><code class="command">ALTER EXTENSION</code> также может выполнять последовательности скриптов обновления для получения запрошенной версии. Например, если имеются только скрипты <code class="literal">foo--1.0--1.1.sql</code> и <code class="literal">foo--1.1--2.0.sql</code>, <code class="command">ALTER EXTENSION</code> будет применять их по порядку, если при установленной версии <code class="literal">1.0</code> запрошено обновлении до версии <code class="literal">2.0</code>.</p><p><span class="productname">PostgreSQL</span> не делает никаких предположений о свойствах имён версий: например, он не знает, следует ли версия <code class="literal">1.1</code> за <code class="literal">1.0</code>. Он просто сопоставляет имена имеющихся версий и следует пути, который требует применить как можно меньше скриптов обновлений. (Именем версии на самом деле может быть любая строка, которая не содержит <code class="literal">--</code> и при этом не начинается и не заканчивается символом <code class="literal">-</code>.)</p><p>Иногда бывают полезны скрипты <span class="quote">«<span class="quote">понижения версии</span>»</span>, например, <code class="literal">foo--1.1--1.0.sql</code>, которые позволяют откатить изменения, связанные с версией <code class="literal">1.1</code>. Если вы применяете их, учтите, что есть вероятность неожиданного выполнения такого скрипта, если он окажется в кратчайшем пути. Рискованная ситуация возникает при наличии скрипта обновления по <span class="quote">«<span class="quote">короткому пути</span>»</span>, который перепрыгивает через несколько версий, и скрипта понижения версии до начальной точки первого скрипта. В результате может получиться так, что понижение версии с последующим обновлением по короткому пути окажется на несколько шагов короче, чем последовательное повышение версии. Если скрипт понижения версии удаляет какие-либо незаменимые объекты, это может привести к нежелательным результатам.</p><p>Чтобы убедиться, что при обновлении не будет выбран нежелательный путь, воспользуйтесь этой командой: </p><pre class="programlisting">SELECT * FROM pg_extension_update_paths('<em class="replaceable"><code>имя_расширения</code></em>');</pre><p> Она показывает каждую пару различных известных имён версий для указанного расширения, вместе с последовательностью обновления, которая будет выбрана для перехода от одной версии к другой, либо <code class="literal">NULL</code>, если путь обновления не находится. Путь выводится в текстовом виде с разделителями <code class="literal">--</code>. Если вы предпочитаете формат массива, вы можете применить <code class="literal">regexp_split_to_array(path,'--')</code>.</p></div><div class="sect2" id="EXTEND-EXTENSIONS-UPDATE-SCRIPTS"><div class="titlepage"><div><div><h3 class="title">38.17.5. Установка расширений скриптами обновления <a href="#EXTEND-EXTENSIONS-UPDATE-SCRIPTS" class="id_link">#</a></h3></div></div></div><p>Расширение, существующее некоторое время, вероятно, будет иметь несколько версий, для которых автору надо будет писать скрипты обновления. Например, если вы выпустили расширение <code class="literal">foo</code> версий <code class="literal">1.0</code>, <code class="literal">1.1</code> и <code class="literal">1.2</code>, у вас должны быть скрипты обновления <code class="filename">foo--1.0--1.1.sql</code> и <code class="filename">foo--1.1--1.2.sql</code>. До <span class="productname">PostgreSQL</span> версии 10 необходимо было также создавать файлы скриптов <code class="filename">foo--1.1.sql</code> и <code class="filename">foo--1.2.sql</code>, которые устанавливают непосредственно новые версии скриптов; в противном случае их можно было установить, только установив <code class="literal">1.0</code> и произведя обновление. Это было утомительно и неэффективно, но теперь такой необходимости нет, так как команда <code class="command">CREATE EXTENSION</code> может сама построить цепочку обновлений. Например, если имеются только файлы скриптов <code class="filename">foo--1.0.sql</code>, <code class="filename">foo--1.0--1.1.sql</code> и <code class="filename">foo--1.1--1.2.sql</code>, то запрос на установку версии <code class="literal">1.2</code> удовлетворяется запуском этих трёх скриптов по очереди. Это не будет отличаться от установки версии <code class="literal">1.0</code> с последующим обновлением до <code class="literal">1.2</code>. (Как и с командой <code class="command">ALTER EXTENSION UPDATE</code>, при наличии нескольких путей выбирается самый короткий.) Организация скриптов расширения по такой схеме может упростить сопровождение небольших обновлений.</p><p>Если вы используете дополнительные (ориентированные на версию) управляющие файлы для расширения, поддерживаемого по такой схеме, имейте в виду, что управляющий файл нужен для каждой версии, даже если для неё нет отдельного скрипта установки, так как этот файл будет определять, как произвести неявное обновление до этой версии. Например, если в файле <code class="filename">foo--1.0.control</code> задаётся <code class="literal">requires = 'bar'</code>, а в других управляющих файлах <code class="literal">foo</code> — нет, зависимость расширения от <code class="literal">bar</code> будет удалена при обновлении с версии <code class="literal">1.0</code> до другой.</p></div><div class="sect2" id="EXTEND-EXTENSIONS-SECURITY"><div class="titlepage"><div><div><h3 class="title">38.17.6. Замечания о безопасности расширений <a href="#EXTEND-EXTENSIONS-SECURITY" class="id_link">#</a></h3></div></div></div><p>Широко распространяемые расширения не должны строить никаких предположений относительно базы данных, в которой они находятся. Таким образом, функции, предоставляемые расширениями, следует писать в безопасном стиле, так, чтобы их нельзя было скомпрометировать в атаках с использованием пути поиска.</p><p>Расширение, у которого свойство <code class="varname">superuser</code> имеет значение true, должно быть также защищено от угроз безопасности, связанных с действиями, которые выполняются при установке и обновлении расширения. Для злонамеренного пользователя не составит большого труда создать объект типа троянского коня, который впоследствии скомпрометирует выполнение неаккуратно написанного скрипта расширения и позволит этому пользователю стать суперпользователем.</p><p>Если расширение имеет характеристику <code class="varname">trusted</code>, вызывающий пользователь может выбрать схему, в которую оно будет устанавливаться. При этом он может намеренно выбрать небезопасную схему в надежде получить таким образом права суперпользователя. Поэтому доверенное расширение крайне уязвимо с точки зрения безопасности, так что все содержащиеся в его скриптах команды необходимо тщательно проверять, чтобы исключить возможность его компрометации.</p><p>Советы по безопасному написанию функций представлены ниже в <a class="xref" href="extend-extensions.html#EXTEND-EXTENSIONS-SECURITY-FUNCS" title="38.17.6.1. Замечания о безопасности функций в расширениях">Подразделе 38.17.6.1</a>, а советы по написанию установочных скриптов — в <a class="xref" href="extend-extensions.html#EXTEND-EXTENSIONS-SECURITY-SCRIPTS" title="38.17.6.2. Замечания о безопасности скриптов расширений">Подразделе 38.17.6.2</a>.</p><div class="sect3" id="EXTEND-EXTENSIONS-SECURITY-FUNCS"><div class="titlepage"><div><div><h4 class="title">38.17.6.1. Замечания о безопасности функций в расширениях <a href="#EXTEND-EXTENSIONS-SECURITY-FUNCS" class="id_link">#</a></h4></div></div></div><p>Функции, реализованные в расширениях на языках SQL и PL*, подвержены атакам с использованием пути поиска во время выполнения, так как синтаксический разбор этих функций имеет место, когда они выполняются, а не когда создаются.</p><p>На странице <a class="link" href="sql-createfunction.html#SQL-CREATEFUNCTION-SECURITY" title="Разработка защищённых функций SECURITY DEFINER"><code class="command">CREATE FUNCTION</code></a> даётся полезный совет по безопасному написанию функций с характеристикой <code class="literal">SECURITY DEFINER</code>. Эти приёмы рекомендуется применять и для функций, предоставляемых расширениями, так как подобная функция может вызываться пользователем с расширенными правами.</p><p>Если вы не можете оставить в <code class="varname">search_path</code> только безопасные схемы, считайте, что каждое заданное без схемы имя может быть разрешено в объект, созданный злонамеренным пользователем. Избегайте конструкций, явно зависящих от <code class="varname">search_path</code>; например, <code class="token">IN</code> и <code class="literal">CASE <em class="replaceable"><code>выражение</code></em> WHEN</code> всегда выбирают оператор по пути поиска. Вместо них следует использовать конструкции <code class="literal">OPERATOR(<em class="replaceable"><code>схема</code></em>.=) ANY</code> и <code class="literal">CASE WHEN <em class="replaceable"><code>выражение</code></em></code>.</p><p>Расширения общего назначения не должны рассчитывать на то, что они устанавливаются в безопасную схему, что означает, что даже ссылаться на собственные объекты с указанием схемы в них небезопасно. Например, если в расширении определена функция <code class="literal">myschema.myfunc(bigint)</code>, её вызов в виде <code class="literal">myschema.myfunc(42)</code> можно перехватить, создав специальную функцию <code class="literal">myschema.myfunc(integer)</code>. Позаботьтесь о том, чтобы типы параметров функций и операторов в точности соответствовали объявленным типам их аргументов, и используйте явные приведения, где это необходимо.</p></div><div class="sect3" id="EXTEND-EXTENSIONS-SECURITY-SCRIPTS"><div class="titlepage"><div><div><h4 class="title">38.17.6.2. Замечания о безопасности скриптов расширений <a href="#EXTEND-EXTENSIONS-SECURITY-SCRIPTS" class="id_link">#</a></h4></div></div></div><p>Скрипт установки или обновления расширения следует защищать от атак, осуществляемых во время выполнения с использованием пути поиска. Если имя объекта, который должен использоваться в скрипте по замыслу автора, может быть разрешено в какой-либо другой объект, компрометация расширения произойдёт сразу либо позже, когда объект расширения будет использоваться.</p><p>Команды DDL, например <code class="command">CREATE FUNCTION</code> и <code class="command">CREATE OPERATOR CLASS</code>, в целом безопасны, но будьте бдительны в отношении команд, в которых фигурируют произвольные запросы и выражения. Например, требуют проверки команды <code class="command">CREATE VIEW</code>, а также выражения <code class="literal">DEFAULT</code> в <code class="command">CREATE FUNCTION</code>.</p><p>Иногда в скрипте расширения возникает потребность выполнить произвольный SQL, например, чтобы внести в каталог изменения, невозможные через DDL. В этом случае обязательно выполняйте такие команды с безопасным <code class="varname">search_path</code>; <span class="emphasis"><em>не</em></span> доверяйте пути, установленному при выполнении <code class="command">CREATE/ALTER EXTENSION</code>. Для этого рекомендуется временно сменить <code class="varname">search_path</code> на <code class="literal">'pg_catalog, pg_temp'</code> и добавить явные указания схемы, в которую устанавливается расширение, везде, где это требуется. (Этот приём также может быть полезен при создании представлений.) Практические примеры вы можете найти в модулях <code class="filename">contrib</code> в исходном коде <span class="productname">PostgreSQL</span>.</p><p>Ссылки на другие расширения крайне сложно полностью обезопасить, отчасти из-за отсутствия понимания, в какой схеме находится другое расширения. Риски уменьшаются, если оба расширения устанавливаются в одну схему, так как в этом случае зловредный объект не может оказаться перед объектами в схеме целевого расширения при используемом во время установки <code class="varname">search_path</code>. Однако в настоящее время нет механизма, который бы это требовал. Поэтому на данный момент рекомендуется не помечать расширение как доверенное, если оно зависит от других, не считая тех, что уже установлены в схему <code class="literal">pg_catalog</code>.</p></div></div><div class="sect2" id="EXTEND-EXTENSIONS-EXAMPLE"><div class="titlepage"><div><div><h3 class="title">38.17.7. Пример расширения <a href="#EXTEND-EXTENSIONS-EXAMPLE" class="id_link">#</a></h3></div></div></div><p>Здесь представлен полный пример расширения, в котором средствами исключительно <acronym class="acronym">SQL</acronym> реализуется составной тип с двумя элементами, который может сохранить в своих слотах значения любого типа, названные <span class="quote">«<span class="quote">k</span>»</span> и <span class="quote">«<span class="quote">v</span>»</span>. Для хранения все значения переводятся в текстовый формат (если они имеют другой формат).</p><p>Файл скрипта <code class="filename">pair--1.0.sql</code> выглядит так: </p><pre class="programlisting">
-- complain if script is sourced in psql, rather than via CREATE EXTENSION
\echo Use "CREATE EXTENSION pair" to load this file. \quit

CREATE TYPE pair AS ( k text, v text );

CREATE FUNCTION pair(text, text)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::@extschema@.pair;';

CREATE OPERATOR ~&gt; (LEFTARG = text, RIGHTARG = text, FUNCTION = pair);

-- "SET search_path" is easy to get right, but qualified names perform better.
CREATE FUNCTION lower(pair)
RETURNS pair LANGUAGE SQL
AS 'SELECT ROW(lower($1.k), lower($1.v))::@extschema@.pair;'
SET search_path = pg_temp;

CREATE FUNCTION pair_concat(pair, pair)
RETURNS pair LANGUAGE SQL
AS 'SELECT ROW($1.k OPERATOR(pg_catalog.||) $2.k,
               $1.v OPERATOR(pg_catalog.||) $2.v)::@extschema@.pair;';

</pre><p>Управляющий файл <code class="filename">pair.control</code> выглядит так: </p><pre class="programlisting"># расширение pair
comment = 'Тип данных для пары ключ/значение'
default_version = '1.0'
# расширение не может быть перемещаемым, так как использует @extschema@
relocatable = false</pre><p>Хотя вам вряд ли понадобится сборочный файл, только для того, чтобы установить эти два файла в нужный каталог, вы можете использовать <code class="filename">Makefile</code> следующего содержания: </p><pre class="programlisting">EXTENSION = pair
DATA = pair--1.0.sql

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)</pre><p> Этот Makefile опирается на инфраструктуру <acronym class="acronym">PGXS</acronym>, которая описывается в <a class="xref" href="extend-pgxs.html" title="38.18. Инфраструктура сборки расширений">Разделе 38.18</a>. С ним команда <code class="literal">make install</code> установит управляющий файл и скрипт в правильный каталог, который определит <span class="application">pg_config</span>.</p><p>Когда эти файлы будут установлены, выполните команду <code class="command">CREATE EXTENSION</code>, чтобы загрузить объекты в определённую базу данных.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="xindex.html" title="38.16. Интерфейсы расширений для индексов">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="extend.html" title="Глава 38. Расширение SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="extend-pgxs.html" title="38.18. Инфраструктура сборки расширений">След.</a></td></tr><tr><td width="40%" align="left" valign="top">38.16. Интерфейсы расширений для индексов </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 38.18. Инфраструктура сборки расширений</td></tr></table></div></body></html>