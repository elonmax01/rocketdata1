<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>14.2. Статистика, используемая планировщиком</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="using-explain.html" title="14.1. Использование EXPLAIN" /><link rel="next" href="explicit-joins.html" title="14.3. Управление планировщиком с помощью явных предложений JOIN" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">14.2. Статистика, используемая планировщиком</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="using-explain.html" title="14.1. Использование EXPLAIN">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="performance-tips.html" title="Глава 14. Оптимизация производительности">Наверх</a></td><th width="60%" align="center">Глава 14. Оптимизация производительности</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="explicit-joins.html" title="14.3. Управление планировщиком с помощью явных предложений JOIN">След.</a></td></tr></table><hr /></div><div class="sect1" id="PLANNER-STATS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">14.2. Статистика, используемая планировщиком <a href="#PLANNER-STATS" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="planner-stats.html#PLANNER-STATS-SINGLE-COLUMN">14.2.1. Статистика по одному столбцу</a></span></dt><dt><span class="sect2"><a href="planner-stats.html#PLANNER-STATS-EXTENDED">14.2.2. Расширенная статистика</a></span></dt></dl></div><a id="id-1.5.13.5.2" class="indexterm"></a><div class="sect2" id="PLANNER-STATS-SINGLE-COLUMN"><div class="titlepage"><div><div><h3 class="title">14.2.1. Статистика по одному столбцу <a href="#PLANNER-STATS-SINGLE-COLUMN" class="id_link">#</a></h3></div></div></div><p>Как было показано в предыдущем разделе, планировщик запросов должен оценить число строк, возвращаемых запросов, чтобы сделать правильный выбор в отношении плана запроса. В этом разделе кратко описывается статистика, которую использует система для этих оценок.</p><p>В частности, статистика включает общее число записей в каждой таблице и индексе, а также число дисковых блоков, которые они занимают. Эта информация содержится в таблице <a class="link" href="catalog-pg-class.html" title="53.11. pg_class"><code class="structname">pg_class</code></a>, в столбцах <code class="structfield">reltuples</code> и <code class="structfield">relpages</code>. Получить её можно, например так: </p><pre class="screen">
SELECT relname, relkind, reltuples, relpages
FROM pg_class
WHERE relname LIKE 'tenk1%';

       relname        | relkind | reltuples | relpages
----------------------+---------+-----------+----------
 tenk1                | r       |     10000 |      358
 tenk1_hundred        | i       |     10000 |       30
 tenk1_thous_tenthous | i       |     10000 |       30
 tenk1_unique1        | i       |     10000 |       30
 tenk1_unique2        | i       |     10000 |       30
(5 rows)
</pre><p> Здесь мы видим, что <code class="structname">tenk1</code> содержит 10000 строк данных и столько же строк в индексах (что неудивительно), но объём индексов гораздо меньше таблицы.</p><p>Для большей эффективности <code class="structfield">reltuples</code> и <code class="structfield">relpages</code> не пересчитываются «на лету», так что они обычно содержат несколько устаревшие значения. Их обновляют команды <code class="command">VACUUM</code>, <code class="command">ANALYZE</code> и несколько команд DDL, такие как <code class="command">CREATE INDEX</code>. <code class="command">VACUUM</code> и <code class="command">ANALYZE</code> могут не сканировать всю таблицу (и обычно так и делают), а только вычислить приращение <code class="structfield">reltuples</code> по части таблицы, так что результат остаётся приблизительным. В любом случае планировщик пересчитывает значения, полученные из <code class="structname">pg_class</code>, в пропорции к текущему физическому размеру таблицы и таким образом уточняет приближение.</p><a id="id-1.5.13.5.3.5" class="indexterm"></a><p>Большинство запросов возвращают не все строки таблицы, а только немногие из них, ограниченные условиями <code class="literal">WHERE</code>. Поэтому планировщику нужно оценить <em class="firstterm">избирательность</em> условий <code class="literal">WHERE</code>, то есть определить, какой процент строк будет соответствовать каждому условию в предложении <code class="literal">WHERE</code>. Нужная для этого информация хранится в системном каталоге <a class="link" href="catalog-pg-statistic.html" title="53.51. pg_statistic"><code class="structname">pg_statistic</code></a>. Значения в <code class="structname">pg_statistic</code> обновляются командами <code class="command">ANALYZE</code> и <code class="command">VACUUM ANALYZE</code> и никогда не бывают точными, даже сразу после обновления.</p><a id="id-1.5.13.5.3.7" class="indexterm"></a><p>Для исследования статистики лучше обращаться не непосредственно к таблице <code class="structname">pg_statistic</code>, а к представлению <a class="link" href="view-pg-stats.html" title="54.27. pg_stats"><code class="structname">pg_stats</code></a>, предназначенному для облегчения восприятия этой информации. Кроме того, представление <code class="structname">pg_stats</code> доступно для чтения всем, тогда как <code class="structname">pg_statistic</code> — только суперпользователям. (Это сделано для того, чтобы непривилегированные пользователи не могли ничего узнать о содержимом таблиц других людей из статистики. Представление <code class="structname">pg_stats</code> устроено так, что оно показывает строки только для тех таблиц, которые может читать данный пользователь.) Например, мы можем выполнить: </p><pre class="screen">
SELECT attname, inherited, n_distinct,
       array_to_string(most_common_vals, E'\n') as most_common_vals
FROM pg_stats
WHERE tablename = 'road';

 attname | inherited | n_distinct |          most_common_vals
---------+-----------+------------+------------------------------------
 name    | f         |  -0.363388 | I- 580                        Ramp+
         |           |            | I- 880                        Ramp+
         |           |            | Sp Railroad                       +
         |           |            | I- 580                            +
         |           |            | I- 680                        Ramp
 name    | t         |  -0.284859 | I- 880                        Ramp+
         |           |            | I- 580                        Ramp+
         |           |            | I- 680                        Ramp+
         |           |            | I- 580                            +
         |           |            | State Hwy 13                  Ramp
(2 rows)
</pre><p> Заметьте, что для одного столбца показываются две строки: одна соответствует полной иерархии наследования, построенной для таблицы <code class="literal">road</code> (<code class="literal">inherited</code>=<code class="literal">t</code>), и другая относится непосредственно к таблице <code class="literal">road</code> (<code class="literal">inherited</code>=<code class="literal">f</code>).</p><p>Объём информации, сохраняемой в <code class="structname">pg_statistic</code> командой <code class="command">ANALYZE</code>, в частности максимальное число записей в массивах <code class="structfield">most_common_vals</code> (самые популярные значения) и <code class="structfield">histogram_bounds</code> (границы гистограмм) для каждого столбца, можно ограничить на уровне столбцов с помощью команды <code class="command">ALTER TABLE SET STATISTICS</code> или глобально, установив параметр конфигурации <a class="xref" href="runtime-config-query.html#GUC-DEFAULT-STATISTICS-TARGET">default_statistics_target</a>. В настоящее время ограничение по умолчанию равно 100 записям. Увеличивая этот предел, можно увеличить точность оценок планировщика, особенно для столбцов с нерегулярным распределением данных, ценой большего объёма <code class="structname">pg_statistic</code> и, возможно, увеличения времени расчёта этой статистики. И напротив, для столбцов с простым распределением данных может быть достаточно меньшего предела.</p><p>Подробнее использование статистики планировщиком описывается в <a class="xref" href="planner-stats-details.html" title="Глава 76. Как планировщик использует статистику">Главе 76</a>.</p></div><div class="sect2" id="PLANNER-STATS-EXTENDED"><div class="titlepage"><div><div><h3 class="title">14.2.2. Расширенная статистика <a href="#PLANNER-STATS-EXTENDED" class="id_link">#</a></h3></div></div></div><a id="id-1.5.13.5.4.2" class="indexterm"></a><a id="id-1.5.13.5.4.3" class="indexterm"></a><a id="id-1.5.13.5.4.4" class="indexterm"></a><a id="id-1.5.13.5.4.5" class="indexterm"></a><p>Часто наблюдается картина, когда медленное выполнение запросов объясняется плохим выбором плана из-за того, что несколько столбцов, фигурирующих в условиях запроса, оказываются связанными. Обычно планировщик полагает, что несколько условий не зависят друг от друга, а это предположение оказывается неверным, когда значения этих столбцов коррелируют. Обычная статистика, которая по природе своей строится по отдельным столбцам, не может выявить корреляции между столбцами. Однако <span class="productname">PostgreSQL</span> имеет возможность вычислять <em class="firstterm">многовариантную статистику</em>, которая может собирать необходимую для этого информацию.</p><p>Так как число возможных комбинаций столбцов очень велико, автоматически вычислять многовариантную статистику непрактично. Вместо этого можно создать <em class="firstterm">объекты расширенной статистики</em>, чаще называемые просто <em class="firstterm">объектами статистики</em>, чтобы сервер собирал статистику по некоторым наборам столбцов, представляющим интерес.</p><p>Объекты статистики создаются командой <a class="link" href="sql-createstatistics.html" title="CREATE STATISTICS"><code class="command">CREATE STATISTICS</code></a>. При создании такого объекта просто добавляется запись в каталоге, выражающая востребованность этой статистики. Собственно сбор данных выполняется процедурой <code class="command">ANALYZE</code> (запускаемой вручную или автоматически в фоновом процессе). Изучить собранные значения можно в каталоге <a class="link" href="catalog-pg-statistic-ext-data.html" title="53.53. pg_statistic_ext_data"><code class="structname">pg_statistic_ext_data</code></a>.</p><p>Команда <code class="command">ANALYZE</code> вычисляет расширенную статистику по той же выборке строк таблицы, которая используется и для вычисления обычной статистики по отдельным столбцам. Так как размер выборки увеличивается с увеличением целевого ограничения статистики для таблицы или любых её столбцов (как описано в предыдущем разделе), при большем целевом ограничении обычно получается более точная расширенная статистика, но и времени на её вычисление требуется больше.</p><p>В следующих подразделах описываются виды расширенной статистики, поддерживаемые в настоящее время.</p><div class="sect3" id="PLANNER-STATS-EXTENDED-FUNCTIONAL-DEPS"><div class="titlepage"><div><div><h4 class="title">14.2.2.1. Функциональные зависимости <a href="#PLANNER-STATS-EXTENDED-FUNCTIONAL-DEPS" class="id_link">#</a></h4></div></div></div><p>Простейший вид расширенной статистики отслеживает <em class="firstterm">функциональные зависимости</em> (это понятие используется в определении нормальных форм баз данных). Мы называем столбец <code class="structfield">b</code> функционально зависимым от столбца <code class="structfield">a</code>, если знания значения <code class="structfield">a</code> достаточно для определения значения <code class="structfield">b</code>, то есть не существует двух строк с одинаковыми значениями <code class="structfield">a</code>, но разными значениями <code class="structfield">b</code>. В полностью нормализованной базе данных функциональные зависимости должны существовать только в первичных ключах и суперключах. Однако на практике многие наборы данных не нормализуются полностью по разным причинам; например, денормализация часто производится намеренно по соображениям производительности.</p><p>Существование функциональных зависимостей напрямую влияет на точность оценок в определённых запросах. Если запрос содержит условия как по независимым, так и по зависимым столбцам, условия по зависимым столбцам дополнительно не сокращают размер результата. Однако без знания о функциональной зависимости планировщик запросов будет полагать, что все условия независимы, и недооценит размер результата.</p><p>Для информирования планировщика о функциональных зависимостях команда <code class="command">ANALYZE</code> может собирать показатели зависимостей между столбцами. Оценить степень зависимости между всеми наборами столбцов обошлось бы непозволительно дорого, поэтому сбор данных ограничивается только теми группами столбцов, которые фигурируют вместе в объекте статистики, определённом со свойством <code class="literal">dependencies</code>. Во избежание ненужных издержек при выполнении <code class="command">ANALYZE</code> и последующем планировании запросов статистику с <code class="literal">dependencies</code> рекомендуется создавать только для групп сильно коррелирующих столбцов.</p><p>Взгляните на пример сбора статистики функциональной зависимости: </p><pre class="programlisting">CREATE STATISTICS stts (dependencies) ON city, zip FROM zipcodes;

ANALYZE zipcodes;

SELECT stxname, stxkeys, stxddependencies
  FROM pg_statistic_ext join pg_statistic_ext_data on (oid = stxoid)
  WHERE stxname = 'stts';
 stxname | stxkeys |             stxddependencies
---------+---------+------------------------------------------
 stts    | 1 5     | {"1 =&gt; 5": 1.000000, "5 =&gt; 1": 0.423130}
(1 row)</pre><p> В показанном случае столбец 1 (код zip) полностью определяет столбец 5 (city), так что коэффициент равен 1.0, тогда как город (столбец city) определяет код ZIP только в 42% всех случаев, что означает, что многие города (58%) представлены несколькими кодами ZIP.</p><p>При вычислении избирательности запроса, в котором задействованы функционально зависимые столбцы, планировщик корректирует оценки избирательности по условиям, используя коэффициенты зависимостей, чтобы не допустить недооценки размера результата.</p><div class="sect4" id="PLANNER-STATS-EXTENDED-FUNCTIONAL-DEPS-LIMITS"><div class="titlepage"><div><div><h5 class="title">14.2.2.1.1. Ограничения функциональных зависимостей <a href="#PLANNER-STATS-EXTENDED-FUNCTIONAL-DEPS-LIMITS" class="id_link">#</a></h5></div></div></div><p>Функциональные зависимости в настоящее время применяются только при рассмотрении простых условий с равенствами, сравнивающих значения столбцов с константами, и условиями <code class="literal">IN</code> с константами. Они не используются для улучшения оценок при проверке равенства двух столбцов или сравнении столбца с выражением, а также в условиях с диапазоном, условиях <code class="literal">LIKE</code> или любых других видах условий.</p><p>Рассматривая функциональные зависимости, планировщик предполагает, что условия по задействованным столбцам совместимы и таким образом избыточны. Если условия несовместимы, правильной оценкой должен быть ноль строк, но эта возможность не рассматривается. Например, с таким запросом </p><pre class="programlisting">SELECT * FROM zipcodes WHERE city = 'San Francisco' AND zip = '94105';</pre><p> планировщик отбросит условие с <code class="structfield">city</code>, так как оно не влияет на избирательность, что верно. Однако он сделает то же предположение и в таком случае: </p><pre class="programlisting">SELECT * FROM zipcodes WHERE city = 'San Francisco' AND zip = '90210';</pre><p> хотя на самом деле этому запросу будет удовлетворять ноль строк. Но статистика функциональной зависимости не даёт достаточно информации, чтобы прийти к такому заключению.</p><p>Во многих практических ситуациях это предположение обычно удовлетворяется; например, графический интерфейс приложения для последующего формирования запроса может не допускать выбор несовместимого сочетания города и кода ZIP. Но когда это не так, статистика функциональной зависимости может не подойти.</p></div></div><div class="sect3" id="PLANNER-STATS-EXTENDED-N-DISTINCT-COUNTS"><div class="titlepage"><div><div><h4 class="title">14.2.2.2. Многовариантное число различных значений <a href="#PLANNER-STATS-EXTENDED-N-DISTINCT-COUNTS" class="id_link">#</a></h4></div></div></div><p>Статистика по одному столбцу содержит число различных значений в каждом отдельном столбце. Оценки числа различных значений в сочетании нескольких столбцов (например, в <code class="literal">GROUP BY a, b</code>) часто оказываются ошибочными, когда планировщик имеет статистические данные только по отдельным столбцам, что приводит к выбору плохих планов.</p><p>Для улучшения таких оценок операция <code class="command">ANALYZE</code> может собирать статистику по различным значениям для группы столбцов. Как и ранее, это непрактично делать для каждой возможной группы столбцов, так что данные собираются только по тем группам столбцов, которые указаны в определении объекта статистики, создаваемого со свойством <code class="literal">ndistinct</code>. Данные будут собираться по всем возможным сочетаниям из двух или нескольких столбцов из перечисленных в определении.</p><p>В продолжение предыдущего примера, количества различных значений в таблице ZIP-кодов могут выглядеть так: </p><pre class="programlisting">CREATE STATISTICS stts2 (ndistinct) ON city, state, zip FROM zipcodes;

ANALYZE zipcodes;

SELECT stxkeys AS k, stxdndistinct AS nd
  FROM pg_statistic_ext join pg_statistic_ext_data on (oid = stxoid)
  WHERE stxname = 'stts2';
-[ RECORD 1 ]------------------------------------------------------​--
k  | 1 2 5
nd | {"1, 2": 33178, "1, 5": 33178, "2, 5": 27435, "1, 2, 5": 33178}
(1 row)</pre><p> Как видно, есть три комбинации столбцов, имеющих 33178 различных значений: код ZIP и штат; код ZIP и город; код ZIP, город и штат (то, что все эти числа равны, ожидаемый факт, так как сам по себе код ZIP в этой таблице уникален). С другой стороны, сочетание города и штата даёт только 27435 различных значений.</p><p>Объект статистики <code class="literal">ndistinct</code> рекомендуется создавать только для тех сочетаний столбцов, которые действительно используются при группировке, и только когда неправильная оценка числа групп может привести к выбору плохих планов. В противном случае усилия, потраченные на выполнение <code class="command">ANALYZE</code>, будут напрасными.</p></div><div class="sect3" id="PLANNER-STATS-EXTENDED-MCV-LISTS"><div class="titlepage"><div><div><h4 class="title">14.2.2.3. Многовариантные списки MCV <a href="#PLANNER-STATS-EXTENDED-MCV-LISTS" class="id_link">#</a></h4></div></div></div><p>Ещё один тип статистики, сохраняемой для каждого столбца, представляют списки частых значений. Такие списки позволяют получать очень точную оценку для отдельных столбцов, но для запросов, содержащих условия с несколькими столбцами, полученная по ним оценка может быть значительно искажена.</p><p>Для улучшения таких оценок операция <code class="command">ANALYZE</code> может собирать списки MCV по комбинациям столбцов. Подобно статистике функциональных зависимостей и различных значений, такую статистику непрактично собирать для каждой возможной группировки столбцов. В данном случае это ещё более актуально, так как списки MCV (в отличие от двух упомянутых статистик) содержат распространённые значения столбцов. Поэтому данные для них собираются только по тем группам столбцов, которые фигурируют в объекте статистики, определённом с указанием <code class="literal">mcv</code>.</p><p>В продолжение предыдущего примера, список MCV для таблицы ZIP-кодов может выглядеть следующим образом (в отличие от более простых типов статистики, для его анализа требуется применить функцию): </p><pre class="programlisting">CREATE STATISTICS stts3 (mcv) ON city, state FROM zipcodes;

ANALYZE zipcodes;

SELECT m.* FROM pg_statistic_ext join pg_statistic_ext_data on (oid = stxoid),
                pg_mcv_list_items(stxdmcv) m WHERE stxname = 'stts3';

 index |         values         | nulls | frequency | base_frequency
-------+------------------------+-------+-----------+----------------
     0 | {Washington, DC}       | {f,f} |  0.003467 |        2.7e-05
     1 | {Apo, AE}              | {f,f} |  0.003067 |        1.9e-05
     2 | {Houston, TX}          | {f,f} |  0.002167 |       0.000133
     3 | {El Paso, TX}          | {f,f} |     0.002 |       0.000113
     4 | {New York, NY}         | {f,f} |  0.001967 |       0.000114
     5 | {Atlanta, GA}          | {f,f} |  0.001633 |        3.3e-05
     6 | {Sacramento, CA}       | {f,f} |  0.001433 |        7.8e-05
     7 | {Miami, FL}            | {f,f} |    0.0014 |          6e-05
     8 | {Dallas, TX}           | {f,f} |  0.001367 |        8.8e-05
     9 | {Chicago, IL}          | {f,f} |  0.001333 |        5.1e-05
   ...
(99 rows)</pre><p> Выводимая информация показывает, что наиболее распространённую комбинацию города и штата образует Washington и DC, с частотой около 0.35% (в объёме выборки). Базовая частота этой комбинации (вычисленная из частот значений в отдельных столбцах) составляет всего 0.0027%, то есть эта оценка оказывается заниженной на два порядка.</p><p>Объекты статистики <acronym class="acronym">MCV</acronym> рекомендуется создавать только для тех сочетаний столбцов, которые действительно используются в условиях вместе, и только когда неправильная оценка числа групп может привести к выбору плохих планов. В противном случае усилия, потраченные на выполнение <code class="command">ANALYZE</code> и планирование, будут напрасными.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="using-explain.html" title="14.1. Использование EXPLAIN">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="performance-tips.html" title="Глава 14. Оптимизация производительности">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="explicit-joins.html" title="14.3. Управление планировщиком с помощью явных предложений JOIN">След.</a></td></tr><tr><td width="40%" align="left" valign="top">14.1. Использование <code class="command">EXPLAIN</code> </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 14.3. Управление планировщиком с помощью явных предложений <code class="literal">JOIN</code></td></tr></table></div></body></html>