<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>69.4. Реализация</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="spgist-extensibility.html" title="69.3. Расширяемость" /><link rel="next" href="spgist-examples.html" title="69.5. Примеры" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">69.4. Реализация</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="spgist-extensibility.html" title="69.3. Расширяемость">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="spgist.html" title="Глава 69. Индексы SP-GiST">Наверх</a></td><th width="60%" align="center">Глава 69. Индексы SP-GiST</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="spgist-examples.html" title="69.5. Примеры">След.</a></td></tr></table><hr /></div><div class="sect1" id="SPGIST-IMPLEMENTATION"><div class="titlepage"><div><div><h2 class="title" style="clear: both">69.4. Реализация <a href="#SPGIST-IMPLEMENTATION" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="spgist-implementation.html#SPGIST-LIMITS">69.4.1. Ограничения SP-GiST</a></span></dt><dt><span class="sect2"><a href="spgist-implementation.html#SPGIST-NULL-LABELS">69.4.2. SP-GiST без меток узлов</a></span></dt><dt><span class="sect2"><a href="spgist-implementation.html#SPGIST-ALL-THE-SAME">69.4.3. Внутренние кортежи <span class="quote">«<span class="quote">все-равны</span>»</span></a></span></dt></dl></div><p>В этом разделе освещаются тонкости реализации и особенности, о которых полезно знать тем, кто будет реализовывать классы операторов <acronym class="acronym">SP-GiST</acronym>.</p><div class="sect2" id="SPGIST-LIMITS"><div class="titlepage"><div><div><h3 class="title">69.4.1. Ограничения SP-GiST <a href="#SPGIST-LIMITS" class="id_link">#</a></h3></div></div></div><p>Отдельные кортежи листьев и внутренние кортежи должны умещаться в одной странице индекса (по умолчанию её размер 8 Кбайт). Таким образом при индексировании значений типов данных переменной длины большие значения могут поддерживаться только такими схемами, как префиксные деревья, в которых каждый уровень дерева включает префикс, достаточно короткий для помещения в страницу, и на конечном уровне листьев содержится суффикс, который также достаточно мал, чтобы поместиться в странице. Класс операторов должен устанавливать признак <code class="structfield">longValuesOK</code>, только если он готов организовывать такую структуру. Если этот признак не установлен, ядро <acronym class="acronym">SP-GiST</acronym> не примет запрос на индексацию значения, которое слишком велико для одной страницы индекса.</p><p>Также класс операторов должен отвечать за то, чтобы внутренние кортежи при расширении не выходили за пределы страницы индекса; это ограничивает число дочерних узлов, которые могут принадлежать одному внутреннему кортежу, а также максимальный размер значения префикса.</p><p>Ещё одно ограничение состоит в том, что когда узел внутреннего кортежа указывает на набор кортежей листьев, все эти кортежи должны находиться в одной странице индекса. (Это конструктивное ограничение введено для оптимизации позиционирования и экономии места на ссылках, связывающих такие кортежи вместе.) Если набор кортежей листьев оказывается слишком большим для одной страницы, выполняется разделение и вставляется промежуточный внутренний кортеж. Чтобы устранить возникшую проблему, новый внутренний кортеж <span class="emphasis"><em>должен</em></span> разделять набор значений в листе на несколько групп узлов. Если функция <code class="function">picksplit</code> класса операторов не может сделать это, ядро <acronym class="acronym">SP-GiST</acronym> переходит к чрезвычайным мерам, описанным в <a class="xref" href="spgist-implementation.html#SPGIST-ALL-THE-SAME" title="69.4.3. Внутренние кортежи «все-равны»">Подразделе 69.4.3</a>.</p><p>Когда <code class="structfield">longValuesOK</code> имеет значение true, ожидается, что последующие уровни дерева <acronym class="acronym">SP-GiST</acronym> будут включать всё больше и больше информации в префиксы и метки узлов внутренних кортежей, постепенно уменьшая значение, которое нужно сохранить на уровне листьев, чтобы оно в конце концов уместилось на странице. Чтобы в случае ошибки в классах операторах исключить бесконечные циклы при добавлении записи, ядро <acronym class="acronym">SP-GiST</acronym> выдаст ошибку, если значение для листа не уменьшится за 10 вызовов метода <code class="function">choose</code>.</p></div><div class="sect2" id="SPGIST-NULL-LABELS"><div class="titlepage"><div><div><h3 class="title">69.4.2. SP-GiST без меток узлов <a href="#SPGIST-NULL-LABELS" class="id_link">#</a></h3></div></div></div><p>В некоторых древовидных схемах каждый внутренний кортеж содержит фиксированный набор узлов; например, в дереве квадрантов это всегда четыре узла, соответствующие четырём квадрантам вокруг центральной точки внутреннего кортежа. В таком случае код обычно работает с узлами по номерам и необходимости в явных метках узлов нет. Чтобы убрать метки узлов (и таким образом сэкономить место), функция <code class="function">picksplit</code> может возвратить NULL вместо массива <code class="structfield">nodeLabels</code>, а функция <code class="function">choose</code> аналогично может возвратить NULL вместо массива <code class="structfield">prefixNodeLabels</code> во время действия <code class="literal">spgSplitTuple</code>. В результате при последующих вызовах функций <code class="function">choose</code> и <code class="function">inner_consistent</code> им вместо <code class="structfield">nodeLabels</code> будет передаваться NULL. В принципе метки узлов могут применяться для одних внутренних кортежей и отсутствовать у других в том же индексе.</p><p>Когда внутренний кортеж содержит узлы без меток, функция <code class="function">choose</code> не может выбрать действие <code class="literal">spgAddNode</code>, так как в этом случае предполагается, что набор узлов фиксированный.</p></div><div class="sect2" id="SPGIST-ALL-THE-SAME"><div class="titlepage"><div><div><h3 class="title">69.4.3. Внутренние кортежи <span class="quote">«<span class="quote">все-равны</span>»</span> <a href="#SPGIST-ALL-THE-SAME" class="id_link">#</a></h3></div></div></div><p>Ядро <acronym class="acronym">SP-GiST</acronym> может переопределить результаты функции <code class="function">picksplit</code> класса операторов, когда эта функция не может разделить поступившие значения листьев на минимум две категории узлов. Когда это происходит, создаётся новый внутренний кортеж с несколькими узлами, каждый из которых имеет одну метку (если имеет), которую <code class="function">picksplit</code> дала одному узлу, а значения листьев распределяются случайно между этими равнозначными узлами. Для этого внутреннего кортежа устанавливается флаг <code class="literal">allTheSame</code>, который предупреждает функции <code class="function">choose</code> и <code class="function">inner_consistent</code>, что кортеж не содержит набор узлов, который они обычно ожидают.</p><p>Когда обрабатывается кортеж с флагом <code class="literal">allTheSame</code>, выбранное функцией <code class="function">choose</code> действие <code class="literal">spgMatchNode</code> воспринимается как указание, что новое значение можно присвоить одному из равнозначных узлов; код ядра будет игнорировать полученное значение <code class="structfield">nodeN</code> и спустится в один из узлов, выбранный случайно (чтобы дерево было сбалансированным). Будет считаться ошибкой, если <code class="function">choose</code> выберет действие <code class="literal">spgAddNode</code>, так как при этом не все узлы окажутся равны; если добавляемое значение не соответствует существующим узлам, должно выбираться действие <code class="literal">spgSplitTuple</code>.</p><p>Также, когда обрабатывается кортеж с флагом <code class="literal">allTheSame</code>, функция <code class="function">inner_consistent</code> должна вернуть все или не возвращать никакие узлы для продолжения поиска по индексу, так как все узлы равнозначны. Для этого может потребоваться, а может и не потребоваться код обработки особого случая, в зависимости от того, как <code class="function">inner_consistent</code> обычно воспринимает узлы.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="spgist-extensibility.html" title="69.3. Расширяемость">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="spgist.html" title="Глава 69. Индексы SP-GiST">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="spgist-examples.html" title="69.5. Примеры">След.</a></td></tr><tr><td width="40%" align="left" valign="top">69.3. Расширяемость </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 69.5. Примеры</td></tr></table></div></body></html>