<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CREATE AGGREGATE</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sql-create-access-method.html" title="CREATE ACCESS METHOD" /><link rel="next" href="sql-createcast.html" title="CREATE CAST" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">CREATE AGGREGATE</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-create-access-method.html" title="CREATE ACCESS METHOD">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><th width="60%" align="center">Команды SQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-createcast.html" title="CREATE CAST">След.</a></td></tr></table><hr /></div><div class="refentry" id="SQL-CREATEAGGREGATE"><div class="titlepage"></div><a id="id-1.9.3.57.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">CREATE AGGREGATE</span></h2><p>CREATE AGGREGATE — создать агрегатную функцию</p></div><div class="refsynopsisdiv"><h2>Синтаксис</h2><pre class="synopsis">CREATE [ OR REPLACE ] AGGREGATE <em class="replaceable"><code>имя</code></em> ( [ <em class="replaceable"><code>режим_аргумента</code></em> ] [ <em class="replaceable"><code>имя_аргумента</code></em> ] <em class="replaceable"><code>тип_данных_аргумента</code></em> [ , ... ] ) (
    SFUNC = <em class="replaceable"><code>функция_состояния</code></em>,
    STYPE = <em class="replaceable"><code>тип_данных_состояния</code></em>
    [ , SSPACE = <em class="replaceable"><code>размер_данных_состояния</code></em> ]
    [ , FINALFUNC = <em class="replaceable"><code>функция_завершения</code></em> ]
    [ , FINALFUNC_EXTRA ]
    [ , FINALFUNC_MODIFY = { READ_ONLY | SHAREABLE | READ_WRITE } ]
    [ , COMBINEFUNC = <em class="replaceable"><code>комбинирующая_функция</code></em> ]
    [ , SERIALFUNC = <em class="replaceable"><code>функция_сериализации</code></em> ]
    [ , DESERIALFUNC = <em class="replaceable"><code>функция_десериализации</code></em> ]
    [ , INITCOND = <em class="replaceable"><code>начальное_условие</code></em> ]
    [ , MSFUNC = <em class="replaceable"><code>функция_состояния_движ</code></em> ]
    [ , MINVFUNC = <em class="replaceable"><code>обратная_функция_движ</code></em> ]
    [ , MSTYPE = <em class="replaceable"><code>тип_данных_состояния_движ</code></em> ]
    [ , MSSPACE = <em class="replaceable"><code>размер_данных_состояния_движ</code></em> ]
    [ , MFINALFUNC = <em class="replaceable"><code>функция_завершения_движ</code></em> ]
    [ , MFINALFUNC_EXTRA ]
    [ , MFINALFUNC_MODIFY = { READ_ONLY | SHAREABLE | READ_WRITE } ]
    [ , MINITCOND = <em class="replaceable"><code>начальное_условие_движ</code></em> ]
    [ , SORTOP = <em class="replaceable"><code>оператор_сортировки</code></em> ]
    [ , PARALLEL = { SAFE | RESTRICTED | UNSAFE } ]
)

CREATE [ OR REPLACE ] AGGREGATE <em class="replaceable"><code>имя</code></em> ( [ [ <em class="replaceable"><code>режим_аргумента</code></em> ] [ <em class="replaceable"><code>имя_аргумента</code></em> ] <em class="replaceable"><code>тип_данных_аргумента</code></em> [ , ... ] ]
                        ORDER BY [ <em class="replaceable"><code>режим_аргумента</code></em> ] [ <em class="replaceable"><code>имя_аргумента</code></em> ] <em class="replaceable"><code>тип_данных_аргумента</code></em> [ , ... ] ) (
    SFUNC = <em class="replaceable"><code>функция_состояния</code></em>,
    STYPE = <em class="replaceable"><code>тип_данных_состояния</code></em>
    [ , SSPACE = <em class="replaceable"><code>размер_данных_состояния</code></em> ]
    [ , FINALFUNC = <em class="replaceable"><code>функция_завершения</code></em> ]
    [ , FINALFUNC_EXTRA ]
    [ , FINALFUNC_MODIFY = { READ_ONLY | SHAREABLE | READ_WRITE } ]
    [ , INITCOND = <em class="replaceable"><code>начальное_условие</code></em> ]
    [ , PARALLEL = { SAFE | RESTRICTED | UNSAFE } ]
    [ , HYPOTHETICAL ]
)

<span class="phrase">или старый синтаксис</span>

CREATE [ OR REPLACE ] AGGREGATE <em class="replaceable"><code>имя</code></em> (
    BASETYPE = <em class="replaceable"><code>базовый_тип</code></em>,
    SFUNC = <em class="replaceable"><code>функция_состояния</code></em>,
    STYPE = <em class="replaceable"><code>тип_данных_состояния</code></em>
    [ , SSPACE = <em class="replaceable"><code>размер_данных_состояния</code></em> ]
    [ , FINALFUNC = <em class="replaceable"><code>функция_завершения</code></em> ]
    [ , FINALFUNC_EXTRA ]
    [ , FINALFUNC_MODIFY = { READ_ONLY | SHAREABLE | READ_WRITE } ]
    [ , COMBINEFUNC = <em class="replaceable"><code>комбинирующая_функция</code></em> ]
    [ , SERIALFUNC = <em class="replaceable"><code>функция_сериализации</code></em> ]
    [ , DESERIALFUNC = <em class="replaceable"><code>функция_десериализации</code></em> ]
    [ , INITCOND = <em class="replaceable"><code>начальное_условие</code></em> ]
    [ , MSFUNC = <em class="replaceable"><code>функция_состояния_движ</code></em> ]
    [ , MINVFUNC = <em class="replaceable"><code>обратная_функция_движ</code></em> ]
    [ , MSTYPE = <em class="replaceable"><code>тип_данных_состояния_движ</code></em> ]
    [ , MSSPACE = <em class="replaceable"><code>размер_данных_состояния_движ</code></em> ]
    [ , MFINALFUNC = <em class="replaceable"><code>функция_завершения_движ</code></em> ]
    [ , MFINALFUNC_EXTRA ]
    [ , MFINALFUNC_MODIFY = { READ_ONLY | SHAREABLE | READ_WRITE } ]
    [ , MINITCOND = <em class="replaceable"><code>начальное_условие_движ</code></em> ]
    [ , SORTOP = <em class="replaceable"><code>оператор_сортировки</code></em> ]
)</pre></div><div class="refsect1" id="id-1.9.3.57.5"><h2>Описание</h2><p><code class="command">CREATE AGGREGATE</code> создаёт новую агрегатную функцию, а <code class="command">CREATE OR REPLACE AGGREGATE</code> создаёт новую или заменяет определение уже существующей агрегатной функции. Некоторое количество базовых и часто используемых агрегатных функций включено в дистрибутив; они описаны в <a class="xref" href="functions-aggregate.html" title="9.21. Агрегатные функции">Разделе 9.21</a>. Но если нужно адаптировать их к новым типам или создать недостающие агрегатные функции, это можно сделать с помощью команды <code class="command">CREATE AGGREGATE</code>.</p><p>При замене существующего определения изменить типы и количество непосредственных аргументов, а также тип результата нельзя. Кроме того, новое определение должно быть того же вида (обычный, сортирующий или гипотезирующий агрегат), что и старое.</p><p>Если указывается имя схемы (например, <code class="literal">CREATE AGGREGATE myschema.myagg ...</code>), агрегатная функция создаётся в указанной схеме. В противном случае она создаётся в текущей схеме.</p><p>Агрегатная функция идентифицируется по имени и типам входных данных. Две агрегатных функции в одной схеме могут иметь одно имя, только если они работают с разными типами данных. Имя и тип(ы) входных данных агрегата не могут совпадать с именем и типами данных любой другой обычной функции в той же схеме. Это же правило действует при перегрузке имён обычных функций (см. <a class="xref" href="sql-createfunction.html" title="CREATE FUNCTION"><span class="refentrytitle">CREATE FUNCTION</span></a>).</p><p>Простую агрегатную функцию образуют одна или две обычные функции: функция перехода состояния <em class="replaceable"><code>функция_состояния</code></em> и необязательная функция окончательного вычисления <em class="replaceable"><code>функция_завершения</code></em>. Они используются следующим образом: </p><pre class="programlisting"><em class="replaceable"><code>функция_состояния</code></em>( внутреннее-состояние, следующие-значения-данных ) ---&gt; следующее-внутреннее-состояние
<em class="replaceable"><code>функция_завершения</code></em>( внутреннее-состояние ) ---&gt; агрегатное_значение</pre><p><span class="productname">PostgreSQL</span> создаёт временную переменную типа <em class="replaceable"><code>тип_данных_состояния</code></em> для хранения текущего внутреннего состояния агрегата. Затем для каждой поступающей строки вычисляются значения аргументов агрегата и вызывается функция перехода состояния с текущим значением состояния и полученными аргументами; эта функция вычисляет следующее внутреннее состояние. Когда таким образом будут обработаны все строки, вызывается завершающая функция, которая должна вычислить возвращаемое значение агрегата. Если функция завершения отсутствует, просто возвращается конечное значение состояния.</p><p>Агрегатная функция может определить начальное условие, то есть начальное значение для внутренней переменной состояния. Это значение задаётся и сохраняется в базе данных в виде строки типа <code class="type">text</code>, но оно должно быть допустимым внешним представлением константы типа данных переменной состояния. По умолчанию начальным значением состояния считается NULL.</p><p>Если функция перехода состояния объявлена как <span class="quote">«<span class="quote">strict</span>»</span> (строгая), её нельзя вызывать с входными значениями NULL. В этом случае агрегатная функция выполняется следующим образом. Строки со значениями NULL игнорируются (функция перехода не вызывается и предыдущее значение состояния не меняется) и если начальное состояние равно NULL, то в первой же строке, в которой все входные значения не NULL, первый аргумент заменяет значение состояния, а функция перехода вызывается для каждой последующей строки, в которой все входные значения не NULL. Это поведение удобно для реализации таких агрегатных функций, как <code class="function">max</code>. Заметьте, что такое поведение возможно, только если <em class="replaceable"><code>тип_данных_состояния</code></em> совпадает с первым <em class="replaceable"><code>типом_данных_аргумента</code></em>. Если же эти типы различаются, необходимо задать начальное условие не NULL или использовать нестрогую функцию перехода состояния.</p><p>Если функция перехода состояния не является строгой, она вызывается безусловно для каждой поступающей строки и должна сама обрабатывать вводимые значения и переменную состояния, равные NULL. Это позволяет разработчику агрегатной функции полностью управлять тем, как она воспринимает значения NULL.</p><p>Если функция завершения объявлена как <span class="quote">«<span class="quote">strict</span>»</span> (строгая), она не будет вызвана при конечном значении состояния, равном NULL; вместо этого автоматически возвращается результат NULL. (Разумеется, это вполне нормальное поведение для строгих функций.) Когда функция завершения вызывается, она в любом случае может возвратить значение NULL. Например, функция завершения для <code class="function">avg</code> возвращает NULL, если определяет, что было обработано ноль строк.</p><p>Иногда бывает полезно объявить функцию завершения как принимающую не только состояние, но и дополнительные параметры, соответствующие входным данным агрегата. В основном это имеет смысл для полиморфных функций завершения, которым может быть недостаточно знать тип данных только переменной состояния, чтобы вывести тип результата. Эти дополнительные параметры всегда передаются как NULL (так что функция завершения не должна быть строгой, когда применяется <code class="literal">FINALFUNC_EXTRA</code>), но в остальном это обычные параметры. Функция завершения может выяснить фактические типы аргументов в текущем вызове, воспользовавшись системным вызовом <code class="function">get_fn_expr_argtype</code>.</p><p>Агрегатная функция может дополнительно поддерживать <em class="firstterm">режим движущегося агрегата</em>, как описано в <a class="xref" href="xaggr.html#XAGGR-MOVING-AGGREGATES" title="38.12.1. Режим движущегося агрегата">Подразделе 38.12.1</a>. Для этого режима требуются параметры <code class="literal">MSFUNC</code>, <code class="literal">MINVFUNC</code> и <code class="literal">MSTYPE</code>, а также могут задаваться <code class="literal">MSSPACE</code>, <code class="literal">MFINALFUNC</code>, <code class="literal">MFINALFUNC_EXTRA</code>, <code class="literal">MFINALFUNC_MODIFY</code> и <code class="literal">MINITCOND</code>. За исключением <code class="literal">MINVFUNC</code>, эти параметры работают как соответствующие параметры простого агрегата без начальной буквы <code class="literal">M</code>; они определяют отдельную реализацию агрегата, включающую функцию обратного перехода.</p><p>Если в список параметров добавлено указание <code class="literal">ORDER BY</code>, создаётся особый типа агрегата, называемый <em class="firstterm">сортирующим агрегатом</em>; с указанием <code class="literal">HYPOTHETICAL</code> создаётся <em class="firstterm">гипотезирующий агрегат</em>. Эти агрегаты работают с группами отсортированных значений и зависят от порядка сортировки, поэтому определение порядка сортировки входных данных является неотъемлемой частью их вызова. Кроме того, они могут иметь <em class="firstterm">непосредственные</em> аргументы, которые вычисляются единожды для всей процедуры агрегирования, а не для каждой поступающей строки. Гипотезирующие агрегаты представляют собой подкласс сортирующих агрегатов, в которых непосредственные аргументы должны совпадать, по количеству и типам данных, с агрегируемыми аргументами. Это позволяет добавить значения этих непосредственных аргументов в набор агрегируемых строк в качестве дополнительной <span class="quote">«<span class="quote">гипотетической</span>»</span> строки.</p><p>Агрегатная функция может дополнительно поддерживать <em class="firstterm">частичное агрегирование</em>, как описано в <a class="xref" href="xaggr.html#XAGGR-PARTIAL-AGGREGATES" title="38.12.4. Частичное агрегирование">Подразделе 38.12.4</a>. Для этого требуется задать параметр <code class="literal">COMBINEFUNC</code>. Если в качестве <em class="replaceable"><code>типа_данных_состояния</code></em> выбран <code class="type">internal</code>, обычно уместно также задать <code class="literal">SERIALFUNC</code> и <code class="literal">DESERIALFUNC</code>, чтобы было возможно параллельное агрегирование. Заметьте, что для параллельного агрегирования агрегатная функция также должна быть помечена как <code class="literal">PARALLEL SAFE</code> (безопасная для распараллеливания).</p><p>Агрегаты, работающие подобно <code class="function">MIN</code> и <code class="function">MAX</code>, иногда можно соптимизировать, заменив сканирование всех строк таблицы обращением к индексу. Если агрегат подлежит такой оптимизации, это можно указать, определив <em class="firstterm">оператор сортировки</em>. Основное требование при этом: агрегат должен выдавать в результате первый элемент по порядку сортировки, задаваемому оператором; другими словами: </p><pre class="programlisting">SELECT agg(col) FROM tab;</pre><p> должно быть равнозначно: </p><pre class="programlisting">SELECT col FROM tab ORDER BY col USING sortop LIMIT 1;</pre><p> Дополнительно предполагается, что агрегат игнорирует значения NULL и возвращает NULL, только если строк со значениями не NULL не нашлось. Обычно оператор <code class="literal">&lt;</code> является подходящим оператором сортировки для <code class="function">MIN</code>, а <code class="literal">&gt;</code> — для <code class="function">MAX</code>. Заметьте, что обращение к индексу может дать эффект, только если заданный оператор реализует стратегию <span class="quote">«<span class="quote">меньше</span>»</span> или <span class="quote">«<span class="quote">больше</span>»</span> в классе операторов индекса-B-дерева.</p><p>Чтобы создать агрегатную функцию, необходимо иметь право <code class="literal">USAGE</code> для типов аргументов, типа(ов) состояния и типа результата, а также право <code class="literal">EXECUTE</code> для опорных функций.</p></div><div class="refsect1" id="id-1.9.3.57.6"><h2>Параметры</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>имя</code></em></span></dt><dd><p>Имя создаваемой агрегатной функции (возможно, дополненное схемой).</p></dd><dt><span class="term"><em class="replaceable"><code>режим_аргумента</code></em></span></dt><dd><p>Режим аргумента: <code class="literal">IN</code> или <code class="literal">VARIADIC</code>. (Агрегатные функции не поддерживают выходные аргументы (<code class="literal">OUT</code>).) По умолчанию подразумевается <code class="literal">IN</code>. Режим <code class="literal">VARIADIC</code> может быть указан только последним.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_аргумента</code></em></span></dt><dd><p>Имя аргумента. В настоящее время используется только в целях документирования. Если опущено, соответствующий аргумент будет безымянным.</p></dd><dt><span class="term"><em class="replaceable"><code>тип_данных_аргумента</code></em></span></dt><dd><p>Тип входных данных, с которым работает эта агрегатная функция. Для создания агрегатной функции без аргументов вставьте <code class="literal">*</code> вместо списка с определениями аргументов. (Пример такой агрегатной функции: <code class="function">count(*)</code>.)</p></dd><dt><span class="term"><em class="replaceable"><code>базовый_тип</code></em></span></dt><dd><p>В прежнем синтаксисе <code class="command">CREATE AGGREGATE</code> тип входных данных задавался параметром <code class="literal">basetype</code>, а не записывался после имени агрегата. Это позволяло указать только один входной параметр. Чтобы определить функцию без аргументов, используя этот синтаксис, в качестве значения <code class="literal">basetype</code> нужно указать <code class="literal">"ANY"</code> (не <code class="literal">*</code>). Создать сортирующий агрегат старый синтаксис не позволял.</p></dd><dt><span class="term"><em class="replaceable"><code>функция_состояния</code></em></span></dt><dd><p>Имя функции перехода состояния, вызываемой для каждой входной строки. Для обычных агрегатных функций с <em class="replaceable"><code>N</code></em> аргументами, <em class="replaceable"><code>функция_состояния</code></em> должна принимать <em class="replaceable"><code>N</code></em>+1 аргумент, первый должен иметь тип <em class="replaceable"><code>тип_данных_состояния</code></em>, а остальные — типы соответствующих входных данных. Возвращать она должна значение типа <em class="replaceable"><code>тип_данных_состояния</code></em>. Эта функция принимает текущее значение состояния и текущие значения входных данных, и возвращает следующее значение состояния.</p><p>В сортирующих (и в том числе, гипотезирующих) агрегатах функция перехода состояния получает только текущее значение состояния и агрегируемые аргументы, без непосредственных аргументов. Других отличий у неё нет.</p></dd><dt><span class="term"><em class="replaceable"><code>тип_данных_состояния</code></em></span></dt><dd><p>Тип данных значения состояния для агрегатной функции.</p></dd><dt><span class="term"><em class="replaceable"><code>размер_данных_состояния</code></em></span></dt><dd><p>Средний размер значения состояния агрегата (в байтах). Если этот параметр опущен или равен нулю, применяемая оценка по умолчанию определяется по <em class="replaceable"><code>типу_данных_состояния</code></em>. Планировщик использует это значение для оценивания объёма памяти, требуемого для агрегатного запроса с группировкой.</p></dd><dt><span class="term"><em class="replaceable"><code>функция_завершения</code></em></span></dt><dd><p>Имя функции завершения, вызываемой для вычисления результата агрегатной функции после обработки всех входных строк. Для обычного агрегата эта функция должна принимать единственный аргумент типа <em class="replaceable"><code>тип_данных_состояния</code></em>. Возвращаемым типом агрегата будет тип, который возвращает эта функция. Если <em class="replaceable"><code>функция_завершения</code></em> не указана, результатом агрегата будет конечное значение состояния, а типом результата — <em class="replaceable"><code>тип_данных_состояния</code></em>.</p><p>В сортирующих (и в том числе, гипотезирующих) агрегатах функция завершения получает не только конечное значение состояния, но и значения всех непосредственных аргументов.</p><p>Если команда содержит указание <code class="literal">FINALFUNC_EXTRA</code>, то в дополнение к конечному значению состояния и всем непосредственным аргументам функция завершения получает добавочные значения NULL, соответствующие обычным (агрегируемым) аргументам агрегата. Это в основном полезно для правильного определения типа результата при создании полиморфной агрегатной функции.</p></dd><dt><span class="term"><code class="literal">FINALFUNC_MODIFY</code> = { <code class="literal">READ_ONLY</code> | <code class="literal">SHAREABLE</code> | <code class="literal">READ_WRITE</code> }</span></dt><dd><p>Этот параметр указывает, является ли функция завершения чистой функцией, которая не изменяет свои аргументы. Это свойство функции передаёт значение <code class="literal">READ_ONLY</code>; два других значения показывают, что она может менять значение переходного состояния. Подробнее об этом говорится в разделе <a class="xref" href="sql-createaggregate.html#SQL-CREATEAGGREGATE-NOTES" title="Замечания">Замечания</a> ниже. По умолчанию подразумевается значение <code class="literal">READ_ONLY</code>, за исключением сортирующих агрегатов (для них значение по умолчанию — <code class="literal">READ_WRITE</code>).</p></dd><dt><span class="term"><em class="replaceable"><code>комбинирующая_функция</code></em></span></dt><dd><p>Дополнительно может быть указана <em class="replaceable"><code>комбинирующая_функция</code></em>, чтобы агрегатная функция поддерживала частичное агрегирование. Если задаётся, <em class="replaceable"><code>комбинирующая_функция</code></em> должна комбинировать два значения <em class="replaceable"><code>типа_данных_состояния</code></em>, содержащих результат агрегирования по некоторому подмножеству входных значений, и вычислять новое значение <em class="replaceable"><code>типа_данных_состояния</code></em>, представляющее результат агрегирования по обоим множествам данных. Эту функцию можно считать своего рода <em class="replaceable"><code>функцией_состояния</code></em>, которая вместо обработки отдельной входной строки и включения её данных в текущее агрегируемое состояние включает некоторое агрегированное состояние в текущее.</p><p>Указанная <em class="replaceable"><code>комбинирующая_функция</code></em> должна быть объявлена как принимающая два аргумента <em class="replaceable"><code>типа_данных_состояния</code></em> и возвращающая значение <em class="replaceable"><code>типа_данных_состояния</code></em>. Эта функция дополнительно может быть объявлена <span class="quote">«<span class="quote">строгой</span>»</span>. В этом случае данная функция не будет вызываться, когда одно из входных состояний — NULL; в качестве корректного результата будет выдано другое состояние.</p><p>Для агрегатных функций, у которых <em class="replaceable"><code>тип_данных_состояния</code></em> — <code class="type">internal</code>, <em class="replaceable"><code>комбинирующая_функция</code></em> не должна быть <span class="quote">«<span class="quote">строгой</span>»</span>. При этом <em class="replaceable"><code>комбинирующая_функция</code></em> должна позаботиться о том, чтобы состояния NULL обрабатывались корректно и возвращаемое состояние располагалось в контексте памяти агрегирования.</p></dd><dt><span class="term"><em class="replaceable"><code>функция_сериализации</code></em></span></dt><dd><p>Агрегатная функция, у которой <em class="replaceable"><code>тип_данных_состояния</code></em> — <code class="type">internal</code>, может участвовать в параллельном агрегировании, только если для неё задана <em class="replaceable"><code>функция_сериализации</code></em>, которая должна сериализовать агрегатное состояние в значение <code class="type">bytea</code> для передачи другому процессу. Эта функция должна принимать один аргумент типа <code class="type">internal</code> и возвращать тип <code class="type">bytea</code>. Также при этом нужно задать соответствующую <em class="replaceable"><code>функцию_десериализации</code></em>.</p></dd><dt><span class="term"><em class="replaceable"><code>функция_десериализации</code></em></span></dt><dd><p>Десериализует ранее сериализованное агрегатное состояние обратно в <em class="replaceable"><code>тип_данных_состояния</code></em>. Эта функция должна принимать два аргумента типов <code class="type">bytea</code> и <code class="type">internal</code> и выдавать результат типа <code class="type">internal</code>. (Замечание: второй аргумент типа <code class="type">internal</code> не используется, но требуется из соображений типобезопасности.)</p></dd><dt><span class="term"><em class="replaceable"><code>начальное_условие</code></em></span></dt><dd><p>Начальное значение переменной состояния. Оно должно задаваться строковой константой в форме, пригодной для ввода в <em class="replaceable"><code>тип_данных_состояния</code></em>. Если не указано, начальным значением состояния будет NULL.</p></dd><dt><span class="term"><em class="replaceable"><code>функция_состояния_движ</code></em></span></dt><dd><p>Имя функции прямого перехода состояния, вызываемой для каждой входной строки в режиме движущегося агрегата. Это точно такая же функция, как и обычная функция перехода, но её первый аргумент и результат имеют тип <em class="replaceable"><code>тип_данных_состояния_движ</code></em>, который может отличаться от типа <em class="replaceable"><code>тип_данных_состояния</code></em>.</p></dd><dt><span class="term"><em class="replaceable"><code>обратная_функция_движ</code></em></span></dt><dd><p>Имя функции обратного перехода состояния, применяемой в режиме движущегося агрегата. У этой функции те же типы аргумента и результатов, что и у <em class="replaceable"><code>функции_состояния_движ</code></em>, но она предназначена не для добавления, а для удаления значения из текущего состояния агрегата. Функция обратного перехода должна иметь ту же характеристику строгости, что и функция прямого перехода.</p></dd><dt><span class="term"><em class="replaceable"><code>тип_данных_состояния_движ</code></em></span></dt><dd><p>Тип данных значения состояния для агрегатной функции в режиме движущегося агрегата.</p></dd><dt><span class="term"><em class="replaceable"><code>размер_данных_состояния_движ</code></em></span></dt><dd><p>Примерный размер значения состояния в режиме движущегося агрегата. Он имеет то же значение, что и <em class="replaceable"><code>размер_данных_состояния</code></em>.</p></dd><dt><span class="term"><em class="replaceable"><code>функция_завершения_движ</code></em></span></dt><dd><p>Имя функции завершения, вызываемой в режиме движущегося агрегата для вычисления результата агрегатной функции после обработки всех входных строк. Она работает так же, как <em class="replaceable"><code>функция_завершения</code></em>, но её первый аргумент имеет тип <em class="replaceable"><code>тип_данных_состояния_движ</code></em>, а дополнительными пустыми аргументами управляет параметр <code class="literal">MFINALFUNC_EXTRA</code>. Тип результата, который определяет <em class="replaceable"><code>функция_завершения_движ</code></em>, или <em class="replaceable"><code>тип_данных_состояния_движ</code></em>, должен совпадать с типом результата обычной реализации агрегата.</p></dd><dt><span class="term"><code class="literal">MFINALFUNC_MODIFY</code> = { <code class="literal">READ_ONLY</code> | <code class="literal">SHAREABLE</code> | <code class="literal">READ_WRITE</code> }</span></dt><dd><p>Этот параметр подобен <code class="literal">FINALFUNC_MODIFY</code>, но описывает поведение функции завершения для движущегося агрегата.</p></dd><dt><span class="term"><em class="replaceable"><code>начальное_условие_движ</code></em></span></dt><dd><p>Начальное значение переменной состояния в режиме движущегося агрегата. Оно применяется так же, как <em class="replaceable"><code>начальное_условие</code></em>.</p></dd><dt><span class="term"><em class="replaceable"><code>оператор_сортировки</code></em></span></dt><dd><p>Связанный оператор сортировки для реализации агрегатов, подобных <code class="function">MIN</code> или <code class="function">MAX</code>. Здесь указывается просто имя оператора (возможно, дополненное схемой). Предполагается, что оператор поддерживает те же типы входных данных, что и агрегат (который должен быть обычным и иметь один аргумент).</p></dd><dt><span class="term"><code class="literal">PARALLEL =</code> { <code class="literal">SAFE</code> | <code class="literal">RESTRICTED</code> | <code class="literal">UNSAFE</code> }</span></dt><dd><p>Указания <code class="literal">PARALLEL SAFE</code>, <code class="literal">PARALLEL RESTRICTED</code> и <code class="literal">PARALLEL UNSAFE</code> имеют те же значения, что и в <a class="link" href="sql-createfunction.html" title="CREATE FUNCTION"><code class="command">CREATE FUNCTION</code></a>. Агрегатная функция не будет считаться распараллеливаемой, если она имеет характеристику <code class="literal">PARALLEL UNSAFE</code> (она подразумевается по умолчанию!) или <code class="literal">PARALLEL RESTRICTED</code>. Заметьте, что планировщик не обращает внимание на допустимость распараллеливания опорных функций агрегата, а учитывает только характеристику самой агрегатной функции.</p></dd><dt><span class="term"><code class="literal">HYPOTHETICAL</code></span></dt><dd><p>Этот признак, допустимый только для сортирующих агрегатов, указывает, что агрегатные аргументы должны обрабатываться согласно требованиям гипотезирующих агрегатов: то есть последние несколько непосредственных аргументов должны соответствовать по типам агрегатным аргументам (<code class="literal">WITHIN GROUP</code>). Признак <code class="literal">HYPOTHETICAL</code> не влияет на поведение во время выполнения, он учитывается только при разрешении типов данных и правил сортировки аргументов.</p></dd></dl></div><p>Параметры <code class="command">CREATE AGGREGATE</code> могут записываться в любом порядке, не обязательно так, как показано выше.</p></div><div class="refsect1" id="SQL-CREATEAGGREGATE-NOTES"><h2>Замечания</h2><p>В параметрах, определяющих имена вспомогательных функций, при необходимости можно написать имя схемы, например: <code class="literal">SFUNC = public.sum</code>. Однако типы аргументов там не указываются — типы аргументов вспомогательных функций определяются другими параметрами.</p><p>Обычно функции PostgreSQL должны быть действительно функциями, не меняющими свои входные значения. Однако функциям агрегатного перехода, <span class="emphasis"><em>используемым в контексте агрегатной функции</em></span>, разрешено действовать хитрее и изменять аргумент с переходным состоянием на месте. Это может дать значительный выигрыш в скорости по сравнению с созданием новой копии переходного состояния при каждом вызове.</p><p>Подобным образом, хотя функция завершения агрегата обычно не должна изменять свои входные значения, иногда может быть полезно допустить изменение аргумента с переходным состоянием. Соответствующее поведение должно обозначаться параметром <code class="literal">FINALFUNC_MODIFY</code>. Его значение <code class="literal">READ_WRITE</code> показывает, что функция завершения модифицирует переходное состояние неопределённым образом. При этом значении предотвращается использование агрегата в качестве оконной функции, а также не допускается объединение переходных состояний при вызове агрегатов с одинаковыми входными данными и функциями перехода. Значение <code class="literal">SHAREABLE</code> указывает, что функцию перехода нельзя применять после функции завершения, но с конечным значением состояния могут быть выполнены несколько вызовов функции завершения. При этом значении предотвращается использование агрегата в качестве оконной функции, но переходные состояния могут объединяться. (То есть оптимизация в данном случае состоит не в многократном применении одной функции завершения, а в применении различных функций завершения к одному и тому же конечному переходному состоянию. Это допускается, только если ни одна из функций завершения не помечена как <code class="literal">READ_WRITE</code>.)</p><p>Если агрегатная функция поддерживает режим движущегося агрегата, это увеличивает эффективность вычислений, когда она применяется в качестве оконной функции для окна с движущимся началом рамки (то есть когда начало определяется не как <code class="literal">UNBOUNDED PRECEDING</code>). По сути, функция прямого перехода добавляет входные значения к состоянию агрегата, когда они поступают в рамку окна снизу, а функция обратного перехода снова вычитает их, когда они покидают рамку сверху. Поэтому вычитаются значения в том же порядке, в каком добавлялись. Когда бы ни вызывалась функция обратного перехода, она таким образом получит первое из добавленных, но ещё не удалённых значений аргумента. Функция обратного перехода может рассчитывать на то, что после того, как она удалит самые старые данные, в текущем состоянии останется ещё как минимум одна строка. (Когда это правило могло бы нарушиться, механизм оконных функций просто начинает агрегировать данные заново, а не вызывает функцию обратного перехода.)</p><p>Функция прямого перехода для режима движущегося агрегата не может возвращать NULL в качестве нового значения состояния. Если NULL возвращает функция обратного перехода, это показывает, что она не может произвести обратное вычисление для этих конкретных данных, и что вычисление агрегата следует выполнить заново от начальной позиции текущей рамки. Благодаря этому соглашению, режим движущегося агрегата можно использовать, даже если иногда возникают ситуации, в которых обратный расчёт состояния производить непрактично.</p><p>Агрегатную функцию можно использовать с движущимися рамками и без реализации движущегося агрегата, но при этом <span class="productname">PostgreSQL</span> будет заново агрегировать все данные при каждом перемещении начала рамки. Заметьте, что вне зависимости от того, поддерживает ли агрегатная функция режим движущегося агрегата, <span class="productname">PostgreSQL</span> может обойтись без повторных вычислений при сдвиге конца рамки; новые значения просто продолжают добавляться в состояние агрегата. Именно поэтому для использования агрегата в качестве оконной функции требуется, чтобы функция завершения была только читающей: она не должна изменять значение состояния агрегата, чтобы агрегирование могло продолжаться и после получения результата для набора строк в определённой рамке.</p><p>Синтаксис сортирующих агрегатных функций позволяет указать <code class="literal">VARIADIC</code> и в последнем непосредственном параметре, и в последнем агрегатном (<code class="literal">WITHIN GROUP</code>). Однако в текущей реализации на применение <code class="literal">VARIADIC</code> накладываются два ограничения. Во-первых, в сортирующих агрегатах можно использовать только <code class="literal">VARIADIC "any"</code>, но не другие типы переменных массивов. Во-вторых, если последним непосредственным аргументом является <code class="literal">VARIADIC "any"</code>, то допускается только один агрегатный аргумент и это тоже должен быть <code class="literal">VARIADIC "any"</code>. (В представлении, используемом в системных каталогах, эти два параметра объединяются в один элемент <code class="literal">VARIADIC "any"</code>, так как в <code class="structname">pg_proc</code> нельзя представить функцию с несколькими параметрами <code class="literal">VARIADIC</code>.) Если агрегатная функция является гипотезирующей, непосредственные аргументы, соответствующие параметру <code class="literal">VARIADIC "any"</code>, будут гипотетическими; любые предшествующие параметры представляют дополнительные непосредственные аргументы, которые могут не соответствовать агрегатным.</p><p>В настоящее время сортирующие агрегатные функции не поддерживают режим движущегося агрегата, так как их нельзя применять в качестве оконных функций.</p><p>Частичное (в том числе, параллельное) агрегирование в настоящее время не поддерживается для сортирующих агрегатных функций. Также оно никогда не будет применяться для агрегатных вызовов с предложениями <code class="literal">DISTINCT</code> или <code class="literal">ORDER BY</code>, так как они по природе своей не могут быть реализованы с частичным агрегированием.</p></div><div class="refsect1" id="id-1.9.3.57.8"><h2>Примеры</h2><p>См. <a class="xref" href="xaggr.html" title="38.12. Пользовательские агрегатные функции">Раздел 38.12</a>.</p></div><div class="refsect1" id="id-1.9.3.57.9"><h2>Совместимость</h2><p>Оператор <code class="command">CREATE AGGREGATE</code> является языковым расширением <span class="productname">PostgreSQL</span>. В стандарте SQL не предусмотрено создание пользовательских агрегатных функций.</p></div><div class="refsect1" id="id-1.9.3.57.10"><h2>См. также</h2><span class="simplelist"><a class="xref" href="sql-alteraggregate.html" title="ALTER AGGREGATE"><span class="refentrytitle">ALTER AGGREGATE</span></a>, <a class="xref" href="sql-dropaggregate.html" title="DROP AGGREGATE"><span class="refentrytitle">DROP AGGREGATE</span></a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-create-access-method.html" title="CREATE ACCESS METHOD">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-createcast.html" title="CREATE CAST">След.</a></td></tr><tr><td width="40%" align="left" valign="top">CREATE ACCESS METHOD </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> CREATE CAST</td></tr></table></div></body></html>