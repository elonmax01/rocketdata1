<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>5.9. Схемы</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="ddl-rowsecurity.html" title="5.8. Политики защиты строк" /><link rel="next" href="ddl-inherit.html" title="5.10. Наследование" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">5.9. Схемы</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="ddl-rowsecurity.html" title="5.8. Политики защиты строк">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="ddl.html" title="Глава 5. Определение данных">Наверх</a></td><th width="60%" align="center">Глава 5. Определение данных</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="ddl-inherit.html" title="5.10. Наследование">След.</a></td></tr></table><hr /></div><div class="sect1" id="DDL-SCHEMAS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">5.9. Схемы <a href="#DDL-SCHEMAS" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="ddl-schemas.html#DDL-SCHEMAS-CREATE">5.9.1. Создание схемы</a></span></dt><dt><span class="sect2"><a href="ddl-schemas.html#DDL-SCHEMAS-PUBLIC">5.9.2. Схема public</a></span></dt><dt><span class="sect2"><a href="ddl-schemas.html#DDL-SCHEMAS-PATH">5.9.3. Путь поиска схемы</a></span></dt><dt><span class="sect2"><a href="ddl-schemas.html#DDL-SCHEMAS-PRIV">5.9.4. Схемы и права</a></span></dt><dt><span class="sect2"><a href="ddl-schemas.html#DDL-SCHEMAS-CATALOG">5.9.5. Схема системного каталога</a></span></dt><dt><span class="sect2"><a href="ddl-schemas.html#DDL-SCHEMAS-PATTERNS">5.9.6. Шаблоны использования</a></span></dt><dt><span class="sect2"><a href="ddl-schemas.html#DDL-SCHEMAS-PORTABILITY">5.9.7. Переносимость</a></span></dt></dl></div><a id="id-1.5.4.11.2" class="indexterm"></a><p>Кластер баз данных <span class="productname">PostgreSQL</span> содержит один или несколько именованных экземпляров баз. На уровне кластера создаются роли и некоторые другие объекты. При этом в рамках одного подключения к серверу можно обращаться к данным только одной базы — той, что была выбрана при установлении соединения.</p><div class="note"><h3 class="title">Примечание</h3><p>Пользователи кластера не обязательно будут иметь доступ ко всем базам данных этого кластера. Тот факт, что роли создаются на уровне кластера, означает только то, что в кластере не может быть двух ролей <code class="literal">joe</code> в разных базах данных, хотя система позволяет ограничить доступ <code class="literal">joe</code> только некоторыми базами данных.</p></div><p>База данных содержит одну или несколько именованных <em class="firstterm">схем</em>, которые в свою очередь содержат таблицы. Схемы также содержат именованные объекты других видов, включая типы данных, функции и операторы. Одно и то же имя объекта можно свободно использовать в разных схемах, например и <code class="literal">schema1</code>, и <code class="literal">myschema</code> могут содержать таблицы с именем <code class="literal">mytable</code>. В отличие от баз данных, схемы не ограничивают доступ к данным: пользователи могут обращаться к объектам в любой схеме текущей базы данных, если им назначены соответствующие права.</p><p>Есть несколько возможных объяснений, для чего стоит применять схемы: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Чтобы одну базу данных могли использовать несколько пользователей, независимо друг от друга.</p></li><li class="listitem"><p>Чтобы объединить объекты базы данных в логические группы для облегчения управления ими.</p></li><li class="listitem"><p>Чтобы в одной базе сосуществовали разные приложения, и при этом не возникало конфликтов имён.</p></li></ul></div><p> Схемы в некотором смысле подобны каталогам в операционной системе, но они не могут быть вложенными.</p><div class="sect2" id="DDL-SCHEMAS-CREATE"><div class="titlepage"><div><div><h3 class="title">5.9.1. Создание схемы <a href="#DDL-SCHEMAS-CREATE" class="id_link">#</a></h3></div></div></div><a id="id-1.5.4.11.7.2" class="indexterm"></a><p>Для создания схемы используется команда <a class="xref" href="sql-createschema.html" title="CREATE SCHEMA"><span class="refentrytitle">CREATE SCHEMA</span></a>. При этом вы определяете имя схемы по своему выбору, например так: </p><pre class="programlisting">CREATE SCHEMA myschema;</pre><a id="id-1.5.4.11.7.4" class="indexterm"></a><a id="id-1.5.4.11.7.5" class="indexterm"></a><p>Чтобы создать объекты в схеме или обратиться к ним, указывайте <em class="firstterm">полное имя</em>, состоящее из имён схемы и объекта, разделённых точкой: </p><pre class="synopsis">
<em class="replaceable"><code>схема</code></em><code class="literal">.</code><em class="replaceable"><code>таблица</code></em>
</pre><p> Этот синтаксис работает везде, где ожидается имя таблицы, включая команды модификации таблицы и команды обработки данных, обсуждаемые в следующих главах. (Для краткости мы будем говорить только о таблицах, но всё это распространяется и на другие типы именованных объектов, например, типы и функции.)</p><p>Есть ещё более общий синтаксис </p><pre class="synopsis">
<em class="replaceable"><code>база_данных</code></em><code class="literal">.</code><em class="replaceable"><code>схема</code></em><code class="literal">.</code><em class="replaceable"><code>таблица</code></em>
</pre><p>но в настоящее время он поддерживается только для формального соответствия стандарту SQL. Если вы указываете базу данных, это может быть только база данных, к которой вы подключены.</p><p>Таким образом, создать таблицу в новой схеме можно так: </p><pre class="programlisting">CREATE TABLE myschema.mytable (
 ...
);</pre><a id="id-1.5.4.11.7.9" class="indexterm"></a><p>Чтобы удалить пустую схему (не содержащую объектов), выполните: </p><pre class="programlisting">DROP SCHEMA myschema;</pre><p> Удалить схему со всеми содержащимися в ней объектами можно так: </p><pre class="programlisting">DROP SCHEMA myschema CASCADE;</pre><p> Стоящий за этим общий механизм описан в <a class="xref" href="ddl-depend.html" title="5.14. Отслеживание зависимостей">Разделе 5.14</a>.</p><p>Часто бывает нужно создать схему, владельцем которой будет другой пользователь (это один из способов ограничения пользователей пространствами имён). Сделать это можно так: </p><pre class="programlisting">CREATE SCHEMA <em class="replaceable"><code>имя_схемы</code></em> AUTHORIZATION <em class="replaceable"><code>имя_пользователя</code></em>;</pre><p> Вы даже можете опустить имя схемы, в этом случае именем схемы станет имя пользователя. Как это можно применять, описано в <a class="xref" href="ddl-schemas.html#DDL-SCHEMAS-PATTERNS" title="5.9.6. Шаблоны использования">Подразделе 5.9.6</a>.</p><p>Схемы с именами, начинающимися с <code class="literal">pg_</code>, являются системными; пользователям не разрешено использовать такие имена.</p></div><div class="sect2" id="DDL-SCHEMAS-PUBLIC"><div class="titlepage"><div><div><h3 class="title">5.9.2. Схема public <a href="#DDL-SCHEMAS-PUBLIC" class="id_link">#</a></h3></div></div></div><a id="id-1.5.4.11.8.2" class="indexterm"></a><p>До этого мы создавали таблицы, не указывая никакие имена схем. По умолчанию такие таблицы (и другие объекты) автоматически помещаются в схему <span class="quote">«<span class="quote">public</span>»</span>. Она содержится во всех создаваемых базах данных. Таким образом, команда: </p><pre class="programlisting">CREATE TABLE products ( ... );</pre><p> эквивалентна: </p><pre class="programlisting">CREATE TABLE public.products ( ... );</pre></div><div class="sect2" id="DDL-SCHEMAS-PATH"><div class="titlepage"><div><div><h3 class="title">5.9.3. Путь поиска схемы <a href="#DDL-SCHEMAS-PATH" class="id_link">#</a></h3></div></div></div><a id="id-1.5.4.11.9.2" class="indexterm"></a><a id="id-1.5.4.11.9.3" class="indexterm"></a><a id="id-1.5.4.11.9.4" class="indexterm"></a><p>Везде писать полные имена утомительно, и часто всё равно лучше не привязывать приложения к конкретной схеме. Поэтому к таблицам обычно обращаются по <em class="firstterm">неполному имени</em>, состоящему просто из имени таблицы. Система определяет, какая именно таблица подразумевается, используя <em class="firstterm">путь поиска</em>, который представляет собой список просматриваемых схем. Подразумеваемой таблицей считается первая подходящая таблица, найденная в схемах пути. Если подходящая таблица не найдена, возникает ошибка, даже если таблица с таким именем есть в других схемах базы данных.</p><p>Возможность создавать одноимённые объекты в разных схемах усложняет написание запросов, которые должны всегда обращаться к конкретным объектам. Это также потенциально позволяет пользователям влиять на поведение запросов других пользователей, злонамеренно или случайно. Ввиду преобладания неполных имён в запросах и их использования внутри <span class="productname">PostgreSQL</span>, добавить схему в <code class="varname">search_path</code> — по сути значит доверять всем пользователям, имеющим право <code class="literal">CREATE</code> в этой схеме. Когда вы выполняете обычный запрос, злонамеренный пользователь может создать объекты в схеме, включённой в ваш путь поиска, и таким образом перехватывать управление и выполнять произвольные функции SQL как если бы их выполняли вы.</p><a id="id-1.5.4.11.9.7" class="indexterm"></a><p>Первая схема в пути поиска называется текущей. Эта схема будет использоваться не только при поиске, но и при создании объектов — она будет включать таблицы, созданные командой <code class="command">CREATE TABLE</code> без указания схемы.</p><a id="id-1.5.4.11.9.9" class="indexterm"></a><p>Чтобы узнать текущий тип поиска, выполните следующую команду: </p><pre class="programlisting">SHOW search_path;</pre><p> В конфигурации по умолчанию она возвращает: </p><pre class="screen">
 search_path
--------------
 "$user", public
</pre><p> Первый элемент ссылается на схему с именем текущего пользователя. Если такой схемы не существует, ссылка на неё игнорируется. Второй элемент ссылается на схему public, которую мы уже видели.</p><p>Первая существующая схема в пути поиска также считается схемой по умолчанию для новых объектов. Именно поэтому по умолчанию объекты создаются в схеме public. При указании неполной ссылки на объект в любом контексте (при модификации таблиц, изменении данных или в запросах) система просматривает путь поиска, пока не найдёт соответствующий объект. Таким образом, в конфигурации по умолчанию неполные имена могут относиться только к объектам в схеме public.</p><p>Чтобы добавить в путь нашу новую схему, мы выполняем: </p><pre class="programlisting">SET search_path TO myschema,public;</pre><p> (Мы опускаем компонент <code class="literal">$user</code>, так как здесь в нём нет необходимости.) Теперь мы можем обращаться к таблице без указания схемы: </p><pre class="programlisting">DROP TABLE mytable;</pre><p> И так как <code class="literal">myschema</code> — первый элемент в пути, новые объекты будут по умолчанию создаваться в этой схеме.</p><p>Мы можем также написать: </p><pre class="programlisting">SET search_path TO myschema;</pre><p> Тогда мы больше не сможем обращаться к схеме public, не написав полное имя объекта. Единственное, что отличает схему public от других, это то, что она существует по умолчанию, хотя её так же можно удалить.</p><p>В <a class="xref" href="functions-info.html" title="9.26. Системные информационные функции и операторы">Разделе 9.26</a> вы узнаете, как ещё можно манипулировать путём поиска схем.</p><p>Как и для имён таблиц, путь поиска аналогично работает для имён типов данных, имён функций и имён операторов. Имена типов данных и функций можно записать в полном виде так же, как и имена таблиц. Если же вам нужно использовать в выражении полное имя оператора, для этого есть специальный способ — вы должны написать: </p><pre class="synopsis">
<code class="literal">OPERATOR(</code><em class="replaceable"><code>схема</code></em><code class="literal">.</code><em class="replaceable"><code>оператор</code></em><code class="literal">)</code>
</pre><p> Такая запись необходима для избежания синтаксической неоднозначности. Пример такого выражения: </p><pre class="programlisting">SELECT 3 OPERATOR(pg_catalog.+) 4;</pre><p> На практике пользователи часто полагаются на путь поиска, чтобы не приходилось писать такие замысловатые конструкции.</p></div><div class="sect2" id="DDL-SCHEMAS-PRIV"><div class="titlepage"><div><div><h3 class="title">5.9.4. Схемы и права <a href="#DDL-SCHEMAS-PRIV" class="id_link">#</a></h3></div></div></div><a id="id-1.5.4.11.10.2" class="indexterm"></a><p>По умолчанию пользователь не может обращаться к объектам в чужих схемах. Чтобы изменить это, владелец схемы должен дать пользователю право <code class="literal">USAGE</code> для данной схемы. По умолчанию все пользователи имеют это право для схемы <code class="literal">public</code>. Чтобы пользователи могли использовать объекты схемы, может понадобиться назначить дополнительные права на уровне объектов.</p><p>Пользователю также можно разрешить создавать объекты в схеме, не принадлежащей ему. Для этого ему нужно дать право <code class="literal">CREATE</code> в требуемой схеме. В базах данных, обновлённых с <span class="productname">PostgreSQL</span> 14 или более ранней версии, все имеют это право в схеме <code class="literal">public</code>. Некоторые <a class="link" href="ddl-schemas.html#DDL-SCHEMAS-PATTERNS" title="5.9.6. Шаблоны использования">шаблоны использования</a> требуют запретить это: </p><pre class="programlisting">REVOKE CREATE ON SCHEMA public FROM PUBLIC;</pre><p> (Первое слово <span class="quote">«<span class="quote">public</span>»</span> обозначает схему, а второе означает <span class="quote">«<span class="quote">каждый пользователь</span>»</span>. В первом случае это идентификатор, а во втором — ключевое слово, поэтому они написаны в разном регистре; вспомните указания из <a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS" title="4.1.1. Идентификаторы и ключевые слова">Подраздела 4.1.1</a>.)</p></div><div class="sect2" id="DDL-SCHEMAS-CATALOG"><div class="titlepage"><div><div><h3 class="title">5.9.5. Схема системного каталога <a href="#DDL-SCHEMAS-CATALOG" class="id_link">#</a></h3></div></div></div><a id="id-1.5.4.11.11.2" class="indexterm"></a><p>В дополнение к схеме <code class="literal">public</code> и схемам, создаваемым пользователями, любая база данных содержит схему <code class="literal">pg_catalog</code>, в которой находятся системные таблицы и все встроенные типы данных, функции и операторы. <code class="literal">pg_catalog</code> фактически всегда является частью пути поиска. Если даже эта схема не добавлена в путь явно, она неявно просматривается <span class="emphasis"><em>до</em></span> всех схем, указанных в пути. Так обеспечивается доступность встроенных имён при любых условиях. Однако вы можете явным образом поместить <code class="literal">pg_catalog</code> в конец пути поиска, если вам нужно, чтобы пользовательские имена переопределяли встроенные.</p><p>Так как имена системных таблиц начинаются с <code class="literal">pg_</code>, такие имена лучше не использовать во избежание конфликта имён, возможного при появлении в будущем системной таблицы с тем же именем, что и ваша. (С путём поиска по умолчанию неполная ссылка будет воспринята как обращение к системной таблице.) Системные таблицы будут и дальше содержать в имени приставку <code class="literal">pg_</code>, так что они не будут конфликтовать с неполными именами пользовательских таблиц, если пользователи со своей стороны не будут использовать приставку <code class="literal">pg_</code>.</p></div><div class="sect2" id="DDL-SCHEMAS-PATTERNS"><div class="titlepage"><div><div><h3 class="title">5.9.6. Шаблоны использования <a href="#DDL-SCHEMAS-PATTERNS" class="id_link">#</a></h3></div></div></div><p>Схемам можно найти множество применений. Для защиты от влияния недоверенных пользователей на поведение запросов других пользователей предлагается <em class="firstterm">шаблон безопасного использования схем</em>, но если этот шаблон не применяется в базе данных, пользователи, желающие безопасно выполнять в ней запросы, должны будут принимать защитные меры в начале каждого сеанса. В частности, они должны начинать каждый сеанс с присваивания пустого значения переменной <code class="varname">search_path</code> или каким-либо другим образом удалять из <code class="varname">search_path</code> схемы, доступные для записи обычным пользователям. С конфигурацией по умолчанию легко реализуются следующие шаблоны использования: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Ограничить обычных пользователей личными схемами. Для реализации этого подхода сначала убедитесь, что ни у одной схемы нет права <code class="literal">CREATE</code>. Затем для каждого пользователя, который будет создавать не временные объекты, создайте схему с его именем, например <code class="literal">CREATE SCHEMA alice AUTHORIZATION alice</code>. (Как вы знаете, путь поиска по умолчанию начинается с имени <code class="literal">$user</code>, вместо которого подставляется имя пользователя. Таким образом, если у всех пользователей будет отдельная схема, они по умолчанию будут обращаться к собственным схемам.) Этот шаблон позволяет безопасно использовать схемы, только если никакой недоверенный пользователь не является владельцем базы данных и не получал право <code class="literal">ADMIN OPTION</code> для соответствующей роли. В противном случае безопасное использование схем невозможно.</p><p>В <span class="productname">PostgreSQL</span> 15 и выше этот подход использования поддерживается конфигурацией по умолчанию. В предыдущих версиях или при использовании базы данных, обновлённой с предыдущей версии, необходимо удалить право <code class="literal">CREATE</code> из схемы <code class="literal">public</code> (выполнить <code class="literal">REVOKE CREATE ON SCHEMA public FROM PUBLIC</code>). Затем проверьте, нет ли в схеме <code class="literal">public</code> объектов с такими же именами, как у объектов в схеме <code class="literal">pg_catalog</code>.</p></li><li class="listitem"><p>Удалить схему public из пути поиска по умолчанию, изменив <a class="link" href="config-setting.html#CONFIG-SETTING-CONFIGURATION-FILE" title="20.1.2. Определение параметров в файле конфигурации"><code class="filename">postgresql.conf</code></a> или выполнив команду <code class="literal">ALTER ROLE ALL SET search_path = "$user"</code>. Затем следует предоставить права на создание объектов в схеме public. Выбираться объекты в этой схеме будут только по полному имени. Тогда как обращаться к таблицам по полному имени вполне допустимо, обращения к функциям в общей схеме всё же <a class="link" href="typeconv-func.html" title="10.3. Функции">будут небезопасными или ненадёжными</a>. Поэтому если вы создаёте функции или расширения в схеме public, применяйте первый шаблон. Если же нет, этот шаблон, как и первый, безопасен при условии, что никакой недоверенный пользователь не является владельцем базы данных и не получал право <code class="literal">ADMIN OPTION</code> для соответствующей роли.</p></li><li class="listitem"><p>Сохранить путь поиска по умолчанию и предоставить права создания объектов в схеме public. Все пользователи неявно обращаются к схеме public. Тем самым имитируется ситуация с полным отсутствием схем, что позволяет осуществить плавный переход из среды без схем. Однако данный шаблон ни в коем случае нельзя считать безопасным. Он подходит, только если в базе данных имеется всего один либо несколько доверяющих друг другу пользователей. В базах данных, обновлённых с версии <span class="productname">PostgreSQL</span> 14 или более ранней, этот шаблон применяется по умолчанию.</p></li></ul></div><p>При любом подходе, устанавливая совместно используемые приложения (таблицы, которые нужны всем, дополнительные функции сторонних разработчиков и т. д.), помещайте их в отдельные схемы. Не забудьте дать другим пользователям права для доступа к этим схемам. Тогда пользователи смогут обращаться к этим дополнительным объектам по полному имени или при желании добавят эти схемы в свои пути поиска.</p></div><div class="sect2" id="DDL-SCHEMAS-PORTABILITY"><div class="titlepage"><div><div><h3 class="title">5.9.7. Переносимость <a href="#DDL-SCHEMAS-PORTABILITY" class="id_link">#</a></h3></div></div></div><p>Стандарт SQL не поддерживает обращение в одной схеме к разным объектам, принадлежащим разным пользователям. Более того, в ряде реализаций СУБД нельзя создавать схемы с именем, отличным от имени владельца. На практике, в СУБД, реализующих только базовую поддержку схем согласно стандарту, концепции пользователя и схемы очень близки. Таким образом, многие пользователи полагают, что полное имя на самом деле образуется как <code class="literal"><em class="replaceable"><code>имя_пользователя</code></em>.<em class="replaceable"><code>имя_таблицы</code></em></code>. И именно так будет вести себя <span class="productname">PostgreSQL</span>, если вы создадите схемы для каждого пользователя.</p><p>В стандарте SQL нет и понятия схемы <code class="literal">public</code>. Для максимального соответствия стандарту использовать схему <code class="literal">public</code> не следует.</p><p>Конечно, есть СУБД, в которых вообще не реализованы схемы или пространства имён поддерживают (возможно, с ограничениями) обращения к другим базам данных. Если вам потребуется работать с этими системами, максимальной переносимости вы достигнете, вообще не используя схемы.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ddl-rowsecurity.html" title="5.8. Политики защиты строк">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="ddl.html" title="Глава 5. Определение данных">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="ddl-inherit.html" title="5.10. Наследование">След.</a></td></tr><tr><td width="40%" align="left" valign="top">5.8. Политики защиты строк </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 5.10. Наследование</td></tr></table></div></body></html>