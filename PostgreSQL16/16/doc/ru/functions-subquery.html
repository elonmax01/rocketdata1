<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>9.23. Выражения подзапросов</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="functions-window.html" title="9.22. Оконные функции" /><link rel="next" href="functions-comparisons.html" title="9.24. Сравнение табличных строк и массивов" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">9.23. Выражения подзапросов</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="functions-window.html" title="9.22. Оконные функции">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="functions.html" title="Глава 9. Функции и операторы">Наверх</a></td><th width="60%" align="center">Глава 9. Функции и операторы</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="functions-comparisons.html" title="9.24. Сравнение табличных строк и массивов">След.</a></td></tr></table><hr /></div><div class="sect1" id="FUNCTIONS-SUBQUERY"><div class="titlepage"><div><div><h2 class="title" style="clear: both">9.23. Выражения подзапросов <a href="#FUNCTIONS-SUBQUERY" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="functions-subquery.html#FUNCTIONS-SUBQUERY-EXISTS">9.23.1. <code class="literal">EXISTS</code></a></span></dt><dt><span class="sect2"><a href="functions-subquery.html#FUNCTIONS-SUBQUERY-IN">9.23.2. <code class="literal">IN</code></a></span></dt><dt><span class="sect2"><a href="functions-subquery.html#FUNCTIONS-SUBQUERY-NOTIN">9.23.3. <code class="literal">NOT IN</code></a></span></dt><dt><span class="sect2"><a href="functions-subquery.html#FUNCTIONS-SUBQUERY-ANY-SOME">9.23.4. <code class="literal">ANY</code>/<code class="literal">SOME</code></a></span></dt><dt><span class="sect2"><a href="functions-subquery.html#FUNCTIONS-SUBQUERY-ALL">9.23.5. <code class="literal">ALL</code></a></span></dt><dt><span class="sect2"><a href="functions-subquery.html#FUNCTIONS-SUBQUERY-SINGLE-ROW-COMP">9.23.6. Сравнение единичных строк</a></span></dt></dl></div><a id="id-1.5.8.29.2" class="indexterm"></a><a id="id-1.5.8.29.3" class="indexterm"></a><a id="id-1.5.8.29.4" class="indexterm"></a><a id="id-1.5.8.29.5" class="indexterm"></a><a id="id-1.5.8.29.6" class="indexterm"></a><a id="id-1.5.8.29.7" class="indexterm"></a><a id="id-1.5.8.29.8" class="indexterm"></a><p>В этом разделе описаны выражения подзапросов, которые реализованы в <span class="productname">PostgreSQL</span> в соответствии со стандартом <acronym class="acronym">SQL</acronym>. Все рассмотренные здесь формы выражений возвращает булевы значения (true/false).</p><div class="sect2" id="FUNCTIONS-SUBQUERY-EXISTS"><div class="titlepage"><div><div><h3 class="title">9.23.1. <code class="literal">EXISTS</code> <a href="#FUNCTIONS-SUBQUERY-EXISTS" class="id_link">#</a></h3></div></div></div><pre class="synopsis">EXISTS (<em class="replaceable"><code>подзапрос</code></em>)</pre><p>Аргументом <code class="token">EXISTS</code> является обычный оператор <code class="command">SELECT</code>, т. е. <em class="firstterm">подзапрос</em>. Выполнив запрос, система проверяет, возвращает ли он строки в результате. Если он возвращает минимум одну строку, результатом <code class="token">EXISTS</code> будет <span class="quote">«<span class="quote">true</span>»</span>, а если не возвращает ни одной — <span class="quote">«<span class="quote">false</span>»</span>.</p><p>Подзапрос может обращаться к переменным внешнего запроса, которые в рамках одного вычисления подзапроса считаются константами.</p><p>Вообще говоря, подзапрос может выполняться не полностью, а завершаться, как только будет возвращена хотя бы одна строка. Поэтому в подзапросах следует избегать побочных эффектов (например, обращений к генераторам последовательностей); проявление побочного эффекта может быть непредсказуемым.</p><p>Так как результат этого выражения зависит только от того, возвращаются строки или нет, но не от их содержимого, список выходных значений подзапроса обычно не имеет значения. Как следствие, широко распространена практика, когда проверки <code class="literal">EXISTS</code> записываются в форме <code class="literal">EXISTS(SELECT 1 WHERE ...)</code>. Однако из этого правила есть и исключения, например с подзапросами с предложением <code class="token">INTERSECT</code>.</p><p>Этот простой пример похож на внутреннее соединение по столбцу <code class="literal">col2</code>, но он выдаёт максимум одну строку для каждой строки в <code class="literal">tab1</code>, даже если в <code class="literal">tab2</code> ей соответствуют несколько строк: </p><pre class="screen">
SELECT col1
FROM tab1
WHERE EXISTS (SELECT 1 FROM tab2 WHERE col2 = tab1.col2);
</pre></div><div class="sect2" id="FUNCTIONS-SUBQUERY-IN"><div class="titlepage"><div><div><h3 class="title">9.23.2. <code class="literal">IN</code> <a href="#FUNCTIONS-SUBQUERY-IN" class="id_link">#</a></h3></div></div></div><pre class="synopsis"><em class="replaceable"><code>выражение</code></em> IN (<em class="replaceable"><code>подзапрос</code></em>)</pre><p>В правой стороне этого выражения в скобках задаётся подзапрос, который должен возвращать ровно один столбец. Вычисленное значение левого выражения сравнивается со значениями во всех строках, возвращённых подзапросом. Результатом всего выражения <code class="token">IN</code> будет <span class="quote">«<span class="quote">true</span>»</span>, если строка с таким значением находится, и <span class="quote">«<span class="quote">false</span>»</span> в противном случае (в том числе, когда подзапрос вообще не возвращает строк).</p><p>Заметьте, что если результатом выражения слева оказывается NULL или равных значений справа не находится, а хотя бы одно из значений справа равно NULL, конструкция <code class="token">IN</code> возвращает NULL, а не false. Это соответствует принятым в SQL правилам сравнения переменных со значениями NULL.</p><p>Так же, как и с <code class="token">EXISTS</code>, здесь не следует рассчитывать на то, что подзапрос будет всегда выполняться полностью.</p><pre class="synopsis"><em class="replaceable"><code>конструктор_строки</code></em> IN (<em class="replaceable"><code>подзапрос</code></em>)</pre><p>В левой части этой формы <code class="token">IN</code> записывается конструктор строки (подробнее они рассматриваются в <a class="xref" href="sql-expressions.html#SQL-SYNTAX-ROW-CONSTRUCTORS" title="4.2.13. Конструкторы табличных строк">Подразделе 4.2.13</a>). Справа в скобках записывается подзапрос, который должен вернуть ровно столько столбцов, сколько содержит строка в выражении слева. Вычисленные значения левого выражения сравниваются построчно со значениями во всех строках, возвращённых подзапросом. Результатом всего выражения <code class="token">IN</code> будет <span class="quote">«<span class="quote">true</span>»</span>, если строка с такими значениями находится, и <span class="quote">«<span class="quote">false</span>»</span> в противном случае (в том числе, когда подзапрос вообще не возвращает строк).</p><p>Как обычно, значения NULL в строках обрабатываются при этом по принятым в SQL правилам сравнения. Две строки считаются равными, если все их соответствующие элементы не равны NULL, но равны между собой; неравными они считаются, когда в них находятся элементы, не равные NULL, и не равные друг другу; в противном случае результат сравнения строк не определён (равен NULL). Если в результатах сравнения строк нет ни одного положительного, но есть хотя бы один NULL, результатом <code class="token">IN</code> будет NULL.</p></div><div class="sect2" id="FUNCTIONS-SUBQUERY-NOTIN"><div class="titlepage"><div><div><h3 class="title">9.23.3. <code class="literal">NOT IN</code> <a href="#FUNCTIONS-SUBQUERY-NOTIN" class="id_link">#</a></h3></div></div></div><pre class="synopsis"><em class="replaceable"><code>выражение</code></em> NOT IN (<em class="replaceable"><code>подзапрос</code></em>)</pre><p>Справа в скобках записывается подзапрос, который должен возвращать ровно один столбец. Вычисленное значение левого выражения сравнивается со значением во всех строках, возвращённых подзапросом. Результатом всего выражения <code class="token">NOT IN</code> будет <span class="quote">«<span class="quote">true</span>»</span>, если находятся только несовпадающие строки (в том числе, когда подзапрос вообще не возвращает строк). Если же находится хотя бы одна подходящая строка, результатом будет <span class="quote">«<span class="quote">false</span>»</span>.</p><p>Заметьте, что если результатом выражения слева оказывается NULL или равных значений справа не находится, а хотя бы одно из значений справа равно NULL, конструкция <code class="token">NOT IN</code> возвращает NULL, а не true. Это соответствует принятым в SQL правилам сравнения переменных со значениями NULL.</p><p>Так же, как и с <code class="token">EXISTS</code>, здесь не следует рассчитывать на то, что подзапрос будет всегда выполняться полностью.</p><pre class="synopsis"><em class="replaceable"><code>конструктор_строки</code></em> NOT IN (<em class="replaceable"><code>подзапрос</code></em>)</pre><p>В левой части этой формы <code class="token">NOT IN</code> записывается конструктор строки (подробнее они описываются в <a class="xref" href="sql-expressions.html#SQL-SYNTAX-ROW-CONSTRUCTORS" title="4.2.13. Конструкторы табличных строк">Подразделе 4.2.13</a>). Справа в скобках записывается подзапрос, который должен вернуть ровно столько столбцов, сколько содержит строка в выражении слева. Вычисленные значения левого выражения сравниваются построчно со значениями во всех строках, возвращённых подзапросом. Результатом всего выражения <code class="token">NOT IN</code> будет <span class="quote">«<span class="quote">true</span>»</span>, если равных строк не найдётся (в том числе, и когда подзапрос не возвращает строк), и <span class="quote">«<span class="quote">false</span>»</span>, если такие строки есть.</p><p>Как обычно, значения NULL в строках обрабатываются при этом по принятым в SQL правилам сравнения. Две строки считаются равными, если все их соответствующие элементы не равны NULL, но равны между собой; неравными они считаются, когда в них находятся элементы, не равные NULL, и не равные друг другу; в противном случае результат сравнения строк не определён (равен NULL). Если в результатах сравнения строк нет ни одного положительного, но есть хотя бы один NULL, результатом <code class="token">NOT IN</code> будет NULL.</p></div><div class="sect2" id="FUNCTIONS-SUBQUERY-ANY-SOME"><div class="titlepage"><div><div><h3 class="title">9.23.4. <code class="literal">ANY</code>/<code class="literal">SOME</code> <a href="#FUNCTIONS-SUBQUERY-ANY-SOME" class="id_link">#</a></h3></div></div></div><pre class="synopsis"><em class="replaceable"><code>выражение</code></em> <em class="replaceable"><code>оператор</code></em> ANY (<em class="replaceable"><code>подзапрос</code></em>)
<em class="replaceable"><code>выражение</code></em> <em class="replaceable"><code>оператор</code></em> SOME (<em class="replaceable"><code>подзапрос</code></em>)</pre><p>В правой части конструкции в скобках записывается подзапрос, который должен возвращать ровно один столбец. Вычисленное значение левого выражения сравнивается со значением в каждой строке результата подзапроса с помощью заданного <em class="replaceable"><code>оператора</code></em> условия, который должен выдавать логическое значение. Результатом <code class="token">ANY</code> будет <span class="quote">«<span class="quote">true</span>»</span>, если хотя бы для одной строки условие истинно, и <span class="quote">«<span class="quote">false</span>»</span> в противном случае (в том числе, и когда подзапрос не возвращает строк).</p><p>Ключевое слово <code class="token">SOME</code> является синонимом <code class="token">ANY</code>. Конструкцию <code class="token">IN</code> можно также записать как <code class="literal">= ANY</code>.</p><p>Заметьте, что если условие не выполняется ни для одной из строк, а хотя бы для одной строки условный оператор выдаёт NULL, конструкция <code class="token">ANY</code> возвращает NULL, а не false. Это соответствует принятым в SQL правилам сравнения переменных со значениями NULL.</p><p>Так же, как и с <code class="token">EXISTS</code>, здесь не следует рассчитывать на то, что подзапрос будет всегда выполняться полностью.</p><pre class="synopsis"><em class="replaceable"><code>конструктор_строки</code></em> <em class="replaceable"><code>оператор</code></em> ANY (<em class="replaceable"><code>подзапрос</code></em>)
<em class="replaceable"><code>конструктор_строки</code></em> <em class="replaceable"><code>оператор</code></em> SOME (<em class="replaceable"><code>подзапрос</code></em>)</pre><p>В левой части этой формы <code class="token">ANY</code> записывается конструктор строки (подробнее они описываются в <a class="xref" href="sql-expressions.html#SQL-SYNTAX-ROW-CONSTRUCTORS" title="4.2.13. Конструкторы табличных строк">Подразделе 4.2.13</a>). Справа в скобках записывается подзапрос, который должен возвращать ровно столько столбцов, сколько содержит строка в выражении слева. Вычисленные значения левого выражения сравниваются построчно со значениями во всех строках, возвращённых подзапросом, с применением заданного <em class="replaceable"><code>оператора</code></em>. Результатом всего выражения <code class="token">ANY</code> будет <span class="quote">«<span class="quote">true</span>»</span>, если для какой-либо из строк подзапроса результатом сравнения будет true, или <span class="quote">«<span class="quote">false</span>»</span>, если для всех строк результатом сравнения оказывается false (в том числе, и когда подзапрос не возвращает строк). Результатом выражения будет NULL, если ни для одной из строк подзапроса результат сравнения не равен true, а минимум для одной равен NULL.</p><p>Подробнее логика сравнения конструкторов строк описана в <a class="xref" href="functions-comparisons.html#ROW-WISE-COMPARISON" title="9.24.5. Сравнение конструкторов строк">Подразделе 9.24.5</a>.</p></div><div class="sect2" id="FUNCTIONS-SUBQUERY-ALL"><div class="titlepage"><div><div><h3 class="title">9.23.5. <code class="literal">ALL</code> <a href="#FUNCTIONS-SUBQUERY-ALL" class="id_link">#</a></h3></div></div></div><pre class="synopsis"><em class="replaceable"><code>выражение</code></em> <em class="replaceable"><code>оператор</code></em> ALL (<em class="replaceable"><code>подзапрос</code></em>)</pre><p>В правой части конструкции в скобках записывается подзапрос, который должен возвращать ровно один столбец. Вычисленное значение левого выражения сравнивается со значением в каждой строке результата подзапроса с помощью заданного <em class="replaceable"><code>оператора</code></em> условия, который должен выдавать логическое значение. Результатом <code class="token">ALL</code> будет <span class="quote">«<span class="quote">true</span>»</span>, если условие истинно для всех строк (и когда подзапрос не возвращает строк), или <span class="quote">«<span class="quote">false</span>»</span>, если находятся строки, для которых оно ложно. Результатом выражения будет NULL, если ни для одной из строк подзапроса результат сравнения не равен true, а минимум для одной равен NULL.</p><p>Конструкция <code class="token">NOT IN</code> равнозначна <code class="literal">&lt;&gt; ALL</code>.</p><p>Так же, как и с <code class="token">EXISTS</code>, здесь не следует рассчитывать на то, что подзапрос будет всегда выполняться полностью.</p><pre class="synopsis"><em class="replaceable"><code>конструктор_строки</code></em> <em class="replaceable"><code>оператор</code></em> ALL (<em class="replaceable"><code>подзапрос</code></em>)</pre><p>В левой части этой формы <code class="token">ALL</code> записывается конструктор строки (подробнее они описываются в <a class="xref" href="sql-expressions.html#SQL-SYNTAX-ROW-CONSTRUCTORS" title="4.2.13. Конструкторы табличных строк">Подразделе 4.2.13</a>). Справа в скобках записывается подзапрос, который должен возвращать ровно столько столбцов, сколько содержит строка в выражении слева. Вычисленные значения левого выражения сравниваются построчно со значениями во всех строках, возвращённых подзапросом, с применением заданного <em class="replaceable"><code>оператора</code></em>. Результатом всего выражения <code class="token">ALL</code> будет <span class="quote">«<span class="quote">true</span>»</span>, если для всех строк подзапроса результатом сравнения будет true (или если подзапрос не возвращает строк), либо <span class="quote">«<span class="quote">false</span>»</span>, если результат сравнения равен false для любой из строк подзапроса. Результатом выражения будет NULL, если ни для одной из строк подзапроса результат сравнения не равен true, а минимум для одной равен NULL.</p><p>Подробнее логика сравнения конструкторов строк описана в <a class="xref" href="functions-comparisons.html#ROW-WISE-COMPARISON" title="9.24.5. Сравнение конструкторов строк">Подразделе 9.24.5</a>.</p></div><div class="sect2" id="FUNCTIONS-SUBQUERY-SINGLE-ROW-COMP"><div class="titlepage"><div><div><h3 class="title">9.23.6. Сравнение единичных строк <a href="#FUNCTIONS-SUBQUERY-SINGLE-ROW-COMP" class="id_link">#</a></h3></div></div></div><a id="id-1.5.8.29.15.2" class="indexterm"></a><pre class="synopsis"><em class="replaceable"><code>конструктор_строки</code></em> <em class="replaceable"><code>оператор</code></em> (<em class="replaceable"><code>подзапрос</code></em>)</pre><p>В левой части конструкции записывается конструктор строки (подробнее они описываются в <a class="xref" href="sql-expressions.html#SQL-SYNTAX-ROW-CONSTRUCTORS" title="4.2.13. Конструкторы табличных строк">Подразделе 4.2.13</a>). Справа в скобках записывается подзапрос, который должен возвращать ровно столько столбцов, сколько содержит строка в выражении слева. Более того, подзапрос может вернуть максимум одну строку. (Если он не вернёт строк, результатом будет NULL.) Конструкция возвращает результат сравнения строки слева с этой одной строкой результата подзапроса.</p><p>Подробнее логика сравнения конструкторов строк описана в <a class="xref" href="functions-comparisons.html#ROW-WISE-COMPARISON" title="9.24.5. Сравнение конструкторов строк">Подразделе 9.24.5</a>.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="functions-window.html" title="9.22. Оконные функции">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="functions.html" title="Глава 9. Функции и операторы">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="functions-comparisons.html" title="9.24. Сравнение табличных строк и массивов">След.</a></td></tr><tr><td width="40%" align="left" valign="top">9.22. Оконные функции </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 9.24. Сравнение табличных строк и массивов</td></tr></table></div></body></html>