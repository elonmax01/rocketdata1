<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>30.5. Настройка WAL</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="wal-async-commit.html" title="30.4. Асинхронное подтверждение транзакций" /><link rel="next" href="wal-internals.html" title="30.6. Внутреннее устройство WAL" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">30.5. Настройка <acronym class="acronym">WAL</acronym></th></tr><tr><td width="10%" align="left"><a accesskey="p" href="wal-async-commit.html" title="30.4. Асинхронное подтверждение транзакций">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="wal.html" title="Глава 30. Надёжность и журнал предзаписи">Наверх</a></td><th width="60%" align="center">Глава 30. Надёжность и журнал предзаписи</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="wal-internals.html" title="30.6. Внутреннее устройство WAL">След.</a></td></tr></table><hr /></div><div class="sect1" id="WAL-CONFIGURATION"><div class="titlepage"><div><div><h2 class="title" style="clear: both">30.5. Настройка <acronym class="acronym">WAL</acronym> <a href="#WAL-CONFIGURATION" class="id_link">#</a></h2></div></div></div><p>Существует несколько конфигурационных параметров относящихся к <acronym class="acronym">WAL</acronym>, которые влияют на производительность СУБД. Далее рассказывается об их использовании. Общую информацию об установке параметров конфигурации сервера смотрите в <a class="xref" href="runtime-config.html" title="Глава 20. Настройка сервера">Главе 20</a>.</p><p><em class="firstterm">Контрольные точки</em><a id="id-1.6.17.7.3.2" class="indexterm"></a> — это точки в последовательности транзакций, в которых гарантируется, что файлы с данными и индексами были обновлены всей информацией записанной перед контрольной точкой. Во время контрольной точки, все <span class="quote">«<span class="quote">грязные</span>»</span> страницы данных, находящиеся в памяти, сохраняются на диск, а в файл WAL записывается специальная запись контрольной точки. (Сделанные изменения были перед этим записаны в файлы <acronym class="acronym">WAL</acronym>.) В случае краха процедура восстановления ищет последнюю запись контрольной точки, чтобы определить эту точку в WAL (называемую записью REDO), от которой процедура должна начать операцию воспроизведения изменений. Любые изменения файлов данных перед этой точкой гарантированно находятся уже на диске. Таким образом, после контрольной точки сегменты WAL, которые предшествуют записи воспроизведения, больше не нужны и могут быть удалены или направлены в циклическую перезапись. (Когда архивирование WAL будет завершено, сегменты WAL должны быть архивированы перед их удалением или циклической перезаписи.)</p><p>Запись всех <span class="quote">«<span class="quote">грязных</span>»</span> страниц данных из памяти на диск, которая требуется для контрольной точки, может вызвать значительную нагрузку на дисковый ввод/вывод. По этой причине, активность записи по контрольной точке регулируется так, что ввод/вывод начинается при старте контрольной точки и завершается перед стартом следующей контрольной точки; это минимизирует потерю производительности во время прохождения контрольных точек.</p><p>Отдельный серверный процесс контрольных точек автоматически выполняет контрольные точки с заданной частотой. Контрольные точки производятся каждые <a class="xref" href="runtime-config-wal.html#GUC-CHECKPOINT-TIMEOUT">checkpoint_timeout</a> секунд либо при приближении к пределу <a class="xref" href="runtime-config-wal.html#GUC-MAX-WAL-SIZE">max_wal_size</a>, если это имеет место раньше. Значения по умолчанию: 5 минут и 1 Гбайт, соответственно. Если после предыдущей контрольной точки новые записи WAL не добавились, следующие контрольные точки будут пропущены, даже если проходит время <code class="varname">checkpoint_timeout</code>. (Если вы применяете архивацию WAL и хотите установить нижний предел для частоты архивации, чтобы ограничить потенциальную потерю данных, вам следует настраивать параметр <a class="xref" href="runtime-config-wal.html#GUC-ARCHIVE-TIMEOUT">archive_timeout</a>, а не параметры контрольных точек.) Также можно выполнить контрольную точку принудительно, воспользовавшись SQL-командой <code class="command">CHECKPOINT</code>.</p><p>Уменьшение значений <code class="varname">checkpoint_timeout</code> и/или <code class="varname">max_wal_size</code> приводит к учащению контрольных точек. Это позволяет ускорить восстановление после краха (поскольку для воспроизведения нужно меньше данных), но с другой стороны нужно учитывать дополнительную нагрузку, возникающую вследствие более частого сброса <span class="quote">«<span class="quote">грязных</span>»</span> страниц данных на диск. Если включён режим <a class="xref" href="runtime-config-wal.html#GUC-FULL-PAGE-WRITES">full_page_writes</a> (по умолчанию это так), нужно учесть и ещё один фактор. Для обеспечения целостности страницы данных, при первом изменении страницы данных после контрольной точки эта страница записывается в журнал целиком. В данном случае, чем меньше интервал между контрольными точками, тем больше объём записи в WAL, так что это частично дискредитирует идею уменьшения интервала записи, и в любом случае приводит к увеличению объёма обмена с диском.</p><p>Контрольные точки довольно дороги с точки зрения ресурсов, во-первых, потому что они требуют записи всех <span class="quote">«<span class="quote">грязных</span>»</span> буферов из памяти на диск, и во-вторых потому что они создают дополнительный трафик WAL, о чём говорилось выше. Таким образом, будет благоразумным установить параметры контрольных точек так, чтобы контрольные точки не выполнялись слишком часто. Для простой проверки параметров контрольной точки можно установить параметр <a class="xref" href="runtime-config-wal.html#GUC-CHECKPOINT-WARNING">checkpoint_warning</a>. Если промежуток времени между контрольными точками будет меньше чем количество секунд, заданное параметром <code class="varname">checkpoint_warning</code>, то в журнал сервера будет выдано сообщение с рекомендацией увеличить <code class="varname">max_wal_size</code>. Эпизодическое появление такого сообщения не является поводом для беспокойства. Но если оно появляется часто, необходимо увеличить значения параметров управления контрольными точками. Массовые операции, такие как <code class="command">COPY</code> с большим объёмом данных, могут привести к появлению нескольких таких предупреждений, если вы не установили <code class="varname">max_wal_size</code> достаточно большим.</p><p>Чтобы избежать «заваливания» системы ввода/вывода при резкой интенсивной записи страниц, запись «грязных» буферов во время контрольной точки растягивается на определённый период времени. Этот период управляется параметром <a class="xref" href="runtime-config-wal.html#GUC-CHECKPOINT-COMPLETION-TARGET">checkpoint_completion_target</a>, который задаётся как часть интервала между контрольными точками (настраиваемого параметром <code class="varname">checkpoint_timeout</code>). Скорость ввода/вывода подстраивается так, чтобы контрольная точка завершилась к моменту истечения заданной части от <code class="varname">checkpoint_timeout</code> секунд или до превышения <code class="varname">max_wal_size</code>, если оно имеет место раньше. Со значением 0.9, заданным по умолчанию, можно ожидать, что <span class="productname">PostgreSQL</span> завершит процедуру контрольной точки незадолго до следующей запланированной (примерно на 90% выполнения предыдущей контрольной точки). При этом процесс ввода/вывода растягивается насколько возможно, чтобы обеспечить равномерную нагрузку ввода/вывода в течение интервала между контрольными точками. Но с другой стороны, растягивание контрольных точек влияет на время восстановления, так как для восстановления нужно будет задействовать большее количество сегментов WAL. Если вы хотите оптимизировать длительность восстановления, вы можете уменьшить <code class="varname">checkpoint_timeout</code>, чтобы контрольные точки создавались чаще, а ввод/вывод при этом всё же растягивался на интервал между ними. Либо же можно уменьшить значение <code class="varname">checkpoint_completion_target</code>, но это не рекомендуется, поскольку в результате в определённые периоды ввод/вывод будет более интенсивным (во время создания контрольной точки) или менее интенсивным (по завершении контрольной точки, но до следующей запланированной контрольной точки). Хотя в <code class="varname">checkpoint_completion_target</code> можно задать значение вплоть до 1.0, лучше выбрать значение меньше (по крайней мере, не больше 0.9), так как при контрольных точках выполняются и некоторые другие операции, помимо записи «грязных» буферов. Со значением 1.0 контрольные точки, скорее всего, не будут завершаться вовремя, что приведёт к потере производительности из-за неожиданных колебаний требуемого количества сегментов WAL.</p><p>На платформах Linux и POSIX параметр <a class="xref" href="runtime-config-wal.html#GUC-CHECKPOINT-FLUSH-AFTER">checkpoint_flush_after</a> позволяет принудить ОС к сбросу страниц, записываемых во время контрольной точки, при накоплении заданного количества байт. Если его не настроить, эти страницы могут оставаться в кеше страниц ОС, что повлечёт затормаживание при выполнении <code class="literal">fsync</code> в конце контрольной точки. Этот параметр часто помогает уменьшить задержки транзакций, но может оказать и негативное влияние на производительность; особенно, когда объём нагрузки больше <a class="xref" href="runtime-config-resource.html#GUC-SHARED-BUFFERS">shared_buffers</a>, но меньше кеша страниц в ОС.</p><p>Число файлов сегментов WAL в каталоге <code class="filename">pg_wal</code> зависит от <code class="varname">min_wal_size</code>, <code class="varname">max_wal_size</code> и объёма WAL, сгенерированного в предыдущих циклах контрольных точек. Когда старые файлы сегментов оказываются не нужны, они удаляются или перерабатываются (то есть переименовываются, чтобы стать будущими сегментами в нумерованной последовательности). Если вследствие кратковременного скачка интенсивности записи в WAL предел <code class="varname">max_wal_size</code> превышается, ненужные файлы сегментов будут удаляться, пока система не опустится ниже этого предела. Оставаясь ниже этого предела, система перерабатывает столько файлов WAL, сколько необходимо для покрытия ожидаемой потребности до следующей контрольной точки, и удаляет остальные. Эта оценка базируется на скользящем среднем числа файлов WAL, задействованных в предыдущих циклах контрольных точек. Скользящее среднее увеличивается немедленно, если фактическое использование превышает оценку, так что в нём в некоторой степени накапливается пиковое использование, а не среднее. Значение <code class="varname">min_wal_size</code> ограничивает снизу число файлов WAL, которые будут переработаны для будущего использования; такой объём WAL всегда будет перерабатываться, даже если система простаивает и оценка использования говорит, что нужен совсем небольшой WAL.</p><p>Вне зависимости от <code class="varname">max_wal_size</code>, последние файлы WAL в объёме <a class="xref" href="runtime-config-replication.html#GUC-WAL-KEEP-SIZE">wal_keep_size</a> мегабайт и ещё один дополнительный файл WAL сохраняются в любом случае. Кроме того, если применяется архивация WAL, старые сегменты не могут быть удалены или переработаны, пока они не будут заархивированы. Если WAL архивируется медленнее, чем генерируется, либо если команда <code class="varname">archive_library</code> или библиотека <code class="varname">archive_library</code> постоянно даёт сбои, старые файлы WAL будут накапливаться в <code class="filename">pg_wal</code>, пока ситуация не будет разрешена. Медленно работающий или отказавший ведомый сервер, использующий слот репликации, даст тот же эффект (см. <a class="xref" href="warm-standby.html#STREAMING-REPLICATION-SLOTS" title="27.2.6. Слоты репликации">Подраздел 27.2.6</a>).</p><p>В режиме восстановления архива или горячего резерва сервер периодически выполняет <em class="firstterm">точки перезапуска</em><a id="id-1.6.17.7.12.2" class="indexterm"></a>, которые похожи на контрольные точки в обычном режиме работы: сервер принудительно сбрасывает своё состояние на диск, обновляет файл <code class="filename">pg_control</code>, чтобы показать, что уже обработанные данные WAL не нужно сканировать снова, и затем перерабатывает все старые файлы сегментов WAL в каталоге <code class="filename">pg_wal</code>. Точки перезапуска не могут выполняться чаще, чем контрольные точки на главном сервере, так как они могут происходить только в записях контрольных точек. Точка перезапуска производится, когда достигается запись контрольной точки и после предыдущей точки перезапуска прошло не меньше <code class="varname">checkpoint_timeout</code> секунд или размер WAL может превысить <code class="varname">max_wal_size</code>. Однако из-за того, что на время выполнения точек перезапуска накладываются ограничения, <code class="varname">max_wal_size</code> часто превышается при восстановлении, вплоть до объёма WAL, записываемого в цикле между контрольными точками. (Значение <code class="varname">max_wal_size</code> никогда и не было жёстким пределом, так что всегда следует оставлять приличный запас сверху, чтобы не остаться без свободного места на диске.)</p><p>Наиболее часто используются две связанные с <acronym class="acronym">WAL</acronym> внутренние функции: <code class="function">XLogInsertRecord</code> и <code class="function">XLogFlush</code>. <code class="function">XLogInsertRecord</code> применяется для добавления записи в буферы <acronym class="acronym">WAL</acronym> в разделяемой памяти. Если места для новой записи недостаточно, <code class="function">XLogInsertRecord</code> придётся записать (переместить в кеш ядра) несколько заполненных буферов <acronym class="acronym">WAL</acronym>. Это нежелательно, так как <code class="function">XLogInsertRecord</code> используется при каждом изменении в базе данных на низком уровне (например, при добавлении строки) в момент, когда установлена исключительная блокировка задействованных страниц данных, поэтому данная операция должна быть максимально быстрой. Что ещё хуже, запись буферов <acronym class="acronym">WAL</acronym> может также повлечь создание нового сегмента WAL, что займёт ещё больше времени. Обычно буферы <acronym class="acronym">WAL</acronym> должны записываться и сохраняться на диске в функции <code class="function">XLogFlush</code>, которая вызывается, по большей части, при фиксировании транзакции, чтобы результаты транзакции сохранились в надёжном хранилище. В системах с интенсивной записью в WAL вызовы <code class="function">XLogFlush</code> могут иметь место не так часто, чтобы <code class="function">XLogInsertRecord</code> не приходилось производить запись. В таких системах следует увеличить число буферов <acronym class="acronym">WAL</acronym>, изменив параметр <a class="xref" href="runtime-config-wal.html#GUC-WAL-BUFFERS">wal_buffers</a>. Когда включён режим <a class="xref" href="runtime-config-wal.html#GUC-FULL-PAGE-WRITES">full_page_writes</a> и система очень сильно загружена, увеличение <code class="varname">wal_buffers</code> поможет сгладить скачки во времени ответа в период сразу после каждой контрольной точки.</p><p>Параметр <a class="xref" href="runtime-config-wal.html#GUC-COMMIT-DELAY">commit_delay</a> определяет, на сколько микросекунд будет засыпать ведущий процесс группы, записывающий в журнал, после получения блокировки в <code class="function">XLogFlush</code>, пока подчинённые формируют очередь на запись. Во время этой задержки другие серверные процессы смогут добавлять записи в WAL буферы журнала, чтобы все эти записи сохранились на диск в результате одной операции синхронизации, которую выполнит ведущий. Ведущий процесс не засыпает, если отключён режим <a class="xref" href="runtime-config-wal.html#GUC-FSYNC">fsync</a>, либо число сеансов с активными транзакциями меньше <a class="xref" href="runtime-config-wal.html#GUC-COMMIT-SIBLINGS">commit_siblings</a>, так как маловероятно, что какой-либо другой сеанс зафиксирует транзакцию в ближайшее время. Заметьте, что на некоторых платформах, разрешение этого таймера сна составляет 10 миллисекунд, так что любое значение параметра <code class="varname">commit_delay</code> от 1 до 10000 микросекунд будет действовать одинаково. Кроме того, в некоторых системах состояние сна может продлиться несколько дольше, чем требует параметр.</p><p>Так как цель <code class="varname">commit_delay</code> состоит в том, чтобы позволить стоимости каждой операции синхронизации амортизироваться через параллельную фиксацию транзакций (потенциально за счёт задержки транзакции), необходимо определить количество той стоимости, прежде чем урегулирование сможет быть выбрано разумно. Чем выше стоимость, тем более эффективный будет <code class="varname">commit_delay</code> в увеличении пропускной способности транзакций в какой-то степени. Программа <a class="xref" href="pgtestfsync.html" title="pg_test_fsync"><span class="refentrytitle"><span class="application">pg_test_fsync</span></span></a> может использоваться, чтобы измерить среднее время в микросекундах, которое занимает одиночная работа сброса WAL на диск. Значение половины среднего времени сообщаемого программой рекомендуется в качестве отправной точки для использования значения в параметре <code class="varname">commit_delay</code> при оптимизации для конкретного объёма работы, и говорит о том, сколько нужно времени для синхронизации сброса единственной операции записи 8 Кбайт. Настройка параметра <code class="varname">commit_delay</code> особенно полезна в случае хранения WAL в хранилище с высокоскоростными дисками, такими как твердотельные накопители (SSD) или RAID-массивы с кешем записи и аварийным питанием на батарее; но это определённо должно тестироваться на репрезентативной рабочей нагрузке. Более высокие значения <code class="varname">commit_siblings</code> должны использоваться в таких случаях, тогда как меньшие значения <code class="varname">commit_siblings</code> часто полезны на носителях с большими задержками. Обратите внимание на то, что увеличение значения параметра <code class="varname">commit_delay</code> может увеличить задержку транзакции настолько, что пострадает общая производительность транзакций.</p><p>Даже если <code class="varname">commit_delay</code> равен нулю (значение по умолчанию), групповая фиксация все равно может произойти, но группа будет состоять только из тех сеансов, которым понадобилось сбросить записи о фиксации на диск за то время, пока происходил предыдущий сброс. Чем больше сеансов, тем чаще это происходит даже при нулевом <code class="varname">commit_delay</code>, поэтому увеличение этого параметра может и не оказать заметного действия. Установка <code class="varname">commit_delay</code> имеет смысл в двух случаях: (1) когда несколько транзакций одновременно фиксируют изменения, (2) либо когда частота фиксаций ограничена пропускной способностью дисковой подсистемы. Однако при задержке из-за низкой скорости вращения диска, эта настройка может оказаться полезной даже всего при двух сеансах.</p><p>Параметр <a class="xref" href="runtime-config-wal.html#GUC-WAL-SYNC-METHOD">wal_sync_method</a> определяет, как <span class="productname">PostgreSQL</span> будет обращаться к ядру, чтобы принудительно сохранить <acronym class="acronym">WAL</acronym> на диск. Все методы должны быть одинаковыми в плане надёжности, за исключением <code class="literal">fsync_writethrough</code>, который может иногда принудительно сбрасывать кеш диска, даже если другие методы не делают этого. Однако какой из них самый быстрый, во многом определяется платформой; вы можете протестировать скорость, используя модуль <a class="xref" href="pgtestfsync.html" title="pg_test_fsync"><span class="refentrytitle"><span class="application">pg_test_fsync</span></span></a>. Обратите внимание, что данный параметр не имеет значения, если <code class="varname">fsync</code> выключен.</p><p>Включение параметра конфигурации <a class="xref" href="runtime-config-developer.html#GUC-WAL-DEBUG">wal_debug</a> (предоставляется, если <span class="productname">PostgreSQL</span> был скомпилирован с его поддержкой) будет приводить к тому, что все вызовы связанных с <acronym class="acronym">WAL</acronym> функций <code class="function">XLogInsertRecord</code> и <code class="function">XLogFlush</code> будут протоколироваться в журнале сервера. В будущем данный параметр может быть заменён более общим механизмом.</p><p>Для записи данных WAL на диск предназначены две внутренние функции: <code class="function">XLogWrite</code> и <code class="function">issue_xlog_fsync</code>. Когда параметр <a class="xref" href="runtime-config-statistics.html#GUC-TRACK-WAL-IO-TIMING">track_wal_io_timing</a> включён, общее время, которое затратила функция <code class="function">XLogWrite</code> на запись WAL на диск и которое затратила функция <code class="function">issue_xlog_fsync</code> на синхронизацию с ФС, подсчитывается в <a class="xref" href="monitoring-stats.html#PG-STAT-WAL-VIEW" title="Таблица 28.25. Представление pg_stat_wal">pg_stat_wal</a> как <code class="literal">wal_write_time</code> и <code class="literal">wal_sync_time</code> соответственно. Функцию <code class="function">XLogWrite</code> обычно вызывают <code class="function">XLogInsertRecord</code> (когда в буферах WAL нет места для новых записей), <code class="function">XLogFlush</code> и процесс записи WAL, чтобы записать данные из буферов WAL на диск, а затем вызвать функцию <code class="function">issue_xlog_fsync</code>. Функцию <code class="function">issue_xlog_fsync</code> обычно вызывает <code class="function">XLogWrite</code> для синхронизации файлов WAL. Если параметр <code class="varname">wal_sync_method</code> принимает значение <code class="literal">open_datasync</code> или <code class="literal">open_sync</code>, операция записи <code class="function">XLogWrite</code> обеспечивает синхронизацию данных WAL, а <code class="function">issue_xlog_fsync</code> не делает ничего. Если же <code class="varname">wal_sync_method</code> принимает значение <code class="literal">fdatasync</code>, <code class="literal">fsync</code> или <code class="literal">fsync_writethrough</code>, операция записи перемещает буферы WAL в кеш ядра, а <code class="function">issue_xlog_fsync</code> синхронизирует с ФС. Вне зависимости от значения <code class="varname">track_wal_io_timing</code>, в полях <code class="literal">wal_write</code> и <code class="literal">wal_sync</code> представления <code class="structname">pg_stat_wal</code> отображается, сколько раз вызывалась функция <code class="function">XLogWrite</code> для записи WAL и сколько раз вызывалась функция <code class="function">issue_xlog_fsync</code> для синхронизации с ФС, соответственно.</p><p>Параметр <a class="xref" href="runtime-config-wal.html#GUC-RECOVERY-PREFETCH">recovery_prefetch</a> позволяет уменьшить время ожидания ввода/вывода во время восстановления, указывая ядру начинать чтение дисковых блоков, которые ещё не в пуле буферов <span class="productname">PostgreSQL</span>, но вскоре потребуются. Количество параллельных потоков и объём предвыборки ограничиваются параметрами <a class="xref" href="runtime-config-resource.html#GUC-MAINTENANCE-IO-CONCURRENCY">maintenance_io_concurrency</a> и <a class="xref" href="runtime-config-wal.html#GUC-WAL-DECODE-BUFFER-SIZE">wal_decode_buffer_size</a> соответственно. По умолчанию параметр <code class="varname">recovery_prefetch</code> имеет значение <code class="literal">try</code>, при котором эта функциональность включается в системах, поддерживающих <code class="function">posix_fadvise</code>.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="wal-async-commit.html" title="30.4. Асинхронное подтверждение транзакций">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="wal.html" title="Глава 30. Надёжность и журнал предзаписи">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="wal-internals.html" title="30.6. Внутреннее устройство WAL">След.</a></td></tr><tr><td width="40%" align="left" valign="top">30.4. Асинхронное подтверждение транзакций </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 30.6. Внутреннее устройство WAL</td></tr></table></div></body></html>