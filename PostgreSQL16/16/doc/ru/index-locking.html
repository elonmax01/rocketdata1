<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>64.4. Замечания о блокировке с индексами</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="index-scanning.html" title="64.3. Сканирование индекса" /><link rel="next" href="index-unique-checks.html" title="64.5. Проверки уникальности в индексе" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">64.4. Замечания о блокировке с индексами</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="index-scanning.html" title="64.3. Сканирование индекса">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="indexam.html" title="Глава 64. Определение интерфейса для индексных методов доступа">Наверх</a></td><th width="60%" align="center">Глава 64. Определение интерфейса для индексных методов доступа</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="index-unique-checks.html" title="64.5. Проверки уникальности в индексе">След.</a></td></tr></table><hr /></div><div class="sect1" id="INDEX-LOCKING"><div class="titlepage"><div><div><h2 class="title" style="clear: both">64.4. Замечания о блокировке с индексами <a href="#INDEX-LOCKING" class="id_link">#</a></h2></div></div></div><p>Индексные методы доступа должны справляться с параллельными операциями обновления индекса, производимыми несколькими процессами. Ядро системы <span class="productname">PostgreSQL</span> получает блокировку <code class="literal">AccessShareLock</code> для индекса в процессе сканирования и <code class="literal">RowExclusiveLock</code> при модификации индекса (включая и обычную очистку командой <code class="command">VACUUM</code>). Так как эти типы блокировок не конфликтуют, метод доступа должен сам устанавливать более точечные блокировки, которые ему могут потребоваться. Блокировка индекса в целом в режиме <code class="literal">ACCESS EXCLUSIVE</code> устанавливается только при создании и уничтожении индекса или операции <code class="command">REINDEX</code> (вместо этого используется <code class="literal">SHARE UPDATE EXCLUSIVE</code> вместе с <code class="literal">CONCURRENTLY</code>).</p><p>Реализация типа индекса, поддерживающего параллельные изменения, обычно требует глубокого и всестороннего анализа требуемого поведения. Для общего представления вы можете узнать о конструктивных решениях, принятых при реализации B-дерева и индекса по хешу, обратившись к <code class="filename">src/backend/access/nbtree/README</code> и <code class="filename">src/backend/access/hash/README</code>.</p><p>Помимо собственных внутренних требований индексов к целостности, при параллельном обновлении данных возникают вопросы согласованности родительской таблицы (<em class="firstterm">основных данных</em>) и индекса. Вследствие того, что <span class="productname">PostgreSQL</span> отделяет чтение и изменение основных данных от чтения и изменения индекса, образуются временные интервалы, в которых индекс может быть несогласованным с данными. Мы решаем эту проблему, применяя следующие правила: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Новая запись в области данных добавляется до того, как для неё будут созданы записи в индексах. (Таким образом, при параллельном сканировании индекса эта запись в данных скорее всего не будет замечена. Это не проблема, так как читателю индекса всё равно не нужны незафиксированные строки. Но учтите написанное в <a class="xref" href="index-unique-checks.html" title="64.5. Проверки уникальности в индексе">Разделе 64.5</a>.)</p></li><li class="listitem"><p>Когда запись данных удаляется (командой <code class="command">VACUUM</code>), сначала должны удалиться все созданные для неё записи в индексах.</p></li><li class="listitem"><p>Сканирование индекса должно закрепить страницу индекса, на которой находится элемент, возвращённый последним вызовом <code class="function">amgettuple</code>, а <code class="function">ambulkdelete</code> не должна удалять записи со страниц, закреплённых другими процессами. Чем обосновано это правило, описывается ниже.</p></li></ul></div><p> Без третьего правила читатель индекса мог бы увидеть запись индекса за мгновение до того, как она была удалена процедурой <code class="command">VACUUM</code>, а затем обратиться к соответствующей записи данных после того, как <code class="command">VACUUM</code> удалит и её. Это не приведёт к серьёзным проблемам, если данный элемент остаётся незадействованным, когда к нему обращается читатель, так как пустой слот будет игнорироваться функцией <code class="function">heap_fetch()</code>. Но как быть, если третий процесс уже занял этот слот какими-то своими данными? Когда применяется снимок, совместимый с MVCC, и это не проблема, так как эти данные определённо окажутся слишком новыми при проверке видимости для данного снимка. Однако для снимка несовместимого с MVCC (например, снимка <code class="literal">SnapshotAny</code>), может так получиться, что будет возвращена строка, на самом деле не соответствующая ключам сканирования. Мы можем защититься от такого исхода, потребовав, чтобы ключи сканирования всегда перепроверялись для строки данных, но это слишком дорогостоящее решение. Вместо этого, мы закрепляем страницу индекса как промежуточный объект, показывающий, что читатель может всё ещё быть <span class="quote">«<span class="quote">в пути</span>»</span> от записи индекса к соответствующей строке данных. Благодаря тому, что <code class="function">ambulkdelete</code> блокируется при обращении к этой закреплённой странице, процедура <code class="command">VACUUM</code> не сможет удалить строку данных, пока её извлечение не закончит читатель. Это решение оказывается очень недорогим по времени выполнения, а издержки блокирования привносятся только в редких случаях, когда действительно возникает конфликт.</p><p>Такое решение требует, чтобы сканирования индексов выполнялись <span class="quote">«<span class="quote">синхронно</span>»</span>: мы должны выбирать каждый следующий кортеж данных сразу после того получили соответствущую запись индекса. Это оказывается невыгодно по ряду причин. <span class="quote">«<span class="quote">Асинхронное</span>»</span> сканирование, при котором мы собираем множество TID из индекса, и обращаемся за кортежами данных только после этого, влечёт гораздо меньше издержек с блокировками и позволяет обращаться к данным более эффективным образом. Согласно проведённому выше анализу, мы должны использовать синхронный подход для снимков, несовместимых с MVCC, но для запросов со снимками MVCC будет работать и асинхронное сканирование.</p><p>При сканировании индекса с <code class="function">amgetbitmap</code>, метод доступа не закрепляет страницы индекса ни для каких из возвращаемых кортежей. Поэтому такое сканирование можно безопасно применять только со снимками MVCC.</p><p>Когда флаг <code class="structfield">ampredlocks</code> не установлен, любое сканирование с данным методом доступа в сериализуемой транзакции будет получать неблокирующую предикатную блокировку для всего индекса. Это будет приводить к конфликту чтения-записи при добавлении любого кортежа в этот индекс параллельной сериализуемой транзакцией. Если среди набора параллельных сериализуемых транзакций выявляются определённые варианты конфликтов чтения-записи, одна из этих транзакций может быть отменена для сохранения целостности данных. Когда данный флаг установлен, это означает, что метод доступа реализует более точную предикатную блокировку, что способствует сокращению частоты отмены транзакций по этой причине.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="index-scanning.html" title="64.3. Сканирование индекса">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="indexam.html" title="Глава 64. Определение интерфейса для индексных методов доступа">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="index-unique-checks.html" title="64.5. Проверки уникальности в индексе">След.</a></td></tr><tr><td width="40%" align="left" valign="top">64.3. Сканирование индекса </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 64.5. Проверки уникальности в индексе</td></tr></table></div></body></html>