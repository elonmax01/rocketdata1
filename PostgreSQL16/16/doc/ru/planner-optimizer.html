<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>52.5. Планировщик/оптимизатор</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="rule-system.html" title="52.4. Система правил PostgreSQL" /><link rel="next" href="executor.html" title="52.6. Исполнитель" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">52.5. Планировщик/оптимизатор</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="rule-system.html" title="52.4. Система правил PostgreSQL">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="overview.html" title="Глава 52. Обзор внутреннего устройства PostgreSQL">Наверх</a></td><th width="60%" align="center">Глава 52. Обзор внутреннего устройства PostgreSQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="executor.html" title="52.6. Исполнитель">След.</a></td></tr></table><hr /></div><div class="sect1" id="PLANNER-OPTIMIZER"><div class="titlepage"><div><div><h2 class="title" style="clear: both">52.5. Планировщик/оптимизатор <a href="#PLANNER-OPTIMIZER" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="planner-optimizer.html#PLANNER-OPTIMIZER-GENERATING-POSSIBLE-PLANS">52.5.1. Выработка возможных планов</a></span></dt></dl></div><p>Задача <em class="firstterm">планировщика/оптимизатора</em> — построить наилучший план выполнения. Определённый SQL-запрос (а значит, и дерево запроса) на самом деле можно выполнить самыми разными способами, при этом получая одни и те же результаты. Если это не требует больших вычислений, оптимизатор запросов будет перебирать все возможные варианты планов, чтобы в итоге выбрать тот, который должен выполниться быстрее остальных.</p><div class="note"><h3 class="title">Примечание</h3><p>В некоторых ситуациях рассмотрение всех возможных вариантов выполнения запросов занимает слишком много времени и памяти. В частности, это имеет место при выполнении запросов с большим количеством операций соединения. Поэтому, чтобы выбрать разумный (но не обязательно наилучший) план запроса за приемлемое время, <span class="productname">PostgreSQL</span> использует <em class="firstterm">генетический оптимизатор запросов</em> (см. <a class="xref" href="geqo.html" title="Глава 62. Генетический оптимизатор запросов">Главу 62</a>), когда количество соединений превышает некоторый предел (см. <a class="xref" href="runtime-config-query.html#GUC-GEQO-THRESHOLD">geqo_threshold</a>).</p></div><p>Процедура поиска лучшего плана на самом деле работает со структурами данных, называемыми <em class="firstterm">путями</em>, которые представляют собой упрощённые схемы планов, содержащие минимум информации, необходимый планировщику для принятия решений. Когда наиболее выгодный план выбран, строится полноценное <em class="firstterm">дерево плана</em>, которое и передаётся исполнителю. Оно описывает желаемый план выполнения достаточно подробно, чтобы исполнитель мог обработать его. В продолжении этого раздела мы будем считать, что планы и пути по сути одно и то же.</p><div class="sect2" id="PLANNER-OPTIMIZER-GENERATING-POSSIBLE-PLANS"><div class="titlepage"><div><div><h3 class="title">52.5.1. Выработка возможных планов <a href="#PLANNER-OPTIMIZER-GENERATING-POSSIBLE-PLANS" class="id_link">#</a></h3></div></div></div><p>Сначала планировщик/оптимизатор вырабатывает планы для сканирования каждого отдельного отношения (таблицы), используемого в запросе. Множество возможных планов определяется в зависимости от наличия индексов в каждом отношении. Произвести последовательное сканирование отношения можно в любом случае, так что план последовательного сканирования создаётся всегда. Предположим, что для отношения создан индекс (например, индекс-B-дерево) и запрос содержит ограничение <code class="literal">отношение.атрибут ОПЕР константа</code>. Если окажется, что <code class="literal">отношение.атрибут</code> совпадает с ключом индекса-B-дерева и <code class="literal">ОПЕР</code> — один из операторов, входящих в <em class="firstterm">класс операторов</em> индекса, создаётся ещё один план, c использованием индекса-B-дерева для чтения отношения. Если находятся другие индексы, ключи которых соответствуют ограничениям запроса, могут добавиться и другие планы. Планы сканирования индекса также создаются для индексов, если их порядок сортировки соответствует предложению <code class="literal">ORDER BY</code> (если оно есть), или этот порядок может быть полезен для соединения слиянием (см. ниже).</p><p>Если в запросе требуется соединить два или несколько отношений, после того, как будут определены все подходящие планы сканирования отдельных отношений, рассматриваются планы соединения. При этом возможны три стратегии соединения: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><em class="firstterm">соединение с вложенным циклом</em>: Правое отношение сканируется один раз для каждой строки, найденной в левом отношении. Эту стратегию легко реализовать, но она может быть очень трудоёмкой. (Однако если правое отношение можно сканировать по индексу, эта стратегия может быть удачной. Тогда значения из текущей строки левого отношения могут использоваться как ключи для сканирования по индексу справа.)</p></li><li class="listitem"><p><em class="firstterm">соединение слиянием</em>: Каждое отношение сортируется по атрибутам соединения до начала соединения. Затем два отношения сканируются параллельно и соответствующие строки, объединяясь, формируют строки соединения. Этот тип соединения более привлекательный, так как каждое отношение сканируется только один раз. Требуемый порядок сортировки можно получить, либо добавив явный этап сортировки, либо просканировав отношение в нужном порядке, используя индекс по ключу соединения.</p></li><li class="listitem"><p><em class="firstterm">соединение по хешу</em>: сначала сканируется правое отношение и формируется хеш-таблица, ключ в которой вычисляется по атрибутам соединения. Затем сканируется левое отношение и по тем же атрибутам в каждой строке вычисляется ключ для поиска в этой хеш-таблице соответствующих строк справа.</p></li></ul></div><p>Когда в запросе задействованы более двух отношений, окончательный результат должен быть получен из дерева с узлами соединения, имеющими по два входа. Планировщик рассматривает все возможные последовательности соединения и выбирает самую выгодную.</p><p>Если число задействованных в запросе отношений меньше <a class="xref" href="runtime-config-query.html#GUC-GEQO-THRESHOLD">geqo_threshold</a>, для поиска оптимальной последовательности соединений производится практически полный перебор. Планировщик отдаёт предпочтение соединениям между двумя отношениями, для которых есть соответствующее предложение соединения в условии <code class="literal">WHERE</code> (то есть, для которых находится ограничение вида <code class="literal">where табл1.атр1=табл2.атр2</code>). Пары соединения без подобного предложения рассматриваются, только если нет другого выбора, то есть когда для определённого отношения не находятся предложения соединения с каким-либо другим отношением. Планировщик рассматривает все возможные планы для каждой пары соединения и выбирает самый выгодный из них (по его оценке).</p><p>Если <code class="varname">geqo_threshold</code> превышается, последовательность соединений выбирается эвристическим путём, как описано в <a class="xref" href="geqo.html" title="Глава 62. Генетический оптимизатор запросов">Главе 62</a>. В остальном процесс планирования тот же.</p><p>Законченное дерево плана содержит узлы сканирования по индексу или последовательного сканирования базовых отношений, плюс узлы соединения с вложенным циклом, соединения слиянием или соединения по хешу (если требуется), плюс, возможно, узлы дополнительных действий, например, сортировки или вычисления агрегатных функций. Большинство из этих узлов могут дополнительно производить <em class="firstterm">отбор</em> (отбрасывать строки, не удовлетворяющие заданному логическому условию) и <em class="firstterm">расчёты</em> (вычислять производный набор столбцов по значениям заданных столбцов, то есть вычислять скалярные выражения). Одна из задач планировщика — добавить условия отбора из предложения <code class="literal">WHERE</code> и вычисления требуемых выходных выражений к наиболее подходящим узлам дерева плана.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="rule-system.html" title="52.4. Система правил PostgreSQL">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="overview.html" title="Глава 52. Обзор внутреннего устройства PostgreSQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="executor.html" title="52.6. Исполнитель">След.</a></td></tr><tr><td width="40%" align="left" valign="top">52.4. Система правил <span class="productname">PostgreSQL</span> </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 52.6. Исполнитель</td></tr></table></div></body></html>