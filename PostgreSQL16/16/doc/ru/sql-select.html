<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>SELECT</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sql-security-label.html" title="SECURITY LABEL" /><link rel="next" href="sql-selectinto.html" title="SELECT INTO" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">SELECT</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-security-label.html" title="SECURITY LABEL">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><th width="60%" align="center">Команды SQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-selectinto.html" title="SELECT INTO">След.</a></td></tr></table><hr /></div><div class="refentry" id="SQL-SELECT"><div class="titlepage"></div><a id="id-1.9.3.172.1" class="indexterm"></a><a id="id-1.9.3.172.2" class="indexterm"></a><a id="id-1.9.3.172.3" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">SELECT</span></h2><p>SELECT, TABLE, WITH — получить строки из таблицы или представления</p></div><div class="refsynopsisdiv"><h2>Синтаксис</h2><pre class="synopsis">[ WITH [ RECURSIVE ] <em class="replaceable"><code>запрос_WITH</code></em> [, ...] ]
SELECT [ ALL | DISTINCT [ ON ( <em class="replaceable"><code>выражение</code></em> [, ...] ) ] ]
    [ * | <em class="replaceable"><code>выражение</code></em> [ [ AS ] <em class="replaceable"><code>имя_результата</code></em> ] [, ...] ]
    [ FROM <em class="replaceable"><code>элемент_FROM</code></em> [, ...] ]
    [ WHERE <em class="replaceable"><code>условие</code></em> ]
    [ GROUP BY [ ALL | DISTINCT ] <em class="replaceable"><code>элемент_группирования</code></em> [, ...] ]
    [ HAVING <em class="replaceable"><code>условие</code></em> ]
    [ WINDOW <em class="replaceable"><code>имя_окна</code></em> AS ( <em class="replaceable"><code>определение_окна</code></em> ) [, ...] ]
    [ { UNION | INTERSECT | EXCEPT } [ ALL | DISTINCT ] <em class="replaceable"><code>выборка</code></em> ]
    [ ORDER BY <em class="replaceable"><code>выражение</code></em> [ ASC | DESC | USING <em class="replaceable"><code>оператор</code></em> ] [ NULLS { FIRST | LAST } ] [, ...] ]
    [ LIMIT { <em class="replaceable"><code>число</code></em> | ALL } ]
    [ OFFSET <em class="replaceable"><code>начало</code></em> [ ROW | ROWS ] ]
    [ FETCH { FIRST | NEXT } [ <em class="replaceable"><code>число</code></em> ] { ROW | ROWS } { ONLY | WITH TIES } ]
    [ FOR { UPDATE | NO KEY UPDATE | SHARE | KEY SHARE } [ OF <em class="replaceable"><code>имя_таблицы</code></em> [, ...] ] [ NOWAIT | SKIP LOCKED ] [...] ]

<span class="phrase">Здесь допускается <em class="replaceable"><code>элемент_FROM</code></em>:</span>

    [ ONLY ] <em class="replaceable"><code>имя_таблицы</code></em> [ * ] [ [ AS ] <em class="replaceable"><code>псевдоним</code></em> [ ( <em class="replaceable"><code>псевдоним_столбца</code></em> [, ...] ) ] ]
                [ TABLESAMPLE <em class="replaceable"><code>метод_выборки</code></em> ( <em class="replaceable"><code>аргумент</code></em> [, ...] ) [ REPEATABLE ( <em class="replaceable"><code>затравка</code></em> ) ] ]
    [ LATERAL ] ( <em class="replaceable"><code>выборка</code></em> ) [ [ AS ] <em class="replaceable"><code>псевдоним</code></em> [ ( <em class="replaceable"><code>псевдоним_столбца</code></em> [, ...] ) ] ]
    <em class="replaceable"><code>имя_запроса_WITH</code></em> [ [ AS ] <em class="replaceable"><code>псевдоним</code></em> [ ( <em class="replaceable"><code>псевдоним_столбца</code></em> [, ...] ) ] ]
    [ LATERAL ] <em class="replaceable"><code>имя_функции</code></em> ( [ <em class="replaceable"><code>аргумент</code></em> [, ...] ] )
                [ WITH ORDINALITY ] [ [ AS ] <em class="replaceable"><code>псевдоним</code></em> [ ( <em class="replaceable"><code>псевдоним_столбца</code></em> [, ...] ) ] ]
    [ LATERAL ] <em class="replaceable"><code>имя_функции</code></em> ( [ <em class="replaceable"><code>аргумент</code></em> [, ...] ] ) [ AS ] <em class="replaceable"><code>псевдоним</code></em> ( <em class="replaceable"><code>определение_столбца</code></em> [, ...] )
    [ LATERAL ] <em class="replaceable"><code>имя_функции</code></em> ( [ <em class="replaceable"><code>аргумент</code></em> [, ...] ] ) AS ( <em class="replaceable"><code>определение_столбца</code></em> [, ...] )
    [ LATERAL ] ROWS FROM( <em class="replaceable"><code>имя_функции</code></em> ( [ <em class="replaceable"><code>аргумент</code></em> [, ...] ] ) [ AS ( <em class="replaceable"><code>определение_столбца</code></em> [, ...] ) ] [, ...] )
                [ WITH ORDINALITY ] [ [ AS ] <em class="replaceable"><code>псевдоним</code></em> [ ( <em class="replaceable"><code>псевдоним_столбца</code></em> [, ...] ) ] ]
    <em class="replaceable"><code>элемент_FROM</code></em> <em class="replaceable"><code>тип_соединения</code></em> <em class="replaceable"><code>элемент_FROM</code></em> { ON <em class="replaceable"><code>условие_соединения</code></em> | USING ( <em class="replaceable"><code>столбец_соединения</code></em> [, ...] ) [ AS <em class="replaceable"><code>псевдоним_использования_соединения</code></em> ] }
    <em class="replaceable"><code>элемент_FROM</code></em> NATURAL <em class="replaceable"><code>тип_соединения</code></em> <em class="replaceable"><code>элемент_FROM</code></em>
    <em class="replaceable"><code>элемент_FROM</code></em> CROSS JOIN <em class="replaceable"><code>элемент_FROM</code></em>

<span class="phrase">и <em class="replaceable"><code>элемент_группирования</code></em> может быть следующим:</span>

    ( )
    <em class="replaceable"><code>выражение</code></em>
    ( <em class="replaceable"><code>выражение</code></em> [, ...] )
    ROLLUP ( { <em class="replaceable"><code>выражение</code></em> | ( <em class="replaceable"><code>выражение</code></em> [, ...] ) } [, ...] )
    CUBE ( { <em class="replaceable"><code>выражение</code></em> | ( <em class="replaceable"><code>выражение</code></em> [, ...] ) } [, ...] )
    GROUPING SETS ( <em class="replaceable"><code>элемент_группирования</code></em> [, ...] )

<span class="phrase">и <em class="replaceable"><code>запрос_WITH</code></em>:</span>

    <em class="replaceable"><code>имя_запроса_WITH</code></em> [ ( <em class="replaceable"><code>имя_столбца</code></em> [, ...] ) ] AS [ [ NOT ] MATERIALIZED ] ( <em class="replaceable"><code>выборка</code></em> | <em class="replaceable"><code>values</code></em> | <em class="replaceable"><code>insert</code></em> | <em class="replaceable"><code>update</code></em> | <em class="replaceable"><code>delete</code></em> )
        [ SEARCH { BREADTH | DEPTH } FIRST BY <em class="replaceable"><code>имя_столбца</code></em> [, ...] SET <em class="replaceable"><code>имя_столбца_послед_поиска</code></em> ]
        [ CYCLE <em class="replaceable"><code>имя_столбца</code></em> [, ...] SET <em class="replaceable"><code>имя_столбца_пометки_цикла</code></em> [ TO <em class="replaceable"><code>значение_пометки_цикла</code></em> DEFAULT <em class="replaceable"><code>пометка_цикла_по_умолчанию</code></em> ] USING <em class="replaceable"><code>имя_столбца_пути_цикла</code></em> ]

TABLE [ ONLY ] <em class="replaceable"><code>имя_таблицы</code></em> [ * ]</pre></div><div class="refsect1" id="id-1.9.3.172.7"><h2>Описание</h2><p><code class="command">SELECT</code> получает строки из множества таблиц (возможно, пустого). Общая процедура выполнения <code class="command">SELECT</code> следующая: </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Выполняются все запросы в списке <code class="literal">WITH</code>. По сути они формируют временные таблицы, к которым затем можно обращаться в списке <code class="literal">FROM</code>. Запрос в <code class="literal">WITH</code> без указания <code class="literal">NOT MATERIALIZED</code> выполняется только один раз, даже когда он фигурирует в списке <code class="literal">FROM</code> неоднократно. (См. <a class="xref" href="sql-select.html#SQL-WITH" title="Предложение WITH">Предложение WITH</a> ниже.)</p></li><li class="listitem"><p>Вычисляются все элементы в списке <code class="literal">FROM</code>. (Каждый элемент в списке <code class="literal">FROM</code> представляет собой реальную или виртуальную таблицу.) Если список <code class="literal">FROM</code> содержит несколько элементов, они объединяются перекрёстным соединением. (См. <a class="xref" href="sql-select.html#SQL-FROM" title="Предложение FROM">Предложение FROM</a> ниже.)</p></li><li class="listitem"><p>Если указано предложение <code class="literal">WHERE</code>, все строки, не удовлетворяющие условию, исключаются из результата. (См. <a class="xref" href="sql-select.html#SQL-WHERE" title="Предложение WHERE">Предложение WHERE</a> ниже.)</p></li><li class="listitem"><p>Если присутствует указание <code class="literal">GROUP BY</code>, либо в запросе вызываются агрегатные функции, вывод разделяется по группам строк, соответствующим одному или нескольким значениям, а затем вычисляются результаты агрегатных функций. Если добавлено предложение <code class="literal">HAVING</code>, оно исключает группы, не удовлетворяющие заданному условию. (См. <a class="xref" href="sql-select.html#SQL-GROUPBY" title="Предложение GROUP BY">Предложение GROUP BY</a> и <a class="xref" href="sql-select.html#SQL-HAVING" title="Предложение HAVING">Предложение HAVING</a> ниже.) Хотя столбцы вывода запроса номинально вычисляются на следующем шаге, на них также можно ссылаться (по имени или порядковому номеру) в предложении <code class="literal">GROUP BY</code>.</p></li><li class="listitem"><p>Вычисляются фактические выходные строки по заданным в <code class="command">SELECT</code> выражениям для каждой выбранной строки или группы строк. (См. <a class="xref" href="sql-select.html#SQL-SELECT-LIST" title="Список SELECT">Список SELECT</a> ниже.)</p></li><li class="listitem"><p><code class="literal">SELECT DISTINCT</code> исключает из результата повторяющиеся строки. <code class="literal">SELECT DISTINCT ON</code> исключает строки, совпадающие по всем указанным выражениям. <code class="literal">SELECT ALL</code> (по умолчанию) возвращает все строки результата, включая дубликаты. (См. <a class="xref" href="sql-select.html#SQL-DISTINCT" title="Предложение DISTINCT">Предложение DISTINCT</a> ниже.)</p></li><li class="listitem"><p>Операторы <code class="literal">UNION</code>, <code class="literal">INTERSECT</code> и <code class="literal">EXCEPT</code> объединяют вывод нескольких команд <code class="command">SELECT</code> в один результирующий набор. Оператор <code class="literal">UNION</code> возвращает все строки, представленные в одном, либо обоих наборах результатов. Оператор <code class="literal">INTERSECT</code> возвращает все строки, представленные строго в обоих наборах. Оператор <code class="literal">EXCEPT</code> возвращает все строки, представленные в первом наборе, но не во втором. Во всех трёх случаях повторяющиеся строки исключаются из результата, если явно не указано <code class="literal">ALL</code>. Чтобы явно обозначить, что выдаваться должны только неповторяющиеся строки, можно добавить избыточное слово <code class="literal">DISTINCT</code>. Заметьте, что в данном контексте по умолчанию подразумевается <code class="literal">DISTINCT</code>, хотя в самом <code class="command">SELECT</code> по умолчанию подразумевается <code class="literal">ALL</code>. (См. <a class="xref" href="sql-select.html#SQL-UNION" title="Предложение UNION+">Предложение UNION+</a>, <a class="xref" href="sql-select.html#SQL-INTERSECT" title="Предложение INTERSECT">Предложение INTERSECT</a> и <a class="xref" href="sql-select.html#SQL-EXCEPT" title="Предложение EXCEPT">Предложение EXCEPT</a> ниже.)</p></li><li class="listitem"><p>Если присутствует предложение <code class="literal">ORDER BY</code>, возвращаемые строки сортируются в указанном порядке. В отсутствие <code class="literal">ORDER BY</code> строки возвращаются в том порядке, в каком системе будет проще их выдать. (См. <a class="xref" href="sql-select.html#SQL-ORDERBY" title="Предложение ORDER BY">Предложение ORDER BY</a>&gt; ниже.)</p></li><li class="listitem"><p>Если указано предложение <code class="literal">LIMIT</code> (или <code class="literal">FETCH FIRST</code>) либо <code class="literal">OFFSET</code>, оператор <code class="command">SELECT</code> возвращает только подмножество строк результата. (См. <a class="xref" href="sql-select.html#SQL-LIMIT" title="Предложение LIMIT">Предложение LIMIT</a> ниже.)</p></li><li class="listitem"><p>Если указано <code class="literal">FOR UPDATE</code>, <code class="literal">FOR NO KEY UPDATE</code>, <code class="literal">FOR SHARE</code> или <code class="literal">FOR KEY SHARE</code>, оператор <code class="command">SELECT</code> блокирует выбранные строки, защищая их от одновременных изменений. (См. <a class="xref" href="sql-select.html#SQL-FOR-UPDATE-SHARE" title="Предложение блокировки">Предложение блокировки</a> ниже.)</p></li></ol></div><p>Для всех столбцов, задействованных в команде <code class="command">SELECT</code>, необходимо иметь право <code class="literal">SELECT</code>. Применение блокировок <code class="literal">FOR NO KEY UPDATE</code>, <code class="literal">FOR UPDATE</code>, <code class="literal">FOR SHARE</code> или <code class="literal">FOR KEY SHARE</code> требует также права <code class="literal">UPDATE</code> (как минимум для одного столбца в каждой выбранной для блокировки таблице).</p></div><div class="refsect1" id="id-1.9.3.172.8"><h2>Параметры</h2><div class="refsect2" id="SQL-WITH"><h3>Предложение <code class="literal">WITH</code></h3><p>Предложение <code class="literal">WITH</code> позволяет задать один или несколько подзапросов, к которым затем можно обратиться по имени в основном запросе. Эти подзапросы по сути действуют как временные таблицы или представления в процессе выполнения главного запроса. Каждый подзапрос может представлять собой оператор <code class="command">SELECT</code>, <code class="command">TABLE</code>, <code class="command">VALUES</code>, <code class="command">INSERT</code>, <code class="command">UPDATE</code> или <code class="command">DELETE</code>. При использовании в <code class="literal">WITH</code> оператора, изменяющего данные, (<code class="command">INSERT</code>, <code class="command">UPDATE</code> или <code class="command">DELETE</code>) обычно добавляется предложение <code class="literal">RETURNING</code>. Заметьте, что именно результат <code class="literal">RETURNING</code>, а <span class="emphasis"><em>не</em></span> нижележащая таблица, изменяемая запросом, формирует временную таблицу, которую затем читает основной запрос. Если <code class="literal">RETURNING</code> опущено, оператор тем не менее выполняется, но не выдаёт никакого результата, так что на него нельзя сослаться как на таблицу в основном запросе.</p><p>Имя (без схемы) должно быть указано для каждого запроса <code class="literal">WITH</code>. Также можно задать необязательный список с именами столбцов; если он опущен, имена столбцов формируются из результата подзапроса.</p><p>Если указано <code class="literal">RECURSIVE</code>, подзапрос <code class="command">SELECT</code> может ссылаться сам на себя по имени. Такой подзапрос должен иметь форму </p><pre class="synopsis">
<em class="replaceable"><code>нерекурсивная_часть</code></em> UNION [ ALL | DISTINCT ] <em class="replaceable"><code>рекурсивная_часть</code></em>
</pre><p>, где рекурсивная ссылка на сам запрос может находиться только справа от <code class="literal">UNION</code>. Для одного запроса допускается только одна рекурсивная ссылка на него же. Операторы, изменяющие данные, не могут быть рекурсивными, но результат рекурсивного запроса <code class="command">SELECT</code> в таких операторах можно использовать. За примером обратитесь к <a class="xref" href="queries-with.html" title="7.8. Запросы WITH (Общие табличные выражения)">Разделу 7.8</a>.</p><p>Ещё одна особенность <code class="literal">RECURSIVE</code> в том, что запросы <code class="literal">WITH</code> могут быть неупорядоченными: запрос может ссылаться на другой, идущий в списке после него. (Однако циклические ссылки или взаимная рекурсия не поддерживаются.) Без <code class="literal">RECURSIVE</code> запрос в <code class="literal">WITH</code> может ссылаться только на запросы того же уровня в <code class="literal">WITH</code>, предшествующие ему в списке <code class="literal">WITH</code>.</p><p>Когда в предложении <code class="literal">WITH</code> задаются несколько запросов, <code class="literal">RECURSIVE</code> следует указывать только единожды, сразу после <code class="literal">WITH</code>. Это указание будет действовать на все запросы в предложении <code class="literal">WITH</code>, хотя оно никак не скажется на запросах, не использующих рекурсию или ссылки на последующие запросы.</p><p>Необязательное предложение <code class="literal">SEARCH</code> вычисляет <em class="firstterm">столбец последовательности поиска</em>, который может применяться для упорядочивания результатов рекурсивного запроса «сначала в ширину» или «сначала в глубину». Передаваемый список имён столбцов задаёт ключ строки, по которому будет отслеживаться, какие строки были посещены. Столбец с именем <em class="replaceable"><code>имя_столбца_послед_поиска</code></em> будет добавлен в список результирующих столбцов запроса <code class="literal">WITH</code>. Для получения нужного порядка можно выполнить сортировку по этому столбцу во внешнем запросе. За примерами обратитесь к <a class="xref" href="queries-with.html#QUERIES-WITH-SEARCH" title="7.8.2.1. Порядок поиска">Подразделу 7.8.2.1</a>.</p><p>Необязательное предложение <code class="literal">CYCLE</code> применяется для обнаружения циклов в рекурсивных запросах. Задаваемый в нём список имён столбцов определяет ключ строки, по которому будут отслеживаться посещённые строки. Столбец <em class="replaceable"><code>имя_столбца_пометки_цикла</code></em> будет добавлен в список результирующих столбцов запроса <code class="literal">WITH</code>. В случае обнаружения цикла в этом столбце окажется <em class="replaceable"><code>значение_пометки_цикла</code></em>, а иначе — <em class="replaceable"><code>пометка_цикла_по_умолчанию</code></em>. Более того, в случае обнаружения цикла обработка рекурсивного объединения будет остановлена. Задаваемые <em class="replaceable"><code>значение_пометки_цикла</code></em> и <em class="replaceable"><code>пометка_цикла_по_умолчанию</code></em> должны быть константами и должны приводиться к общему типу данных, а для этого типа должен быть определён оператор неравенства. (Стандарт SQL требует, чтобы они были булевыми константами или символьными строками, но в PostgreSQL это необязательно.) По умолчанию подразумеваются соответственно константы <code class="literal">TRUE</code> и <code class="literal">FALSE</code> (типа <code class="type">boolean</code>). Кроме того, в список результирующих столбцов запроса <code class="literal">WITH</code> будет добавлен столбец <em class="replaceable"><code>имя_столбца_пути_цикла</code></em>. Этот столбец имеет внутреннее предназначение, в нём отслеживаются посещённые строки. За примерами обратитесь к <a class="xref" href="queries-with.html#QUERIES-WITH-CYCLE" title="7.8.2.2. Выявление циклов">Подразделу 7.8.2.2</a>.</p><p>Предложения <code class="literal">SEARCH</code> и <code class="literal">CYCLE</code> работают только с рекурсивными запросами <code class="literal">WITH</code>. При этом <em class="replaceable"><code>запрос_WITH</code></em> должен быть объединением (<code class="literal">UNION</code> или <code class="literal">UNION ALL</code>) двух <code class="literal">SELECT</code> (или равнозначных команд) без вложенных <code class="literal">UNION</code>. В случае применения обоих предложений столбец, добавляемый предложением <code class="literal">SEARCH</code>, размещается перед столбцами, добавляемыми предложением <code class="literal">CYCLE</code>.</p><p>Основной запрос и все запросы <code class="literal">WITH</code>, условно говоря, выполняются одновременно. Это значит, что действие оператора, изменяющего данные в <code class="literal">WITH</code>, не будут видеть другие части запроса, кроме как прочитав его вывод <code class="literal">RETURNING</code>. Если два таких оператора попытаются изменить одну строку, результат будет неопределённым.</p><p>Ключевое свойство запросов <code class="literal">WITH</code> состоит в том, что они обычно вычисляются один раз для всего основного запроса, даже если в основном запросе содержатся несколько ссылок на них. В частности, гарантируется, что операторы, изменяющие данные, будут выполняться ровно один раз, вне зависимости от того, будет ли их результат прочитан основным запросом и в каком объёме.</p><p>Однако от этой гарантии можно отказаться, добавив для запроса <code class="literal">WITH</code> пометку <code class="literal">NOT MATERIALIZED</code>. В этом случае запрос <code class="literal">WITH</code> может быть свёрнут в основной запрос, как если бы это был простой <code class="literal">SELECT</code> внутри предложения <code class="literal">FROM</code> основного запроса. В результате запрос <code class="literal">WITH</code> может вычисляться неоднократно, если основной запрос обращается к нему несколько раз. Но если при каждом таком обращении требуются лишь отдельные строки из всего результата запроса <code class="literal">WITH</code>, указание <code class="literal">NOT MATERIALIZED</code>, позволяющее оптимизировать запросы совместно, в целом может оказаться выгодным. Указание <code class="literal">NOT MATERIALIZED</code> игнорируется в запросе <code class="literal">WITH</code>, который имеет рекурсивный характер или не свободен от побочных эффектов (то есть когда это не простой <code class="literal">SELECT</code> без изменчивых функций).</p><p>По умолчанию запрос <code class="literal">WITH</code>, свободный от побочных эффектов, заворачивается в основной запрос, если он используется в его предложении <code class="literal">FROM</code> ровно один раз. Это позволяет совместно оптимизировать два уровня запросов в ситуациях, когда семантика запроса в целом сохраняется. Но это заворачивание можно предотвратить, пометив запрос <code class="literal">WITH</code> как <code class="literal">MATERIALIZED</code>. Это может быть полезно, например когда предложение <code class="literal">WITH</code> применяется как преграда для оптимизатора, не позволяющая ему выбрать неудачный план. В <span class="productname">PostgreSQL</span> до 12 версии такое заворачивание не выполнялось никогда, поэтому запросы, написанные для предыдущих версий, могли полагаться на то, что оптимизации будет препятствовать собственно предложение <code class="literal">WITH</code>.</p><p>За дополнительными сведениями обратитесь к <a class="xref" href="queries-with.html" title="7.8. Запросы WITH (Общие табличные выражения)">Разделу 7.8</a>.</p></div><div class="refsect2" id="SQL-FROM"><h3>Предложение <code class="literal">FROM</code></h3><p>В предложении <code class="literal">FROM</code> перечисляются одна или несколько таблиц, служащих источниками данных для <code class="command">SELECT</code>. Если указано несколько источников, результатом будет декартово произведение (перекрёстное соединение) всех их строк. Но обычно в запрос добавляются уточняющие условия (в предложении <code class="literal">WHERE</code>), которые ограничивают набор строк небольшим подмножеством этого произведения.</p><p>Предложение <code class="literal">FROM</code> может содержать следующие элементы: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>имя_таблицы</code></em></span></dt><dd><p>Имя (возможно, дополненное схемой) существующей таблицы или представления. Если перед именем таблицы указано <code class="literal">ONLY</code>, считывается только заданная таблица. Без <code class="literal">ONLY</code> считывается и заданная таблица, и все её потомки (если таковые есть). После имени таблицы можно также добавить необязательное указание <code class="literal">*</code>, чтобы явно обозначить, что блокировка затрагивает и все дочерние таблицы.</p></dd><dt><span class="term"><em class="replaceable"><code>псевдоним</code></em></span></dt><dd><p>Альтернативное имя для элемента списка <code class="literal">FROM</code>. Этот псевдоним используется для краткости или для исключения неоднозначности с замкнутыми соединениями (когда одна таблица читается неоднократно). Когда задаётся псевдоним, он полностью скрывает настоящее имя таблицы или функции; например, при записи <code class="literal">FROM foo AS f</code>, в продолжении запроса <code class="command">SELECT</code> к этому элементу <code class="literal">FROM</code> нужно обращаться по имени <code class="literal">f</code>, а не <code class="literal">foo</code>. Если задан псевдоним таблицы, за ним можно также написать список псевдонимов столбцов, который определит альтернативные имена для столбцов таблицы.</p></dd><dt><span class="term"><code class="literal">TABLESAMPLE <em class="replaceable"><code>метод_выборки</code></em> ( <em class="replaceable"><code>аргумент</code></em> [, ...] ) [ REPEATABLE ( <em class="replaceable"><code>затравка</code></em> ) ]</code></span></dt><dd><p>Предложение <code class="literal">TABLESAMPLE</code>, сопровождающее <em class="replaceable"><code>имя_таблицы</code></em>, показывает, что для получения подмножества строк в этой таблице должен применяться указанный <em class="replaceable"><code>метод_выборки</code></em>. Эта выборка предшествует применению любых других фильтров, например, в предложении <code class="literal">WHERE</code>. В стандартный дистрибутив <span class="productname">PostgreSQL</span> включены два метода выборки, <code class="literal">BERNOULLI</code> и <code class="literal">SYSTEM</code>; другие методы выборки можно установить в базу данных через расширения.</p><p>Методы выборки <code class="literal">BERNOULLI</code> и <code class="literal">SYSTEM</code> принимают единственный <em class="replaceable"><code>аргумент</code></em>, определяющий, какой процент таблицы должен попасть в выборку, от 0 до 100. Этот аргумент может задаваться любым выражением со значением типа <code class="type">real</code>. (Другие методы выборки могут принимать дополнительные или другие параметры.) Оба этих метода возвращают случайную выборку таблицы, содержащую примерно указанный процент строк таблицы. Метод <code class="literal">BERNOULLI</code> сканирует всю таблицу и выбирает или игнорирует отдельные строки независимо, с заданной вероятностью. Метод <code class="literal">SYSTEM</code> строит выборку на уровне блоков, определяя для каждого блока шанс его задействовать, и возвращает все строки из каждого задействуемого блока. Метод <code class="literal">SYSTEM</code> работает значительно быстрее <code class="literal">BERNOULLI</code>, когда выбирается небольшой процент строк, но он может выдавать менее случайную выборку таблицы из-за эффектов кучности.</p><p>В необязательном предложении <code class="literal">REPEATABLE</code> задаётся <em class="replaceable"><code>затравка</code></em> — число или выражение, задающее отправное значение для генератора случайных чисел в методе выборки. Значением затравки может быть любое отличное от NULL число с плавающей точкой. Два запроса, в которых указаны одинаковые значения затравки и <em class="replaceable"><code>аргумента</code></em>, выдадут одну и ту же выборку таблицы при условии неизменности содержимого таблицы. Но с разными значениями затравки выборки обычно получаются разными. В отсутствие предложения <code class="literal">REPEATABLE</code> для каждого запроса выдаётся новая случайная выборка, в зависимости от затравки, сгенерированной системой. Заметьте, что некоторые дополнительные методы выборки не принимают предложение <code class="literal">REPEATABLE</code> и выдают разные выборки при каждом использовании.</p></dd><dt><span class="term"><em class="replaceable"><code>выборка</code></em></span></dt><dd><p>Предложение <code class="literal">FROM</code> может содержать вложенный запрос <code class="command">SELECT</code>. Можно считать, что из его результата создаётся временная таблица на время выполнения основной команды <code class="command">SELECT</code>. Заметьте, что вложенный запрос <code class="command">SELECT</code> должен заключаться в скобки и для него может задаваться псевдоним так же, как для таблицы. Здесь также можно использовать команду <a class="link" href="sql-values.html" title="VALUES"><code class="command">VALUES</code></a>.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_запроса_WITH</code></em></span></dt><dd><p>На запрос <code class="literal">WITH</code> можно ссылаться по имени, как если бы имя запроса представляло имя таблицы. (На самом деле запрос <code class="literal">WITH</code> скрывает любую реальную таблицу с тем же именем для основного запроса. Если необходимо обратиться к одноимённой реальной таблице, можно дополнить имя этой таблицы именем схемы.) Для этого имени можно задать псевдоним, так же, как и для имени таблицы.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_функции</code></em></span></dt><dd><p>В предложении <code class="literal">FROM</code> могут содержаться вызовы функций. (Это особенно полезно для функций, возвращающих множества, но в принципе можно использовать любые функции.) Можно считать, что для результата функции создаётся временная таблица на время выполнения текущей команды <code class="command">SELECT</code>. Если функция возвращает результат составного типа (это касается и функций с несколькими аргументами <code class="literal">OUT</code>), каждый атрибут результата помещается в отдельный столбец этой неявной таблицы.</p><p>Когда вызов функции дополняется необязательным предложением <code class="command">WITH ORDINALITY</code>, к столбцам результата функции добавляется столбец типа <code class="type">bigint</code>. В этом столбце нумеруются строки набора результатов функции, начиная с 1. По умолчанию ему присваивается имя <code class="literal">ordinality</code>.</p><p>Псевдоним для функции можно задать так же, как и для таблицы. Если этот псевдоним задан, за ним можно также написать список псевдонимов столбцов, который определит альтернативные имена для атрибутов составного типа результата функции, включая имя столбца нумерации (если он присутствует).</p><p>Несколько вызовов функций можно объединить в одном элементе предложения <code class="literal">FROM</code>, заключив их в конструкцию <code class="literal">ROWS FROM( ... )</code>. Выводом такого элемента будет соединение первых строк всех функций, затем вторых строк и т. д. Если одни функции выдают меньше строк, чем другие, недостающие данные заменяются значениями NULL, так что общее число возвращаемых строк всегда будет равняться максимальному числу строк из возвращённых всеми функциями.</p><p>Если функция определена как возвращающая тип данных <code class="type">record</code>, для неё нужно указать псевдоним или ключевое слово <code class="literal">AS</code>, за которым должен идти список определений столбцов в форме <code class="literal">( <em class="replaceable"><code>имя_столбца</code></em> <em class="replaceable"><code>тип_данных</code></em> [<span class="optional">, ... </span>])</code>. Список определений столбцов должен соответствовать фактическому количеству и типу столбцов, возвращаемых функцией.</p><p>Если при использовании синтаксиса <code class="literal">ROWS FROM( ... )</code> одна из функций требует наличия списка определений столбцов, этот список лучше разместить после вызова функции внутри <code class="literal">ROWS FROM( ... )</code>. Список определений столбцов можно поместить после конструкции <code class="literal">ROWS FROM( ... )</code>, только если вызывается всего одна функция, а предложение <code class="literal">WITH ORDINALITY</code> отсутствует.</p><p>Чтобы использовать <code class="literal">ORDINALITY</code> со списком определений столбцов, необходимо применить запись <code class="literal">ROWS FROM( ... )</code> и поместить список с определениями столбцов внутрь <code class="literal">ROWS FROM( ... )</code>.</p></dd><dt><span class="term"><em class="replaceable"><code>тип_соединения</code></em></span></dt><dd><p>Один из следующих вариантов: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">[ INNER ] JOIN</code></p></li><li class="listitem"><p><code class="literal">LEFT [ OUTER ] JOIN</code></p></li><li class="listitem"><p><code class="literal">RIGHT [ OUTER ] JOIN</code></p></li><li class="listitem"><p><code class="literal">FULL [ OUTER ] JOIN</code></p></li></ul></div><p> Для типов соединений <code class="literal">INNER</code> и <code class="literal">OUTER</code> необходимо указать условие соединения, а именно одно из предложений <code class="literal">ON <em class="replaceable"><code>условие_соединения</code></em></code>, <code class="literal">USING (<em class="replaceable"><code>столбец_соединения</code></em> [, ...])</code>, или <code class="literal">NATURAL</code>. Эти предложения описываются ниже.</p><p>Предложение <code class="literal">JOIN</code> объединяет два элемента списка <code class="literal">FROM</code>, которые мы для простоты дальше будем называть <span class="quote">«<span class="quote">таблицами</span>»</span>, хотя на самом деле это может быть любой объект, допустимый в качестве элемента <code class="literal">FROM</code>. Для определения порядка вложенности при необходимости следует использовать скобки. В отсутствие скобок предложения <code class="literal">JOIN</code> обрабатывается слева направо. В любом случае <code class="literal">JOIN</code> связывает элементы сильнее, чем запятые, разделяющие элементы в списке <code class="literal">FROM</code>. Все возможности <code class="literal">JOIN</code> существуют просто для удобства записи, они не дают ничего такого, чего нельзя было бы получить, применяя обычные предложения <code class="literal">FROM</code> и <code class="literal">WHERE</code>.</p><p><code class="literal">LEFT OUTER JOIN</code> возвращает все строки ограниченного декартова произведения (т. е. все объединённые строки, удовлетворяющие условию соединения) плюс все строки в таблице слева, для которых не находится строк в таблице справа, удовлетворяющих условию. Строка, взятая из таблицы слева, дополняется до полной ширины объединённой таблицы значениями NULL в столбцах таблицы справа. Заметьте, что для определения, какие строки двух таблиц соответствуют друг другу, проверяется только условие самого предложения <code class="literal">JOIN</code>. Внешние условия проверяются позже.</p><p><code class="literal">RIGHT OUTER JOIN</code>, напротив, возвращает все соединённые строки плюс одну строку для каждой строки справа, не имеющей соответствия слева (эта строка дополняется значениями NULL влево). Это предложение введено исключительно для удобства записи, так как его можно легко свести к <code class="literal">LEFT OUTER JOIN</code>, поменяв левую и правую таблицы местами.</p><p><code class="literal">FULL OUTER JOIN</code> возвращает все соединённые строки плюс все строки слева, не имеющие соответствия справа, (дополненные значениями NULL вправо) плюс все строки справа, не имеющие соответствия слева (дополненные значениями NULL влево).</p></dd><dt><span class="term"><code class="literal">ON <em class="replaceable"><code>условие_соединения</code></em></code></span></dt><dd><p>Задаваемое <em class="replaceable"><code>условие_соединения</code></em> представляет собой выражение, выдающее значение типа <code class="type">boolean</code> (как в предложении <code class="literal">WHERE</code>), которое определяет, какие строки считаются соответствующими при соединении.</p></dd><dt><span class="term"><code class="literal">USING ( <em class="replaceable"><code>столбец_соединения</code></em> [, ...] ) [ AS <em class="replaceable"><code>псевдоним_использования_соединения</code></em> ]</code></span></dt><dd><p>Предложение вида <code class="literal">USING ( a, b, ... )</code> представляет собой сокращённую форму записи <code class="literal">ON таблица_слева.a = таблица_справа.a AND таблица_слева.b = таблица_справа.b ...</code>. Кроме того, <code class="literal">USING</code> подразумевает, что в результат соединения будет включён только один из пары равных столбцов, но не оба.</p><p>Если задан <em class="replaceable"><code>псевдоним_использования_соединения</code></em>, он определяет псевдоним таблицы со столбцами соединения. По этому имени можно будет обращаться только к столбцам соединения, перечисленным в предложении <code class="literal">USING</code>. В отличие от обычного <em class="replaceable"><code>псевдонима</code></em>, он не скрывает имена соединяемых таблиц от остального запроса. Также в отличие от <em class="replaceable"><code>псевдонима</code></em>, с ним нельзя задать список псевдонимов столбцов — выходными именами столбцов соединения будут те же имена, что фигурируют в списке <code class="literal">USING</code>.</p></dd><dt><span class="term"><code class="literal">NATURAL</code></span></dt><dd><p><code class="literal">NATURAL</code> представляет собой краткую запись <code class="literal">USING</code> со списком, в котором перечисляются все столбцы двух таблиц, имеющие одинаковые имена. Если одинаковых имён нет, указание <code class="literal">NATURAL</code> равнозначно <code class="literal">ON TRUE</code>.</p></dd><dt><span class="term"><code class="literal">CROSS JOIN</code></span></dt><dd><p>Предложение <code class="literal">CROSS JOIN</code> равнозначно <code class="literal">INNER JOIN ON (TRUE)</code>, то есть с ним никакие строки по условию не удаляются. Оба эти предложения формируют простое декартово произведение — тот же результат получится, если указать две таблицы на верхнем уровне <code class="literal">FROM</code> и добавить в качестве ограничения условие соединения (если оно есть).</p></dd><dt><span class="term"><code class="literal">LATERAL</code></span></dt><dd><p>Ключевое слово <code class="literal">LATERAL</code> может предварять вложенный запрос <code class="command">SELECT</code> в списке <code class="literal">FROM</code>. Оно позволяет обращаться в этом вложенном <code class="command">SELECT</code> к столбцам элементов <code class="literal">FROM</code>, предшествующим ему в списке <code class="literal">FROM</code>. (Без <code class="literal">LATERAL</code> все вложенные подзапросы <code class="command">SELECT</code> обрабатываются независимо и не могут ссылаться на другие элементы списка <code class="literal">FROM</code>.)</p><p>Слово <code class="literal">LATERAL</code> можно также добавить перед вызовом функции в списке <code class="literal">FROM</code>, но в этом случае оно будет избыточным, так как выражения с функциями могут ссылаться на предыдущие элементы списка <code class="literal">FROM</code> в любом случае.</p><p>Элемент <code class="literal">LATERAL</code> может находиться на верхнем уровне списка <code class="literal">FROM</code> или в дереве <code class="literal">JOIN</code>. В последнем случае он может также ссылаться на любые элементы в левой части <code class="literal">JOIN</code>, справа от которого он находится.</p><p>Когда элемент <code class="literal">FROM</code> содержит ссылки <code class="literal">LATERAL</code>, запрос выполняется следующим образом: сначала для строки элемента <code class="literal">FROM</code> с целевыми столбцами, или набора строк из нескольких элементов <code class="literal">FROM</code>, содержащих целевые столбцы, вычисляется элемент <code class="literal">LATERAL</code> со значениями этих столбцов. Затем результирующие строки обычным образом соединяются со строками, из которых они были вычислены. Эта процедура повторяется для всех строк исходных таблиц.</p><p>Таблица, служащая источником столбцов, должна быть связана с элементом <code class="literal">LATERAL</code> соединением <code class="literal">INNER</code> или <code class="literal">LEFT</code>, в противном случае не образуется однозначно определяемый набор строк, из которого можно будет получать наборы строк для элемента <code class="literal">LATERAL</code>. Таким образом, хотя конструкция <code class="literal"><em class="replaceable"><code>X</code></em> RIGHT JOIN LATERAL <em class="replaceable"><code>Y</code></em></code> синтаксически правильная, <em class="replaceable"><code>Y</code></em> в ней не может обращаться к <em class="replaceable"><code>X</code></em>.</p></dd></dl></div></div><div class="refsect2" id="SQL-WHERE"><h3>Предложение <code class="literal">WHERE</code></h3><p>Необязательное предложение <code class="literal">WHERE</code> имеет общую форму </p><pre class="synopsis">
WHERE <em class="replaceable"><code>условие</code></em>
</pre><p>, где <em class="replaceable"><code>условие</code></em> — любое выражение, выдающее результат типа <code class="type">boolean</code>. Любая строка, не удовлетворяющая этому условию, исключается из результата. Строка удовлетворяет условию, если оно возвращает true при подстановке вместо ссылок на переменные фактических значений из этой строки.</p></div><div class="refsect2" id="SQL-GROUPBY"><h3>Предложение <code class="literal">GROUP BY</code></h3><p>Необязательное предложение <code class="literal">GROUP BY</code> имеет общую форму </p><pre class="synopsis">
GROUP BY [ ALL | DISTINCT ] <em class="replaceable"><code>элемент_группирования</code></em> [, ...]
</pre><p><code class="literal">GROUP BY</code> собирает в одну строку все выбранные строки, выдающие одинаковые значения для выражений группировки. В качестве <em class="replaceable"><code>выражения</code></em> внутри <em class="replaceable"><code>элемента_группирования</code></em> может выступать имя входного столбца, либо имя или порядковый номер выходного столбца (из списка элементов <code class="command">SELECT</code>), либо произвольное значение, вычисляемое по значениям входных столбцов. В случае неоднозначности имя в <code class="literal">GROUP BY</code> будет восприниматься как имя входного, а не выходного столбца.</p><p>Если в элементе группирования задаётся <code class="literal">GROUPING SETS</code>, <code class="literal">ROLLUP</code> или <code class="literal">CUBE</code>, предложение <code class="literal">GROUP BY</code> в целом определяет некоторое число независимых <em class="replaceable"><code>наборов группирования</code></em>. Это даёт тот же эффект, что и объединение подзапросов (с <code class="literal">UNION ALL</code>) с отдельными наборами группирования в их предложениях <code class="literal">GROUP BY</code>. Необязательное предложение <code class="literal">DISTINCT</code> исключает повторяющиеся наборы перед обработкой, но оно <span class="emphasis"><em>не</em></span> преобразует <code class="literal">UNION ALL</code> в <code class="literal">UNION DISTINCT</code>. Подробнее использование наборов группирования описывается в <a class="xref" href="queries-table-expressions.html#QUERIES-GROUPING-SETS" title="7.2.4. GROUPING SETS, CUBE и ROLLUP">Подразделе 7.2.4</a>.</p><p>Агрегатные функции, если они используются, вычисляются по всем строкам, составляющим каждую группу, и в итоге выдают отдельное значение для каждой группы. (Если агрегатные функции используются без предложения <code class="literal">GROUP BY</code>, запрос выполняется как с одной группой, включающей все выбранные строки.) Набор строк, поступающих в каждую агрегатную функцию, можно дополнительно отфильтровать, добавив предложение <code class="literal">FILTER</code> к вызову агрегатной функции; за дополнительными сведениями обратитесь к <a class="xref" href="sql-expressions.html#SYNTAX-AGGREGATES" title="4.2.7. Агрегатные выражения">Подразделу 4.2.7</a>. С предложением <code class="literal">FILTER</code> на вход агрегатной функции поступают только те строки, которые соответствуют заданному фильтру.</p><p>Когда в запросе присутствует предложение <code class="literal">GROUP BY</code> или какая-либо агрегатная функция, выражения в списке <code class="command">SELECT</code> не могут обращаться к негруппируемым столбцам, кроме как в агрегатных функциях или в случае функциональной зависимости, так как иначе в негруппируемом столбце нужно было бы вернуть более одного возможного значения. Функциональная зависимость образуется, если группируемые столбцы (или их подмножество) составляют первичный ключ таблицы, содержащей негруппируемый столбец.</p><p>Имейте в виду, что все агрегатные функции вычисляются перед <span class="quote">«<span class="quote">скалярными</span>»</span> выражениями в предложении <code class="literal">HAVING</code> или списке <code class="literal">SELECT</code>. Это значит, что например, с помощью выражения <code class="literal">CASE</code> нельзя обойти вычисление агрегатной функции; см. <a class="xref" href="sql-expressions.html#SYNTAX-EXPRESS-EVAL" title="4.2.14. Правила вычисления выражений">Подраздел 4.2.14</a>.</p><p>В настоящее время указания <code class="literal">FOR NO KEY UPDATE</code>, <code class="literal">FOR UPDATE</code>, <code class="literal">FOR SHARE</code> и <code class="literal">FOR KEY SHARE</code> нельзя задать вместе с <code class="literal">GROUP BY</code>.</p></div><div class="refsect2" id="SQL-HAVING"><h3>Предложение <code class="literal">HAVING</code></h3><p>Необязательное предложение <code class="literal">HAVING</code> имеет общую форму </p><pre class="synopsis">
HAVING <em class="replaceable"><code>условие</code></em>
</pre><p> Здесь <em class="replaceable"><code>условие</code></em> задаётся так же, как и для предложения <code class="literal">WHERE</code>.</p><p><code class="literal">HAVING</code> исключает из результата строки групп, не удовлетворяющих условию. <code class="literal">HAVING</code> отличается от <code class="literal">WHERE</code>: <code class="literal">WHERE</code> фильтрует отдельные строки до применения <code class="literal">GROUP BY</code>, а <code class="literal">HAVING</code> фильтрует строки групп, созданных предложением <code class="literal">GROUP BY</code>. Каждый столбец, фигурирующий в <em class="replaceable"><code>условии</code></em>, должен однозначно ссылаться на группируемый столбец, за исключением случаев, когда эта ссылка находится внутри агрегатной функции или негруппируемый столбец функционально зависит от группируемых.</p><p>В присутствие <code class="literal">HAVING</code> запрос превращается в группируемый, даже если <code class="literal">GROUP BY</code> отсутствует. То же самое происходит, когда запрос содержит агрегатные функции, но не предложение <code class="literal">GROUP BY</code>. Все выбранные строки считаются формирующими одну группу, а в списке <code class="command">SELECT</code> и предложении <code class="literal">HAVING</code> можно обращаться к столбцам таблицы только из агрегатных функций. Такой запрос будет выдавать единственную строку, если результат условия <code class="literal">HAVING</code> — true, и ноль строк в противном случае.</p><p>В настоящее время указания <code class="literal">FOR NO KEY UPDATE</code>, <code class="literal">FOR UPDATE</code>, <code class="literal">FOR SHARE</code> и <code class="literal">FOR KEY SHARE</code> нельзя задать вместе с <code class="literal">HAVING</code>.</p></div><div class="refsect2" id="SQL-WINDOW"><h3>Предложение <code class="literal">WINDOW</code></h3><p>Необязательное предложение <code class="literal">WINDOW</code> имеет общую форму </p><pre class="synopsis">
WINDOW <em class="replaceable"><code>имя_окна</code></em> AS ( <em class="replaceable"><code>определение_окна</code></em> ) [, ...]
</pre><p> Здесь <em class="replaceable"><code>имя_окна</code></em> — это имя, на которое можно ссылаться из предложений <code class="literal">OVER</code> или последующих определений окон, а <em class="replaceable"><code>определение_окна</code></em> имеет следующий вид: </p><pre class="synopsis">
[ <em class="replaceable"><code>имя_существующего_окна</code></em> ]
[ PARTITION BY <em class="replaceable"><code>выражение</code></em> [, ...] ]
[ ORDER BY <em class="replaceable"><code>выражение</code></em> [ ASC | DESC | USING <em class="replaceable"><code>оператор</code></em> ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ <em class="replaceable"><code>предложение_рамки</code></em> ]
</pre><p>Если указано <em class="replaceable"><code>имя_существующего_окна</code></em>, оно должно ссылаться на предшествующую запись в списке <code class="literal">WINDOW</code>; новое окно копирует предложение разбиения из этой записи, а также предложение сортировки, если оно присутствует. В этом случае для нового окна нельзя задать собственное предложение <code class="literal">PARTITION BY</code>, а <code class="literal">ORDER BY</code> можно указать, только если его не было у копируемого окна. Новое окно всегда использует собственное предложение рамки; в копируемом окне оно задаваться не должно.</p><p>Элементы списка <code class="literal">PARTITION BY</code> интерпретируется во многом так же, как и элементы списка <a class="link" href="sql-select.html#SQL-GROUPBY" title="Предложение GROUP BY"><code class="literal">GROUP BY</code></a>, за исключением того, что это всегда простые выражения, но не имя или номер выходного столбца. Другое различие состоит в том, что эти выражения могут содержать вызовы агрегатных функций, которые не допускаются в обычном предложении <code class="literal">GROUP BY</code>. Здесь они допускаются потому, что формирование окна происходит после группировки и агрегирования.</p><p>Подобным образом, элементы списка <code class="literal">ORDER BY</code> интерпретируются во многом так же, как и элементы предложения <a class="link" href="sql-select.html#SQL-ORDERBY" title="Предложение ORDER BY"><code class="literal">ORDER BY</code></a> на уровне оператора, за исключением того, что они всегда воспринимаются как простые выражения, но не как имя или номер выходного столбца.</p><p>Необязательное <em class="replaceable"><code>предложение_рамки</code></em> определяет <em class="firstterm">рамку окна</em> для оконных функций, которые зависят от рамки (не все функции таковы). Рамка окна — это набор связанных строк для каждой строки запроса (называемой <em class="firstterm">текущей строкой</em>). В качестве <em class="replaceable"><code>предложения_рамки</code></em> может задаваться </p><pre class="synopsis">
{ RANGE | ROWS | GROUPS } <em class="replaceable"><code>начало_рамки</code></em> [ <em class="replaceable"><code>исключение_рамки</code></em> ]
{ RANGE | ROWS | GROUPS } BETWEEN <em class="replaceable"><code>начало_рамки</code></em> AND <em class="replaceable"><code>конец_рамки</code></em> [ <em class="replaceable"><code>исключение_рамки</code></em> ]
</pre><p> Здесь <em class="replaceable"><code>начало_рамки</code></em> и <em class="replaceable"><code>конец_рамки</code></em> может задаваться как </p><pre class="synopsis">
UNBOUNDED PRECEDING
<em class="replaceable"><code>смещение</code></em> PRECEDING
CURRENT ROW
<em class="replaceable"><code>смещение</code></em> FOLLOWING
UNBOUNDED FOLLOWING
</pre><p> и <em class="replaceable"><code>исключение_рамки</code></em> может быть таким: </p><pre class="synopsis">
EXCLUDE CURRENT ROW
EXCLUDE GROUP
EXCLUDE TIES
EXCLUDE NO OTHERS
</pre><p> Если <em class="replaceable"><code>конец_рамки</code></em> опущен, по умолчанию подразумевается <code class="literal">CURRENT ROW</code>. В качестве <em class="replaceable"><code>начала_рамки</code></em> нельзя задать <code class="literal">UNBOUNDED FOLLOWING</code>, в качестве <em class="replaceable"><code>конца_рамки</code></em> не допускается <code class="literal">UNBOUNDED PRECEDING</code>, и <em class="replaceable"><code>конец_рамки</code></em> не может идти в показанном выше списке указаний <em class="replaceable"><code>начало_рамки</code></em> AND <em class="replaceable"><code>конец_рамки</code></em> перед <em class="replaceable"><code>началом_рамки</code></em> — например, синтаксис <code class="literal">RANGE BETWEEN CURRENT ROW AND <em class="replaceable"><code>смещение</code></em> PRECEDING</code> не допускается.</p><p>По умолчанию рамка образуется предложением <code class="literal">RANGE UNBOUNDED PRECEDING</code>, что по сути то же, что <code class="literal">RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>; оно устанавливает рамку так, что она включает все строки от начала раздела до последней строки, <em class="firstterm">родственной</em> текущей (строки, которые согласно указанному для окна предложению <code class="literal">ORDER BY</code> считаются равными текущей; если <code class="literal">ORDER BY</code> отсутствует, все строки считаются родственными). Вообще <code class="literal">UNBOUNDED PRECEDING</code> означает, что рамка начинается с первой строки раздела, а <code class="literal">UNBOUNDED FOLLOWING</code> означает, что рамка заканчивается на последней строке раздела, независимо от режима <code class="literal">RANGE</code>, <code class="literal">ROWS</code> или <code class="literal">GROUPS</code>. В режиме <code class="literal">ROWS</code> указание <code class="literal">CURRENT ROW</code> означает, что рамка начинается или заканчивается текущей строкой; но в режиме <code class="literal">RANGE</code> или <code class="literal">GROUPS</code> оно означает, что рамка начинается или заканчивается первой или последней строкой, родственной текущей, согласно порядку <code class="literal">ORDER BY</code>. Варианты <em class="replaceable"><code>смещение</code></em> <code class="literal">PRECEDING</code> и <em class="replaceable"><code>смещение</code></em> <code class="literal">FOLLOWING</code> означают разное в зависимости от режима рамки. В режиме <code class="literal">ROWS</code> целочисленное <em class="replaceable"><code>смещение</code></em> определяет сдвиг, с которым начало рамки позиционируется перед текущей строкой, а конец рамки — после текущей строки. В режиме <code class="literal">GROUPS</code> целочисленное <em class="replaceable"><code>смещение</code></em> аналогичным образом определяет сдвиг относительно группы строк, родственных текущей, где <em class="firstterm">группа родственных строк</em> — группа строк, считающихся равными согласно предложению <code class="literal">ORDER BY</code> для данного окна. В режиме <code class="literal">RANGE</code> для указания <em class="replaceable"><code>смещения</code></em> необходимо присутствие в определении окна ровно одного столбца <code class="literal">ORDER BY</code>. Тогда рамка будет содержать те строки, в которых значение упорядочивающего столбца не более чем на <em class="replaceable"><code>смещение</code></em> меньше (для <code class="literal">PRECEDING</code>) или больше (для <code class="literal">FOLLOWING</code>) значения упорядочивающего столбца в текущей строке. В этом случае тип данных выражения <em class="replaceable"><code>смещение</code></em> зависит от типа данных упорядочивающего столбца. Для числовых столбцов это обычно тот же числовой тип, а для столбцов с типом дата/время — тип <code class="type">interval</code>. Во всех этих случаях значение <em class="replaceable"><code>смещения</code></em> должно быть отличным от NULL и неотрицательным. Кроме того, хотя <em class="replaceable"><code>смещение</code></em> не обязательно должно быть простой константой, оно не может содержать переменные, агрегатные или оконные функции.</p><p>Дополнение <em class="replaceable"><code>исключение_рамки</code></em> позволяет исключить из рамки строки, которые окружают текущую строку, даже если они должны быть включены согласно указаниям, определяющим начало и конец рамки. <code class="literal">EXCLUDE CURRENT ROW</code> исключает из рамки текущую строку. <code class="literal">EXCLUDE GROUP</code> исключает из рамки текущую строку и родственные ей согласно порядку сортировки. <code class="literal">EXCLUDE TIES</code> исключает из рамки все родственные строки для текущей, но не собственно текущую строку. <code class="literal">EXCLUDE NO OTHERS</code> просто явно выражает поведение по умолчанию — не исключает ни текущую строку, ни родственные ей.</p><p>Учтите, что в режиме <code class="literal">ROWS</code> могут выдаваться непредсказуемые результаты, если согласно порядку, заданному в <code class="literal">ORDER BY</code>, строки сортируются неоднозначно. Режимы <code class="literal">RANGE</code> и <code class="literal">GROUPS</code> предусмотрены для того, чтобы строки, являющиеся родственными в порядке <code class="literal">ORDER BY</code>, обрабатывались одинаково: все строки определённой группы попадут в одну рамку или будут исключены из неё.</p><p>Предложение <code class="literal">WINDOW</code> применяется для управления поведением <em class="firstterm">оконных функций</em>, фигурирующих в запросе, в <a class="link" href="sql-select.html#SQL-SELECT-LIST" title="Список SELECT">списке <code class="command">SELECT</code></a> или предложении <a class="link" href="sql-select.html#SQL-ORDERBY" title="Предложение ORDER BY"><code class="literal">ORDER BY</code></a>. Эти функции могут обращаться к элементам <code class="literal">WINDOW</code> по именам в своих предложениях <code class="literal">OVER</code>. При этом элементы <code class="literal">WINDOW</code> не обязательно задействовать в запросе; если они не используются, они просто игнорируются. Оконные функции можно использовать вовсе без элементов <code class="literal">WINDOW</code>, так как в вызове оконной функции можно задать определение окна непосредственно в предложении <code class="literal">OVER</code>. Однако предложение <code class="literal">WINDOW</code> позволяет сократить текст запроса, когда одно и то же определение окна применяется при вызове нескольких оконных функций.</p><p>В настоящее время указания <code class="literal">FOR NO KEY UPDATE</code>, <code class="literal">FOR UPDATE</code>, <code class="literal">FOR SHARE</code> и <code class="literal">FOR KEY SHARE</code> нельзя задать вместе с <code class="literal">WINDOW</code>.</p><p>Оконные функции подробно описываются в <a class="xref" href="tutorial-window.html" title="3.5. Оконные функции">Разделе 3.5</a>, <a class="xref" href="sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS" title="4.2.8. Вызовы оконных функций">Подразделе 4.2.8</a> и <a class="xref" href="queries-table-expressions.html#QUERIES-WINDOW" title="7.2.5. Обработка оконных функций">Подразделе 7.2.5</a>.</p></div><div class="refsect2" id="SQL-SELECT-LIST"><h3>Список <code class="command">SELECT</code></h3><p>Список <code class="command">SELECT</code> (между ключевыми словами <code class="literal">SELECT</code> и <code class="literal">FROM</code>) содержит выражения, которые формируют выходные строки оператора <code class="command">SELECT</code>. Эти выражения могут обращаться (и обычно обращаются) к столбцам, вычисленным в предложении <code class="literal">FROM</code>.</p><p>Так же, как в таблице, каждый выходной столбец <code class="command">SELECT</code> имеет имя. В простом предложении <code class="command">SELECT</code> это имя просто помечает столбец при выводе, но когда <code class="command">SELECT</code> представляет собой подзапрос большого запроса, это имя большой запрос видит как имя столбца виртуальной таблицы, созданной подзапросом. Чтобы задать имя для выходного столбца, нужно написать <code class="literal">AS</code> <em class="replaceable"><code>выходное_имя</code></em> после выражения столбца. (Слово <code class="literal">AS</code> можно опустить, но только если желаемое выходное имя не совпадает с каким-либо ключевым словом <span class="productname">PostgreSQL</span> (см. <a class="xref" href="sql-keywords-appendix.html" title="Приложение C. Ключевые слова SQL">Приложение C</a>). Чтобы не зависеть от появления новых ключевых слов в будущем, рекомендуется всегда писать <code class="literal">AS</code>, либо заключать имя в двойные кавычки.) Если имя столбца не задать, <span class="productname">PostgreSQL</span> выберет его автоматически. Если выражение столбца представляет собой просто ссылку на столбец, то выбранное таким образом имя будет совпадать с именем столбца. В более сложных случаях может использоваться имя функции или типа, либо в отсутствие других вариантов система может сгенерировать имя вроде <code class="literal">?column?</code>.</p><p>По имени выходного столбца можно обратиться к его значению в предложениях <code class="literal">ORDER BY</code> и <code class="literal">GROUP BY</code>, но не в <code class="literal">WHERE</code> или <code class="literal">HAVING</code>; в них вместо имени надо записывать всё выражение.</p><p>Вместо выражения в выходном списке можно указать <code class="literal">*</code>, что будет обозначать все столбцы выбранных строк. Кроме того, можно записать <code class="literal"><em class="replaceable"><code>имя_таблицы</code></em>.*</code> как краткое обозначение всех столбцов, получаемых из данной таблицы. В этих случаях нельзя задать новые имена столбцов с помощью <code class="literal">AS</code>; именами выходных столбцов будут имена столбцов в таблице.</p><p>Согласно стандарту SQL, выражения в выходном списке должны вычисляться до применения <code class="literal">DISTINCT</code>, <code class="literal">ORDER BY</code> или <code class="literal">LIMIT</code>. Это, очевидно, необходимо для <code class="literal">DISTINCT</code>, так как иначе не будет ясно, какие значения должны выдаваться как уникальные. Однако во многих случаях выходные выражения удобнее вычислять после <code class="literal">ORDER BY</code> и <code class="literal">LIMIT</code>; в частности, если в выходном списке содержатся изменчивые или дорогостоящие функции. В этом случае порядок вычисления функций оказывается более интуитивным, а для строк, которые не попадут в результат, не будут производиться вычисления. <span class="productname">PostgreSQL</span> фактически будет вычислять выходные выражения после сортировки и ограничения их количества, если эти выражения не фигурируют в <code class="literal">DISTINCT</code>, <code class="literal">ORDER BY</code> или <code class="literal">GROUP BY</code>. (Например, в запросе <code class="literal">SELECT f(x) FROM tab ORDER BY 1</code> функция <code class="function">f(x)</code>, несомненно, должна вычисляться перед сортировкой.) Выходные выражения, содержащие функции, возвращающие множества, фактически вычисляются после сортировки и до ограничения количества строк, так что <code class="literal">LIMIT</code> будет отбрасывать строки, выдаваемые функцией, возвращающей множество.</p><div class="note"><h3 class="title">Примечание</h3><p>В <span class="productname">PostgreSQL</span> до версии 9.6 никакой порядок вычисления выходных выражений по отношению к сортировке или ограничениям количества не гарантировался; он зависел от формы выбранного плана запроса.</p></div></div><div class="refsect2" id="SQL-DISTINCT"><h3>Предложение <code class="literal">DISTINCT</code></h3><p>Если указано <code class="literal">SELECT DISTINCT</code>, все повторяющиеся строки исключаются из результирующего набора (из каждой группы дубликатов остаётся одна строка). <code class="literal">SELECT ALL</code> делает противоположное: сохраняет все строки; это поведение по умолчанию.</p><p><code class="literal">SELECT DISTINCT ON ( <em class="replaceable"><code>выражение</code></em> [, ...] )</code> сохраняет только первую строку из каждого набора строк, для которого данное выражение даёт одинаковые значения. Выражения <code class="literal">DISTINCT ON</code> обрабатываются по тем же правилам, что и выражения <code class="literal">ORDER BY</code> (см. выше). Заметьте, что <span class="quote">«<span class="quote">первая строка</span>»</span> каждого набора непредсказуема, если только не применяется предложение <code class="literal">ORDER BY</code>, определяющее, какие строки должны быть первыми. Например: </p><pre class="programlisting">SELECT DISTINCT ON (location) location, time, report
    FROM weather_reports
    ORDER BY location, time DESC;</pre><p> возвращает самую последнюю сводку погоды для каждого местоположения. Но если бы мы не добавили <code class="literal">ORDER BY</code>, чтобы значения времени убывали, мы бы получили сводки по местоположениям от непредсказуемого времени.</p><p>Выражения <code class="literal">DISTINCT ON</code> должны соответствовать самым левым выражениям в <code class="literal">ORDER BY</code>. Предложение <code class="literal">ORDER BY</code> обычно содержит и другие выражения, которые определяют желаемый порядок строк в каждой группе <code class="literal">DISTINCT ON</code>.</p><p>В настоящее время указания <code class="literal">FOR NO KEY UPDATE</code>, <code class="literal">FOR UPDATE</code>, <code class="literal">FOR SHARE</code> и <code class="literal">FOR KEY SHARE</code> нельзя задать вместе с <code class="literal">DISTINCT</code>.</p></div><div class="refsect2" id="SQL-UNION"><h3>Предложение <code class="literal">UNION</code>+</h3><p>Предложение <code class="literal">UNION</code> имеет следующую общую форму: </p><pre class="synopsis">
<em class="replaceable"><code>оператор_SELECT</code></em> UNION [ ALL | DISTINCT ] <em class="replaceable"><code>оператор_SELECT</code></em>
</pre><p> Здесь <em class="replaceable"><code>оператор_SELECT</code></em> — это любой подзапрос <code class="command">SELECT</code> без предложений <code class="literal">ORDER BY</code>, <code class="literal">LIMIT</code>, <code class="literal">FOR NO KEY UPDATE</code>, <code class="literal">FOR UPDATE</code>, <code class="literal">FOR SHARE</code> и <code class="literal">FOR KEY SHARE</code>. (<code class="literal">ORDER BY</code> и <code class="literal">LIMIT</code> можно добавить к вложенному выражению, если оно заключено в скобки. Без скобок эти предложения будут восприняты как применяемые к результату <code class="literal">UNION</code>, а не к выражению в его правой части.)</p><p>Оператор <code class="literal">UNION</code> вычисляет объединение множеств всех строк, возвращённых заданными запросами <code class="command">SELECT</code>. Строка оказывается в объединении двух наборов результатов, если она присутствует минимум в одном наборе. Два оператора <code class="command">SELECT</code>, представляющие прямые операнды <code class="literal">UNION</code>, должны выдавать одинаковое число столбцов, а типы соответствующих столбцов должны быть совместимыми.</p><p>Результат <code class="literal">UNION</code> не будет содержать повторяющихся строк, если не указан параметр <code class="literal">ALL</code>. <code class="literal">ALL</code> предотвращает исключение дубликатов. (Таким образом, <code class="literal">UNION ALL</code> обычно работает значительно быстрее, чем <code class="literal">UNION</code>; поэтому, везде, где возможно, следует указывать <code class="literal">ALL</code>.) <code class="literal">DISTINCT</code> можно записать явно, чтобы обозначить, что дублирующиеся строки должны удаляться (это поведение по умолчанию).</p><p>При использовании в одном запросе <code class="command">SELECT</code> нескольких операторов <code class="literal">UNION</code> они вычисляются слева направо, если иной порядок не определяется скобками.</p><p>В настоящее время указания <code class="literal">FOR NO KEY UPDATE</code>, <code class="literal">FOR UPDATE</code>, <code class="literal">FOR SHARE</code> и <code class="literal">FOR KEY SHARE</code> нельзя задать ни для результата <code class="literal">UNION</code>, ни для любого из подзапросов <code class="literal">UNION</code>.</p></div><div class="refsect2" id="SQL-INTERSECT"><h3>Предложение <code class="literal">INTERSECT</code></h3><p>Предложение <code class="literal">INTERSECT</code> имеет следующую общую форму: </p><pre class="synopsis">
<em class="replaceable"><code>оператор_SELECT</code></em> INTERSECT [ ALL | DISTINCT ] <em class="replaceable"><code>оператор_SELECT</code></em>
</pre><p> Здесь <em class="replaceable"><code>оператор_SELECT</code></em> — это любой подзапрос <code class="command">SELECT</code> без предложений <code class="literal">ORDER BY</code>, <code class="literal">LIMIT</code>, <code class="literal">FOR NO KEY UPDATE</code>, <code class="literal">FOR UPDATE</code>, <code class="literal">FOR SHARE</code> и <code class="literal">FOR KEY SHARE</code>.</p><p>Оператор <code class="literal">INTERSECT</code> вычисляет пересечение множеств всех строк, возвращённых заданными запросами <code class="command">SELECT</code>. Строка оказывается в пересечении двух наборов результатов, если она присутствует в обоих наборах.</p><p>Результат <code class="literal">INTERSECT</code> не будет содержать повторяющихся строк, если не указан параметр <code class="literal">ALL</code>. С параметром <code class="literal">ALL</code> строка, повторяющаяся <em class="replaceable"><code>m</code></em> раз в левой таблице и <em class="replaceable"><code>n</code></em> раз в правой, будет выдана в результирующем наборе min(<em class="replaceable"><code>m</code></em>,<em class="replaceable"><code>n</code></em>) раз. <code class="literal">DISTINCT</code> можно записать явно, чтобы обозначить, что дублирующиеся строки должны удаляться (это поведение по умолчанию).</p><p>При использовании в одном запросе <code class="command">SELECT</code> нескольких операторов <code class="literal">INTERSECT</code> они вычисляются слева направо, если иной порядок не диктуется скобками. <code class="literal">INTERSECT</code> связывает свои подзапросы сильнее, чем <code class="literal">UNION</code>. Другими словами, <code class="literal">A UNION B INTERSECT C</code> будет восприниматься как <code class="literal">A UNION (B INTERSECT C)</code>.</p><p>В настоящее время указания <code class="literal">FOR NO KEY UPDATE</code>, <code class="literal">FOR UPDATE</code>, <code class="literal">FOR SHARE</code> и <code class="literal">FOR KEY SHARE</code> нельзя задать ни для результата <code class="literal">INTERSECT</code>, ни для любого из подзапросов <code class="literal">INTERSECT</code>.</p></div><div class="refsect2" id="SQL-EXCEPT"><h3>Предложение <code class="literal">EXCEPT</code></h3><p>Предложение <code class="literal">EXCEPT</code> имеет следующую общую форму: </p><pre class="synopsis">
<em class="replaceable"><code>оператор_SELECT</code></em> EXCEPT [ ALL | DISTINCT ] <em class="replaceable"><code>оператор_SELECT</code></em>
</pre><p> Здесь <em class="replaceable"><code>оператор_SELECT</code></em> — это любой подзапрос <code class="command">SELECT</code> без предложений <code class="literal">ORDER BY</code>, <code class="literal">LIMIT</code>, <code class="literal">FOR NO KEY UPDATE</code>, <code class="literal">FOR UPDATE</code>, <code class="literal">FOR SHARE</code> и <code class="literal">FOR KEY SHARE</code>.</p><p>Оператор <code class="literal">EXCEPT</code> вычисляет набор строк, которые присутствуют в результате левого запроса <code class="command">SELECT</code>, но отсутствуют в результате правого.</p><p>Результат <code class="literal">EXCEPT</code> не будет содержать повторяющихся строк, если не указан параметр <code class="literal">ALL</code>. С параметром <code class="literal">ALL</code> строка, повторяющаяся <em class="replaceable"><code>m</code></em> раз в левой таблице и <em class="replaceable"><code>n</code></em> раз в правой, будет выдана в результирующем наборе max(<em class="replaceable"><code>m</code></em>-<em class="replaceable"><code>n</code></em>,0) раз. <code class="literal">DISTINCT</code> можно записать явно, чтобы обозначить, что дублирующиеся строки должны удаляться (это поведение по умолчанию).</p><p>При использовании в одном запросе <code class="command">SELECT</code> нескольких операторов <code class="literal">EXCEPT</code> они вычисляются слева направо, если иной порядок не диктуется скобками. <code class="literal">EXCEPT</code> связывает свои подзапросы так же сильно, как <code class="literal">UNION</code>.</p><p>В настоящее время указания <code class="literal">FOR NO KEY UPDATE</code>, <code class="literal">FOR UPDATE</code>, <code class="literal">FOR SHARE</code> и <code class="literal">FOR KEY SHARE</code> нельзя задать ни для результата <code class="literal">EXCEPT</code>, ни для любого из подзапросов <code class="literal">EXCEPT</code>.</p></div><div class="refsect2" id="SQL-ORDERBY"><h3>Предложение <code class="literal">ORDER BY</code></h3><p>Необязательное предложение <code class="literal">ORDER BY</code> имеет следующую общую форму: </p><pre class="synopsis">
ORDER BY <em class="replaceable"><code>выражение</code></em> [ ASC | DESC | USING <em class="replaceable"><code>оператор</code></em> ] [ NULLS { FIRST | LAST } ] [, ...]
</pre><p> Предложение <code class="literal">ORDER BY</code> указывает, что строки результата должны сортироваться согласно заданным выражениям. Если две строки дают равные значения для самого левого выражения, проверяется следующее выражение и т. д. Если их значения оказываются равными для всех заданных выражений, строки возвращаются в порядке, определяемом реализацией.</p><p>В качестве <em class="replaceable"><code>выражения</code></em> может задаваться имя или порядковый номер выходного столбца (элемента списка <code class="command">SELECT</code>), либо произвольное выражение со значениями входных столбцов.</p><p>Порядковым номером в данном случае считается последовательный номер (при нумерации слева направо) позиции выходного столбца. Возможность указать порядковый номер позволяет выполнить сортировку по столбцу, не имеющему уникального имени. В принципе это не абсолютно необходимо, так как выходному столбцу всегда можно присвоить имя, воспользовавшись предложением <code class="literal">AS</code>.</p><p>В предложении <code class="literal">ORDER BY</code> также можно использовать произвольные выражения, в том числе, и со столбцами, отсутствующими в списке результатов <code class="command">SELECT</code>. Таким образом, следующий оператор вполне корректен: </p><pre class="programlisting">SELECT name FROM distributors ORDER BY code;</pre><p> Однако если <code class="literal">ORDER BY</code> применяется к результату <code class="literal">UNION</code>, <code class="literal">INTERSECT</code> или <code class="literal">EXCEPT</code>, в нём можно задать только имя или номер выходного столбца, но не выражение.</p><p>Если в качестве выражения <code class="literal">ORDER BY</code> задано простое имя, которому соответствует и выходной, и входной столбец, то <code class="literal">ORDER BY</code> будет воспринимать его как имя выходного столбца. Этот выбор противоположен тому, что делает <code class="literal">GROUP BY</code> в такой же ситуации. Такая несогласованность допущена для соответствия стандарту SQL.</p><p>Дополнительно после любого выражения в предложении <code class="literal">ORDER BY</code> можно добавить ключевое слово <code class="literal">ASC</code> (по возрастанию) или <code class="literal">DESC</code> (по убыванию). По умолчанию подразумевается <code class="literal">ASC</code>. Кроме того, можно задать имя специфического оператора сортировки в предложении <code class="literal">USING</code>. Оператор сортировки должен быть членом «меньше» или «больше» некоторого семейства операторов B-дерева. <code class="literal">ASC</code> обычно равнозначно <code class="literal">USING &lt;</code> и <code class="literal">DESC</code> обычно равнозначно <code class="literal">USING &gt;</code>. (Хотя создатель нестандартного типа данных может определить по-другому порядок сортировки по умолчанию и поставить ему в соответствие операторы с другими именами.)</p><p>Если указано <code class="literal">NULLS LAST</code>, значения NULL при сортировке оказываются после значений не NULL; с указанием <code class="literal">NULLS FIRST</code> значения NULL оказываются перед значениями не NULL. Если не указано ни то, ни другое, по умолчанию подразумевается <code class="literal">NULLS LAST</code> при явно или неявно выбранном порядке <code class="literal">ASC</code>, либо <code class="literal">NULLS FIRST</code> при порядке <code class="literal">DESC</code> (то есть по умолчанию считается, что значения NULL больше значений не NULL). С предложением <code class="literal">USING</code> порядок NULL по умолчанию зависит от того, является ли указанный оператор оператором «меньше» или «больше».</p><p>Заметьте, что параметры сортировки применяются только к тому выражению, за которым они следуют; в частности, <code class="literal">ORDER BY x, y DESC</code> означает не то же самое, что <code class="literal">ORDER BY x DESC, y DESC</code>.</p><p>Данные символьных строк сортируются согласно правилу сортировки, установленному для сортируемого столбца. При необходимости это правило можно переопределить, добавив предложение <code class="literal">COLLATE</code> в <em class="replaceable"><code>выражение</code></em>, например так: <code class="literal">ORDER BY mycolumn COLLATE "en_US"</code>. За дополнительными сведениями обратитесь к <a class="xref" href="sql-expressions.html#SQL-SYNTAX-COLLATE-EXPRS" title="4.2.10. Применение правил сортировки">Подразделу 4.2.10</a> и <a class="xref" href="collation.html" title="24.2. Поддержка правил сортировки">Разделу 24.2</a>.</p></div><div class="refsect2" id="SQL-LIMIT"><h3>Предложение <code class="literal">LIMIT</code></h3><p>Предложение <code class="literal">LIMIT</code> состоит из двух независимых вложенных предложений: </p><pre class="synopsis">
LIMIT { <em class="replaceable"><code>число</code></em> | ALL }
OFFSET <em class="replaceable"><code>начало</code></em>
</pre><p> Параметр <em class="replaceable"><code>число</code></em> определяет максимальное количество строк, которое должно быть выдано, тогда как <em class="replaceable"><code>начало</code></em> определяет, сколько строк нужно пропустить, прежде чем начать выдавать строки. Когда указаны оба значения, сначала строки пропускаются в количестве, заданном значением <em class="replaceable"><code>начало</code></em>, а затем следующие строки выдаются в количестве, не превышающем значения <em class="replaceable"><code>число</code></em>.</p><p>Если результатом выражения <em class="replaceable"><code>число</code></em> оказывается NULL, предложение воспринимается как <code class="literal">LIMIT ALL</code>, т. е. число строк не ограничивается. Если <em class="replaceable"><code>начало</code></em> принимает значение NULL, предложение воспринимается как <code class="literal">OFFSET 0</code>.</p><p>SQL:2008 вводит другой синтаксис для получения того же результата, и его так же поддерживает <span class="productname">PostgreSQL</span>. Он выглядит так: </p><pre class="synopsis">
OFFSET <em class="replaceable"><code>начало</code></em> { ROW | ROWS }
FETCH { FIRST | NEXT } [ <em class="replaceable"><code>число</code></em> ] { ROW | ROWS } { ONLY | WITH TIES }
</pre><p> В этом синтаксисе значение <em class="replaceable"><code>начало</code></em> или <em class="replaceable"><code>число</code></em> в соответствии со стандартом должно быть буквальной константой, параметром или именем переменной; <span class="productname">PostgreSQL</span> позволяет использовать и другие выражения, но их обычно нужно заключать в скобки во избежание неоднозначности. Если <em class="replaceable"><code>число</code></em> опускается в предложении <code class="literal">FETCH</code>, оно принимает значение 1. С указанием <code class="literal">WITH TIES</code> будут возвращены дополнительные строки, с точки зрения <code class="literal">ORDER BY</code> совпадающие с последней строкой набора результатов; в этом случае предложение <code class="literal">ORDER BY</code> обязательно, а <code class="literal">SKIP LOCKED</code> — недопустимо. Слова <code class="literal">ROW</code> и <code class="literal">ROWS</code>, а также <code class="literal">FIRST</code> и <code class="literal">NEXT</code> являются незначащими и не влияют на поведение этих предложений. Согласно стандарту предложение <code class="literal">OFFSET</code> должно идти перед <code class="literal">FETCH</code>, если они присутствуют вместе; но <span class="productname">PostgreSQL</span> менее строг и допускает любой порядок.</p><p>Применяя <code class="literal">LIMIT</code>, имеет смысл использовать также предложение <code class="literal">ORDER BY</code>, чтобы строки результата выдавались в определённом порядке. Иначе будут возвращаться непредсказуемые подмножества строк запроса — вы можете запросить строки с десятой по двадцатую, но какой порядок вы имеете в виду? Порядок будет неизвестен, если не добавить <code class="literal">ORDER BY</code>.</p><p>Планировщик запроса учитывает ограничение <code class="literal">LIMIT</code>, строя план выполнения запроса, поэтому, вероятнее всего, планы (а значит и порядок строк) будут меняться при разных <code class="literal">LIMIT</code> и <code class="literal">OFFSET</code>. Таким образом, различные значения <code class="literal">LIMIT</code>/<code class="literal">OFFSET</code>, выбирающие разные подмножества результатов запроса, <span class="emphasis"><em>приведут к несогласованности результатов</em></span>, если не установить предсказуемую сортировку с помощью <code class="literal">ORDER BY</code>. Это не ошибка, а неизбежное следствие того, что SQL не гарантирует вывод результатов запроса в некотором порядке, если порядок не определён явно предложением <code class="literal">ORDER BY</code>.</p><p>Возможно даже, что при повторном выполнении одного и того же запроса с <code class="literal">LIMIT</code> будут получены разные подмножества строк таблицы, если предложение <code class="literal">ORDER BY</code> не диктует выбор определённого подмножества. Опять же, это не ошибка; в данном случае детерминированность результата просто не гарантируется.</p></div><div class="refsect2" id="SQL-FOR-UPDATE-SHARE"><h3>Предложение блокировки</h3><p><em class="firstterm">Предложения блокировки</em> включают в себя <code class="literal">FOR UPDATE</code>, <code class="literal">FOR NO KEY UPDATE</code>, <code class="literal">FOR SHARE</code> и <code class="literal">FOR KEY SHARE</code>; они влияют на то, как <code class="literal">SELECT</code> блокирует строки, получаемые из таблицы.</p><p>Предложение блокировки имеет следующую общую форму: </p><pre class="synopsis">
FOR <em class="replaceable"><code>вариант_блокировки</code></em> [ OF <em class="replaceable"><code>имя_таблицы</code></em> [, ...] ] [ NOWAIT | SKIP LOCKED ]
</pre><p> Здесь <em class="replaceable"><code>вариант_блокировки</code></em> может быть следующим: </p><pre class="synopsis">
UPDATE
NO KEY UPDATE
SHARE
KEY SHARE
</pre><p>Подробнее о каждом режиме блокировки на уровне строк можно узнать в <a class="xref" href="explicit-locking.html#LOCKING-ROWS" title="13.3.2. Блокировки на уровне строк">Подразделе 13.3.2</a>.</p><p>Чтобы операция не ждала завершения других транзакций, к блокировке можно добавить указание <code class="literal">NOWAIT</code> или <code class="literal">SKIP LOCKED</code>. С <code class="literal">NOWAIT</code> оператор выдаёт ошибку, а не ждёт, если выбранную строку нельзя заблокировать немедленно. С указанием <code class="literal">SKIP LOCKED</code> выбранные строки, которые нельзя заблокировать немедленно, пропускаются. При этом формируется несогласованное представление данных, так что этот вариант не подходит для общего применения, но может использоваться для исключения блокировок при обращении множества потребителей к таблице типа очереди. Заметьте, что указания <code class="literal">NOWAIT</code> и <code class="literal">SKIP LOCKED</code> применяются только к блокировкам на уровне строк — необходимая блокировка <code class="literal">ROW SHARE</code> уровня таблицы запрашивается обычным способом (см. <a class="xref" href="mvcc.html" title="Глава 13. Управление конкурентным доступом">Главу 13</a>). Если требуется запросить блокировку уровня таблицы без ожидания, можно сначала выполнить <a class="link" href="sql-lock.html" title="LOCK"><code class="command">LOCK</code></a> с указанием <code class="literal">NOWAIT</code>.</p><p>Если в предложении блокировки указаны определённые таблицы, блокироваться будут только строки, получаемые из этих таблиц; другие таблицы, задействованные в <code class="command">SELECT</code>, будут прочитаны как обычно. Предложение блокировки без списка таблиц затрагивает все таблицы, задействованные в этом операторе. Если предложение блокировки применяется к представлению или подзапросу, оно затрагивает все таблицы, которые используются в представлении или подзапросе. Однако эти предложения не применяются к запросам <code class="literal">WITH</code>, к которым обращается основной запрос. Если требуется установить блокировку строк в запросе <code class="literal">WITH</code>, предложение блокировки нужно указать непосредственно в этом запросе <code class="literal">WITH</code>.</p><p>В случае необходимости задать для разных таблиц разное поведение блокировки, в запрос можно добавить несколько предложений. Если при этом одна и та же таблица упоминается (или неявно затрагивается) в нескольких предложениях блокировки, блокировка устанавливается так, как если бы было указано только одно, самое сильное из них. Подобным образом, если в одном из предложений указано <code class="literal">NOWAIT</code>, для этой таблицы блокировка будет запрашиваться без ожидания. В противном случае она будет обработана в режиме <code class="literal">SKIP LOCKED</code>, если он выбран в любом из затрагивающих её предложений.</p><p>Предложения блокировки не могут применяться в контекстах, где возвращаемые строки нельзя чётко связать с отдельными строками таблицы; например, блокировка неприменима при агрегировании.</p><p>Когда предложение блокировки находится на верхнем уровне запроса <code class="command">SELECT</code>, блокируются именно те строки, которые возвращаются запросом; в случае с запросом объединения, блокировке подлежат строки, из которых составляются возвращаемые строки объединения. В дополнение к этому, заблокированы будут строки, удовлетворяющие условиям запроса на момент создания снимка запроса, хотя они не будут возвращены, если с момента снимка они изменятся и перестанут удовлетворять условиям. Если применяется <code class="literal">LIMIT</code>, блокировка прекращается, как только будет получено достаточное количество строк для удовлетворения лимита (но заметьте, что строки, пропускаемые указанием <code class="literal">OFFSET</code>, будут блокироваться). Подобным образом, если предложение блокировки применяется в запросе курсора, блокироваться будут только строки, фактически полученные или пройденные курсором.</p><p>Когда предложение блокировки находится в подзапросе <code class="command">SELECT</code>, блокировке подлежат те строки, которые будет получены внешним запросом от подзапроса. Таких строк может оказаться меньше, чем можно было бы предположить, проанализировав только сам подзапрос, так как условия из внешнего запроса могут способствовать оптимизации выполнения подзапроса. Например, запрос </p><pre class="programlisting">SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss WHERE col1 = 5;</pre><p> заблокирует только строки, в которых <code class="literal">col1 = 5</code>, при том, что в такой записи условие не относится к подзапросу.</p><p>Предыдущие версии не могли сохранить блокировку, которая была повышена последующей точкой сохранения. Например, этот код: </p><pre class="programlisting">BEGIN;
SELECT * FROM mytable WHERE key = 1 FOR UPDATE;
SAVEPOINT s;
UPDATE mytable SET ... WHERE key = 1;
ROLLBACK TO s;</pre><p> не мог сохранить блокировку <code class="literal">FOR UPDATE</code> после <code class="command">ROLLBACK TO</code>. Это было исправлено в версии 9.3.</p><div class="caution"><h3 class="title">Внимание</h3><p>Возможно, что команда <code class="command">SELECT</code>, работающая на уровне изоляции <code class="literal">READ COMMITTED</code> и применяющая предложение <code class="literal">ORDER BY</code> вместе с блокировкой, будет возвращать строки не по порядку. Это связано с тем, что <code class="literal">ORDER BY</code> выполняется в первую очередь. Эта команда отсортирует результат, но затем может быть заблокирована, пытаясь получить блокировку одной или нескольких строк. К моменту, когда блокировка <code class="literal">SELECT</code> будет снята, некоторые из сортируемых столбцов могут уже измениться, в результате чего их порядок может быть нарушен (хотя они были упорядочены для исходных значений). При необходимости обойти эту проблему, можно поместить <code class="literal">FOR UPDATE/SHARE</code> в подзапрос, например так: </p><pre class="programlisting">SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss ORDER BY column1;</pre><p> Заметьте, что в результате это приведёт к блокированию всех строк в <code class="structname">mytable</code>, тогда как указание <code class="literal">FOR UPDATE</code> на верхнем уровне могло бы заблокировать только фактически возвращаемые строки. Это может значительно повлиять на производительность, особенно в сочетании <code class="literal">ORDER BY</code> с <code class="literal">LIMIT</code> или другими ограничениями. Таким образом, этот приём рекомендуется, только если ожидается параллельное изменение сортируемых столбцов, а результат должен быть строго отсортирован.</p><p>На уровнях изоляции <code class="literal">REPEATABLE READ</code> и <code class="literal">SERIALIZABLE</code> это приведёт к ошибке сериализации (с <code class="literal">SQLSTATE</code> <code class="literal">'40001'</code>), так что на этих уровнях получить строки не по порядку невозможно.</p></div></div><div class="refsect2" id="SQL-TABLE"><h3>Команда <code class="literal">TABLE</code></h3><p>Команда </p><pre class="programlisting">TABLE <em class="replaceable"><code>имя</code></em></pre><p> равнозначна </p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>имя</code></em></pre><p> Её можно применять в качестве команды верхнего уровня или как более краткую запись внутри сложных запросов. С командой <code class="command">TABLE</code> могут использоваться только предложения <code class="literal">WITH</code>, <code class="literal">UNION</code>, <code class="literal">INTERSECT</code>, <code class="literal">EXCEPT</code>, <code class="literal">ORDER BY</code>, <code class="literal">LIMIT</code>, <code class="literal">OFFSET</code>, <code class="literal">FETCH</code> и предложения блокировки <code class="literal">FOR</code>; предложение <code class="literal">WHERE</code> и какие-либо формы агрегирования не поддерживаются.</p></div></div><div class="refsect1" id="id-1.9.3.172.9"><h2>Примеры</h2><p>Соединение таблицы <code class="literal">films</code> с таблицей <code class="literal">distributors</code>: </p><pre class="programlisting">SELECT f.title, f.did, d.name, f.date_prod, f.kind
    FROM distributors d JOIN films f USING (did);

       title       | did |     name     | date_prod  |   kind
-------------------+-----+--------------+------------+----------
 The Third Man     | 101 | British Lion | 1949-12-23 | Drama
 The African Queen | 101 | British Lion | 1951-08-11 | Romantic
 ...</pre><p>Суммирование значений столбца <code class="literal">len</code> (продолжительность) для всех фильмов и группирование результатов по столбцу <code class="literal">kind</code> (типу фильма): </p><pre class="programlisting">SELECT kind, sum(len) AS total FROM films GROUP BY kind;

   kind   | total
----------+-------
 Action   | 07:34
 Comedy   | 02:58
 Drama    | 14:28
 Musical  | 06:42
 Romantic | 04:38</pre><p>Суммирование значений столбца <code class="literal">len</code> для всех фильмов, группирование результатов по столбцу <code class="literal">kind</code> и вывод только тех групп, общая продолжительность которых меньше 5 часов: </p><pre class="programlisting">SELECT kind, sum(len) AS total
    FROM films
    GROUP BY kind
    HAVING sum(len) &lt; interval '5 hours';

   kind   | total
----------+-------
 Comedy   | 02:58
 Romantic | 04:38</pre><p>Следующие два запроса демонстрируют равнозначные способы сортировки результатов по содержимому второго столбца (<code class="literal">name</code>): </p><pre class="programlisting">SELECT * FROM distributors ORDER BY name;
SELECT * FROM distributors ORDER BY 2;

 did |       name
-----+------------------
 109 | 20th Century Fox
 110 | Bavaria Atelier
 101 | British Lion
 107 | Columbia
 102 | Jean Luc Godard
 113 | Luso films
 104 | Mosfilm
 103 | Paramount
 106 | Toho
 105 | United Artists
 111 | Walt Disney
 112 | Warner Bros.
 108 | Westward</pre><p>Следующий пример показывает объединение таблиц <code class="literal">distributors</code> и <code class="literal">actors</code>, ограниченное именами, начинающимися с буквы W в каждой таблице. Интерес представляют только неповторяющиеся строки, поэтому ключевое слово <code class="literal">ALL</code> опущено. </p><pre class="programlisting">distributors:               actors:
 did |     name              id |     name
-----+--------------        ----+----------------
 108 | Westward               1 | Woody Allen
 111 | Walt Disney            2 | Warren Beatty
 112 | Warner Bros.           3 | Walter Matthau
 ...                         ...

SELECT distributors.name
    FROM distributors
    WHERE distributors.name LIKE 'W%'
UNION
SELECT actors.name
    FROM actors
    WHERE actors.name LIKE 'W%';

      name
----------------
 Walt Disney
 Walter Matthau
 Warner Bros.
 Warren Beatty
 Westward
 Woody Allen</pre><p>Этот пример показывает, как использовать функцию в предложении <code class="literal">FROM</code>, со списком определений столбцов и без него: </p><pre class="programlisting">CREATE FUNCTION distributors(int) RETURNS SETOF distributors AS $$
    SELECT * FROM distributors WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributors(111);
 did |    name
-----+-------------
 111 | Walt Disney

CREATE FUNCTION distributors_2(int) RETURNS SETOF record AS $$
    SELECT * FROM distributors WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributors_2(111) AS (f1 int, f2 text);
 f1  |     f2
-----+-------------
 111 | Walt Disney</pre><p>Пример функции с добавленным столбцом нумерации: </p><pre class="programlisting">SELECT * FROM unnest(ARRAY['a','b','c','d','e','f']) WITH ORDINALITY;
 unnest | ordinality
--------+----------
 a      |        1
 b      |        2
 c      |        3
 d      |        4
 e      |        5
 f      |        6
(6 rows)</pre><p>Этот пример показывает, как использовать простое предложение <code class="literal">WITH</code>: </p><pre class="programlisting">WITH t AS (
    SELECT random() as x FROM generate_series(1, 3)
  )
SELECT * FROM t
UNION ALL
SELECT * FROM t;
         x
--------------------
  0.534150459803641
  0.520092216785997
 0.0735620250925422
  0.534150459803641
  0.520092216785997
 0.0735620250925422</pre><p> Заметьте, что запрос <code class="literal">WITH</code> выполняется всего один раз, поэтому мы получаем два одинаковых набора по три случайных значения.</p><p>В этом примере <code class="literal">WITH RECURSIVE</code> применяется для поиска всех подчинённых Мери (непосредственных или косвенных) и вывода их уровня косвенности в таблице с информацией только о непосредственных подчинённых: </p><pre class="programlisting">WITH RECURSIVE employee_recursive(distance, employee_name, manager_name) AS (
    SELECT 1, employee_name, manager_name
    FROM employee
    WHERE manager_name = 'Mary'
  UNION ALL
    SELECT er.distance + 1, e.employee_name, e.manager_name
    FROM employee_recursive er, employee e
    WHERE er.employee_name = e.manager_name
  )
SELECT distance, employee_name FROM employee_recursive;</pre><p> Заметьте, что это типичная форма рекурсивных запросов: начальное условие, последующий <code class="literal">UNION</code>, а затем рекурсивная часть запроса. Убедитесь в том, что рекурсивная часть запроса в конце концов перестанет возвращать строки, иначе запрос окажется в бесконечном цикле. (За другими примерами обратитесь к <a class="xref" href="queries-with.html" title="7.8. Запросы WITH (Общие табличные выражения)">Разделу 7.8</a>.)</p><p>В этом примере используется <code class="literal">LATERAL</code> для применения функции <code class="function">get_product_names()</code>, возвращающей множество, для каждой строки таблицы <code class="structname">manufacturers</code>: </p><pre class="programlisting">SELECT m.name AS mname, pname
FROM manufacturers m, LATERAL get_product_names(m.id) pname;</pre><p> Производители, с которыми в данный момент не связаны никакие продукты, не попадут в результат, так как это внутреннее соединение. Если бы мы захотели включить названия и этих производителей, мы могли бы сделать так: </p><pre class="programlisting">SELECT m.name AS mname, pname
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true;</pre></div><div class="refsect1" id="id-1.9.3.172.10"><h2>Совместимость</h2><p>Разумеется, оператор <code class="command">SELECT</code> совместим со стандартом SQL. Однако не все описанные в стандарте возможности реализованы, а некоторые, наоборот, являются расширениями.</p><div class="refsect2" id="id-1.9.3.172.10.3"><h3>Необязательное предложение <code class="literal">FROM</code></h3><p><span class="productname">PostgreSQL</span> разрешает опустить предложение <code class="literal">FROM</code>. Это позволяет очень легко вычислять результаты простых выражений: </p><pre class="programlisting">SELECT 2+2;

 ?column?
----------
        4</pre><p> Некоторые другие базы данных <acronym class="acronym">SQL</acronym> не допускают этого, требуя задействовать в <code class="command">SELECT</code> фиктивную таблицу с одной строкой.</p></div><div class="refsect2" id="id-1.9.3.172.10.4"><h3>Пустые списки <code class="literal">SELECT</code></h3><p>Список выходных выражений после <code class="literal">SELECT</code> может быть пустым, что в результате даст таблицу без столбцов. Стандарт SQL не считает такой синтаксис допустимым, но <span class="productname">PostgreSQL</span> допускает его, так как это согласуется с возможностью иметь таблицы с нулём столбцов. Однако когда используется <code class="literal">DISTINCT</code>, пустой список не допускается.</p></div><div class="refsect2" id="id-1.9.3.172.10.5"><h3>Необязательное ключевое слово <code class="literal">AS</code></h3><p>В стандарте SQL необязательное ключевое слово <code class="literal">AS</code> можно опустить перед именем выходного столбца, если это имя является допустимым именем столбца (то есть не совпадает с каким-либо зарезервированным ключевым словом). <span class="productname">PostgreSQL</span> несколько более строг: <code class="literal">AS</code> требуется, если имя столбца совпадает с любым ключевым словом, зарезервированным или нет. Тем не менее рекомендуется использовать <code class="literal">AS</code> или заключать имена выходных столбцов в кавычки, во избежание конфликтов, возможных при появлении в будущем новых ключевых слов.</p><p>В списке <code class="literal">FROM</code> и стандарт, и <span class="productname">PostgreSQL</span> позволяют опускать <code class="literal">AS</code> перед псевдонимом, который является незарезервированным ключевым словом. Но для имён выходных столбцов это не подходит из-за синтаксической неоднозначности.</p></div><div class="refsect2" id="id-1.9.3.172.10.6"><h3>Неиспользование псевдонимов вложенных <code class="command">SELECT</code> в предложении <code class="literal">FROM</code></h3><p>Согласно стандарту SQL для любого вложенного запроса <code class="command">SELECT</code> в списке <code class="literal">FROM</code> должен быть псевдоним. В <span class="productname">PostgreSQL</span> псевдонимы можно не использовать.</p></div><div class="refsect2" id="id-1.9.3.172.10.7"><h3><code class="literal">ONLY</code> и наследование</h3><p>Стандарт SQL требует заключать в скобки имя таблицы после <code class="literal">ONLY</code>, например <code class="literal">SELECT * FROM ONLY (tab1), ONLY (tab2) WHERE ...</code>. <span class="productname">PostgreSQL</span> считает эти скобки необязательными.</p><p><span class="productname">PostgreSQL</span> позволяет добавлять в конце <code class="literal">*</code>, чтобы явно обозначить, что дочерние таблицы включаются в рассмотрение, в отличие от поведения с <code class="literal">ONLY</code>. Стандарт не позволяет этого.</p><p>(Эти соображения в равной степени касаются всех SQL-команд, поддерживающих параметр <code class="literal">ONLY</code>.)</p></div><div class="refsect2" id="id-1.9.3.172.10.8"><h3>Ограничения предложения <code class="literal">TABLESAMPLE</code></h3><p>Предложение <code class="literal">TABLESAMPLE</code> в настоящий момент принимается только для обычных таблиц и материализованных представлений. Однако согласно стандарту SQL оно должно применяться к любым элементам списка <code class="literal">FROM</code>.</p></div><div class="refsect2" id="id-1.9.3.172.10.9"><h3>Вызовы функций в предложении <code class="literal">FROM</code></h3><p><span class="productname">PostgreSQL</span> позволяет записать вызов функции непосредственно в виде элемента списка <code class="literal">FROM</code>. В стандарте SQL такой вызов функции требуется помещать во вложенный <code class="command">SELECT</code>; то есть, запись <code class="literal">FROM <em class="replaceable"><code>функция</code></em>(...) <em class="replaceable"><code>псевдоним</code></em></code> примерно равнозначна записи <code class="literal">FROM LATERAL (SELECT <em class="replaceable"><code>функция</code></em>(...)) <em class="replaceable"><code>псевдоним</code></em></code>. Заметьте, что указание <code class="literal">LATERAL</code> считается неявным; это связано с тем, что стандарт требует поведения <code class="literal">LATERAL</code> для элемента <code class="literal">UNNEST()</code> в предложении <code class="literal">FROM</code>. <span class="productname">PostgreSQL</span> обрабатывает <code class="literal">UNNEST()</code> так же, как и другие функции, возвращающие множества.</p></div><div class="refsect2" id="id-1.9.3.172.10.10"><h3>Пространства имён в <code class="literal">GROUP BY</code> и <code class="literal">ORDER BY</code></h3><p>В стандарте SQL-92 предложение <code class="literal">ORDER BY</code> может содержать ссылки только на выходные столбцы по именам или номерам, тогда как <code class="literal">GROUP BY</code> может содержать выражения с именами только входных столбцов. <span class="productname">PostgreSQL</span> расширяет оба эти предложения, позволяя также применять другие варианты (но если возникает неоднозначность, он разрешает её согласно стандарту). <span class="productname">PostgreSQL</span> также позволяет задавать произвольные выражения в обоих предложениях. Заметьте, что имена, фигурирующие в выражениях, всегда будут восприниматься как имена входных, а не выходных столбцов.</p><p>В SQL:1999 и более поздних стандартах введено несколько другое определение, которое не полностью совместимо с SQL-92. Однако в большинстве случаев <span class="productname">PostgreSQL</span> будет интерпретировать выражение <code class="literal">ORDER BY</code> или <code class="literal">GROUP BY</code> так, как требует SQL:1999.</p></div><div class="refsect2" id="id-1.9.3.172.10.11"><h3>Функциональные зависимости</h3><p><span class="productname">PostgreSQL</span> распознаёт функциональную зависимость (что позволяет опускать столбцы в <code class="literal">GROUP BY</code>), только когда первичный ключ таблицы присутствует в списке <code class="literal">GROUP BY</code>. В стандарте SQL оговариваются дополнительные условия, которые следует учитывать.</p></div><div class="refsect2" id="id-1.9.3.172.10.12"><h3><code class="literal">LIMIT</code> и <code class="literal">OFFSET</code></h3><p>Предложения <code class="literal">LIMIT</code> и <code class="literal">OFFSET</code> относятся к специфическим особенностям <span class="productname">PostgreSQL</span> и поддерживаются также в <span class="productname">MySQL</span>. В стандарте SQL:2008 для той же цели вводятся предложения <code class="literal">OFFSET ... FETCH {FIRST|NEXT} ...</code>, рассмотренные ранее в <a class="xref" href="sql-select.html#SQL-LIMIT" title="Предложение LIMIT">Предложение LIMIT</a>. Этот синтаксис также используется в <span class="productname">IBM DB2</span>. (Приложения, написанные для <span class="productname">Oracle</span>, часто применяют обходной способ и получают эффект этих предложений, задействуя автоматически генерируемый столбец <code class="literal">rownum</code>, который отсутствует в PostgreSQL.)</p></div><div class="refsect2" id="id-1.9.3.172.10.13"><h3><code class="literal">FOR NO KEY UPDATE</code>, <code class="literal">FOR UPDATE</code>, <code class="literal">FOR SHARE</code>, <code class="literal">FOR KEY SHARE</code></h3><p>Хотя указание <code class="literal">FOR UPDATE</code> есть в стандарте SQL, стандарт позволяет использовать его только в предложении <code class="command">DECLARE CURSOR</code>. <span class="productname">PostgreSQL</span> допускает его использование в любом запросе <code class="command">SELECT</code>, а также в подзапросах <code class="command">SELECT</code>, но это является расширением. Варианты <code class="literal">FOR NO KEY UPDATE</code>, <code class="literal">FOR SHARE</code> и <code class="literal">FOR KEY SHARE</code>, а также указания <code class="literal">NOWAIT</code> и <code class="literal">SKIP LOCKED</code> в стандарте отсутствуют.</p></div><div class="refsect2" id="id-1.9.3.172.10.14"><h3>Изменение данных в <code class="literal">WITH</code></h3><p><span class="productname">PostgreSQL</span> разрешает использовать <code class="command">INSERT</code>, <code class="command">UPDATE</code> и <code class="command">DELETE</code> в качестве запросов <code class="literal">WITH</code>. Стандарт SQL этого не предусматривает.</p></div><div class="refsect2" id="id-1.9.3.172.10.15"><h3>Нестандартные предложения</h3><p><code class="literal">DISTINCT ON ( ... )</code> — расширение стандарта SQL.</p><p><code class="literal">ROWS FROM( ... )</code> — расширение стандарта SQL.</p><p>Указания <code class="literal">MATERIALIZED</code> и <code class="literal">NOT MATERIALIZED</code> предложения <code class="literal">WITH</code> относятся к расширениям стандарта SQL.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-security-label.html" title="SECURITY LABEL">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-selectinto.html" title="SELECT INTO">След.</a></td></tr><tr><td width="40%" align="left" valign="top">SECURITY LABEL </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> SELECT INTO</td></tr></table></div></body></html>