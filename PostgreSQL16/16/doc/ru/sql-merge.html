<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>MERGE</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sql-lock.html" title="LOCK" /><link rel="next" href="sql-move.html" title="MOVE" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">MERGE</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-lock.html" title="LOCK">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><th width="60%" align="center">Команды SQL</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-move.html" title="MOVE">След.</a></td></tr></table><hr /></div><div class="refentry" id="SQL-MERGE"><div class="titlepage"></div><a id="id-1.9.3.156.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">MERGE</span></h2><p>MERGE — добавить, изменить или удалить строки таблицы по условию</p></div><div class="refsynopsisdiv"><h2>Синтаксис</h2><pre class="synopsis">[ WITH <em class="replaceable"><code>запрос_WITH</code></em> [, ...] ]
MERGE INTO [ ONLY ] <em class="replaceable"><code>имя_целевой_таблицы</code></em> [ * ] [ [ AS ] <em class="replaceable"><code>целевой_псевдоним</code></em> ]
USING <em class="replaceable"><code>источник_данных</code></em> ON <em class="replaceable"><code>условие_соединения</code></em>
<em class="replaceable"><code>предложение_when</code></em> [...]

<span class="phrase">здесь <em class="replaceable"><code>источник_данных</code></em>:</span>

{ [ ONLY ] <em class="replaceable"><code>имя_исходной_таблицы</code></em> [ * ] | ( <em class="replaceable"><code>исходный_запрос</code></em> ) } [ [ AS ] <em class="replaceable"><code>исходный_псевдоним</code></em> ]

<span class="phrase">и <em class="replaceable"><code>предложение_when</code></em>:</span>

{ WHEN MATCHED [ AND <em class="replaceable"><code>условие</code></em> ] THEN { <em class="replaceable"><code>изменение_при_объединении</code></em> | <em class="replaceable"><code>удаление_при_объединении</code></em> | DO NOTHING } |
  WHEN NOT MATCHED [ AND <em class="replaceable"><code>условие</code></em> ] THEN { <em class="replaceable"><code>добавление_при_объединении</code></em> | DO NOTHING } }

<span class="phrase">и <em class="replaceable"><code>добавление_при_объединении</code></em>:</span>

INSERT [( <em class="replaceable"><code>имя_столбца</code></em> [, ...] )]
[ OVERRIDING { SYSTEM | USER } VALUE ]
{ VALUES ( { <em class="replaceable"><code>выражение</code></em> | DEFAULT } [, ...] ) | DEFAULT VALUES }

<span class="phrase">и <em class="replaceable"><code>изменение_при_объединении</code></em>:</span>

UPDATE SET { <em class="replaceable"><code>имя_столбца</code></em> = { <em class="replaceable"><code>выражение</code></em> | DEFAULT } |
             ( <em class="replaceable"><code>имя_столбца</code></em> [, ...] ) = [ ROW ] ( { <em class="replaceable"><code>выражение</code></em> | DEFAULT } [, ...] ) |
             ( <em class="replaceable"><code>имя_столбца</code></em> [, ...] ) = ( <em class="replaceable"><code>вложенный_SELECT</code></em> )
           } [, ...]

<span class="phrase">и <em class="replaceable"><code>удаление_при_объединении</code></em>:</span>

DELETE</pre></div><div class="refsect1" id="id-1.9.3.156.5"><h2>Описание</h2><p>Операция <code class="command">MERGE</code> выполняет действия, которые меняют строки в целевой таблице с <em class="replaceable"><code>именем_целевой_таблицы</code></em>, используя <em class="replaceable"><code>источник_данных</code></em>. <code class="command">MERGE</code> — это один <acronym class="acronym">SQL</acronym>-оператор, который по условию выполняет со строками действия <code class="command">INSERT</code>, <code class="command">UPDATE</code> или <code class="command">DELETE</code>; сделать то же самое без <code class="command">MERGE</code> можно, только используя несколько операторов процедурного языка.</p><p>Сначала команда <code class="command">MERGE</code> выполняет соединение <em class="replaceable"><code>источника_данных</code></em> с целевой таблицей, формируя ноль или более строк-кандидатов на изменение. Для каждой строки-кандидата устанавливается неизменяемый позже статус <code class="literal">MATCHED</code> (совпадает) или <code class="literal">NOT MATCHED</code> (не совпадает), после чего вычисляются условия <code class="literal">WHEN</code> в заданном порядке. Для каждой отдельной строки будет выполняться действие первого же предложения, условие которого выдаст true. При этом для каждой строки-кандидата может быть выполнено действие не более чем одного предложения <code class="literal">WHEN</code>.</p><p>Действия операции <code class="command">MERGE</code> имеют тот же эффект, что и обычные одноимённые команды <code class="command">UPDATE</code>, <code class="command">INSERT</code> или <code class="command">DELETE</code>. Синтаксис этих команд в <code class="command">MERGE</code> отличается, в частности, отсутствием предложения <code class="literal">WHERE</code> и имени таблицы. Действия этих команд выполняются с целевой таблицей, хотя посредством триггеров могут быть изменены и другие таблицы.</p><p>С указанием <code class="literal">DO NOTHING</code> исходная строка пропускается. Поскольку применимость действий оценивается в заданном порядке, используя <code class="literal">DO NOTHING</code>, удобно пропускать исходные строки, не представляющие интерес, чтобы затем более детально обрабатывать остальные.</p><p>Для команды <code class="literal">MERGE</code> не предусмотрено отдельное право. Если пользователь указывает в ней действие <code class="literal">UPDATE</code>, у него должно быть право <code class="literal">UPDATE</code> для столбцов целевой таблицы, на которые ссылается предложение <code class="literal">SET</code>. Когда указывается действие <code class="literal">INSERT</code> или <code class="literal">DELETE</code>, у пользователя должно быть соответствующее право для целевой таблицы. Если пользователь указывает действие <code class="literal">DO NOTHING</code>, у него должно быть право <code class="literal">SELECT</code> хотя бы для одного столбца целевой таблицы. Кроме того, необходимо иметь право <code class="literal">SELECT</code> для любых столбцов <em class="replaceable"><code>источника_данных</code></em> и целевой таблицы, которые фигурируют в <code class="literal">condition</code> (в том числе <code class="literal">join_condition</code>) или <code class="literal">expression</code>. Права проверяются один раз в начале выполнения оператора, вне зависимости от того, будут ли выполняться конкретные предложения <code class="literal">WHEN</code>.</p><p>Оператор <code class="command">MERGE</code> не поддерживается для целевых таблиц, являющихся материализованными представлениями, сторонними таблицами, или если для них заданы какие-либо правила.</p></div><div class="refsect1" id="id-1.9.3.156.6"><h2>Параметры</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>запрос_WITH</code></em></span></dt><dd><p>Предложение <code class="literal">WITH</code> позволяет задать один или несколько подзапросов, на которые затем можно ссылаться по имени в запросе <code class="command">MERGE</code>. За подробностями обратитесь к <a class="xref" href="queries-with.html" title="7.8. Запросы WITH (Общие табличные выражения)">Разделу 7.8</a> и <a class="xref" href="sql-select.html" title="SELECT"><span class="refentrytitle">SELECT</span></a>. Обратите внимание, что предложение <code class="literal">WITH RECURSIVE</code> для команды <code class="command">MERGE</code> не поддерживается.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_целевой_таблицы</code></em></span></dt><dd><p>Имя (возможно, дополненное схемой) целевой таблицы, принимающей результат объединения. Если перед именем таблицы добавлено <code class="literal">ONLY</code>, соответствующие строки изменяются или удаляются только в указанной таблице. Без <code class="literal">ONLY</code> соответствующие строки также изменяются или удаляются во всех таблицах, унаследованных от указанной таблицы. При желании, после имени таблицы можно указать <code class="literal">*</code>, чтобы явно обозначить, что операция затрагивает все дочерние таблицы. Ключевое слово <code class="literal">ONLY</code> и параметр <code class="literal">*</code> не влияют на действия <code class="literal">INSERT</code>, добавляющие строки только в указанную таблицу.</p></dd><dt><span class="term"><em class="replaceable"><code>целевой_псевдоним</code></em></span></dt><dd><p>Альтернативное имя целевой таблицы. Когда это имя задаётся, настоящее имя таблицы полностью скрывается. Например, в запросе <code class="literal">MERGE INTO foo AS f</code> остальные компоненты оператора <code class="command">MERGE</code> должны обращаться к целевой таблице по имени <code class="literal">f</code>, а не <code class="literal">foo</code>.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_исходной_таблицы</code></em></span></dt><dd><p>Имя (возможно, дополненное схемой) исходной таблицы, представления или переходной таблицы. Если перед именем таблицы добавлено <code class="literal">ONLY</code>, соответствующие строки берутся только из указанной таблицы. Без <code class="literal">ONLY</code> строки также берутся из всех таблиц, унаследованных от указанной. При желании, после имени таблицы можно указать <code class="literal">*</code>, чтобы явно обозначить, что операция затрагивает все дочерние таблицы.</p></dd><dt><span class="term"><em class="replaceable"><code>исходный_запрос</code></em></span></dt><dd><p>Запрос (оператор <code class="command">SELECT</code> или оператор <code class="command">VALUES</code>), предоставляющий строки для объединения в целевой таблице. За информацией о синтаксисе обратитесь к описанию <a class="xref" href="sql-select.html" title="SELECT"><span class="refentrytitle">SELECT</span></a> и <a class="xref" href="sql-values.html" title="VALUES"><span class="refentrytitle">VALUES</span></a>.</p></dd><dt><span class="term"><em class="replaceable"><code>исходный_псевдоним</code></em></span></dt><dd><p>Альтернативное имя для источника данных. Когда задаётся этот псевдоним, он полностью скрывает настоящее имя таблицы или тот факт, что это результат запроса.</p></dd><dt><span class="term"><em class="replaceable"><code>условие_соединения</code></em></span></dt><dd><p>Задаваемое <em class="replaceable"><code>условие_соединения</code></em> представляет собой выражение, выдающее значение типа <code class="type">boolean</code> (как в предложении <code class="literal">WHERE</code>), которое определяет, какие строки в <em class="replaceable"><code>источнике_данных</code></em> соответствуют строкам в целевой таблице.</p><div class="warning"><h3 class="title">Предупреждение</h3><p>В <em class="replaceable"><code>условии_соединения</code></em> должны фигурировать только столбцы целевой таблицы, по которым её строки сопоставляются со строками <em class="replaceable"><code>источника_данных</code></em>. Подвыражения <em class="replaceable"><code>условия_соединения</code></em>, ссылающиеся только на столбцы целевой таблицы, могут влиять на выполняемое действие, часто неожиданным образом.</p></div></dd><dt><span class="term"><em class="replaceable"><code>предложение_when</code></em></span></dt><dd><p>В команде <code class="command">MERGE</code> должно быть минимум одно предложение <code class="literal">WHEN</code>.</p><p>Если в предложении <code class="literal">WHEN</code> указано <code class="literal">WHEN MATCHED</code> и строка-кандидат на изменение соответствует строке целевой таблицы, предложение <code class="literal">WHEN</code> выполняется, когда <em class="replaceable"><code>условие</code></em> отсутствует или выдаёт <code class="literal">true</code>.</p><p>И наоборот, если в предложении <code class="literal">WHEN</code> указано <code class="literal">WHEN NOT MATCHED</code> и строка-кандидат на изменение не соответствует строке целевой таблицы, предложение <code class="literal">WHEN</code> выполняется, когда <em class="replaceable"><code>условие</code></em> отсутствует или выдаёт <code class="literal">true</code>.</p></dd><dt><span class="term"><em class="replaceable"><code>условие</code></em></span></dt><dd><p>Выражение, выдающее значение типа <code class="type">boolean</code>. Если это выражение для предложения <code class="literal">WHEN</code> выдаёт <code class="literal">true</code>, для данной строки выполняется действие этого предложения.</p><p>Условие в предложении <code class="literal">WHEN MATCHED</code> может ссылаться на столбцы как исходного, так и целевого отношения. Условие в предложении <code class="literal">WHEN NOT MATCHED</code> может ссылаться только на столбцы исходного отношения, поскольку соответствующей целевой строки нет по определению. В целевой таблице доступны только системные атрибуты.</p></dd><dt><span class="term"><em class="replaceable"><code>добавление_при_объединении</code></em></span></dt><dd><p>Указание действия <code class="literal">INSERT</code>, добавляющего одну строку в целевую таблицу. Имена целевых столбцов могут перечисляться в любом порядке. Если список имён столбцов не задан вовсе, по умолчанию используются все столбцы таблицы в порядке объявления.</p><p>Все столбцы, не представленные в явном или неявном списке столбцов, получат значения по умолчанию, если для них заданы эти значения, либо NULL в противном случае.</p><p>Если целевая таблица является секционированной, каждая строка направляется в соответствующую секцию и добавляется в неё. Если целевая таблица является секцией и какая-либо входная строка нарушит ограничение секции, произойдёт ошибка.</p><p>Имена столбцов нельзя указывать более одного раза. Действия <code class="command">INSERT</code> не могут содержать вложенные запросы <code class="command">SELECT</code>.</p><p>Предложение <code class="literal">VALUES</code> может указываться только один раз. Ссылаться в нём можно только на столбцы исходного отношения, так как соответствующих целевых строк нет по определению.</p></dd><dt><span class="term"><em class="replaceable"><code>изменение_при_объединении</code></em></span></dt><dd><p>Указание действия <code class="literal">UPDATE</code>, изменяющего текущую строку целевой таблицы. Имена столбцов нельзя указывать более одного раза.</p><p>Задавать имя таблицы и предложение <code class="literal">WHERE</code> здесь нельзя.</p></dd><dt><span class="term"><em class="replaceable"><code>удаление_при_объединении</code></em></span></dt><dd><p>Указание действия <code class="literal">DELETE</code>, удаляющего текущую строку целевой таблицы. Задавать имя таблицы или какие-либо другие предложения, как в обычной команде <a class="xref" href="sql-delete.html" title="DELETE"><span class="refentrytitle">DELETE</span></a>, здесь нельзя.</p></dd><dt><span class="term"><em class="replaceable"><code>имя_столбца</code></em></span></dt><dd><p>Имя столбца целевой таблицы. При необходимости имя столбца можно дополнить именем поля или индексом массива. (При добавлении данных лишь в некоторые поля составного типа другие поля будут содержать NULL.) Имя таблицы в указание целевого столбца добавлять не нужно.</p></dd><dt><span class="term"><code class="literal">OVERRIDING SYSTEM VALUE</code></span></dt><dd><p>Без этого предложения не допускается задание явного значения (отличного от <code class="literal">DEFAULT</code>) для столбца идентификации, определённого с характеристикой <code class="literal">GENERATED ALWAYS</code>. Данное предложение перекрывает это ограничение.</p></dd><dt><span class="term"><code class="literal">OVERRIDING USER VALUE</code></span></dt><dd><p>Если указывается это предложение, то значения, заданные для столбцов идентификации, которые определены с характеристикой <code class="literal">GENERATED BY DEFAULT</code>, игнорируются и вместо них применяются значения, выдаваемые последовательностями по умолчанию.</p></dd><dt><span class="term"><code class="literal">DEFAULT VALUES</code></span></dt><dd><p>Все столбцы получают значения по умолчанию. (Предложение <code class="literal">OVERRIDING</code> в этой форме не допускается.)</p></dd><dt><span class="term"><em class="replaceable"><code>выражение</code></em></span></dt><dd><p>Выражение, результат которого присваивается столбцу. В выражениях предложений <code class="literal">WHEN MATCHED</code> могут использоваться значения из исходной строки целевой таблицы и значения из строки <em class="replaceable"><code>источника_данных</code></em>. В выражениях предложений <code class="literal">WHEN NOT MATCHED</code> могут использоваться значения только из <em class="replaceable"><code>источника_данных</code></em>.</p></dd><dt><span class="term"><code class="literal">DEFAULT</code></span></dt><dd><p>Присвоить столбцу значение по умолчанию (или <code class="literal">NULL</code>, если выражение по умолчанию для столбца не определено).</p></dd><dt><span class="term"><em class="replaceable"><code>вложенный_SELECT</code></em></span></dt><dd><p>Подзапрос <code class="literal">SELECT</code>, выдающий столько выходных столбцов, сколько перечислено в предшествующем ему списке столбцов в скобках. При выполнении этого подзапроса должна быть получена максимум одна строка. Если он выдаёт одну строку, значения столбцов в нём присваиваются целевым столбцам; если же он не возвращает строку, целевым столбцам присваивается NULL. Этот подзапрос может обращаться к значениям исходной строки в целевой таблице, а также значениям строки <em class="replaceable"><code>источника_данных</code></em>.</p></dd></dl></div></div><div class="refsect1" id="id-1.9.3.156.7"><h2>Выводимая информация</h2><p>При успешном выполнении команда <code class="command">MERGE</code> возвращает метку команды в виде </p><pre class="screen">
MERGE <em class="replaceable"><code>общее_число</code></em>
</pre><p> Здесь <em class="replaceable"><code>общее_число</code></em> — суммарное количество изменённых строк (добавленных, изменённых или удалённых). Если <em class="replaceable"><code>общее_число</code></em> равно 0, ни одна строка не была изменена.</p></div><div class="refsect1" id="id-1.9.3.156.8"><h2>Замечания</h2><p>В ходе выполнения <code class="command">MERGE</code> производятся следующие действия. </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Вызываются все триггеры <code class="literal">BEFORE STATEMENT</code> для всех указанных действий, независимо от того, совпадают ли их предложения <code class="literal">WHEN</code>.</p></li><li class="listitem"><p>Выполняется соединение исходной таблицы с целевой. Полученный в результате запрос оптимизируется как обычно и выдаёт набор строк-кандидатов на изменение. Для каждой строки-кандидата на изменение: </p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>Для каждой строки определяется состояние: <code class="literal">MATCHED</code> (совпадает) или <code class="literal">NOT MATCHED</code> (не совпадает).</p></li><li class="listitem"><p>Проверяется каждое условие <code class="literal">WHEN</code> в заданном порядке, пока какое-либо не выдаст значение true.</p></li><li class="listitem"><p>Если условие выдаёт true, происходит следующее: </p><div class="orderedlist"><ol class="orderedlist" type="i"><li class="listitem"><p>Вызываются все триггеры <code class="literal">BEFORE ROW</code>, соответствующие типу события выполняемого действия.</p></li><li class="listitem"><p>Выполняется указанное действие, при этом вызываются ограничения-проверки для целевой таблицы.</p></li><li class="listitem"><p>Вызываются все триггеры <code class="literal">AFTER ROW</code>, соответствующие типу события выполняемого действия.</p></li></ol></div></li></ol></div></li><li class="listitem"><p>Выполняются все триггеры <code class="literal">AFTER STATEMENT</code> для всех указанных действий, независимо от того, выполнялись ли эти действия фактически. Это похоже на поведение оператора <code class="command">UPDATE</code>, когда он не меняет ни одной строки.</p></li></ol></div><p> То есть триггеры уровня оператора для некоторого события (скажем, <code class="command">INSERT</code>) будут вызываться всегда, когда <span class="emphasis"><em>указывается</em></span> действие такого типа. Триггеры уровня строк, напротив, вызываются только для определённого действия, которое <span class="emphasis"><em>выполняется</em></span>. Таким образом, при выполнении <code class="command">MERGE</code> могут вызываться триггеры уровня оператора как для <code class="command">UPDATE</code>, так и для <code class="command">INSERT</code>, даже если на уровне строк вызывались только триггеры <code class="command">UPDATE</code>.</p><p>Следует позаботиться о том, чтобы для каждой целевой строки в результате соединения создавалось не более одной строки-кандидата на изменение. Другими словами, целевая строка не должна соединяться с более чем одной строкой источника данных. Если это не так, только одна из строк-кандидатов будет применяться для изменения целевой строки; последующие попытки изменить эту строку вызовут ошибку. Ошибка также может произойти, когда триггеры строк вносят изменения в целевую таблицу, а команда <code class="command">MERGE</code> впоследствии воздействует на уже изменённые строки. Если повторится действие <code class="command">INSERT</code>, это вызовет нарушение уникальности, а повторение <code class="command">UPDATE</code> или <code class="command">DELETE</code> вызовет ошибку <span class="quote">«<span class="quote">Нарушение количества</span>»</span>; последнее требуется стандартом <acronym class="acronym">SQL</acronym>. Такое поведение отличается от поведения соединений в <code class="command">UPDATE</code> и <code class="command">DELETE</code>, традиционного для <span class="productname">PostgreSQL</span>, когда вторая и последующие попытки изменить одну и ту же строку просто игнорируются.</p><p>Если в предложении <code class="literal">WHEN</code> отсутствует дополнительное условие <code class="literal">AND</code>, оно становится последним достижимым предложением этого рода (<code class="literal">MATCHED</code> или <code class="literal">NOT MATCHED</code>). Если в команде встретится последующее предложение <code class="literal">WHEN</code> такого рода, оно гарантированно будет недостижимым, и это вызовет ошибку. В случае отсутствия последнего достижимого предложения любого рода возможна ситуация, когда для строки-кандидата на изменение не будет предпринято никаких действий.</p><p>Порядок, в котором строки выдаются из источника данных, по умолчанию не определён. Если необходим определённый порядок, например для предотвращения взаимоблокировок между параллельными транзакциями, его можно задать в <em class="replaceable"><code>исходном_запросе</code></em>.</p><p>В операторе <code class="command">MERGE</code> не допускается предложение <code class="literal">RETURNING</code>. Действия <code class="command">INSERT</code>, <code class="command">UPDATE</code> и <code class="command">DELETE</code> также не могут содержать предложения <code class="literal">RETURNING</code> или <code class="literal">WITH</code>.</p><p>Когда <code class="command">MERGE</code> выполняется одновременно с другими командами, изменяющими целевую таблицу, применяются обычные правила изоляции транзакций; поведение на каждом уровне изоляции описано в <a class="xref" href="transaction-iso.html" title="13.2. Изоляция транзакций">Разделе 13.2</a>. В качестве альтернативы можно рассмотреть использование оператора <code class="command">INSERT ... ON CONFLICT</code>, который предусматривает возможность выполнения команды <code class="command">UPDATE</code>, если параллельно выполняется команда <code class="command">INSERT</code>. Эти два типа операторов имеют ряд различий и особых ограничений, они не являются взаимозаменяемыми.</p></div><div class="refsect1" id="id-1.9.3.156.9"><h2>Примеры</h2><p>Корректировка клиентских счетов (<code class="literal">customer_accounts</code>) с учётом новых транзакций (<code class="literal">recent_transactions</code>). </p><pre class="programlisting">MERGE INTO customer_account ca
USING recent_transactions t
ON t.customer_id = ca.customer_id
WHEN MATCHED THEN
  UPDATE SET balance = balance + transaction_value
WHEN NOT MATCHED THEN
  INSERT (customer_id, balance)
  VALUES (t.customer_id, t.transaction_value);</pre><p>Заметьте, что это полностью равнозначно следующему оператору, потому что статус <code class="literal">MATCHED</code> не меняется во время выполнения. </p><pre class="programlisting">MERGE INTO customer_account ca
USING (SELECT customer_id, transaction_value FROM recent_transactions) AS t
ON t.customer_id = ca.customer_id
WHEN MATCHED THEN
  UPDATE SET balance = balance + transaction_value
WHEN NOT MATCHED THEN
  INSERT (customer_id, balance)
  VALUES (t.customer_id, t.transaction_value);</pre><p>Обработка изменений количества товара: новая позиция добавляется вместе с количеством; если данная позиция уже существует, её количество корректируется; позиции с нулевым количеством удаляются. </p><pre class="programlisting">MERGE INTO wines w
USING wine_stock_changes s
ON s.winename = w.winename
WHEN NOT MATCHED AND s.stock_delta &gt; 0 THEN
  INSERT VALUES(s.winename, s.stock_delta)
WHEN MATCHED AND w.stock + s.stock_delta &gt; 0 THEN
  UPDATE SET stock = w.stock + s.stock_delta
WHEN MATCHED THEN
  DELETE;</pre><p> Таблица <code class="literal">wine_stock_changes</code> может быть, например, временной таблицей, недавно загруженной в базу данных.</p></div><div class="refsect1" id="id-1.9.3.156.10"><h2>Совместимость</h2><p>Эта команда соответствует стандарту <acronym class="acronym">SQL</acronym>.</p><p>Предложение <code class="literal">WITH</code> и действие <code class="literal">DO NOTHING</code> являются расширениями стандарта <acronym class="acronym">SQL</acronym>.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-lock.html" title="LOCK">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html" title="Команды SQL">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-move.html" title="MOVE">След.</a></td></tr><tr><td width="40%" align="left" valign="top">LOCK </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> MOVE</td></tr></table></div></body></html>