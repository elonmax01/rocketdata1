<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>68.3. Расширяемость</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="gist-builtin-opclasses.html" title="68.2. Встроенные классы операторов" /><link rel="next" href="gist-implementation.html" title="68.4. Реализация" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">68.3. Расширяемость</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="gist-builtin-opclasses.html" title="68.2. Встроенные классы операторов">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="gist.html" title="Глава 68. Индексы GiST">Наверх</a></td><th width="60%" align="center">Глава 68. Индексы GiST</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="gist-implementation.html" title="68.4. Реализация">След.</a></td></tr></table><hr /></div><div class="sect1" id="GIST-EXTENSIBILITY"><div class="titlepage"><div><div><h2 class="title" style="clear: both">68.3. Расширяемость <a href="#GIST-EXTENSIBILITY" class="id_link">#</a></h2></div></div></div><p>Реализация нового метода доступа индекса традиционно была большой и сложной задачей. Чтобы её решить, необходимо было понимать внутреннее устройство базы данных, в частности работу менеджера блокировок и журнала предзаписи. Но с интерфейсом <acronym class="acronym">GiST</acronym>, реализующим высокий уровень абстракции, разработчик метода доступа должен реализовать только смысловое наполнение индексируемого типа данных. Уровень <acronym class="acronym">GiST</acronym> берёт на себя заботу о параллельном доступе, поддержке журнала и поиске в структуре дерева.</p><p>Эту расширяемость не следует путать с расширяемостью других стандартных деревьев поиска в смысле поддержки различных типов данных. Например, <span class="productname">PostgreSQL</span> поддерживает расширяемость B-деревьев и индексов по хешу. Это означает, что в <span class="productname">PostgreSQL</span> вы можете построить B-дерево или хеш-таблицу по любому желаемому типу данных. Но такие B-деревья будут поддерживать только предикаты сравнений (<code class="literal">&lt;</code>, <code class="literal">=</code>, <code class="literal">&gt;</code>), а индексы по хешу только запросы с равенством.</p><p>Поэтому, если вы проиндексируете в <span class="productname">PostgreSQL</span> в B-дереве, например, коллекцию изображений, вы сможете выполнять только проверки вида <span class="quote">«<span class="quote">равны ли изображения X и Y</span>»</span>, <span class="quote">«<span class="quote">меньше ли изображение X изображения Y</span>»</span> и <span class="quote">«<span class="quote">больше ли изображение X изображения Y</span>»</span>. Это может быть полезно, в зависимости от того, как вы определите операции <span class="quote">«<span class="quote">равно</span>»</span>, <span class="quote">«<span class="quote">меньше</span>»</span> и <span class="quote">«<span class="quote">больше</span>»</span>. Однако используя индекс на базе <acronym class="acronym">GiST</acronym>, возможно удовлетворять и запросы из предметной области, например, <span class="quote">«<span class="quote">найти все изображения лошадей</span>»</span> или <span class="quote">«<span class="quote">найти все пересвеченные изображения</span>»</span>.</p><p>Всё, что нужно, чтобы получить работающий метод доступа <acronym class="acronym">GiST</acronym> — это реализовать несколько методов, определяющих поведение ключей в дереве. Конечно, эти методы должны быть довольно изощрёнными, чтобы поддерживать изощрённые запросы, но для всех стандартных запросов (B-деревьев, R-деревьев и т. д.) они относительно просты. Словом, <acronym class="acronym">GiST</acronym> сочетает расширяемость с универсальностью, повторным использованием кода и аккуратным интерфейсом.</p><p>Класс операторов индекса <acronym class="acronym">GiST</acronym> должен предоставить пять методов и может дополнительно предоставлять ещё шесть. Корректность индекса обеспечивается реализацией методов <code class="function">same</code>, <code class="function">consistent</code> и <code class="function">union</code>, а его эффективность (по размеру и скорости) будет зависеть от методов <code class="function">penalty</code> и <code class="function">picksplit</code>. Два необязательных метода, <code class="function">compress</code> и <code class="function">decompress</code>, позволяют реализовать внутреннее представление данных дерева, не совпадающее с типом индексируемых данных. Данные листьев индекса должны быть индексируемого типа, тогда как в остальных узлах дерева могут быть произвольные структуры C (но при этом должны соблюдаться правила, предъявляемые <span class="productname">PostgreSQL</span> к типам данных; прочитайте о <code class="literal">varlena</code> для данных переменного размера). Если внутренний тип данных дерева существует на уровне SQL, в команде <code class="command">CREATE OPERATOR CLASS</code> можно использовать указание <code class="literal">STORAGE</code>. Необязательный восьмой метод <code class="function">distance</code> нужно реализовать, только если класс операторов желает поддерживать упорядоченные сканирования (поиск ближайших соседей). Необязательный девятый метод <code class="function">fetch</code> требуется, если класс операторов должен поддерживать сканирование только индекса и при этом предоставляется метод <code class="function">compress</code>. Необязательный десятый метод <code class="function">options</code> необходим, если класс операторов содержит определяемые пользователем параметры. Необязательный одиннадцатый метод <code class="function">sortsupport</code> используется для ускорения построения индекса <acronym class="acronym">GiST</acronym>.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="function">consistent</code></span></dt><dd><p>Для переданной записи индекса <code class="literal">p</code> и значения запроса <code class="literal">q</code> эта функция определяет, является ли запись индекса <span class="quote">«<span class="quote">соответствующей</span>»</span> запросу; то есть, может ли предикат <span class="quote">«<span class="quote"><em class="replaceable"><code>индексированный_столбец</code></em> <em class="replaceable"><code>индексируемый_оператор</code></em> <code class="literal">q</code></span>»</span> удовлетворяться для какой-либо строки, представленной данной записью индекса? Для записей на уровне листьев это равносильно проверке индексируемого условия, тогда как для внутреннего узла дерева требуется определить, нужно ли сканировать поддерево индекса, относящееся к данному узлу. Когда результат <code class="literal">true</code>, также должен возвращаться флаг <code class="literal">recheck</code>, показывающий, точно ли удовлетворяется предикат или это лишь потенциально возможно. Если <code class="literal">recheck</code> = <code class="literal">false</code>, это означает, что индекс проверил условие предиката в точности, тогда как при <code class="literal">recheck</code> = <code class="literal">true</code> проверяемая строка будет только кандидатом на совпадение. В этом случае система автоматически перепроверит <em class="replaceable"><code>индексируемый_оператор</code></em> с действительным значением строки, чтобы окончательно определить, соответствует ли оно запросу. Благодаря этому <acronym class="acronym">GiST</acronym> поддерживает индексы как точной, так и неточной структуры.</p><p>В <acronym class="acronym">SQL</acronym> эта функция должна объявляться примерно так: </p><pre class="programlisting">CREATE OR REPLACE FUNCTION my_consistent(internal, data_type, smallint, oid, internal)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;</pre><p> А соответствующий код в модуле C может реализовываться по такому шаблону: </p><pre class="programlisting">PG_FUNCTION_INFO_V1(my_consistent);

Datum
my_consistent(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    data_type  *query = PG_GETARG_DATA_TYPE_P(1);
    StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2);
    /* Oid subtype = PG_GETARG_OID(3); */
    bool       *recheck = (bool *) PG_GETARG_POINTER(4);
    data_type  *key = DatumGetDataType(entry-&gt;key);
    bool        retval;

    /*
     * Определить возвращаемое значение как функцию стратегии, ключа и запроса.
     *
     * Вызовите GIST_LEAF(entry), чтобы узнать текущую позицию в дереве индекса,
     * что удобно, например для поддержки оператора = (вы можете проверить
     * равенство в листьях дерева и непустое пересечение в остальных
     * узлах).
     */

    *recheck = true;        /* или false, если проверка точная */

    PG_RETURN_BOOL(retval);
}</pre><p> Здесь <code class="varname">key</code> — это элемент в индексе, а <code class="varname">query</code> — значение, искомое в индексе. Параметр <code class="literal">StrategyNumber</code> показывает, какой оператор из класса операторов применяется — он соответствует одному из номеров операторов, заданных в команде <code class="command">CREATE OPERATOR CLASS</code>.</p><p>В зависимости от того, какие операторы включены в класс, тип данных <code class="varname">query</code> может быть разным для разных операторов, так как это будет тот тип, что фигурирует в правой части оператора, и он может отличаться от индексируемого типа данных, фигурирующего слева. (В показанном выше шаблоне предполагается, что допускается только один тип; в противном случае получение значения <code class="varname">query</code> зависело бы от оператора.) В SQL-объявлении функции <code class="function">consistent</code> для аргумента <code class="varname">query</code> рекомендуется установить индексированный тип данного класса операторов, хотя фактический тип может быть каким-то другим, в зависимости от оператора.</p></dd><dt><span class="term"><code class="function">union</code></span></dt><dd><p>Этот метод консолидирует информацию в дереве. Получив набор записей, он должен сгенерировать в индексе новую запись, представляющие все эти записи.</p><p>В <acronym class="acronym">SQL</acronym> эта функция должна объявляться так: </p><pre class="programlisting">CREATE OR REPLACE FUNCTION my_union(internal, internal)
RETURNS storage_type
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;</pre><p> И соответствующий код в модуле C должен реализовываться по такому шаблону: </p><pre class="programlisting">PG_FUNCTION_INFO_V1(my_union);

Datum
my_union(PG_FUNCTION_ARGS)
{
    GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);
    GISTENTRY  *ent = entryvec-&gt;vector;
    data_type  *out,
               *tmp,
               *old;
    int         numranges,
                i = 0;

    numranges = entryvec-&gt;n;
    tmp = DatumGetDataType(ent[0].key);
    out = tmp;

    if (numranges == 1)
    {
        out = data_type_deep_copy(tmp);

        PG_RETURN_DATA_TYPE_P(out);
    }

    for (i = 1; i &lt; numranges; i++)
    {
        old = out;
        tmp = DatumGetDataType(ent[i].key);
        out = my_union_implementation(out, tmp);
    }

    PG_RETURN_DATA_TYPE_P(out);
}</pre><p>Как можно заметить, в этом шаблоне мы имеем дело с типом данных, для которого <code class="literal">union(X, Y, Z) = union(union(X, Y), Z)</code>. Достаточно просто можно поддержать и такие типы данных, для которых это не выполняется, реализовав соответствующий алгоритм объединения в этом опорном методе <acronym class="acronym">GiST</acronym>.</p><p>Результатом функции <code class="function">union</code> должно быть значение типа хранения индекса, каким бы он ни был (он может совпадать с типом индексированного столбца, а может и отличаться от него). Функция, реализующая <code class="function">union</code>, должна возвращать указатель на память, выделенную вызовом <code class="function">palloc()</code>. Она не может просто вернуть полученное значение как есть, даже если оно имеет тот же тип.</p><p>Как показано выше, первый аргумент <code class="type">internal</code> функции <code class="function">union</code> на самом деле представляет указатель <code class="structname">GistEntryVector</code>. Во втором аргументе (его можно игнорировать) передаётся указатель на целочисленную переменную. (Раньше требовалось, чтобы функция <code class="function">union</code> сохраняла в этой переменной размер результирующего значения, но теперь такого требования нет.)</p></dd><dt><span class="term"><code class="function">compress</code></span></dt><dd><p>Преобразует элемент данных в формат, подходящий для физического хранения в странице индекса. Если метод <code class="function">compress</code> не реализован, элементы данных хранятся в индексе без модификации.</p><p>В <acronym class="acronym">SQL</acronym> эта функция должна объявляться так: </p><pre class="programlisting">CREATE OR REPLACE FUNCTION my_compress(internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;</pre><p> И соответствующий код в модуле C должен реализовываться по такому шаблону: </p><pre class="programlisting">PG_FUNCTION_INFO_V1(my_compress);

Datum
my_compress(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    GISTENTRY  *retval;

    if (entry-&gt;leafkey)
    {
        /* заменить entry-&gt;key сжатой версией */
        compressed_data_type *compressed_data = palloc(sizeof(compressed_data_type));

        /* заполнить *compressed_data из entry-&gt;key ... */

        retval = palloc(sizeof(GISTENTRY));
        gistentryinit(*retval, PointerGetDatum(compressed_data),
                      entry-&gt;rel, entry-&gt;page, entry-&gt;offset, FALSE);
    }
    else
    {
        /* обычно с записями внутренних узлов ничего делать не нужно */
        retval = entry;
    }

    PG_RETURN_POINTER(retval);
}</pre><p>Разумеется, <em class="replaceable"><code>compressed_data_type</code></em> (тип сжатых данных) нужно привести к нужному типу, при преобразовании в который будут сжиматься узлы на уровне листьев.</p></dd><dt><span class="term"><code class="function">decompress</code></span></dt><dd><p>Преобразует сохранённое представление данных в формат, с которым смогут работать другие методы GiST в классе операторов. Если метод <code class="function">decompress</code> опускается, подразумевается, что эти методы могут работать непосредственно с форматом хранения данных. (Метод <code class="function">decompress</code> не обязательно будет обратным к <code class="function">compress</code>; в частности, если функция <code class="function">compress</code> сохраняет данные с потерями, <code class="function">decompress</code> не сможет восстановить в точности исходные данные. Поэтому метод <code class="function">decompress</code> в общем случае неравнозначен <code class="function">fetch</code>, так как другим методам GiST может не потребоваться восстанавливать данные полностью.)</p><p>В <acronym class="acronym">SQL</acronym> эта функция должна объявляться так: </p><pre class="programlisting">CREATE OR REPLACE FUNCTION my_decompress(internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;</pre><p> И соответствующий код в модуле C должен реализовываться по такому шаблону: </p><pre class="programlisting">PG_FUNCTION_INFO_V1(my_decompress);

Datum
my_decompress(PG_FUNCTION_ARGS)
{
    PG_RETURN_POINTER(PG_GETARG_POINTER(0));
}</pre><p> Этот шаблон подходит для случая, когда преобразовывать данные не нужно. (Но, разумеется, ещё проще и в большинстве случаев рекомендуется вовсе опустить этот метод.)</p></dd><dt><span class="term"><code class="function">penalty</code></span></dt><dd><p>Возвращает значение, выражающее <span class="quote">«<span class="quote">стоимость</span>»</span> добавления новой записи в конкретную ветвь дерева. Элементы будут вставляться по тому направлению в дереве, для которого значение <code class="function">penalty</code> минимально. Результаты <code class="function">penalty</code> должны быть неотрицательными; если возвращается отрицательное значение, оно воспринимается как ноль.</p><p>В <acronym class="acronym">SQL</acronym> эта функция должна объявляться так: </p><pre class="programlisting">CREATE OR REPLACE FUNCTION my_penalty(internal, internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;  -- в некоторых случаях функции стоимости не должны быть строгими</pre><p> И соответствующий код в модуле C может реализовываться по такому шаблону: </p><pre class="programlisting">PG_FUNCTION_INFO_V1(my_penalty);

Datum
my_penalty(PG_FUNCTION_ARGS)
{
    GISTENTRY  *origentry = (GISTENTRY *) PG_GETARG_POINTER(0);
    GISTENTRY  *newentry = (GISTENTRY *) PG_GETARG_POINTER(1);
    float      *penalty = (float *) PG_GETARG_POINTER(2);
    data_type  *orig = DatumGetDataType(origentry-&gt;key);
    data_type  *new = DatumGetDataType(newentry-&gt;key);

    *penalty = my_penalty_implementation(orig, new);
    PG_RETURN_POINTER(penalty);
}</pre><p> По историческим причинам функция <code class="function">penalty</code> не просто возвращает результат типа <code class="type">float</code>; вместо этого она должна сохранить его значение по адресу, указанному третьим аргументом. Собственно возвращаемое значение игнорируется, хотя в нём принято возвращать этот же адрес.</p><p>Функция <code class="function">penalty</code> важна для хорошей производительности индекса. Она будет вызываться во время добавления записи, чтобы выбрать ветвь для дальнейшего движения, когда в дерево нужно добавить новый элемент. Это имеет значение во время запроса, так как чем более сбалансирован индекс, тем быстрее будет поиск в нём.</p></dd><dt><span class="term"><code class="function">picksplit</code></span></dt><dd><p>Когда необходимо разделить страницу индекса, эта функция решает, какие записи должны остаться в старой странице, а какие нужно перенести в новую.</p><p>В <acronym class="acronym">SQL</acronym> эта функция должна объявляться так: </p><pre class="programlisting">CREATE OR REPLACE FUNCTION my_picksplit(internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;</pre><p> И соответствующий код в модуле C может реализовываться по такому шаблону: </p><pre class="programlisting">PG_FUNCTION_INFO_V1(my_picksplit);

Datum
my_picksplit(PG_FUNCTION_ARGS)
{
    GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);
    GIST_SPLITVEC *v = (GIST_SPLITVEC *) PG_GETARG_POINTER(1);
    OffsetNumber maxoff = entryvec-&gt;n - 1;
    GISTENTRY  *ent = entryvec-&gt;vector;
    int         i,
                nbytes;
    OffsetNumber *left,
               *right;
    data_type  *tmp_union;
    data_type  *unionL;
    data_type  *unionR;
    GISTENTRY **raw_entryvec;

    maxoff = entryvec-&gt;n - 1;
    nbytes = (maxoff + 1) * sizeof(OffsetNumber);

    v-&gt;spl_left = (OffsetNumber *) palloc(nbytes);
    left = v-&gt;spl_left;
    v-&gt;spl_nleft = 0;

    v-&gt;spl_right = (OffsetNumber *) palloc(nbytes);
    right = v-&gt;spl_right;
    v-&gt;spl_nright = 0;

    unionL = NULL;
    unionR = NULL;

    /* Инициализировать чистый вектор записи. */
    raw_entryvec = (GISTENTRY **) malloc(entryvec-&gt;n * sizeof(void *));
    for (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))
        raw_entryvec[i] = &amp;(entryvec-&gt;vector[i]);

    for (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))
    {
        int         real_index = raw_entryvec[i] - entryvec-&gt;vector;

        tmp_union = DatumGetDataType(entryvec-&gt;vector[real_index].key);
        Assert(tmp_union != NULL);

        /*
         * Выбрать, куда помещать записи индекса и изменить unionL и unionR
         * соответственно. Добавить записи в v-&gt;spl_left или
         * v-&gt;spl_right и увеличить счётчики.
         */

        if (my_choice_is_left(unionL, curl, unionR, curr))
        {
            if (unionL == NULL)
                unionL = tmp_union;
            else
                unionL = my_union_implementation(unionL, tmp_union);

            *left = real_index;
            ++left;
            ++(v-&gt;spl_nleft);
        }
        else
        {
            /*
             * То же самое с правой стороной
             */
        }
    }

    v-&gt;spl_ldatum = DataTypeGetDatum(unionL);
    v-&gt;spl_rdatum = DataTypeGetDatum(unionR);
    PG_RETURN_POINTER(v);
}</pre><p> Заметьте, что результат функции <code class="function">picksplit</code> доставляется через полученную на вход структуру <code class="structname">v</code>. Собственно возвращаемое значение игнорируется, хотя в нём принято возвращать адрес <code class="structname">v</code>.</p><p>Как и <code class="function">penalty</code>, функция <code class="function">picksplit</code> важна для хорошей производительности индекса. Сложность создания быстродействующих индексов <acronym class="acronym">GiST</acronym> заключается как раз в разработке подходящих реализаций <code class="function">penalty</code> и <code class="function">picksplit</code>.</p></dd><dt><span class="term"><code class="function">same</code></span></dt><dd><p>Возвращает true, если два элемента индекса равны, и false в противном случае. (<span class="quote">«<span class="quote">Элемент индекса</span>»</span> — это значение типа хранения индекса, а не обязательно исходного типа индексируемого столбца.)</p><p>В <acronym class="acronym">SQL</acronym> эта функция должна объявляться так: </p><pre class="programlisting">CREATE OR REPLACE FUNCTION my_same(storage_type, storage_type, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;</pre><p> И соответствующий код в модуле C может реализовываться по такому шаблону: </p><pre class="programlisting">PG_FUNCTION_INFO_V1(my_same);

Datum
my_same(PG_FUNCTION_ARGS)
{
    prefix_range *v1 = PG_GETARG_PREFIX_RANGE_P(0);
    prefix_range *v2 = PG_GETARG_PREFIX_RANGE_P(1);
    bool       *result = (bool *) PG_GETARG_POINTER(2);

    *result = my_eq(v1, v2);
    PG_RETURN_POINTER(result);
}</pre><p> По историческим причинам функция <code class="function">same</code> не просто возвращает результат булевого типа; вместо этого она должна сохранить флаг по адресу, указанному третьим аргументом. Собственно возвращаемое значение игнорируется, хотя в нём принято возвращать этот же адрес.</p></dd><dt><span class="term"><code class="function">distance</code></span></dt><dd><p>Для переданной записи индекса <code class="literal">p</code> и значения запроса <code class="literal">q</code> эта функция определяет <span class="quote">«<span class="quote">дистанцию</span>»</span> от записи индекса до значения в запросе. Эта функция должна быть представлена, если класс операторов содержит какие-либо операторы упорядочивания. Запрос с оператором упорядочивания будет выполняться так, чтобы записи индекса с наименьшей <span class="quote">«<span class="quote">дистанцией</span>»</span> возвращались первыми, так что результаты должны согласовываться со смысловым значением оператора. Для записи на уровне листьев результат представляет только дистанцию до этой записи, а для внутреннего узла дерева это будет минимальная дистанция, которая может быть получена среди всех его потомков.</p><p>В <acronym class="acronym">SQL</acronym> эта функция должна объявляться так: </p><pre class="programlisting">CREATE OR REPLACE FUNCTION my_distance(internal, data_type, smallint, oid, internal)
RETURNS float8
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;</pre><p> И соответствующий код в модуле C должен реализовываться по такому шаблону: </p><pre class="programlisting">PG_FUNCTION_INFO_V1(my_distance);

Datum
my_distance(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    data_type  *query = PG_GETARG_DATA_TYPE_P(1);
    StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2);
    /* Oid subtype = PG_GETARG_OID(3); */
    /* bool *recheck = (bool *) PG_GETARG_POINTER(4); */
    data_type  *key = DatumGetDataType(entry-&gt;key);
    double      retval;

    /*
     * определить возвращаемое значение как функцию стратегии, ключа и запроса.
     */

    PG_RETURN_FLOAT8(retval);
}</pre><p> Функции <code class="function">distance</code> передаются те же аргументы, что и функции <code class="function">consistent</code>.</p><p>При определении дистанции допускается некоторая неточность, если результат никогда не будет превышать действительную дистанцию до элемента. Так, например, в геометрических приложениях бывает достаточно определить дистанцию до описанного прямоугольника. Для внутреннего узла дерева результат не должен превышать дистанцию до любого из его дочерних узлов. Если возвращаемая дистанция неточная, функция должна установить флаг <code class="literal">*recheck</code>. (Это необязательно для внутренних узлов дерева; для них результат всегда считается неточным.) В этом случае исполнитель вычислит точную дистанцию, выбрав кортеж из кучи, и переупорядочит кортежи при необходимости.</p><p>Если функция distance возвращает <code class="literal">*recheck = true</code> для любого узла на уровне листьев, типом результата исходного оператора упорядочивания должен быть <code class="type">float8</code> или <code class="type">float4</code>, и значения результата функции distance должны быть сравнимы с результатами исходного оператора упорядочивания, так как исполнитель будет выполнять сортировку, используя и результаты функции distance, и уточнённые результаты оператора упорядочивания. В противном случае значениями результата distance могут быть любые конечные значения <code class="type">float8</code>, при условии, что относительный порядок значений результата соответствует порядку, который даёт оператор упорядочивания. (Значения бесконечность и минус бесконечность применяются внутри для особых случаев, например, представления NULL, поэтому возвращать такие значения из функций <code class="function">distance</code> не рекомендуется.)</p></dd><dt><span class="term"><code class="function">fetch</code></span></dt><dd><p>Преобразует сжатое представление элемента данных в индексе в исходный тип данных, для сканирования только индекса. Возвращаемые данные должны быть точной, не примерной копией изначально проиндексированного значения.</p><p>В <acronym class="acronym">SQL</acronym> эта функция должна объявляться так: </p><pre class="programlisting">CREATE OR REPLACE FUNCTION my_fetch(internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;</pre><p> В качестве аргумента ей передаётся указатель на структуру <code class="structname">GISTENTRY</code>. При вызове её поле <code class="structfield">key</code> содержит данные листа в сжатой форме (не NULL). Возвращаемое значение — ещё одна структура <code class="structname">GISTENTRY</code>, в которой поле <code class="structfield">key</code> содержит те же данные в исходной, развёрнутой форме. Если функция <code class="function">compress</code> класса операторов не делает с данными листьев ничего, метод <code class="function">fetch</code> может возвратить аргумент без изменений. Либо, если класс операторов не имеет функции <code class="function">compress</code>, метод <code class="function">fetch</code> тоже может быть опущен, так как он в любом случае не должен ничего делать.</p><p>Соответствующий код в модуле C должен реализовываться по такому шаблону: </p><pre class="programlisting">PG_FUNCTION_INFO_V1(my_fetch);

Datum
my_fetch(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    input_data_type *in = DatumGetPointer(entry-&gt;key);
    fetched_data_type *fetched_data;
    GISTENTRY  *retval;

    retval = palloc(sizeof(GISTENTRY));
    fetched_data = palloc(sizeof(fetched_data_type));

    /*
     * Преобразовать структуру 'fetched_data' в Datum исходного типа данных.
     */

    /* Заполнить *retval из fetch_data. */
    gistentryinit(*retval, PointerGetDatum(converted_datum),
                  entry-&gt;rel, entry-&gt;page, entry-&gt;offset, FALSE);

    PG_RETURN_POINTER(retval);
}</pre><p>Если метод сжатия является неточным для записей уровня листьев, такой класс операторов не может поддерживать сканирование только индекса и не должен определять функцию <code class="function">fetch</code>.</p></dd><dt><span class="term"><code class="function">options</code></span></dt><dd><p>Позволяет определить видимые пользователю параметры, управляющие поведением класса операторов.</p><p>В <acronym class="acronym">SQL</acronym> эта функция должна объявляться так: </p><pre class="programlisting">CREATE OR REPLACE FUNCTION my_options(internal)
RETURNS void
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;</pre><p>Этой функции передаётся указатель на структуру <code class="structname">local_relopts</code>, в которую нужно внести набор параметров, относящихся к классу операторов. Обращаться к этим параметрам из других опорных функций можно с помощью макросов <code class="literal">PG_HAS_OPCLASS_OPTIONS()</code> и <code class="literal">PG_GET_OPCLASS_OPTIONS()</code>.</p><p>Ниже показан пример реализации функции my_options() и использования параметров из других опорных функций: </p><pre class="programlisting">typedef enum MyEnumType
{
    MY_ENUM_ON,
    MY_ENUM_OFF,
    MY_ENUM_AUTO
} MyEnumType;

typedef struct
{
    int32   vl_len_;    /* заголовок varlena (не меняйте его напрямую!) */
    int     int_param;  /* целочисленный параметр */
    double  real_param; /* параметр с плавающей точкой */
    MyEnumType enum_param; /* параметр-перечисление */
    int     str_param;  /* строковый параметр */
} MyOptionsStruct;

/* Строковое представление значений в перечислении */
static relopt_enum_elt_def myEnumValues[] =
{
    {"on", MY_ENUM_ON},
    {"off", MY_ENUM_OFF},
    {"auto", MY_ENUM_AUTO},
    {(const char *) NULL}   /* завершающий элемент списка */
};

static char *str_param_default = "default";

/*
 * Пример проверочной функции: проверяет, что строка не длиннее 8 байт.
 */
static void 
validate_my_string_relopt(const char *value)
{
    if (strlen(value) &gt; 8)
        ereport(ERROR,
                (errcode(ERRCODE_INVALID_PARAMETER_VALUE),
                 errmsg("str_param must be at most 8 bytes")));
}

/*
 * Пример функции-заполнителя: переводит символы в нижний регистр.
 */
static Size
fill_my_string_relopt(const char *value, void *ptr)
{
    char   *tmp = str_tolower(value, strlen(value), DEFAULT_COLLATION_OID);
    int     len = strlen(tmp);

    if (ptr)
        strcpy((char *) ptr, tmp);

    pfree(tmp);
    return len + 1;
}

PG_FUNCTION_INFO_V1(my_options);

Datum
my_options(PG_FUNCTION_ARGS)
{
    local_relopts *relopts = (local_relopts *) PG_GETARG_POINTER(0);

    init_local_reloptions(relopts, sizeof(MyOptionsStruct));
    add_local_int_reloption(relopts, "int_param", "integer parameter",
                            100, 0, 1000000,
                            offsetof(MyOptionsStruct, int_param));
    add_local_real_reloption(relopts, "real_param", "real parameter",
                             1.0, 0.0, 1000000.0,
                             offsetof(MyOptionsStruct, real_param));
    add_local_enum_reloption(relopts, "enum_param", "enum parameter",
                             myEnumValues, MY_ENUM_ON,
                             "Valid values are: \"on\", \"off\" and \"auto\".",
                             offsetof(MyOptionsStruct, enum_param));
    add_local_string_reloption(relopts, "str_param", "string parameter",
                               str_param_default,
                               &amp;validate_my_string_relopt,
                               &amp;fill_my_string_relopt,
                               offsetof(MyOptionsStruct, str_param));

    PG_RETURN_VOID();
}

PG_FUNCTION_INFO_V1(my_compress);

Datum
my_compress(PG_FUNCTION_ARGS)
{
    int     int_param = 100;
    double  real_param = 1.0;
    MyEnumType enum_param = MY_ENUM_ON;
    char   *str_param = str_param_default;

    /*
     * Обычно когда в классе операторов определён метод 'options', полученные через него
     * параметры всегда передаются опорным функциям.  Однако, если вы добавите метод 'options' в
     * существующий класс операторов, в ранее созданных индексах параметров не будет, поэтому
     * необходима следующая проверка.
     */
    if (PG_HAS_OPCLASS_OPTIONS())
    {
        MyOptionsStruct *options = (MyOptionsStruct *) PG_GET_OPCLASS_OPTIONS();

        int_param = options-&gt;int_param;
        real_param = options-&gt;real_param;
        enum_param = options-&gt;enum_param;
        str_param = GET_STRING_RELOPTION(options, str_param);
    }

    /* продолжение реализации опорной функции */
}</pre><p>Так как в <acronym class="acronym">GiST</acronym> представление ключа допускает гибкость, могут быть полезны параметры для настройки этого индекса. Например, можно задать длину ключа сигнатуры. В качестве примера рассмотрите функцию <code class="literal">gtsvector_options()</code>.</p></dd><dt><span class="term"><code class="function">sortsupport</code></span></dt><dd><p>Возвращает функцию-компаратор для сортировки данных с сохранением локальности. Она используется командами <code class="command">CREATE INDEX</code> и <code class="command">REINDEX</code>. Качество созданного индекса зависит от того, насколько хорошо порядок сортировки, определённый функцией-компаратором, сохраняет локальность вводимых данных.</p><p>Метод <code class="function">sortsupport</code> не является обязательным. Если он не предоставляется, <code class="command">CREATE INDEX</code> создаёт индекс, вставляя каждый кортеж в дерево с помощью функций <code class="function">penalty</code> и <code class="function">picksplit</code>, но этот способ гораздо медленнее.</p><p>В <acronym class="acronym">SQL</acronym> эта функция должна объявляться так: </p><pre class="programlisting">CREATE OR REPLACE FUNCTION my_sortsupport(internal)
RETURNS void
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;</pre><p> В аргументе передаётся указатель на структуру <code class="structname">SortSupport</code>. Как минимум, данная функция должна заполнить в ней поле <code class="structfield">comparator</code>. Компаратору передаются три аргумента: два элемента Datum для сравнения и указатель на структуру <code class="structname">SortSupport</code>. В данном случае в Datum передаются индексированные значения в том формате, в котором они хранятся в индексе; то есть в формате, возвращаемом методом <code class="function">compress</code>. Полный API определён в файле <code class="filename">src/include/utils/sortsupport.h</code>.</p><p>Соответствующий код в модуле C должен реализовываться по такому шаблону: </p><pre class="programlisting">PG_FUNCTION_INFO_V1(my_sortsupport);

static int
my_fastcmp(Datum x, Datum y, SortSupport ssup)
{
  /* establish order between x and y by computing some sorting value z */

  int z1 = ComputeSpatialCode(x);
  int z2 = ComputeSpatialCode(y);

  return z1 == z2 ? 0 : z1 &gt; z2 ? 1 : -1;
}

Datum
my_sortsupport(PG_FUNCTION_ARGS)
{
  SortSupport ssup = (SortSupport) PG_GETARG_POINTER(0);

  ssup-&gt;comparator = my_fastcmp;
  PG_RETURN_VOID();
}</pre></dd></dl></div><p>Все опорные методы GiST обычно вызываются в кратковременных контекстах памяти; то есть, <code class="varname">CurrentMemoryContext</code> сбрасывается после обработки каждого кортежа. Таким образом можно не заботиться об освобождении любых блоков памяти, выделенных функцией palloc. Однако в некоторых случаях для опорного метода полезно кешировать какие-либо данные между вызовами. Для этого нужно разместить долгоживущие данные в контексте <code class="literal">fcinfo-&gt;flinfo-&gt;fn_mcxt</code> и сохранить указатель на них в <code class="literal">fcinfo-&gt;flinfo-&gt;fn_extra</code>. Такие данные смогут просуществовать всё время операции с индексом (например, одно сканирование индекса GiST, построение индекса или добавление кортежа в индекс). Не забудьте вызвать pfree для предыдущего значения, заменяя значение в <code class="literal">fn_extra</code>, чтобы не допустить накопления утечек памяти в ходе операции.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="gist-builtin-opclasses.html" title="68.2. Встроенные классы операторов">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="gist.html" title="Глава 68. Индексы GiST">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="gist-implementation.html" title="68.4. Реализация">След.</a></td></tr><tr><td width="40%" align="left" valign="top">68.2. Встроенные классы операторов </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 68.4. Реализация</td></tr></table></div></body></html>