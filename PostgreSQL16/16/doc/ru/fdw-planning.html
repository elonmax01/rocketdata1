<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>59.4. Планирование запросов с обёртками сторонних данных</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="fdw-helpers.html" title="59.3. Вспомогательные функции для обёрток сторонних данных" /><link rel="next" href="fdw-row-locking.html" title="59.5. Блокировка строк в обёртках сторонних данных" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">59.4. Планирование запросов с обёртками сторонних данных</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="fdw-helpers.html" title="59.3. Вспомогательные функции для обёрток сторонних данных">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="fdwhandler.html" title="Глава 59. Написание обёртки сторонних данных">Наверх</a></td><th width="60%" align="center">Глава 59. Написание обёртки сторонних данных</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="fdw-row-locking.html" title="59.5. Блокировка строк в обёртках сторонних данных">След.</a></td></tr></table><hr /></div><div class="sect1" id="FDW-PLANNING"><div class="titlepage"><div><div><h2 class="title" style="clear: both">59.4. Планирование запросов с обёртками сторонних данных <a href="#FDW-PLANNING" class="id_link">#</a></h2></div></div></div><p>Процедуры в FDW, реализующие функции <code class="function">GetForeignRelSize</code>, <code class="function">GetForeignPaths</code>, <code class="function">GetForeignPlan</code>, <code class="function">PlanForeignModify</code>, <code class="function">GetForeignJoinPaths</code>, <code class="function">GetForeignUpperPaths</code> и <code class="function">PlanDirectModify</code>, должны вписываться в работу планировщика <span class="productname">PostgreSQL</span>. Здесь даётся несколько замечаний о том, как это должно происходить.</p><p>Для уменьшения объёма выбираемых из сторонней таблицы данных (и как следствие, сокращения стоимости) может использоваться информация, поступающая в <code class="literal">root</code> и <code class="literal">baserel</code>. Особый интерес представляет поле <code class="literal">baserel-&gt;baserestrictinfo</code>, так как оно содержит ограничивающие условия (предложение <code class="literal">WHERE</code>), по которым можно отфильтровать выбираемые строки. (Сама FDW не обязательно должна применять эти ограничения, так как их может проверить и ядро исполнителя.) Список <code class="literal">baserel-&gt;reltarget-&gt;exprs</code> позволяет определить, какие именно столбцы требуется выбрать; но учтите, что в нём перечисляются только те столбцы, которые выдаются узлом плана <code class="structname">ForeignScan</code>, но не столбцы, которые задействованы в ограничивающих условиях и при этом не выводятся запросом.</p><p>Когда функциям планирования FDW требуется сохранять свою информацию, они могут использовать различные частные поля. Вообще, все структуры, которые FDW помещает в закрытые поля, должны выделяться функцией palloc, чтобы они автоматически освобождались при завершении планирования.</p><p>Для хранения информации, относящейся к определённой сторонней таблице, функции планирования FDW могут использовать поле <code class="literal">baserel-&gt;fdw_private</code>, которое может содержать указатель на <code class="type">void</code>. Ядро планировщика никак не касается его, кроме того, что записывает в него NULL при создании узла <code class="literal">RelOptInfo</code>. Оно полезно для передачи информации из <code class="function">GetForeignRelSize</code> в <code class="function">GetForeignPaths</code> и/или из <code class="function">GetForeignPaths</code> в <code class="function">GetForeignPlan</code> и позволяет избежать повторных вычислений.</p><p><code class="function">GetForeignPaths</code> может обозначить свойства различных путей доступа, сохранив частную информацию в поле <code class="structfield">fdw_private</code> узлов <code class="structname">ForeignPath</code>. Это поле <code class="structfield">fdw_private</code> объявлено как указатель на список (<code class="type">List</code>), но в принципе может содержать всё, что угодно, так как ядро планировщика его не касается. Однако лучше поместить в него данные, которые сможет представить функция <code class="function">nodeToString</code>, для применения средств отладки, имеющихся на сервере.</p><p><code class="function">GetForeignPlan</code> может изучить поле <code class="structfield">fdw_private</code> выбранного узла <code class="structname">ForeignPath</code> и сформировать списки <code class="structfield">fdw_exprs</code> и <code class="structfield">fdw_private</code>, которые будут помещены в узел <code class="structname">ForeignScan</code>, где они будут находиться во время выполнения запроса. Оба эти списка должны быть представлены в форме, которую способна копировать функция <code class="function">copyObject</code>. Список <code class="structfield">fdw_private</code> не имеет других ограничений и никаким образом не интерпретируется ядром сервера. Список <code class="structfield">fdw_exprs</code>, если этот указатель не NULL, предположительно содержит деревья выражений, которые должны быть вычислены при выполнении запроса. Затем планировщик обрабатывает эти деревья, чтобы они были полностью готовы к выполнению.</p><p><code class="function">GetForeignPlan</code> обычно может скопировать полученный целевой список в узел плана как есть. Передаваемый список <code class="literal">scan_clauses</code> содержит те же предложения, что и <code class="literal">baserel-&gt;baserestrictinfo</code>, но, возможно, в другом порядке для более эффективного выполнения. В простых случаях FDW может просто убрать узлы <code class="structname">RestrictInfo</code> из списка <code class="literal">scan_clauses</code> (используя функцию <code class="function">extract_actual_clauses</code>) и поместить все предложения в список ограничений узла плана, что будет означать, что эти предложения будут проверяться исполнителем во время выполнения. Более сложные FDW могут самостоятельно проверять некоторые предложения, и в этом случае такие предложения можно удалить из списка ограничений узла, чтобы исполнитель не тратил время на их перепроверку.</p><p>Например, FDW может распознавать некоторые предложения ограничений вида <em class="replaceable"><code>сторонняя_переменная</code></em> <code class="literal">=</code> <em class="replaceable"><code>подвыражение</code></em>, которые, по её представлению, могут выполняться на удалённом сервере с локально вычисленным значением <em class="replaceable"><code>подвыражения</code></em>. Собственно выявление такого предложения должно происходить в функции <code class="function">GetForeignPaths</code>, так как это влияет на оценку стоимости пути. Эта функция может включить в поле <code class="structfield">fdw_private</code> конкретного пути указатель на узел <code class="structname">RestrictInfo</code> этого предложения. Затем <code class="function">GetForeignPlan</code> удалит это предложение из <code class="literal">scan_clauses</code>, но добавит <em class="replaceable"><code>подвыражение</code></em> в <code class="structfield">fdw_exprs</code>, чтобы оно было приведено к исполняемой форме. Она также может поместить управляющую информацию в поле <code class="structfield">fdw_private</code> плана узла, которая скажет исполняющим функциям, что делать во время выполнения. Запрос, передаваемый удалённому серверу, будет содержать что-то вроде <code class="literal">WHERE <em class="replaceable"><code>сторонняя_переменная</code></em> = $1</code>, а значение параметра будет получено во время выполнения в результате вычисления дерева выражения <code class="structfield">fdw_exprs</code>.</p><p>Все предложения, удаляемые из списка условий узла плана, должны быть добавлены в <code class="literal">fdw_recheck_quals</code> или перепроверены функцией <code class="literal">RecheckForeignScan</code> для обеспечения корректного поведения на уровне изоляции <code class="literal">READ COMMITTED</code>. Когда имеет место параллельное изменение в некоторой другой таблице, задействованной в запросе, исполнителю может потребоваться убедиться в том, что все исходные условия по-прежнему выполняются для кортежа, возможно, с другим набором значений параметров. Использовать <code class="literal">fdw_recheck_quals</code> обычно проще, чем реализовывать проверки внутри <code class="literal">RecheckForeignScan</code>, но этот метод недостаточен, когда внешние соединения выносятся наружу, так как вследствие перепроверки в соединённых кортежах могут обнуляться некоторые поля, но сами кортежи не будут исключаться.</p><p>Ещё одно поле <code class="structname">ForeignScan</code>, которое могут заполнять FDW, это <code class="structfield">fdw_scan_tlist</code>, описывающее кортежи, возвращаемые обёрткой для этого узла плана. Для простых сторонних таблиц в него можно записать <code class="literal">NIL</code>, из чего будет следовать, что возвращённые кортежи имеют тип, объявленный для сторонней таблицы. Отличное от <code class="symbol">NIL</code> значение должно указывать на список целевых элементов (список структур <code class="structname">TargetEntry</code>), содержащий переменные и/или выражения, представляющие возвращаемые столбцы. Это можно использовать, например, чтобы показать, что FDW опустила некоторые столбцы, которые по её наблюдению не нужны для запроса. Также, если FDW может вычислить выражения, используемые в запросе, более эффективно, чем это можно сделать локально, она должна добавить эти выражения в список <code class="structfield">fdw_scan_tlist</code>. Заметьте, что планы соединения (полученные из путей, созданных функцией <code class="function">GetForeignJoinPaths</code>) должны всегда заполнять <code class="structfield">fdw_scan_tlist</code>, описывая набор столбцов, которые они будут возвращать.</p><p>FDW должна всегда строить минимум один путь, зависящий только от предложений ограничения таблицы. В запросах с соединением она может также построить пути, зависящие от ограничения соединения, например <em class="replaceable"><code>сторонняя_переменная</code></em> <code class="literal">=</code> <em class="replaceable"><code>локальная_переменная</code></em>. Такие предложения будут отсутствовать в <code class="literal">baserel-&gt;baserestrictinfo</code>; их нужно искать в списках соединений отношений. Путь, построенный с таким предложением, называется <span class="quote">«<span class="quote">параметризованным</span>»</span>. Другие отношения, задействованные в выбранном предложении соединения, должны связываться c этим путём соответствующим значением <code class="literal">param_info</code>; для получения этого значения используется <code class="function">get_baserel_parampathinfo</code>. В <code class="function">GetForeignPlan</code> часть <em class="replaceable"><code>локальная_переменная</code></em> предложения соединения будет добавлена в <code class="structfield">fdw_exprs</code>, и затем, во время выполнения, это будет работать так же, как и обычное предложение ограничения.</p><p>Если FDW поддерживает удалённые соединения, <code class="function">GetForeignJoinPaths</code> должна выдавать пути <code class="structname">ForeignPath</code> для потенциально удалённых соединений почти так же, как это делает <code class="function">GetForeignPaths</code> для базовых таблиц. Информация о выбранном соединении может быть передана функции <code class="function">GetForeignPlan</code> так же, как было описано выше. Однако поле <code class="structfield">baserestrictinfo</code> неприменимо к отношениям соединения; вместо этого соответствующие предложения соединения для конкретного соединения передаются в <code class="function">GetForeignJoinPaths</code> в отдельном параметре (<code class="literal">extra-&gt;restrictlist</code>).</p><p>FDW может дополнительно поддерживать прямое выполнение некоторых действий плана, находящихся выше уровня сканирований и соединений, например, группировки или агрегирования. Для реализации этой возможности FDW должна сформировать пути и вставить их в соответствующее <em class="firstterm">верхнее отношение</em>. Например, путь, представляющий удалённое агрегирование, должен вставляться в отношение <code class="literal">UPPERREL_GROUP_AGG</code> с помощью <code class="function">add_path</code>. Этот путь будет сравниваться по стоимости с локальным агрегированием, выполненным по результатам пути простого сканирования стороннего отношения (заметьте, что такой путь также должен быть сформирован, иначе во время планирования произойдёт ошибка). Если путь с удалённым агрегированием выигрывает, что, как правило, и происходит, он будет преобразован в план обычным образом, вызовом <code class="function">GetForeignPlan</code>. Такие пути рекомендуется формировать в обработчике <code class="function">GetForeignUpperPaths</code>, который вызывается для каждого верхнего отношения (то есть на каждом шаге обработки после сканирования/соединения), если все базовые отношения запроса выдаются одной обёрткой.</p><p><code class="function">PlanForeignModify</code> и другие обработчики, описанные в <a class="xref" href="fdw-callbacks.html#FDW-CALLBACKS-UPDATE" title="59.2.4. Подпрограммы FDW для изменения данных в сторонних таблицах">Подразделе 59.2.4</a>, рассчитаны на то, что стороннее отношение будет сканироваться обычным способом, а затем отдельные изменения строк будут обрабатываться локальным узлом плана <code class="literal">ModifyTable</code>. Этот подход необходим в общем случае, когда для такого изменения требуется прочитать не только сторонние, но и локальные таблицы. Однако если операция может быть целиком выполнена сторонним сервером, FDW может построить путь, представляющий эту возможность, и вставить его в верхнее отношение <code class="literal">UPPERREL_FINAL</code>, где он будет конкурировать с подходом <code class="literal">ModifyTable</code>. Этот подход также должен применяться для реализации удалённого <code class="literal">SELECT FOR UPDATE</code>, вместо обработчиков блокировки строк, описанных <a class="xref" href="fdw-callbacks.html#FDW-CALLBACKS-ROW-LOCKING" title="59.2.6. Подпрограммы FDW для блокировки строк">Подразделе 59.2.6</a>. Учтите, что путь, вставляемый в <code class="literal">UPPERREL_FINAL</code>, отвечает за реализацию <span class="emphasis"><em>всех</em></span> аспектов поведения запроса.</p><p>При планировании запросов <code class="command">UPDATE</code> или <code class="command">DELETE</code> функции <code class="function">PlanForeignModify</code> и <code class="function">PlanDirectModify</code> могут обратиться к структуре <code class="structname">RelOptInfo</code> сторонней таблицы и воспользоваться информацией <code class="literal">baserel-&gt;fdw_private</code>, записанной ранее функциями планирования сканирования. Однако при запросе <code class="command">INSERT</code> целевая таблица не сканируется, так что для неё <code class="structname">RelOptInfo</code> не заполняется. На список (<code class="structname">List</code>), возвращаемый функцией <code class="function">PlanForeignModify</code>, накладываются те же ограничения, что и на список <code class="structfield">fdw_private</code> в узле плана <code class="structname">ForeignScan</code>, то есть он должен содержать только такие структуры, которые способна копировать функция <code class="function">copyObject</code>.</p><p>Команда <code class="command">INSERT</code> с предложением <code class="literal">ON CONFLICT</code> не поддерживает указание объекта конфликта, так как уникальные ограничения или ограничения-исключения в удалённых таблицах неизвестны локально. Из этого, в свою очередь, вытекает, что предложение <code class="literal">ON CONFLICT DO UPDATE</code> не поддерживается, так как в нём это указание является обязательным.</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="fdw-helpers.html" title="59.3. Вспомогательные функции для обёрток сторонних данных">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="fdwhandler.html" title="Глава 59. Написание обёртки сторонних данных">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="fdw-row-locking.html" title="59.5. Блокировка строк в обёртках сторонних данных">След.</a></td></tr><tr><td width="40%" align="left" valign="top">59.3. Вспомогательные функции для обёрток сторонних данных </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 59.5. Блокировка строк в обёртках сторонних данных</td></tr></table></div></body></html>