<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>10.2. Операторы</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="typeconv-overview.html" title="10.1. Обзор" /><link rel="next" href="typeconv-func.html" title="10.3. Функции" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">10.2. Операторы</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="typeconv-overview.html" title="10.1. Обзор">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="typeconv.html" title="Глава 10. Преобразование типов">Наверх</a></td><th width="60%" align="center">Глава 10. Преобразование типов</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="typeconv-func.html" title="10.3. Функции">След.</a></td></tr></table><hr /></div><div class="sect1" id="TYPECONV-OPER"><div class="titlepage"><div><div><h2 class="title" style="clear: both">10.2. Операторы <a href="#TYPECONV-OPER" class="id_link">#</a></h2></div></div></div><a id="id-1.5.9.7.2" class="indexterm"></a><p>При выборе конкретного оператора, задействованного в выражении, <span class="productname">PostgreSQL</span> следует описанному ниже алгоритму. Заметьте, что на этот выбор могут неявно влиять приоритеты остальных операторов в данном выражении, так как они определяют, какие подвыражения будут аргументами операторов. Подробнее об этом рассказывается в <a class="xref" href="sql-syntax-lexical.html#SQL-PRECEDENCE" title="4.1.6. Приоритеты операторов">Подразделе 4.1.6</a>.</p><div class="procedure" id="id-1.5.9.7.4"><p class="title"><strong>Выбор оператора по типу</strong></p><ol class="procedure" type="1"><li class="step" id="OP-RESOL-SELECT"><p>Выбрать операторы для рассмотрения из системного каталога <code class="classname">pg_operator</code>. Если имя оператора не дополнено именем схемы (обычно это так), будут рассматриваться все операторы с подходящим именем и числом аргументов, видимые в текущем пути поиска (см. <a class="xref" href="ddl-schemas.html#DDL-SCHEMAS-PATH" title="5.9.3. Путь поиска схемы">Подраздел 5.9.3</a>). Если имя оператора определено полностью, в рассмотрение принимаются только операторы из указанной схемы.</p><ol type="a" class="substeps"><li class="step"><p>Если в пути поиска оказывается несколько операторов с одинаковыми типами аргументов, учитываются только те из них, которые находятся в пути раньше. Операторы с разными типами аргументов рассматриваются на равных правах вне зависимости от их положения в пути поиска.</p></li></ol></li><li class="step" id="OP-RESOL-EXACT-MATCH"><p>Проверить, нет ли среди них оператора с точно совпадающими типами аргументов. Если такой оператор есть (он может быть только одним в отобранном ранее наборе), использовать его. Отсутствие точного совпадения создаёт угрозу вызова с указанием полного имени <a href="#ftn.OP-QUALIFIED-SECURITY" class="footnote"><sup class="footnote" id="OP-QUALIFIED-SECURITY">[9]</sup></a> (нетипичным) любого оператора, который может оказаться в схеме, где могут создавать объекты недоверенные пользователи. В таких ситуациях приведите типы аргументов для получения точного совпадения.</p><ol type="a" class="substeps"><li class="step" id="OP-RESOL-EXACT-UNKNOWN"><p>Если один аргумент при вызове бинарного оператора имеет тип <code class="type">unknown</code>, для данной проверки предполагается, что он имеет тот же тип, что и второй его аргумент. При вызове бинарного оператора с двумя аргументами <code class="type">unknown</code> или префиксного с одним <code class="type">unknown</code> оператор не будет выбран на этом шаге.</p></li><li class="step" id="OP-RESOL-EXACT-DOMAIN"><p>Если один аргумент при вызове бинарного оператора имеет тип <code class="type">unknown</code>, а другой — домен, проверить, есть ли оператор, принимающий базовый тип домена с обеих сторон; если таковой находится, использовать его.</p></li></ol></li><li class="step" id="OP-RESOL-BEST-MATCH"><p>Найти самый подходящий.</p><ol type="a" class="substeps"><li class="step"><p>Отбросить кандидатов, для которых входные типы не совпадают и не могут быть преобразованы (неявным образом) так, чтобы они совпали. В данном случае считается, что константы типа <code class="type">unknown</code> можно преобразовать во что угодно. Если остаётся только один кандидат, использовать его, в противном случае перейти к следующему шагу.</p></li><li class="step"><p>Если один из аргументов имеет тип домен, далее считать его типом базовый тип домена. Благодаря этому при поиске неоднозначно заданного оператора домены будут подобны свои базовым типам.</p></li><li class="step"><p>Просмотреть всех кандидатов и оставить только тех, для которых точно совпадают как можно больше типов аргументов. Оставить всех кандидатов, если точных совпадений нет. Если остаётся только один кандидат, использовать его, в противном случае перейти к следующему шагу.</p></li><li class="step"><p>Просмотреть всех кандидатов и оставить только тех, которые принимают предпочитаемые типы (из категории типов входных значений) в наибольшем числе позиций, где требуется преобразование типов. Оставить всех кандидатов, если ни один не принимает предпочитаемые типы. Если остаётся только один кандидат, использовать его, в противном случае перейти к следующему шагу.</p></li><li class="step"><p>Если какие-либо значения имеют тип <code class="type">unknown</code>, проверить категории типов, принимаемых в данных позициях аргументов оставшимися кандидатами. Для каждой позиции выбрать категорию <code class="type">string</code>, если какой-либо кандидат принимает эту категорию. (Эта склонность к строкам объясняется тем, что константа типа unknown выглядит как строка.) Если эта категория не подходит, но все оставшиеся кандидаты принимают одну категорию, выбрать её; в противном случае констатировать неудачу — сделать правильный выбор без дополнительных подсказок нельзя. Затем отбросить кандидатов, которые не принимают типы выбранной категории. Далее, если какой-либо кандидат принимает предпочитаемый тип из этой категории, отбросить кандидатов, принимающих другие, не предпочитаемые типы для данного аргумента. Оставить всех кандидатов, если эти проверки не прошёл ни один. Если остаётся только один кандидат, использовать его, в противном случае перейти к следующему шагу.</p></li><li class="step" id="OP-RESOL-LAST-UNKNOWN"><p>Если в списке аргументов есть аргументы и типа <code class="type">unknown</code>, и известного типа, и этот известный тип один для всех аргументов, предположить, что аргументы типа <code class="type">unknown</code> также имеют этот тип, и проверить, какие кандидаты могут принимать этот тип в позиции аргумента <code class="type">unknown</code>. Если остаётся только один кандидат, использовать его, в противном случае констатировать неудачу.</p></li></ol></li></ol></div><p>Ниже это проиллюстрировано на примерах.</p><div class="example" id="id-1.5.9.7.6"><p class="title"><strong>Пример 10.1. Разрешение типа для оператора квадратного корня</strong></p><div class="example-contents"><p>В стандартном каталоге определён только один оператор квадратного корня (префиксный <code class="literal">|/</code>) и он принимает аргумент типа <code class="type">double precision</code>. При просмотре следующего выражения его аргументу изначально назначается тип <code class="type">integer</code>: </p><pre class="screen">
SELECT |/ 40 AS "square root of 40";
 square root of 40
-------------------
 6.324555320336759
(1 row)
</pre><p> Поэтому анализатор преобразует тип этого операнда и запрос становится равносильным такому: </p><pre class="screen">
SELECT |/ CAST(40 AS double precision) AS "square root of 40";
</pre></div></div><br class="example-break" /><div class="example" id="id-1.5.9.7.7"><p class="title"><strong>Пример 10.2. Разрешение оператора конкатенации строк</strong></p><div class="example-contents"><p>Синтаксис текстовых строк используется как для записи строковых типов, так и для сложных типов расширений. Если тип не указан явно, такие строки сопоставляются по тому же алгоритму с наиболее подходящими операторами.</p><p>Пример с одним неопределённым аргументом: </p><pre class="screen">
SELECT text 'abc' || 'def' AS "text and unknown";

 text and unknown
------------------
 abcdef
(1 row)
</pre><p>В этом случае анализатор смотрит, есть ли оператор, у которого оба аргумента имеют тип <code class="type">text</code>. Такой оператор находится, поэтому предполагается, что второй аргумент следует воспринимать как аргумент типа <code class="type">text</code>.</p><p>Конкатенация двух значений неопределённых типов: </p><pre class="screen">
SELECT 'abc' || 'def' AS "unspecified";

 unspecified
-------------
 abcdef
(1 row)
</pre><p>В данном случае нет подсказки для выбора типа, так как в данном запросе никакие типы не указаны. Поэтому анализатор просматривает все возможные операторы и находит в них кандидатов, принимающих аргументы категорий string и bit-string. Так как категория string является предпочтительной, выбирается она, а затем для разрешения типа не типизированной константы выбирается предпочтительный тип этой категории, <code class="type">text</code>.</p></div></div><br class="example-break" /><div class="example" id="id-1.5.9.7.8"><p class="title"><strong>Пример 10.3. Разрешение оператора абсолютного значения и отрицания</strong></p><div class="example-contents"><p>В каталоге операторов <span class="productname">PostgreSQL</span> для префиксного оператора <code class="literal">@</code> есть несколько записей, описывающих операции получения абсолютного значения для различных числовых типов данных. Одна из записей соответствует типу <code class="type">float8</code>, предпочтительного в категории числовых типов. Таким образом, столкнувшись со значением типа <code class="type">unknown</code>, <span class="productname">PostgreSQL</span> выберет эту запись: </p><pre class="screen">
SELECT @ '-4.5' AS "abs";
 abs
-----
 4.5
(1 row)
</pre><p> Здесь система неявно привела константу неизвестного типа к типу <code class="type">float8</code>, прежде чем применять выбранный оператор. Можно убедиться в том, что выбран именно тип <code class="type">float8</code>, а не какой-то другой: </p><pre class="screen">
SELECT @ '-4.5e500' AS "abs";

ОШИБКА:  "-4.5e500" вне диапазона для типа double precision
</pre><p>С другой стороны, префиксный оператор <code class="literal">~</code> (побитовое отрицание) определён только для целочисленных типов данных, но не для <code class="type">float8</code>. Поэтому, если попытаться выполнить похожий запрос с <code class="literal">~</code>, мы получаем: </p><pre class="screen">
SELECT ~ '20' AS "negation";

ОШИБКА: оператор не уникален: ~ "unknown"
ПОДСКАЗКА: Не удалось выбрать лучшую кандидатуру оператора. Возможно, вам следует
добавить явные преобразования типов.
</pre><p> Это происходит оттого, что система не может решить, какой оператор предпочесть из нескольких возможных вариантов <code class="literal">~</code>. Мы можем облегчить её задачу, добавив явное преобразование: </p><pre class="screen">
SELECT ~ CAST('20' AS int8) AS "negation";

 negation
----------
      -21
(1 row)
</pre></div></div><br class="example-break" /><div class="example" id="id-1.5.9.7.9"><p class="title"><strong>Пример 10.4. Разрешение оператора включения в массив</strong></p><div class="example-contents"><p>Ещё один пример разрешения оператора с одним аргументом известного типа и другим неизвестного: </p><pre class="screen">
SELECT array[1,2] &lt;@ '{1,2,3}' as "is subset";

 is subset
-----------
 t
(1 row)
</pre><p> В каталоге операторов <span class="productname">PostgreSQL</span> есть несколько записей для инфиксного оператора <code class="literal">&lt;@</code>, но только два из них могут принять целочисленный массива слева: оператор включения массива (<code class="type">anyarray</code><code class="literal">&lt;@</code><code class="type">anyarray</code>) и оператор включения диапазона (<code class="type">anyelement</code><code class="literal">&lt;@</code><code class="type">anyrange</code>). Так как ни один из этих полиморфных псевдотипов (см. <a class="xref" href="datatype-pseudo.html" title="8.21. Псевдотипы">Раздел 8.21</a>) не считается предпочтительным, анализатор не может избавиться от неоднозначности на данном этапе. Однако в <a class="xref" href="typeconv-oper.html#OP-RESOL-LAST-UNKNOWN" title="Шаг 3.f">Шаг 3.f</a> говорится, что константа неизвестного типа должна рассматриваться как значение типа другого аргумента, в данном случае это целочисленный массив. После этого подходящим считается только один из двух операторов, так что выбирается оператор с целочисленными массивами. (Если бы был выбран оператор включения диапазона, мы получили бы ошибку, так как значение в строке не соответствует формату значений диапазона.)</p></div></div><br class="example-break" /><div class="example" id="id-1.5.9.7.10"><p class="title"><strong>Пример 10.5. Нестандартный оператор с доменом</strong></p><div class="example-contents"><p>Иногда пользователи пытаются ввести операторы, применимые только к определённому домену. Это возможно, но вовсе не так полезно, как может показаться, ведь правила разрешения операторов применяются к базовому типу домена. Взгляните на этот пример: </p><pre class="screen">
CREATE DOMAIN mytext AS text CHECK(...);
CREATE FUNCTION mytext_eq_text (mytext, text) RETURNS boolean AS ...;
CREATE OPERATOR = (procedure=mytext_eq_text, leftarg=mytext, rightarg=text);
CREATE TABLE mytable (val mytext);

SELECT * FROM mytable WHERE val = 'foo';
</pre><p> В этом запросе не будет использоваться нововведённый оператор. При разборе запроса сначала будет проверено, есть ли оператор <code class="type">mytext</code> <code class="literal">=</code> <code class="type">mytext</code> (см. <a class="xref" href="typeconv-oper.html#OP-RESOL-EXACT-UNKNOWN" title="Шаг 2.a">Шаг 2.a</a>), но это не так; затем будет рассмотрен базовый тип домена (<code class="type">text</code>) и проверено наличие оператора <code class="type">text</code> <code class="literal">=</code> <code class="type">text</code> (см. <a class="xref" href="typeconv-oper.html#OP-RESOL-EXACT-DOMAIN" title="Шаг 2.b">Шаг 2.b</a>), и таковой действительно есть; в итоге строковое значение типа <code class="type">unknown</code> будет воспринято как <code class="type">text</code> и будет применён оператор <code class="type">text</code> <code class="literal">=</code> <code class="type">text</code>. Единственный вариант задействовать нововведённый оператор — добавить явное приведение: </p><pre class="screen">
SELECT * FROM mytable WHERE val = text 'foo';
</pre><p> так, чтобы оператор <code class="type">mytext</code> <code class="literal">=</code> <code class="type">text</code> был найден сразу, согласно правилу точного совпадения. Если дело доходит до правил наибольшего соответствия, они активно дискредитируют операторы доменных типов. Если бы они этого не делали, с таким оператором возникало бы слишком много ошибок разрешения операторов, потому что правила приведения всегда считают домен приводимым к базовому типу и наоборот, так что доменный оператор применялся бы во всех случаях, где применяется одноимённый оператор с базовым типом.</p></div></div><br class="example-break" /><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.OP-QUALIFIED-SECURITY" class="footnote"><p><a href="#OP-QUALIFIED-SECURITY" class="para"><sup class="para">[9] </sup></a>Эта угроза неактуальна для имён без схемы, так как путь поиска, содержащий схемы, в которых недоверенные пользователи могут создавать объекты, не соответствует <a class="link" href="ddl-schemas.html#DDL-SCHEMAS-PATTERNS" title="5.9.6. Шаблоны использования">шаблону безопасного использования схем</a>.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="typeconv-overview.html" title="10.1. Обзор">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="typeconv.html" title="Глава 10. Преобразование типов">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="typeconv-func.html" title="10.3. Функции">След.</a></td></tr><tr><td width="40%" align="left" valign="top">10.1. Обзор </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 10.3. Функции</td></tr></table></div></body></html>