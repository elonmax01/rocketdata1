<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>73.6. Компоновка страницы базы данных</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="storage-init.html" title="73.5. Слой инициализации" /><link rel="next" href="storage-hot.html" title="73.7. Кортежи только в куче (Heap-Only Tuples, HOT)" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">73.6. Компоновка страницы базы данных</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="storage-init.html" title="73.5. Слой инициализации">Пред.</a> </td><td width="10%" align="left"><a accesskey="u" href="storage.html" title="Глава 73. Физическое хранение базы данных">Наверх</a></td><th width="60%" align="center">Глава 73. Физическое хранение базы данных</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="10%" align="right"> <a accesskey="n" href="storage-hot.html" title="73.7. Кортежи только в куче (Heap-Only Tuples, HOT)">След.</a></td></tr></table><hr /></div><div class="sect1" id="STORAGE-PAGE-LAYOUT"><div class="titlepage"><div><div><h2 class="title" style="clear: both">73.6. Компоновка страницы базы данных <a href="#STORAGE-PAGE-LAYOUT" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="storage-page-layout.html#STORAGE-TUPLE-LAYOUT">73.6.1. Компоновка строки таблицы</a></span></dt></dl></div><p>В данном разделе рассматривается формат страницы, используемый в таблицах и индексах <span class="productname">PostgreSQL</span>.<a href="#ftn.id-1.10.24.8.2.2" class="footnote"><sup class="footnote" id="id-1.10.24.8.2.2">[17]</sup></a> Последовательности и таблицы <acronym class="acronym">TOAST</acronym> форматируются как обычные таблицы.</p><p>В дальнейшем подразумевается, что <em class="firstterm">байт</em> содержит 8 бит. В дополнение, термин <em class="firstterm">элемент</em> относится к индивидуальному значению данных, которое хранится на странице. В таблице элемент — это строка; в индексе — элемент индекса.</p><p>Каждая таблица и индекс хранятся как массив <em class="firstterm">страниц</em> фиксированного размера (обычно 8 kB, хотя можно выбрать другой размер страницы при компиляции сервера). В таблице все страницы логически эквивалентны, поэтому конкретный элемент (строка) может храниться на любой странице. В индексах первая страница обычно резервируется как <em class="firstterm">метастраница</em>, хранящая контрольную информацию, а внутри индекса могут быть разные типы страниц, в зависимости от метода доступа индекса.</p><p><a class="xref" href="storage-page-layout.html#PAGE-TABLE" title="Таблица 73.2. Общая компоновка страницы">Таблица 73.2</a> показывает общую компоновку страницы. Каждая страница имеет пять частей.</p><div class="table" id="PAGE-TABLE"><p class="title"><strong>Таблица 73.2. Общая компоновка страницы</strong></p><div class="table-contents"><table class="table" summary="Общая компоновка страницы" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Элемент</th><th>Описание</th></tr></thead><tbody><tr><td>Данные заголовка страницы</td><td>Длина — 24 байта. Содержит общую информацию о странице, включая указатели свободного пространства.</td></tr><tr><td>Данные идентификаторов элементов</td><td>Массив идентификаторов, указывающих на фактические элементы. Каждый идентификатор представляет собой пару «смещение, длина» и занимает 4 байта.</td></tr><tr><td>Свободное пространство</td><td>Незанятое пространство. Новые идентификаторы элементов размещаются с начала этой области, сами новые элементы — с конца.</td></tr><tr><td>Элементы</td><td>Сами элементы данных как таковые.</td></tr><tr><td>Специальное пространство</td><td>Специфические данные метода доступа. Для различных методов хранятся различные данные. Для обычных таблиц таких данных нет.</td></tr></tbody></table></div></div><br class="table-break" /><p>Первые 24 байта каждой страницы образуют заголовок страницы (<code class="structname">PageHeaderData</code>). Его формат подробно описан в <a class="xref" href="storage-page-layout.html#PAGEHEADERDATA-TABLE" title="Таблица 73.3. Данные заголовка страницы (PageHeaderData)">Таблице 73.3</a>. В первом поле отслеживается самая последняя запись в WAL, связанная с этой страницей. Второе поле содержит контрольную сумму страницы, если включён режим <a class="xref" href="app-initdb.html#APP-INITDB-DATA-CHECKSUMS">Контрольные суммы данных</a>. Затем идёт двухбайтовое поле, содержащее биты флагов. За ним следуют три двухбайтовых целочисленных поля (<code class="structfield">pd_lower</code>, <code class="structfield">pd_upper</code> и <code class="structfield">pd_special</code>). Они содержат смещения в байтах от начала страницы до начала незанятого пространства, до конца незанятого пространства и до начала специального пространства. В следующих 2 байтах заголовка страницы, в поле <code class="structfield">pd_pagesize_version</code>, хранится размер страницы и индикатор версии. Начиная с <span class="productname">PostgreSQL</span> 8.3, используется версия 4; в <span class="productname">PostgreSQL</span> 8.1 и 8.2 использовалась версия 3; в <span class="productname">PostgreSQL</span> 8.0 — версия 2; в <span class="productname">PostgreSQL</span> 7.3 и 7.4 — версия 1; в предыдущих выпусках — версия 0. (Основная структура страницы и формат заголовка почти во всех этих версиях одни и те же, но структура заголовка строк в куче изменялась.) Размер страницы присутствует в основном только для перекрёстной проверки; возможность использовать в одной инсталляции разные размеры страниц не поддерживается. Последнее поле подсказывает, насколько вероятна возможность получить выигрыш, произведя очистку страницы: оно отслеживает самый старый XMAX на странице, не подвергавшийся очистке.</p><div class="table" id="PAGEHEADERDATA-TABLE"><p class="title"><strong>Таблица 73.3. Данные заголовка страницы (PageHeaderData)</strong></p><div class="table-contents"><table class="table" summary="Данные заголовка страницы (PageHeaderData)" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Поле</th><th>Тип</th><th>Длина</th><th>Описание</th></tr></thead><tbody><tr><td>pd_lsn</td><td>PageXLogRecPtr</td><td>8 байт</td><td>LSN: Следующий байт после последнего байта записи WAL для последнего изменения на этой странице</td></tr><tr><td>pd_checksum</td><td>uint16</td><td>2 байта</td><td>Контрольная сумма страницы</td></tr><tr><td>pd_flags</td><td>uint16</td><td>2 байта</td><td>Биты признаков</td></tr><tr><td>pd_lower</td><td>LocationIndex</td><td>2 байта</td><td>Смещение до начала свободного пространства</td></tr><tr><td>pd_upper</td><td>LocationIndex</td><td>2 байта</td><td>Смещение до конца свободного пространства</td></tr><tr><td>pd_special</td><td>LocationIndex</td><td>2 байта</td><td>Смещение до начала специального пространства</td></tr><tr><td>pd_pagesize_version</td><td>uint16</td><td>2 байта</td><td>Информация о размере страницы и номере версии компоновки</td></tr><tr><td>pd_prune_xid</td><td>TransactionId</td><td>4 байта</td><td>Самый старый неочищенный идентификатор XMAX на странице или ноль при отсутствии такового</td></tr></tbody></table></div></div><br class="table-break" /><p>Всю подробную информацию можно найти в <code class="filename">src/include/storage/bufpage.h</code>.</p><p>За заголовком страницы следуют идентификаторы элемента (<code class="type">ItemIdData</code>), каждому из которых требуется 4 байта. Идентификатор элемента содержит байтовое смещение до начала элемента, его длину в байтах и несколько битов атрибутов, которые влияют на его интерпретацию. Новые идентификаторы элементов размещаются по мере необходимости от начала свободного пространства. Количество имеющихся идентификаторов элементов можно определить через значение <code class="structfield">pd_lower</code>, которое увеличивается при добавлении нового идентификатора. Поскольку идентификатор элемента никогда не перемещается до тех пор, пока он не освобождается, его индекс можно использовать в течение длительного периода времени, чтобы ссылаться на элемент, даже когда сам элемент перемещается по странице для уплотнения свободного пространства. Фактически каждый указатель на элемент (<code class="type">ItemPointer</code>, также известный как <code class="type">CTID</code>), созданный <span class="productname">PostgreSQL</span>, состоит из номера страницы и индекса идентификатора элемента.</p><p>Сами элементы хранятся в пространстве, выделяемом в направлении от конца к началу незанятого пространства. Точная структура меняется в зависимости от того, каким будет содержимое таблицы. Как таблицы, так и последовательности используют структуру под названием <code class="type">HeapTupleHeaderData</code>, которая описывается ниже.</p><p>Последний раздел является <span class="quote">«<span class="quote">особым разделом</span>»</span>, который может содержать всё, что необходимо методу доступа для хранения. Например, индексы-B-деревья хранят ссылки на страницы слева и справа, равно как и некоторые другие данные, соответствующие структуре индекса. Обычные таблицы не используют особый раздел вовсе (что указывается установкой значения <code class="structfield">pd_special</code> равным размеру страницы).</p><p><a class="xref" href="storage-page-layout.html#STORAGE-PAGE-LAYOUT-FIGURE" title="Рисунок 73.1. Компоновка страницы">Рисунок 73.1</a> показывает, как эти компоненты размещаются в странице.</p><div class="figure" id="STORAGE-PAGE-LAYOUT-FIGURE"><p class="title"><strong>Рисунок 73.1. Компоновка страницы</strong></p><div class="figure-contents"><div class="mediaobject"><object type="image/svg+xml" data="pagelayout.svg" width="100%"></object></div></div></div><br class="figure-break" /><div class="sect2" id="STORAGE-TUPLE-LAYOUT"><div class="titlepage"><div><div><h3 class="title">73.6.1. Компоновка строки таблицы <a href="#STORAGE-TUPLE-LAYOUT" class="id_link">#</a></h3></div></div></div><p>Все строки таблицы имеют одинаковую структуру. Они включают заголовок фиксированного размера (занимающий 23 байта на большинстве машин), за которым следует необязательная битовая карта пустых значений, необязательное поле идентификатора объекта и данные пользователя. Подробное описание заголовка представлено в <a class="xref" href="storage-page-layout.html#HEAPTUPLEHEADERDATA-TABLE" title="Таблица 73.4. Данные заголовка строки таблицы (HeapTupleHeaderData)">Таблице 73.4</a>. Актуальные пользовательские данные (столбцы строки) начинаются после смещения, заданного в <code class="structfield">t_hoff</code>, которое должно всегда быть кратным величине MAXALIGN для платформы. Битовая карта пустых значений имеется тогда, когда бит <em class="firstterm">HEAP_HASNULL</em> установлен в значении <code class="structfield">t_infomask</code>. В случае наличия она начинается сразу после фиксированного заголовка и занимает столько байтов, сколько требуется для размещения битов по количеству столбцов (т. е. число битов равно количеству атрибутов, определяемому полем <code class="structfield">t_infomask2</code>). В этом списке битов установленный бит означает непустое значение, а сброшенный соответствует пустому значению. Когда битовая карта отсутствует, все столбцы считаются непустыми. Идентификатор объекта присутствует, если только в значении <code class="structfield">t_infomask</code> установлен бит <em class="firstterm">HEAP_HASOID_OLD</em>. Если он есть, он расположен сразу перед началом <code class="structfield">t_hoff</code>. Любое заполнение, необходимое для того, чтобы сделать <code class="structfield">t_hoff</code> кратным MAXALIGN, будет добавлено между битовой картой пустых значений и идентификатором объекта. (Это в свою очередь гарантирует, что идентификатор объекта будет правильно выровнен.)</p><div class="table" id="HEAPTUPLEHEADERDATA-TABLE"><p class="title"><strong>Таблица 73.4. Данные заголовка строки таблицы (HeapTupleHeaderData)</strong></p><div class="table-contents"><table class="table" summary="Данные заголовка строки таблицы (HeapTupleHeaderData)" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Поле</th><th>Тип</th><th>Длина</th><th>Описание</th></tr></thead><tbody><tr><td>t_xmin</td><td>TransactionId</td><td>4 байта</td><td>значение XID вставки</td></tr><tr><td>t_xmax</td><td>TransactionId</td><td>4 байта</td><td>значение XID удаления</td></tr><tr><td>t_cid</td><td>CommandId</td><td>4 байта</td><td>значение CID для вставки и/или удаления (пересекается с t_xvac)</td></tr><tr><td>t_xvac</td><td>TransactionId</td><td>4 байта</td><td>XID для операции VACUUM, которая перемещает версию строки</td></tr><tr><td>t_ctid</td><td>ItemPointerData</td><td>6 байт</td><td>текущее значение TID этой или более новой версии строки</td></tr><tr><td>t_infomask2</td><td>uint16</td><td>2 байта</td><td>количество атрибутов плюс различные биты флагов</td></tr><tr><td>t_infomask</td><td>uint16</td><td>2 байта</td><td>различные биты флагов</td></tr><tr><td>t_hoff</td><td>uint8</td><td>1 байт</td><td>отступ до пользовательских данных</td></tr></tbody></table></div></div><br class="table-break" /><p>Всю подробную информацию можно найти в <code class="filename">src/include/access/htup_details.h</code>.</p><p>Интерпретировать текущие данные можно только с использованием информации, полученной из других таблиц, в основном из <code class="structname">pg_attribute</code>. Ключевыми значениями, необходимыми для определения расположения полей, являются <code class="structfield">attlen</code> и <code class="structfield">attalign</code>. Не существует способа непосредственного получения заданного атрибута, кроме случая, когда имеются только поля фиксированной длины и при этом нет значений NULL. Все эти особенности учитываются в функциях <em class="firstterm">heap_getattr</em>, <em class="firstterm">fastgetattr</em> и <em class="firstterm">heap_getsysattr</em>.</p><p>Чтобы прочитать данные, необходимо просмотреть каждый атрибут по очереди. В первую очередь нужно проверить, является ли значение поля пустым согласно битовой карте пустых значений. Если это так, можно переходить к следующему полю. Затем следует убедиться, что выравнивание является верным. Если это поле фиксированной ширины, берутся просто все его байты. Если это поле переменной длины (attlen = -1), всё несколько сложнее. Все типы данных с переменной длиной имеют общую структуру заголовка <code class="type">struct varlena</code>, которая включает общую длину сохранённого значения и некоторые биты флагов. В зависимости от установленных флагов, данные могут храниться либо локально, либо в таблице <acronym class="acronym">TOAST</acronym>. Также, возможно сжатие данных (см. <a class="xref" href="storage-toast.html" title="73.2. TOAST">Раздел 73.2</a>).</p></div><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.id-1.10.24.8.2.2" class="footnote"><p><a href="#id-1.10.24.8.2.2" class="para"><sup class="para">[17] </sup></a>На самом деле этот формат страниц не является обязательным ни для табличных, ни для индексных методов доступа. Его всегда использует табличный метод <code class="literal">heap</code> и все существующие индексные методы, но в метастраницах индексов данные обычно компонуются по другим правилам.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="storage-init.html" title="73.5. Слой инициализации">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="storage.html" title="Глава 73. Физическое хранение базы данных">Наверх</a></td><td width="40%" align="right"> <a accesskey="n" href="storage-hot.html" title="73.7. Кортежи только в куче (Heap-Only Tuples, HOT)">След.</a></td></tr><tr><td width="40%" align="left" valign="top">73.5. Слой инициализации </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="Документация к PostgreSQL 16.3">Начало</a></td><td width="40%" align="right" valign="top"> 73.7. Кортежи только в куче (Heap-Only Tuples, <acronym class="acronym">HOT</acronym>)</td></tr></table></div></body></html>